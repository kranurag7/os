#ifndef __VMLINUX_H__
#define __VMLINUX_H__

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
#endif

#ifndef __ksym
#define __ksym __attribute__((section(".ksyms")))
#endif

#ifndef __weak
#define __weak __attribute__((weak))
#endif

enum {
	ACPI_BUTTON_LID_INIT_IGNORE = 0,
	ACPI_BUTTON_LID_INIT_OPEN = 1,
	ACPI_BUTTON_LID_INIT_METHOD = 2,
	ACPI_BUTTON_LID_INIT_DISABLED = 3,
};

enum {
	ACPI_GENL_ATTR_UNSPEC = 0,
	ACPI_GENL_ATTR_EVENT = 1,
	__ACPI_GENL_ATTR_MAX = 2,
};

enum {
	ACPI_GENL_CMD_UNSPEC = 0,
	ACPI_GENL_CMD_EVENT = 1,
	__ACPI_GENL_CMD_MAX = 2,
};

enum {
	ACPI_REFCLASS_LOCAL = 0,
	ACPI_REFCLASS_ARG = 1,
	ACPI_REFCLASS_REFOF = 2,
	ACPI_REFCLASS_INDEX = 3,
	ACPI_REFCLASS_TABLE = 4,
	ACPI_REFCLASS_NAME = 5,
	ACPI_REFCLASS_DEBUG = 6,
	ACPI_REFCLASS_MAX = 6,
};

enum {
	ACPI_RSC_INITGET = 0,
	ACPI_RSC_INITSET = 1,
	ACPI_RSC_FLAGINIT = 2,
	ACPI_RSC_1BITFLAG = 3,
	ACPI_RSC_2BITFLAG = 4,
	ACPI_RSC_3BITFLAG = 5,
	ACPI_RSC_6BITFLAG = 6,
	ACPI_RSC_ADDRESS = 7,
	ACPI_RSC_BITMASK = 8,
	ACPI_RSC_BITMASK16 = 9,
	ACPI_RSC_COUNT = 10,
	ACPI_RSC_COUNT16 = 11,
	ACPI_RSC_COUNT_GPIO_PIN = 12,
	ACPI_RSC_COUNT_GPIO_RES = 13,
	ACPI_RSC_COUNT_GPIO_VEN = 14,
	ACPI_RSC_COUNT_SERIAL_RES = 15,
	ACPI_RSC_COUNT_SERIAL_VEN = 16,
	ACPI_RSC_DATA8 = 17,
	ACPI_RSC_EXIT_EQ = 18,
	ACPI_RSC_EXIT_LE = 19,
	ACPI_RSC_EXIT_NE = 20,
	ACPI_RSC_LENGTH = 21,
	ACPI_RSC_MOVE_GPIO_PIN = 22,
	ACPI_RSC_MOVE_GPIO_RES = 23,
	ACPI_RSC_MOVE_SERIAL_RES = 24,
	ACPI_RSC_MOVE_SERIAL_VEN = 25,
	ACPI_RSC_MOVE8 = 26,
	ACPI_RSC_MOVE16 = 27,
	ACPI_RSC_MOVE32 = 28,
	ACPI_RSC_MOVE64 = 29,
	ACPI_RSC_SET8 = 30,
	ACPI_RSC_SOURCE = 31,
	ACPI_RSC_SOURCEX = 32,
};

enum {
	ACTION_FAIL = 0,
	ACTION_REPREP = 1,
	ACTION_DELAYED_REPREP = 2,
	ACTION_RETRY = 3,
	ACTION_DELAYED_RETRY = 4,
};

enum {
	AFFINITY = 0,
	AFFINITY_LIST = 1,
	EFFECTIVE = 2,
	EFFECTIVE_LIST = 3,
};

enum {
	AML_FIELD_ACCESS_ANY = 0,
	AML_FIELD_ACCESS_BYTE = 1,
	AML_FIELD_ACCESS_WORD = 2,
	AML_FIELD_ACCESS_DWORD = 3,
	AML_FIELD_ACCESS_QWORD = 4,
	AML_FIELD_ACCESS_BUFFER = 5,
};

enum {
	AML_FIELD_ATTRIB_QUICK = 2,
	AML_FIELD_ATTRIB_SEND_RECEIVE = 4,
	AML_FIELD_ATTRIB_BYTE = 6,
	AML_FIELD_ATTRIB_WORD = 8,
	AML_FIELD_ATTRIB_BLOCK = 10,
	AML_FIELD_ATTRIB_BYTES = 11,
	AML_FIELD_ATTRIB_PROCESS_CALL = 12,
	AML_FIELD_ATTRIB_BLOCK_PROCESS_CALL = 13,
	AML_FIELD_ATTRIB_RAW_BYTES = 14,
	AML_FIELD_ATTRIB_RAW_PROCESS_BYTES = 15,
};

enum {
	AML_FIELD_UPDATE_PRESERVE = 0,
	AML_FIELD_UPDATE_WRITE_AS_ONES = 32,
	AML_FIELD_UPDATE_WRITE_AS_ZEROS = 64,
};

enum {
	ARCH_LBR_BR_TYPE_JCC = 0,
	ARCH_LBR_BR_TYPE_NEAR_IND_JMP = 1,
	ARCH_LBR_BR_TYPE_NEAR_REL_JMP = 2,
	ARCH_LBR_BR_TYPE_NEAR_IND_CALL = 3,
	ARCH_LBR_BR_TYPE_NEAR_REL_CALL = 4,
	ARCH_LBR_BR_TYPE_NEAR_RET = 5,
	ARCH_LBR_BR_TYPE_KNOWN_MAX = 5,
	ARCH_LBR_BR_TYPE_MAP_MAX = 16,
};

enum {
	ASCII_NULL = 0,
	ASCII_BELL = 7,
	ASCII_BACKSPACE = 8,
	ASCII_IGNORE_FIRST = 8,
	ASCII_HTAB = 9,
	ASCII_LINEFEED = 10,
	ASCII_VTAB = 11,
	ASCII_FORMFEED = 12,
	ASCII_CAR_RET = 13,
	ASCII_IGNORE_LAST = 13,
	ASCII_SHIFTOUT = 14,
	ASCII_SHIFTIN = 15,
	ASCII_CANCEL = 24,
	ASCII_SUBSTITUTE = 26,
	ASCII_ESCAPE = 27,
	ASCII_CSI_IGNORE_FIRST = 32,
	ASCII_CSI_IGNORE_LAST = 63,
	ASCII_DEL = 127,
	ASCII_EXT_CSI = 155,
};

enum {
	ATA_MAX_DEVICES = 2,
	ATA_MAX_PRD = 256,
	ATA_SECT_SIZE = 512,
	ATA_MAX_SECTORS_128 = 128,
	ATA_MAX_SECTORS = 256,
	ATA_MAX_SECTORS_1024 = 1024,
	ATA_MAX_SECTORS_LBA48 = 65535,
	ATA_MAX_SECTORS_TAPE = 65535,
	ATA_MAX_TRIM_RNUM = 64,
	ATA_ID_WORDS = 256,
	ATA_ID_CONFIG = 0,
	ATA_ID_CYLS = 1,
	ATA_ID_HEADS = 3,
	ATA_ID_SECTORS = 6,
	ATA_ID_SERNO = 10,
	ATA_ID_BUF_SIZE = 21,
	ATA_ID_FW_REV = 23,
	ATA_ID_PROD = 27,
	ATA_ID_MAX_MULTSECT = 47,
	ATA_ID_DWORD_IO = 48,
	ATA_ID_TRUSTED = 48,
	ATA_ID_CAPABILITY = 49,
	ATA_ID_OLD_PIO_MODES = 51,
	ATA_ID_OLD_DMA_MODES = 52,
	ATA_ID_FIELD_VALID = 53,
	ATA_ID_CUR_CYLS = 54,
	ATA_ID_CUR_HEADS = 55,
	ATA_ID_CUR_SECTORS = 56,
	ATA_ID_MULTSECT = 59,
	ATA_ID_LBA_CAPACITY = 60,
	ATA_ID_SWDMA_MODES = 62,
	ATA_ID_MWDMA_MODES = 63,
	ATA_ID_PIO_MODES = 64,
	ATA_ID_EIDE_DMA_MIN = 65,
	ATA_ID_EIDE_DMA_TIME = 66,
	ATA_ID_EIDE_PIO = 67,
	ATA_ID_EIDE_PIO_IORDY = 68,
	ATA_ID_ADDITIONAL_SUPP = 69,
	ATA_ID_QUEUE_DEPTH = 75,
	ATA_ID_SATA_CAPABILITY = 76,
	ATA_ID_SATA_CAPABILITY_2 = 77,
	ATA_ID_FEATURE_SUPP = 78,
	ATA_ID_MAJOR_VER = 80,
	ATA_ID_COMMAND_SET_1 = 82,
	ATA_ID_COMMAND_SET_2 = 83,
	ATA_ID_CFSSE = 84,
	ATA_ID_CFS_ENABLE_1 = 85,
	ATA_ID_CFS_ENABLE_2 = 86,
	ATA_ID_CSF_DEFAULT = 87,
	ATA_ID_UDMA_MODES = 88,
	ATA_ID_HW_CONFIG = 93,
	ATA_ID_SPG = 98,
	ATA_ID_LBA_CAPACITY_2 = 100,
	ATA_ID_SECTOR_SIZE = 106,
	ATA_ID_WWN = 108,
	ATA_ID_LOGICAL_SECTOR_SIZE = 117,
	ATA_ID_COMMAND_SET_3 = 119,
	ATA_ID_COMMAND_SET_4 = 120,
	ATA_ID_LAST_LUN = 126,
	ATA_ID_DLF = 128,
	ATA_ID_CSFO = 129,
	ATA_ID_CFA_POWER = 160,
	ATA_ID_CFA_KEY_MGMT = 162,
	ATA_ID_CFA_MODES = 163,
	ATA_ID_DATA_SET_MGMT = 169,
	ATA_ID_SCT_CMD_XPORT = 206,
	ATA_ID_ROT_SPEED = 217,
	ATA_ID_PIO4 = 2,
	ATA_ID_SERNO_LEN = 20,
	ATA_ID_FW_REV_LEN = 8,
	ATA_ID_PROD_LEN = 40,
	ATA_ID_WWN_LEN = 8,
	ATA_PCI_CTL_OFS = 2,
	ATA_PIO0 = 1,
	ATA_PIO1 = 3,
	ATA_PIO2 = 7,
	ATA_PIO3 = 15,
	ATA_PIO4 = 31,
	ATA_PIO5 = 63,
	ATA_PIO6 = 127,
	ATA_PIO4_ONLY = 16,
	ATA_SWDMA0 = 1,
	ATA_SWDMA1 = 3,
	ATA_SWDMA2 = 7,
	ATA_SWDMA2_ONLY = 4,
	ATA_MWDMA0 = 1,
	ATA_MWDMA1 = 3,
	ATA_MWDMA2 = 7,
	ATA_MWDMA3 = 15,
	ATA_MWDMA4 = 31,
	ATA_MWDMA12_ONLY = 6,
	ATA_MWDMA2_ONLY = 4,
	ATA_UDMA0 = 1,
	ATA_UDMA1 = 3,
	ATA_UDMA2 = 7,
	ATA_UDMA3 = 15,
	ATA_UDMA4 = 31,
	ATA_UDMA5 = 63,
	ATA_UDMA6 = 127,
	ATA_UDMA7 = 255,
	ATA_UDMA24_ONLY = 20,
	ATA_UDMA_MASK_40C = 7,
	ATA_PRD_SZ = 8,
	ATA_PRD_TBL_SZ = 2048,
	ATA_PRD_EOT = -2147483648,
	ATA_DMA_TABLE_OFS = 4,
	ATA_DMA_STATUS = 2,
	ATA_DMA_CMD = 0,
	ATA_DMA_WR = 8,
	ATA_DMA_START = 1,
	ATA_DMA_INTR = 4,
	ATA_DMA_ERR = 2,
	ATA_DMA_ACTIVE = 1,
	ATA_HOB = 128,
	ATA_NIEN = 2,
	ATA_LBA = 64,
	ATA_DEV1 = 16,
	ATA_DEVICE_OBS = 160,
	ATA_DEVCTL_OBS = 8,
	ATA_BUSY = 128,
	ATA_DRDY = 64,
	ATA_DF = 32,
	ATA_DSC = 16,
	ATA_DRQ = 8,
	ATA_CORR = 4,
	ATA_SENSE = 2,
	ATA_ERR = 1,
	ATA_SRST = 4,
	ATA_ICRC = 128,
	ATA_BBK = 128,
	ATA_UNC = 64,
	ATA_MC = 32,
	ATA_IDNF = 16,
	ATA_MCR = 8,
	ATA_ABORTED = 4,
	ATA_TRK0NF = 2,
	ATA_AMNF = 1,
	ATAPI_LFS = 240,
	ATAPI_EOM = 2,
	ATAPI_ILI = 1,
	ATAPI_IO = 2,
	ATAPI_COD = 1,
	ATA_REG_DATA = 0,
	ATA_REG_ERR = 1,
	ATA_REG_NSECT = 2,
	ATA_REG_LBAL = 3,
	ATA_REG_LBAM = 4,
	ATA_REG_LBAH = 5,
	ATA_REG_DEVICE = 6,
	ATA_REG_STATUS = 7,
	ATA_REG_FEATURE = 1,
	ATA_REG_CMD = 7,
	ATA_REG_BYTEL = 4,
	ATA_REG_BYTEH = 5,
	ATA_REG_DEVSEL = 6,
	ATA_REG_IRQ = 2,
	ATA_CMD_DEV_RESET = 8,
	ATA_CMD_CHK_POWER = 229,
	ATA_CMD_STANDBY = 226,
	ATA_CMD_IDLE = 227,
	ATA_CMD_EDD = 144,
	ATA_CMD_DOWNLOAD_MICRO = 146,
	ATA_CMD_DOWNLOAD_MICRO_DMA = 147,
	ATA_CMD_NOP = 0,
	ATA_CMD_FLUSH = 231,
	ATA_CMD_FLUSH_EXT = 234,
	ATA_CMD_ID_ATA = 236,
	ATA_CMD_ID_ATAPI = 161,
	ATA_CMD_SERVICE = 162,
	ATA_CMD_READ = 200,
	ATA_CMD_READ_EXT = 37,
	ATA_CMD_READ_QUEUED = 38,
	ATA_CMD_READ_STREAM_EXT = 43,
	ATA_CMD_READ_STREAM_DMA_EXT = 42,
	ATA_CMD_WRITE = 202,
	ATA_CMD_WRITE_EXT = 53,
	ATA_CMD_WRITE_QUEUED = 54,
	ATA_CMD_WRITE_STREAM_EXT = 59,
	ATA_CMD_WRITE_STREAM_DMA_EXT = 58,
	ATA_CMD_WRITE_FUA_EXT = 61,
	ATA_CMD_WRITE_QUEUED_FUA_EXT = 62,
	ATA_CMD_FPDMA_READ = 96,
	ATA_CMD_FPDMA_WRITE = 97,
	ATA_CMD_NCQ_NON_DATA = 99,
	ATA_CMD_FPDMA_SEND = 100,
	ATA_CMD_FPDMA_RECV = 101,
	ATA_CMD_PIO_READ = 32,
	ATA_CMD_PIO_READ_EXT = 36,
	ATA_CMD_PIO_WRITE = 48,
	ATA_CMD_PIO_WRITE_EXT = 52,
	ATA_CMD_READ_MULTI = 196,
	ATA_CMD_READ_MULTI_EXT = 41,
	ATA_CMD_WRITE_MULTI = 197,
	ATA_CMD_WRITE_MULTI_EXT = 57,
	ATA_CMD_WRITE_MULTI_FUA_EXT = 206,
	ATA_CMD_SET_FEATURES = 239,
	ATA_CMD_SET_MULTI = 198,
	ATA_CMD_PACKET = 160,
	ATA_CMD_VERIFY = 64,
	ATA_CMD_VERIFY_EXT = 66,
	ATA_CMD_WRITE_UNCORR_EXT = 69,
	ATA_CMD_STANDBYNOW1 = 224,
	ATA_CMD_IDLEIMMEDIATE = 225,
	ATA_CMD_SLEEP = 230,
	ATA_CMD_INIT_DEV_PARAMS = 145,
	ATA_CMD_READ_NATIVE_MAX = 248,
	ATA_CMD_READ_NATIVE_MAX_EXT = 39,
	ATA_CMD_SET_MAX = 249,
	ATA_CMD_SET_MAX_EXT = 55,
	ATA_CMD_READ_LOG_EXT = 47,
	ATA_CMD_WRITE_LOG_EXT = 63,
	ATA_CMD_READ_LOG_DMA_EXT = 71,
	ATA_CMD_WRITE_LOG_DMA_EXT = 87,
	ATA_CMD_TRUSTED_NONDATA = 91,
	ATA_CMD_TRUSTED_RCV = 92,
	ATA_CMD_TRUSTED_RCV_DMA = 93,
	ATA_CMD_TRUSTED_SND = 94,
	ATA_CMD_TRUSTED_SND_DMA = 95,
	ATA_CMD_PMP_READ = 228,
	ATA_CMD_PMP_READ_DMA = 233,
	ATA_CMD_PMP_WRITE = 232,
	ATA_CMD_PMP_WRITE_DMA = 235,
	ATA_CMD_CONF_OVERLAY = 177,
	ATA_CMD_SEC_SET_PASS = 241,
	ATA_CMD_SEC_UNLOCK = 242,
	ATA_CMD_SEC_ERASE_PREP = 243,
	ATA_CMD_SEC_ERASE_UNIT = 244,
	ATA_CMD_SEC_FREEZE_LOCK = 245,
	ATA_CMD_SEC_DISABLE_PASS = 246,
	ATA_CMD_CONFIG_STREAM = 81,
	ATA_CMD_SMART = 176,
	ATA_CMD_MEDIA_LOCK = 222,
	ATA_CMD_MEDIA_UNLOCK = 223,
	ATA_CMD_DSM = 6,
	ATA_CMD_CHK_MED_CRD_TYP = 209,
	ATA_CMD_CFA_REQ_EXT_ERR = 3,
	ATA_CMD_CFA_WRITE_NE = 56,
	ATA_CMD_CFA_TRANS_SECT = 135,
	ATA_CMD_CFA_ERASE = 192,
	ATA_CMD_CFA_WRITE_MULT_NE = 205,
	ATA_CMD_REQ_SENSE_DATA = 11,
	ATA_CMD_SANITIZE_DEVICE = 180,
	ATA_CMD_ZAC_MGMT_IN = 74,
	ATA_CMD_ZAC_MGMT_OUT = 159,
	ATA_CMD_RESTORE = 16,
	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 1,
	ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN = 2,
	ATA_SUBCMD_FPDMA_SEND_DSM = 0,
	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 2,
	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE = 0,
	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 5,
	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT = 6,
	ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT = 7,
	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0,
	ATA_SUBCMD_ZAC_MGMT_OUT_CLOSE_ZONE = 1,
	ATA_SUBCMD_ZAC_MGMT_OUT_FINISH_ZONE = 2,
	ATA_SUBCMD_ZAC_MGMT_OUT_OPEN_ZONE = 3,
	ATA_SUBCMD_ZAC_MGMT_OUT_RESET_WRITE_POINTER = 4,
	ATA_LOG_DIRECTORY = 0,
	ATA_LOG_SATA_NCQ = 16,
	ATA_LOG_NCQ_NON_DATA = 18,
	ATA_LOG_NCQ_SEND_RECV = 19,
	ATA_LOG_CDL = 24,
	ATA_LOG_CDL_SIZE = 512,
	ATA_LOG_IDENTIFY_DEVICE = 48,
	ATA_LOG_SENSE_NCQ = 15,
	ATA_LOG_SENSE_NCQ_SIZE = 1024,
	ATA_LOG_CONCURRENT_POSITIONING_RANGES = 71,
	ATA_LOG_SUPPORTED_CAPABILITIES = 3,
	ATA_LOG_CURRENT_SETTINGS = 4,
	ATA_LOG_SECURITY = 6,
	ATA_LOG_SATA_SETTINGS = 8,
	ATA_LOG_ZONED_INFORMATION = 9,
	ATA_LOG_DEVSLP_OFFSET = 48,
	ATA_LOG_DEVSLP_SIZE = 8,
	ATA_LOG_DEVSLP_MDAT = 0,
	ATA_LOG_DEVSLP_MDAT_MASK = 31,
	ATA_LOG_DEVSLP_DETO = 1,
	ATA_LOG_DEVSLP_VALID = 7,
	ATA_LOG_DEVSLP_VALID_MASK = 128,
	ATA_LOG_NCQ_PRIO_OFFSET = 9,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_DSM = 1,
	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET = 4,
	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM = 1,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET = 8,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET = 12,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET = 16,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OUT_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED = 2,
	ATA_LOG_NCQ_SEND_RECV_SIZE = 20,
	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_NCQ = 1,
	ATA_LOG_NCQ_NON_DATA_ABORT_ALL = 2,
	ATA_LOG_NCQ_NON_DATA_ABORT_STREAMING = 4,
	ATA_LOG_NCQ_NON_DATA_ABORT_NON_STREAMING = 8,
	ATA_LOG_NCQ_NON_DATA_ABORT_SELECTED = 16,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET = 28,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT = 1,
	ATA_LOG_NCQ_NON_DATA_SIZE = 64,
	ATA_CMD_READ_LONG = 34,
	ATA_CMD_READ_LONG_ONCE = 35,
	ATA_CMD_WRITE_LONG = 50,
	ATA_CMD_WRITE_LONG_ONCE = 51,
	SETFEATURES_XFER = 3,
	XFER_UDMA_7 = 71,
	XFER_UDMA_6 = 70,
	XFER_UDMA_5 = 69,
	XFER_UDMA_4 = 68,
	XFER_UDMA_3 = 67,
	XFER_UDMA_2 = 66,
	XFER_UDMA_1 = 65,
	XFER_UDMA_0 = 64,
	XFER_MW_DMA_4 = 36,
	XFER_MW_DMA_3 = 35,
	XFER_MW_DMA_2 = 34,
	XFER_MW_DMA_1 = 33,
	XFER_MW_DMA_0 = 32,
	XFER_SW_DMA_2 = 18,
	XFER_SW_DMA_1 = 17,
	XFER_SW_DMA_0 = 16,
	XFER_PIO_6 = 14,
	XFER_PIO_5 = 13,
	XFER_PIO_4 = 12,
	XFER_PIO_3 = 11,
	XFER_PIO_2 = 10,
	XFER_PIO_1 = 9,
	XFER_PIO_0 = 8,
	XFER_PIO_SLOW = 0,
	SETFEATURES_WC_ON = 2,
	SETFEATURES_WC_OFF = 130,
	SETFEATURES_RA_ON = 170,
	SETFEATURES_RA_OFF = 85,
	SETFEATURES_AAM_ON = 66,
	SETFEATURES_AAM_OFF = 194,
	SETFEATURES_SPINUP = 7,
	SETFEATURES_SPINUP_TIMEOUT = 30000,
	SETFEATURES_SATA_ENABLE = 16,
	SETFEATURES_SATA_DISABLE = 144,
	SETFEATURES_CDL = 13,
	SATA_FPDMA_OFFSET = 1,
	SATA_FPDMA_AA = 2,
	SATA_DIPM = 3,
	SATA_FPDMA_IN_ORDER = 4,
	SATA_AN = 5,
	SATA_SSP = 6,
	SATA_DEVSLP = 9,
	SETFEATURE_SENSE_DATA = 195,
	SETFEATURE_SENSE_DATA_SUCC_NCQ = 196,
	ATA_SET_MAX_ADDR = 0,
	ATA_SET_MAX_PASSWD = 1,
	ATA_SET_MAX_LOCK = 2,
	ATA_SET_MAX_UNLOCK = 3,
	ATA_SET_MAX_FREEZE_LOCK = 4,
	ATA_SET_MAX_PASSWD_DMA = 5,
	ATA_SET_MAX_UNLOCK_DMA = 6,
	ATA_DCO_RESTORE = 192,
	ATA_DCO_FREEZE_LOCK = 193,
	ATA_DCO_IDENTIFY = 194,
	ATA_DCO_SET = 195,
	ATA_SMART_ENABLE = 216,
	ATA_SMART_READ_VALUES = 208,
	ATA_SMART_READ_THRESHOLDS = 209,
	ATA_DSM_TRIM = 1,
	ATA_SMART_LBAM_PASS = 79,
	ATA_SMART_LBAH_PASS = 194,
	ATAPI_PKT_DMA = 1,
	ATAPI_DMADIR = 4,
	ATAPI_CDB_LEN = 16,
	SATA_PMP_MAX_PORTS = 15,
	SATA_PMP_CTRL_PORT = 15,
	SATA_PMP_GSCR_DWORDS = 128,
	SATA_PMP_GSCR_PROD_ID = 0,
	SATA_PMP_GSCR_REV = 1,
	SATA_PMP_GSCR_PORT_INFO = 2,
	SATA_PMP_GSCR_ERROR = 32,
	SATA_PMP_GSCR_ERROR_EN = 33,
	SATA_PMP_GSCR_FEAT = 64,
	SATA_PMP_GSCR_FEAT_EN = 96,
	SATA_PMP_PSCR_STATUS = 0,
	SATA_PMP_PSCR_ERROR = 1,
	SATA_PMP_PSCR_CONTROL = 2,
	SATA_PMP_FEAT_BIST = 1,
	SATA_PMP_FEAT_PMREQ = 2,
	SATA_PMP_FEAT_DYNSSC = 4,
	SATA_PMP_FEAT_NOTIFY = 8,
	ATA_CBL_NONE = 0,
	ATA_CBL_PATA40 = 1,
	ATA_CBL_PATA80 = 2,
	ATA_CBL_PATA40_SHORT = 3,
	ATA_CBL_PATA_UNK = 4,
	ATA_CBL_PATA_IGN = 5,
	ATA_CBL_SATA = 6,
	SCR_STATUS = 0,
	SCR_ERROR = 1,
	SCR_CONTROL = 2,
	SCR_ACTIVE = 3,
	SCR_NOTIFICATION = 4,
	SERR_DATA_RECOVERED = 1,
	SERR_COMM_RECOVERED = 2,
	SERR_DATA = 256,
	SERR_PERSISTENT = 512,
	SERR_PROTOCOL = 1024,
	SERR_INTERNAL = 2048,
	SERR_PHYRDY_CHG = 65536,
	SERR_PHY_INT_ERR = 131072,
	SERR_COMM_WAKE = 262144,
	SERR_10B_8B_ERR = 524288,
	SERR_DISPARITY = 1048576,
	SERR_CRC = 2097152,
	SERR_HANDSHAKE = 4194304,
	SERR_LINK_SEQ_ERR = 8388608,
	SERR_TRANS_ST_ERROR = 16777216,
	SERR_UNRECOG_FIS = 33554432,
	SERR_DEV_XCHG = 67108864,
};

enum {
	ATM_DF_REMOVED = 0,
};

enum {
	ATM_VF_ADDR = 0,
	ATM_VF_READY = 1,
	ATM_VF_PARTIAL = 2,
	ATM_VF_REGIS = 3,
	ATM_VF_BOUND = 4,
	ATM_VF_RELEASED = 5,
	ATM_VF_HASQOS = 6,
	ATM_VF_LISTEN = 7,
	ATM_VF_META = 8,
	ATM_VF_SESSION = 9,
	ATM_VF_HASSAP = 10,
	ATM_VF_CLOSE = 11,
	ATM_VF_WAITING = 12,
	ATM_VF_IS_CLIP = 13,
};

enum {
	AT_PKT_END = -1,
	BEYOND_PKT_END = -2,
};

enum {
	AUTOFS_DEV_IOCTL_VERSION_CMD = 113,
	AUTOFS_DEV_IOCTL_PROTOVER_CMD = 114,
	AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD = 115,
	AUTOFS_DEV_IOCTL_OPENMOUNT_CMD = 116,
	AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD = 117,
	AUTOFS_DEV_IOCTL_READY_CMD = 118,
	AUTOFS_DEV_IOCTL_FAIL_CMD = 119,
	AUTOFS_DEV_IOCTL_SETPIPEFD_CMD = 120,
	AUTOFS_DEV_IOCTL_CATATONIC_CMD = 121,
	AUTOFS_DEV_IOCTL_TIMEOUT_CMD = 122,
	AUTOFS_DEV_IOCTL_REQUESTER_CMD = 123,
	AUTOFS_DEV_IOCTL_EXPIRE_CMD = 124,
	AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD = 125,
	AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD = 126,
};

enum {
	AUTOFS_IOC_EXPIRE_MULTI_CMD = 102,
	AUTOFS_IOC_PROTOSUBVER_CMD = 103,
	AUTOFS_IOC_ASKUMOUNT_CMD = 112,
};

enum {
	AUTOFS_IOC_READY_CMD = 96,
	AUTOFS_IOC_FAIL_CMD = 97,
	AUTOFS_IOC_CATATONIC_CMD = 98,
	AUTOFS_IOC_PROTOVER_CMD = 99,
	AUTOFS_IOC_SETTIMEOUT_CMD = 100,
	AUTOFS_IOC_EXPIRE_CMD = 101,
};

enum {
	AUTOP_INVALID = 0,
	AUTOP_HDD = 1,
	AUTOP_SSD_QD1 = 2,
	AUTOP_SSD_DFL = 3,
	AUTOP_SSD_FAST = 4,
};

enum {
	AX25_VALUES_IPDEFMODE = 0,
	AX25_VALUES_AXDEFMODE = 1,
	AX25_VALUES_BACKOFF = 2,
	AX25_VALUES_CONMODE = 3,
	AX25_VALUES_WINDOW = 4,
	AX25_VALUES_EWINDOW = 5,
	AX25_VALUES_T1 = 6,
	AX25_VALUES_T2 = 7,
	AX25_VALUES_T3 = 8,
	AX25_VALUES_IDLE = 9,
	AX25_VALUES_N2 = 10,
	AX25_VALUES_PACLEN = 11,
	AX25_VALUES_PROTOCOL = 12,
	AX25_MAX_VALUES = 13,
};

enum {
	Audit_equal = 0,
	Audit_not_equal = 1,
	Audit_bitmask = 2,
	Audit_bittest = 3,
	Audit_lt = 4,
	Audit_gt = 5,
	Audit_le = 6,
	Audit_ge = 7,
	Audit_bad = 8,
};

enum {
	BAD_STACK = -1,
	NOT_STACK = 0,
	GOOD_FRAME = 1,
	GOOD_STACK = 2,
};

enum {
	BC_NACK_SND_CONDITIONAL = 0,
	BC_NACK_SND_UNCONDITIONAL = 1,
	BC_NACK_SND_SUPPRESS = 2,
};

enum {
	BDX_PCI_UNCORE_HA = 0,
	BDX_PCI_UNCORE_IMC = 1,
	BDX_PCI_UNCORE_IRP = 2,
	BDX_PCI_UNCORE_QPI = 3,
	BDX_PCI_UNCORE_R2PCIE = 4,
	BDX_PCI_UNCORE_R3QPI = 5,
};

enum {
	BIAS = 2147483648,
};

enum {
	BIOSET_NEED_BVECS = 1,
	BIOSET_NEED_RESCUER = 2,
	BIOSET_PERCPU_CACHE = 4,
};

enum {
	BIO_PAGE_PINNED = 0,
	BIO_CLONED = 1,
	BIO_BOUNCED = 2,
	BIO_QUIET = 3,
	BIO_CHAIN = 4,
	BIO_REFFED = 5,
	BIO_BPS_THROTTLED = 6,
	BIO_TRACE_COMPLETION = 7,
	BIO_CGROUP_ACCT = 8,
	BIO_QOS_THROTTLED = 9,
	BIO_QOS_MERGED = 10,
	BIO_REMAPPED = 11,
	BIO_ZONE_WRITE_PLUGGING = 12,
	BIO_EMULATES_ZONE_APPEND = 13,
	BIO_FLAG_LAST = 14,
};

enum {
	BLK_MQ_F_TAG_QUEUE_SHARED = 2,
	BLK_MQ_F_STACKING = 4,
	BLK_MQ_F_TAG_HCTX_SHARED = 8,
	BLK_MQ_F_BLOCKING = 16,
	BLK_MQ_F_TAG_RR = 32,
	BLK_MQ_F_NO_SCHED_BY_DEFAULT = 64,
	BLK_MQ_F_MAX = 128,
};

enum {
	BLK_MQ_NO_TAG = 4294967295,
	BLK_MQ_TAG_MIN = 1,
	BLK_MQ_TAG_MAX = 4294967294,
};

enum {
	BLK_MQ_REQ_NOWAIT = 1,
	BLK_MQ_REQ_RESERVED = 2,
	BLK_MQ_REQ_PM = 4,
};

enum {
	BLK_MQ_S_STOPPED = 0,
	BLK_MQ_S_TAG_ACTIVE = 1,
	BLK_MQ_S_SCHED_RESTART = 2,
	BLK_MQ_S_INACTIVE = 3,
	BLK_MQ_S_MAX = 4,
};

enum {
	BLK_MQ_UNIQUE_TAG_BITS = 16,
	BLK_MQ_UNIQUE_TAG_MASK = 65535,
};

enum {
	BLOCK_BITMAP = 0,
	INODE_BITMAP = 1,
	INODE_TABLE = 2,
	GROUP_TABLE_COUNT = 3,
};

enum {
	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
};

enum {
	BPF_ANY = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST = 2,
	BPF_F_LOCK = 4,
};

enum {
	BPF_CSUM_LEVEL_QUERY = 0,
	BPF_CSUM_LEVEL_INC = 1,
	BPF_CSUM_LEVEL_DEC = 2,
	BPF_CSUM_LEVEL_RESET = 3,
};

enum {
	BPF_FIB_LKUP_RET_SUCCESS = 0,
	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
	BPF_FIB_LKUP_RET_PROHIBIT = 3,
	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
	BPF_FIB_LKUP_RET_NO_SRC_ADDR = 9,
};

enum {
	BPF_FIB_LOOKUP_DIRECT = 1,
	BPF_FIB_LOOKUP_OUTPUT = 2,
	BPF_FIB_LOOKUP_SKIP_NEIGH = 4,
	BPF_FIB_LOOKUP_TBID = 8,
	BPF_FIB_LOOKUP_SRC = 16,
	BPF_FIB_LOOKUP_MARK = 32,
};

enum {
	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG = 1,
	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL = 2,
	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP = 4,
};

enum {
	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
	BPF_F_ADJ_ROOM_NO_CSUM_RESET = 32,
	BPF_F_ADJ_ROOM_ENCAP_L2_ETH = 64,
	BPF_F_ADJ_ROOM_DECAP_L3_IPV4 = 128,
	BPF_F_ADJ_ROOM_DECAP_L3_IPV6 = 256,
};

enum {
	BPF_F_BPRM_SECUREEXEC = 1,
};

enum {
	BPF_F_CURRENT_NETNS = -1,
};

enum {
	BPF_F_GET_BRANCH_RECORDS_SIZE = 1,
};

enum {
	BPF_F_HDR_FIELD_MASK = 15,
};

enum {
	BPF_F_INDEX_MASK = 4294967295ULL,
	BPF_F_CURRENT_CPU = 4294967295ULL,
	BPF_F_CTXLEN_MASK = 4503595332403200ULL,
};

enum {
	BPF_F_INGRESS = 1,
	BPF_F_BROADCAST = 8,
	BPF_F_EXCLUDE_INGRESS = 16,
};

enum {
	BPF_F_NEIGH = 65536,
	BPF_F_PEER = 131072,
	BPF_F_NEXTHOP = 262144,
};

enum {
	BPF_F_NO_PREALLOC = 1,
	BPF_F_NO_COMMON_LRU = 2,
	BPF_F_NUMA_NODE = 4,
	BPF_F_RDONLY = 8,
	BPF_F_WRONLY = 16,
	BPF_F_STACK_BUILD_ID = 32,
	BPF_F_ZERO_SEED = 64,
	BPF_F_RDONLY_PROG = 128,
	BPF_F_WRONLY_PROG = 256,
	BPF_F_CLONE = 512,
	BPF_F_MMAPABLE = 1024,
	BPF_F_PRESERVE_ELEMS = 2048,
	BPF_F_INNER_MAP = 4096,
	BPF_F_LINK = 8192,
	BPF_F_PATH_FD = 16384,
	BPF_F_VTYPE_BTF_OBJ_FD = 32768,
	BPF_F_TOKEN_FD = 65536,
	BPF_F_SEGV_ON_FAULT = 131072,
	BPF_F_NO_USER_CONV = 262144,
};

enum {
	BPF_F_PSEUDO_HDR = 16,
	BPF_F_MARK_MANGLED_0 = 32,
	BPF_F_MARK_ENFORCE = 64,
};

enum {
	BPF_F_RECOMPUTE_CSUM = 1,
	BPF_F_INVALIDATE_HASH = 2,
};

enum {
	BPF_F_SKIP_FIELD_MASK = 255,
	BPF_F_USER_STACK = 256,
	BPF_F_FAST_STACK_CMP = 512,
	BPF_F_REUSE_STACKID = 1024,
	BPF_F_USER_BUILD_ID = 2048,
};

enum {
	BPF_F_SYSCTL_BASE_NAME = 1,
};

enum {
	BPF_F_TIMER_ABS = 1,
	BPF_F_TIMER_CPU_PIN = 2,
};

enum {
	BPF_F_TUNINFO_FLAGS = 16,
};

enum {
	BPF_F_TUNINFO_IPV6 = 1,
};

enum {
	BPF_F_UPROBE_MULTI_RETURN = 1,
};

enum {
	BPF_F_ZERO_CSUM_TX = 2,
	BPF_F_DONT_FRAGMENT = 4,
	BPF_F_SEQ_NUMBER = 8,
	BPF_F_NO_TUNNEL_KEY = 16,
};

enum {
	BPF_LOAD_HDR_OPT_TCP_SYN = 1,
};

enum {
	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
	BPF_SK_STORAGE_GET_F_CREATE = 1,
};

enum {
	BPF_MAX_LOOPS = 8388608,
};

enum {
	BPF_MAX_TRAMP_LINKS = 38,
};

enum {
	BPF_RB_AVAIL_DATA = 0,
	BPF_RB_RING_SIZE = 1,
	BPF_RB_CONS_POS = 2,
	BPF_RB_PROD_POS = 3,
};

enum {
	BPF_RB_NO_WAKEUP = 1,
	BPF_RB_FORCE_WAKEUP = 2,
};

enum {
	BPF_REG_0 = 0,
	BPF_REG_1 = 1,
	BPF_REG_2 = 2,
	BPF_REG_3 = 3,
	BPF_REG_4 = 4,
	BPF_REG_5 = 5,
	BPF_REG_6 = 6,
	BPF_REG_7 = 7,
	BPF_REG_8 = 8,
	BPF_REG_9 = 9,
	BPF_REG_10 = 10,
	__MAX_BPF_REG = 11,
};

enum {
	BPF_RINGBUF_BUSY_BIT = 2147483648,
	BPF_RINGBUF_DISCARD_BIT = 1073741824,
	BPF_RINGBUF_HDR_SZ = 8,
};

enum {
	BPF_SKB_TSTAMP_UNSPEC = 0,
	BPF_SKB_TSTAMP_DELIVERY_MONO = 1,
	BPF_SKB_CLOCK_REALTIME = 0,
	BPF_SKB_CLOCK_MONOTONIC = 1,
	BPF_SKB_CLOCK_TAI = 2,
};

enum {
	BPF_SK_LOOKUP_F_REPLACE = 1,
	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
};

enum {
	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG = 16,
	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 32,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = 64,
	BPF_SOCK_OPS_ALL_CB_FLAGS = 127,
};

enum {
	BPF_SOCK_OPS_VOID = 0,
	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
	BPF_SOCK_OPS_RWND_INIT = 2,
	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
	BPF_SOCK_OPS_NEEDS_ECN = 6,
	BPF_SOCK_OPS_BASE_RTT = 7,
	BPF_SOCK_OPS_RTO_CB = 8,
	BPF_SOCK_OPS_RETRANS_CB = 9,
	BPF_SOCK_OPS_STATE_CB = 10,
	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
	BPF_SOCK_OPS_RTT_CB = 12,
	BPF_SOCK_OPS_PARSE_HDR_OPT_CB = 13,
	BPF_SOCK_OPS_HDR_OPT_LEN_CB = 14,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB = 15,
};

enum {
	BPF_TASK_ITER_ALL_PROCS = 0,
	BPF_TASK_ITER_ALL_THREADS = 1,
	BPF_TASK_ITER_PROC_THREADS = 2,
};

enum {
	BPF_TCP_ESTABLISHED = 1,
	BPF_TCP_SYN_SENT = 2,
	BPF_TCP_SYN_RECV = 3,
	BPF_TCP_FIN_WAIT1 = 4,
	BPF_TCP_FIN_WAIT2 = 5,
	BPF_TCP_TIME_WAIT = 6,
	BPF_TCP_CLOSE = 7,
	BPF_TCP_CLOSE_WAIT = 8,
	BPF_TCP_LAST_ACK = 9,
	BPF_TCP_LISTEN = 10,
	BPF_TCP_CLOSING = 11,
	BPF_TCP_NEW_SYN_RECV = 12,
	BPF_TCP_BOUND_INACTIVE = 13,
	BPF_TCP_MAX_STATES = 14,
};

enum {
	BPF_WRITE_HDR_TCP_CURRENT_MSS = 1,
	BPF_WRITE_HDR_TCP_SYNACK_COOKIE = 2,
};

enum {
	BPF_XFRM_STATE_OPTS_SZ = 36,
};

enum {
	BRIDGE_QUERIER_UNSPEC = 0,
	BRIDGE_QUERIER_IP_ADDRESS = 1,
	BRIDGE_QUERIER_IP_PORT = 2,
	BRIDGE_QUERIER_IP_OTHER_TIMER = 3,
	BRIDGE_QUERIER_PAD = 4,
	BRIDGE_QUERIER_IPV6_ADDRESS = 5,
	BRIDGE_QUERIER_IPV6_PORT = 6,
	BRIDGE_QUERIER_IPV6_OTHER_TIMER = 7,
	__BRIDGE_QUERIER_MAX = 8,
};

enum {
	BRIDGE_VLANDB_DUMP_UNSPEC = 0,
	BRIDGE_VLANDB_DUMP_FLAGS = 1,
	__BRIDGE_VLANDB_DUMP_MAX = 2,
};

enum {
	BRIDGE_VLANDB_ENTRY_UNSPEC = 0,
	BRIDGE_VLANDB_ENTRY_INFO = 1,
	BRIDGE_VLANDB_ENTRY_RANGE = 2,
	BRIDGE_VLANDB_ENTRY_STATE = 3,
	BRIDGE_VLANDB_ENTRY_TUNNEL_INFO = 4,
	BRIDGE_VLANDB_ENTRY_STATS = 5,
	BRIDGE_VLANDB_ENTRY_MCAST_ROUTER = 6,
	BRIDGE_VLANDB_ENTRY_MCAST_N_GROUPS = 7,
	BRIDGE_VLANDB_ENTRY_MCAST_MAX_GROUPS = 8,
	BRIDGE_VLANDB_ENTRY_NEIGH_SUPPRESS = 9,
	__BRIDGE_VLANDB_ENTRY_MAX = 10,
};

enum {
	BRIDGE_VLANDB_GOPTS_UNSPEC = 0,
	BRIDGE_VLANDB_GOPTS_ID = 1,
	BRIDGE_VLANDB_GOPTS_RANGE = 2,
	BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING = 3,
	BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION = 4,
	BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION = 5,
	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_CNT = 6,
	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_CNT = 7,
	BRIDGE_VLANDB_GOPTS_MCAST_LAST_MEMBER_INTVL = 8,
	BRIDGE_VLANDB_GOPTS_PAD = 9,
	BRIDGE_VLANDB_GOPTS_MCAST_MEMBERSHIP_INTVL = 10,
	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_INTVL = 11,
	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_INTVL = 12,
	BRIDGE_VLANDB_GOPTS_MCAST_QUERY_RESPONSE_INTVL = 13,
	BRIDGE_VLANDB_GOPTS_MCAST_STARTUP_QUERY_INTVL = 14,
	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER = 15,
	BRIDGE_VLANDB_GOPTS_MCAST_ROUTER_PORTS = 16,
	BRIDGE_VLANDB_GOPTS_MCAST_QUERIER_STATE = 17,
	BRIDGE_VLANDB_GOPTS_MSTI = 18,
	__BRIDGE_VLANDB_GOPTS_MAX = 19,
};

enum {
	BRIDGE_VLANDB_STATS_UNSPEC = 0,
	BRIDGE_VLANDB_STATS_RX_BYTES = 1,
	BRIDGE_VLANDB_STATS_RX_PACKETS = 2,
	BRIDGE_VLANDB_STATS_TX_BYTES = 3,
	BRIDGE_VLANDB_STATS_TX_PACKETS = 4,
	BRIDGE_VLANDB_STATS_PAD = 5,
	__BRIDGE_VLANDB_STATS_MAX = 6,
};

enum {
	BRIDGE_VLANDB_TINFO_UNSPEC = 0,
	BRIDGE_VLANDB_TINFO_ID = 1,
	BRIDGE_VLANDB_TINFO_CMD = 2,
	__BRIDGE_VLANDB_TINFO_MAX = 3,
};

enum {
	BRIDGE_VLANDB_UNSPEC = 0,
	BRIDGE_VLANDB_ENTRY = 1,
	BRIDGE_VLANDB_GLOBAL_OPTIONS = 2,
	__BRIDGE_VLANDB_MAX = 3,
};

enum {
	BRIDGE_XSTATS_UNSPEC = 0,
	BRIDGE_XSTATS_VLAN = 1,
	BRIDGE_XSTATS_MCAST = 2,
	BRIDGE_XSTATS_PAD = 3,
	BRIDGE_XSTATS_STP = 4,
	__BRIDGE_XSTATS_MAX = 5,
};

enum {
	BR_FDB_LOCAL = 0,
	BR_FDB_STATIC = 1,
	BR_FDB_STICKY = 2,
	BR_FDB_ADDED_BY_USER = 3,
	BR_FDB_ADDED_BY_EXT_LEARN = 4,
	BR_FDB_OFFLOADED = 5,
	BR_FDB_NOTIFY = 6,
	BR_FDB_NOTIFY_INACTIVE = 7,
	BR_FDB_LOCKED = 8,
	BR_FDB_DYNAMIC_LEARNED = 9,
};

enum {
	BR_GROUPFWD_STP = 1,
	BR_GROUPFWD_MACPAUSE = 2,
	BR_GROUPFWD_LACP = 4,
};

enum {
	BR_MCAST_DIR_RX = 0,
	BR_MCAST_DIR_TX = 1,
	BR_MCAST_DIR_SIZE = 2,
};

enum {
	BR_VLFLAG_PER_PORT_STATS = 1,
	BR_VLFLAG_ADDED_BY_SWITCHDEV = 2,
	BR_VLFLAG_MCAST_ENABLED = 4,
	BR_VLFLAG_GLOBAL_MCAST_ENABLED = 8,
	BR_VLFLAG_NEIGH_SUPPRESS_ENABLED = 16,
};

enum {
	BTF_FIELDS_MAX = 11,
};

enum {
	BTF_FIELD_IGNORE = 0,
	BTF_FIELD_FOUND = 1,
};

enum {
	BTF_F_COMPACT = 1,
	BTF_F_NONAME = 2,
	BTF_F_PTR_RAW = 4,
	BTF_F_ZERO = 8,
};

enum {
	BTF_KFUNC_SET_MAX_CNT = 256,
	BTF_DTOR_KFUNC_MAX_CNT = 256,
	BTF_KFUNC_FILTER_MAX_CNT = 16,
};

enum {
	BTF_KIND_UNKN = 0,
	BTF_KIND_INT = 1,
	BTF_KIND_PTR = 2,
	BTF_KIND_ARRAY = 3,
	BTF_KIND_STRUCT = 4,
	BTF_KIND_UNION = 5,
	BTF_KIND_ENUM = 6,
	BTF_KIND_FWD = 7,
	BTF_KIND_TYPEDEF = 8,
	BTF_KIND_VOLATILE = 9,
	BTF_KIND_CONST = 10,
	BTF_KIND_RESTRICT = 11,
	BTF_KIND_FUNC = 12,
	BTF_KIND_FUNC_PROTO = 13,
	BTF_KIND_VAR = 14,
	BTF_KIND_DATASEC = 15,
	BTF_KIND_FLOAT = 16,
	BTF_KIND_DECL_TAG = 17,
	BTF_KIND_TYPE_TAG = 18,
	BTF_KIND_ENUM64 = 19,
	NR_BTF_KINDS = 20,
	BTF_KIND_MAX = 19,
};

enum {
	BTF_MODULE_F_LIVE = 1,
};

enum {
	BTF_SOCK_TYPE_INET = 0,
	BTF_SOCK_TYPE_INET_CONN = 1,
	BTF_SOCK_TYPE_INET_REQ = 2,
	BTF_SOCK_TYPE_INET_TW = 3,
	BTF_SOCK_TYPE_REQ = 4,
	BTF_SOCK_TYPE_SOCK = 5,
	BTF_SOCK_TYPE_SOCK_COMMON = 6,
	BTF_SOCK_TYPE_TCP = 7,
	BTF_SOCK_TYPE_TCP_REQ = 8,
	BTF_SOCK_TYPE_TCP_TW = 9,
	BTF_SOCK_TYPE_TCP6 = 10,
	BTF_SOCK_TYPE_UDP = 11,
	BTF_SOCK_TYPE_UDP6 = 12,
	BTF_SOCK_TYPE_UNIX = 13,
	BTF_SOCK_TYPE_MPTCP = 14,
	BTF_SOCK_TYPE_SOCKET = 15,
	MAX_BTF_SOCK_TYPE = 16,
};

enum {
	BTF_TRACING_TYPE_TASK = 0,
	BTF_TRACING_TYPE_FILE = 1,
	BTF_TRACING_TYPE_VMA = 2,
	MAX_BTF_TRACING_TYPE = 3,
};

enum {
	BTF_VAR_STATIC = 0,
	BTF_VAR_GLOBAL_ALLOCATED = 1,
	BTF_VAR_GLOBAL_EXTERN = 2,
};

enum {
	BTRFS_FILE_EXTENT_INLINE = 0,
	BTRFS_FILE_EXTENT_REG = 1,
	BTRFS_FILE_EXTENT_PREALLOC = 2,
	BTRFS_NR_FILE_EXTENT_TYPES = 3,
};

enum {
	BTRFS_FS_CLOSING_START = 0,
	BTRFS_FS_CLOSING_DONE = 1,
	BTRFS_FS_LOG_RECOVERING = 2,
	BTRFS_FS_OPEN = 3,
	BTRFS_FS_QUOTA_ENABLED = 4,
	BTRFS_FS_UPDATE_UUID_TREE_GEN = 5,
	BTRFS_FS_CREATING_FREE_SPACE_TREE = 6,
	BTRFS_FS_BTREE_ERR = 7,
	BTRFS_FS_LOG1_ERR = 8,
	BTRFS_FS_LOG2_ERR = 9,
	BTRFS_FS_QUOTA_OVERRIDE = 10,
	BTRFS_FS_FROZEN = 11,
	BTRFS_FS_BALANCE_RUNNING = 12,
	BTRFS_FS_RELOC_RUNNING = 13,
	BTRFS_FS_CLEANER_RUNNING = 14,
	BTRFS_FS_CSUM_IMPL_FAST = 15,
	BTRFS_FS_DISCARD_RUNNING = 16,
	BTRFS_FS_CLEANUP_SPACE_CACHE_V1 = 17,
	BTRFS_FS_FREE_SPACE_TREE_UNTRUSTED = 18,
	BTRFS_FS_TREE_MOD_LOG_USERS = 19,
	BTRFS_FS_COMMIT_TRANS = 20,
	BTRFS_FS_UNFINISHED_DROPS = 21,
	BTRFS_FS_NEED_ZONE_FINISH = 22,
	BTRFS_FS_NEED_TRANS_COMMIT = 23,
	BTRFS_FS_ACTIVE_ZONE_TRACKING = 24,
	BTRFS_FS_FEATURE_CHANGED = 25,
	BTRFS_FS_UNALIGNED_TREE_BLOCK = 26,
};

enum {
	BTRFS_FS_STATE_REMOUNTING = 0,
	BTRFS_FS_STATE_RO = 1,
	BTRFS_FS_STATE_TRANS_ABORTED = 2,
	BTRFS_FS_STATE_DEV_REPLACING = 3,
	BTRFS_FS_STATE_DUMMY_FS_INFO = 4,
	BTRFS_FS_STATE_NO_DATA_CSUMS = 5,
	BTRFS_FS_STATE_SKIP_META_CSUMS = 6,
	BTRFS_FS_STATE_LOG_CLEANUP_ERROR = 7,
	BTRFS_FS_STATE_COUNT = 8,
};

enum {
	BTRFS_INODE_FLUSH_ON_CLOSE = 0,
	BTRFS_INODE_DUMMY = 1,
	BTRFS_INODE_IN_DEFRAG = 2,
	BTRFS_INODE_HAS_ASYNC_EXTENT = 3,
	BTRFS_INODE_NEEDS_FULL_SYNC = 4,
	BTRFS_INODE_COPY_EVERYTHING = 5,
	BTRFS_INODE_HAS_PROPS = 6,
	BTRFS_INODE_SNAPSHOT_FLUSH = 7,
	BTRFS_INODE_NO_XATTRS = 8,
	BTRFS_INODE_NO_DELALLOC_FLUSH = 9,
	BTRFS_INODE_VERITY_IN_PROGRESS = 10,
	BTRFS_INODE_FREE_SPACE_INODE = 11,
	BTRFS_INODE_NO_CAP_XATTR = 12,
	BTRFS_INODE_COW_WRITE_ERROR = 13,
	BTRFS_INODE_ROOT_STUB = 14,
};

enum {
	BTRFS_MOUNT_NODATASUM = 1ULL,
	BTRFS_MOUNT_NODATACOW = 2ULL,
	BTRFS_MOUNT_NOBARRIER = 4ULL,
	BTRFS_MOUNT_SSD = 8ULL,
	BTRFS_MOUNT_DEGRADED = 16ULL,
	BTRFS_MOUNT_COMPRESS = 32ULL,
	BTRFS_MOUNT_NOTREELOG = 64ULL,
	BTRFS_MOUNT_FLUSHONCOMMIT = 128ULL,
	BTRFS_MOUNT_SSD_SPREAD = 256ULL,
	BTRFS_MOUNT_NOSSD = 512ULL,
	BTRFS_MOUNT_DISCARD_SYNC = 1024ULL,
	BTRFS_MOUNT_FORCE_COMPRESS = 2048ULL,
	BTRFS_MOUNT_SPACE_CACHE = 4096ULL,
	BTRFS_MOUNT_CLEAR_CACHE = 8192ULL,
	BTRFS_MOUNT_USER_SUBVOL_RM_ALLOWED = 16384ULL,
	BTRFS_MOUNT_ENOSPC_DEBUG = 32768ULL,
	BTRFS_MOUNT_AUTO_DEFRAG = 65536ULL,
	BTRFS_MOUNT_USEBACKUPROOT = 131072ULL,
	BTRFS_MOUNT_SKIP_BALANCE = 262144ULL,
	BTRFS_MOUNT_PANIC_ON_FATAL_ERROR = 524288ULL,
	BTRFS_MOUNT_RESCAN_UUID_TREE = 1048576ULL,
	BTRFS_MOUNT_FRAGMENT_DATA = 2097152ULL,
	BTRFS_MOUNT_FRAGMENT_METADATA = 4194304ULL,
	BTRFS_MOUNT_FREE_SPACE_TREE = 8388608ULL,
	BTRFS_MOUNT_NOLOGREPLAY = 16777216ULL,
	BTRFS_MOUNT_REF_VERIFY = 33554432ULL,
	BTRFS_MOUNT_DISCARD_ASYNC = 67108864ULL,
	BTRFS_MOUNT_IGNOREBADROOTS = 134217728ULL,
	BTRFS_MOUNT_IGNOREDATACSUMS = 268435456ULL,
	BTRFS_MOUNT_NODISCARD = 536870912ULL,
	BTRFS_MOUNT_NOSPACECACHE = 1073741824ULL,
	BTRFS_MOUNT_IGNOREMETACSUMS = 2147483648ULL,
	BTRFS_MOUNT_IGNORESUPERFLAGS = 4294967296ULL,
};

enum {
	BTRFS_ORDERED_REGULAR = 0,
	BTRFS_ORDERED_NOCOW = 1,
	BTRFS_ORDERED_PREALLOC = 2,
	BTRFS_ORDERED_COMPRESSED = 3,
	BTRFS_ORDERED_DIRECT = 4,
	BTRFS_ORDERED_IO_DONE = 5,
	BTRFS_ORDERED_COMPLETE = 6,
	BTRFS_ORDERED_IOERR = 7,
	BTRFS_ORDERED_TRUNCATED = 8,
	BTRFS_ORDERED_LOGGED = 9,
	BTRFS_ORDERED_LOGGED_CSUM = 10,
	BTRFS_ORDERED_PENDING = 11,
	BTRFS_ORDERED_ENCODED = 12,
};

enum {
	BTRFS_ROOT_IN_TRANS_SETUP = 0,
	BTRFS_ROOT_SHAREABLE = 1,
	BTRFS_ROOT_TRACK_DIRTY = 2,
	BTRFS_ROOT_IN_RADIX = 3,
	BTRFS_ROOT_ORPHAN_ITEM_INSERTED = 4,
	BTRFS_ROOT_DEFRAG_RUNNING = 5,
	BTRFS_ROOT_FORCE_COW = 6,
	BTRFS_ROOT_MULTI_LOG_TASKS = 7,
	BTRFS_ROOT_DIRTY = 8,
	BTRFS_ROOT_DELETING = 9,
	BTRFS_ROOT_DEAD_RELOC_TREE = 10,
	BTRFS_ROOT_DEAD_TREE = 11,
	BTRFS_ROOT_HAS_LOG_TREE = 12,
	BTRFS_ROOT_QGROUP_FLUSHING = 13,
	BTRFS_ROOT_ORPHAN_CLEANUP = 14,
	BTRFS_ROOT_UNFINISHED_DROP = 15,
	BTRFS_ROOT_RESET_LOCKDEP_CLASS = 16,
};

enum {
	BTRFS_SEND_A_UNSPEC = 0,
	BTRFS_SEND_A_UUID = 1,
	BTRFS_SEND_A_CTRANSID = 2,
	BTRFS_SEND_A_INO = 3,
	BTRFS_SEND_A_SIZE = 4,
	BTRFS_SEND_A_MODE = 5,
	BTRFS_SEND_A_UID = 6,
	BTRFS_SEND_A_GID = 7,
	BTRFS_SEND_A_RDEV = 8,
	BTRFS_SEND_A_CTIME = 9,
	BTRFS_SEND_A_MTIME = 10,
	BTRFS_SEND_A_ATIME = 11,
	BTRFS_SEND_A_OTIME = 12,
	BTRFS_SEND_A_XATTR_NAME = 13,
	BTRFS_SEND_A_XATTR_DATA = 14,
	BTRFS_SEND_A_PATH = 15,
	BTRFS_SEND_A_PATH_TO = 16,
	BTRFS_SEND_A_PATH_LINK = 17,
	BTRFS_SEND_A_FILE_OFFSET = 18,
	BTRFS_SEND_A_DATA = 19,
	BTRFS_SEND_A_CLONE_UUID = 20,
	BTRFS_SEND_A_CLONE_CTRANSID = 21,
	BTRFS_SEND_A_CLONE_PATH = 22,
	BTRFS_SEND_A_CLONE_OFFSET = 23,
	BTRFS_SEND_A_CLONE_LEN = 24,
	BTRFS_SEND_A_MAX_V1 = 24,
	BTRFS_SEND_A_FALLOCATE_MODE = 25,
	BTRFS_SEND_A_FILEATTR = 26,
	BTRFS_SEND_A_UNENCODED_FILE_LEN = 27,
	BTRFS_SEND_A_UNENCODED_LEN = 28,
	BTRFS_SEND_A_UNENCODED_OFFSET = 29,
	BTRFS_SEND_A_COMPRESSION = 30,
	BTRFS_SEND_A_ENCRYPTION = 31,
	BTRFS_SEND_A_MAX_V2 = 31,
	BTRFS_SEND_A_VERITY_ALGORITHM = 32,
	BTRFS_SEND_A_VERITY_BLOCK_SIZE = 33,
	BTRFS_SEND_A_VERITY_SALT_DATA = 34,
	BTRFS_SEND_A_VERITY_SIG_DATA = 35,
	BTRFS_SEND_A_MAX_V3 = 35,
	__BTRFS_SEND_A_MAX = 35,
};

enum {
	BTRFS_STAT_CURR = 0,
	BTRFS_STAT_PREV = 1,
	BTRFS_STAT_NR_ENTRIES = 2,
};

enum {
	BTS_STATE_STOPPED = 0,
	BTS_STATE_INACTIVE = 1,
	BTS_STATE_ACTIVE = 2,
};

enum {
	Blktrace_setup = 1,
	Blktrace_running = 2,
	Blktrace_stopped = 3,
};

enum {
	CACHE_VALID = 0,
	CACHE_NEGATIVE = 1,
	CACHE_PENDING = 2,
	CACHE_CLEANED = 3,
};

enum {
	CAKE_ACK_NONE = 0,
	CAKE_ACK_FILTER = 1,
	CAKE_ACK_AGGRESSIVE = 2,
	CAKE_ACK_MAX = 3,
};

enum {
	CAKE_ATM_NONE = 0,
	CAKE_ATM_ATM = 1,
	CAKE_ATM_PTM = 2,
	CAKE_ATM_MAX = 3,
};

enum {
	CAKE_DIFFSERV_DIFFSERV3 = 0,
	CAKE_DIFFSERV_DIFFSERV4 = 1,
	CAKE_DIFFSERV_DIFFSERV8 = 2,
	CAKE_DIFFSERV_BESTEFFORT = 3,
	CAKE_DIFFSERV_PRECEDENCE = 4,
	CAKE_DIFFSERV_MAX = 5,
};

enum {
	CAKE_FLAG_OVERHEAD = 1,
	CAKE_FLAG_AUTORATE_INGRESS = 2,
	CAKE_FLAG_INGRESS = 4,
	CAKE_FLAG_WASH = 8,
	CAKE_FLAG_SPLIT_GSO = 16,
};

enum {
	CAKE_FLOW_NONE = 0,
	CAKE_FLOW_SRC_IP = 1,
	CAKE_FLOW_DST_IP = 2,
	CAKE_FLOW_HOSTS = 3,
	CAKE_FLOW_FLOWS = 4,
	CAKE_FLOW_DUAL_SRC = 5,
	CAKE_FLOW_DUAL_DST = 6,
	CAKE_FLOW_TRIPLE = 7,
	CAKE_FLOW_MAX = 8,
};

enum {
	CAKE_SET_NONE = 0,
	CAKE_SET_SPARSE = 1,
	CAKE_SET_SPARSE_WAIT = 2,
	CAKE_SET_BULK = 3,
	CAKE_SET_DECAYING = 4,
};

enum {
	CARDBUS_TYPE_DEFAULT = -1,
	CARDBUS_TYPE_TI = 0,
	CARDBUS_TYPE_TI113X = 1,
	CARDBUS_TYPE_TI12XX = 2,
	CARDBUS_TYPE_TI1250 = 3,
	CARDBUS_TYPE_RICOH = 4,
	CARDBUS_TYPE_TOPIC95 = 5,
	CARDBUS_TYPE_TOPIC97 = 6,
	CARDBUS_TYPE_O2MICRO = 7,
	CARDBUS_TYPE_ENE = 8,
};

enum {
	CFTYPE_ONLY_ON_ROOT = 1,
	CFTYPE_NOT_ON_ROOT = 2,
	CFTYPE_NS_DELEGATABLE = 4,
	CFTYPE_NO_PREFIX = 8,
	CFTYPE_WORLD_WRITABLE = 16,
	CFTYPE_DEBUG = 32,
	__CFTYPE_ONLY_ON_DFL = 65536,
	__CFTYPE_NOT_ON_DFL = 131072,
	__CFTYPE_ADDED = 262144,
};

enum {
	CGROUPSTATS_CMD_ATTR_UNSPEC = 0,
	CGROUPSTATS_CMD_ATTR_FD = 1,
	__CGROUPSTATS_CMD_ATTR_MAX = 2,
};

enum {
	CGROUPSTATS_CMD_UNSPEC = 3,
	CGROUPSTATS_CMD_GET = 4,
	CGROUPSTATS_CMD_NEW = 5,
	__CGROUPSTATS_CMD_MAX = 6,
};

enum {
	CGROUPSTATS_TYPE_UNSPEC = 0,
	CGROUPSTATS_TYPE_CGROUP_STATS = 1,
	__CGROUPSTATS_TYPE_MAX = 2,
};

enum {
	CGRP_NOTIFY_ON_RELEASE = 0,
	CGRP_CPUSET_CLONE_CHILDREN = 1,
	CGRP_FREEZE = 2,
	CGRP_FROZEN = 3,
};

enum {
	CGRP_ROOT_NOPREFIX = 2,
	CGRP_ROOT_XATTR = 4,
	CGRP_ROOT_NS_DELEGATE = 8,
	CGRP_ROOT_FAVOR_DYNMODS = 16,
	CGRP_ROOT_CPUSET_V2_MODE = 65536,
	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 131072,
	CGRP_ROOT_MEMORY_RECURSIVE_PROT = 262144,
	CGRP_ROOT_MEMORY_HUGETLB_ACCOUNTING = 524288,
	CGRP_ROOT_PIDS_LOCAL_EVENTS = 1048576,
};

enum {
	CLEAR_RESIDUALS = 0,
};

enum {
	CLUSTER_KEY = 1,
	PER_NODE_KEY = 2,
};

enum {
	CMIS_MODULE_LOW_PWR = 1,
	CMIS_MODULE_READY = 3,
};

enum {
	CONNSECMARK_SAVE = 1,
	CONNSECMARK_RESTORE = 2,
};

enum {
	COST_CTRL = 0,
	COST_MODEL = 1,
	NR_COST_CTRL_PARAMS = 2,
};

enum {
	CRNG_EMPTY = 0,
	CRNG_EARLY = 1,
	CRNG_READY = 2,
};

enum {
	CRNG_RESEED_START_INTERVAL = 1000,
	CRNG_RESEED_INTERVAL = 60000,
};

enum {
	CRYPTOA_UNSPEC = 0,
	CRYPTOA_ALG = 1,
	CRYPTOA_TYPE = 2,
	__CRYPTOA_MAX = 3,
};

enum {
	CRYPTO_AUTHENC_KEYA_UNSPEC = 0,
	CRYPTO_AUTHENC_KEYA_PARAM = 1,
};

enum {
	CRYPTO_KPP_SECRET_TYPE_UNKNOWN = 0,
	CRYPTO_KPP_SECRET_TYPE_DH = 1,
	CRYPTO_KPP_SECRET_TYPE_ECDH = 2,
};

enum {
	CRYPTO_MSG_ALG_REQUEST = 0,
	CRYPTO_MSG_ALG_REGISTER = 1,
	CRYPTO_MSG_ALG_LOADED = 2,
};

enum {
	CSD_FLAG_LOCK = 1,
	IRQ_WORK_PENDING = 1,
	IRQ_WORK_BUSY = 2,
	IRQ_WORK_LAZY = 4,
	IRQ_WORK_HARD_IRQ = 8,
	IRQ_WORK_CLAIMED = 3,
	CSD_TYPE_ASYNC = 0,
	CSD_TYPE_SYNC = 16,
	CSD_TYPE_IRQ_WORK = 32,
	CSD_TYPE_TTWU = 48,
	CSD_FLAG_TYPE_MASK = 240,
};

enum {
	CSI_DEC_hl_CURSOR_KEYS = 1,
	CSI_DEC_hl_132_COLUMNS = 3,
	CSI_DEC_hl_REVERSE_VIDEO = 5,
	CSI_DEC_hl_ORIGIN_MODE = 6,
	CSI_DEC_hl_AUTOWRAP = 7,
	CSI_DEC_hl_AUTOREPEAT = 8,
	CSI_DEC_hl_MOUSE_X10 = 9,
	CSI_DEC_hl_SHOW_CURSOR = 25,
	CSI_DEC_hl_MOUSE_VT200 = 1000,
};

enum {
	CSI_K_CURSOR_TO_LINEEND = 0,
	CSI_K_LINESTART_TO_CURSOR = 1,
	CSI_K_LINE = 2,
};

enum {
	CSI_hl_DISPLAY_CTRL = 3,
	CSI_hl_INSERT = 4,
	CSI_hl_AUTO_NL = 20,
};

enum {
	CSI_m_DEFAULT = 0,
	CSI_m_BOLD = 1,
	CSI_m_HALF_BRIGHT = 2,
	CSI_m_ITALIC = 3,
	CSI_m_UNDERLINE = 4,
	CSI_m_BLINK = 5,
	CSI_m_REVERSE = 7,
	CSI_m_PRI_FONT = 10,
	CSI_m_ALT_FONT1 = 11,
	CSI_m_ALT_FONT2 = 12,
	CSI_m_DOUBLE_UNDERLINE = 21,
	CSI_m_NORMAL_INTENSITY = 22,
	CSI_m_NO_ITALIC = 23,
	CSI_m_NO_UNDERLINE = 24,
	CSI_m_NO_BLINK = 25,
	CSI_m_NO_REVERSE = 27,
	CSI_m_FG_COLOR_BEG = 30,
	CSI_m_FG_COLOR_END = 37,
	CSI_m_FG_COLOR = 38,
	CSI_m_DEFAULT_FG_COLOR = 39,
	CSI_m_BG_COLOR_BEG = 40,
	CSI_m_BG_COLOR_END = 47,
	CSI_m_BG_COLOR = 48,
	CSI_m_DEFAULT_BG_COLOR = 49,
	CSI_m_BRIGHT_FG_COLOR_BEG = 90,
	CSI_m_BRIGHT_FG_COLOR_END = 97,
	CSI_m_BRIGHT_FG_COLOR_OFF = 60,
	CSI_m_BRIGHT_BG_COLOR_BEG = 100,
	CSI_m_BRIGHT_BG_COLOR_END = 107,
	CSI_m_BRIGHT_BG_COLOR_OFF = 60,
};

enum {
	CSS_NO_REF = 1,
	CSS_ONLINE = 2,
	CSS_RELEASED = 4,
	CSS_VISIBLE = 8,
	CSS_DYING = 16,
};

enum {
	CSS_TASK_ITER_PROCS = 1,
	CSS_TASK_ITER_THREADED = 2,
	CSS_TASK_ITER_SKIPPED = 65536,
};

enum {
	CTINFO_MODE_DSCP = 1,
	CTINFO_MODE_CPMARK = 2,
};

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
	CTRL_ATTR_MCAST_GRP_NAME = 1,
	CTRL_ATTR_MCAST_GRP_ID = 2,
	__CTRL_ATTR_MCAST_GRP_MAX = 3,
};

enum {
	CTRL_ATTR_OP_UNSPEC = 0,
	CTRL_ATTR_OP_ID = 1,
	CTRL_ATTR_OP_FLAGS = 2,
	__CTRL_ATTR_OP_MAX = 3,
};

enum {
	CTRL_ATTR_POLICY_UNSPEC = 0,
	CTRL_ATTR_POLICY_DO = 1,
	CTRL_ATTR_POLICY_DUMP = 2,
	__CTRL_ATTR_POLICY_DUMP_MAX = 3,
	CTRL_ATTR_POLICY_DUMP_MAX = 2,
};

enum {
	CTRL_ATTR_UNSPEC = 0,
	CTRL_ATTR_FAMILY_ID = 1,
	CTRL_ATTR_FAMILY_NAME = 2,
	CTRL_ATTR_VERSION = 3,
	CTRL_ATTR_HDRSIZE = 4,
	CTRL_ATTR_MAXATTR = 5,
	CTRL_ATTR_OPS = 6,
	CTRL_ATTR_MCAST_GROUPS = 7,
	CTRL_ATTR_POLICY = 8,
	CTRL_ATTR_OP_POLICY = 9,
	CTRL_ATTR_OP = 10,
	__CTRL_ATTR_MAX = 11,
};

enum {
	CTRL_CMD_UNSPEC = 0,
	CTRL_CMD_NEWFAMILY = 1,
	CTRL_CMD_DELFAMILY = 2,
	CTRL_CMD_GETFAMILY = 3,
	CTRL_CMD_NEWOPS = 4,
	CTRL_CMD_DELOPS = 5,
	CTRL_CMD_GETOPS = 6,
	CTRL_CMD_NEWMCAST_GRP = 7,
	CTRL_CMD_DELMCAST_GRP = 8,
	CTRL_CMD_GETMCAST_GRP = 9,
	CTRL_CMD_GETPOLICY = 10,
	__CTRL_CMD_MAX = 11,
};

enum {
	DAD_PROCESS = 0,
	DAD_BEGIN = 1,
	DAD_ABORT = 2,
};

enum {
	DCCPC_CCID2 = 2,
	DCCPC_CCID3 = 3,
};

enum {
	DCCPF_OPEN = 2,
	DCCPF_REQUESTING = 4,
	DCCPF_LISTEN = 1024,
	DCCPF_RESPOND = 8,
	DCCPF_ACTIVE_CLOSEREQ = 16,
	DCCPF_CLOSING = 2048,
	DCCPF_TIME_WAIT = 64,
	DCCPF_CLOSED = 128,
	DCCPF_NEW_SYN_RECV = 4096,
	DCCPF_PARTOPEN = 16384,
};

enum {
	DCCPO_PADDING = 0,
	DCCPO_MANDATORY = 1,
	DCCPO_MIN_RESERVED = 3,
	DCCPO_MAX_RESERVED = 31,
	DCCPO_CHANGE_L = 32,
	DCCPO_CONFIRM_L = 33,
	DCCPO_CHANGE_R = 34,
	DCCPO_CONFIRM_R = 35,
	DCCPO_NDP_COUNT = 37,
	DCCPO_ACK_VECTOR_0 = 38,
	DCCPO_ACK_VECTOR_1 = 39,
	DCCPO_TIMESTAMP = 41,
	DCCPO_TIMESTAMP_ECHO = 42,
	DCCPO_ELAPSED_TIME = 43,
	DCCPO_MAX = 45,
	DCCPO_MIN_RX_CCID_SPECIFIC = 128,
	DCCPO_MAX_RX_CCID_SPECIFIC = 191,
	DCCPO_MIN_TX_CCID_SPECIFIC = 192,
	DCCPO_MAX_TX_CCID_SPECIFIC = 255,
};

enum {
	DCCP_MIB_NUM = 0,
	DCCP_MIB_ACTIVEOPENS = 1,
	DCCP_MIB_ESTABRESETS = 2,
	DCCP_MIB_CURRESTAB = 3,
	DCCP_MIB_OUTSEGS = 4,
	DCCP_MIB_OUTRSTS = 5,
	DCCP_MIB_ABORTONTIMEOUT = 6,
	DCCP_MIB_TIMEOUTS = 7,
	DCCP_MIB_ABORTFAILED = 8,
	DCCP_MIB_PASSIVEOPENS = 9,
	DCCP_MIB_ATTEMPTFAILS = 10,
	DCCP_MIB_OUTDATAGRAMS = 11,
	DCCP_MIB_INERRS = 12,
	DCCP_MIB_OPTMANDATORYERROR = 13,
	DCCP_MIB_INVALIDOPT = 14,
	__DCCP_MIB_MAX = 15,
};

enum {
	DD_DIR_COUNT = 2,
};

enum {
	DD_PRIO_COUNT = 3,
};

enum {
	DEBUG_FENCE_IDLE = 0,
	DEBUG_FENCE_NOTIFY = 1,
};

enum {
	DELL_INSPIRON_7375 = 0,
	DELL_LATITUDE_5495 = 1,
	LENOVO_IDEAPAD_330S_15ARR = 2,
};

enum {
	DESC_TSS = 9,
	DESC_LDT = 2,
	DESCTYPE_S = 16,
};

enum {
	DEVCONF_FORWARDING = 0,
	DEVCONF_HOPLIMIT = 1,
	DEVCONF_MTU6 = 2,
	DEVCONF_ACCEPT_RA = 3,
	DEVCONF_ACCEPT_REDIRECTS = 4,
	DEVCONF_AUTOCONF = 5,
	DEVCONF_DAD_TRANSMITS = 6,
	DEVCONF_RTR_SOLICITS = 7,
	DEVCONF_RTR_SOLICIT_INTERVAL = 8,
	DEVCONF_RTR_SOLICIT_DELAY = 9,
	DEVCONF_USE_TEMPADDR = 10,
	DEVCONF_TEMP_VALID_LFT = 11,
	DEVCONF_TEMP_PREFERED_LFT = 12,
	DEVCONF_REGEN_MAX_RETRY = 13,
	DEVCONF_MAX_DESYNC_FACTOR = 14,
	DEVCONF_MAX_ADDRESSES = 15,
	DEVCONF_FORCE_MLD_VERSION = 16,
	DEVCONF_ACCEPT_RA_DEFRTR = 17,
	DEVCONF_ACCEPT_RA_PINFO = 18,
	DEVCONF_ACCEPT_RA_RTR_PREF = 19,
	DEVCONF_RTR_PROBE_INTERVAL = 20,
	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN = 21,
	DEVCONF_PROXY_NDP = 22,
	DEVCONF_OPTIMISTIC_DAD = 23,
	DEVCONF_ACCEPT_SOURCE_ROUTE = 24,
	DEVCONF_MC_FORWARDING = 25,
	DEVCONF_DISABLE_IPV6 = 26,
	DEVCONF_ACCEPT_DAD = 27,
	DEVCONF_FORCE_TLLAO = 28,
	DEVCONF_NDISC_NOTIFY = 29,
	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL = 30,
	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL = 31,
	DEVCONF_SUPPRESS_FRAG_NDISC = 32,
	DEVCONF_ACCEPT_RA_FROM_LOCAL = 33,
	DEVCONF_USE_OPTIMISTIC = 34,
	DEVCONF_ACCEPT_RA_MTU = 35,
	DEVCONF_STABLE_SECRET = 36,
	DEVCONF_USE_OIF_ADDRS_ONLY = 37,
	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT = 38,
	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 39,
	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 40,
	DEVCONF_DROP_UNSOLICITED_NA = 41,
	DEVCONF_KEEP_ADDR_ON_DOWN = 42,
	DEVCONF_RTR_SOLICIT_MAX_INTERVAL = 43,
	DEVCONF_SEG6_ENABLED = 44,
	DEVCONF_SEG6_REQUIRE_HMAC = 45,
	DEVCONF_ENHANCED_DAD = 46,
	DEVCONF_ADDR_GEN_MODE = 47,
	DEVCONF_DISABLE_POLICY = 48,
	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN = 49,
	DEVCONF_NDISC_TCLASS = 50,
	DEVCONF_RPL_SEG_ENABLED = 51,
	DEVCONF_RA_DEFRTR_METRIC = 52,
	DEVCONF_IOAM6_ENABLED = 53,
	DEVCONF_IOAM6_ID = 54,
	DEVCONF_IOAM6_ID_WIDE = 55,
	DEVCONF_NDISC_EVICT_NOCARRIER = 56,
	DEVCONF_ACCEPT_UNTRACKED_NA = 57,
	DEVCONF_ACCEPT_RA_MIN_LFT = 58,
	DEVCONF_MAX = 59,
};

enum {
	DIO_LOCKING = 1,
	DIO_SKIP_HOLES = 2,
};

enum {
	DIO_SHOULD_DIRTY = 1,
	DIO_IS_SYNC = 2,
};

enum {
	DIR_OFFSET_FIRST = 2,
	DIR_OFFSET_EOD = 2147483647,
};

enum {
	DIR_OFFSET_MIN = 3,
	DIR_OFFSET_MAX = 2147483646,
};

enum {
	DISCOVERED = 16,
	EXPLORED = 32,
	FALLTHROUGH = 1,
	BRANCH = 2,
};

enum {
	DISK_EVENT_FLAG_POLL = 1,
	DISK_EVENT_FLAG_UEVENT = 2,
	DISK_EVENT_FLAG_BLOCK_ON_EXCL_WRITE = 4,
};

enum {
	DISK_EVENT_MEDIA_CHANGE = 1,
	DISK_EVENT_EJECT_REQUEST = 2,
};

enum {
	DMA_DSCR_HOST = 0,
	DMA_DSCR_DEVICE = 1,
	DMA_DSCR_CTRL = 2,
	DMA_DSCR_NUM = 3,
};

enum {
	DMA_FENCE_WORK_IMM = 3,
};

enum {
	DM_IO_ACCOUNTED = 0,
	DM_IO_WAS_SPLIT = 1,
	DM_IO_BLK_STAT = 2,
};

enum {
	DM_TIO_INSIDE_DM_IO = 0,
	DM_TIO_IS_DUPLICATE_BIO = 1,
};

enum {
	DM_VERSION_CMD = 0,
	DM_REMOVE_ALL_CMD = 1,
	DM_LIST_DEVICES_CMD = 2,
	DM_DEV_CREATE_CMD = 3,
	DM_DEV_REMOVE_CMD = 4,
	DM_DEV_RENAME_CMD = 5,
	DM_DEV_SUSPEND_CMD = 6,
	DM_DEV_STATUS_CMD = 7,
	DM_DEV_WAIT_CMD = 8,
	DM_TABLE_LOAD_CMD = 9,
	DM_TABLE_CLEAR_CMD = 10,
	DM_TABLE_DEPS_CMD = 11,
	DM_TABLE_STATUS_CMD = 12,
	DM_LIST_VERSIONS_CMD = 13,
	DM_TARGET_MSG_CMD = 14,
	DM_DEV_SET_GEOMETRY_CMD = 15,
	DM_DEV_ARM_POLL_CMD = 16,
	DM_GET_TARGET_VERSION_CMD = 17,
};

enum {
	DONE_EXPLORING = 0,
	KEEP_EXPLORING = 1,
};

enum {
	DQF_INFO_DIRTY_B = 17,
};

enum {
	DQF_ROOT_SQUASH_B = 0,
	DQF_SYS_FILE_B = 16,
	DQF_PRIVATE = 17,
};

enum {
	DQST_LOOKUPS = 0,
	DQST_DROPS = 1,
	DQST_READS = 2,
	DQST_WRITES = 3,
	DQST_CACHE_HITS = 4,
	DQST_ALLOC_DQUOTS = 5,
	DQST_FREE_DQUOTS = 6,
	DQST_SYNCS = 7,
	_DQST_DQSTAT_LAST = 8,
};

enum {
	DSE_FIRST = 2039,
	SECONDS_PER_DAY = 86400,
};

enum {
	DUMP_PREFIX_NONE = 0,
	DUMP_PREFIX_ADDRESS = 1,
	DUMP_PREFIX_OFFSET = 2,
};

enum {
	D_SHIFT_LEFT = 0,
	D_SHIFT_RIGHT = 1,
};

enum {
	EC_FLAGS_QUERY_ENABLED = 0,
	EC_FLAGS_EVENT_HANDLER_INSTALLED = 1,
	EC_FLAGS_EC_HANDLER_INSTALLED = 2,
	EC_FLAGS_EC_REG_CALLED = 3,
	EC_FLAGS_QUERY_METHODS_INSTALLED = 4,
	EC_FLAGS_STARTED = 5,
	EC_FLAGS_STOPPED = 6,
	EC_FLAGS_EVENTS_MASKED = 7,
};

enum {
	EMULATE = 0,
	XONLY = 1,
	NONE = 2,
};

enum {
	EPecma = 0,
	EPdec = 1,
	EPeq = 2,
	EPgt = 3,
	EPlt = 4,
};

enum {
	ERASE = 0,
	WERASE = 1,
	KILL = 2,
};

enum {
	ES_WRITTEN_B = 0,
	ES_UNWRITTEN_B = 1,
	ES_DELAYED_B = 2,
	ES_HOLE_B = 3,
	ES_REFERENCED_B = 4,
	ES_FLAGS = 5,
};

enum {
	ETHTOOL_A_BITSET_BITS_UNSPEC = 0,
	ETHTOOL_A_BITSET_BITS_BIT = 1,
	__ETHTOOL_A_BITSET_BITS_CNT = 2,
	ETHTOOL_A_BITSET_BITS_MAX = 1,
};

enum {
	ETHTOOL_A_BITSET_BIT_UNSPEC = 0,
	ETHTOOL_A_BITSET_BIT_INDEX = 1,
	ETHTOOL_A_BITSET_BIT_NAME = 2,
	ETHTOOL_A_BITSET_BIT_VALUE = 3,
	__ETHTOOL_A_BITSET_BIT_CNT = 4,
	ETHTOOL_A_BITSET_BIT_MAX = 3,
};

enum {
	ETHTOOL_A_BITSET_UNSPEC = 0,
	ETHTOOL_A_BITSET_NOMASK = 1,
	ETHTOOL_A_BITSET_SIZE = 2,
	ETHTOOL_A_BITSET_BITS = 3,
	ETHTOOL_A_BITSET_VALUE = 4,
	ETHTOOL_A_BITSET_MASK = 5,
	__ETHTOOL_A_BITSET_CNT = 6,
	ETHTOOL_A_BITSET_MAX = 5,
};

enum {
	ETHTOOL_A_C33_PSE_PW_LIMIT_UNSPEC = 0,
	ETHTOOL_A_C33_PSE_PW_LIMIT_MIN = 1,
	ETHTOOL_A_C33_PSE_PW_LIMIT_MAX = 2,
	__ETHTOOL_A_C33_PSE_PW_LIMIT_CNT = 3,
	__ETHTOOL_A_C33_PSE_PW_LIMIT_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC = 0,
	ETHTOOL_A_CABLE_AMPLITUDE_PAIR = 1,
	ETHTOOL_A_CABLE_AMPLITUDE_mV = 2,
	__ETHTOOL_A_CABLE_AMPLITUDE_CNT = 3,
	ETHTOOL_A_CABLE_AMPLITUDE_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC = 0,
	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR = 1,
	ETHTOOL_A_CABLE_FAULT_LENGTH_CM = 2,
	ETHTOOL_A_CABLE_FAULT_LENGTH_SRC = 3,
	__ETHTOOL_A_CABLE_FAULT_LENGTH_CNT = 4,
	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_INF_SRC_UNSPEC = 0,
	ETHTOOL_A_CABLE_INF_SRC_TDR = 1,
	ETHTOOL_A_CABLE_INF_SRC_ALCD = 2,
};

enum {
	ETHTOOL_A_CABLE_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_NEST_RESULT = 1,
	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH = 2,
	__ETHTOOL_A_CABLE_NEST_CNT = 3,
	ETHTOOL_A_CABLE_NEST_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_PAIR_A = 0,
	ETHTOOL_A_CABLE_PAIR_B = 1,
	ETHTOOL_A_CABLE_PAIR_C = 2,
	ETHTOOL_A_CABLE_PAIR_D = 3,
};

enum {
	ETHTOOL_A_CABLE_PULSE_UNSPEC = 0,
	ETHTOOL_A_CABLE_PULSE_mV = 1,
	__ETHTOOL_A_CABLE_PULSE_CNT = 2,
	ETHTOOL_A_CABLE_PULSE_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_RESULT_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_PAIR = 1,
	ETHTOOL_A_CABLE_RESULT_CODE = 2,
	ETHTOOL_A_CABLE_RESULT_SRC = 3,
	__ETHTOOL_A_CABLE_RESULT_CNT = 4,
	ETHTOOL_A_CABLE_RESULT_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_STEP_UNSPEC = 0,
	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE = 1,
	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE = 2,
	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE = 3,
	__ETHTOOL_A_CABLE_STEP_CNT = 4,
	ETHTOOL_A_CABLE_STEP_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TDR_NEST_STEP = 1,
	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE = 2,
	ETHTOOL_A_CABLE_TDR_NEST_PULSE = 3,
	__ETHTOOL_A_CABLE_TDR_NEST_CNT = 4,
	ETHTOOL_A_CABLE_TDR_NEST_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS = 2,
	ETHTOOL_A_CABLE_TEST_NTF_NEST = 3,
	__ETHTOOL_A_CABLE_TEST_NTF_CNT = 4,
	ETHTOOL_A_CABLE_TEST_NTF_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST = 2,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP = 3,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR = 4,
	__ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT = 5,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX = 4,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG = 2,
	__ETHTOOL_A_CABLE_TEST_TDR_CNT = 3,
	ETHTOOL_A_CABLE_TEST_TDR_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_HEADER = 1,
	__ETHTOOL_A_CABLE_TEST_CNT = 2,
	ETHTOOL_A_CABLE_TEST_MAX = 1,
};

enum {
	ETHTOOL_A_CHANNELS_UNSPEC = 0,
	ETHTOOL_A_CHANNELS_HEADER = 1,
	ETHTOOL_A_CHANNELS_RX_MAX = 2,
	ETHTOOL_A_CHANNELS_TX_MAX = 3,
	ETHTOOL_A_CHANNELS_OTHER_MAX = 4,
	ETHTOOL_A_CHANNELS_COMBINED_MAX = 5,
	ETHTOOL_A_CHANNELS_RX_COUNT = 6,
	ETHTOOL_A_CHANNELS_TX_COUNT = 7,
	ETHTOOL_A_CHANNELS_OTHER_COUNT = 8,
	ETHTOOL_A_CHANNELS_COMBINED_COUNT = 9,
	__ETHTOOL_A_CHANNELS_CNT = 10,
	ETHTOOL_A_CHANNELS_MAX = 9,
};

enum {
	ETHTOOL_A_COALESCE_UNSPEC = 0,
	ETHTOOL_A_COALESCE_HEADER = 1,
	ETHTOOL_A_COALESCE_RX_USECS = 2,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES = 3,
	ETHTOOL_A_COALESCE_RX_USECS_IRQ = 4,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ = 5,
	ETHTOOL_A_COALESCE_TX_USECS = 6,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES = 7,
	ETHTOOL_A_COALESCE_TX_USECS_IRQ = 8,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ = 9,
	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS = 10,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX = 11,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX = 12,
	ETHTOOL_A_COALESCE_PKT_RATE_LOW = 13,
	ETHTOOL_A_COALESCE_RX_USECS_LOW = 14,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW = 15,
	ETHTOOL_A_COALESCE_TX_USECS_LOW = 16,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW = 17,
	ETHTOOL_A_COALESCE_PKT_RATE_HIGH = 18,
	ETHTOOL_A_COALESCE_RX_USECS_HIGH = 19,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH = 20,
	ETHTOOL_A_COALESCE_TX_USECS_HIGH = 21,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH = 22,
	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 23,
	ETHTOOL_A_COALESCE_USE_CQE_MODE_TX = 24,
	ETHTOOL_A_COALESCE_USE_CQE_MODE_RX = 25,
	ETHTOOL_A_COALESCE_TX_AGGR_MAX_BYTES = 26,
	ETHTOOL_A_COALESCE_TX_AGGR_MAX_FRAMES = 27,
	ETHTOOL_A_COALESCE_TX_AGGR_TIME_USECS = 28,
	ETHTOOL_A_COALESCE_RX_PROFILE = 29,
	ETHTOOL_A_COALESCE_TX_PROFILE = 30,
	__ETHTOOL_A_COALESCE_CNT = 31,
	ETHTOOL_A_COALESCE_MAX = 30,
};

enum {
	ETHTOOL_A_DEBUG_UNSPEC = 0,
	ETHTOOL_A_DEBUG_HEADER = 1,
	ETHTOOL_A_DEBUG_MSGMASK = 2,
	__ETHTOOL_A_DEBUG_CNT = 3,
	ETHTOOL_A_DEBUG_MAX = 2,
};

enum {
	ETHTOOL_A_EEE_UNSPEC = 0,
	ETHTOOL_A_EEE_HEADER = 1,
	ETHTOOL_A_EEE_MODES_OURS = 2,
	ETHTOOL_A_EEE_MODES_PEER = 3,
	ETHTOOL_A_EEE_ACTIVE = 4,
	ETHTOOL_A_EEE_ENABLED = 5,
	ETHTOOL_A_EEE_TX_LPI_ENABLED = 6,
	ETHTOOL_A_EEE_TX_LPI_TIMER = 7,
	__ETHTOOL_A_EEE_CNT = 8,
	ETHTOOL_A_EEE_MAX = 7,
};

enum {
	ETHTOOL_A_FEATURES_UNSPEC = 0,
	ETHTOOL_A_FEATURES_HEADER = 1,
	ETHTOOL_A_FEATURES_HW = 2,
	ETHTOOL_A_FEATURES_WANTED = 3,
	ETHTOOL_A_FEATURES_ACTIVE = 4,
	ETHTOOL_A_FEATURES_NOCHANGE = 5,
	__ETHTOOL_A_FEATURES_CNT = 6,
	ETHTOOL_A_FEATURES_MAX = 5,
};

enum {
	ETHTOOL_A_FEC_STAT_UNSPEC = 0,
	ETHTOOL_A_FEC_STAT_PAD = 1,
	ETHTOOL_A_FEC_STAT_CORRECTED = 2,
	ETHTOOL_A_FEC_STAT_UNCORR = 3,
	ETHTOOL_A_FEC_STAT_CORR_BITS = 4,
	__ETHTOOL_A_FEC_STAT_CNT = 5,
	ETHTOOL_A_FEC_STAT_MAX = 4,
};

enum {
	ETHTOOL_A_FEC_UNSPEC = 0,
	ETHTOOL_A_FEC_HEADER = 1,
	ETHTOOL_A_FEC_MODES = 2,
	ETHTOOL_A_FEC_AUTO = 3,
	ETHTOOL_A_FEC_ACTIVE = 4,
	ETHTOOL_A_FEC_STATS = 5,
	__ETHTOOL_A_FEC_CNT = 6,
	ETHTOOL_A_FEC_MAX = 5,
};

enum {
	ETHTOOL_A_HEADER_UNSPEC = 0,
	ETHTOOL_A_HEADER_DEV_INDEX = 1,
	ETHTOOL_A_HEADER_DEV_NAME = 2,
	ETHTOOL_A_HEADER_FLAGS = 3,
	ETHTOOL_A_HEADER_PHY_INDEX = 4,
	__ETHTOOL_A_HEADER_CNT = 5,
	ETHTOOL_A_HEADER_MAX = 4,
};

enum {
	ETHTOOL_A_IRQ_MODERATION_UNSPEC = 0,
	ETHTOOL_A_IRQ_MODERATION_USEC = 1,
	ETHTOOL_A_IRQ_MODERATION_PKTS = 2,
	ETHTOOL_A_IRQ_MODERATION_COMPS = 3,
	__ETHTOOL_A_IRQ_MODERATION_CNT = 4,
	ETHTOOL_A_IRQ_MODERATION_MAX = 3,
};

enum {
	ETHTOOL_A_LINKINFO_UNSPEC = 0,
	ETHTOOL_A_LINKINFO_HEADER = 1,
	ETHTOOL_A_LINKINFO_PORT = 2,
	ETHTOOL_A_LINKINFO_PHYADDR = 3,
	ETHTOOL_A_LINKINFO_TP_MDIX = 4,
	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL = 5,
	ETHTOOL_A_LINKINFO_TRANSCEIVER = 6,
	__ETHTOOL_A_LINKINFO_CNT = 7,
	ETHTOOL_A_LINKINFO_MAX = 6,
};

enum {
	ETHTOOL_A_LINKMODES_UNSPEC = 0,
	ETHTOOL_A_LINKMODES_HEADER = 1,
	ETHTOOL_A_LINKMODES_AUTONEG = 2,
	ETHTOOL_A_LINKMODES_OURS = 3,
	ETHTOOL_A_LINKMODES_PEER = 4,
	ETHTOOL_A_LINKMODES_SPEED = 5,
	ETHTOOL_A_LINKMODES_DUPLEX = 6,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG = 7,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 8,
	ETHTOOL_A_LINKMODES_LANES = 9,
	ETHTOOL_A_LINKMODES_RATE_MATCHING = 10,
	__ETHTOOL_A_LINKMODES_CNT = 11,
	ETHTOOL_A_LINKMODES_MAX = 10,
};

enum {
	ETHTOOL_A_LINKSTATE_UNSPEC = 0,
	ETHTOOL_A_LINKSTATE_HEADER = 1,
	ETHTOOL_A_LINKSTATE_LINK = 2,
	ETHTOOL_A_LINKSTATE_SQI = 3,
	ETHTOOL_A_LINKSTATE_SQI_MAX = 4,
	ETHTOOL_A_LINKSTATE_EXT_STATE = 5,
	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE = 6,
	ETHTOOL_A_LINKSTATE_EXT_DOWN_CNT = 7,
	__ETHTOOL_A_LINKSTATE_CNT = 8,
	ETHTOOL_A_LINKSTATE_MAX = 7,
};

enum {
	ETHTOOL_A_MM_STAT_UNSPEC = 0,
	ETHTOOL_A_MM_STAT_PAD = 1,
	ETHTOOL_A_MM_STAT_REASSEMBLY_ERRORS = 2,
	ETHTOOL_A_MM_STAT_SMD_ERRORS = 3,
	ETHTOOL_A_MM_STAT_REASSEMBLY_OK = 4,
	ETHTOOL_A_MM_STAT_RX_FRAG_COUNT = 5,
	ETHTOOL_A_MM_STAT_TX_FRAG_COUNT = 6,
	ETHTOOL_A_MM_STAT_HOLD_COUNT = 7,
	__ETHTOOL_A_MM_STAT_CNT = 8,
	ETHTOOL_A_MM_STAT_MAX = 7,
};

enum {
	ETHTOOL_A_MM_UNSPEC = 0,
	ETHTOOL_A_MM_HEADER = 1,
	ETHTOOL_A_MM_PMAC_ENABLED = 2,
	ETHTOOL_A_MM_TX_ENABLED = 3,
	ETHTOOL_A_MM_TX_ACTIVE = 4,
	ETHTOOL_A_MM_TX_MIN_FRAG_SIZE = 5,
	ETHTOOL_A_MM_RX_MIN_FRAG_SIZE = 6,
	ETHTOOL_A_MM_VERIFY_ENABLED = 7,
	ETHTOOL_A_MM_VERIFY_STATUS = 8,
	ETHTOOL_A_MM_VERIFY_TIME = 9,
	ETHTOOL_A_MM_MAX_VERIFY_TIME = 10,
	ETHTOOL_A_MM_STATS = 11,
	__ETHTOOL_A_MM_CNT = 12,
	ETHTOOL_A_MM_MAX = 11,
};

enum {
	ETHTOOL_A_MODULE_EEPROM_UNSPEC = 0,
	ETHTOOL_A_MODULE_EEPROM_HEADER = 1,
	ETHTOOL_A_MODULE_EEPROM_OFFSET = 2,
	ETHTOOL_A_MODULE_EEPROM_LENGTH = 3,
	ETHTOOL_A_MODULE_EEPROM_PAGE = 4,
	ETHTOOL_A_MODULE_EEPROM_BANK = 5,
	ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS = 6,
	ETHTOOL_A_MODULE_EEPROM_DATA = 7,
	__ETHTOOL_A_MODULE_EEPROM_CNT = 8,
	ETHTOOL_A_MODULE_EEPROM_MAX = 7,
};

enum {
	ETHTOOL_A_MODULE_FW_FLASH_UNSPEC = 0,
	ETHTOOL_A_MODULE_FW_FLASH_HEADER = 1,
	ETHTOOL_A_MODULE_FW_FLASH_FILE_NAME = 2,
	ETHTOOL_A_MODULE_FW_FLASH_PASSWORD = 3,
	ETHTOOL_A_MODULE_FW_FLASH_STATUS = 4,
	ETHTOOL_A_MODULE_FW_FLASH_STATUS_MSG = 5,
	ETHTOOL_A_MODULE_FW_FLASH_DONE = 6,
	ETHTOOL_A_MODULE_FW_FLASH_TOTAL = 7,
	__ETHTOOL_A_MODULE_FW_FLASH_CNT = 8,
	ETHTOOL_A_MODULE_FW_FLASH_MAX = 7,
};

enum {
	ETHTOOL_A_MODULE_UNSPEC = 0,
	ETHTOOL_A_MODULE_HEADER = 1,
	ETHTOOL_A_MODULE_POWER_MODE_POLICY = 2,
	ETHTOOL_A_MODULE_POWER_MODE = 3,
	__ETHTOOL_A_MODULE_CNT = 4,
	ETHTOOL_A_MODULE_MAX = 3,
};

enum {
	ETHTOOL_A_PAUSE_STAT_UNSPEC = 0,
	ETHTOOL_A_PAUSE_STAT_PAD = 1,
	ETHTOOL_A_PAUSE_STAT_TX_FRAMES = 2,
	ETHTOOL_A_PAUSE_STAT_RX_FRAMES = 3,
	__ETHTOOL_A_PAUSE_STAT_CNT = 4,
	ETHTOOL_A_PAUSE_STAT_MAX = 3,
};

enum {
	ETHTOOL_A_PAUSE_UNSPEC = 0,
	ETHTOOL_A_PAUSE_HEADER = 1,
	ETHTOOL_A_PAUSE_AUTONEG = 2,
	ETHTOOL_A_PAUSE_RX = 3,
	ETHTOOL_A_PAUSE_TX = 4,
	ETHTOOL_A_PAUSE_STATS = 5,
	ETHTOOL_A_PAUSE_STATS_SRC = 6,
	__ETHTOOL_A_PAUSE_CNT = 7,
	ETHTOOL_A_PAUSE_MAX = 6,
};

enum {
	ETHTOOL_A_PHC_VCLOCKS_UNSPEC = 0,
	ETHTOOL_A_PHC_VCLOCKS_HEADER = 1,
	ETHTOOL_A_PHC_VCLOCKS_NUM = 2,
	ETHTOOL_A_PHC_VCLOCKS_INDEX = 3,
	__ETHTOOL_A_PHC_VCLOCKS_CNT = 4,
	ETHTOOL_A_PHC_VCLOCKS_MAX = 3,
};

enum {
	ETHTOOL_A_PHY_UNSPEC = 0,
	ETHTOOL_A_PHY_HEADER = 1,
	ETHTOOL_A_PHY_INDEX = 2,
	ETHTOOL_A_PHY_DRVNAME = 3,
	ETHTOOL_A_PHY_NAME = 4,
	ETHTOOL_A_PHY_UPSTREAM_TYPE = 5,
	ETHTOOL_A_PHY_UPSTREAM_INDEX = 6,
	ETHTOOL_A_PHY_UPSTREAM_SFP_NAME = 7,
	ETHTOOL_A_PHY_DOWNSTREAM_SFP_NAME = 8,
	__ETHTOOL_A_PHY_CNT = 9,
	ETHTOOL_A_PHY_MAX = 8,
};

enum {
	ETHTOOL_A_PLCA_UNSPEC = 0,
	ETHTOOL_A_PLCA_HEADER = 1,
	ETHTOOL_A_PLCA_VERSION = 2,
	ETHTOOL_A_PLCA_ENABLED = 3,
	ETHTOOL_A_PLCA_STATUS = 4,
	ETHTOOL_A_PLCA_NODE_CNT = 5,
	ETHTOOL_A_PLCA_NODE_ID = 6,
	ETHTOOL_A_PLCA_TO_TMR = 7,
	ETHTOOL_A_PLCA_BURST_CNT = 8,
	ETHTOOL_A_PLCA_BURST_TMR = 9,
	__ETHTOOL_A_PLCA_CNT = 10,
	ETHTOOL_A_PLCA_MAX = 9,
};

enum {
	ETHTOOL_A_PRIVFLAGS_UNSPEC = 0,
	ETHTOOL_A_PRIVFLAGS_HEADER = 1,
	ETHTOOL_A_PRIVFLAGS_FLAGS = 2,
	__ETHTOOL_A_PRIVFLAGS_CNT = 3,
	ETHTOOL_A_PRIVFLAGS_MAX = 2,
};

enum {
	ETHTOOL_A_PROFILE_UNSPEC = 0,
	ETHTOOL_A_PROFILE_IRQ_MODERATION = 1,
	__ETHTOOL_A_PROFILE_CNT = 2,
	ETHTOOL_A_PROFILE_MAX = 1,
};

enum {
	ETHTOOL_A_PSE_UNSPEC = 0,
	ETHTOOL_A_PSE_HEADER = 1,
	ETHTOOL_A_PODL_PSE_ADMIN_STATE = 2,
	ETHTOOL_A_PODL_PSE_ADMIN_CONTROL = 3,
	ETHTOOL_A_PODL_PSE_PW_D_STATUS = 4,
	ETHTOOL_A_C33_PSE_ADMIN_STATE = 5,
	ETHTOOL_A_C33_PSE_ADMIN_CONTROL = 6,
	ETHTOOL_A_C33_PSE_PW_D_STATUS = 7,
	ETHTOOL_A_C33_PSE_PW_CLASS = 8,
	ETHTOOL_A_C33_PSE_ACTUAL_PW = 9,
	ETHTOOL_A_C33_PSE_EXT_STATE = 10,
	ETHTOOL_A_C33_PSE_EXT_SUBSTATE = 11,
	ETHTOOL_A_C33_PSE_AVAIL_PW_LIMIT = 12,
	ETHTOOL_A_C33_PSE_PW_LIMIT_RANGES = 13,
	__ETHTOOL_A_PSE_CNT = 14,
	ETHTOOL_A_PSE_MAX = 13,
};

enum {
	ETHTOOL_A_RINGS_UNSPEC = 0,
	ETHTOOL_A_RINGS_HEADER = 1,
	ETHTOOL_A_RINGS_RX_MAX = 2,
	ETHTOOL_A_RINGS_RX_MINI_MAX = 3,
	ETHTOOL_A_RINGS_RX_JUMBO_MAX = 4,
	ETHTOOL_A_RINGS_TX_MAX = 5,
	ETHTOOL_A_RINGS_RX = 6,
	ETHTOOL_A_RINGS_RX_MINI = 7,
	ETHTOOL_A_RINGS_RX_JUMBO = 8,
	ETHTOOL_A_RINGS_TX = 9,
	ETHTOOL_A_RINGS_RX_BUF_LEN = 10,
	ETHTOOL_A_RINGS_TCP_DATA_SPLIT = 11,
	ETHTOOL_A_RINGS_CQE_SIZE = 12,
	ETHTOOL_A_RINGS_TX_PUSH = 13,
	ETHTOOL_A_RINGS_RX_PUSH = 14,
	ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN = 15,
	ETHTOOL_A_RINGS_TX_PUSH_BUF_LEN_MAX = 16,
	ETHTOOL_A_RINGS_HDS_THRESH = 17,
	ETHTOOL_A_RINGS_HDS_THRESH_MAX = 18,
	__ETHTOOL_A_RINGS_CNT = 19,
	ETHTOOL_A_RINGS_MAX = 18,
};

enum {
	ETHTOOL_A_RSS_UNSPEC = 0,
	ETHTOOL_A_RSS_HEADER = 1,
	ETHTOOL_A_RSS_CONTEXT = 2,
	ETHTOOL_A_RSS_HFUNC = 3,
	ETHTOOL_A_RSS_INDIR = 4,
	ETHTOOL_A_RSS_HKEY = 5,
	ETHTOOL_A_RSS_INPUT_XFRM = 6,
	ETHTOOL_A_RSS_START_CONTEXT = 7,
	__ETHTOOL_A_RSS_CNT = 8,
	ETHTOOL_A_RSS_MAX = 7,
};

enum {
	ETHTOOL_A_STATS_ETH_CTRL_3_TX = 0,
	ETHTOOL_A_STATS_ETH_CTRL_4_RX = 1,
	ETHTOOL_A_STATS_ETH_CTRL_5_RX_UNSUP = 2,
	__ETHTOOL_A_STATS_ETH_CTRL_CNT = 3,
	ETHTOOL_A_STATS_ETH_CTRL_MAX = 2,
};

enum {
	ETHTOOL_A_STATS_ETH_MAC_2_TX_PKT = 0,
	ETHTOOL_A_STATS_ETH_MAC_3_SINGLE_COL = 1,
	ETHTOOL_A_STATS_ETH_MAC_4_MULTI_COL = 2,
	ETHTOOL_A_STATS_ETH_MAC_5_RX_PKT = 3,
	ETHTOOL_A_STATS_ETH_MAC_6_FCS_ERR = 4,
	ETHTOOL_A_STATS_ETH_MAC_7_ALIGN_ERR = 5,
	ETHTOOL_A_STATS_ETH_MAC_8_TX_BYTES = 6,
	ETHTOOL_A_STATS_ETH_MAC_9_TX_DEFER = 7,
	ETHTOOL_A_STATS_ETH_MAC_10_LATE_COL = 8,
	ETHTOOL_A_STATS_ETH_MAC_11_XS_COL = 9,
	ETHTOOL_A_STATS_ETH_MAC_12_TX_INT_ERR = 10,
	ETHTOOL_A_STATS_ETH_MAC_13_CS_ERR = 11,
	ETHTOOL_A_STATS_ETH_MAC_14_RX_BYTES = 12,
	ETHTOOL_A_STATS_ETH_MAC_15_RX_INT_ERR = 13,
	ETHTOOL_A_STATS_ETH_MAC_18_TX_MCAST = 14,
	ETHTOOL_A_STATS_ETH_MAC_19_TX_BCAST = 15,
	ETHTOOL_A_STATS_ETH_MAC_20_XS_DEFER = 16,
	ETHTOOL_A_STATS_ETH_MAC_21_RX_MCAST = 17,
	ETHTOOL_A_STATS_ETH_MAC_22_RX_BCAST = 18,
	ETHTOOL_A_STATS_ETH_MAC_23_IR_LEN_ERR = 19,
	ETHTOOL_A_STATS_ETH_MAC_24_OOR_LEN = 20,
	ETHTOOL_A_STATS_ETH_MAC_25_TOO_LONG_ERR = 21,
	__ETHTOOL_A_STATS_ETH_MAC_CNT = 22,
	ETHTOOL_A_STATS_ETH_MAC_MAX = 21,
};

enum {
	ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR = 0,
	__ETHTOOL_A_STATS_ETH_PHY_CNT = 1,
	ETHTOOL_A_STATS_ETH_PHY_MAX = 0,
};

enum {
	ETHTOOL_A_STATS_GRP_UNSPEC = 0,
	ETHTOOL_A_STATS_GRP_PAD = 1,
	ETHTOOL_A_STATS_GRP_ID = 2,
	ETHTOOL_A_STATS_GRP_SS_ID = 3,
	ETHTOOL_A_STATS_GRP_STAT = 4,
	ETHTOOL_A_STATS_GRP_HIST_RX = 5,
	ETHTOOL_A_STATS_GRP_HIST_TX = 6,
	ETHTOOL_A_STATS_GRP_HIST_BKT_LOW = 7,
	ETHTOOL_A_STATS_GRP_HIST_BKT_HI = 8,
	ETHTOOL_A_STATS_GRP_HIST_VAL = 9,
	__ETHTOOL_A_STATS_GRP_CNT = 10,
	ETHTOOL_A_STATS_GRP_MAX = 9,
};

enum {
	ETHTOOL_A_STATS_PHY_RX_PKTS = 0,
	ETHTOOL_A_STATS_PHY_RX_BYTES = 1,
	ETHTOOL_A_STATS_PHY_RX_ERRORS = 2,
	ETHTOOL_A_STATS_PHY_TX_PKTS = 3,
	ETHTOOL_A_STATS_PHY_TX_BYTES = 4,
	ETHTOOL_A_STATS_PHY_TX_ERRORS = 5,
	__ETHTOOL_A_STATS_PHY_CNT = 6,
	ETHTOOL_A_STATS_PHY_MAX = 5,
};

enum {
	ETHTOOL_A_STATS_RMON_UNDERSIZE = 0,
	ETHTOOL_A_STATS_RMON_OVERSIZE = 1,
	ETHTOOL_A_STATS_RMON_FRAG = 2,
	ETHTOOL_A_STATS_RMON_JABBER = 3,
	__ETHTOOL_A_STATS_RMON_CNT = 4,
	ETHTOOL_A_STATS_RMON_MAX = 3,
};

enum {
	ETHTOOL_A_STATS_UNSPEC = 0,
	ETHTOOL_A_STATS_PAD = 1,
	ETHTOOL_A_STATS_HEADER = 2,
	ETHTOOL_A_STATS_GROUPS = 3,
	ETHTOOL_A_STATS_GRP = 4,
	ETHTOOL_A_STATS_SRC = 5,
	__ETHTOOL_A_STATS_CNT = 6,
	ETHTOOL_A_STATS_MAX = 5,
};

enum {
	ETHTOOL_A_STRINGSETS_UNSPEC = 0,
	ETHTOOL_A_STRINGSETS_STRINGSET = 1,
	__ETHTOOL_A_STRINGSETS_CNT = 2,
	ETHTOOL_A_STRINGSETS_MAX = 1,
};

enum {
	ETHTOOL_A_STRINGSET_UNSPEC = 0,
	ETHTOOL_A_STRINGSET_ID = 1,
	ETHTOOL_A_STRINGSET_COUNT = 2,
	ETHTOOL_A_STRINGSET_STRINGS = 3,
	__ETHTOOL_A_STRINGSET_CNT = 4,
	ETHTOOL_A_STRINGSET_MAX = 3,
};

enum {
	ETHTOOL_A_STRINGS_UNSPEC = 0,
	ETHTOOL_A_STRINGS_STRING = 1,
	__ETHTOOL_A_STRINGS_CNT = 2,
	ETHTOOL_A_STRINGS_MAX = 1,
};

enum {
	ETHTOOL_A_STRING_UNSPEC = 0,
	ETHTOOL_A_STRING_INDEX = 1,
	ETHTOOL_A_STRING_VALUE = 2,
	__ETHTOOL_A_STRING_CNT = 3,
	ETHTOOL_A_STRING_MAX = 2,
};

enum {
	ETHTOOL_A_STRSET_UNSPEC = 0,
	ETHTOOL_A_STRSET_HEADER = 1,
	ETHTOOL_A_STRSET_STRINGSETS = 2,
	ETHTOOL_A_STRSET_COUNTS_ONLY = 3,
	__ETHTOOL_A_STRSET_CNT = 4,
	ETHTOOL_A_STRSET_MAX = 3,
};

enum {
	ETHTOOL_A_TSCONFIG_UNSPEC = 0,
	ETHTOOL_A_TSCONFIG_HEADER = 1,
	ETHTOOL_A_TSCONFIG_HWTSTAMP_PROVIDER = 2,
	ETHTOOL_A_TSCONFIG_TX_TYPES = 3,
	ETHTOOL_A_TSCONFIG_RX_FILTERS = 4,
	ETHTOOL_A_TSCONFIG_HWTSTAMP_FLAGS = 5,
	__ETHTOOL_A_TSCONFIG_CNT = 6,
	ETHTOOL_A_TSCONFIG_MAX = 5,
};

enum {
	ETHTOOL_A_TSINFO_UNSPEC = 0,
	ETHTOOL_A_TSINFO_HEADER = 1,
	ETHTOOL_A_TSINFO_TIMESTAMPING = 2,
	ETHTOOL_A_TSINFO_TX_TYPES = 3,
	ETHTOOL_A_TSINFO_RX_FILTERS = 4,
	ETHTOOL_A_TSINFO_PHC_INDEX = 5,
	ETHTOOL_A_TSINFO_STATS = 6,
	ETHTOOL_A_TSINFO_HWTSTAMP_PROVIDER = 7,
	__ETHTOOL_A_TSINFO_CNT = 8,
	ETHTOOL_A_TSINFO_MAX = 7,
};

enum {
	ETHTOOL_A_TS_HWTSTAMP_PROVIDER_UNSPEC = 0,
	ETHTOOL_A_TS_HWTSTAMP_PROVIDER_INDEX = 1,
	ETHTOOL_A_TS_HWTSTAMP_PROVIDER_QUALIFIER = 2,
	__ETHTOOL_A_TS_HWTSTAMP_PROVIDER_CNT = 3,
	ETHTOOL_A_TS_HWTSTAMP_PROVIDER_MAX = 2,
};

enum {
	ETHTOOL_A_TS_STAT_UNSPEC = 0,
	ETHTOOL_A_TS_STAT_TX_PKTS = 1,
	ETHTOOL_A_TS_STAT_TX_LOST = 2,
	ETHTOOL_A_TS_STAT_TX_ERR = 3,
	ETHTOOL_A_TS_STAT_TX_ONESTEP_PKTS_UNCONFIRMED = 4,
	__ETHTOOL_A_TS_STAT_CNT = 5,
	ETHTOOL_A_TS_STAT_MAX = 4,
};

enum {
	ETHTOOL_A_TUNNEL_INFO_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_INFO_HEADER = 1,
	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS = 2,
	__ETHTOOL_A_TUNNEL_INFO_CNT = 3,
	ETHTOOL_A_TUNNEL_INFO_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT = 1,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE = 2,
	__ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT = 3,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE = 1,
	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES = 2,
	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY = 3,
	__ETHTOOL_A_TUNNEL_UDP_TABLE_CNT = 4,
	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE = 1,
	__ETHTOOL_A_TUNNEL_UDP_CNT = 2,
	ETHTOOL_A_TUNNEL_UDP_MAX = 1,
};

enum {
	ETHTOOL_A_WOL_UNSPEC = 0,
	ETHTOOL_A_WOL_HEADER = 1,
	ETHTOOL_A_WOL_MODES = 2,
	ETHTOOL_A_WOL_SOPASS = 3,
	__ETHTOOL_A_WOL_CNT = 4,
	ETHTOOL_A_WOL_MAX = 3,
};

enum {
	ETHTOOL_MSG_KERNEL_NONE = 0,
	ETHTOOL_MSG_STRSET_GET_REPLY = 1,
	ETHTOOL_MSG_LINKINFO_GET_REPLY = 2,
	ETHTOOL_MSG_LINKINFO_NTF = 3,
	ETHTOOL_MSG_LINKMODES_GET_REPLY = 4,
	ETHTOOL_MSG_LINKMODES_NTF = 5,
	ETHTOOL_MSG_LINKSTATE_GET_REPLY = 6,
	ETHTOOL_MSG_DEBUG_GET_REPLY = 7,
	ETHTOOL_MSG_DEBUG_NTF = 8,
	ETHTOOL_MSG_WOL_GET_REPLY = 9,
	ETHTOOL_MSG_WOL_NTF = 10,
	ETHTOOL_MSG_FEATURES_GET_REPLY = 11,
	ETHTOOL_MSG_FEATURES_SET_REPLY = 12,
	ETHTOOL_MSG_FEATURES_NTF = 13,
	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY = 14,
	ETHTOOL_MSG_PRIVFLAGS_NTF = 15,
	ETHTOOL_MSG_RINGS_GET_REPLY = 16,
	ETHTOOL_MSG_RINGS_NTF = 17,
	ETHTOOL_MSG_CHANNELS_GET_REPLY = 18,
	ETHTOOL_MSG_CHANNELS_NTF = 19,
	ETHTOOL_MSG_COALESCE_GET_REPLY = 20,
	ETHTOOL_MSG_COALESCE_NTF = 21,
	ETHTOOL_MSG_PAUSE_GET_REPLY = 22,
	ETHTOOL_MSG_PAUSE_NTF = 23,
	ETHTOOL_MSG_EEE_GET_REPLY = 24,
	ETHTOOL_MSG_EEE_NTF = 25,
	ETHTOOL_MSG_TSINFO_GET_REPLY = 26,
	ETHTOOL_MSG_CABLE_TEST_NTF = 27,
	ETHTOOL_MSG_CABLE_TEST_TDR_NTF = 28,
	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 29,
	ETHTOOL_MSG_FEC_GET_REPLY = 30,
	ETHTOOL_MSG_FEC_NTF = 31,
	ETHTOOL_MSG_MODULE_EEPROM_GET_REPLY = 32,
	ETHTOOL_MSG_STATS_GET_REPLY = 33,
	ETHTOOL_MSG_PHC_VCLOCKS_GET_REPLY = 34,
	ETHTOOL_MSG_MODULE_GET_REPLY = 35,
	ETHTOOL_MSG_MODULE_NTF = 36,
	ETHTOOL_MSG_PSE_GET_REPLY = 37,
	ETHTOOL_MSG_RSS_GET_REPLY = 38,
	ETHTOOL_MSG_PLCA_GET_CFG_REPLY = 39,
	ETHTOOL_MSG_PLCA_GET_STATUS_REPLY = 40,
	ETHTOOL_MSG_PLCA_NTF = 41,
	ETHTOOL_MSG_MM_GET_REPLY = 42,
	ETHTOOL_MSG_MM_NTF = 43,
	ETHTOOL_MSG_MODULE_FW_FLASH_NTF = 44,
	ETHTOOL_MSG_PHY_GET_REPLY = 45,
	ETHTOOL_MSG_PHY_NTF = 46,
	ETHTOOL_MSG_TSCONFIG_GET_REPLY = 47,
	ETHTOOL_MSG_TSCONFIG_SET_REPLY = 48,
	__ETHTOOL_MSG_KERNEL_CNT = 49,
	ETHTOOL_MSG_KERNEL_MAX = 48,
};

enum {
	ETHTOOL_MSG_USER_NONE = 0,
	ETHTOOL_MSG_STRSET_GET = 1,
	ETHTOOL_MSG_LINKINFO_GET = 2,
	ETHTOOL_MSG_LINKINFO_SET = 3,
	ETHTOOL_MSG_LINKMODES_GET = 4,
	ETHTOOL_MSG_LINKMODES_SET = 5,
	ETHTOOL_MSG_LINKSTATE_GET = 6,
	ETHTOOL_MSG_DEBUG_GET = 7,
	ETHTOOL_MSG_DEBUG_SET = 8,
	ETHTOOL_MSG_WOL_GET = 9,
	ETHTOOL_MSG_WOL_SET = 10,
	ETHTOOL_MSG_FEATURES_GET = 11,
	ETHTOOL_MSG_FEATURES_SET = 12,
	ETHTOOL_MSG_PRIVFLAGS_GET = 13,
	ETHTOOL_MSG_PRIVFLAGS_SET = 14,
	ETHTOOL_MSG_RINGS_GET = 15,
	ETHTOOL_MSG_RINGS_SET = 16,
	ETHTOOL_MSG_CHANNELS_GET = 17,
	ETHTOOL_MSG_CHANNELS_SET = 18,
	ETHTOOL_MSG_COALESCE_GET = 19,
	ETHTOOL_MSG_COALESCE_SET = 20,
	ETHTOOL_MSG_PAUSE_GET = 21,
	ETHTOOL_MSG_PAUSE_SET = 22,
	ETHTOOL_MSG_EEE_GET = 23,
	ETHTOOL_MSG_EEE_SET = 24,
	ETHTOOL_MSG_TSINFO_GET = 25,
	ETHTOOL_MSG_CABLE_TEST_ACT = 26,
	ETHTOOL_MSG_CABLE_TEST_TDR_ACT = 27,
	ETHTOOL_MSG_TUNNEL_INFO_GET = 28,
	ETHTOOL_MSG_FEC_GET = 29,
	ETHTOOL_MSG_FEC_SET = 30,
	ETHTOOL_MSG_MODULE_EEPROM_GET = 31,
	ETHTOOL_MSG_STATS_GET = 32,
	ETHTOOL_MSG_PHC_VCLOCKS_GET = 33,
	ETHTOOL_MSG_MODULE_GET = 34,
	ETHTOOL_MSG_MODULE_SET = 35,
	ETHTOOL_MSG_PSE_GET = 36,
	ETHTOOL_MSG_PSE_SET = 37,
	ETHTOOL_MSG_RSS_GET = 38,
	ETHTOOL_MSG_PLCA_GET_CFG = 39,
	ETHTOOL_MSG_PLCA_SET_CFG = 40,
	ETHTOOL_MSG_PLCA_GET_STATUS = 41,
	ETHTOOL_MSG_MM_GET = 42,
	ETHTOOL_MSG_MM_SET = 43,
	ETHTOOL_MSG_MODULE_FW_FLASH_ACT = 44,
	ETHTOOL_MSG_PHY_GET = 45,
	ETHTOOL_MSG_TSCONFIG_GET = 46,
	ETHTOOL_MSG_TSCONFIG_SET = 47,
	__ETHTOOL_MSG_USER_CNT = 48,
	ETHTOOL_MSG_USER_MAX = 47,
};

enum {
	ETHTOOL_STATS_ETH_PHY = 0,
	ETHTOOL_STATS_ETH_MAC = 1,
	ETHTOOL_STATS_ETH_CTRL = 2,
	ETHTOOL_STATS_RMON = 3,
	ETHTOOL_STATS_PHY = 4,
	__ETHTOOL_STATS_CNT = 5,
};

enum {
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN = 0,
	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE = 1,
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE = 2,
	__ETHTOOL_UDP_TUNNEL_TYPE_CNT = 3,
	ETHTOOL_UDP_TUNNEL_TYPE_MAX = 2,
};

enum {
	ETH_RSS_HASH_TOP_BIT = 0,
	ETH_RSS_HASH_XOR_BIT = 1,
	ETH_RSS_HASH_CRC32_BIT = 2,
	ETH_RSS_HASH_FUNCS_COUNT = 3,
};

enum {
	EVENTFS_SAVE_MODE = 65536,
	EVENTFS_SAVE_UID = 131072,
	EVENTFS_SAVE_GID = 262144,
};

enum {
	EVENT_FILE_FL_ENABLED = 1,
	EVENT_FILE_FL_RECORDED_CMD = 2,
	EVENT_FILE_FL_RECORDED_TGID = 4,
	EVENT_FILE_FL_FILTERED = 8,
	EVENT_FILE_FL_NO_SET_FILTER = 16,
	EVENT_FILE_FL_SOFT_MODE = 32,
	EVENT_FILE_FL_SOFT_DISABLED = 64,
	EVENT_FILE_FL_TRIGGER_MODE = 128,
	EVENT_FILE_FL_TRIGGER_COND = 256,
	EVENT_FILE_FL_PID_FILTER = 512,
	EVENT_FILE_FL_WAS_ENABLED = 1024,
	EVENT_FILE_FL_FREED = 2048,
};

enum {
	EVENT_FILE_FL_ENABLED_BIT = 0,
	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
	EVENT_FILE_FL_FILTERED_BIT = 3,
	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
	EVENT_FILE_FL_PID_FILTER_BIT = 9,
	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
	EVENT_FILE_FL_FREED_BIT = 11,
};

enum {
	EVENT_TRIGGER_FL_PROBE = 1,
};

enum {
	EXT4_FC_REASON_XATTR = 0,
	EXT4_FC_REASON_CROSS_RENAME = 1,
	EXT4_FC_REASON_JOURNAL_FLAG_CHANGE = 2,
	EXT4_FC_REASON_NOMEM = 3,
	EXT4_FC_REASON_SWAP_BOOT = 4,
	EXT4_FC_REASON_RESIZE = 5,
	EXT4_FC_REASON_RENAME_DIR = 6,
	EXT4_FC_REASON_FALLOC_RANGE = 7,
	EXT4_FC_REASON_INODE_JOURNAL_DATA = 8,
	EXT4_FC_REASON_ENCRYPTED_FILENAME = 9,
	EXT4_FC_REASON_MAX = 10,
};

enum {
	EXT4_FC_STATUS_OK = 0,
	EXT4_FC_STATUS_INELIGIBLE = 1,
	EXT4_FC_STATUS_SKIPPED = 2,
	EXT4_FC_STATUS_FAILED = 3,
};

enum {
	EXT4_FLAGS_RESIZING = 0,
	EXT4_FLAGS_SHUTDOWN = 1,
	EXT4_FLAGS_BDEV_IS_DAX = 2,
	EXT4_FLAGS_EMERGENCY_RO = 3,
};

enum {
	EXT4_INODE_SECRM = 0,
	EXT4_INODE_UNRM = 1,
	EXT4_INODE_COMPR = 2,
	EXT4_INODE_SYNC = 3,
	EXT4_INODE_IMMUTABLE = 4,
	EXT4_INODE_APPEND = 5,
	EXT4_INODE_NODUMP = 6,
	EXT4_INODE_NOATIME = 7,
	EXT4_INODE_DIRTY = 8,
	EXT4_INODE_COMPRBLK = 9,
	EXT4_INODE_NOCOMPR = 10,
	EXT4_INODE_ENCRYPT = 11,
	EXT4_INODE_INDEX = 12,
	EXT4_INODE_IMAGIC = 13,
	EXT4_INODE_JOURNAL_DATA = 14,
	EXT4_INODE_NOTAIL = 15,
	EXT4_INODE_DIRSYNC = 16,
	EXT4_INODE_TOPDIR = 17,
	EXT4_INODE_HUGE_FILE = 18,
	EXT4_INODE_EXTENTS = 19,
	EXT4_INODE_VERITY = 20,
	EXT4_INODE_EA_INODE = 21,
	EXT4_INODE_DAX = 25,
	EXT4_INODE_INLINE_DATA = 28,
	EXT4_INODE_PROJINHERIT = 29,
	EXT4_INODE_CASEFOLD = 30,
	EXT4_INODE_RESERVED = 31,
};

enum {
	EXT4_MF_MNTDIR_SAMPLED = 0,
	EXT4_MF_FC_INELIGIBLE = 1,
	EXT4_MF_JOURNAL_DESTROY = 2,
};

enum {
	EXT4_STATE_NEW = 0,
	EXT4_STATE_XATTR = 1,
	EXT4_STATE_NO_EXPAND = 2,
	EXT4_STATE_DA_ALLOC_CLOSE = 3,
	EXT4_STATE_EXT_MIGRATE = 4,
	EXT4_STATE_NEWENTRY = 5,
	EXT4_STATE_MAY_INLINE_DATA = 6,
	EXT4_STATE_EXT_PRECACHED = 7,
	EXT4_STATE_LUSTRE_EA_INODE = 8,
	EXT4_STATE_VERITY_IN_PROGRESS = 9,
	EXT4_STATE_FC_COMMITTING = 10,
	EXT4_STATE_ORPHAN_FILE = 11,
};

enum {
	EXTENT_BUFFER_UPTODATE = 0,
	EXTENT_BUFFER_DIRTY = 1,
	EXTENT_BUFFER_CORRUPT = 2,
	EXTENT_BUFFER_READAHEAD = 3,
	EXTENT_BUFFER_TREE_REF = 4,
	EXTENT_BUFFER_STALE = 5,
	EXTENT_BUFFER_WRITEBACK = 6,
	EXTENT_BUFFER_READ_ERR = 7,
	EXTENT_BUFFER_UNMAPPED = 8,
	EXTENT_BUFFER_IN_TREE = 9,
	EXTENT_BUFFER_WRITE_ERR = 10,
	EXTENT_BUFFER_ZONED_ZEROOUT = 11,
	EXTENT_BUFFER_READING = 12,
};

enum {
	EXTRA_REG_NHMEX_M_FILTER = 0,
	EXTRA_REG_NHMEX_M_DSP = 1,
	EXTRA_REG_NHMEX_M_ISS = 2,
	EXTRA_REG_NHMEX_M_MAP = 3,
	EXTRA_REG_NHMEX_M_MSC_THR = 4,
	EXTRA_REG_NHMEX_M_PGT = 5,
	EXTRA_REG_NHMEX_M_PLD = 6,
	EXTRA_REG_NHMEX_M_ZDP_CTL_FVC = 7,
};

enum {
	Enabled = 0,
	Magic = 1,
};

enum {
	FATTR4_CLONE_BLKSIZE = 77,
	FATTR4_SPACE_FREED = 78,
	FATTR4_CHANGE_ATTR_TYPE = 79,
	FATTR4_SEC_LABEL = 80,
};

enum {
	FATTR4_DIR_NOTIF_DELAY = 56,
	FATTR4_DIRENT_NOTIF_DELAY = 57,
	FATTR4_DACL = 58,
	FATTR4_SACL = 59,
	FATTR4_CHANGE_POLICY = 60,
	FATTR4_FS_STATUS = 61,
	FATTR4_FS_LAYOUT_TYPES = 62,
	FATTR4_LAYOUT_HINT = 63,
	FATTR4_LAYOUT_TYPES = 64,
	FATTR4_LAYOUT_BLKSIZE = 65,
	FATTR4_LAYOUT_ALIGNMENT = 66,
	FATTR4_FS_LOCATIONS_INFO = 67,
	FATTR4_MDSTHRESHOLD = 68,
	FATTR4_RETENTION_GET = 69,
	FATTR4_RETENTION_SET = 70,
	FATTR4_RETENTEVT_GET = 71,
	FATTR4_RETENTEVT_SET = 72,
	FATTR4_RETENTION_HOLD = 73,
	FATTR4_MODE_SET_MASKED = 74,
	FATTR4_SUPPATTR_EXCLCREAT = 75,
	FATTR4_FS_CHARSET_CAP = 76,
};

enum {
	FATTR4_MODE_UMASK = 81,
};

enum {
	FATTR4_OPEN_ARGUMENTS = 86,
};

enum {
	FATTR4_SUPPORTED_ATTRS = 0,
	FATTR4_TYPE = 1,
	FATTR4_FH_EXPIRE_TYPE = 2,
	FATTR4_CHANGE = 3,
	FATTR4_SIZE = 4,
	FATTR4_LINK_SUPPORT = 5,
	FATTR4_SYMLINK_SUPPORT = 6,
	FATTR4_NAMED_ATTR = 7,
	FATTR4_FSID = 8,
	FATTR4_UNIQUE_HANDLES = 9,
	FATTR4_LEASE_TIME = 10,
	FATTR4_RDATTR_ERROR = 11,
	FATTR4_ACL = 12,
	FATTR4_ACLSUPPORT = 13,
	FATTR4_ARCHIVE = 14,
	FATTR4_CANSETTIME = 15,
	FATTR4_CASE_INSENSITIVE = 16,
	FATTR4_CASE_PRESERVING = 17,
	FATTR4_CHOWN_RESTRICTED = 18,
	FATTR4_FILEHANDLE = 19,
	FATTR4_FILEID = 20,
	FATTR4_FILES_AVAIL = 21,
	FATTR4_FILES_FREE = 22,
	FATTR4_FILES_TOTAL = 23,
	FATTR4_FS_LOCATIONS = 24,
	FATTR4_HIDDEN = 25,
	FATTR4_HOMOGENEOUS = 26,
	FATTR4_MAXFILESIZE = 27,
	FATTR4_MAXLINK = 28,
	FATTR4_MAXNAME = 29,
	FATTR4_MAXREAD = 30,
	FATTR4_MAXWRITE = 31,
	FATTR4_MIMETYPE = 32,
	FATTR4_MODE = 33,
	FATTR4_NO_TRUNC = 34,
	FATTR4_NUMLINKS = 35,
	FATTR4_OWNER = 36,
	FATTR4_OWNER_GROUP = 37,
	FATTR4_QUOTA_AVAIL_HARD = 38,
	FATTR4_QUOTA_AVAIL_SOFT = 39,
	FATTR4_QUOTA_USED = 40,
	FATTR4_RAWDEV = 41,
	FATTR4_SPACE_AVAIL = 42,
	FATTR4_SPACE_FREE = 43,
	FATTR4_SPACE_TOTAL = 44,
	FATTR4_SPACE_USED = 45,
	FATTR4_SYSTEM = 46,
	FATTR4_TIME_ACCESS = 47,
	FATTR4_TIME_ACCESS_SET = 48,
	FATTR4_TIME_BACKUP = 49,
	FATTR4_TIME_CREATE = 50,
	FATTR4_TIME_DELTA = 51,
	FATTR4_TIME_METADATA = 52,
	FATTR4_TIME_MODIFY = 53,
	FATTR4_TIME_MODIFY_SET = 54,
	FATTR4_MOUNTED_ON_FILEID = 55,
};

enum {
	FATTR4_TIME_DELEG_ACCESS = 84,
};

enum {
	FATTR4_TIME_DELEG_MODIFY = 85,
};

enum {
	FATTR4_XATTR_SUPPORT = 82,
};

enum {
	FBCON_LOGO_CANSHOW = -1,
	FBCON_LOGO_DRAW = -2,
	FBCON_LOGO_DONTSHOW = -3,
};

enum {
	FB_BLANK_UNBLANK = 0,
	FB_BLANK_NORMAL = 1,
	FB_BLANK_VSYNC_SUSPEND = 2,
	FB_BLANK_HSYNC_SUSPEND = 3,
	FB_BLANK_POWERDOWN = 4,
};

enum {
	FCNVME_CMD_CAT_MASK = 15,
	FCNVME_CMD_CAT_ADMINQ = 1,
	FCNVME_CMD_CAT_CSSMASK = 7,
	FCNVME_CMD_CAT_CSSFLAG = 8,
};

enum {
	FCNVME_CMD_FLAGS_DIRMASK = 3,
	FCNVME_CMD_FLAGS_WRITE = 1,
	FCNVME_CMD_FLAGS_READ = 2,
	FCNVME_CMD_FLAGS_PICWP = 4,
};

enum {
	FCNVME_LSDESC_RSVD = 0,
	FCNVME_LSDESC_RQST = 1,
	FCNVME_LSDESC_RJT = 2,
	FCNVME_LSDESC_CREATE_ASSOC_CMD = 3,
	FCNVME_LSDESC_CREATE_CONN_CMD = 4,
	FCNVME_LSDESC_DISCONN_CMD = 5,
	FCNVME_LSDESC_CONN_ID = 6,
	FCNVME_LSDESC_ASSOC_ID = 7,
};

enum {
	FCNVME_LS_RSVD = 0,
	FCNVME_LS_RJT = 1,
	FCNVME_LS_ACC = 2,
	FCNVME_LS_CREATE_ASSOCIATION = 3,
	FCNVME_LS_CREATE_CONNECTION = 4,
	FCNVME_LS_DISCONNECT_ASSOC = 5,
	FCNVME_LS_DISCONNECT_CONN = 6,
};

enum {
	FDB_NOTIFY_BIT = 1,
	FDB_NOTIFY_INACTIVE_BIT = 2,
};

enum {
	FIB6_NO_SERNUM_CHANGE = 0,
};

enum {
	FILEID_HIGH_OFF = 0,
	FILEID_LOW_OFF = 1,
	FILE_I_TYPE_OFF = 2,
	EMBED_FH_OFF = 3,
};

enum {
	FILTER_OTHER = 0,
	FILTER_STATIC_STRING = 1,
	FILTER_DYN_STRING = 2,
	FILTER_RDYN_STRING = 3,
	FILTER_PTR_STRING = 4,
	FILTER_TRACE_FN = 5,
	FILTER_CPUMASK = 6,
	FILTER_COMM = 7,
	FILTER_CPU = 8,
	FILTER_STACKTRACE = 9,
};

enum {
	FILT_ERR_NONE = 0,
	FILT_ERR_INVALID_OP = 1,
	FILT_ERR_TOO_MANY_OPEN = 2,
	FILT_ERR_TOO_MANY_CLOSE = 3,
	FILT_ERR_MISSING_QUOTE = 4,
	FILT_ERR_MISSING_BRACE_OPEN = 5,
	FILT_ERR_MISSING_BRACE_CLOSE = 6,
	FILT_ERR_OPERAND_TOO_LONG = 7,
	FILT_ERR_EXPECT_STRING = 8,
	FILT_ERR_EXPECT_DIGIT = 9,
	FILT_ERR_ILLEGAL_FIELD_OP = 10,
	FILT_ERR_FIELD_NOT_FOUND = 11,
	FILT_ERR_ILLEGAL_INTVAL = 12,
	FILT_ERR_BAD_SUBSYS_FILTER = 13,
	FILT_ERR_TOO_MANY_PREDS = 14,
	FILT_ERR_INVALID_FILTER = 15,
	FILT_ERR_INVALID_CPULIST = 16,
	FILT_ERR_IP_FIELD_ONLY = 17,
	FILT_ERR_INVALID_VALUE = 18,
	FILT_ERR_NO_FUNCTION = 19,
	FILT_ERR_ERRNO = 20,
	FILT_ERR_NO_FILTER = 21,
};

enum {
	FLOW_KEY_SRC = 0,
	FLOW_KEY_DST = 1,
	FLOW_KEY_PROTO = 2,
	FLOW_KEY_PROTO_SRC = 3,
	FLOW_KEY_PROTO_DST = 4,
	FLOW_KEY_IIF = 5,
	FLOW_KEY_PRIORITY = 6,
	FLOW_KEY_MARK = 7,
	FLOW_KEY_NFCT = 8,
	FLOW_KEY_NFCT_SRC = 9,
	FLOW_KEY_NFCT_DST = 10,
	FLOW_KEY_NFCT_PROTO_SRC = 11,
	FLOW_KEY_NFCT_PROTO_DST = 12,
	FLOW_KEY_RTCLASSID = 13,
	FLOW_KEY_SKUID = 14,
	FLOW_KEY_SKGID = 15,
	FLOW_KEY_VLAN_TAG = 16,
	FLOW_KEY_RXHASH = 17,
	__FLOW_KEY_MAX = 18,
};

enum {
	FLOW_MODE_MAP = 0,
	FLOW_MODE_HASH = 1,
};

enum {
	FOLL_TOUCH = 65536,
	FOLL_TRIED = 131072,
	FOLL_REMOTE = 262144,
	FOLL_PIN = 524288,
	FOLL_FAST_ONLY = 1048576,
	FOLL_UNLOCKABLE = 2097152,
	FOLL_MADV_POPULATE = 4194304,
};

enum {
	FOLL_WRITE = 1,
	FOLL_GET = 2,
	FOLL_DUMP = 4,
	FOLL_FORCE = 8,
	FOLL_NOWAIT = 16,
	FOLL_NOFAULT = 32,
	FOLL_HWPOISON = 64,
	FOLL_ANON = 128,
	FOLL_LONGTERM = 256,
	FOLL_SPLIT_PMD = 512,
	FOLL_PCI_P2PDMA = 1024,
	FOLL_INTERRUPTIBLE = 2048,
	FOLL_HONOR_NUMA_FAULT = 4096,
};

enum {
	FORCE_CPU_RELOC = 1,
	FORCE_GTT_RELOC = 2,
	FORCE_GPU_RELOC = 3,
};

enum {
	FORMAT_HEADER = 1,
	FORMAT_FIELD_SEPERATOR = 2,
	FORMAT_PRINTFMT = 3,
};

enum {
	FRA_UNSPEC = 0,
	FRA_DST = 1,
	FRA_SRC = 2,
	FRA_IIFNAME = 3,
	FRA_GOTO = 4,
	FRA_UNUSED2 = 5,
	FRA_PRIORITY = 6,
	FRA_UNUSED3 = 7,
	FRA_UNUSED4 = 8,
	FRA_UNUSED5 = 9,
	FRA_FWMARK = 10,
	FRA_FLOW = 11,
	FRA_TUN_ID = 12,
	FRA_SUPPRESS_IFGROUP = 13,
	FRA_SUPPRESS_PREFIXLEN = 14,
	FRA_TABLE = 15,
	FRA_FWMASK = 16,
	FRA_OIFNAME = 17,
	FRA_PAD = 18,
	FRA_L3MDEV = 19,
	FRA_UID_RANGE = 20,
	FRA_PROTOCOL = 21,
	FRA_IP_PROTO = 22,
	FRA_SPORT_RANGE = 23,
	FRA_DPORT_RANGE = 24,
	FRA_DSCP = 25,
	FRA_FLOWLABEL = 26,
	FRA_FLOWLABEL_MASK = 27,
	__FRA_MAX = 28,
};

enum {
	FR_ACT_UNSPEC = 0,
	FR_ACT_TO_TBL = 1,
	FR_ACT_GOTO = 2,
	FR_ACT_NOP = 3,
	FR_ACT_RES3 = 4,
	FR_ACT_RES4 = 5,
	FR_ACT_BLACKHOLE = 6,
	FR_ACT_UNREACHABLE = 7,
	FR_ACT_PROHIBIT = 8,
	__FR_ACT_MAX = 9,
};

enum {
	FUSE_I_ADVISE_RDPLUS = 0,
	FUSE_I_INIT_RDPLUS = 1,
	FUSE_I_SIZE_UNSTABLE = 2,
	FUSE_I_BAD = 3,
	FUSE_I_BTIME = 4,
	FUSE_I_CACHE_IO_MODE = 5,
};

enum {
	FUTEX_STATE_OK = 0,
	FUTEX_STATE_EXITING = 1,
	FUTEX_STATE_DEAD = 2,
};

enum {
	GATE_INTERRUPT = 14,
	GATE_TRAP = 15,
	GATE_CALL = 12,
	GATE_TASK = 5,
};

enum {
	GENHD_FL_REMOVABLE = 1,
	GENHD_FL_HIDDEN = 2,
	GENHD_FL_NO_PART = 4,
};

enum {
	GP_IDLE = 0,
	GP_ENTER = 1,
	GP_PASSED = 2,
	GP_EXIT = 3,
	GP_REPLAY = 4,
};

enum {
	GRED_WRED_MODE = 1,
	GRED_RIO_MODE = 2,
};

enum {
	GSSX_NULL = 0,
	GSSX_INDICATE_MECHS = 1,
	GSSX_GET_CALL_CONTEXT = 2,
	GSSX_IMPORT_AND_CANON_NAME = 3,
	GSSX_EXPORT_CRED = 4,
	GSSX_IMPORT_CRED = 5,
	GSSX_ACQUIRE_CRED = 6,
	GSSX_STORE_CRED = 7,
	GSSX_INIT_SEC_CONTEXT = 8,
	GSSX_ACCEPT_SEC_CONTEXT = 9,
	GSSX_RELEASE_HANDLE = 10,
	GSSX_GET_MIC = 11,
	GSSX_VERIFY = 12,
	GSSX_WRAP = 13,
	GSSX_UNWRAP = 14,
	GSSX_WRAP_SIZE_LIMIT = 15,
};

enum {
	GUC_CAPTURE_LIST_CLASS_RENDER_COMPUTE = 0,
	GUC_CAPTURE_LIST_CLASS_VIDEO = 1,
	GUC_CAPTURE_LIST_CLASS_VIDEOENHANCE = 2,
	GUC_CAPTURE_LIST_CLASS_BLITTER = 3,
	GUC_CAPTURE_LIST_CLASS_GSC_OTHER = 4,
};

enum {
	GUC_CAPTURE_LIST_INDEX_PF = 0,
	GUC_CAPTURE_LIST_INDEX_VF = 1,
	GUC_CAPTURE_LIST_INDEX_MAX = 2,
};

enum {
	GUC_CONTEXT_POLICIES_KLV_ID_EXECUTION_QUANTUM = 8193,
	GUC_CONTEXT_POLICIES_KLV_ID_PREEMPTION_TIMEOUT = 8194,
	GUC_CONTEXT_POLICIES_KLV_ID_SCHEDULING_PRIORITY = 8195,
	GUC_CONTEXT_POLICIES_KLV_ID_PREEMPT_TO_IDLE_ON_QUANTUM_EXPIRY = 8196,
	GUC_CONTEXT_POLICIES_KLV_ID_SLPM_GT_FREQUENCY = 8197,
	GUC_CONTEXT_POLICIES_KLV_NUM_IDS = 5,
};

enum {
	GUC_LOG_SECTIONS_CRASH = 0,
	GUC_LOG_SECTIONS_DEBUG = 1,
	GUC_LOG_SECTIONS_CAPTURE = 2,
	GUC_LOG_SECTIONS_LIMIT = 3,
};

enum {
	GUC_SCHEDULING_POLICIES_KLV_ID_RENDER_COMPUTE_YIELD = 4097,
};

enum {
	GUC_WORKAROUND_KLV_SERIALIZED_RA_MODE = 36865,
	GUC_WORKAROUND_KLV_BLOCK_INTERRUPTS_WHEN_MGSR_BLOCKED = 36866,
	GUC_WORKAROUND_KLV_AVOID_GFX_CLEAR_WHILE_ACTIVE = 36870,
};

enum {
	HANDSHAKE_A_ACCEPT_SOCKFD = 1,
	HANDSHAKE_A_ACCEPT_HANDLER_CLASS = 2,
	HANDSHAKE_A_ACCEPT_MESSAGE_TYPE = 3,
	HANDSHAKE_A_ACCEPT_TIMEOUT = 4,
	HANDSHAKE_A_ACCEPT_AUTH_MODE = 5,
	HANDSHAKE_A_ACCEPT_PEER_IDENTITY = 6,
	HANDSHAKE_A_ACCEPT_CERTIFICATE = 7,
	HANDSHAKE_A_ACCEPT_PEERNAME = 8,
	__HANDSHAKE_A_ACCEPT_MAX = 9,
	HANDSHAKE_A_ACCEPT_MAX = 8,
};

enum {
	HANDSHAKE_A_DONE_STATUS = 1,
	HANDSHAKE_A_DONE_SOCKFD = 2,
	HANDSHAKE_A_DONE_REMOTE_AUTH = 3,
	__HANDSHAKE_A_DONE_MAX = 4,
	HANDSHAKE_A_DONE_MAX = 3,
};

enum {
	HANDSHAKE_A_X509_CERT = 1,
	HANDSHAKE_A_X509_PRIVKEY = 2,
	__HANDSHAKE_A_X509_MAX = 3,
	HANDSHAKE_A_X509_MAX = 2,
};

enum {
	HANDSHAKE_CMD_READY = 1,
	HANDSHAKE_CMD_ACCEPT = 2,
	HANDSHAKE_CMD_DONE = 3,
	__HANDSHAKE_CMD_MAX = 4,
	HANDSHAKE_CMD_MAX = 3,
};

enum {
	HANDSHAKE_NLGRP_NONE = 0,
	HANDSHAKE_NLGRP_TLSHD = 1,
};

enum {
	HASH_SIZE = 128,
};

enum {
	HAS_GLOBAL_MOCS = 1,
	HAS_ENGINE_MOCS = 2,
	HAS_RENDER_L3CC = 4,
};

enum {
	HAS_READ = 1,
	HAS_WRITE = 2,
	HAS_LSEEK = 4,
	HAS_POLL = 8,
	HAS_IOCTL = 16,
};

enum {
	HIBERNATION_INVALID = 0,
	HIBERNATION_PLATFORM = 1,
	HIBERNATION_SHUTDOWN = 2,
	HIBERNATION_REBOOT = 3,
	HIBERNATION_SUSPEND = 4,
	HIBERNATION_TEST_RESUME = 5,
	__HIBERNATION_AFTER_LAST = 6,
};

enum {
	HI_SOFTIRQ = 0,
	TIMER_SOFTIRQ = 1,
	NET_TX_SOFTIRQ = 2,
	NET_RX_SOFTIRQ = 3,
	BLOCK_SOFTIRQ = 4,
	IRQ_POLL_SOFTIRQ = 5,
	TASKLET_SOFTIRQ = 6,
	SCHED_SOFTIRQ = 7,
	HRTIMER_SOFTIRQ = 8,
	RCU_SOFTIRQ = 9,
	NR_SOFTIRQS = 10,
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE = 1,
	HP_THREAD_PARKED = 2,
};

enum {
	HSR_A_UNSPEC = 0,
	HSR_A_NODE_ADDR = 1,
	HSR_A_IFINDEX = 2,
	HSR_A_IF1_AGE = 3,
	HSR_A_IF2_AGE = 4,
	HSR_A_NODE_ADDR_B = 5,
	HSR_A_IF1_SEQ = 6,
	HSR_A_IF2_SEQ = 7,
	HSR_A_IF1_IFINDEX = 8,
	HSR_A_IF2_IFINDEX = 9,
	HSR_A_ADDR_B_IFINDEX = 10,
	__HSR_A_MAX = 11,
};

enum {
	HSR_C_UNSPEC = 0,
	HSR_C_RING_ERROR = 1,
	HSR_C_NODE_DOWN = 2,
	HSR_C_GET_NODE_STATUS = 3,
	HSR_C_SET_NODE_STATUS = 4,
	HSR_C_GET_NODE_LIST = 5,
	HSR_C_SET_NODE_LIST = 6,
	__HSR_C_MAX = 7,
};

enum {
	HSR_PROTOCOL_HSR = 0,
	HSR_PROTOCOL_PRP = 1,
	HSR_PROTOCOL_MAX = 2,
};

enum {
	HSWEP_PCI_UNCORE_HA = 0,
	HSWEP_PCI_UNCORE_IMC = 1,
	HSWEP_PCI_UNCORE_IRP = 2,
	HSWEP_PCI_UNCORE_QPI = 3,
	HSWEP_PCI_UNCORE_R2PCIE = 4,
	HSWEP_PCI_UNCORE_R3QPI = 5,
};

enum {
	HUGETLB_SHMFS_INODE = 1,
	HUGETLB_ANONHUGE_INODE = 2,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = 3,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = 7,
};

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_3 = 3,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_5 = 5,
	HW_BREAKPOINT_LEN_6 = 6,
	HW_BREAKPOINT_LEN_7 = 7,
	HW_BREAKPOINT_LEN_8 = 8,
};

enum {
	I915_FENCE_FLAG_ACTIVE = 3,
	I915_FENCE_FLAG_PQUEUE = 4,
	I915_FENCE_FLAG_HOLD = 5,
	I915_FENCE_FLAG_INITIAL_BREADCRUMB = 6,
	I915_FENCE_FLAG_SIGNAL = 7,
	I915_FENCE_FLAG_NOPREEMPT = 8,
	I915_FENCE_FLAG_SENTINEL = 9,
	I915_FENCE_FLAG_BOOST = 10,
	I915_FENCE_FLAG_SUBMIT_PARALLEL = 11,
	I915_FENCE_FLAG_SKIP_PARALLEL = 12,
	I915_FENCE_FLAG_COMPOSITE = 13,
};

enum {
	I915_PRIORITY_MIN = -1024,
	I915_PRIORITY_NORMAL = 0,
	I915_PRIORITY_MAX = 1024,
	I915_PRIORITY_HEARTBEAT = 1025,
	I915_PRIORITY_DISPLAY = 1026,
};

enum {
	IB_MGMT_MAD_HDR = 24,
	IB_MGMT_MAD_DATA = 232,
	IB_MGMT_RMPP_HDR = 36,
	IB_MGMT_RMPP_DATA = 220,
	IB_MGMT_VENDOR_HDR = 40,
	IB_MGMT_VENDOR_DATA = 216,
	IB_MGMT_SA_HDR = 56,
	IB_MGMT_SA_DATA = 200,
	IB_MGMT_DEVICE_HDR = 64,
	IB_MGMT_DEVICE_DATA = 192,
	IB_MGMT_MAD_SIZE = 256,
	OPA_MGMT_MAD_DATA = 2024,
	OPA_MGMT_RMPP_DATA = 2012,
	OPA_MGMT_MAD_SIZE = 2048,
};

enum {
	IB_USER_MAD_USER_RMPP = 1,
};

enum {
	ICMP6_MIB_NUM = 0,
	ICMP6_MIB_INMSGS = 1,
	ICMP6_MIB_INERRORS = 2,
	ICMP6_MIB_OUTMSGS = 3,
	ICMP6_MIB_OUTERRORS = 4,
	ICMP6_MIB_CSUMERRORS = 5,
	ICMP6_MIB_RATELIMITHOST = 6,
	__ICMP6_MIB_MAX = 7,
};

enum {
	ICMP_MIB_NUM = 0,
	ICMP_MIB_INMSGS = 1,
	ICMP_MIB_INERRORS = 2,
	ICMP_MIB_INDESTUNREACHS = 3,
	ICMP_MIB_INTIMEEXCDS = 4,
	ICMP_MIB_INPARMPROBS = 5,
	ICMP_MIB_INSRCQUENCHS = 6,
	ICMP_MIB_INREDIRECTS = 7,
	ICMP_MIB_INECHOS = 8,
	ICMP_MIB_INECHOREPS = 9,
	ICMP_MIB_INTIMESTAMPS = 10,
	ICMP_MIB_INTIMESTAMPREPS = 11,
	ICMP_MIB_INADDRMASKS = 12,
	ICMP_MIB_INADDRMASKREPS = 13,
	ICMP_MIB_OUTMSGS = 14,
	ICMP_MIB_OUTERRORS = 15,
	ICMP_MIB_OUTDESTUNREACHS = 16,
	ICMP_MIB_OUTTIMEEXCDS = 17,
	ICMP_MIB_OUTPARMPROBS = 18,
	ICMP_MIB_OUTSRCQUENCHS = 19,
	ICMP_MIB_OUTREDIRECTS = 20,
	ICMP_MIB_OUTECHOS = 21,
	ICMP_MIB_OUTECHOREPS = 22,
	ICMP_MIB_OUTTIMESTAMPS = 23,
	ICMP_MIB_OUTTIMESTAMPREPS = 24,
	ICMP_MIB_OUTADDRMASKS = 25,
	ICMP_MIB_OUTADDRMASKREPS = 26,
	ICMP_MIB_CSUMERRORS = 27,
	ICMP_MIB_RATELIMITGLOBAL = 28,
	ICMP_MIB_RATELIMITHOST = 29,
	__ICMP_MIB_MAX = 30,
};

enum {
	ICX_PCIE1_PMON_ID = 0,
	ICX_PCIE2_PMON_ID = 1,
	ICX_PCIE3_PMON_ID = 2,
	ICX_PCIE4_PMON_ID = 3,
	ICX_PCIE5_PMON_ID = 4,
	ICX_CBDMA_DMI_PMON_ID = 5,
};

enum {
	ICX_PCI_UNCORE_M2M = 0,
	ICX_PCI_UNCORE_UPI = 1,
	ICX_PCI_UNCORE_M3UPI = 2,
};

enum {
	IDX_MODULE_ID = 0,
	IDX_ST_OPS_COMMON_VALUE_ID = 1,
};

enum {
	IEEE802154_ADDR_NONE = 0,
	IEEE802154_ADDR_SHORT = 2,
	IEEE802154_ADDR_LONG = 3,
};

enum {
	IFAL_ADDRESS = 1,
	IFAL_LABEL = 2,
	__IFAL_MAX = 3,
};

enum {
	IFA_UNSPEC = 0,
	IFA_ADDRESS = 1,
	IFA_LOCAL = 2,
	IFA_LABEL = 3,
	IFA_BROADCAST = 4,
	IFA_ANYCAST = 5,
	IFA_CACHEINFO = 6,
	IFA_MULTICAST = 7,
	IFA_FLAGS = 8,
	IFA_RT_PRIORITY = 9,
	IFA_TARGET_NETNSID = 10,
	IFA_PROTO = 11,
	__IFA_MAX = 12,
};

enum {
	IFE_META_SKBMARK = 1,
	IFE_META_HASHID = 2,
	IFE_META_PRIO = 3,
	IFE_META_QMAP = 4,
	IFE_META_TCINDEX = 5,
	__IFE_META_MAX = 6,
};

enum {
	IFLA_BRIDGE_CFM_CC_CCM_TX_UNSPEC = 0,
	IFLA_BRIDGE_CFM_CC_CCM_TX_INSTANCE = 1,
	IFLA_BRIDGE_CFM_CC_CCM_TX_DMAC = 2,
	IFLA_BRIDGE_CFM_CC_CCM_TX_SEQ_NO_UPDATE = 3,
	IFLA_BRIDGE_CFM_CC_CCM_TX_PERIOD = 4,
	IFLA_BRIDGE_CFM_CC_CCM_TX_IF_TLV = 5,
	IFLA_BRIDGE_CFM_CC_CCM_TX_IF_TLV_VALUE = 6,
	IFLA_BRIDGE_CFM_CC_CCM_TX_PORT_TLV = 7,
	IFLA_BRIDGE_CFM_CC_CCM_TX_PORT_TLV_VALUE = 8,
	__IFLA_BRIDGE_CFM_CC_CCM_TX_MAX = 9,
};

enum {
	IFLA_BRIDGE_CFM_CC_CONFIG_UNSPEC = 0,
	IFLA_BRIDGE_CFM_CC_CONFIG_INSTANCE = 1,
	IFLA_BRIDGE_CFM_CC_CONFIG_ENABLE = 2,
	IFLA_BRIDGE_CFM_CC_CONFIG_EXP_INTERVAL = 3,
	IFLA_BRIDGE_CFM_CC_CONFIG_EXP_MAID = 4,
	__IFLA_BRIDGE_CFM_CC_CONFIG_MAX = 5,
};

enum {
	IFLA_BRIDGE_CFM_CC_PEER_MEP_UNSPEC = 0,
	IFLA_BRIDGE_CFM_CC_PEER_MEP_INSTANCE = 1,
	IFLA_BRIDGE_CFM_CC_PEER_MEPID = 2,
	__IFLA_BRIDGE_CFM_CC_PEER_MEP_MAX = 3,
};

enum {
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_UNSPEC = 0,
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_INSTANCE = 1,
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_PEER_MEPID = 2,
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_CCM_DEFECT = 3,
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_RDI = 4,
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_PORT_TLV_VALUE = 5,
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_IF_TLV_VALUE = 6,
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_SEEN = 7,
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_TLV_SEEN = 8,
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_SEQ_UNEXP_SEEN = 9,
	__IFLA_BRIDGE_CFM_CC_PEER_STATUS_MAX = 10,
};

enum {
	IFLA_BRIDGE_CFM_CC_RDI_UNSPEC = 0,
	IFLA_BRIDGE_CFM_CC_RDI_INSTANCE = 1,
	IFLA_BRIDGE_CFM_CC_RDI_RDI = 2,
	__IFLA_BRIDGE_CFM_CC_RDI_MAX = 3,
};

enum {
	IFLA_BRIDGE_CFM_MEP_CONFIG_UNSPEC = 0,
	IFLA_BRIDGE_CFM_MEP_CONFIG_INSTANCE = 1,
	IFLA_BRIDGE_CFM_MEP_CONFIG_UNICAST_MAC = 2,
	IFLA_BRIDGE_CFM_MEP_CONFIG_MDLEVEL = 3,
	IFLA_BRIDGE_CFM_MEP_CONFIG_MEPID = 4,
	__IFLA_BRIDGE_CFM_MEP_CONFIG_MAX = 5,
};

enum {
	IFLA_BRIDGE_CFM_MEP_CREATE_UNSPEC = 0,
	IFLA_BRIDGE_CFM_MEP_CREATE_INSTANCE = 1,
	IFLA_BRIDGE_CFM_MEP_CREATE_DOMAIN = 2,
	IFLA_BRIDGE_CFM_MEP_CREATE_DIRECTION = 3,
	IFLA_BRIDGE_CFM_MEP_CREATE_IFINDEX = 4,
	__IFLA_BRIDGE_CFM_MEP_CREATE_MAX = 5,
};

enum {
	IFLA_BRIDGE_CFM_MEP_DELETE_UNSPEC = 0,
	IFLA_BRIDGE_CFM_MEP_DELETE_INSTANCE = 1,
	__IFLA_BRIDGE_CFM_MEP_DELETE_MAX = 2,
};

enum {
	IFLA_BRIDGE_CFM_MEP_STATUS_UNSPEC = 0,
	IFLA_BRIDGE_CFM_MEP_STATUS_INSTANCE = 1,
	IFLA_BRIDGE_CFM_MEP_STATUS_OPCODE_UNEXP_SEEN = 2,
	IFLA_BRIDGE_CFM_MEP_STATUS_VERSION_UNEXP_SEEN = 3,
	IFLA_BRIDGE_CFM_MEP_STATUS_RX_LEVEL_LOW_SEEN = 4,
	__IFLA_BRIDGE_CFM_MEP_STATUS_MAX = 5,
};

enum {
	IFLA_BRIDGE_CFM_UNSPEC = 0,
	IFLA_BRIDGE_CFM_MEP_CREATE = 1,
	IFLA_BRIDGE_CFM_MEP_DELETE = 2,
	IFLA_BRIDGE_CFM_MEP_CONFIG = 3,
	IFLA_BRIDGE_CFM_CC_CONFIG = 4,
	IFLA_BRIDGE_CFM_CC_PEER_MEP_ADD = 5,
	IFLA_BRIDGE_CFM_CC_PEER_MEP_REMOVE = 6,
	IFLA_BRIDGE_CFM_CC_RDI = 7,
	IFLA_BRIDGE_CFM_CC_CCM_TX = 8,
	IFLA_BRIDGE_CFM_MEP_CREATE_INFO = 9,
	IFLA_BRIDGE_CFM_MEP_CONFIG_INFO = 10,
	IFLA_BRIDGE_CFM_CC_CONFIG_INFO = 11,
	IFLA_BRIDGE_CFM_CC_RDI_INFO = 12,
	IFLA_BRIDGE_CFM_CC_CCM_TX_INFO = 13,
	IFLA_BRIDGE_CFM_CC_PEER_MEP_INFO = 14,
	IFLA_BRIDGE_CFM_MEP_STATUS_INFO = 15,
	IFLA_BRIDGE_CFM_CC_PEER_STATUS_INFO = 16,
	__IFLA_BRIDGE_CFM_MAX = 17,
};

enum {
	IFLA_BRIDGE_FLAGS = 0,
	IFLA_BRIDGE_MODE = 1,
	IFLA_BRIDGE_VLAN_INFO = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
	IFLA_BRIDGE_MRP = 4,
	IFLA_BRIDGE_CFM = 5,
	IFLA_BRIDGE_MST = 6,
	__IFLA_BRIDGE_MAX = 7,
};

enum {
	IFLA_BRIDGE_MRP_INFO_UNSPEC = 0,
	IFLA_BRIDGE_MRP_INFO_RING_ID = 1,
	IFLA_BRIDGE_MRP_INFO_P_IFINDEX = 2,
	IFLA_BRIDGE_MRP_INFO_S_IFINDEX = 3,
	IFLA_BRIDGE_MRP_INFO_PRIO = 4,
	IFLA_BRIDGE_MRP_INFO_RING_STATE = 5,
	IFLA_BRIDGE_MRP_INFO_RING_ROLE = 6,
	IFLA_BRIDGE_MRP_INFO_TEST_INTERVAL = 7,
	IFLA_BRIDGE_MRP_INFO_TEST_MAX_MISS = 8,
	IFLA_BRIDGE_MRP_INFO_TEST_MONITOR = 9,
	IFLA_BRIDGE_MRP_INFO_I_IFINDEX = 10,
	IFLA_BRIDGE_MRP_INFO_IN_STATE = 11,
	IFLA_BRIDGE_MRP_INFO_IN_ROLE = 12,
	IFLA_BRIDGE_MRP_INFO_IN_TEST_INTERVAL = 13,
	IFLA_BRIDGE_MRP_INFO_IN_TEST_MAX_MISS = 14,
	__IFLA_BRIDGE_MRP_INFO_MAX = 15,
};

enum {
	IFLA_BRIDGE_MRP_INSTANCE_UNSPEC = 0,
	IFLA_BRIDGE_MRP_INSTANCE_RING_ID = 1,
	IFLA_BRIDGE_MRP_INSTANCE_P_IFINDEX = 2,
	IFLA_BRIDGE_MRP_INSTANCE_S_IFINDEX = 3,
	IFLA_BRIDGE_MRP_INSTANCE_PRIO = 4,
	__IFLA_BRIDGE_MRP_INSTANCE_MAX = 5,
};

enum {
	IFLA_BRIDGE_MRP_IN_ROLE_UNSPEC = 0,
	IFLA_BRIDGE_MRP_IN_ROLE_RING_ID = 1,
	IFLA_BRIDGE_MRP_IN_ROLE_IN_ID = 2,
	IFLA_BRIDGE_MRP_IN_ROLE_ROLE = 3,
	IFLA_BRIDGE_MRP_IN_ROLE_I_IFINDEX = 4,
	__IFLA_BRIDGE_MRP_IN_ROLE_MAX = 5,
};

enum {
	IFLA_BRIDGE_MRP_IN_STATE_UNSPEC = 0,
	IFLA_BRIDGE_MRP_IN_STATE_IN_ID = 1,
	IFLA_BRIDGE_MRP_IN_STATE_STATE = 2,
	__IFLA_BRIDGE_MRP_IN_STATE_MAX = 3,
};

enum {
	IFLA_BRIDGE_MRP_PORT_ROLE_UNSPEC = 0,
	IFLA_BRIDGE_MRP_PORT_ROLE_ROLE = 1,
	__IFLA_BRIDGE_MRP_PORT_ROLE_MAX = 2,
};

enum {
	IFLA_BRIDGE_MRP_PORT_STATE_UNSPEC = 0,
	IFLA_BRIDGE_MRP_PORT_STATE_STATE = 1,
	__IFLA_BRIDGE_MRP_PORT_STATE_MAX = 2,
};

enum {
	IFLA_BRIDGE_MRP_RING_ROLE_UNSPEC = 0,
	IFLA_BRIDGE_MRP_RING_ROLE_RING_ID = 1,
	IFLA_BRIDGE_MRP_RING_ROLE_ROLE = 2,
	__IFLA_BRIDGE_MRP_RING_ROLE_MAX = 3,
};

enum {
	IFLA_BRIDGE_MRP_RING_STATE_UNSPEC = 0,
	IFLA_BRIDGE_MRP_RING_STATE_RING_ID = 1,
	IFLA_BRIDGE_MRP_RING_STATE_STATE = 2,
	__IFLA_BRIDGE_MRP_RING_STATE_MAX = 3,
};

enum {
	IFLA_BRIDGE_MRP_START_IN_TEST_UNSPEC = 0,
	IFLA_BRIDGE_MRP_START_IN_TEST_IN_ID = 1,
	IFLA_BRIDGE_MRP_START_IN_TEST_INTERVAL = 2,
	IFLA_BRIDGE_MRP_START_IN_TEST_MAX_MISS = 3,
	IFLA_BRIDGE_MRP_START_IN_TEST_PERIOD = 4,
	__IFLA_BRIDGE_MRP_START_IN_TEST_MAX = 5,
};

enum {
	IFLA_BRIDGE_MRP_START_TEST_UNSPEC = 0,
	IFLA_BRIDGE_MRP_START_TEST_RING_ID = 1,
	IFLA_BRIDGE_MRP_START_TEST_INTERVAL = 2,
	IFLA_BRIDGE_MRP_START_TEST_MAX_MISS = 3,
	IFLA_BRIDGE_MRP_START_TEST_PERIOD = 4,
	IFLA_BRIDGE_MRP_START_TEST_MONITOR = 5,
	__IFLA_BRIDGE_MRP_START_TEST_MAX = 6,
};

enum {
	IFLA_BRIDGE_MRP_UNSPEC = 0,
	IFLA_BRIDGE_MRP_INSTANCE = 1,
	IFLA_BRIDGE_MRP_PORT_STATE = 2,
	IFLA_BRIDGE_MRP_PORT_ROLE = 3,
	IFLA_BRIDGE_MRP_RING_STATE = 4,
	IFLA_BRIDGE_MRP_RING_ROLE = 5,
	IFLA_BRIDGE_MRP_START_TEST = 6,
	IFLA_BRIDGE_MRP_INFO = 7,
	IFLA_BRIDGE_MRP_IN_ROLE = 8,
	IFLA_BRIDGE_MRP_IN_STATE = 9,
	IFLA_BRIDGE_MRP_START_IN_TEST = 10,
	__IFLA_BRIDGE_MRP_MAX = 11,
};

enum {
	IFLA_BRIDGE_MST_ENTRY_UNSPEC = 0,
	IFLA_BRIDGE_MST_ENTRY_MSTI = 1,
	IFLA_BRIDGE_MST_ENTRY_STATE = 2,
	__IFLA_BRIDGE_MST_ENTRY_MAX = 3,
};

enum {
	IFLA_BRIDGE_MST_UNSPEC = 0,
	IFLA_BRIDGE_MST_ENTRY = 1,
	__IFLA_BRIDGE_MST_MAX = 2,
};

enum {
	IFLA_BRIDGE_VLAN_TUNNEL_UNSPEC = 0,
	IFLA_BRIDGE_VLAN_TUNNEL_ID = 1,
	IFLA_BRIDGE_VLAN_TUNNEL_VID = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_FLAGS = 3,
	__IFLA_BRIDGE_VLAN_TUNNEL_MAX = 4,
};

enum {
	IFLA_BRPORT_UNSPEC = 0,
	IFLA_BRPORT_STATE = 1,
	IFLA_BRPORT_PRIORITY = 2,
	IFLA_BRPORT_COST = 3,
	IFLA_BRPORT_MODE = 4,
	IFLA_BRPORT_GUARD = 5,
	IFLA_BRPORT_PROTECT = 6,
	IFLA_BRPORT_FAST_LEAVE = 7,
	IFLA_BRPORT_LEARNING = 8,
	IFLA_BRPORT_UNICAST_FLOOD = 9,
	IFLA_BRPORT_PROXYARP = 10,
	IFLA_BRPORT_LEARNING_SYNC = 11,
	IFLA_BRPORT_PROXYARP_WIFI = 12,
	IFLA_BRPORT_ROOT_ID = 13,
	IFLA_BRPORT_BRIDGE_ID = 14,
	IFLA_BRPORT_DESIGNATED_PORT = 15,
	IFLA_BRPORT_DESIGNATED_COST = 16,
	IFLA_BRPORT_ID = 17,
	IFLA_BRPORT_NO = 18,
	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
	IFLA_BRPORT_CONFIG_PENDING = 20,
	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
	IFLA_BRPORT_HOLD_TIMER = 23,
	IFLA_BRPORT_FLUSH = 24,
	IFLA_BRPORT_MULTICAST_ROUTER = 25,
	IFLA_BRPORT_PAD = 26,
	IFLA_BRPORT_MCAST_FLOOD = 27,
	IFLA_BRPORT_MCAST_TO_UCAST = 28,
	IFLA_BRPORT_VLAN_TUNNEL = 29,
	IFLA_BRPORT_BCAST_FLOOD = 30,
	IFLA_BRPORT_GROUP_FWD_MASK = 31,
	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
	IFLA_BRPORT_ISOLATED = 33,
	IFLA_BRPORT_BACKUP_PORT = 34,
	IFLA_BRPORT_MRP_RING_OPEN = 35,
	IFLA_BRPORT_MRP_IN_OPEN = 36,
	IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT = 37,
	IFLA_BRPORT_MCAST_EHT_HOSTS_CNT = 38,
	IFLA_BRPORT_LOCKED = 39,
	IFLA_BRPORT_MAB = 40,
	IFLA_BRPORT_MCAST_N_GROUPS = 41,
	IFLA_BRPORT_MCAST_MAX_GROUPS = 42,
	IFLA_BRPORT_NEIGH_VLAN_SUPPRESS = 43,
	IFLA_BRPORT_BACKUP_NHID = 44,
	__IFLA_BRPORT_MAX = 45,
};

enum {
	IFLA_BR_UNSPEC = 0,
	IFLA_BR_FORWARD_DELAY = 1,
	IFLA_BR_HELLO_TIME = 2,
	IFLA_BR_MAX_AGE = 3,
	IFLA_BR_AGEING_TIME = 4,
	IFLA_BR_STP_STATE = 5,
	IFLA_BR_PRIORITY = 6,
	IFLA_BR_VLAN_FILTERING = 7,
	IFLA_BR_VLAN_PROTOCOL = 8,
	IFLA_BR_GROUP_FWD_MASK = 9,
	IFLA_BR_ROOT_ID = 10,
	IFLA_BR_BRIDGE_ID = 11,
	IFLA_BR_ROOT_PORT = 12,
	IFLA_BR_ROOT_PATH_COST = 13,
	IFLA_BR_TOPOLOGY_CHANGE = 14,
	IFLA_BR_TOPOLOGY_CHANGE_DETECTED = 15,
	IFLA_BR_HELLO_TIMER = 16,
	IFLA_BR_TCN_TIMER = 17,
	IFLA_BR_TOPOLOGY_CHANGE_TIMER = 18,
	IFLA_BR_GC_TIMER = 19,
	IFLA_BR_GROUP_ADDR = 20,
	IFLA_BR_FDB_FLUSH = 21,
	IFLA_BR_MCAST_ROUTER = 22,
	IFLA_BR_MCAST_SNOOPING = 23,
	IFLA_BR_MCAST_QUERY_USE_IFADDR = 24,
	IFLA_BR_MCAST_QUERIER = 25,
	IFLA_BR_MCAST_HASH_ELASTICITY = 26,
	IFLA_BR_MCAST_HASH_MAX = 27,
	IFLA_BR_MCAST_LAST_MEMBER_CNT = 28,
	IFLA_BR_MCAST_STARTUP_QUERY_CNT = 29,
	IFLA_BR_MCAST_LAST_MEMBER_INTVL = 30,
	IFLA_BR_MCAST_MEMBERSHIP_INTVL = 31,
	IFLA_BR_MCAST_QUERIER_INTVL = 32,
	IFLA_BR_MCAST_QUERY_INTVL = 33,
	IFLA_BR_MCAST_QUERY_RESPONSE_INTVL = 34,
	IFLA_BR_MCAST_STARTUP_QUERY_INTVL = 35,
	IFLA_BR_NF_CALL_IPTABLES = 36,
	IFLA_BR_NF_CALL_IP6TABLES = 37,
	IFLA_BR_NF_CALL_ARPTABLES = 38,
	IFLA_BR_VLAN_DEFAULT_PVID = 39,
	IFLA_BR_PAD = 40,
	IFLA_BR_VLAN_STATS_ENABLED = 41,
	IFLA_BR_MCAST_STATS_ENABLED = 42,
	IFLA_BR_MCAST_IGMP_VERSION = 43,
	IFLA_BR_MCAST_MLD_VERSION = 44,
	IFLA_BR_VLAN_STATS_PER_PORT = 45,
	IFLA_BR_MULTI_BOOLOPT = 46,
	IFLA_BR_MCAST_QUERIER_STATE = 47,
	IFLA_BR_FDB_N_LEARNED = 48,
	IFLA_BR_FDB_MAX_LEARNED = 49,
	__IFLA_BR_MAX = 50,
};

enum {
	IFLA_EVENT_NONE = 0,
	IFLA_EVENT_REBOOT = 1,
	IFLA_EVENT_FEATURES = 2,
	IFLA_EVENT_BONDING_FAILOVER = 3,
	IFLA_EVENT_NOTIFY_PEERS = 4,
	IFLA_EVENT_IGMP_RESEND = 5,
	IFLA_EVENT_BONDING_OPTIONS = 6,
};

enum {
	IFLA_GRE_UNSPEC = 0,
	IFLA_GRE_LINK = 1,
	IFLA_GRE_IFLAGS = 2,
	IFLA_GRE_OFLAGS = 3,
	IFLA_GRE_IKEY = 4,
	IFLA_GRE_OKEY = 5,
	IFLA_GRE_LOCAL = 6,
	IFLA_GRE_REMOTE = 7,
	IFLA_GRE_TTL = 8,
	IFLA_GRE_TOS = 9,
	IFLA_GRE_PMTUDISC = 10,
	IFLA_GRE_ENCAP_LIMIT = 11,
	IFLA_GRE_FLOWINFO = 12,
	IFLA_GRE_FLAGS = 13,
	IFLA_GRE_ENCAP_TYPE = 14,
	IFLA_GRE_ENCAP_FLAGS = 15,
	IFLA_GRE_ENCAP_SPORT = 16,
	IFLA_GRE_ENCAP_DPORT = 17,
	IFLA_GRE_COLLECT_METADATA = 18,
	IFLA_GRE_IGNORE_DF = 19,
	IFLA_GRE_FWMARK = 20,
	IFLA_GRE_ERSPAN_INDEX = 21,
	IFLA_GRE_ERSPAN_VER = 22,
	IFLA_GRE_ERSPAN_DIR = 23,
	IFLA_GRE_ERSPAN_HWID = 24,
	__IFLA_GRE_MAX = 25,
};

enum {
	IFLA_HSR_UNSPEC = 0,
	IFLA_HSR_SLAVE1 = 1,
	IFLA_HSR_SLAVE2 = 2,
	IFLA_HSR_MULTICAST_SPEC = 3,
	IFLA_HSR_SUPERVISION_ADDR = 4,
	IFLA_HSR_SEQ_NR = 5,
	IFLA_HSR_VERSION = 6,
	IFLA_HSR_PROTOCOL = 7,
	IFLA_HSR_INTERLINK = 8,
	__IFLA_HSR_MAX = 9,
};

enum {
	IFLA_INET6_UNSPEC = 0,
	IFLA_INET6_FLAGS = 1,
	IFLA_INET6_CONF = 2,
	IFLA_INET6_STATS = 3,
	IFLA_INET6_MCAST = 4,
	IFLA_INET6_CACHEINFO = 5,
	IFLA_INET6_ICMP6STATS = 6,
	IFLA_INET6_TOKEN = 7,
	IFLA_INET6_ADDR_GEN_MODE = 8,
	IFLA_INET6_RA_MTU = 9,
	__IFLA_INET6_MAX = 10,
};

enum {
	IFLA_INET_UNSPEC = 0,
	IFLA_INET_CONF = 1,
	__IFLA_INET_MAX = 2,
};

enum {
	IFLA_INFO_UNSPEC = 0,
	IFLA_INFO_KIND = 1,
	IFLA_INFO_DATA = 2,
	IFLA_INFO_XSTATS = 3,
	IFLA_INFO_SLAVE_KIND = 4,
	IFLA_INFO_SLAVE_DATA = 5,
	__IFLA_INFO_MAX = 6,
};

enum {
	IFLA_IPTUN_UNSPEC = 0,
	IFLA_IPTUN_LINK = 1,
	IFLA_IPTUN_LOCAL = 2,
	IFLA_IPTUN_REMOTE = 3,
	IFLA_IPTUN_TTL = 4,
	IFLA_IPTUN_TOS = 5,
	IFLA_IPTUN_ENCAP_LIMIT = 6,
	IFLA_IPTUN_FLOWINFO = 7,
	IFLA_IPTUN_FLAGS = 8,
	IFLA_IPTUN_PROTO = 9,
	IFLA_IPTUN_PMTUDISC = 10,
	IFLA_IPTUN_6RD_PREFIX = 11,
	IFLA_IPTUN_6RD_RELAY_PREFIX = 12,
	IFLA_IPTUN_6RD_PREFIXLEN = 13,
	IFLA_IPTUN_6RD_RELAY_PREFIXLEN = 14,
	IFLA_IPTUN_ENCAP_TYPE = 15,
	IFLA_IPTUN_ENCAP_FLAGS = 16,
	IFLA_IPTUN_ENCAP_SPORT = 17,
	IFLA_IPTUN_ENCAP_DPORT = 18,
	IFLA_IPTUN_COLLECT_METADATA = 19,
	IFLA_IPTUN_FWMARK = 20,
	__IFLA_IPTUN_MAX = 21,
};

enum {
	IFLA_IPVLAN_UNSPEC = 0,
	IFLA_IPVLAN_MODE = 1,
	IFLA_IPVLAN_FLAGS = 2,
	__IFLA_IPVLAN_MAX = 3,
};

enum {
	IFLA_MACVLAN_UNSPEC = 0,
	IFLA_MACVLAN_MODE = 1,
	IFLA_MACVLAN_FLAGS = 2,
	IFLA_MACVLAN_MACADDR_MODE = 3,
	IFLA_MACVLAN_MACADDR = 4,
	IFLA_MACVLAN_MACADDR_DATA = 5,
	IFLA_MACVLAN_MACADDR_COUNT = 6,
	IFLA_MACVLAN_BC_QUEUE_LEN = 7,
	IFLA_MACVLAN_BC_QUEUE_LEN_USED = 8,
	IFLA_MACVLAN_BC_CUTOFF = 9,
	__IFLA_MACVLAN_MAX = 10,
};

enum {
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_REQUEST = 1,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_USED = 2,
	__IFLA_OFFLOAD_XSTATS_HW_S_INFO_MAX = 3,
};

enum {
	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO = 2,
	IFLA_OFFLOAD_XSTATS_L3_STATS = 3,
	__IFLA_OFFLOAD_XSTATS_MAX = 4,
};

enum {
	IFLA_PORT_UNSPEC = 0,
	IFLA_PORT_VF = 1,
	IFLA_PORT_PROFILE = 2,
	IFLA_PORT_VSI_TYPE = 3,
	IFLA_PORT_INSTANCE_UUID = 4,
	IFLA_PORT_HOST_UUID = 5,
	IFLA_PORT_REQUEST = 6,
	IFLA_PORT_RESPONSE = 7,
	__IFLA_PORT_MAX = 8,
};

enum {
	IFLA_PROTO_DOWN_REASON_UNSPEC = 0,
	IFLA_PROTO_DOWN_REASON_MASK = 1,
	IFLA_PROTO_DOWN_REASON_VALUE = 2,
	__IFLA_PROTO_DOWN_REASON_CNT = 3,
	IFLA_PROTO_DOWN_REASON_MAX = 2,
};

enum {
	IFLA_STATS_GETSET_UNSPEC = 0,
	IFLA_STATS_GET_FILTERS = 1,
	IFLA_STATS_SET_OFFLOAD_XSTATS_L3_STATS = 2,
	__IFLA_STATS_GETSET_MAX = 3,
};

enum {
	IFLA_STATS_UNSPEC = 0,
	IFLA_STATS_LINK_64 = 1,
	IFLA_STATS_LINK_XSTATS = 2,
	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
	IFLA_STATS_AF_SPEC = 5,
	__IFLA_STATS_MAX = 6,
};

enum {
	IFLA_UNSPEC = 0,
	IFLA_ADDRESS = 1,
	IFLA_BROADCAST = 2,
	IFLA_IFNAME = 3,
	IFLA_MTU = 4,
	IFLA_LINK = 5,
	IFLA_QDISC = 6,
	IFLA_STATS = 7,
	IFLA_COST = 8,
	IFLA_PRIORITY = 9,
	IFLA_MASTER = 10,
	IFLA_WIRELESS = 11,
	IFLA_PROTINFO = 12,
	IFLA_TXQLEN = 13,
	IFLA_MAP = 14,
	IFLA_WEIGHT = 15,
	IFLA_OPERSTATE = 16,
	IFLA_LINKMODE = 17,
	IFLA_LINKINFO = 18,
	IFLA_NET_NS_PID = 19,
	IFLA_IFALIAS = 20,
	IFLA_NUM_VF = 21,
	IFLA_VFINFO_LIST = 22,
	IFLA_STATS64 = 23,
	IFLA_VF_PORTS = 24,
	IFLA_PORT_SELF = 25,
	IFLA_AF_SPEC = 26,
	IFLA_GROUP = 27,
	IFLA_NET_NS_FD = 28,
	IFLA_EXT_MASK = 29,
	IFLA_PROMISCUITY = 30,
	IFLA_NUM_TX_QUEUES = 31,
	IFLA_NUM_RX_QUEUES = 32,
	IFLA_CARRIER = 33,
	IFLA_PHYS_PORT_ID = 34,
	IFLA_CARRIER_CHANGES = 35,
	IFLA_PHYS_SWITCH_ID = 36,
	IFLA_LINK_NETNSID = 37,
	IFLA_PHYS_PORT_NAME = 38,
	IFLA_PROTO_DOWN = 39,
	IFLA_GSO_MAX_SEGS = 40,
	IFLA_GSO_MAX_SIZE = 41,
	IFLA_PAD = 42,
	IFLA_XDP = 43,
	IFLA_EVENT = 44,
	IFLA_NEW_NETNSID = 45,
	IFLA_IF_NETNSID = 46,
	IFLA_TARGET_NETNSID = 46,
	IFLA_CARRIER_UP_COUNT = 47,
	IFLA_CARRIER_DOWN_COUNT = 48,
	IFLA_NEW_IFINDEX = 49,
	IFLA_MIN_MTU = 50,
	IFLA_MAX_MTU = 51,
	IFLA_PROP_LIST = 52,
	IFLA_ALT_IFNAME = 53,
	IFLA_PERM_ADDRESS = 54,
	IFLA_PROTO_DOWN_REASON = 55,
	IFLA_PARENT_DEV_NAME = 56,
	IFLA_PARENT_DEV_BUS_NAME = 57,
	IFLA_GRO_MAX_SIZE = 58,
	IFLA_TSO_MAX_SIZE = 59,
	IFLA_TSO_MAX_SEGS = 60,
	IFLA_ALLMULTI = 61,
	IFLA_DEVLINK_PORT = 62,
	IFLA_GSO_IPV4_MAX_SIZE = 63,
	IFLA_GRO_IPV4_MAX_SIZE = 64,
	IFLA_DPLL_PIN = 65,
	IFLA_MAX_PACING_OFFLOAD_HORIZON = 66,
	__IFLA_MAX = 67,
};

enum {
	IFLA_VF_INFO_UNSPEC = 0,
	IFLA_VF_INFO = 1,
	__IFLA_VF_INFO_MAX = 2,
};

enum {
	IFLA_VF_PORT_UNSPEC = 0,
	IFLA_VF_PORT = 1,
	__IFLA_VF_PORT_MAX = 2,
};

enum {
	IFLA_VF_STATS_RX_PACKETS = 0,
	IFLA_VF_STATS_TX_PACKETS = 1,
	IFLA_VF_STATS_RX_BYTES = 2,
	IFLA_VF_STATS_TX_BYTES = 3,
	IFLA_VF_STATS_BROADCAST = 4,
	IFLA_VF_STATS_MULTICAST = 5,
	IFLA_VF_STATS_PAD = 6,
	IFLA_VF_STATS_RX_DROPPED = 7,
	IFLA_VF_STATS_TX_DROPPED = 8,
	__IFLA_VF_STATS_MAX = 9,
};

enum {
	IFLA_VF_UNSPEC = 0,
	IFLA_VF_MAC = 1,
	IFLA_VF_VLAN = 2,
	IFLA_VF_TX_RATE = 3,
	IFLA_VF_SPOOFCHK = 4,
	IFLA_VF_LINK_STATE = 5,
	IFLA_VF_RATE = 6,
	IFLA_VF_RSS_QUERY_EN = 7,
	IFLA_VF_STATS = 8,
	IFLA_VF_TRUST = 9,
	IFLA_VF_IB_NODE_GUID = 10,
	IFLA_VF_IB_PORT_GUID = 11,
	IFLA_VF_VLAN_LIST = 12,
	IFLA_VF_BROADCAST = 13,
	__IFLA_VF_MAX = 14,
};

enum {
	IFLA_VF_VLAN_INFO_UNSPEC = 0,
	IFLA_VF_VLAN_INFO = 1,
	__IFLA_VF_VLAN_INFO_MAX = 2,
};

enum {
	IFLA_VTI_UNSPEC = 0,
	IFLA_VTI_LINK = 1,
	IFLA_VTI_IKEY = 2,
	IFLA_VTI_OKEY = 3,
	IFLA_VTI_LOCAL = 4,
	IFLA_VTI_REMOTE = 5,
	IFLA_VTI_FWMARK = 6,
	__IFLA_VTI_MAX = 7,
};

enum {
	IFLA_VXLAN_UNSPEC = 0,
	IFLA_VXLAN_ID = 1,
	IFLA_VXLAN_GROUP = 2,
	IFLA_VXLAN_LINK = 3,
	IFLA_VXLAN_LOCAL = 4,
	IFLA_VXLAN_TTL = 5,
	IFLA_VXLAN_TOS = 6,
	IFLA_VXLAN_LEARNING = 7,
	IFLA_VXLAN_AGEING = 8,
	IFLA_VXLAN_LIMIT = 9,
	IFLA_VXLAN_PORT_RANGE = 10,
	IFLA_VXLAN_PROXY = 11,
	IFLA_VXLAN_RSC = 12,
	IFLA_VXLAN_L2MISS = 13,
	IFLA_VXLAN_L3MISS = 14,
	IFLA_VXLAN_PORT = 15,
	IFLA_VXLAN_GROUP6 = 16,
	IFLA_VXLAN_LOCAL6 = 17,
	IFLA_VXLAN_UDP_CSUM = 18,
	IFLA_VXLAN_UDP_ZERO_CSUM6_TX = 19,
	IFLA_VXLAN_UDP_ZERO_CSUM6_RX = 20,
	IFLA_VXLAN_REMCSUM_TX = 21,
	IFLA_VXLAN_REMCSUM_RX = 22,
	IFLA_VXLAN_GBP = 23,
	IFLA_VXLAN_REMCSUM_NOPARTIAL = 24,
	IFLA_VXLAN_COLLECT_METADATA = 25,
	IFLA_VXLAN_LABEL = 26,
	IFLA_VXLAN_GPE = 27,
	IFLA_VXLAN_TTL_INHERIT = 28,
	IFLA_VXLAN_DF = 29,
	IFLA_VXLAN_VNIFILTER = 30,
	IFLA_VXLAN_LOCALBYPASS = 31,
	IFLA_VXLAN_LABEL_POLICY = 32,
	IFLA_VXLAN_RESERVED_BITS = 33,
	__IFLA_VXLAN_MAX = 34,
};

enum {
	IFLA_XDP_UNSPEC = 0,
	IFLA_XDP_FD = 1,
	IFLA_XDP_ATTACHED = 2,
	IFLA_XDP_FLAGS = 3,
	IFLA_XDP_PROG_ID = 4,
	IFLA_XDP_DRV_PROG_ID = 5,
	IFLA_XDP_SKB_PROG_ID = 6,
	IFLA_XDP_HW_PROG_ID = 7,
	IFLA_XDP_EXPECTED_FD = 8,
	__IFLA_XDP_MAX = 9,
};

enum {
	IFLA_XFRM_UNSPEC = 0,
	IFLA_XFRM_LINK = 1,
	IFLA_XFRM_IF_ID = 2,
	IFLA_XFRM_COLLECT_METADATA = 3,
	__IFLA_XFRM_MAX = 4,
};

enum {
	IF_ACT_NONE = -1,
	IF_ACT_FILTER = 0,
	IF_ACT_START = 1,
	IF_ACT_STOP = 2,
	IF_SRC_FILE = 3,
	IF_SRC_KERNEL = 4,
	IF_SRC_FILEADDR = 5,
	IF_SRC_KERNELADDR = 6,
};

enum {
	IF_LINK_MODE_DEFAULT = 0,
	IF_LINK_MODE_DORMANT = 1,
	IF_LINK_MODE_TESTING = 2,
};

enum {
	IF_OPER_UNKNOWN = 0,
	IF_OPER_NOTPRESENT = 1,
	IF_OPER_DOWN = 2,
	IF_OPER_LOWERLAYERDOWN = 3,
	IF_OPER_TESTING = 4,
	IF_OPER_DORMANT = 5,
	IF_OPER_UP = 6,
};

enum {
	IF_STATE_ACTION = 0,
	IF_STATE_SOURCE = 1,
	IF_STATE_END = 2,
};

enum {
	IIO_TOPOLOGY_TYPE = 0,
	UPI_TOPOLOGY_TYPE = 1,
	TOPOLOGY_MAX = 2,
};

enum {
	ILA_ATTR_UNSPEC = 0,
	ILA_ATTR_LOCATOR = 1,
	ILA_ATTR_IDENTIFIER = 2,
	ILA_ATTR_LOCATOR_MATCH = 3,
	ILA_ATTR_IFINDEX = 4,
	ILA_ATTR_DIR = 5,
	ILA_ATTR_PAD = 6,
	ILA_ATTR_CSUM_MODE = 7,
	ILA_ATTR_IDENT_TYPE = 8,
	ILA_ATTR_HOOK_TYPE = 9,
	__ILA_ATTR_MAX = 10,
};

enum {
	ILA_ATYPE_IID = 0,
	ILA_ATYPE_LUID = 1,
	ILA_ATYPE_VIRT_V4 = 2,
	ILA_ATYPE_VIRT_UNI_V6 = 3,
	ILA_ATYPE_VIRT_MULTI_V6 = 4,
	ILA_ATYPE_NONLOCAL_ADDR = 5,
	ILA_ATYPE_RSVD_1 = 6,
	ILA_ATYPE_RSVD_2 = 7,
	ILA_ATYPE_USE_FORMAT = 32,
};

enum {
	ILA_CMD_UNSPEC = 0,
	ILA_CMD_ADD = 1,
	ILA_CMD_DEL = 2,
	ILA_CMD_GET = 3,
	ILA_CMD_FLUSH = 4,
	__ILA_CMD_MAX = 5,
};

enum {
	ILA_CSUM_ADJUST_TRANSPORT = 0,
	ILA_CSUM_NEUTRAL_MAP = 1,
	ILA_CSUM_NO_ACTION = 2,
	ILA_CSUM_NEUTRAL_MAP_AUTO = 3,
};

enum {
	ILA_HOOK_ROUTE_OUTPUT = 0,
	ILA_HOOK_ROUTE_INPUT = 1,
};

enum {
	INET6_IFADDR_STATE_PREDAD = 0,
	INET6_IFADDR_STATE_DAD = 1,
	INET6_IFADDR_STATE_POSTDAD = 2,
	INET6_IFADDR_STATE_ERRDAD = 3,
	INET6_IFADDR_STATE_DEAD = 4,
};

enum {
	INET_DIAG_BC_NOP = 0,
	INET_DIAG_BC_JMP = 1,
	INET_DIAG_BC_S_GE = 2,
	INET_DIAG_BC_S_LE = 3,
	INET_DIAG_BC_D_GE = 4,
	INET_DIAG_BC_D_LE = 5,
	INET_DIAG_BC_AUTO = 6,
	INET_DIAG_BC_S_COND = 7,
	INET_DIAG_BC_D_COND = 8,
	INET_DIAG_BC_DEV_COND = 9,
	INET_DIAG_BC_MARK_COND = 10,
	INET_DIAG_BC_S_EQ = 11,
	INET_DIAG_BC_D_EQ = 12,
	INET_DIAG_BC_CGROUP_COND = 13,
};

enum {
	INET_DIAG_NONE = 0,
	INET_DIAG_MEMINFO = 1,
	INET_DIAG_INFO = 2,
	INET_DIAG_VEGASINFO = 3,
	INET_DIAG_CONG = 4,
	INET_DIAG_TOS = 5,
	INET_DIAG_TCLASS = 6,
	INET_DIAG_SKMEMINFO = 7,
	INET_DIAG_SHUTDOWN = 8,
	INET_DIAG_DCTCPINFO = 9,
	INET_DIAG_PROTOCOL = 10,
	INET_DIAG_SKV6ONLY = 11,
	INET_DIAG_LOCALS = 12,
	INET_DIAG_PEERS = 13,
	INET_DIAG_PAD = 14,
	INET_DIAG_MARK = 15,
	INET_DIAG_BBRINFO = 16,
	INET_DIAG_CLASS_ID = 17,
	INET_DIAG_MD5SIG = 18,
	INET_DIAG_ULP_INFO = 19,
	INET_DIAG_SK_BPF_STORAGES = 20,
	INET_DIAG_CGROUP_ID = 21,
	INET_DIAG_SOCKOPT = 22,
	__INET_DIAG_MAX = 23,
};

enum {
	INET_DIAG_REQ_NONE = 0,
	INET_DIAG_REQ_BYTECODE = 1,
	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
	INET_DIAG_REQ_PROTOCOL = 3,
	__INET_DIAG_REQ_MAX = 4,
};

enum {
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,
	INET_ECN_CE = 3,
	INET_ECN_MASK = 3,
};

enum {
	INET_FLAGS_PKTINFO = 0,
	INET_FLAGS_TTL = 1,
	INET_FLAGS_TOS = 2,
	INET_FLAGS_RECVOPTS = 3,
	INET_FLAGS_RETOPTS = 4,
	INET_FLAGS_PASSSEC = 5,
	INET_FLAGS_ORIGDSTADDR = 6,
	INET_FLAGS_CHECKSUM = 7,
	INET_FLAGS_RECVFRAGSIZE = 8,
	INET_FLAGS_RECVERR = 9,
	INET_FLAGS_RECVERR_RFC4884 = 10,
	INET_FLAGS_FREEBIND = 11,
	INET_FLAGS_HDRINCL = 12,
	INET_FLAGS_MC_LOOP = 13,
	INET_FLAGS_MC_ALL = 14,
	INET_FLAGS_TRANSPARENT = 15,
	INET_FLAGS_IS_ICSK = 16,
	INET_FLAGS_NODEFRAG = 17,
	INET_FLAGS_BIND_ADDRESS_NO_PORT = 18,
	INET_FLAGS_DEFER_CONNECT = 19,
	INET_FLAGS_MC6_LOOP = 20,
	INET_FLAGS_RECVERR6_RFC4884 = 21,
	INET_FLAGS_MC6_ALL = 22,
	INET_FLAGS_AUTOFLOWLABEL_SET = 23,
	INET_FLAGS_AUTOFLOWLABEL = 24,
	INET_FLAGS_DONTFRAG = 25,
	INET_FLAGS_RECVERR6 = 26,
	INET_FLAGS_REPFLOW = 27,
	INET_FLAGS_RTALERT_ISOLATE = 28,
	INET_FLAGS_SNDFLOW = 29,
	INET_FLAGS_RTALERT = 30,
};

enum {
	INET_FRAG_FIRST_IN = 1,
	INET_FRAG_LAST_IN = 2,
	INET_FRAG_COMPLETE = 4,
	INET_FRAG_HASH_DEAD = 8,
	INET_FRAG_DROP = 16,
};

enum {
	INET_ULP_INFO_UNSPEC = 0,
	INET_ULP_INFO_NAME = 1,
	INET_ULP_INFO_TLS = 2,
	INET_ULP_INFO_MPTCP = 3,
	__INET_ULP_INFO_MAX = 4,
};

enum {
	INSN_F_FRAMENO_MASK = 7,
	INSN_F_SPI_MASK = 63,
	INSN_F_SPI_SHIFT = 3,
	INSN_F_STACK_ACCESS = 512,
};

enum {
	INTEL_ADVANCED_CONTEXT = 0,
	INTEL_LEGACY_32B_CONTEXT = 1,
	INTEL_ADVANCED_AD_CONTEXT = 2,
	INTEL_LEGACY_64B_CONTEXT = 3,
};

enum {
	INTEL_CONTEXT_SCHEDULE_IN = 0,
	INTEL_CONTEXT_SCHEDULE_OUT = 1,
	INTEL_CONTEXT_SCHEDULE_PREEMPTED = 2,
};

enum {
	INTEL_RPS_ENABLED = 0,
	INTEL_RPS_ACTIVE = 1,
	INTEL_RPS_INTERRUPTS = 2,
	INTEL_RPS_TIMER = 3,
};

enum {
	INTEL_WAKEREF_PUT_ASYNC_BIT = 0,
	__INTEL_WAKEREF_PUT_LAST_BIT__ = 1,
};

enum {
	INVERT = 1,
	PROCESS_AND = 2,
	PROCESS_OR = 4,
};

enum {
	IOAM6_ATTR_UNSPEC = 0,
	IOAM6_ATTR_NS_ID = 1,
	IOAM6_ATTR_NS_DATA = 2,
	IOAM6_ATTR_NS_DATA_WIDE = 3,
	IOAM6_ATTR_SC_ID = 4,
	IOAM6_ATTR_SC_DATA = 5,
	IOAM6_ATTR_SC_NONE = 6,
	IOAM6_ATTR_PAD = 7,
	__IOAM6_ATTR_MAX = 8,
};

enum {
	IOAM6_CMD_UNSPEC = 0,
	IOAM6_CMD_ADD_NAMESPACE = 1,
	IOAM6_CMD_DEL_NAMESPACE = 2,
	IOAM6_CMD_DUMP_NAMESPACES = 3,
	IOAM6_CMD_ADD_SCHEMA = 4,
	IOAM6_CMD_DEL_SCHEMA = 5,
	IOAM6_CMD_DUMP_SCHEMAS = 6,
	IOAM6_CMD_NS_SET_SCHEMA = 7,
	__IOAM6_CMD_MAX = 8,
};

enum {
	IOAM6_IPTUNNEL_UNSPEC = 0,
	IOAM6_IPTUNNEL_MODE = 1,
	IOAM6_IPTUNNEL_DST = 2,
	IOAM6_IPTUNNEL_TRACE = 3,
	IOAM6_IPTUNNEL_FREQ_K = 4,
	IOAM6_IPTUNNEL_FREQ_N = 5,
	IOAM6_IPTUNNEL_SRC = 6,
	__IOAM6_IPTUNNEL_MAX = 7,
};

enum {
	IOBL_BUF_RING = 1,
	IOBL_INC = 2,
};

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	IOCB_CMD_POLL = 5,
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

enum {
	IOMMUFD_ACCESS_RW_READ = 0,
	IOMMUFD_ACCESS_RW_WRITE = 1,
	IOMMUFD_ACCESS_RW_KTHREAD = 2,
	__IOMMUFD_ACCESS_RW_SLOW_PATH = 4,
};

enum {
	IOMMUFD_CMD_BASE = 128,
	IOMMUFD_CMD_DESTROY = 128,
	IOMMUFD_CMD_IOAS_ALLOC = 129,
	IOMMUFD_CMD_IOAS_ALLOW_IOVAS = 130,
	IOMMUFD_CMD_IOAS_COPY = 131,
	IOMMUFD_CMD_IOAS_IOVA_RANGES = 132,
	IOMMUFD_CMD_IOAS_MAP = 133,
	IOMMUFD_CMD_IOAS_UNMAP = 134,
	IOMMUFD_CMD_OPTION = 135,
	IOMMUFD_CMD_VFIO_IOAS = 136,
	IOMMUFD_CMD_HWPT_ALLOC = 137,
	IOMMUFD_CMD_GET_HW_INFO = 138,
	IOMMUFD_CMD_HWPT_SET_DIRTY_TRACKING = 139,
	IOMMUFD_CMD_HWPT_GET_DIRTY_BITMAP = 140,
	IOMMUFD_CMD_HWPT_INVALIDATE = 141,
	IOMMUFD_CMD_FAULT_QUEUE_ALLOC = 142,
	IOMMUFD_CMD_IOAS_MAP_FILE = 143,
	IOMMUFD_CMD_VIOMMU_ALLOC = 144,
	IOMMUFD_CMD_VDEVICE_ALLOC = 145,
	IOMMUFD_CMD_IOAS_CHANGE_PROCESS = 146,
};

enum {
	IOMMU_SET_DOMAIN_MUST_SUCCEED = 1,
};

enum {
	IOPRIO_CLASS_NONE = 0,
	IOPRIO_CLASS_RT = 1,
	IOPRIO_CLASS_BE = 2,
	IOPRIO_CLASS_IDLE = 3,
	IOPRIO_CLASS_INVALID = 7,
};

enum {
	IOPRIO_HINT_NONE = 0,
	IOPRIO_HINT_DEV_DURATION_LIMIT_1 = 1,
	IOPRIO_HINT_DEV_DURATION_LIMIT_2 = 2,
	IOPRIO_HINT_DEV_DURATION_LIMIT_3 = 3,
	IOPRIO_HINT_DEV_DURATION_LIMIT_4 = 4,
	IOPRIO_HINT_DEV_DURATION_LIMIT_5 = 5,
	IOPRIO_HINT_DEV_DURATION_LIMIT_6 = 6,
	IOPRIO_HINT_DEV_DURATION_LIMIT_7 = 7,
};

enum {
	IOPRIO_WHO_PROCESS = 1,
	IOPRIO_WHO_PGRP = 2,
	IOPRIO_WHO_USER = 3,
};

enum {
	IOPT_ALLOC_IOVA = 1,
};

enum {
	IOPT_PAGES_ACCOUNT_NONE = 0,
	IOPT_PAGES_ACCOUNT_USER = 1,
	IOPT_PAGES_ACCOUNT_MM = 2,
	IOPT_PAGES_ACCOUNT_MODE_NUM = 3,
};

enum {
	IORES_DESC_NONE = 0,
	IORES_DESC_CRASH_KERNEL = 1,
	IORES_DESC_ACPI_TABLES = 2,
	IORES_DESC_ACPI_NV_STORAGE = 3,
	IORES_DESC_PERSISTENT_MEMORY = 4,
	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
	IORES_DESC_RESERVED = 7,
	IORES_DESC_SOFT_RESERVED = 8,
	IORES_DESC_CXL = 9,
};

enum {
	IORES_MAP_SYSTEM_RAM = 1,
	IORES_MAP_ENCRYPTED = 2,
};

enum {
	IORING_MEM_REGION_REG_WAIT_ARG = 1,
};

enum {
	IORING_MEM_REGION_TYPE_USER = 1,
};

enum {
	IORING_REGISTER_SRC_REGISTERED = 1,
	IORING_REGISTER_DST_REPLACE = 2,
};

enum {
	IORING_REG_WAIT_TS = 1,
};

enum {
	IORING_RSRC_FILE = 0,
	IORING_RSRC_BUFFER = 1,
};

enum {
	IOU_F_TWQ_LAZY_WAKE = 1,
};

enum {
	IOU_OK = 0,
	IOU_ISSUE_SKIP_COMPLETE = -529,
	IOU_REQUEUE = -3072,
	IOU_STOP_MULTISHOT = -125,
};

enum {
	IOU_POLL_DONE = 0,
	IOU_POLL_NO_ACTION = 1,
	IOU_POLL_REMOVE_POLL_USE_RES = 2,
	IOU_POLL_REISSUE = 3,
	IOU_POLL_REQUEUE = 4,
};

enum {
	IO_ACCT_STALLED_BIT = 0,
};

enum {
	IO_APOLL_OK = 0,
	IO_APOLL_ABORTED = 1,
	IO_APOLL_READY = 2,
};

enum {
	IO_CHECK_CQ_OVERFLOW_BIT = 0,
	IO_CHECK_CQ_DROPPED_BIT = 1,
};

enum {
	IO_EVENTFD_OP_SIGNAL_BIT = 0,
};

enum {
	IO_REGION_F_VMAP = 1,
	IO_REGION_F_USER_PROVIDED = 2,
	IO_REGION_F_SINGLE_REF = 4,
};

enum {
	IO_SQ_THREAD_SHOULD_STOP = 0,
	IO_SQ_THREAD_SHOULD_PARK = 1,
};

enum {
	IO_TREE_FS_PINNED_EXTENTS = 0,
	IO_TREE_FS_EXCLUDED_EXTENTS = 1,
	IO_TREE_BTREE_INODE_IO = 2,
	IO_TREE_INODE_IO = 3,
	IO_TREE_RELOC_BLOCKS = 4,
	IO_TREE_TRANS_DIRTY_PAGES = 5,
	IO_TREE_ROOT_DIRTY_LOG_PAGES = 6,
	IO_TREE_INODE_FILE_EXTENT = 7,
	IO_TREE_LOG_CSUM_RANGE = 8,
	IO_TREE_SELFTEST = 9,
	IO_TREE_DEVICE_ALLOC_STATE = 10,
};

enum {
	IO_WORKER_F_UP = 0,
	IO_WORKER_F_RUNNING = 1,
	IO_WORKER_F_FREE = 2,
	IO_WORKER_F_BOUND = 3,
};

enum {
	IO_WQ_ACCT_BOUND = 0,
	IO_WQ_ACCT_UNBOUND = 1,
	IO_WQ_ACCT_NR = 2,
};

enum {
	IO_WQ_BIT_EXIT = 0,
};

enum {
	IO_WQ_WORK_CANCEL = 1,
	IO_WQ_WORK_HASHED = 2,
	IO_WQ_WORK_UNBOUND = 4,
	IO_WQ_WORK_CONCURRENT = 16,
	IO_WQ_HASH_SHIFT = 24,
};

enum {
	IP6MRA_CREPORT_UNSPEC = 0,
	IP6MRA_CREPORT_MSGTYPE = 1,
	IP6MRA_CREPORT_MIF_ID = 2,
	IP6MRA_CREPORT_SRC_ADDR = 3,
	IP6MRA_CREPORT_DST_ADDR = 4,
	IP6MRA_CREPORT_PKT = 5,
	__IP6MRA_CREPORT_MAX = 6,
};

enum {
	IP6T_HL_EQ = 0,
	IP6T_HL_NE = 1,
	IP6T_HL_LT = 2,
	IP6T_HL_GT = 3,
};

enum {
	IP6T_HL_SET = 0,
	IP6T_HL_INC = 1,
	IP6T_HL_DEC = 2,
};

enum {
	IP6_FH_F_FRAG = 1,
	IP6_FH_F_AUTH = 2,
	IP6_FH_F_SKIP_RH = 4,
};

enum {
	IPMRA_CREPORT_UNSPEC = 0,
	IPMRA_CREPORT_MSGTYPE = 1,
	IPMRA_CREPORT_VIF_ID = 2,
	IPMRA_CREPORT_SRC_ADDR = 3,
	IPMRA_CREPORT_DST_ADDR = 4,
	IPMRA_CREPORT_PKT = 5,
	IPMRA_CREPORT_TABLE = 6,
	__IPMRA_CREPORT_MAX = 7,
};

enum {
	IPMRA_TABLE_UNSPEC = 0,
	IPMRA_TABLE_ID = 1,
	IPMRA_TABLE_CACHE_RES_QUEUE_LEN = 2,
	IPMRA_TABLE_MROUTE_REG_VIF_NUM = 3,
	IPMRA_TABLE_MROUTE_DO_ASSERT = 4,
	IPMRA_TABLE_MROUTE_DO_PIM = 5,
	IPMRA_TABLE_VIFS = 6,
	IPMRA_TABLE_MROUTE_DO_WRVIFWHOLE = 7,
	__IPMRA_TABLE_MAX = 8,
};

enum {
	IPMRA_VIFA_UNSPEC = 0,
	IPMRA_VIFA_IFINDEX = 1,
	IPMRA_VIFA_VIF_ID = 2,
	IPMRA_VIFA_FLAGS = 3,
	IPMRA_VIFA_BYTES_IN = 4,
	IPMRA_VIFA_BYTES_OUT = 5,
	IPMRA_VIFA_PACKETS_IN = 6,
	IPMRA_VIFA_PACKETS_OUT = 7,
	IPMRA_VIFA_LOCAL_ADDR = 8,
	IPMRA_VIFA_REMOTE_ADDR = 9,
	IPMRA_VIFA_PAD = 10,
	__IPMRA_VIFA_MAX = 11,
};

enum {
	IPMRA_VIF_UNSPEC = 0,
	IPMRA_VIF = 1,
	__IPMRA_VIF_MAX = 2,
};

enum {
	IPPROTO_IP = 0,
	IPPROTO_ICMP = 1,
	IPPROTO_IGMP = 2,
	IPPROTO_IPIP = 4,
	IPPROTO_TCP = 6,
	IPPROTO_EGP = 8,
	IPPROTO_PUP = 12,
	IPPROTO_UDP = 17,
	IPPROTO_IDP = 22,
	IPPROTO_TP = 29,
	IPPROTO_DCCP = 33,
	IPPROTO_IPV6 = 41,
	IPPROTO_RSVP = 46,
	IPPROTO_GRE = 47,
	IPPROTO_ESP = 50,
	IPPROTO_AH = 51,
	IPPROTO_MTP = 92,
	IPPROTO_BEETPH = 94,
	IPPROTO_ENCAP = 98,
	IPPROTO_PIM = 103,
	IPPROTO_COMP = 108,
	IPPROTO_L2TP = 115,
	IPPROTO_SCTP = 132,
	IPPROTO_UDPLITE = 136,
	IPPROTO_MPLS = 137,
	IPPROTO_ETHERNET = 143,
	IPPROTO_AGGFRAG = 144,
	IPPROTO_RAW = 255,
	IPPROTO_SMC = 256,
	IPPROTO_MPTCP = 262,
	IPPROTO_MAX = 263,
};

enum {
	IPRANGE_SRC = 1,
	IPRANGE_DST = 2,
	IPRANGE_SRC_INV = 16,
	IPRANGE_DST_INV = 32,
};

enum {
	IPSEC_DIR_ANY = 0,
	IPSEC_DIR_INBOUND = 1,
	IPSEC_DIR_OUTBOUND = 2,
	IPSEC_DIR_FWD = 3,
	IPSEC_DIR_MAX = 4,
	IPSEC_DIR_INVALID = 5,
};

enum {
	IPSEC_LEVEL_DEFAULT = 0,
	IPSEC_LEVEL_USE = 1,
	IPSEC_LEVEL_REQUIRE = 2,
	IPSEC_LEVEL_UNIQUE = 3,
};

enum {
	IPSEC_MODE_ANY = 0,
	IPSEC_MODE_TRANSPORT = 1,
	IPSEC_MODE_TUNNEL = 2,
	IPSEC_MODE_BEET = 3,
	IPSEC_MODE_IPTFS = 4,
};

enum {
	IPSEC_POLICY_DISCARD = 0,
	IPSEC_POLICY_NONE = 1,
	IPSEC_POLICY_IPSEC = 2,
	IPSEC_POLICY_ENTRUST = 3,
	IPSEC_POLICY_BYPASS = 4,
};

enum {
	IPSET_ADD_STORE_PLAIN_TIMEOUT = -1,
	IPSET_ADD_FAILED = 1,
	IPSET_ADD_START_STORED_TIMEOUT = 2,
};

enum {
	IPSET_ATTR_ETHER = 17,
	IPSET_ATTR_NAME = 18,
	IPSET_ATTR_NAMEREF = 19,
	IPSET_ATTR_IP2 = 20,
	IPSET_ATTR_CIDR2 = 21,
	IPSET_ATTR_IP2_TO = 22,
	IPSET_ATTR_IFACE = 23,
	IPSET_ATTR_BYTES = 24,
	IPSET_ATTR_PACKETS = 25,
	IPSET_ATTR_COMMENT = 26,
	IPSET_ATTR_SKBMARK = 27,
	IPSET_ATTR_SKBPRIO = 28,
	IPSET_ATTR_SKBQUEUE = 29,
	IPSET_ATTR_PAD = 30,
	__IPSET_ATTR_ADT_MAX = 31,
};

enum {
	IPSET_ATTR_IP = 1,
	IPSET_ATTR_IP_FROM = 1,
	IPSET_ATTR_IP_TO = 2,
	IPSET_ATTR_CIDR = 3,
	IPSET_ATTR_PORT = 4,
	IPSET_ATTR_PORT_FROM = 4,
	IPSET_ATTR_PORT_TO = 5,
	IPSET_ATTR_TIMEOUT = 6,
	IPSET_ATTR_PROTO = 7,
	IPSET_ATTR_CADT_FLAGS = 8,
	IPSET_ATTR_CADT_LINENO = 9,
	IPSET_ATTR_MARK = 10,
	IPSET_ATTR_MARKMASK = 11,
	IPSET_ATTR_BITMASK = 12,
	IPSET_ATTR_CADT_MAX = 16,
	IPSET_ATTR_INITVAL = 17,
	IPSET_ATTR_HASHSIZE = 18,
	IPSET_ATTR_MAXELEM = 19,
	IPSET_ATTR_NETMASK = 20,
	IPSET_ATTR_BUCKETSIZE = 21,
	IPSET_ATTR_RESIZE = 22,
	IPSET_ATTR_SIZE = 23,
	IPSET_ATTR_ELEMENTS = 24,
	IPSET_ATTR_REFERENCES = 25,
	IPSET_ATTR_MEMSIZE = 26,
	__IPSET_ATTR_CREATE_MAX = 27,
};

enum {
	IPSET_ATTR_IPADDR_IPV4 = 1,
	IPSET_ATTR_IPADDR_IPV6 = 2,
	__IPSET_ATTR_IPADDR_MAX = 3,
};

enum {
	IPSET_ATTR_UNSPEC = 0,
	IPSET_ATTR_PROTOCOL = 1,
	IPSET_ATTR_SETNAME = 2,
	IPSET_ATTR_TYPENAME = 3,
	IPSET_ATTR_SETNAME2 = 3,
	IPSET_ATTR_REVISION = 4,
	IPSET_ATTR_FAMILY = 5,
	IPSET_ATTR_FLAGS = 6,
	IPSET_ATTR_DATA = 7,
	IPSET_ATTR_ADT = 8,
	IPSET_ATTR_LINENO = 9,
	IPSET_ATTR_PROTOCOL_MIN = 10,
	IPSET_ATTR_REVISION_MIN = 10,
	IPSET_ATTR_INDEX = 11,
	__IPSET_ATTR_CMD_MAX = 12,
};

enum {
	IPSET_CB_NET = 0,
	IPSET_CB_PROTO = 1,
	IPSET_CB_DUMP = 2,
	IPSET_CB_INDEX = 3,
	IPSET_CB_PRIVATE = 4,
	IPSET_CB_ARG0 = 5,
};

enum {
	IPSET_COUNTER_NONE = 0,
	IPSET_COUNTER_EQ = 1,
	IPSET_COUNTER_NE = 2,
	IPSET_COUNTER_LT = 3,
	IPSET_COUNTER_GT = 4,
};

enum {
	IPSET_ERR_BITMAP_RANGE = 4352,
	IPSET_ERR_BITMAP_RANGE_SIZE = 4353,
};

enum {
	IPSET_ERR_HASH_FULL = 4352,
	IPSET_ERR_HASH_ELEM = 4353,
	IPSET_ERR_INVALID_PROTO = 4354,
	IPSET_ERR_MISSING_PROTO = 4355,
	IPSET_ERR_HASH_RANGE_UNSUPPORTED = 4356,
	IPSET_ERR_HASH_RANGE = 4357,
};

enum {
	IPSET_ERR_NAME = 4352,
	IPSET_ERR_LOOP = 4353,
	IPSET_ERR_BEFORE = 4354,
	IPSET_ERR_NAMEREF = 4355,
	IPSET_ERR_LIST_FULL = 4356,
	IPSET_ERR_REF_EXIST = 4357,
};

enum {
	IPSTATS_MIB_NUM = 0,
	IPSTATS_MIB_INPKTS = 1,
	IPSTATS_MIB_INOCTETS = 2,
	IPSTATS_MIB_INDELIVERS = 3,
	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
	IPSTATS_MIB_OUTREQUESTS = 5,
	IPSTATS_MIB_OUTOCTETS = 6,
	IPSTATS_MIB_INHDRERRORS = 7,
	IPSTATS_MIB_INTOOBIGERRORS = 8,
	IPSTATS_MIB_INNOROUTES = 9,
	IPSTATS_MIB_INADDRERRORS = 10,
	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
	IPSTATS_MIB_INDISCARDS = 13,
	IPSTATS_MIB_OUTDISCARDS = 14,
	IPSTATS_MIB_OUTNOROUTES = 15,
	IPSTATS_MIB_REASMTIMEOUT = 16,
	IPSTATS_MIB_REASMREQDS = 17,
	IPSTATS_MIB_REASMOKS = 18,
	IPSTATS_MIB_REASMFAILS = 19,
	IPSTATS_MIB_FRAGOKS = 20,
	IPSTATS_MIB_FRAGFAILS = 21,
	IPSTATS_MIB_FRAGCREATES = 22,
	IPSTATS_MIB_INMCASTPKTS = 23,
	IPSTATS_MIB_OUTMCASTPKTS = 24,
	IPSTATS_MIB_INBCASTPKTS = 25,
	IPSTATS_MIB_OUTBCASTPKTS = 26,
	IPSTATS_MIB_INMCASTOCTETS = 27,
	IPSTATS_MIB_OUTMCASTOCTETS = 28,
	IPSTATS_MIB_INBCASTOCTETS = 29,
	IPSTATS_MIB_OUTBCASTOCTETS = 30,
	IPSTATS_MIB_CSUMERRORS = 31,
	IPSTATS_MIB_NOECTPKTS = 32,
	IPSTATS_MIB_ECT1PKTS = 33,
	IPSTATS_MIB_ECT0PKTS = 34,
	IPSTATS_MIB_CEPKTS = 35,
	IPSTATS_MIB_REASM_OVERLAPS = 36,
	IPSTATS_MIB_OUTPKTS = 37,
	__IPSTATS_MIB_MAX = 38,
};

enum {
	IPT_TTL_EQ = 0,
	IPT_TTL_NE = 1,
	IPT_TTL_LT = 2,
	IPT_TTL_GT = 3,
};

enum {
	IPT_TTL_SET = 0,
	IPT_TTL_INC = 1,
	IPT_TTL_DEC = 2,
};

enum {
	IPV4_DEVCONF_FORWARDING = 1,
	IPV4_DEVCONF_MC_FORWARDING = 2,
	IPV4_DEVCONF_PROXY_ARP = 3,
	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
	IPV4_DEVCONF_SEND_REDIRECTS = 6,
	IPV4_DEVCONF_SHARED_MEDIA = 7,
	IPV4_DEVCONF_RP_FILTER = 8,
	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
	IPV4_DEVCONF_BOOTP_RELAY = 10,
	IPV4_DEVCONF_LOG_MARTIANS = 11,
	IPV4_DEVCONF_TAG = 12,
	IPV4_DEVCONF_ARPFILTER = 13,
	IPV4_DEVCONF_MEDIUM_ID = 14,
	IPV4_DEVCONF_NOXFRM = 15,
	IPV4_DEVCONF_NOPOLICY = 16,
	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
	IPV4_DEVCONF_ARP_IGNORE = 19,
	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
	IPV4_DEVCONF_ARP_ACCEPT = 21,
	IPV4_DEVCONF_ARP_NOTIFY = 22,
	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
	IPV4_DEVCONF_SRC_VMARK = 24,
	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
	IPV4_DEVCONF_BC_FORWARDING = 32,
	IPV4_DEVCONF_ARP_EVICT_NOCARRIER = 33,
	__IPV4_DEVCONF_MAX = 34,
};

enum {
	IPV6_SADDR_RULE_INIT = 0,
	IPV6_SADDR_RULE_LOCAL = 1,
	IPV6_SADDR_RULE_SCOPE = 2,
	IPV6_SADDR_RULE_PREFERRED = 3,
	IPV6_SADDR_RULE_HOA = 4,
	IPV6_SADDR_RULE_OIF = 5,
	IPV6_SADDR_RULE_LABEL = 6,
	IPV6_SADDR_RULE_PRIVACY = 7,
	IPV6_SADDR_RULE_ORCHID = 8,
	IPV6_SADDR_RULE_PREFIX = 9,
	IPV6_SADDR_RULE_NOT_OPTIMISTIC = 10,
	IPV6_SADDR_RULE_MAX = 11,
};

enum {
	IP_TUNNEL_CSUM_BIT = 0,
	IP_TUNNEL_ROUTING_BIT = 1,
	IP_TUNNEL_KEY_BIT = 2,
	IP_TUNNEL_SEQ_BIT = 3,
	IP_TUNNEL_STRICT_BIT = 4,
	IP_TUNNEL_REC_BIT = 5,
	IP_TUNNEL_VERSION_BIT = 6,
	IP_TUNNEL_NO_KEY_BIT = 7,
	IP_TUNNEL_DONT_FRAGMENT_BIT = 8,
	IP_TUNNEL_OAM_BIT = 9,
	IP_TUNNEL_CRIT_OPT_BIT = 10,
	IP_TUNNEL_GENEVE_OPT_BIT = 11,
	IP_TUNNEL_VXLAN_OPT_BIT = 12,
	IP_TUNNEL_NOCACHE_BIT = 13,
	IP_TUNNEL_ERSPAN_OPT_BIT = 14,
	IP_TUNNEL_GTP_OPT_BIT = 15,
	IP_TUNNEL_VTI_BIT = 16,
	IP_TUNNEL_SIT_ISATAP_BIT = 16,
	IP_TUNNEL_PFCP_OPT_BIT = 17,
	__IP_TUNNEL_FLAG_NUM = 18,
};

enum {
	IRQCHIP_FWNODE_REAL = 0,
	IRQCHIP_FWNODE_NAMED = 1,
	IRQCHIP_FWNODE_NAMED_ID = 2,
};

enum {
	IRQCHIP_SET_TYPE_MASKED = 1,
	IRQCHIP_EOI_IF_HANDLED = 2,
	IRQCHIP_MASK_ON_SUSPEND = 4,
	IRQCHIP_ONOFFLINE_ENABLED = 8,
	IRQCHIP_SKIP_SET_WAKE = 16,
	IRQCHIP_ONESHOT_SAFE = 32,
	IRQCHIP_EOI_THREADED = 64,
	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
	IRQCHIP_SUPPORTS_NMI = 256,
	IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,
	IRQCHIP_AFFINITY_PRE_STARTUP = 1024,
	IRQCHIP_IMMUTABLE = 2048,
	IRQCHIP_MOVE_DEFERRED = 4096,
};

enum {
	IRQC_IS_HARDIRQ = 0,
	IRQC_IS_NESTED = 1,
};

enum {
	IRQD_TRIGGER_MASK = 15,
	IRQD_SETAFFINITY_PENDING = 256,
	IRQD_ACTIVATED = 512,
	IRQD_NO_BALANCING = 1024,
	IRQD_PER_CPU = 2048,
	IRQD_AFFINITY_SET = 4096,
	IRQD_LEVEL = 8192,
	IRQD_WAKEUP_STATE = 16384,
	IRQD_IRQ_DISABLED = 65536,
	IRQD_IRQ_MASKED = 131072,
	IRQD_IRQ_INPROGRESS = 262144,
	IRQD_WAKEUP_ARMED = 524288,
	IRQD_FORWARDED_TO_VCPU = 1048576,
	IRQD_AFFINITY_MANAGED = 2097152,
	IRQD_IRQ_STARTED = 4194304,
	IRQD_MANAGED_SHUTDOWN = 8388608,
	IRQD_SINGLE_TARGET = 16777216,
	IRQD_DEFAULT_TRIGGER_SET = 33554432,
	IRQD_CAN_RESERVE = 67108864,
	IRQD_HANDLE_ENFORCE_IRQCTX = 134217728,
	IRQD_AFFINITY_ON_ACTIVATE = 268435456,
	IRQD_IRQ_ENABLED_ON_SUSPEND = 536870912,
	IRQD_RESEND_WHEN_IN_PROGRESS = 1073741824,
};

enum {
	IRQS_AUTODETECT = 1,
	IRQS_SPURIOUS_DISABLED = 2,
	IRQS_POLL_INPROGRESS = 8,
	IRQS_ONESHOT = 32,
	IRQS_REPLAY = 64,
	IRQS_WAITING = 128,
	IRQS_PENDING = 512,
	IRQS_SUSPENDED = 2048,
	IRQS_TIMINGS = 4096,
	IRQS_NMI = 8192,
	IRQS_SYSFS = 16384,
};

enum {
	IRQTF_RUNTHREAD = 0,
	IRQTF_WARNED = 1,
	IRQTF_AFFINITY = 2,
	IRQTF_FORCED_THREAD = 3,
	IRQTF_READY = 4,
};

enum {
	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
	IRQ_DOMAIN_NAME_ALLOCATED = 2,
	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
	IRQ_DOMAIN_FLAG_MSI = 16,
	IRQ_DOMAIN_FLAG_ISOLATED_MSI = 32,
	IRQ_DOMAIN_FLAG_NO_MAP = 64,
	IRQ_DOMAIN_FLAG_MSI_PARENT = 256,
	IRQ_DOMAIN_FLAG_MSI_DEVICE = 512,
	IRQ_DOMAIN_FLAG_DESTROY_GC = 1024,
	IRQ_DOMAIN_FLAG_NONCORE = 65536,
};

enum {
	IRQ_REMAP_XAPIC_MODE = 0,
	IRQ_REMAP_X2APIC_MODE = 1,
};

enum {
	IRQ_SET_MASK_OK = 0,
	IRQ_SET_MASK_OK_NOCOPY = 1,
	IRQ_SET_MASK_OK_DONE = 2,
};

enum {
	IRQ_STARTUP_NORMAL = 0,
	IRQ_STARTUP_MANAGED = 1,
	IRQ_STARTUP_ABORT = 2,
};

enum {
	IRQ_TYPE_NONE = 0,
	IRQ_TYPE_EDGE_RISING = 1,
	IRQ_TYPE_EDGE_FALLING = 2,
	IRQ_TYPE_EDGE_BOTH = 3,
	IRQ_TYPE_LEVEL_HIGH = 4,
	IRQ_TYPE_LEVEL_LOW = 8,
	IRQ_TYPE_LEVEL_MASK = 12,
	IRQ_TYPE_SENSE_MASK = 15,
	IRQ_TYPE_DEFAULT = 15,
	IRQ_TYPE_PROBE = 16,
	IRQ_LEVEL = 256,
	IRQ_PER_CPU = 512,
	IRQ_NOPROBE = 1024,
	IRQ_NOREQUEST = 2048,
	IRQ_NOAUTOEN = 4096,
	IRQ_NO_BALANCING = 8192,
	IRQ_NESTED_THREAD = 32768,
	IRQ_NOTHREAD = 65536,
	IRQ_PER_CPU_DEVID = 131072,
	IRQ_IS_POLLED = 262144,
	IRQ_DISABLE_UNLAZY = 524288,
	IRQ_HIDDEN = 1048576,
	IRQ_NO_DEBUG = 2097152,
};

enum {
	IVBEP_PCI_UNCORE_HA = 0,
	IVBEP_PCI_UNCORE_IMC = 1,
	IVBEP_PCI_UNCORE_IRP = 2,
	IVBEP_PCI_UNCORE_QPI = 3,
	IVBEP_PCI_UNCORE_R2PCIE = 4,
	IVBEP_PCI_UNCORE_R3QPI = 5,
};

enum {
	I_DATA_SEM_NORMAL = 0,
	I_DATA_SEM_OTHER = 1,
	I_DATA_SEM_QUOTA = 2,
	I_DATA_SEM_EA = 3,
};

enum {
	I_LCOEF_RBPS = 0,
	I_LCOEF_RSEQIOPS = 1,
	I_LCOEF_RRANDIOPS = 2,
	I_LCOEF_WBPS = 3,
	I_LCOEF_WSEQIOPS = 4,
	I_LCOEF_WRANDIOPS = 5,
	NR_I_LCOEFS = 6,
};

enum {
	KBUF_MODE_EXPAND = 1,
	KBUF_MODE_FREE = 2,
};

enum {
	KERNEL_PARAM_FL_UNSAFE = 1,
	KERNEL_PARAM_FL_HWPARAM = 2,
};

enum {
	KERNEL_PARAM_OPS_FL_NOARG = 1,
};

enum {
	KEY_MASTER = 0,
	KEY_MIN = 0,
	KEY_1 = 1,
	KEY_2 = 2,
	KEY_3 = 3,
	KEY_MAX = 3,
};

enum {
	KF_ARG_DYNPTR_ID = 0,
	KF_ARG_LIST_HEAD_ID = 1,
	KF_ARG_LIST_NODE_ID = 2,
	KF_ARG_RB_ROOT_ID = 3,
	KF_ARG_RB_NODE_ID = 4,
	KF_ARG_WORKQUEUE_ID = 5,
};

enum {
	KNL_PCI_UNCORE_MC_UCLK = 0,
	KNL_PCI_UNCORE_MC_DCLK = 1,
	KNL_PCI_UNCORE_EDC_UCLK = 2,
	KNL_PCI_UNCORE_EDC_ECLK = 3,
	KNL_PCI_UNCORE_M2PCIE = 4,
	KNL_PCI_UNCORE_IRP = 5,
};

enum {
	KTW_FREEZABLE = 1,
};

enum {
	KYBER_ASYNC_PERCENT = 75,
};

enum {
	KYBER_LATENCY_SHIFT = 2,
	KYBER_GOOD_BUCKETS = 4,
	KYBER_LATENCY_BUCKETS = 8,
};

enum {
	KYBER_READ = 0,
	KYBER_WRITE = 1,
	KYBER_DISCARD = 2,
	KYBER_OTHER = 3,
	KYBER_NUM_DOMAINS = 4,
};

enum {
	KYBER_TOTAL_LATENCY = 0,
	KYBER_IO_LATENCY = 1,
};

enum {
	L2TP_ATTR_NONE = 0,
	L2TP_ATTR_PW_TYPE = 1,
	L2TP_ATTR_ENCAP_TYPE = 2,
	L2TP_ATTR_OFFSET = 3,
	L2TP_ATTR_DATA_SEQ = 4,
	L2TP_ATTR_L2SPEC_TYPE = 5,
	L2TP_ATTR_L2SPEC_LEN = 6,
	L2TP_ATTR_PROTO_VERSION = 7,
	L2TP_ATTR_IFNAME = 8,
	L2TP_ATTR_CONN_ID = 9,
	L2TP_ATTR_PEER_CONN_ID = 10,
	L2TP_ATTR_SESSION_ID = 11,
	L2TP_ATTR_PEER_SESSION_ID = 12,
	L2TP_ATTR_UDP_CSUM = 13,
	L2TP_ATTR_VLAN_ID = 14,
	L2TP_ATTR_COOKIE = 15,
	L2TP_ATTR_PEER_COOKIE = 16,
	L2TP_ATTR_DEBUG = 17,
	L2TP_ATTR_RECV_SEQ = 18,
	L2TP_ATTR_SEND_SEQ = 19,
	L2TP_ATTR_LNS_MODE = 20,
	L2TP_ATTR_USING_IPSEC = 21,
	L2TP_ATTR_RECV_TIMEOUT = 22,
	L2TP_ATTR_FD = 23,
	L2TP_ATTR_IP_SADDR = 24,
	L2TP_ATTR_IP_DADDR = 25,
	L2TP_ATTR_UDP_SPORT = 26,
	L2TP_ATTR_UDP_DPORT = 27,
	L2TP_ATTR_MTU = 28,
	L2TP_ATTR_MRU = 29,
	L2TP_ATTR_STATS = 30,
	L2TP_ATTR_IP6_SADDR = 31,
	L2TP_ATTR_IP6_DADDR = 32,
	L2TP_ATTR_UDP_ZERO_CSUM6_TX = 33,
	L2TP_ATTR_UDP_ZERO_CSUM6_RX = 34,
	L2TP_ATTR_PAD = 35,
	__L2TP_ATTR_MAX = 36,
};

enum {
	L2TP_ATTR_STATS_NONE = 0,
	L2TP_ATTR_TX_PACKETS = 1,
	L2TP_ATTR_TX_BYTES = 2,
	L2TP_ATTR_TX_ERRORS = 3,
	L2TP_ATTR_RX_PACKETS = 4,
	L2TP_ATTR_RX_BYTES = 5,
	L2TP_ATTR_RX_SEQ_DISCARDS = 6,
	L2TP_ATTR_RX_OOS_PACKETS = 7,
	L2TP_ATTR_RX_ERRORS = 8,
	L2TP_ATTR_STATS_PAD = 9,
	L2TP_ATTR_RX_COOKIE_DISCARDS = 10,
	L2TP_ATTR_RX_INVALID = 11,
	__L2TP_ATTR_STATS_MAX = 12,
};

enum {
	L2TP_CMD_NOOP = 0,
	L2TP_CMD_TUNNEL_CREATE = 1,
	L2TP_CMD_TUNNEL_DELETE = 2,
	L2TP_CMD_TUNNEL_MODIFY = 3,
	L2TP_CMD_TUNNEL_GET = 4,
	L2TP_CMD_SESSION_CREATE = 5,
	L2TP_CMD_SESSION_DELETE = 6,
	L2TP_CMD_SESSION_MODIFY = 7,
	L2TP_CMD_SESSION_GET = 8,
	__L2TP_CMD_MAX = 9,
};

enum {
	LAPB_STATE_0 = 0,
	LAPB_STATE_1 = 1,
	LAPB_STATE_2 = 2,
	LAPB_STATE_3 = 3,
	LAPB_STATE_4 = 4,
};

enum {
	LAST_NORM = 0,
	LAST_ROOT = 1,
	LAST_DOT = 2,
	LAST_DOTDOT = 3,
};

enum {
	LBR_FORMAT_32 = 0,
	LBR_FORMAT_LIP = 1,
	LBR_FORMAT_EIP = 2,
	LBR_FORMAT_EIP_FLAGS = 3,
	LBR_FORMAT_EIP_FLAGS2 = 4,
	LBR_FORMAT_INFO = 5,
	LBR_FORMAT_TIME = 6,
	LBR_FORMAT_INFO2 = 7,
	LBR_FORMAT_MAX_KNOWN = 7,
};

enum {
	LBR_NONE = 0,
	LBR_VALID = 1,
};

enum {
	LCOEF_RPAGE = 0,
	LCOEF_RSEQIO = 1,
	LCOEF_RRANDIO = 2,
	LCOEF_WPAGE = 3,
	LCOEF_WSEQIO = 4,
	LCOEF_WRANDIO = 5,
	NR_LCOEFS = 6,
};

enum {
	LIBATA_MAX_PRD = 128,
	LIBATA_DUMB_MAX_PRD = 64,
	ATA_DEF_QUEUE = 1,
	ATA_MAX_QUEUE = 32,
	ATA_TAG_INTERNAL = 32,
	ATA_SHORT_PAUSE = 16,
	ATAPI_MAX_DRAIN = 16384,
	ATA_ALL_DEVICES = 3,
	ATA_SHT_EMULATED = 1,
	ATA_SHT_THIS_ID = -1,
	ATA_TFLAG_LBA48 = 1,
	ATA_TFLAG_ISADDR = 2,
	ATA_TFLAG_DEVICE = 4,
	ATA_TFLAG_WRITE = 8,
	ATA_TFLAG_LBA = 16,
	ATA_TFLAG_FUA = 32,
	ATA_TFLAG_POLLING = 64,
	ATA_DFLAG_LBA = 1,
	ATA_DFLAG_LBA48 = 2,
	ATA_DFLAG_CDB_INTR = 4,
	ATA_DFLAG_NCQ = 8,
	ATA_DFLAG_FLUSH_EXT = 16,
	ATA_DFLAG_ACPI_PENDING = 32,
	ATA_DFLAG_ACPI_FAILED = 64,
	ATA_DFLAG_AN = 128,
	ATA_DFLAG_TRUSTED = 256,
	ATA_DFLAG_FUA = 512,
	ATA_DFLAG_DMADIR = 1024,
	ATA_DFLAG_NCQ_SEND_RECV = 2048,
	ATA_DFLAG_NCQ_PRIO = 4096,
	ATA_DFLAG_CDL = 8192,
	ATA_DFLAG_CFG_MASK = 16383,
	ATA_DFLAG_PIO = 16384,
	ATA_DFLAG_NCQ_OFF = 32768,
	ATA_DFLAG_SLEEPING = 65536,
	ATA_DFLAG_DUBIOUS_XFER = 131072,
	ATA_DFLAG_NO_UNLOAD = 262144,
	ATA_DFLAG_UNLOCK_HPA = 524288,
	ATA_DFLAG_INIT_MASK = 1048575,
	ATA_DFLAG_NCQ_PRIO_ENABLED = 1048576,
	ATA_DFLAG_CDL_ENABLED = 2097152,
	ATA_DFLAG_RESUMING = 4194304,
	ATA_DFLAG_DETACH = 16777216,
	ATA_DFLAG_DETACHED = 33554432,
	ATA_DFLAG_DA = 67108864,
	ATA_DFLAG_DEVSLP = 134217728,
	ATA_DFLAG_ACPI_DISABLED = 268435456,
	ATA_DFLAG_D_SENSE = 536870912,
	ATA_DFLAG_ZAC = 1073741824,
	ATA_DFLAG_FEATURES_MASK = 201341696,
	ATA_DEV_UNKNOWN = 0,
	ATA_DEV_ATA = 1,
	ATA_DEV_ATA_UNSUP = 2,
	ATA_DEV_ATAPI = 3,
	ATA_DEV_ATAPI_UNSUP = 4,
	ATA_DEV_PMP = 5,
	ATA_DEV_PMP_UNSUP = 6,
	ATA_DEV_SEMB = 7,
	ATA_DEV_SEMB_UNSUP = 8,
	ATA_DEV_ZAC = 9,
	ATA_DEV_ZAC_UNSUP = 10,
	ATA_DEV_NONE = 11,
	ATA_LFLAG_NO_HRST = 2,
	ATA_LFLAG_NO_SRST = 4,
	ATA_LFLAG_ASSUME_ATA = 8,
	ATA_LFLAG_ASSUME_SEMB = 16,
	ATA_LFLAG_ASSUME_CLASS = 24,
	ATA_LFLAG_NO_RETRY = 32,
	ATA_LFLAG_DISABLED = 64,
	ATA_LFLAG_SW_ACTIVITY = 128,
	ATA_LFLAG_NO_LPM = 256,
	ATA_LFLAG_RST_ONCE = 512,
	ATA_LFLAG_CHANGED = 1024,
	ATA_LFLAG_NO_DEBOUNCE_DELAY = 2048,
	ATA_FLAG_SLAVE_POSS = 1,
	ATA_FLAG_SATA = 2,
	ATA_FLAG_NO_LPM = 4,
	ATA_FLAG_NO_LOG_PAGE = 32,
	ATA_FLAG_NO_ATAPI = 64,
	ATA_FLAG_PIO_DMA = 128,
	ATA_FLAG_PIO_LBA48 = 256,
	ATA_FLAG_PIO_POLLING = 512,
	ATA_FLAG_NCQ = 1024,
	ATA_FLAG_NO_POWEROFF_SPINDOWN = 2048,
	ATA_FLAG_NO_HIBERNATE_SPINDOWN = 4096,
	ATA_FLAG_DEBUGMSG = 8192,
	ATA_FLAG_FPDMA_AA = 16384,
	ATA_FLAG_IGN_SIMPLEX = 32768,
	ATA_FLAG_NO_IORDY = 65536,
	ATA_FLAG_ACPI_SATA = 131072,
	ATA_FLAG_AN = 262144,
	ATA_FLAG_PMP = 524288,
	ATA_FLAG_FPDMA_AUX = 1048576,
	ATA_FLAG_EM = 2097152,
	ATA_FLAG_SW_ACTIVITY = 4194304,
	ATA_FLAG_NO_DIPM = 8388608,
	ATA_FLAG_SAS_HOST = 16777216,
	ATA_PFLAG_EH_PENDING = 1,
	ATA_PFLAG_EH_IN_PROGRESS = 2,
	ATA_PFLAG_FROZEN = 4,
	ATA_PFLAG_RECOVERED = 8,
	ATA_PFLAG_LOADING = 16,
	ATA_PFLAG_SCSI_HOTPLUG = 64,
	ATA_PFLAG_INITIALIZING = 128,
	ATA_PFLAG_RESETTING = 256,
	ATA_PFLAG_UNLOADING = 512,
	ATA_PFLAG_UNLOADED = 1024,
	ATA_PFLAG_RESUMING = 65536,
	ATA_PFLAG_SUSPENDED = 131072,
	ATA_PFLAG_PM_PENDING = 262144,
	ATA_PFLAG_INIT_GTM_VALID = 524288,
	ATA_PFLAG_PIO32 = 1048576,
	ATA_PFLAG_PIO32CHANGE = 2097152,
	ATA_PFLAG_EXTERNAL = 4194304,
	ATA_QCFLAG_ACTIVE = 1,
	ATA_QCFLAG_DMAMAP = 2,
	ATA_QCFLAG_RTF_FILLED = 4,
	ATA_QCFLAG_IO = 8,
	ATA_QCFLAG_RESULT_TF = 16,
	ATA_QCFLAG_CLEAR_EXCL = 32,
	ATA_QCFLAG_QUIET = 64,
	ATA_QCFLAG_RETRY = 128,
	ATA_QCFLAG_HAS_CDL = 256,
	ATA_QCFLAG_EH = 65536,
	ATA_QCFLAG_SENSE_VALID = 131072,
	ATA_QCFLAG_EH_SCHEDULED = 262144,
	ATA_QCFLAG_EH_SUCCESS_CMD = 524288,
	ATA_HOST_SIMPLEX = 1,
	ATA_HOST_STARTED = 2,
	ATA_HOST_PARALLEL_SCAN = 4,
	ATA_HOST_IGNORE_ATA = 8,
	ATA_HOST_NO_PART = 16,
	ATA_HOST_NO_SSC = 32,
	ATA_HOST_NO_DEVSLP = 64,
	ATA_TMOUT_INTERNAL_QUICK = 5000,
	ATA_TMOUT_MAX_PARK = 30000,
	ATA_TMOUT_FF_WAIT_LONG = 2000,
	ATA_TMOUT_FF_WAIT = 800,
	ATA_WAIT_AFTER_RESET = 150,
	ATA_TMOUT_PMP_SRST_WAIT = 10000,
	ATA_TMOUT_SPURIOUS_PHY = 10000,
	BUS_UNKNOWN = 0,
	BUS_DMA = 1,
	BUS_IDLE = 2,
	BUS_NOINTR = 3,
	BUS_NODATA = 4,
	BUS_TIMER = 5,
	BUS_PIO = 6,
	BUS_EDD = 7,
	BUS_IDENTIFY = 8,
	BUS_PACKET = 9,
	PORT_UNKNOWN = 0,
	PORT_ENABLED = 1,
	PORT_DISABLED = 2,
	ATA_NR_PIO_MODES = 7,
	ATA_NR_MWDMA_MODES = 5,
	ATA_NR_UDMA_MODES = 8,
	ATA_SHIFT_PIO = 0,
	ATA_SHIFT_MWDMA = 7,
	ATA_SHIFT_UDMA = 12,
	ATA_SHIFT_PRIO = 6,
	ATA_PRIO_HIGH = 2,
	ATA_DMA_PAD_SZ = 4,
	ATA_ERING_SIZE = 32,
	ATA_DEFER_LINK = 1,
	ATA_DEFER_PORT = 2,
	ATA_EH_DESC_LEN = 80,
	ATA_EH_REVALIDATE = 1,
	ATA_EH_SOFTRESET = 2,
	ATA_EH_HARDRESET = 4,
	ATA_EH_RESET = 6,
	ATA_EH_ENABLE_LINK = 8,
	ATA_EH_PARK = 32,
	ATA_EH_GET_SUCCESS_SENSE = 64,
	ATA_EH_SET_ACTIVE = 128,
	ATA_EH_PERDEV_MASK = 225,
	ATA_EH_ALL_ACTIONS = 15,
	ATA_EHI_HOTPLUGGED = 1,
	ATA_EHI_NO_AUTOPSY = 4,
	ATA_EHI_QUIET = 8,
	ATA_EHI_NO_RECOVERY = 16,
	ATA_EHI_DID_SOFTRESET = 65536,
	ATA_EHI_DID_HARDRESET = 131072,
	ATA_EHI_PRINTINFO = 262144,
	ATA_EHI_SETMODE = 524288,
	ATA_EHI_POST_SETMODE = 1048576,
	ATA_EHI_DID_PRINT_QUIRKS = 2097152,
	ATA_EHI_DID_RESET = 196608,
	ATA_EHI_TO_SLAVE_MASK = 12,
	ATA_EH_MAX_TRIES = 5,
	ATA_LINK_RESUME_TRIES = 5,
	ATA_EH_DEV_TRIES = 3,
	ATA_EH_PMP_TRIES = 5,
	ATA_EH_PMP_LINK_TRIES = 3,
	SATA_PMP_RW_TIMEOUT = 3000,
	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 8,
	ATA_QUIRK_DIAGNOSTIC = 1,
	ATA_QUIRK_NODMA = 2,
	ATA_QUIRK_NONCQ = 4,
	ATA_QUIRK_MAX_SEC_128 = 8,
	ATA_QUIRK_BROKEN_HPA = 16,
	ATA_QUIRK_DISABLE = 32,
	ATA_QUIRK_HPA_SIZE = 64,
	ATA_QUIRK_IVB = 128,
	ATA_QUIRK_STUCK_ERR = 256,
	ATA_QUIRK_BRIDGE_OK = 512,
	ATA_QUIRK_ATAPI_MOD16_DMA = 1024,
	ATA_QUIRK_FIRMWARE_WARN = 2048,
	ATA_QUIRK_1_5_GBPS = 4096,
	ATA_QUIRK_NOSETXFER = 8192,
	ATA_QUIRK_BROKEN_FPDMA_AA = 16384,
	ATA_QUIRK_DUMP_ID = 32768,
	ATA_QUIRK_MAX_SEC_LBA48 = 65536,
	ATA_QUIRK_ATAPI_DMADIR = 131072,
	ATA_QUIRK_NO_NCQ_TRIM = 262144,
	ATA_QUIRK_NOLPM = 524288,
	ATA_QUIRK_WD_BROKEN_LPM = 1048576,
	ATA_QUIRK_ZERO_AFTER_TRIM = 2097152,
	ATA_QUIRK_NO_DMA_LOG = 4194304,
	ATA_QUIRK_NOTRIM = 8388608,
	ATA_QUIRK_MAX_SEC_1024 = 16777216,
	ATA_QUIRK_MAX_TRIM_128M = 33554432,
	ATA_QUIRK_NO_NCQ_ON_ATI = 67108864,
	ATA_QUIRK_NO_LPM_ON_ATI = 134217728,
	ATA_QUIRK_NO_ID_DEV_LOG = 268435456,
	ATA_QUIRK_NO_LOG_DIR = 536870912,
	ATA_QUIRK_NO_FUA = 1073741824,
	ATA_DMA_MASK_ATA = 1,
	ATA_DMA_MASK_ATAPI = 2,
	ATA_DMA_MASK_CFA = 4,
	ATAPI_READ = 0,
	ATAPI_WRITE = 1,
	ATAPI_READ_CD = 2,
	ATAPI_PASS_THRU = 3,
	ATAPI_MISC = 4,
	ATA_TIMING_SETUP = 1,
	ATA_TIMING_ACT8B = 2,
	ATA_TIMING_REC8B = 4,
	ATA_TIMING_CYC8B = 8,
	ATA_TIMING_8BIT = 14,
	ATA_TIMING_ACTIVE = 16,
	ATA_TIMING_RECOVER = 32,
	ATA_TIMING_DMACK_HOLD = 64,
	ATA_TIMING_CYCLE = 128,
	ATA_TIMING_UDMA = 256,
	ATA_TIMING_ALL = 511,
	ATA_ACPI_FILTER_SETXFER = 1,
	ATA_ACPI_FILTER_LOCK = 2,
	ATA_ACPI_FILTER_DIPM = 4,
	ATA_ACPI_FILTER_FPDMA_OFFSET = 8,
	ATA_ACPI_FILTER_FPDMA_AA = 16,
	ATA_ACPI_FILTER_DEFAULT = 7,
};

enum {
	LINK_ESTABLISHED = 14,
	LINK_ESTABLISHING = 224,
	LINK_RESET = 256,
	LINK_RESETTING = 8192,
	LINK_PEER_RESET = 851968,
	LINK_FAILINGOVER = 15728640,
	LINK_SYNCHING = 201326592,
};

enum {
	LINK_ESTABLISH_EVT = 247573278,
	LINK_PEER_RESET_EVT = 10415374,
	LINK_FAILURE_EVT = 16388366,
	LINK_RESET_EVT = 281681166,
	LINK_FAILOVER_BEGIN_EVT = 4195421166,
	LINK_FAILOVER_END_EVT = 4195421918,
	LINK_SYNCH_BEGIN_EVT = 203213806,
	LINK_SYNCH_END_EVT = 203214558,
};

enum {
	LINK_XSTATS_TYPE_UNSPEC = 0,
	LINK_XSTATS_TYPE_BRIDGE = 1,
	LINK_XSTATS_TYPE_BOND = 2,
	__LINK_XSTATS_TYPE_MAX = 3,
};

enum {
	LINUX_MIB_NUM = 0,
	LINUX_MIB_SYNCOOKIESSENT = 1,
	LINUX_MIB_SYNCOOKIESRECV = 2,
	LINUX_MIB_SYNCOOKIESFAILED = 3,
	LINUX_MIB_EMBRYONICRSTS = 4,
	LINUX_MIB_PRUNECALLED = 5,
	LINUX_MIB_RCVPRUNED = 6,
	LINUX_MIB_OFOPRUNED = 7,
	LINUX_MIB_OUTOFWINDOWICMPS = 8,
	LINUX_MIB_LOCKDROPPEDICMPS = 9,
	LINUX_MIB_ARPFILTER = 10,
	LINUX_MIB_TIMEWAITED = 11,
	LINUX_MIB_TIMEWAITRECYCLED = 12,
	LINUX_MIB_TIMEWAITKILLED = 13,
	LINUX_MIB_PAWSACTIVEREJECTED = 14,
	LINUX_MIB_PAWSESTABREJECTED = 15,
	LINUX_MIB_PAWS_OLD_ACK = 16,
	LINUX_MIB_DELAYEDACKS = 17,
	LINUX_MIB_DELAYEDACKLOCKED = 18,
	LINUX_MIB_DELAYEDACKLOST = 19,
	LINUX_MIB_LISTENOVERFLOWS = 20,
	LINUX_MIB_LISTENDROPS = 21,
	LINUX_MIB_TCPHPHITS = 22,
	LINUX_MIB_TCPPUREACKS = 23,
	LINUX_MIB_TCPHPACKS = 24,
	LINUX_MIB_TCPRENORECOVERY = 25,
	LINUX_MIB_TCPSACKRECOVERY = 26,
	LINUX_MIB_TCPSACKRENEGING = 27,
	LINUX_MIB_TCPSACKREORDER = 28,
	LINUX_MIB_TCPRENOREORDER = 29,
	LINUX_MIB_TCPTSREORDER = 30,
	LINUX_MIB_TCPFULLUNDO = 31,
	LINUX_MIB_TCPPARTIALUNDO = 32,
	LINUX_MIB_TCPDSACKUNDO = 33,
	LINUX_MIB_TCPLOSSUNDO = 34,
	LINUX_MIB_TCPLOSTRETRANSMIT = 35,
	LINUX_MIB_TCPRENOFAILURES = 36,
	LINUX_MIB_TCPSACKFAILURES = 37,
	LINUX_MIB_TCPLOSSFAILURES = 38,
	LINUX_MIB_TCPFASTRETRANS = 39,
	LINUX_MIB_TCPSLOWSTARTRETRANS = 40,
	LINUX_MIB_TCPTIMEOUTS = 41,
	LINUX_MIB_TCPLOSSPROBES = 42,
	LINUX_MIB_TCPLOSSPROBERECOVERY = 43,
	LINUX_MIB_TCPRENORECOVERYFAIL = 44,
	LINUX_MIB_TCPSACKRECOVERYFAIL = 45,
	LINUX_MIB_TCPRCVCOLLAPSED = 46,
	LINUX_MIB_TCPDSACKOLDSENT = 47,
	LINUX_MIB_TCPDSACKOFOSENT = 48,
	LINUX_MIB_TCPDSACKRECV = 49,
	LINUX_MIB_TCPDSACKOFORECV = 50,
	LINUX_MIB_TCPABORTONDATA = 51,
	LINUX_MIB_TCPABORTONCLOSE = 52,
	LINUX_MIB_TCPABORTONMEMORY = 53,
	LINUX_MIB_TCPABORTONTIMEOUT = 54,
	LINUX_MIB_TCPABORTONLINGER = 55,
	LINUX_MIB_TCPABORTFAILED = 56,
	LINUX_MIB_TCPMEMORYPRESSURES = 57,
	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 58,
	LINUX_MIB_TCPSACKDISCARD = 59,
	LINUX_MIB_TCPDSACKIGNOREDOLD = 60,
	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 61,
	LINUX_MIB_TCPSPURIOUSRTOS = 62,
	LINUX_MIB_TCPMD5NOTFOUND = 63,
	LINUX_MIB_TCPMD5UNEXPECTED = 64,
	LINUX_MIB_TCPMD5FAILURE = 65,
	LINUX_MIB_SACKSHIFTED = 66,
	LINUX_MIB_SACKMERGED = 67,
	LINUX_MIB_SACKSHIFTFALLBACK = 68,
	LINUX_MIB_TCPBACKLOGDROP = 69,
	LINUX_MIB_PFMEMALLOCDROP = 70,
	LINUX_MIB_TCPMINTTLDROP = 71,
	LINUX_MIB_TCPDEFERACCEPTDROP = 72,
	LINUX_MIB_IPRPFILTER = 73,
	LINUX_MIB_TCPTIMEWAITOVERFLOW = 74,
	LINUX_MIB_TCPREQQFULLDOCOOKIES = 75,
	LINUX_MIB_TCPREQQFULLDROP = 76,
	LINUX_MIB_TCPRETRANSFAIL = 77,
	LINUX_MIB_TCPRCVCOALESCE = 78,
	LINUX_MIB_TCPBACKLOGCOALESCE = 79,
	LINUX_MIB_TCPOFOQUEUE = 80,
	LINUX_MIB_TCPOFODROP = 81,
	LINUX_MIB_TCPOFOMERGE = 82,
	LINUX_MIB_TCPCHALLENGEACK = 83,
	LINUX_MIB_TCPSYNCHALLENGE = 84,
	LINUX_MIB_TCPFASTOPENACTIVE = 85,
	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 86,
	LINUX_MIB_TCPFASTOPENPASSIVE = 87,
	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 88,
	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 89,
	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 90,
	LINUX_MIB_TCPFASTOPENBLACKHOLE = 91,
	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 92,
	LINUX_MIB_BUSYPOLLRXPACKETS = 93,
	LINUX_MIB_TCPAUTOCORKING = 94,
	LINUX_MIB_TCPFROMZEROWINDOWADV = 95,
	LINUX_MIB_TCPTOZEROWINDOWADV = 96,
	LINUX_MIB_TCPWANTZEROWINDOWADV = 97,
	LINUX_MIB_TCPSYNRETRANS = 98,
	LINUX_MIB_TCPORIGDATASENT = 99,
	LINUX_MIB_TCPHYSTARTTRAINDETECT = 100,
	LINUX_MIB_TCPHYSTARTTRAINCWND = 101,
	LINUX_MIB_TCPHYSTARTDELAYDETECT = 102,
	LINUX_MIB_TCPHYSTARTDELAYCWND = 103,
	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 104,
	LINUX_MIB_TCPACKSKIPPEDPAWS = 105,
	LINUX_MIB_TCPACKSKIPPEDSEQ = 106,
	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 107,
	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 108,
	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 109,
	LINUX_MIB_TCPWINPROBE = 110,
	LINUX_MIB_TCPKEEPALIVE = 111,
	LINUX_MIB_TCPMTUPFAIL = 112,
	LINUX_MIB_TCPMTUPSUCCESS = 113,
	LINUX_MIB_TCPDELIVERED = 114,
	LINUX_MIB_TCPDELIVEREDCE = 115,
	LINUX_MIB_TCPACKCOMPRESSED = 116,
	LINUX_MIB_TCPZEROWINDOWDROP = 117,
	LINUX_MIB_TCPRCVQDROP = 118,
	LINUX_MIB_TCPWQUEUETOOBIG = 119,
	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 120,
	LINUX_MIB_TCPTIMEOUTREHASH = 121,
	LINUX_MIB_TCPDUPLICATEDATAREHASH = 122,
	LINUX_MIB_TCPDSACKRECVSEGS = 123,
	LINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 124,
	LINUX_MIB_TCPMIGRATEREQSUCCESS = 125,
	LINUX_MIB_TCPMIGRATEREQFAILURE = 126,
	LINUX_MIB_TCPPLBREHASH = 127,
	LINUX_MIB_TCPAOREQUIRED = 128,
	LINUX_MIB_TCPAOBAD = 129,
	LINUX_MIB_TCPAOKEYNOTFOUND = 130,
	LINUX_MIB_TCPAOGOOD = 131,
	LINUX_MIB_TCPAODROPPEDICMPS = 132,
	__LINUX_MIB_MAX = 133,
};

enum {
	LINUX_MIB_TLSNUM = 0,
	LINUX_MIB_TLSCURRTXSW = 1,
	LINUX_MIB_TLSCURRRXSW = 2,
	LINUX_MIB_TLSCURRTXDEVICE = 3,
	LINUX_MIB_TLSCURRRXDEVICE = 4,
	LINUX_MIB_TLSTXSW = 5,
	LINUX_MIB_TLSRXSW = 6,
	LINUX_MIB_TLSTXDEVICE = 7,
	LINUX_MIB_TLSRXDEVICE = 8,
	LINUX_MIB_TLSDECRYPTERROR = 9,
	LINUX_MIB_TLSRXDEVICERESYNC = 10,
	LINUX_MIB_TLSDECRYPTRETRY = 11,
	LINUX_MIB_TLSRXNOPADVIOL = 12,
	LINUX_MIB_TLSRXREKEYOK = 13,
	LINUX_MIB_TLSRXREKEYERROR = 14,
	LINUX_MIB_TLSTXREKEYOK = 15,
	LINUX_MIB_TLSTXREKEYERROR = 16,
	LINUX_MIB_TLSRXREKEYRECEIVED = 17,
	__LINUX_MIB_TLSMAX = 18,
};

enum {
	LINUX_MIB_XFRMNUM = 0,
	LINUX_MIB_XFRMINERROR = 1,
	LINUX_MIB_XFRMINBUFFERERROR = 2,
	LINUX_MIB_XFRMINHDRERROR = 3,
	LINUX_MIB_XFRMINNOSTATES = 4,
	LINUX_MIB_XFRMINSTATEPROTOERROR = 5,
	LINUX_MIB_XFRMINSTATEMODEERROR = 6,
	LINUX_MIB_XFRMINSTATESEQERROR = 7,
	LINUX_MIB_XFRMINSTATEEXPIRED = 8,
	LINUX_MIB_XFRMINSTATEMISMATCH = 9,
	LINUX_MIB_XFRMINSTATEINVALID = 10,
	LINUX_MIB_XFRMINTMPLMISMATCH = 11,
	LINUX_MIB_XFRMINNOPOLS = 12,
	LINUX_MIB_XFRMINPOLBLOCK = 13,
	LINUX_MIB_XFRMINPOLERROR = 14,
	LINUX_MIB_XFRMOUTERROR = 15,
	LINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,
	LINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,
	LINUX_MIB_XFRMOUTNOSTATES = 18,
	LINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,
	LINUX_MIB_XFRMOUTSTATEMODEERROR = 20,
	LINUX_MIB_XFRMOUTSTATESEQERROR = 21,
	LINUX_MIB_XFRMOUTSTATEEXPIRED = 22,
	LINUX_MIB_XFRMOUTPOLBLOCK = 23,
	LINUX_MIB_XFRMOUTPOLDEAD = 24,
	LINUX_MIB_XFRMOUTPOLERROR = 25,
	LINUX_MIB_XFRMFWDHDRERROR = 26,
	LINUX_MIB_XFRMOUTSTATEINVALID = 27,
	LINUX_MIB_XFRMACQUIREERROR = 28,
	LINUX_MIB_XFRMOUTSTATEDIRERROR = 29,
	LINUX_MIB_XFRMINSTATEDIRERROR = 30,
	LINUX_MIB_XFRMINIPTFSERROR = 31,
	LINUX_MIB_XFRMOUTNOQSPACE = 32,
	__LINUX_MIB_XFRMMAX = 33,
};

enum {
	LK_STATE_IN_USE = 0,
	NFS_DELEGATED_STATE = 1,
	NFS_OPEN_STATE = 2,
	NFS_O_RDONLY_STATE = 3,
	NFS_O_WRONLY_STATE = 4,
	NFS_O_RDWR_STATE = 5,
	NFS_STATE_RECLAIM_REBOOT = 6,
	NFS_STATE_RECLAIM_NOGRACE = 7,
	NFS_STATE_POSIX_LOCKS = 8,
	NFS_STATE_RECOVERY_FAILED = 9,
	NFS_STATE_MAY_NOTIFY_LOCK = 10,
	NFS_STATE_CHANGE_WAIT = 11,
	NFS_CLNT_DST_SSC_COPY_STATE = 12,
	NFS_CLNT_SRC_SSC_COPY_STATE = 13,
	NFS_SRV_SSC_COPY_STATE = 14,
};

enum {
	LOGIC_PIO_INDIRECT = 0,
	LOGIC_PIO_CPU_MMIO = 1,
};

enum {
	LOG_INODE_ALL = 0,
	LOG_INODE_EXISTS = 1,
};

enum {
	LOG_WALK_PIN_ONLY = 0,
	LOG_WALK_REPLAY_INODES = 1,
	LOG_WALK_REPLAY_DIR_INDEX = 2,
	LOG_WALK_REPLAY_ALL = 3,
};

enum {
	LO_FLAGS_READ_ONLY = 1,
	LO_FLAGS_AUTOCLEAR = 4,
	LO_FLAGS_PARTSCAN = 8,
	LO_FLAGS_DIRECT_IO = 16,
};

enum {
	LWTUNNEL_IP_OPTS_UNSPEC = 0,
	LWTUNNEL_IP_OPTS_GENEVE = 1,
	LWTUNNEL_IP_OPTS_VXLAN = 2,
	LWTUNNEL_IP_OPTS_ERSPAN = 3,
	__LWTUNNEL_IP_OPTS_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_ERSPAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_ERSPAN_VER = 1,
	LWTUNNEL_IP_OPT_ERSPAN_INDEX = 2,
	LWTUNNEL_IP_OPT_ERSPAN_DIR = 3,
	LWTUNNEL_IP_OPT_ERSPAN_HWID = 4,
	__LWTUNNEL_IP_OPT_ERSPAN_MAX = 5,
};

enum {
	LWTUNNEL_IP_OPT_GENEVE_UNSPEC = 0,
	LWTUNNEL_IP_OPT_GENEVE_CLASS = 1,
	LWTUNNEL_IP_OPT_GENEVE_TYPE = 2,
	LWTUNNEL_IP_OPT_GENEVE_DATA = 3,
	__LWTUNNEL_IP_OPT_GENEVE_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_VXLAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_VXLAN_GBP = 1,
	__LWTUNNEL_IP_OPT_VXLAN_MAX = 2,
};

enum {
	LWTUNNEL_XMIT_DONE = 0,
	LWTUNNEL_XMIT_CONTINUE = 256,
};

enum {
	LWT_BPF_PROG_UNSPEC = 0,
	LWT_BPF_PROG_FD = 1,
	LWT_BPF_PROG_NAME = 2,
	__LWT_BPF_PROG_MAX = 3,
};

enum {
	LWT_BPF_UNSPEC = 0,
	LWT_BPF_IN = 1,
	LWT_BPF_OUT = 2,
	LWT_BPF_XMIT = 3,
	LWT_BPF_XMIT_HEADROOM = 4,
	__LWT_BPF_MAX = 5,
};

enum {
	LWT_XFRM_UNSPEC = 0,
	LWT_XFRM_IF_ID = 1,
	LWT_XFRM_LINK = 2,
	__LWT_XFRM_MAX = 3,
};

enum {
	Lo_unbound = 0,
	Lo_bound = 1,
	Lo_rundown = 2,
	Lo_deleting = 3,
};

enum {
	MAC_UNSET = 0,
	MAC_FILLED = 1,
};

enum {
	MATCH_MTR = 0,
	MATCH_MEQ = 1,
	MATCH_MLE = 2,
	MATCH_MLT = 3,
	MATCH_MGE = 4,
	MATCH_MGT = 5,
};

enum {
	MAX_IORES_LEVEL = 5,
};

enum {
	MAX_OPT_ARGS = 3,
};

enum {
	MBE_REFERENCED_B = 0,
	MBE_REUSABLE_B = 1,
};

enum {
	MB_INODE_PA = 0,
	MB_GROUP_PA = 1,
};

enum {
	MDBA_GET_ENTRY_UNSPEC = 0,
	MDBA_GET_ENTRY = 1,
	MDBA_GET_ENTRY_ATTRS = 2,
	__MDBA_GET_ENTRY_MAX = 3,
};

enum {
	MDBA_MDB_EATTR_UNSPEC = 0,
	MDBA_MDB_EATTR_TIMER = 1,
	MDBA_MDB_EATTR_SRC_LIST = 2,
	MDBA_MDB_EATTR_GROUP_MODE = 3,
	MDBA_MDB_EATTR_SOURCE = 4,
	MDBA_MDB_EATTR_RTPROT = 5,
	MDBA_MDB_EATTR_DST = 6,
	MDBA_MDB_EATTR_DST_PORT = 7,
	MDBA_MDB_EATTR_VNI = 8,
	MDBA_MDB_EATTR_IFINDEX = 9,
	MDBA_MDB_EATTR_SRC_VNI = 10,
	__MDBA_MDB_EATTR_MAX = 11,
};

enum {
	MDBA_MDB_ENTRY_UNSPEC = 0,
	MDBA_MDB_ENTRY_INFO = 1,
	__MDBA_MDB_ENTRY_MAX = 2,
};

enum {
	MDBA_MDB_SRCATTR_UNSPEC = 0,
	MDBA_MDB_SRCATTR_ADDRESS = 1,
	MDBA_MDB_SRCATTR_TIMER = 2,
	__MDBA_MDB_SRCATTR_MAX = 3,
};

enum {
	MDBA_MDB_SRCLIST_UNSPEC = 0,
	MDBA_MDB_SRCLIST_ENTRY = 1,
	__MDBA_MDB_SRCLIST_MAX = 2,
};

enum {
	MDBA_MDB_UNSPEC = 0,
	MDBA_MDB_ENTRY = 1,
	__MDBA_MDB_MAX = 2,
};

enum {
	MDBA_ROUTER_PATTR_UNSPEC = 0,
	MDBA_ROUTER_PATTR_TIMER = 1,
	MDBA_ROUTER_PATTR_TYPE = 2,
	MDBA_ROUTER_PATTR_INET_TIMER = 3,
	MDBA_ROUTER_PATTR_INET6_TIMER = 4,
	MDBA_ROUTER_PATTR_VID = 5,
	__MDBA_ROUTER_PATTR_MAX = 6,
};

enum {
	MDBA_ROUTER_UNSPEC = 0,
	MDBA_ROUTER_PORT = 1,
	__MDBA_ROUTER_MAX = 2,
};

enum {
	MDBA_SET_ENTRY_UNSPEC = 0,
	MDBA_SET_ENTRY = 1,
	MDBA_SET_ENTRY_ATTRS = 2,
	__MDBA_SET_ENTRY_MAX = 3,
};

enum {
	MDBA_UNSPEC = 0,
	MDBA_MDB = 1,
	MDBA_ROUTER = 2,
	__MDBA_MAX = 3,
};

enum {
	MDBE_ATTR_UNSPEC = 0,
	MDBE_ATTR_SOURCE = 1,
	MDBE_ATTR_SRC_LIST = 2,
	MDBE_ATTR_GROUP_MODE = 3,
	MDBE_ATTR_RTPROT = 4,
	MDBE_ATTR_DST = 5,
	MDBE_ATTR_DST_PORT = 6,
	MDBE_ATTR_VNI = 7,
	MDBE_ATTR_IFINDEX = 8,
	MDBE_ATTR_SRC_VNI = 9,
	MDBE_ATTR_STATE_MASK = 10,
	__MDBE_ATTR_MAX = 11,
};

enum {
	MDBE_SRCATTR_UNSPEC = 0,
	MDBE_SRCATTR_ADDRESS = 1,
	__MDBE_SRCATTR_MAX = 2,
};

enum {
	MDBE_SRC_LIST_UNSPEC = 0,
	MDBE_SRC_LIST_ENTRY = 1,
	__MDBE_SRC_LIST_MAX = 2,
};

enum {
	MDB_RTR_TYPE_DISABLED = 0,
	MDB_RTR_TYPE_TEMP_QUERY = 1,
	MDB_RTR_TYPE_PERM = 2,
	MDB_RTR_TYPE_TEMP = 3,
};

enum {
	MD_RESYNC_NONE = 0,
	MD_RESYNC_YIELDED = 1,
	MD_RESYNC_DELAYED = 2,
	MD_RESYNC_ACTIVE = 3,
};

enum {
	MEMBARRIER_FLAG_SYNC_CORE = 1,
	MEMBARRIER_FLAG_RSEQ = 2,
};

enum {
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY = 64,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ = 128,
};

enum {
	MEMMAP_ON_MEMORY_DISABLE = 0,
	MEMMAP_ON_MEMORY_ENABLE = 1,
	MEMMAP_ON_MEMORY_FORCE = 2,
};

enum {
	MEMORY_RECLAIM_SWAPPINESS = 0,
	MEMORY_RECLAIM_NULL = 1,
};

enum {
	MEMREMAP_WB = 1,
	MEMREMAP_WT = 2,
	MEMREMAP_WC = 4,
	MEMREMAP_ENC = 8,
	MEMREMAP_DEC = 16,
};

enum {
	MEMTYPE_EXACT_MATCH = 0,
	MEMTYPE_END_MATCH = 1,
};

enum {
	MFC_STATIC = 1,
	MFC_OFFLOAD = 2,
};

enum {
	MILLION = 1000000,
	MIN_PERIOD = 1000,
	MAX_PERIOD = 1000000,
	MARGIN_MIN_PCT = 10,
	MARGIN_LOW_PCT = 20,
	MARGIN_TARGET_PCT = 50,
	INUSE_ADJ_STEP_PCT = 25,
	TIMER_SLACK_PCT = 1,
	WEIGHT_ONE = 65536,
};

enum {
	MIPI_DCS_NOP = 0,
	MIPI_DCS_SOFT_RESET = 1,
	MIPI_DCS_GET_COMPRESSION_MODE = 3,
	MIPI_DCS_GET_DISPLAY_ID = 4,
	MIPI_DCS_GET_ERROR_COUNT_ON_DSI = 5,
	MIPI_DCS_GET_RED_CHANNEL = 6,
	MIPI_DCS_GET_GREEN_CHANNEL = 7,
	MIPI_DCS_GET_BLUE_CHANNEL = 8,
	MIPI_DCS_GET_DISPLAY_STATUS = 9,
	MIPI_DCS_GET_POWER_MODE = 10,
	MIPI_DCS_GET_ADDRESS_MODE = 11,
	MIPI_DCS_GET_PIXEL_FORMAT = 12,
	MIPI_DCS_GET_DISPLAY_MODE = 13,
	MIPI_DCS_GET_SIGNAL_MODE = 14,
	MIPI_DCS_GET_DIAGNOSTIC_RESULT = 15,
	MIPI_DCS_ENTER_SLEEP_MODE = 16,
	MIPI_DCS_EXIT_SLEEP_MODE = 17,
	MIPI_DCS_ENTER_PARTIAL_MODE = 18,
	MIPI_DCS_ENTER_NORMAL_MODE = 19,
	MIPI_DCS_GET_IMAGE_CHECKSUM_RGB = 20,
	MIPI_DCS_GET_IMAGE_CHECKSUM_CT = 21,
	MIPI_DCS_EXIT_INVERT_MODE = 32,
	MIPI_DCS_ENTER_INVERT_MODE = 33,
	MIPI_DCS_SET_GAMMA_CURVE = 38,
	MIPI_DCS_SET_DISPLAY_OFF = 40,
	MIPI_DCS_SET_DISPLAY_ON = 41,
	MIPI_DCS_SET_COLUMN_ADDRESS = 42,
	MIPI_DCS_SET_PAGE_ADDRESS = 43,
	MIPI_DCS_WRITE_MEMORY_START = 44,
	MIPI_DCS_WRITE_LUT = 45,
	MIPI_DCS_READ_MEMORY_START = 46,
	MIPI_DCS_SET_PARTIAL_ROWS = 48,
	MIPI_DCS_SET_PARTIAL_COLUMNS = 49,
	MIPI_DCS_SET_SCROLL_AREA = 51,
	MIPI_DCS_SET_TEAR_OFF = 52,
	MIPI_DCS_SET_TEAR_ON = 53,
	MIPI_DCS_SET_ADDRESS_MODE = 54,
	MIPI_DCS_SET_SCROLL_START = 55,
	MIPI_DCS_EXIT_IDLE_MODE = 56,
	MIPI_DCS_ENTER_IDLE_MODE = 57,
	MIPI_DCS_SET_PIXEL_FORMAT = 58,
	MIPI_DCS_WRITE_MEMORY_CONTINUE = 60,
	MIPI_DCS_SET_3D_CONTROL = 61,
	MIPI_DCS_READ_MEMORY_CONTINUE = 62,
	MIPI_DCS_GET_3D_CONTROL = 63,
	MIPI_DCS_SET_VSYNC_TIMING = 64,
	MIPI_DCS_SET_TEAR_SCANLINE = 68,
	MIPI_DCS_GET_SCANLINE = 69,
	MIPI_DCS_SET_DISPLAY_BRIGHTNESS = 81,
	MIPI_DCS_GET_DISPLAY_BRIGHTNESS = 82,
	MIPI_DCS_WRITE_CONTROL_DISPLAY = 83,
	MIPI_DCS_GET_CONTROL_DISPLAY = 84,
	MIPI_DCS_WRITE_POWER_SAVE = 85,
	MIPI_DCS_GET_POWER_SAVE = 86,
	MIPI_DCS_SET_CABC_MIN_BRIGHTNESS = 94,
	MIPI_DCS_GET_CABC_MIN_BRIGHTNESS = 95,
	MIPI_DCS_READ_DDB_START = 161,
	MIPI_DCS_READ_PPS_START = 162,
	MIPI_DCS_READ_DDB_CONTINUE = 168,
	MIPI_DCS_READ_PPS_CONTINUE = 169,
};

enum {
	MIPI_DSI_V_SYNC_START = 1,
	MIPI_DSI_V_SYNC_END = 17,
	MIPI_DSI_H_SYNC_START = 33,
	MIPI_DSI_H_SYNC_END = 49,
	MIPI_DSI_COMPRESSION_MODE = 7,
	MIPI_DSI_END_OF_TRANSMISSION = 8,
	MIPI_DSI_COLOR_MODE_OFF = 2,
	MIPI_DSI_COLOR_MODE_ON = 18,
	MIPI_DSI_SHUTDOWN_PERIPHERAL = 34,
	MIPI_DSI_TURN_ON_PERIPHERAL = 50,
	MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM = 3,
	MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM = 19,
	MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM = 35,
	MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM = 4,
	MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM = 20,
	MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM = 36,
	MIPI_DSI_DCS_SHORT_WRITE = 5,
	MIPI_DSI_DCS_SHORT_WRITE_PARAM = 21,
	MIPI_DSI_DCS_READ = 6,
	MIPI_DSI_EXECUTE_QUEUE = 22,
	MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE = 55,
	MIPI_DSI_NULL_PACKET = 9,
	MIPI_DSI_BLANKING_PACKET = 25,
	MIPI_DSI_GENERIC_LONG_WRITE = 41,
	MIPI_DSI_DCS_LONG_WRITE = 57,
	MIPI_DSI_PICTURE_PARAMETER_SET = 10,
	MIPI_DSI_COMPRESSED_PIXEL_STREAM = 11,
	MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20 = 12,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24 = 28,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16 = 44,
	MIPI_DSI_PACKED_PIXEL_STREAM_30 = 13,
	MIPI_DSI_PACKED_PIXEL_STREAM_36 = 29,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12 = 61,
	MIPI_DSI_PACKED_PIXEL_STREAM_16 = 14,
	MIPI_DSI_PACKED_PIXEL_STREAM_18 = 30,
	MIPI_DSI_PIXEL_STREAM_3BYTE_18 = 46,
	MIPI_DSI_PACKED_PIXEL_STREAM_24 = 62,
};

enum {
	MIPI_RESET_1 = 0,
	MIPI_AVDD_EN_1 = 1,
	MIPI_BKLT_EN_1 = 2,
	MIPI_AVEE_EN_1 = 3,
	MIPI_VIO_EN_1 = 4,
	MIPI_RESET_2 = 5,
	MIPI_AVDD_EN_2 = 6,
	MIPI_BKLT_EN_2 = 7,
	MIPI_AVEE_EN_2 = 8,
	MIPI_VIO_EN_2 = 9,
};

enum {
	MIX_INFLIGHT = 2147483648,
};

enum {
	MMOP_OFFLINE = 0,
	MMOP_ONLINE = 1,
	MMOP_ONLINE_KERNEL = 2,
	MMOP_ONLINE_MOVABLE = 3,
};

enum {
	MM_FILEPAGES = 0,
	MM_ANONPAGES = 1,
	MM_SWAPENTS = 2,
	MM_SHMEMPAGES = 3,
	NR_MM_COUNTERS = 4,
};

enum {
	MODE_640x480 = 0,
	MODE_800x600 = 1,
	MODE_1024x768 = 2,
};

enum {
	MOUNTPROC3_NULL = 0,
	MOUNTPROC3_MNT = 1,
	MOUNTPROC3_DUMP = 2,
	MOUNTPROC3_UMNT = 3,
	MOUNTPROC3_UMNTALL = 4,
	MOUNTPROC3_EXPORT = 5,
};

enum {
	MOUNTPROC_NULL = 0,
	MOUNTPROC_MNT = 1,
	MOUNTPROC_DUMP = 2,
	MOUNTPROC_UMNT = 3,
	MOUNTPROC_UMNTALL = 4,
	MOUNTPROC_EXPORT = 5,
};

enum {
	MOXA_SUPP_RS232 = 1,
	MOXA_SUPP_RS422 = 2,
	MOXA_SUPP_RS485 = 4,
};

enum {
	MPOL_DEFAULT = 0,
	MPOL_PREFERRED = 1,
	MPOL_BIND = 2,
	MPOL_INTERLEAVE = 3,
	MPOL_LOCAL = 4,
	MPOL_PREFERRED_MANY = 5,
	MPOL_WEIGHTED_INTERLEAVE = 6,
	MPOL_MAX = 7,
};

enum {
	MPTCP_CMSG_TS = 1,
	MPTCP_CMSG_INQ = 2,
};

enum {
	MPTCP_PM_ADDR_ATTR_UNSPEC = 0,
	MPTCP_PM_ADDR_ATTR_FAMILY = 1,
	MPTCP_PM_ADDR_ATTR_ID = 2,
	MPTCP_PM_ADDR_ATTR_ADDR4 = 3,
	MPTCP_PM_ADDR_ATTR_ADDR6 = 4,
	MPTCP_PM_ADDR_ATTR_PORT = 5,
	MPTCP_PM_ADDR_ATTR_FLAGS = 6,
	MPTCP_PM_ADDR_ATTR_IF_IDX = 7,
	__MPTCP_PM_ADDR_ATTR_MAX = 8,
};

enum {
	MPTCP_PM_ATTR_UNSPEC = 0,
	MPTCP_PM_ATTR_ADDR = 1,
	MPTCP_PM_ATTR_RCV_ADD_ADDRS = 2,
	MPTCP_PM_ATTR_SUBFLOWS = 3,
	MPTCP_PM_ATTR_TOKEN = 4,
	MPTCP_PM_ATTR_LOC_ID = 5,
	MPTCP_PM_ATTR_ADDR_REMOTE = 6,
	__MPTCP_ATTR_AFTER_LAST = 7,
};

enum {
	MPTCP_PM_CMD_UNSPEC = 0,
	MPTCP_PM_CMD_ADD_ADDR = 1,
	MPTCP_PM_CMD_DEL_ADDR = 2,
	MPTCP_PM_CMD_GET_ADDR = 3,
	MPTCP_PM_CMD_FLUSH_ADDRS = 4,
	MPTCP_PM_CMD_SET_LIMITS = 5,
	MPTCP_PM_CMD_GET_LIMITS = 6,
	MPTCP_PM_CMD_SET_FLAGS = 7,
	MPTCP_PM_CMD_ANNOUNCE = 8,
	MPTCP_PM_CMD_REMOVE = 9,
	MPTCP_PM_CMD_SUBFLOW_CREATE = 10,
	MPTCP_PM_CMD_SUBFLOW_DESTROY = 11,
	__MPTCP_PM_CMD_AFTER_LAST = 12,
};

enum {
	MPTCP_PM_ENDPOINT_ADDR = 1,
	__MPTCP_PM_ENDPOINT_MAX = 2,
};

enum {
	MPTCP_SUBFLOW_ATTR_UNSPEC = 0,
	MPTCP_SUBFLOW_ATTR_TOKEN_REM = 1,
	MPTCP_SUBFLOW_ATTR_TOKEN_LOC = 2,
	MPTCP_SUBFLOW_ATTR_RELWRITE_SEQ = 3,
	MPTCP_SUBFLOW_ATTR_MAP_SEQ = 4,
	MPTCP_SUBFLOW_ATTR_MAP_SFSEQ = 5,
	MPTCP_SUBFLOW_ATTR_SSN_OFFSET = 6,
	MPTCP_SUBFLOW_ATTR_MAP_DATALEN = 7,
	MPTCP_SUBFLOW_ATTR_FLAGS = 8,
	MPTCP_SUBFLOW_ATTR_ID_REM = 9,
	MPTCP_SUBFLOW_ATTR_ID_LOC = 10,
	MPTCP_SUBFLOW_ATTR_PAD = 11,
	__MPTCP_SUBFLOW_ATTR_MAX = 12,
};

enum {
	MSI_FLAG_USE_DEF_DOM_OPS = 1,
	MSI_FLAG_USE_DEF_CHIP_OPS = 2,
	MSI_FLAG_ACTIVATE_EARLY = 4,
	MSI_FLAG_MUST_REACTIVATE = 8,
	MSI_FLAG_DEV_SYSFS = 16,
	MSI_FLAG_ALLOC_SIMPLE_MSI_DESCS = 32,
	MSI_FLAG_FREE_MSI_DESCS = 64,
	MSI_FLAG_USE_DEV_FWNODE = 128,
	MSI_FLAG_PARENT_PM_DEV = 256,
	MSI_FLAG_PCI_MSI_MASK_PARENT = 512,
	MSI_GENERIC_FLAGS_MASK = 65535,
	MSI_DOMAIN_FLAGS_MASK = 4294901760,
	MSI_FLAG_MULTI_PCI_MSI = 65536,
	MSI_FLAG_PCI_MSIX = 131072,
	MSI_FLAG_LEVEL_CAPABLE = 262144,
	MSI_FLAG_MSIX_CONTIGUOUS = 524288,
	MSI_FLAG_PCI_MSIX_ALLOC_DYN = 1048576,
	MSI_FLAG_NO_AFFINITY = 2097152,
};

enum {
	MTTG_TRAV_INIT = 0,
	MTTG_TRAV_NFP_UNSPEC = 1,
	MTTG_TRAV_NFP_SPEC = 2,
	MTTG_TRAV_DONE = 3,
};

enum {
	NAPIF_STATE_SCHED = 1,
	NAPIF_STATE_MISSED = 2,
	NAPIF_STATE_DISABLE = 4,
	NAPIF_STATE_NPSVC = 8,
	NAPIF_STATE_LISTED = 16,
	NAPIF_STATE_NO_BUSY_POLL = 32,
	NAPIF_STATE_IN_BUSY_POLL = 64,
	NAPIF_STATE_PREFER_BUSY_POLL = 128,
	NAPIF_STATE_THREADED = 256,
	NAPIF_STATE_SCHED_THREADED = 512,
};

enum {
	NAPI_F_PREFER_BUSY_POLL = 1,
	NAPI_F_END_ON_RESCHED = 2,
};

enum {
	NAPI_STATE_SCHED = 0,
	NAPI_STATE_MISSED = 1,
	NAPI_STATE_DISABLE = 2,
	NAPI_STATE_NPSVC = 3,
	NAPI_STATE_LISTED = 4,
	NAPI_STATE_NO_BUSY_POLL = 5,
	NAPI_STATE_IN_BUSY_POLL = 6,
	NAPI_STATE_PREFER_BUSY_POLL = 7,
	NAPI_STATE_THREADED = 8,
	NAPI_STATE_SCHED_THREADED = 9,
};

enum {
	NDA_UNSPEC = 0,
	NDA_DST = 1,
	NDA_LLADDR = 2,
	NDA_CACHEINFO = 3,
	NDA_PROBES = 4,
	NDA_VLAN = 5,
	NDA_PORT = 6,
	NDA_VNI = 7,
	NDA_IFINDEX = 8,
	NDA_MASTER = 9,
	NDA_LINK_NETNSID = 10,
	NDA_SRC_VNI = 11,
	NDA_PROTOCOL = 12,
	NDA_NH_ID = 13,
	NDA_FDB_EXT_ATTRS = 14,
	NDA_FLAGS_EXT = 15,
	NDA_NDM_STATE_MASK = 16,
	NDA_NDM_FLAGS_MASK = 17,
	__NDA_MAX = 18,
};

enum {
	NDD_UNARMED = 1,
	NDD_LOCKED = 2,
	NDD_SECURITY_OVERWRITE = 3,
	NDD_WORK_PENDING = 4,
	NDD_LABELING = 6,
	NDD_INCOHERENT = 7,
	NDD_REGISTER_SYNC = 8,
	ND_IOCTL_MAX_BUFLEN = 4194304,
	ND_CMD_MAX_ELEM = 5,
	ND_CMD_MAX_ENVELOPE = 256,
	ND_MAX_MAPPINGS = 32,
	ND_REGION_PAGEMAP = 0,
	ND_REGION_PERSIST_CACHE = 1,
	ND_REGION_PERSIST_MEMCTRL = 2,
	ND_REGION_ASYNC = 3,
	ND_REGION_CXL = 4,
	DPA_RESOURCE_ADJUSTED = 1,
};

enum {
	NDTA_UNSPEC = 0,
	NDTA_NAME = 1,
	NDTA_THRESH1 = 2,
	NDTA_THRESH2 = 3,
	NDTA_THRESH3 = 4,
	NDTA_CONFIG = 5,
	NDTA_PARMS = 6,
	NDTA_STATS = 7,
	NDTA_GC_INTERVAL = 8,
	NDTA_PAD = 9,
	__NDTA_MAX = 10,
};

enum {
	NDTPA_UNSPEC = 0,
	NDTPA_IFINDEX = 1,
	NDTPA_REFCNT = 2,
	NDTPA_REACHABLE_TIME = 3,
	NDTPA_BASE_REACHABLE_TIME = 4,
	NDTPA_RETRANS_TIME = 5,
	NDTPA_GC_STALETIME = 6,
	NDTPA_DELAY_PROBE_TIME = 7,
	NDTPA_QUEUE_LEN = 8,
	NDTPA_APP_PROBES = 9,
	NDTPA_UCAST_PROBES = 10,
	NDTPA_MCAST_PROBES = 11,
	NDTPA_ANYCAST_DELAY = 12,
	NDTPA_PROXY_DELAY = 13,
	NDTPA_PROXY_QLEN = 14,
	NDTPA_LOCKTIME = 15,
	NDTPA_QUEUE_LENBYTES = 16,
	NDTPA_MCAST_REPROBES = 17,
	NDTPA_PAD = 18,
	NDTPA_INTERVAL_PROBE_TIME_MS = 19,
	__NDTPA_MAX = 20,
};

enum {
	NDUSEROPT_UNSPEC = 0,
	NDUSEROPT_SRCADDR = 1,
	__NDUSEROPT_MAX = 2,
};

enum {
	NEIGH_ARP_TABLE = 0,
	NEIGH_ND_TABLE = 1,
	NEIGH_NR_TABLES = 2,
	NEIGH_LINK_TABLE = 2,
};

enum {
	NEIGH_VAR_MCAST_PROBES = 0,
	NEIGH_VAR_UCAST_PROBES = 1,
	NEIGH_VAR_APP_PROBES = 2,
	NEIGH_VAR_MCAST_REPROBES = 3,
	NEIGH_VAR_RETRANS_TIME = 4,
	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
	NEIGH_VAR_DELAY_PROBE_TIME = 6,
	NEIGH_VAR_INTERVAL_PROBE_TIME_MS = 7,
	NEIGH_VAR_GC_STALETIME = 8,
	NEIGH_VAR_QUEUE_LEN_BYTES = 9,
	NEIGH_VAR_PROXY_QLEN = 10,
	NEIGH_VAR_ANYCAST_DELAY = 11,
	NEIGH_VAR_PROXY_DELAY = 12,
	NEIGH_VAR_LOCKTIME = 13,
	NEIGH_VAR_QUEUE_LEN = 14,
	NEIGH_VAR_RETRANS_TIME_MS = 15,
	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 16,
	NEIGH_VAR_GC_INTERVAL = 17,
	NEIGH_VAR_GC_THRESH1 = 18,
	NEIGH_VAR_GC_THRESH2 = 19,
	NEIGH_VAR_GC_THRESH3 = 20,
	NEIGH_VAR_MAX = 21,
};

enum {
	NESTED_SYNC_IMM_BIT = 0,
	NESTED_SYNC_TODO_BIT = 1,
};

enum {
	NETCONFA_UNSPEC = 0,
	NETCONFA_IFINDEX = 1,
	NETCONFA_FORWARDING = 2,
	NETCONFA_RP_FILTER = 3,
	NETCONFA_MC_FORWARDING = 4,
	NETCONFA_PROXY_NEIGH = 5,
	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
	NETCONFA_INPUT = 7,
	NETCONFA_BC_FORWARDING = 8,
	__NETCONFA_MAX = 9,
};

enum {
	NETDEV_A_DEV_IFINDEX = 1,
	NETDEV_A_DEV_PAD = 2,
	NETDEV_A_DEV_XDP_FEATURES = 3,
	NETDEV_A_DEV_XDP_ZC_MAX_SEGS = 4,
	NETDEV_A_DEV_XDP_RX_METADATA_FEATURES = 5,
	NETDEV_A_DEV_XSK_FEATURES = 6,
	__NETDEV_A_DEV_MAX = 7,
	NETDEV_A_DEV_MAX = 6,
};

enum {
	NETDEV_A_DMABUF_IFINDEX = 1,
	NETDEV_A_DMABUF_QUEUES = 2,
	NETDEV_A_DMABUF_FD = 3,
	NETDEV_A_DMABUF_ID = 4,
	__NETDEV_A_DMABUF_MAX = 5,
	NETDEV_A_DMABUF_MAX = 4,
};

enum {
	NETDEV_A_NAPI_IFINDEX = 1,
	NETDEV_A_NAPI_ID = 2,
	NETDEV_A_NAPI_IRQ = 3,
	NETDEV_A_NAPI_PID = 4,
	NETDEV_A_NAPI_DEFER_HARD_IRQS = 5,
	NETDEV_A_NAPI_GRO_FLUSH_TIMEOUT = 6,
	NETDEV_A_NAPI_IRQ_SUSPEND_TIMEOUT = 7,
	__NETDEV_A_NAPI_MAX = 8,
	NETDEV_A_NAPI_MAX = 7,
};

enum {
	NETDEV_A_PAGE_POOL_ID = 1,
	NETDEV_A_PAGE_POOL_IFINDEX = 2,
	NETDEV_A_PAGE_POOL_NAPI_ID = 3,
	NETDEV_A_PAGE_POOL_INFLIGHT = 4,
	NETDEV_A_PAGE_POOL_INFLIGHT_MEM = 5,
	NETDEV_A_PAGE_POOL_DETACH_TIME = 6,
	NETDEV_A_PAGE_POOL_DMABUF = 7,
	__NETDEV_A_PAGE_POOL_MAX = 8,
	NETDEV_A_PAGE_POOL_MAX = 7,
};

enum {
	NETDEV_A_PAGE_POOL_STATS_INFO = 1,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_FAST = 8,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_SLOW = 9,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_SLOW_HIGH_ORDER = 10,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_EMPTY = 11,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_REFILL = 12,
	NETDEV_A_PAGE_POOL_STATS_ALLOC_WAIVE = 13,
	NETDEV_A_PAGE_POOL_STATS_RECYCLE_CACHED = 14,
	NETDEV_A_PAGE_POOL_STATS_RECYCLE_CACHE_FULL = 15,
	NETDEV_A_PAGE_POOL_STATS_RECYCLE_RING = 16,
	NETDEV_A_PAGE_POOL_STATS_RECYCLE_RING_FULL = 17,
	NETDEV_A_PAGE_POOL_STATS_RECYCLE_RELEASED_REFCNT = 18,
	__NETDEV_A_PAGE_POOL_STATS_MAX = 19,
	NETDEV_A_PAGE_POOL_STATS_MAX = 18,
};

enum {
	NETDEV_A_QSTATS_IFINDEX = 1,
	NETDEV_A_QSTATS_QUEUE_TYPE = 2,
	NETDEV_A_QSTATS_QUEUE_ID = 3,
	NETDEV_A_QSTATS_SCOPE = 4,
	NETDEV_A_QSTATS_RX_PACKETS = 8,
	NETDEV_A_QSTATS_RX_BYTES = 9,
	NETDEV_A_QSTATS_TX_PACKETS = 10,
	NETDEV_A_QSTATS_TX_BYTES = 11,
	NETDEV_A_QSTATS_RX_ALLOC_FAIL = 12,
	NETDEV_A_QSTATS_RX_HW_DROPS = 13,
	NETDEV_A_QSTATS_RX_HW_DROP_OVERRUNS = 14,
	NETDEV_A_QSTATS_RX_CSUM_COMPLETE = 15,
	NETDEV_A_QSTATS_RX_CSUM_UNNECESSARY = 16,
	NETDEV_A_QSTATS_RX_CSUM_NONE = 17,
	NETDEV_A_QSTATS_RX_CSUM_BAD = 18,
	NETDEV_A_QSTATS_RX_HW_GRO_PACKETS = 19,
	NETDEV_A_QSTATS_RX_HW_GRO_BYTES = 20,
	NETDEV_A_QSTATS_RX_HW_GRO_WIRE_PACKETS = 21,
	NETDEV_A_QSTATS_RX_HW_GRO_WIRE_BYTES = 22,
	NETDEV_A_QSTATS_RX_HW_DROP_RATELIMITS = 23,
	NETDEV_A_QSTATS_TX_HW_DROPS = 24,
	NETDEV_A_QSTATS_TX_HW_DROP_ERRORS = 25,
	NETDEV_A_QSTATS_TX_CSUM_NONE = 26,
	NETDEV_A_QSTATS_TX_NEEDS_CSUM = 27,
	NETDEV_A_QSTATS_TX_HW_GSO_PACKETS = 28,
	NETDEV_A_QSTATS_TX_HW_GSO_BYTES = 29,
	NETDEV_A_QSTATS_TX_HW_GSO_WIRE_PACKETS = 30,
	NETDEV_A_QSTATS_TX_HW_GSO_WIRE_BYTES = 31,
	NETDEV_A_QSTATS_TX_HW_DROP_RATELIMITS = 32,
	NETDEV_A_QSTATS_TX_STOP = 33,
	NETDEV_A_QSTATS_TX_WAKE = 34,
	__NETDEV_A_QSTATS_MAX = 35,
	NETDEV_A_QSTATS_MAX = 34,
};

enum {
	NETDEV_A_QUEUE_ID = 1,
	NETDEV_A_QUEUE_IFINDEX = 2,
	NETDEV_A_QUEUE_TYPE = 3,
	NETDEV_A_QUEUE_NAPI_ID = 4,
	NETDEV_A_QUEUE_DMABUF = 5,
	__NETDEV_A_QUEUE_MAX = 6,
	NETDEV_A_QUEUE_MAX = 5,
};

enum {
	NETDEV_CMD_DEV_GET = 1,
	NETDEV_CMD_DEV_ADD_NTF = 2,
	NETDEV_CMD_DEV_DEL_NTF = 3,
	NETDEV_CMD_DEV_CHANGE_NTF = 4,
	NETDEV_CMD_PAGE_POOL_GET = 5,
	NETDEV_CMD_PAGE_POOL_ADD_NTF = 6,
	NETDEV_CMD_PAGE_POOL_DEL_NTF = 7,
	NETDEV_CMD_PAGE_POOL_CHANGE_NTF = 8,
	NETDEV_CMD_PAGE_POOL_STATS_GET = 9,
	NETDEV_CMD_QUEUE_GET = 10,
	NETDEV_CMD_NAPI_GET = 11,
	NETDEV_CMD_QSTATS_GET = 12,
	NETDEV_CMD_BIND_RX = 13,
	NETDEV_CMD_NAPI_SET = 14,
	__NETDEV_CMD_MAX = 15,
	NETDEV_CMD_MAX = 14,
};

enum {
	NETDEV_NLGRP_MGMT = 0,
	NETDEV_NLGRP_PAGE_POOL = 1,
};

enum {
	NETEM_LOSS_UNSPEC = 0,
	NETEM_LOSS_GI = 1,
	NETEM_LOSS_GE = 2,
	__NETEM_LOSS_MAX = 3,
};

enum {
	NETIF_F_SG_BIT = 0,
	NETIF_F_IP_CSUM_BIT = 1,
	__UNUSED_NETIF_F_1 = 2,
	NETIF_F_HW_CSUM_BIT = 3,
	NETIF_F_IPV6_CSUM_BIT = 4,
	NETIF_F_HIGHDMA_BIT = 5,
	NETIF_F_FRAGLIST_BIT = 6,
	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
	NETIF_F_VLAN_CHALLENGED_BIT = 10,
	NETIF_F_GSO_BIT = 11,
	__UNUSED_NETIF_F_12 = 12,
	__UNUSED_NETIF_F_13 = 13,
	NETIF_F_GRO_BIT = 14,
	NETIF_F_LRO_BIT = 15,
	NETIF_F_GSO_SHIFT = 16,
	NETIF_F_TSO_BIT = 16,
	NETIF_F_GSO_ROBUST_BIT = 17,
	NETIF_F_TSO_ECN_BIT = 18,
	NETIF_F_TSO_MANGLEID_BIT = 19,
	NETIF_F_TSO6_BIT = 20,
	NETIF_F_FSO_BIT = 21,
	NETIF_F_GSO_GRE_BIT = 22,
	NETIF_F_GSO_GRE_CSUM_BIT = 23,
	NETIF_F_GSO_IPXIP4_BIT = 24,
	NETIF_F_GSO_IPXIP6_BIT = 25,
	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
	NETIF_F_GSO_PARTIAL_BIT = 28,
	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
	NETIF_F_GSO_SCTP_BIT = 30,
	NETIF_F_GSO_ESP_BIT = 31,
	NETIF_F_GSO_UDP_BIT = 32,
	NETIF_F_GSO_UDP_L4_BIT = 33,
	NETIF_F_GSO_FRAGLIST_BIT = 34,
	NETIF_F_GSO_LAST = 34,
	NETIF_F_FCOE_CRC_BIT = 35,
	NETIF_F_SCTP_CRC_BIT = 36,
	__UNUSED_NETIF_F_37 = 37,
	NETIF_F_NTUPLE_BIT = 38,
	NETIF_F_RXHASH_BIT = 39,
	NETIF_F_RXCSUM_BIT = 40,
	NETIF_F_NOCACHE_COPY_BIT = 41,
	NETIF_F_LOOPBACK_BIT = 42,
	NETIF_F_RXFCS_BIT = 43,
	NETIF_F_RXALL_BIT = 44,
	NETIF_F_HW_VLAN_STAG_TX_BIT = 45,
	NETIF_F_HW_VLAN_STAG_RX_BIT = 46,
	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 47,
	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 48,
	NETIF_F_HW_TC_BIT = 49,
	NETIF_F_HW_ESP_BIT = 50,
	NETIF_F_HW_ESP_TX_CSUM_BIT = 51,
	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 52,
	NETIF_F_HW_TLS_TX_BIT = 53,
	NETIF_F_HW_TLS_RX_BIT = 54,
	NETIF_F_GRO_HW_BIT = 55,
	NETIF_F_HW_TLS_RECORD_BIT = 56,
	NETIF_F_GRO_FRAGLIST_BIT = 57,
	NETIF_F_HW_MACSEC_BIT = 58,
	NETIF_F_GRO_UDP_FWD_BIT = 59,
	NETIF_F_HW_HSR_TAG_INS_BIT = 60,
	NETIF_F_HW_HSR_TAG_RM_BIT = 61,
	NETIF_F_HW_HSR_FWD_BIT = 62,
	NETIF_F_HW_HSR_DUP_BIT = 63,
	NETDEV_FEATURE_COUNT = 64,
};

enum {
	NETIF_MSG_DRV_BIT = 0,
	NETIF_MSG_PROBE_BIT = 1,
	NETIF_MSG_LINK_BIT = 2,
	NETIF_MSG_TIMER_BIT = 3,
	NETIF_MSG_IFDOWN_BIT = 4,
	NETIF_MSG_IFUP_BIT = 5,
	NETIF_MSG_RX_ERR_BIT = 6,
	NETIF_MSG_TX_ERR_BIT = 7,
	NETIF_MSG_TX_QUEUED_BIT = 8,
	NETIF_MSG_INTR_BIT = 9,
	NETIF_MSG_TX_DONE_BIT = 10,
	NETIF_MSG_RX_STATUS_BIT = 11,
	NETIF_MSG_PKTDATA_BIT = 12,
	NETIF_MSG_HW_BIT = 13,
	NETIF_MSG_WOL_BIT = 14,
	NETIF_MSG_CLASS_COUNT = 15,
};

enum {
	NETLINK_DIAG_MEMINFO = 0,
	NETLINK_DIAG_GROUPS = 1,
	NETLINK_DIAG_RX_RING = 2,
	NETLINK_DIAG_TX_RING = 3,
	NETLINK_DIAG_FLAGS = 4,
	__NETLINK_DIAG_MAX = 5,
};

enum {
	NETLINK_F_KERNEL_SOCKET = 0,
	NETLINK_F_RECV_PKTINFO = 1,
	NETLINK_F_BROADCAST_SEND_ERROR = 2,
	NETLINK_F_RECV_NO_ENOBUFS = 3,
	NETLINK_F_LISTEN_ALL_NSID = 4,
	NETLINK_F_CAP_ACK = 5,
	NETLINK_F_EXT_ACK = 6,
	NETLINK_F_STRICT_CHK = 7,
};

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED = 1,
};

enum {
	NETNSA_NONE = 0,
	NETNSA_NSID = 1,
	NETNSA_PID = 2,
	NETNSA_FD = 3,
	NETNSA_TARGET_NSID = 4,
	NETNSA_CURRENT_NSID = 5,
	__NETNSA_MAX = 6,
};

enum {
	NET_NS_INDEX = 0,
	UTS_NS_INDEX = 1,
	IPC_NS_INDEX = 2,
	PID_NS_INDEX = 3,
	USER_NS_INDEX = 4,
	MNT_NS_INDEX = 5,
	CGROUP_NS_INDEX = 6,
	NR_NAMESPACES = 7,
};

enum {
	NEXTHOP_GRP_TYPE_MPATH = 0,
	NEXTHOP_GRP_TYPE_RES = 1,
	__NEXTHOP_GRP_TYPE_MAX = 2,
};

enum {
	NFACCT_NO_QUOTA = -1,
	NFACCT_UNDERQUOTA = 0,
	NFACCT_OVERQUOTA = 1,
};

enum {
	NFEA_UNSPEC = 0,
	NFEA_ACTIVITY_NOTIFY = 1,
	NFEA_DONT_REFRESH = 2,
	__NFEA_MAX = 3,
};

enum {
	NFNL_BATCH_FAILURE = 1,
	NFNL_BATCH_DONE = 2,
	NFNL_BATCH_REPLAY = 4,
};

enum {
	NFNL_MSG_COMPAT_GET = 0,
	NFNL_MSG_COMPAT_MAX = 1,
};

enum {
	NFPROTO_UNSPEC = 0,
	NFPROTO_INET = 1,
	NFPROTO_IPV4 = 2,
	NFPROTO_ARP = 3,
	NFPROTO_NETDEV = 5,
	NFPROTO_BRIDGE = 7,
	NFPROTO_IPV6 = 10,
	NFPROTO_NUMPROTO = 11,
};

enum {
	NFSPROC4_CLNT_NULL = 0,
	NFSPROC4_CLNT_READ = 1,
	NFSPROC4_CLNT_WRITE = 2,
	NFSPROC4_CLNT_COMMIT = 3,
	NFSPROC4_CLNT_OPEN = 4,
	NFSPROC4_CLNT_OPEN_CONFIRM = 5,
	NFSPROC4_CLNT_OPEN_NOATTR = 6,
	NFSPROC4_CLNT_OPEN_DOWNGRADE = 7,
	NFSPROC4_CLNT_CLOSE = 8,
	NFSPROC4_CLNT_SETATTR = 9,
	NFSPROC4_CLNT_FSINFO = 10,
	NFSPROC4_CLNT_RENEW = 11,
	NFSPROC4_CLNT_SETCLIENTID = 12,
	NFSPROC4_CLNT_SETCLIENTID_CONFIRM = 13,
	NFSPROC4_CLNT_LOCK = 14,
	NFSPROC4_CLNT_LOCKT = 15,
	NFSPROC4_CLNT_LOCKU = 16,
	NFSPROC4_CLNT_ACCESS = 17,
	NFSPROC4_CLNT_GETATTR = 18,
	NFSPROC4_CLNT_LOOKUP = 19,
	NFSPROC4_CLNT_LOOKUP_ROOT = 20,
	NFSPROC4_CLNT_REMOVE = 21,
	NFSPROC4_CLNT_RENAME = 22,
	NFSPROC4_CLNT_LINK = 23,
	NFSPROC4_CLNT_SYMLINK = 24,
	NFSPROC4_CLNT_CREATE = 25,
	NFSPROC4_CLNT_PATHCONF = 26,
	NFSPROC4_CLNT_STATFS = 27,
	NFSPROC4_CLNT_READLINK = 28,
	NFSPROC4_CLNT_READDIR = 29,
	NFSPROC4_CLNT_SERVER_CAPS = 30,
	NFSPROC4_CLNT_DELEGRETURN = 31,
	NFSPROC4_CLNT_GETACL = 32,
	NFSPROC4_CLNT_SETACL = 33,
	NFSPROC4_CLNT_FS_LOCATIONS = 34,
	NFSPROC4_CLNT_RELEASE_LOCKOWNER = 35,
	NFSPROC4_CLNT_SECINFO = 36,
	NFSPROC4_CLNT_FSID_PRESENT = 37,
	NFSPROC4_CLNT_EXCHANGE_ID = 38,
	NFSPROC4_CLNT_CREATE_SESSION = 39,
	NFSPROC4_CLNT_DESTROY_SESSION = 40,
	NFSPROC4_CLNT_SEQUENCE = 41,
	NFSPROC4_CLNT_GET_LEASE_TIME = 42,
	NFSPROC4_CLNT_RECLAIM_COMPLETE = 43,
	NFSPROC4_CLNT_LAYOUTGET = 44,
	NFSPROC4_CLNT_GETDEVICEINFO = 45,
	NFSPROC4_CLNT_LAYOUTCOMMIT = 46,
	NFSPROC4_CLNT_LAYOUTRETURN = 47,
	NFSPROC4_CLNT_SECINFO_NO_NAME = 48,
	NFSPROC4_CLNT_TEST_STATEID = 49,
	NFSPROC4_CLNT_FREE_STATEID = 50,
	NFSPROC4_CLNT_GETDEVICELIST = 51,
	NFSPROC4_CLNT_BIND_CONN_TO_SESSION = 52,
	NFSPROC4_CLNT_DESTROY_CLIENTID = 53,
	NFSPROC4_CLNT_SEEK = 54,
	NFSPROC4_CLNT_ALLOCATE = 55,
	NFSPROC4_CLNT_DEALLOCATE = 56,
	NFSPROC4_CLNT_LAYOUTSTATS = 57,
	NFSPROC4_CLNT_CLONE = 58,
	NFSPROC4_CLNT_COPY = 59,
	NFSPROC4_CLNT_OFFLOAD_CANCEL = 60,
	NFSPROC4_CLNT_LOOKUPP = 61,
	NFSPROC4_CLNT_LAYOUTERROR = 62,
	NFSPROC4_CLNT_COPY_NOTIFY = 63,
	NFSPROC4_CLNT_GETXATTR = 64,
	NFSPROC4_CLNT_SETXATTR = 65,
	NFSPROC4_CLNT_LISTXATTRS = 66,
	NFSPROC4_CLNT_REMOVEXATTR = 67,
	NFSPROC4_CLNT_READ_PLUS = 68,
};

enum {
	NFS_DELEGATION_NEED_RECLAIM = 0,
	NFS_DELEGATION_RETURN = 1,
	NFS_DELEGATION_RETURN_IF_CLOSED = 2,
	NFS_DELEGATION_REFERENCED = 3,
	NFS_DELEGATION_RETURNING = 4,
	NFS_DELEGATION_REVOKED = 5,
	NFS_DELEGATION_TEST_EXPIRED = 6,
	NFS_DELEGATION_INODE_FREEING = 7,
	NFS_DELEGATION_RETURN_DELAYED = 8,
	NFS_DELEGATION_DELEGTIME = 9,
};

enum {
	NFS_IOHDR_ERROR = 0,
	NFS_IOHDR_EOF = 1,
	NFS_IOHDR_REDO = 2,
	NFS_IOHDR_STAT = 3,
	NFS_IOHDR_RESEND_PNFS = 4,
	NFS_IOHDR_RESEND_MDS = 5,
	NFS_IOHDR_UNSTABLE_WRITES = 6,
	NFS_IOHDR_ODIRECT = 7,
};

enum {
	NFS_OWNER_RECLAIM_REBOOT = 0,
	NFS_OWNER_RECLAIM_NOGRACE = 1,
};

enum {
	NFTA_COMPAT_UNSPEC = 0,
	NFTA_COMPAT_NAME = 1,
	NFTA_COMPAT_REV = 2,
	NFTA_COMPAT_TYPE = 3,
	__NFTA_COMPAT_MAX = 4,
};

enum {
	NFT_INNER_EXPR_PAYLOAD = 0,
	NFT_INNER_EXPR_META = 1,
};

enum {
	NFT_PAYLOAD_CTX_INNER_TUN = 1,
	NFT_PAYLOAD_CTX_INNER_LL = 2,
	NFT_PAYLOAD_CTX_INNER_NH = 4,
	NFT_PAYLOAD_CTX_INNER_TH = 8,
};

enum {
	NFT_PKTINFO_L4PROTO = 1,
	NFT_PKTINFO_INNER = 2,
	NFT_PKTINFO_INNER_FULL = 4,
};

enum {
	NFT_VALIDATE_SKIP = 0,
	NFT_VALIDATE_NEED = 1,
	NFT_VALIDATE_DO = 2,
};

enum {
	NF_BPF_CT_OPTS_SZ = 16,
};

enum {
	NF_BPF_FLOWTABLE_OPTS_SZ = 4,
};

enum {
	NHA_GROUP_STATS_ENTRY_UNSPEC = 0,
	NHA_GROUP_STATS_ENTRY_ID = 1,
	NHA_GROUP_STATS_ENTRY_PACKETS = 2,
	NHA_GROUP_STATS_ENTRY_PACKETS_HW = 3,
	__NHA_GROUP_STATS_ENTRY_MAX = 4,
};

enum {
	NHA_GROUP_STATS_UNSPEC = 0,
	NHA_GROUP_STATS_ENTRY = 1,
	__NHA_GROUP_STATS_MAX = 2,
};

enum {
	NHA_RES_BUCKET_UNSPEC = 0,
	NHA_RES_BUCKET_PAD = 0,
	NHA_RES_BUCKET_INDEX = 1,
	NHA_RES_BUCKET_IDLE_TIME = 2,
	NHA_RES_BUCKET_NH_ID = 3,
	__NHA_RES_BUCKET_MAX = 4,
};

enum {
	NHA_RES_GROUP_UNSPEC = 0,
	NHA_RES_GROUP_PAD = 0,
	NHA_RES_GROUP_BUCKETS = 1,
	NHA_RES_GROUP_IDLE_TIMER = 2,
	NHA_RES_GROUP_UNBALANCED_TIMER = 3,
	NHA_RES_GROUP_UNBALANCED_TIME = 4,
	__NHA_RES_GROUP_MAX = 5,
};

enum {
	NHA_UNSPEC = 0,
	NHA_ID = 1,
	NHA_GROUP = 2,
	NHA_GROUP_TYPE = 3,
	NHA_BLACKHOLE = 4,
	NHA_OIF = 5,
	NHA_GATEWAY = 6,
	NHA_ENCAP_TYPE = 7,
	NHA_ENCAP = 8,
	NHA_GROUPS = 9,
	NHA_MASTER = 10,
	NHA_FDB = 11,
	NHA_RES_GROUP = 12,
	NHA_RES_BUCKET = 13,
	NHA_OP_FLAGS = 14,
	NHA_GROUP_STATS = 15,
	NHA_HW_STATS_ENABLE = 16,
	NHA_HW_STATS_USED = 17,
	__NHA_MAX = 18,
};

enum {
	NLA_UNSPEC = 0,
	NLA_U8 = 1,
	NLA_U16 = 2,
	NLA_U32 = 3,
	NLA_U64 = 4,
	NLA_STRING = 5,
	NLA_FLAG = 6,
	NLA_MSECS = 7,
	NLA_NESTED = 8,
	NLA_NESTED_ARRAY = 9,
	NLA_NUL_STRING = 10,
	NLA_BINARY = 11,
	NLA_S8 = 12,
	NLA_S16 = 13,
	NLA_S32 = 14,
	NLA_S64 = 15,
	NLA_BITFIELD32 = 16,
	NLA_REJECT = 17,
	NLA_BE16 = 18,
	NLA_BE32 = 19,
	NLA_SINT = 20,
	NLA_UINT = 21,
	__NLA_TYPE_MAX = 22,
};

enum {
	NLBL_CALIPSO_A_UNSPEC = 0,
	NLBL_CALIPSO_A_DOI = 1,
	NLBL_CALIPSO_A_MTYPE = 2,
	__NLBL_CALIPSO_A_MAX = 3,
};

enum {
	NLBL_CALIPSO_C_UNSPEC = 0,
	NLBL_CALIPSO_C_ADD = 1,
	NLBL_CALIPSO_C_REMOVE = 2,
	NLBL_CALIPSO_C_LIST = 3,
	NLBL_CALIPSO_C_LISTALL = 4,
	__NLBL_CALIPSO_C_MAX = 5,
};

enum {
	NLBL_CIPSOV4_A_UNSPEC = 0,
	NLBL_CIPSOV4_A_DOI = 1,
	NLBL_CIPSOV4_A_MTYPE = 2,
	NLBL_CIPSOV4_A_TAG = 3,
	NLBL_CIPSOV4_A_TAGLST = 4,
	NLBL_CIPSOV4_A_MLSLVLLOC = 5,
	NLBL_CIPSOV4_A_MLSLVLREM = 6,
	NLBL_CIPSOV4_A_MLSLVL = 7,
	NLBL_CIPSOV4_A_MLSLVLLST = 8,
	NLBL_CIPSOV4_A_MLSCATLOC = 9,
	NLBL_CIPSOV4_A_MLSCATREM = 10,
	NLBL_CIPSOV4_A_MLSCAT = 11,
	NLBL_CIPSOV4_A_MLSCATLST = 12,
	__NLBL_CIPSOV4_A_MAX = 13,
};

enum {
	NLBL_CIPSOV4_C_UNSPEC = 0,
	NLBL_CIPSOV4_C_ADD = 1,
	NLBL_CIPSOV4_C_REMOVE = 2,
	NLBL_CIPSOV4_C_LIST = 3,
	NLBL_CIPSOV4_C_LISTALL = 4,
	__NLBL_CIPSOV4_C_MAX = 5,
};

enum {
	NLBL_MGMT_A_UNSPEC = 0,
	NLBL_MGMT_A_DOMAIN = 1,
	NLBL_MGMT_A_PROTOCOL = 2,
	NLBL_MGMT_A_VERSION = 3,
	NLBL_MGMT_A_CV4DOI = 4,
	NLBL_MGMT_A_IPV6ADDR = 5,
	NLBL_MGMT_A_IPV6MASK = 6,
	NLBL_MGMT_A_IPV4ADDR = 7,
	NLBL_MGMT_A_IPV4MASK = 8,
	NLBL_MGMT_A_ADDRSELECTOR = 9,
	NLBL_MGMT_A_SELECTORLIST = 10,
	NLBL_MGMT_A_FAMILY = 11,
	NLBL_MGMT_A_CLPDOI = 12,
	__NLBL_MGMT_A_MAX = 13,
};

enum {
	NLBL_MGMT_C_UNSPEC = 0,
	NLBL_MGMT_C_ADD = 1,
	NLBL_MGMT_C_REMOVE = 2,
	NLBL_MGMT_C_LISTALL = 3,
	NLBL_MGMT_C_ADDDEF = 4,
	NLBL_MGMT_C_REMOVEDEF = 5,
	NLBL_MGMT_C_LISTDEF = 6,
	NLBL_MGMT_C_PROTOCOLS = 7,
	NLBL_MGMT_C_VERSION = 8,
	__NLBL_MGMT_C_MAX = 9,
};

enum {
	NLBL_UNLABEL_A_UNSPEC = 0,
	NLBL_UNLABEL_A_ACPTFLG = 1,
	NLBL_UNLABEL_A_IPV6ADDR = 2,
	NLBL_UNLABEL_A_IPV6MASK = 3,
	NLBL_UNLABEL_A_IPV4ADDR = 4,
	NLBL_UNLABEL_A_IPV4MASK = 5,
	NLBL_UNLABEL_A_IFACE = 6,
	NLBL_UNLABEL_A_SECCTX = 7,
	__NLBL_UNLABEL_A_MAX = 8,
};

enum {
	NLBL_UNLABEL_C_UNSPEC = 0,
	NLBL_UNLABEL_C_ACCEPT = 1,
	NLBL_UNLABEL_C_LIST = 2,
	NLBL_UNLABEL_C_STATICADD = 3,
	NLBL_UNLABEL_C_STATICREMOVE = 4,
	NLBL_UNLABEL_C_STATICLIST = 5,
	NLBL_UNLABEL_C_STATICADDDEF = 6,
	NLBL_UNLABEL_C_STATICREMOVEDEF = 7,
	NLBL_UNLABEL_C_STATICLISTDEF = 8,
	__NLBL_UNLABEL_C_MAX = 9,
};

enum {
	NLM_LCK_GRANTED = 0,
	NLM_LCK_DENIED = 1,
	NLM_LCK_DENIED_NOLOCKS = 2,
	NLM_LCK_BLOCKED = 3,
	NLM_LCK_DENIED_GRACE_PERIOD = 4,
	NLM_DEADLCK = 5,
	NLM_ROFS = 6,
	NLM_STALE_FH = 7,
	NLM_FBIG = 8,
	NLM_FAILED = 9,
};

enum {
	NMI_LOCAL = 0,
	NMI_UNKNOWN = 1,
	NMI_SERR = 2,
	NMI_IO_CHECK = 3,
	NMI_MAX = 4,
};

enum {
	NODE_SIZE = 256,
	KEYS_PER_NODE = 16,
	RECS_PER_LEAF = 15,
};

enum {
	NONE_FORCE_HPET_RESUME = 0,
	OLD_ICH_FORCE_HPET_RESUME = 1,
	ICH_FORCE_HPET_RESUME = 2,
	VT8237_FORCE_HPET_RESUME = 3,
	NVIDIA_FORCE_HPET_RESUME = 4,
	ATI_FORCE_HPET_RESUME = 5,
};

enum {
	NSMPROC_NULL = 0,
	NSMPROC_STAT = 1,
	NSMPROC_MON = 2,
	NSMPROC_UNMON = 3,
	NSMPROC_UNMON_ALL = 4,
	NSMPROC_SIMU_CRASH = 5,
	NSMPROC_NOTIFY = 6,
};

enum {
	NUM_TRIAL_SAMPLES = 8192,
	MAX_SAMPLES_PER_BIT = 66,
};

enum {
	NVMEM_ADD = 1,
	NVMEM_REMOVE = 2,
	NVMEM_CELL_ADD = 3,
	NVMEM_CELL_REMOVE = 4,
	NVMEM_LAYOUT_ADD = 5,
	NVMEM_LAYOUT_REMOVE = 6,
};

enum {
	NVME_AEN_BIT_NS_ATTR = 8,
	NVME_AEN_BIT_FW_ACT = 9,
	NVME_AEN_BIT_ANA_CHANGE = 11,
	NVME_AEN_BIT_DISC_CHANGE = 31,
};

enum {
	NVME_AEN_CFG_NS_ATTR = 256,
	NVME_AEN_CFG_FW_ACT = 512,
	NVME_AEN_CFG_ANA_CHANGE = 2048,
	NVME_AEN_CFG_DISC_CHANGE = -2147483648,
};

enum {
	NVME_AER_ERROR = 0,
	NVME_AER_SMART = 1,
	NVME_AER_NOTICE = 2,
	NVME_AER_CSS = 6,
	NVME_AER_VS = 7,
};

enum {
	NVME_AER_ERROR_PERSIST_INT_ERR = 3,
};

enum {
	NVME_AER_NOTICE_NS_CHANGED = 0,
	NVME_AER_NOTICE_FW_ACT_STARTING = 1,
	NVME_AER_NOTICE_ANA = 3,
	NVME_AER_NOTICE_DISC_CHANGED = 240,
};

enum {
	NVME_AUTH_COMMON_MESSAGES = 0,
	NVME_AUTH_DHCHAP_MESSAGES = 1,
};

enum {
	NVME_AUTH_DHCHAP_AUTH_ID = 1,
};

enum {
	NVME_AUTH_DHCHAP_FAILURE_FAILED = 1,
	NVME_AUTH_DHCHAP_FAILURE_NOT_USABLE = 2,
	NVME_AUTH_DHCHAP_FAILURE_CONCAT_MISMATCH = 3,
	NVME_AUTH_DHCHAP_FAILURE_HASH_UNUSABLE = 4,
	NVME_AUTH_DHCHAP_FAILURE_DHGROUP_UNUSABLE = 5,
	NVME_AUTH_DHCHAP_FAILURE_INCORRECT_PAYLOAD = 6,
	NVME_AUTH_DHCHAP_FAILURE_INCORRECT_MESSAGE = 7,
};

enum {
	NVME_AUTH_DHCHAP_FAILURE_REASON_FAILED = 1,
};

enum {
	NVME_AUTH_DHCHAP_MESSAGE_NEGOTIATE = 0,
	NVME_AUTH_DHCHAP_MESSAGE_CHALLENGE = 1,
	NVME_AUTH_DHCHAP_MESSAGE_REPLY = 2,
	NVME_AUTH_DHCHAP_MESSAGE_SUCCESS1 = 3,
	NVME_AUTH_DHCHAP_MESSAGE_SUCCESS2 = 4,
	NVME_AUTH_DHCHAP_MESSAGE_FAILURE2 = 240,
	NVME_AUTH_DHCHAP_MESSAGE_FAILURE1 = 241,
};

enum {
	NVME_AUTH_DHCHAP_PROTOCOL_IDENTIFIER = 233,
};

enum {
	NVME_AUTH_DHGROUP_NULL = 0,
	NVME_AUTH_DHGROUP_2048 = 1,
	NVME_AUTH_DHGROUP_3072 = 2,
	NVME_AUTH_DHGROUP_4096 = 3,
	NVME_AUTH_DHGROUP_6144 = 4,
	NVME_AUTH_DHGROUP_8192 = 5,
	NVME_AUTH_DHGROUP_INVALID = 255,
};

enum {
	NVME_AUTH_HASH_SHA256 = 1,
	NVME_AUTH_HASH_SHA384 = 2,
	NVME_AUTH_HASH_SHA512 = 3,
	NVME_AUTH_HASH_INVALID = 255,
};

enum {
	NVME_CAP_CRMS_CRWMS = 576460752303423488ULL,
	NVME_CAP_CRMS_CRIMS = 1152921504606846976ULL,
};

enum {
	NVME_CAP_CSS_NVM = 1,
	NVME_CAP_CSS_CSI = 64,
};

enum {
	NVME_CC_ENABLE = 1,
	NVME_CC_EN_SHIFT = 0,
	NVME_CC_CSS_SHIFT = 4,
	NVME_CC_CSS_MASK = 112,
	NVME_CC_CSS_NVM = 0,
	NVME_CC_CSS_CSI = 96,
	NVME_CC_MPS_SHIFT = 7,
	NVME_CC_MPS_MASK = 1920,
	NVME_CC_AMS_SHIFT = 11,
	NVME_CC_AMS_MASK = 14336,
	NVME_CC_AMS_RR = 0,
	NVME_CC_AMS_WRRU = 2048,
	NVME_CC_AMS_VS = 14336,
	NVME_CC_SHN_SHIFT = 14,
	NVME_CC_SHN_MASK = 49152,
	NVME_CC_SHN_NONE = 0,
	NVME_CC_SHN_NORMAL = 16384,
	NVME_CC_SHN_ABRUPT = 32768,
	NVME_CC_IOSQES_SHIFT = 16,
	NVME_CC_IOSQES_MASK = 983040,
	NVME_CC_IOSQES = 393216,
	NVME_CC_IOCQES_SHIFT = 20,
	NVME_CC_IOCQES_MASK = 15728640,
	NVME_CC_IOCQES = 4194304,
	NVME_CC_CRIME = 16777216,
};

enum {
	NVME_CMBMSC_CRE = 1,
	NVME_CMBMSC_CMSE = 2,
};

enum {
	NVME_CMBSZ_SQS = 1,
	NVME_CMBSZ_CQS = 2,
	NVME_CMBSZ_LISTS = 4,
	NVME_CMBSZ_RDS = 8,
	NVME_CMBSZ_WDS = 16,
	NVME_CMBSZ_SZ_SHIFT = 12,
	NVME_CMBSZ_SZ_MASK = 1048575,
	NVME_CMBSZ_SZU_SHIFT = 8,
	NVME_CMBSZ_SZU_MASK = 15,
};

enum {
	NVME_CMD_EFFECTS_CSUPP = 1,
	NVME_CMD_EFFECTS_LBCC = 2,
	NVME_CMD_EFFECTS_NCC = 4,
	NVME_CMD_EFFECTS_NIC = 8,
	NVME_CMD_EFFECTS_CCC = 16,
	NVME_CMD_EFFECTS_CSER_MASK = 49152,
	NVME_CMD_EFFECTS_CSE_MASK = 458752,
	NVME_CMD_EFFECTS_UUID_SEL = 524288,
	NVME_CMD_EFFECTS_SCOPE_MASK = 4293918720,
};

enum {
	NVME_CMD_FUSE_FIRST = 1,
	NVME_CMD_FUSE_SECOND = 2,
	NVME_CMD_SGL_METABUF = 64,
	NVME_CMD_SGL_METASEG = 128,
	NVME_CMD_SGL_ALL = 192,
};

enum {
	NVME_CONNECT_AUTHREQ_ASCR = 262144,
	NVME_CONNECT_AUTHREQ_ATR = 131072,
};

enum {
	NVME_CONNECT_DISABLE_SQFLOW = 4,
};

enum {
	NVME_CSI_NVM = 0,
	NVME_CSI_ZNS = 2,
};

enum {
	NVME_CSTS_RDY = 1,
	NVME_CSTS_CFS = 2,
	NVME_CSTS_NSSRO = 16,
	NVME_CSTS_PP = 32,
	NVME_CSTS_SHST_NORMAL = 0,
	NVME_CSTS_SHST_OCCUR = 4,
	NVME_CSTS_SHST_CMPLT = 8,
	NVME_CSTS_SHST_MASK = 12,
};

enum {
	NVME_CTRL_CMIC_MULTI_PORT = 1,
	NVME_CTRL_CMIC_MULTI_CTRL = 2,
	NVME_CTRL_CMIC_ANA = 8,
	NVME_CTRL_ONCS_COMPARE = 1,
	NVME_CTRL_ONCS_WRITE_UNCORRECTABLE = 2,
	NVME_CTRL_ONCS_DSM = 4,
	NVME_CTRL_ONCS_WRITE_ZEROES = 8,
	NVME_CTRL_ONCS_RESERVATIONS = 32,
	NVME_CTRL_ONCS_TIMESTAMP = 64,
	NVME_CTRL_VWC_PRESENT = 1,
	NVME_CTRL_OACS_SEC_SUPP = 1,
	NVME_CTRL_OACS_NS_MNGT_SUPP = 8,
	NVME_CTRL_OACS_DIRECTIVES = 32,
	NVME_CTRL_OACS_DBBUF_SUPP = 256,
	NVME_CTRL_LPA_CMD_EFFECTS_LOG = 2,
	NVME_CTRL_CTRATT_128_ID = 1,
	NVME_CTRL_CTRATT_NON_OP_PSP = 2,
	NVME_CTRL_CTRATT_NVM_SETS = 4,
	NVME_CTRL_CTRATT_READ_RECV_LVLS = 8,
	NVME_CTRL_CTRATT_ENDURANCE_GROUPS = 16,
	NVME_CTRL_CTRATT_PREDICTABLE_LAT = 32,
	NVME_CTRL_CTRATT_NAMESPACE_GRANULARITY = 128,
	NVME_CTRL_CTRATT_UUID_LIST = 512,
	NVME_CTRL_SGLS_BYTE_ALIGNED = 1,
	NVME_CTRL_SGLS_DWORD_ALIGNED = 2,
	NVME_CTRL_SGLS_KSDBDS = 4,
	NVME_CTRL_SGLS_MSDS = 524288,
	NVME_CTRL_SGLS_SAOS = 1048576,
};

enum {
	NVME_DSMGMT_IDR = 1,
	NVME_DSMGMT_IDW = 2,
	NVME_DSMGMT_AD = 4,
};

enum {
	NVME_ENABLE_ACRE = 1,
	NVME_ENABLE_LBAFEE = 1,
};

enum {
	NVME_HOST_MEM_ENABLE = 1,
	NVME_HOST_MEM_RETURN = 2,
};

enum {
	NVME_ID_CNS_NS = 0,
	NVME_ID_CNS_CTRL = 1,
	NVME_ID_CNS_NS_ACTIVE_LIST = 2,
	NVME_ID_CNS_NS_DESC_LIST = 3,
	NVME_ID_CNS_CS_NS = 5,
	NVME_ID_CNS_CS_CTRL = 6,
	NVME_ID_CNS_NS_ACTIVE_LIST_CS = 7,
	NVME_ID_CNS_NS_CS_INDEP = 8,
	NVME_ID_CNS_NS_PRESENT_LIST = 16,
	NVME_ID_CNS_NS_PRESENT = 17,
	NVME_ID_CNS_CTRL_NS_LIST = 18,
	NVME_ID_CNS_CTRL_LIST = 19,
	NVME_ID_CNS_SCNDRY_CTRL_LIST = 21,
	NVME_ID_CNS_NS_GRANULARITY = 22,
	NVME_ID_CNS_UUID_LIST = 23,
	NVME_ID_CNS_ENDGRP_LIST = 25,
};

enum {
	NVME_ID_NS_NVM_STS_MASK = 127,
	NVME_ID_NS_NVM_GUARD_SHIFT = 7,
	NVME_ID_NS_NVM_GUARD_MASK = 3,
	NVME_ID_NS_NVM_QPIF_SHIFT = 9,
	NVME_ID_NS_NVM_QPIF_MASK = 15,
	NVME_ID_NS_NVM_QPIFS = 8,
};

enum {
	NVME_IOCTL_VEC = 1,
	NVME_IOCTL_PARTITION = 2,
};

enum {
	NVME_NIDT_EUI64 = 1,
	NVME_NIDT_NGUID = 2,
	NVME_NIDT_UUID = 3,
	NVME_NIDT_CSI = 4,
};

enum {
	NVME_NSTAT_NRDY = 1,
};

enum {
	NVME_NS_FEAT_THIN = 1,
	NVME_NS_FEAT_ATOMICS = 2,
	NVME_NS_FEAT_IO_OPT = 16,
	NVME_NS_ATTR_RO = 1,
	NVME_NS_FLBAS_LBA_MASK = 15,
	NVME_NS_FLBAS_LBA_UMASK = 96,
	NVME_NS_FLBAS_LBA_SHIFT = 1,
	NVME_NS_FLBAS_META_EXT = 16,
	NVME_NS_NMIC_SHARED = 1,
	NVME_NS_ROTATIONAL = 16,
	NVME_NS_VWC_NOT_PRESENT = 32,
	NVME_LBAF_RP_BEST = 0,
	NVME_LBAF_RP_BETTER = 1,
	NVME_LBAF_RP_GOOD = 2,
	NVME_LBAF_RP_DEGRADED = 3,
	NVME_NS_DPC_PI_LAST = 16,
	NVME_NS_DPC_PI_FIRST = 8,
	NVME_NS_DPC_PI_TYPE3 = 4,
	NVME_NS_DPC_PI_TYPE2 = 2,
	NVME_NS_DPC_PI_TYPE1 = 1,
	NVME_NS_DPS_PI_FIRST = 8,
	NVME_NS_DPS_PI_MASK = 7,
	NVME_NS_DPS_PI_TYPE1 = 1,
	NVME_NS_DPS_PI_TYPE2 = 2,
	NVME_NS_DPS_PI_TYPE3 = 3,
};

enum {
	NVME_NVM_NS_16B_GUARD = 0,
	NVME_NVM_NS_32B_GUARD = 1,
	NVME_NVM_NS_64B_GUARD = 2,
	NVME_NVM_NS_QTYPE_GUARD = 3,
};

enum {
	NVME_PS_FLAGS_MAX_POWER_SCALE = 1,
	NVME_PS_FLAGS_NON_OP_STATE = 2,
};

enum {
	NVME_QUEUE_PHYS_CONTIG = 1,
	NVME_CQ_IRQ_ENABLED = 2,
	NVME_SQ_PRIO_URGENT = 0,
	NVME_SQ_PRIO_HIGH = 2,
	NVME_SQ_PRIO_MEDIUM = 4,
	NVME_SQ_PRIO_LOW = 6,
	NVME_FEAT_ARBITRATION = 1,
	NVME_FEAT_POWER_MGMT = 2,
	NVME_FEAT_LBA_RANGE = 3,
	NVME_FEAT_TEMP_THRESH = 4,
	NVME_FEAT_ERR_RECOVERY = 5,
	NVME_FEAT_VOLATILE_WC = 6,
	NVME_FEAT_NUM_QUEUES = 7,
	NVME_FEAT_IRQ_COALESCE = 8,
	NVME_FEAT_IRQ_CONFIG = 9,
	NVME_FEAT_WRITE_ATOMIC = 10,
	NVME_FEAT_ASYNC_EVENT = 11,
	NVME_FEAT_AUTO_PST = 12,
	NVME_FEAT_HOST_MEM_BUF = 13,
	NVME_FEAT_TIMESTAMP = 14,
	NVME_FEAT_KATO = 15,
	NVME_FEAT_HCTM = 16,
	NVME_FEAT_NOPSC = 17,
	NVME_FEAT_RRL = 18,
	NVME_FEAT_PLM_CONFIG = 19,
	NVME_FEAT_PLM_WINDOW = 20,
	NVME_FEAT_HOST_BEHAVIOR = 22,
	NVME_FEAT_SANITIZE = 23,
	NVME_FEAT_SW_PROGRESS = 128,
	NVME_FEAT_HOST_ID = 129,
	NVME_FEAT_RESV_MASK = 130,
	NVME_FEAT_RESV_PERSIST = 131,
	NVME_FEAT_WRITE_PROTECT = 132,
	NVME_FEAT_VENDOR_START = 192,
	NVME_FEAT_VENDOR_END = 255,
	NVME_LOG_SUPPORTED = 0,
	NVME_LOG_ERROR = 1,
	NVME_LOG_SMART = 2,
	NVME_LOG_FW_SLOT = 3,
	NVME_LOG_CHANGED_NS = 4,
	NVME_LOG_CMD_EFFECTS = 5,
	NVME_LOG_DEVICE_SELF_TEST = 6,
	NVME_LOG_TELEMETRY_HOST = 7,
	NVME_LOG_TELEMETRY_CTRL = 8,
	NVME_LOG_ENDURANCE_GROUP = 9,
	NVME_LOG_ANA = 12,
	NVME_LOG_FEATURES = 18,
	NVME_LOG_RMI = 22,
	NVME_LOG_DISC = 112,
	NVME_LOG_RESERVATION = 128,
	NVME_FWACT_REPL = 0,
	NVME_FWACT_REPL_ACTV = 8,
	NVME_FWACT_ACTV = 16,
};

enum {
	NVME_REG_CAP = 0,
	NVME_REG_VS = 8,
	NVME_REG_INTMS = 12,
	NVME_REG_INTMC = 16,
	NVME_REG_CC = 20,
	NVME_REG_CSTS = 28,
	NVME_REG_NSSR = 32,
	NVME_REG_AQA = 36,
	NVME_REG_ASQ = 40,
	NVME_REG_ACQ = 48,
	NVME_REG_CMBLOC = 56,
	NVME_REG_CMBSZ = 60,
	NVME_REG_BPINFO = 64,
	NVME_REG_BPRSEL = 68,
	NVME_REG_BPMBL = 72,
	NVME_REG_CMBMSC = 80,
	NVME_REG_CRTO = 104,
	NVME_REG_PMRCAP = 3584,
	NVME_REG_PMRCTL = 3588,
	NVME_REG_PMRSTS = 3592,
	NVME_REG_PMREBS = 3596,
	NVME_REG_PMRSWTP = 3600,
	NVME_REG_DBS = 4096,
};

enum {
	NVME_REQ_CANCELLED = 1,
	NVME_REQ_USERCMD = 2,
	NVME_MPATH_IO_STATS = 4,
	NVME_MPATH_CNT_ACTIVE = 8,
};

enum {
	NVME_RW_LR = 32768,
	NVME_RW_FUA = 16384,
	NVME_RW_APPEND_PIREMAP = 512,
	NVME_RW_DSM_FREQ_UNSPEC = 0,
	NVME_RW_DSM_FREQ_TYPICAL = 1,
	NVME_RW_DSM_FREQ_RARE = 2,
	NVME_RW_DSM_FREQ_READS = 3,
	NVME_RW_DSM_FREQ_WRITES = 4,
	NVME_RW_DSM_FREQ_RW = 5,
	NVME_RW_DSM_FREQ_ONCE = 6,
	NVME_RW_DSM_FREQ_PREFETCH = 7,
	NVME_RW_DSM_FREQ_TEMP = 8,
	NVME_RW_DSM_LATENCY_NONE = 0,
	NVME_RW_DSM_LATENCY_IDLE = 16,
	NVME_RW_DSM_LATENCY_NORM = 32,
	NVME_RW_DSM_LATENCY_LOW = 48,
	NVME_RW_DSM_SEQ_REQ = 64,
	NVME_RW_DSM_COMPRESSED = 128,
	NVME_RW_PRINFO_PRCHK_REF = 1024,
	NVME_RW_PRINFO_PRCHK_APP = 2048,
	NVME_RW_PRINFO_PRCHK_GUARD = 4096,
	NVME_RW_PRINFO_PRACT = 8192,
	NVME_RW_DTYPE_STREAMS = 16,
	NVME_WZ_DEAC = 512,
};

enum {
	NVME_SCT_GENERIC = 0,
	NVME_SC_SUCCESS = 0,
	NVME_SC_INVALID_OPCODE = 1,
	NVME_SC_INVALID_FIELD = 2,
	NVME_SC_CMDID_CONFLICT = 3,
	NVME_SC_DATA_XFER_ERROR = 4,
	NVME_SC_POWER_LOSS = 5,
	NVME_SC_INTERNAL = 6,
	NVME_SC_ABORT_REQ = 7,
	NVME_SC_ABORT_QUEUE = 8,
	NVME_SC_FUSED_FAIL = 9,
	NVME_SC_FUSED_MISSING = 10,
	NVME_SC_INVALID_NS = 11,
	NVME_SC_CMD_SEQ_ERROR = 12,
	NVME_SC_SGL_INVALID_LAST = 13,
	NVME_SC_SGL_INVALID_COUNT = 14,
	NVME_SC_SGL_INVALID_DATA = 15,
	NVME_SC_SGL_INVALID_METADATA = 16,
	NVME_SC_SGL_INVALID_TYPE = 17,
	NVME_SC_CMB_INVALID_USE = 18,
	NVME_SC_PRP_INVALID_OFFSET = 19,
	NVME_SC_ATOMIC_WU_EXCEEDED = 20,
	NVME_SC_OP_DENIED = 21,
	NVME_SC_SGL_INVALID_OFFSET = 22,
	NVME_SC_RESERVED = 23,
	NVME_SC_HOST_ID_INCONSIST = 24,
	NVME_SC_KA_TIMEOUT_EXPIRED = 25,
	NVME_SC_KA_TIMEOUT_INVALID = 26,
	NVME_SC_ABORTED_PREEMPT_ABORT = 27,
	NVME_SC_SANITIZE_FAILED = 28,
	NVME_SC_SANITIZE_IN_PROGRESS = 29,
	NVME_SC_SGL_INVALID_GRANULARITY = 30,
	NVME_SC_CMD_NOT_SUP_CMB_QUEUE = 31,
	NVME_SC_NS_WRITE_PROTECTED = 32,
	NVME_SC_CMD_INTERRUPTED = 33,
	NVME_SC_TRANSIENT_TR_ERR = 34,
	NVME_SC_ADMIN_COMMAND_MEDIA_NOT_READY = 36,
	NVME_SC_INVALID_IO_CMD_SET = 44,
	NVME_SC_LBA_RANGE = 128,
	NVME_SC_CAP_EXCEEDED = 129,
	NVME_SC_NS_NOT_READY = 130,
	NVME_SC_RESERVATION_CONFLICT = 131,
	NVME_SC_FORMAT_IN_PROGRESS = 132,
	NVME_SCT_COMMAND_SPECIFIC = 256,
	NVME_SC_CQ_INVALID = 256,
	NVME_SC_QID_INVALID = 257,
	NVME_SC_QUEUE_SIZE = 258,
	NVME_SC_ABORT_LIMIT = 259,
	NVME_SC_ABORT_MISSING = 260,
	NVME_SC_ASYNC_LIMIT = 261,
	NVME_SC_FIRMWARE_SLOT = 262,
	NVME_SC_FIRMWARE_IMAGE = 263,
	NVME_SC_INVALID_VECTOR = 264,
	NVME_SC_INVALID_LOG_PAGE = 265,
	NVME_SC_INVALID_FORMAT = 266,
	NVME_SC_FW_NEEDS_CONV_RESET = 267,
	NVME_SC_INVALID_QUEUE = 268,
	NVME_SC_FEATURE_NOT_SAVEABLE = 269,
	NVME_SC_FEATURE_NOT_CHANGEABLE = 270,
	NVME_SC_FEATURE_NOT_PER_NS = 271,
	NVME_SC_FW_NEEDS_SUBSYS_RESET = 272,
	NVME_SC_FW_NEEDS_RESET = 273,
	NVME_SC_FW_NEEDS_MAX_TIME = 274,
	NVME_SC_FW_ACTIVATE_PROHIBITED = 275,
	NVME_SC_OVERLAPPING_RANGE = 276,
	NVME_SC_NS_INSUFFICIENT_CAP = 277,
	NVME_SC_NS_ID_UNAVAILABLE = 278,
	NVME_SC_NS_ALREADY_ATTACHED = 280,
	NVME_SC_NS_IS_PRIVATE = 281,
	NVME_SC_NS_NOT_ATTACHED = 282,
	NVME_SC_THIN_PROV_NOT_SUPP = 283,
	NVME_SC_CTRL_LIST_INVALID = 284,
	NVME_SC_SELT_TEST_IN_PROGRESS = 285,
	NVME_SC_BP_WRITE_PROHIBITED = 286,
	NVME_SC_CTRL_ID_INVALID = 287,
	NVME_SC_SEC_CTRL_STATE_INVALID = 288,
	NVME_SC_CTRL_RES_NUM_INVALID = 289,
	NVME_SC_RES_ID_INVALID = 290,
	NVME_SC_PMR_SAN_PROHIBITED = 291,
	NVME_SC_ANA_GROUP_ID_INVALID = 292,
	NVME_SC_ANA_ATTACH_FAILED = 293,
	NVME_SC_BAD_ATTRIBUTES = 384,
	NVME_SC_INVALID_PI = 385,
	NVME_SC_READ_ONLY = 386,
	NVME_SC_ONCS_NOT_SUPPORTED = 387,
	NVME_SC_CONNECT_FORMAT = 384,
	NVME_SC_CONNECT_CTRL_BUSY = 385,
	NVME_SC_CONNECT_INVALID_PARAM = 386,
	NVME_SC_CONNECT_RESTART_DISC = 387,
	NVME_SC_CONNECT_INVALID_HOST = 388,
	NVME_SC_DISCOVERY_RESTART = 400,
	NVME_SC_AUTH_REQUIRED = 401,
	NVME_SC_ZONE_BOUNDARY_ERROR = 440,
	NVME_SC_ZONE_FULL = 441,
	NVME_SC_ZONE_READ_ONLY = 442,
	NVME_SC_ZONE_OFFLINE = 443,
	NVME_SC_ZONE_INVALID_WRITE = 444,
	NVME_SC_ZONE_TOO_MANY_ACTIVE = 445,
	NVME_SC_ZONE_TOO_MANY_OPEN = 446,
	NVME_SC_ZONE_INVALID_TRANSITION = 447,
	NVME_SCT_MEDIA_ERROR = 512,
	NVME_SC_WRITE_FAULT = 640,
	NVME_SC_READ_ERROR = 641,
	NVME_SC_GUARD_CHECK = 642,
	NVME_SC_APPTAG_CHECK = 643,
	NVME_SC_REFTAG_CHECK = 644,
	NVME_SC_COMPARE_FAILED = 645,
	NVME_SC_ACCESS_DENIED = 646,
	NVME_SC_UNWRITTEN_BLOCK = 647,
	NVME_SCT_PATH = 768,
	NVME_SC_INTERNAL_PATH_ERROR = 768,
	NVME_SC_ANA_PERSISTENT_LOSS = 769,
	NVME_SC_ANA_INACCESSIBLE = 770,
	NVME_SC_ANA_TRANSITION = 771,
	NVME_SC_CTRL_PATH_ERROR = 864,
	NVME_SC_HOST_PATH_ERROR = 880,
	NVME_SC_HOST_ABORTED_CMD = 881,
	NVME_SC_MASK = 255,
	NVME_SCT_MASK = 1792,
	NVME_SCT_SC_MASK = 2047,
	NVME_STATUS_CRD = 6144,
	NVME_STATUS_MORE = 8192,
	NVME_STATUS_DNR = 16384,
};

enum {
	NVME_SGL_FMT_ADDRESS = 0,
	NVME_SGL_FMT_OFFSET = 1,
	NVME_SGL_FMT_TRANSPORT_A = 10,
	NVME_SGL_FMT_INVALIDATE = 15,
};

enum {
	NVME_SGL_FMT_DATA_DESC = 0,
	NVME_SGL_FMT_SEG_DESC = 2,
	NVME_SGL_FMT_LAST_SEG_DESC = 3,
	NVME_KEY_SGL_FMT_DATA_DESC = 4,
	NVME_TRANSPORT_SGL_DATA_DESC = 5,
};

enum {
	NVME_SMART_CRIT_SPARE = 1,
	NVME_SMART_CRIT_TEMPERATURE = 2,
	NVME_SMART_CRIT_RELIABILITY = 4,
	NVME_SMART_CRIT_MEDIA = 8,
	NVME_SMART_CRIT_VOLATILE_MEMORY = 16,
};

enum {
	NVME_SUBMIT_AT_HEAD = 1,
	NVME_SUBMIT_NOWAIT = 2,
	NVME_SUBMIT_RESERVED = 4,
	NVME_SUBMIT_RETRY = 8,
};

enum {
	NVME_TEMP_THRESH_MASK = 65535,
	NVME_TEMP_THRESH_SELECT_SHIFT = 16,
	NVME_TEMP_THRESH_TYPE_UNDER = 1048576,
};

enum {
	NVMF_OPT_ERR = 0,
	NVMF_OPT_TRANSPORT = 1,
	NVMF_OPT_NQN = 2,
	NVMF_OPT_TRADDR = 4,
	NVMF_OPT_TRSVCID = 8,
	NVMF_OPT_QUEUE_SIZE = 16,
	NVMF_OPT_NR_IO_QUEUES = 32,
	NVMF_OPT_TL_RETRY_COUNT = 64,
	NVMF_OPT_KATO = 128,
	NVMF_OPT_HOSTNQN = 256,
	NVMF_OPT_RECONNECT_DELAY = 512,
	NVMF_OPT_HOST_TRADDR = 1024,
	NVMF_OPT_CTRL_LOSS_TMO = 2048,
	NVMF_OPT_HOST_ID = 4096,
	NVMF_OPT_DUP_CONNECT = 8192,
	NVMF_OPT_DISABLE_SQFLOW = 16384,
	NVMF_OPT_HDR_DIGEST = 32768,
	NVMF_OPT_DATA_DIGEST = 65536,
	NVMF_OPT_NR_WRITE_QUEUES = 131072,
	NVMF_OPT_NR_POLL_QUEUES = 262144,
	NVMF_OPT_TOS = 524288,
	NVMF_OPT_FAIL_FAST_TMO = 1048576,
	NVMF_OPT_HOST_IFACE = 2097152,
	NVMF_OPT_DISCOVERY = 4194304,
	NVMF_OPT_DHCHAP_SECRET = 8388608,
	NVMF_OPT_DHCHAP_CTRL_SECRET = 16777216,
	NVMF_OPT_TLS = 33554432,
	NVMF_OPT_KEYRING = 67108864,
	NVMF_OPT_TLS_KEY = 134217728,
};

enum {
	ODP_NOT_NEEDED = 0,
	ODP_ZEROBASED = 1,
	ODP_VIRTUAL = 2,
};

enum {
	OD_NORMAL_SAMPLE = 0,
	OD_SUB_SAMPLE = 1,
};

enum {
	ONLINE_POLICY_CONTIG_ZONES = 0,
	ONLINE_POLICY_AUTO_MOVABLE = 1,
};

enum {
	OPT_DAX = 0,
	OPT_DAX_ENUM = 1,
};

enum {
	OPT_SOURCE = 0,
	OPT_SUBTYPE = 1,
	OPT_FD = 2,
	OPT_ROOTMODE = 3,
	OPT_USER_ID = 4,
	OPT_GROUP_ID = 5,
	OPT_DEFAULT_PERMISSIONS = 6,
	OPT_ALLOW_OTHER = 7,
	OPT_MAX_READ = 8,
	OPT_BLKSIZE = 9,
	OPT_ERR = 10,
};

enum {
	OPT_UID = 0,
	OPT_GID = 1,
	OPT_MODE = 2,
	OPT_DELEGATE_CMDS = 3,
	OPT_DELEGATE_MAPS = 4,
	OPT_DELEGATE_PROGS = 5,
	OPT_DELEGATE_ATTACHS = 6,
};

enum {
	OVL_REDIRECT_OFF = 0,
	OVL_REDIRECT_FOLLOW = 1,
	OVL_REDIRECT_NOFOLLOW = 2,
	OVL_REDIRECT_ON = 3,
};

enum {
	OVL_UUID_OFF = 0,
	OVL_UUID_NULL = 1,
	OVL_UUID_AUTO = 2,
	OVL_UUID_ON = 3,
};

enum {
	OVL_VERITY_OFF = 0,
	OVL_VERITY_ON = 1,
	OVL_VERITY_REQUIRE = 2,
};

enum {
	OVL_XINO_OFF = 0,
	OVL_XINO_AUTO = 1,
	OVL_XINO_ON = 2,
};

enum {
	OVS_TUNNEL_ATTR_UNSPEC = 0,
	OVS_TUNNEL_ATTR_DST_PORT = 1,
	OVS_TUNNEL_ATTR_EXTENSION = 2,
	__OVS_TUNNEL_ATTR_MAX = 3,
};

enum {
	OVS_VXLAN_EXT_UNSPEC = 0,
	OVS_VXLAN_EXT_GBP = 1,
	__OVS_VXLAN_EXT_MAX = 2,
};

enum {
	Opt_acl = 0,
	Opt_clear_cache = 1,
	Opt_commit_interval = 2,
	Opt_compress = 3,
	Opt_compress_force = 4,
	Opt_compress_force_type = 5,
	Opt_compress_type = 6,
	Opt_degraded = 7,
	Opt_device = 8,
	Opt_fatal_errors = 9,
	Opt_flushoncommit = 10,
	Opt_max_inline = 11,
	Opt_barrier = 12,
	Opt_datacow = 13,
	Opt_datasum = 14,
	Opt_defrag = 15,
	Opt_discard = 16,
	Opt_discard_mode = 17,
	Opt_ratio = 18,
	Opt_rescan_uuid_tree = 19,
	Opt_skip_balance = 20,
	Opt_space_cache = 21,
	Opt_space_cache_version = 22,
	Opt_ssd = 23,
	Opt_ssd_spread = 24,
	Opt_subvol = 25,
	Opt_subvol_empty = 26,
	Opt_subvolid = 27,
	Opt_thread_pool = 28,
	Opt_treelog = 29,
	Opt_user_subvol_rm_allowed = 30,
	Opt_norecovery = 31,
	Opt_rescue = 32,
	Opt_usebackuproot = 33,
	Opt_nologreplay = 34,
	Opt_enospc_debug = 35,
	Opt_err = 36,
};

enum {
	Opt_block = 0,
	Opt_check = 1,
	Opt_cruft = 2,
	Opt_gid = 3,
	Opt_ignore = 4,
	Opt_iocharset = 5,
	Opt_map = 6,
	Opt_mode = 7,
	Opt_nojoliet = 8,
	Opt_norock = 9,
	Opt_sb = 10,
	Opt_session = 11,
	Opt_uid = 12,
	Opt_unhide = 13,
	Opt_utf8 = 14,
	Opt_err___2 = 15,
	Opt_nocompress = 16,
	Opt_hide = 17,
	Opt_showassoc = 18,
	Opt_dmode = 19,
	Opt_overriderockperm = 20,
};

enum {
	Opt_bsd_df = 0,
	Opt_minix_df = 1,
	Opt_grpid = 2,
	Opt_nogrpid = 3,
	Opt_resgid = 4,
	Opt_resuid = 5,
	Opt_sb___2 = 6,
	Opt_nouid32 = 7,
	Opt_debug = 8,
	Opt_removed = 9,
	Opt_user_xattr = 10,
	Opt_acl___2 = 11,
	Opt_auto_da_alloc = 12,
	Opt_noauto_da_alloc = 13,
	Opt_noload = 14,
	Opt_commit = 15,
	Opt_min_batch_time = 16,
	Opt_max_batch_time = 17,
	Opt_journal_dev = 18,
	Opt_journal_path = 19,
	Opt_journal_checksum = 20,
	Opt_journal_async_commit = 21,
	Opt_abort = 22,
	Opt_data_journal = 23,
	Opt_data_ordered = 24,
	Opt_data_writeback = 25,
	Opt_data_err_abort = 26,
	Opt_data_err_ignore = 27,
	Opt_test_dummy_encryption = 28,
	Opt_inlinecrypt = 29,
	Opt_usrjquota = 30,
	Opt_grpjquota = 31,
	Opt_quota = 32,
	Opt_noquota = 33,
	Opt_barrier___2 = 34,
	Opt_nobarrier = 35,
	Opt_err___3 = 36,
	Opt_usrquota = 37,
	Opt_grpquota = 38,
	Opt_prjquota = 39,
	Opt_dax = 40,
	Opt_dax_always = 41,
	Opt_dax_inode = 42,
	Opt_dax_never = 43,
	Opt_stripe = 44,
	Opt_delalloc = 45,
	Opt_nodelalloc = 46,
	Opt_warn_on_error = 47,
	Opt_nowarn_on_error = 48,
	Opt_mblk_io_submit = 49,
	Opt_debug_want_extra_isize = 50,
	Opt_nomblk_io_submit = 51,
	Opt_block_validity = 52,
	Opt_noblock_validity = 53,
	Opt_inode_readahead_blks = 54,
	Opt_journal_ioprio = 55,
	Opt_dioread_nolock = 56,
	Opt_dioread_lock = 57,
	Opt_discard___2 = 58,
	Opt_nodiscard = 59,
	Opt_init_itable = 60,
	Opt_noinit_itable = 61,
	Opt_max_dir_size_kb = 62,
	Opt_nojournal_checksum = 63,
	Opt_nombcache = 64,
	Opt_no_prefetch_block_bitmaps = 65,
	Opt_mb_optimize_scan = 66,
	Opt_errors = 67,
	Opt_data = 68,
	Opt_data_err = 69,
	Opt_jqfmt = 70,
	Opt_dax_type = 71,
};

enum {
	Opt_check___2 = 0,
	Opt_uid___2 = 1,
	Opt_gid___2 = 2,
	Opt_umask = 3,
	Opt_dmask = 4,
	Opt_fmask = 5,
	Opt_allow_utime = 6,
	Opt_codepage = 7,
	Opt_usefree = 8,
	Opt_nocase = 9,
	Opt_quiet = 10,
	Opt_showexec = 11,
	Opt_debug___2 = 12,
	Opt_immutable = 13,
	Opt_dots = 14,
	Opt_dotsOK = 15,
	Opt_charset = 16,
	Opt_shortname = 17,
	Opt_utf8___2 = 18,
	Opt_utf8_bool = 19,
	Opt_uni_xl = 20,
	Opt_uni_xl_bool = 21,
	Opt_nonumtail = 22,
	Opt_nonumtail_bool = 23,
	Opt_obsolete = 24,
	Opt_flush = 25,
	Opt_tz = 26,
	Opt_rodir = 27,
	Opt_errors___2 = 28,
	Opt_discard___3 = 29,
	Opt_nfs = 30,
	Opt_nfs_enum = 31,
	Opt_time_offset = 32,
	Opt_dos1xfloppy = 33,
};

enum {
	Opt_debug___3 = 0,
	Opt_dfltuid = 1,
	Opt_dfltgid = 2,
	Opt_afid = 3,
	Opt_uname = 4,
	Opt_remotename = 5,
	Opt_cache = 6,
	Opt_cachetag = 7,
	Opt_nodevmap = 8,
	Opt_noxattr = 9,
	Opt_directio = 10,
	Opt_ignoreqv = 11,
	Opt_access = 12,
	Opt_posixacl = 13,
	Opt_locktimeout = 14,
	Opt_err___4 = 15,
};

enum {
	Opt_direct = 0,
	Opt_fd = 1,
	Opt_gid___3 = 2,
	Opt_ignore___2 = 3,
	Opt_indirect = 4,
	Opt_maxproto = 5,
	Opt_minproto = 6,
	Opt_offset = 7,
	Opt_pgrp = 8,
	Opt_strictexpire = 9,
	Opt_uid___3 = 10,
};

enum {
	Opt_discard_sync = 0,
	Opt_discard_async = 1,
};

enum {
	Opt_err___5 = 0,
	Opt_enc = 1,
	Opt_hash = 2,
};

enum {
	Opt_fatal_errors_panic = 0,
	Opt_fatal_errors_bug = 1,
};

enum {
	Opt_find_uid = 0,
	Opt_find_gid = 1,
	Opt_find_user = 2,
	Opt_find_group = 3,
	Opt_find_err = 4,
};

enum {
	Opt_local_lock_all = 0,
	Opt_local_lock_flock = 1,
	Opt_local_lock_none = 2,
	Opt_local_lock_posix = 3,
};

enum {
	Opt_logbufs = 0,
	Opt_logbsize = 1,
	Opt_logdev = 2,
	Opt_rtdev = 3,
	Opt_wsync = 4,
	Opt_noalign = 5,
	Opt_swalloc = 6,
	Opt_sunit = 7,
	Opt_swidth = 8,
	Opt_nouuid = 9,
	Opt_grpid___2 = 10,
	Opt_nogrpid___2 = 11,
	Opt_bsdgroups = 12,
	Opt_sysvgroups = 13,
	Opt_allocsize = 14,
	Opt_norecovery___2 = 15,
	Opt_inode64 = 16,
	Opt_inode32 = 17,
	Opt_ikeep = 18,
	Opt_noikeep = 19,
	Opt_largeio = 20,
	Opt_nolargeio = 21,
	Opt_attr2 = 22,
	Opt_noattr2 = 23,
	Opt_filestreams = 24,
	Opt_quota___2 = 25,
	Opt_noquota___2 = 26,
	Opt_usrquota___2 = 27,
	Opt_grpquota___2 = 28,
	Opt_prjquota___2 = 29,
	Opt_uquota = 30,
	Opt_gquota = 31,
	Opt_pquota = 32,
	Opt_uqnoenforce = 33,
	Opt_gqnoenforce = 34,
	Opt_pqnoenforce = 35,
	Opt_qnoenforce = 36,
	Opt_discard___4 = 37,
	Opt_nodiscard___2 = 38,
	Opt_dax___2 = 39,
	Opt_dax_enum = 40,
};

enum {
	Opt_lookupcache_all = 0,
	Opt_lookupcache_none = 1,
	Opt_lookupcache_positive = 2,
};

enum {
	Opt_msize = 0,
	Opt_trans = 1,
	Opt_legacy = 2,
	Opt_version = 3,
	Opt_err___6 = 4,
};

enum {
	Opt_port = 0,
	Opt_rfdno = 1,
	Opt_wfdno = 2,
	Opt_err___7 = 3,
	Opt_privport = 4,
};

enum {
	Opt_rescue_usebackuproot = 0,
	Opt_rescue_nologreplay = 1,
	Opt_rescue_ignorebadroots = 2,
	Opt_rescue_ignoredatacsums = 3,
	Opt_rescue_ignoremetacsums = 4,
	Opt_rescue_ignoresuperflags = 5,
	Opt_rescue_parameter_all = 6,
};

enum {
	Opt_sec_krb5 = 0,
	Opt_sec_krb5i = 1,
	Opt_sec_krb5p = 2,
	Opt_sec_lkey = 3,
	Opt_sec_lkeyi = 4,
	Opt_sec_lkeyp = 5,
	Opt_sec_none = 6,
	Opt_sec_spkm = 7,
	Opt_sec_spkmi = 8,
	Opt_sec_spkmp = 9,
	Opt_sec_sys = 10,
	nr__Opt_sec = 11,
};

enum {
	Opt_space_cache_v1 = 0,
	Opt_space_cache_v2 = 1,
};

enum {
	Opt_uid___4 = 0,
	Opt_gid___4 = 1,
};

enum {
	Opt_uid___5 = 0,
	Opt_gid___5 = 1,
	Opt_mode___2 = 2,
};

enum {
	Opt_uid___6 = 0,
	Opt_gid___6 = 1,
	Opt_mode___3 = 2,
	Opt_source = 3,
};

enum {
	Opt_uid___7 = 0,
	Opt_gid___7 = 1,
	Opt_mode___4 = 2,
	Opt_ptmxmode = 3,
	Opt_newinstance = 4,
	Opt_max = 5,
	Opt_err___8 = 6,
};

enum {
	Opt_vers_2 = 0,
	Opt_vers_3 = 1,
	Opt_vers_4 = 2,
	Opt_vers_4_0 = 3,
	Opt_vers_4_1 = 4,
	Opt_vers_4_2 = 5,
};

enum {
	Opt_write_lazy = 0,
	Opt_write_eager = 1,
	Opt_write_wait = 2,
};

enum {
	Opt_xprt_rdma = 0,
	Opt_xprt_rdma6 = 1,
	Opt_xprt_tcp = 2,
	Opt_xprt_tcp6 = 3,
	Opt_xprt_udp = 4,
	Opt_xprt_udp6 = 5,
	nr__Opt_xprt = 6,
};

enum {
	Opt_xprtsec_none = 0,
	Opt_xprtsec_tls = 1,
	Opt_xprtsec_mtls = 2,
	nr__Opt_xprtsec = 3,
};

enum {
	PACKET_DIAG_INFO = 0,
	PACKET_DIAG_MCLIST = 1,
	PACKET_DIAG_RX_RING = 2,
	PACKET_DIAG_TX_RING = 3,
	PACKET_DIAG_FANOUT = 4,
	PACKET_DIAG_UID = 5,
	PACKET_DIAG_MEMINFO = 6,
	PACKET_DIAG_FILTER = 7,
	__PACKET_DIAG_MAX = 8,
};

enum {
	PAGE_WAS_MAPPED = 1,
	PAGE_WAS_MLOCKED = 2,
	PAGE_OLD_STATES = 3,
};

enum {
	PARSE_INVALID = 1,
	PARSE_NOT_LONGNAME = 2,
	PARSE_EOF = 3,
};

enum {
	PCI_REASSIGN_ALL_RSRC = 1,
	PCI_REASSIGN_ALL_BUS = 2,
	PCI_PROBE_ONLY = 4,
	PCI_CAN_SKIP_ISA_ALIGN = 8,
	PCI_ENABLE_PROC_DOMAINS = 16,
	PCI_COMPAT_DOMAIN_0 = 32,
	PCI_SCAN_ALL_PCIE_DEVS = 64,
};

enum {
	PCI_STD_RESOURCES = 0,
	PCI_STD_RESOURCE_END = 5,
	PCI_ROM_RESOURCE = 6,
	PCI_BRIDGE_RESOURCES = 7,
	PCI_BRIDGE_RESOURCE_END = 10,
	PCI_NUM_RESOURCES = 11,
	DEVICE_COUNT_RESOURCE = 11,
};

enum {
	PCMCIA_IOPORT_0 = 0,
	PCMCIA_IOPORT_1 = 1,
	PCMCIA_IOMEM_0 = 2,
	PCMCIA_IOMEM_1 = 3,
	PCMCIA_IOMEM_2 = 4,
	PCMCIA_IOMEM_3 = 5,
	PCMCIA_NUM_RESOURCES = 6,
};

enum {
	PEP_IND_EMPTY = 0,
	PEP_IND_BUSY = 1,
	PEP_IND_READY = 2,
};

enum {
	PERCPU_REF_INIT_ATOMIC = 1,
	PERCPU_REF_INIT_DEAD = 2,
	PERCPU_REF_ALLOW_REINIT = 4,
};

enum {
	PERF_BR_SPEC_NA = 0,
	PERF_BR_SPEC_WRONG_PATH = 1,
	PERF_BR_NON_SPEC_CORRECT_PATH = 2,
	PERF_BR_SPEC_CORRECT_PATH = 3,
	PERF_BR_SPEC_MAX = 4,
};

enum {
	PERF_BR_UNKNOWN = 0,
	PERF_BR_COND = 1,
	PERF_BR_UNCOND = 2,
	PERF_BR_IND = 3,
	PERF_BR_CALL = 4,
	PERF_BR_IND_CALL = 5,
	PERF_BR_RET = 6,
	PERF_BR_SYSCALL = 7,
	PERF_BR_SYSRET = 8,
	PERF_BR_COND_CALL = 9,
	PERF_BR_COND_RET = 10,
	PERF_BR_ERET = 11,
	PERF_BR_IRQ = 12,
	PERF_BR_SERROR = 13,
	PERF_BR_NO_TX = 14,
	PERF_BR_EXTEND_ABI = 15,
	PERF_BR_MAX = 16,
};

enum {
	PERF_GROUP_OAG = 0,
	PERF_GROUP_OAM_SAMEDIA_0 = 0,
	PERF_GROUP_MAX = 1,
	PERF_GROUP_INVALID = 4294967295,
};

enum {
	PERF_TXN_ELISION = 1ULL,
	PERF_TXN_TRANSACTION = 2ULL,
	PERF_TXN_SYNC = 4ULL,
	PERF_TXN_ASYNC = 8ULL,
	PERF_TXN_RETRY = 16ULL,
	PERF_TXN_CONFLICT = 32ULL,
	PERF_TXN_CAPACITY_WRITE = 64ULL,
	PERF_TXN_CAPACITY_READ = 128ULL,
	PERF_TXN_MAX = 256ULL,
	PERF_TXN_ABORT_MASK = 18446744069414584320ULL,
	PERF_TXN_ABORT_SHIFT = 32ULL,
};

enum {
	PERF_X86_EVENT_PEBS_LDLAT = 1,
	PERF_X86_EVENT_PEBS_ST = 2,
	PERF_X86_EVENT_PEBS_ST_HSW = 4,
	PERF_X86_EVENT_PEBS_LD_HSW = 8,
	PERF_X86_EVENT_PEBS_NA_HSW = 16,
	PERF_X86_EVENT_EXCL = 32,
	PERF_X86_EVENT_DYNAMIC = 64,
	PERF_X86_EVENT_EXCL_ACCT = 256,
	PERF_X86_EVENT_AUTO_RELOAD = 512,
	PERF_X86_EVENT_LARGE_PEBS = 1024,
	PERF_X86_EVENT_PEBS_VIA_PT = 2048,
	PERF_X86_EVENT_PAIR = 4096,
	PERF_X86_EVENT_LBR_SELECT = 8192,
	PERF_X86_EVENT_TOPDOWN = 16384,
	PERF_X86_EVENT_PEBS_STLAT = 32768,
	PERF_X86_EVENT_AMD_BRS = 65536,
	PERF_X86_EVENT_PEBS_LAT_HYBRID = 131072,
	PERF_X86_EVENT_NEEDS_BRANCH_STACK = 262144,
	PERF_X86_EVENT_BRANCH_COUNTERS = 524288,
};

enum {
	PER_LINUX = 0,
	PER_LINUX_32BIT = 8388608,
	PER_LINUX_FDPIC = 524288,
	PER_SVR4 = 68157441,
	PER_SVR3 = 83886082,
	PER_SCOSVR3 = 117440515,
	PER_OSR5 = 100663299,
	PER_WYSEV386 = 83886084,
	PER_ISCR4 = 67108869,
	PER_BSD = 6,
	PER_SUNOS = 67108870,
	PER_XENIX = 83886087,
	PER_LINUX32 = 8,
	PER_LINUX32_3GB = 134217736,
	PER_IRIX32 = 67108873,
	PER_IRIXN32 = 67108874,
	PER_IRIX64 = 67108875,
	PER_RISCOS = 12,
	PER_SOLARIS = 67108877,
	PER_UW7 = 68157454,
	PER_OSF4 = 15,
	PER_HPUX = 16,
	PER_MASK = 255,
};

enum {
	PG_BUSY = 0,
	PG_MAPPED = 1,
	PG_FOLIO = 2,
	PG_CLEAN = 3,
	PG_COMMIT_TO_DS = 4,
	PG_INODE_REF = 5,
	PG_HEADLOCK = 6,
	PG_TEARDOWN = 7,
	PG_UNLOCKPAGE = 8,
	PG_UPTODATE = 9,
	PG_WB_END = 10,
	PG_REMOVE = 11,
	PG_CONTENDED1 = 12,
	PG_CONTENDED2 = 13,
};

enum {
	PIM_TYPE_HELLO = 0,
	PIM_TYPE_REGISTER = 1,
	PIM_TYPE_REGISTER_STOP = 2,
	PIM_TYPE_JOIN_PRUNE = 3,
	PIM_TYPE_BOOTSTRAP = 4,
	PIM_TYPE_ASSERT = 5,
	PIM_TYPE_GRAFT = 6,
	PIM_TYPE_GRAFT_ACK = 7,
	PIM_TYPE_CANDIDATE_RP_ADV = 8,
};

enum {
	PLAT8250_DEV_LEGACY = -1,
	PLAT8250_DEV_PLATFORM = 0,
	PLAT8250_DEV_PLATFORM1 = 1,
	PLAT8250_DEV_PLATFORM2 = 2,
	PLAT8250_DEV_FOURPORT = 3,
	PLAT8250_DEV_ACCENT = 4,
	PLAT8250_DEV_BOCA = 5,
	PLAT8250_DEV_EXAR_ST16C554 = 6,
	PLAT8250_DEV_HUB6 = 7,
	PLAT8250_DEV_AU1X00 = 8,
	PLAT8250_DEV_SM501 = 9,
};

enum {
	PNS_PIPE_CREATE_REQ = 0,
	PNS_PIPE_CREATE_RESP = 1,
	PNS_PIPE_REMOVE_REQ = 2,
	PNS_PIPE_REMOVE_RESP = 3,
	PNS_PIPE_DATA = 32,
	PNS_PIPE_ALIGNED_DATA = 33,
	PNS_PEP_CONNECT_REQ = 64,
	PNS_PEP_CONNECT_RESP = 65,
	PNS_PEP_DISCONNECT_REQ = 66,
	PNS_PEP_DISCONNECT_RESP = 67,
	PNS_PEP_RESET_REQ = 68,
	PNS_PEP_RESET_RESP = 69,
	PNS_PEP_ENABLE_REQ = 70,
	PNS_PEP_ENABLE_RESP = 71,
	PNS_PEP_CTRL_REQ = 72,
	PNS_PEP_CTRL_RESP = 73,
	PNS_PEP_DISABLE_REQ = 76,
	PNS_PEP_DISABLE_RESP = 77,
	PNS_PEP_STATUS_IND = 96,
	PNS_PIPE_CREATED_IND = 97,
	PNS_PIPE_RESET_IND = 99,
	PNS_PIPE_ENABLED_IND = 100,
	PNS_PIPE_REDIRECTED_IND = 101,
	PNS_PIPE_DISABLED_IND = 102,
};

enum {
	PN_NO_FLOW_CONTROL = 0,
	PN_LEGACY_FLOW_CONTROL = 1,
	PN_ONE_CREDIT_FLOW_CONTROL = 2,
	PN_MULTI_CREDIT_FLOW_CONTROL = 3,
	PN_MAX_FLOW_CONTROL = 4,
};

enum {
	PN_PEP_IND_FLOW_CONTROL = 0,
	PN_PEP_IND_ID_MCFC_GRANT_CREDITS = 1,
};

enum {
	PN_PIPE_DISABLE = 0,
	PN_PIPE_ENABLE = 1,
};

enum {
	PN_PIPE_NO_ERROR = 0,
	PN_PIPE_ERR_INVALID_PARAM = 1,
	PN_PIPE_ERR_INVALID_HANDLE = 2,
	PN_PIPE_ERR_INVALID_CTRL_ID = 3,
	PN_PIPE_ERR_NOT_ALLOWED = 4,
	PN_PIPE_ERR_PEP_IN_USE = 5,
	PN_PIPE_ERR_OVERLOAD = 6,
	PN_PIPE_ERR_DEV_DISCONNECTED = 7,
	PN_PIPE_ERR_TIMEOUT = 8,
	PN_PIPE_ERR_ALL_PIPES_IN_USE = 9,
	PN_PIPE_ERR_GENERAL = 10,
	PN_PIPE_ERR_NOT_SUPPORTED = 11,
};

enum {
	PN_PIPE_SB_CREATE_REQ_PEP_SUB_TYPE = 0,
	PN_PIPE_SB_CONNECT_REQ_PEP_SUB_TYPE = 1,
	PN_PIPE_SB_REDIRECT_REQ_PEP_SUB_TYPE = 2,
	PN_PIPE_SB_NEGOTIATED_FC = 3,
	PN_PIPE_SB_REQUIRED_FC_TX = 4,
	PN_PIPE_SB_PREFERRED_FC_RX = 5,
	PN_PIPE_SB_ALIGNED_DATA = 6,
};

enum {
	POOL_BITS = 256,
	POOL_READY_BITS = 256,
	POOL_EARLY_BITS = 128,
};

enum {
	POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0,
	POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL = 1,
	POWER_SUPPLY_CAPACITY_LEVEL_LOW = 2,
	POWER_SUPPLY_CAPACITY_LEVEL_NORMAL = 3,
	POWER_SUPPLY_CAPACITY_LEVEL_HIGH = 4,
	POWER_SUPPLY_CAPACITY_LEVEL_FULL = 5,
};

enum {
	POWER_SUPPLY_HEALTH_UNKNOWN = 0,
	POWER_SUPPLY_HEALTH_GOOD = 1,
	POWER_SUPPLY_HEALTH_OVERHEAT = 2,
	POWER_SUPPLY_HEALTH_DEAD = 3,
	POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4,
	POWER_SUPPLY_HEALTH_UNDERVOLTAGE = 5,
	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 6,
	POWER_SUPPLY_HEALTH_COLD = 7,
	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 8,
	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 9,
	POWER_SUPPLY_HEALTH_OVERCURRENT = 10,
	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED = 11,
	POWER_SUPPLY_HEALTH_WARM = 12,
	POWER_SUPPLY_HEALTH_COOL = 13,
	POWER_SUPPLY_HEALTH_HOT = 14,
	POWER_SUPPLY_HEALTH_NO_BATTERY = 15,
};

enum {
	POWER_SUPPLY_SCOPE_UNKNOWN = 0,
	POWER_SUPPLY_SCOPE_SYSTEM = 1,
	POWER_SUPPLY_SCOPE_DEVICE = 2,
};

enum {
	POWER_SUPPLY_STATUS_UNKNOWN = 0,
	POWER_SUPPLY_STATUS_CHARGING = 1,
	POWER_SUPPLY_STATUS_DISCHARGING = 2,
	POWER_SUPPLY_STATUS_NOT_CHARGING = 3,
	POWER_SUPPLY_STATUS_FULL = 4,
};

enum {
	POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0,
	POWER_SUPPLY_TECHNOLOGY_NiMH = 1,
	POWER_SUPPLY_TECHNOLOGY_LION = 2,
	POWER_SUPPLY_TECHNOLOGY_LIPO = 3,
	POWER_SUPPLY_TECHNOLOGY_LiFe = 4,
	POWER_SUPPLY_TECHNOLOGY_NiCd = 5,
	POWER_SUPPLY_TECHNOLOGY_LiMn = 6,
};

enum {
	PREFIX_UNSPEC = 0,
	PREFIX_ADDRESS = 1,
	PREFIX_CACHEINFO = 2,
	__PREFIX_MAX = 3,
};

enum {
	PROCMON_0_85V_DOT_0 = 0,
	PROCMON_0_95V_DOT_0 = 1,
	PROCMON_0_95V_DOT_1 = 2,
	PROCMON_1_05V_DOT_0 = 3,
	PROCMON_1_05V_DOT_1 = 4,
};

enum {
	PROC_ENTRY_PERMANENT = 1,
	PROC_ENTRY_proc_read_iter = 2,
	PROC_ENTRY_proc_compat_ioctl = 4,
};

enum {
	PROC_ROOT_INO = 1,
	PROC_IPC_INIT_INO = 4026531839,
	PROC_UTS_INIT_INO = 4026531838,
	PROC_USER_INIT_INO = 4026531837,
	PROC_PID_INIT_INO = 4026531836,
	PROC_CGROUP_INIT_INO = 4026531835,
	PROC_TIME_INIT_INO = 4026531834,
};

enum {
	PSAMPLE_ATTR_IIFINDEX = 0,
	PSAMPLE_ATTR_OIFINDEX = 1,
	PSAMPLE_ATTR_ORIGSIZE = 2,
	PSAMPLE_ATTR_SAMPLE_GROUP = 3,
	PSAMPLE_ATTR_GROUP_SEQ = 4,
	PSAMPLE_ATTR_SAMPLE_RATE = 5,
	PSAMPLE_ATTR_DATA = 6,
	PSAMPLE_ATTR_GROUP_REFCOUNT = 7,
	PSAMPLE_ATTR_TUNNEL = 8,
	PSAMPLE_ATTR_PAD = 9,
	PSAMPLE_ATTR_OUT_TC = 10,
	PSAMPLE_ATTR_OUT_TC_OCC = 11,
	PSAMPLE_ATTR_LATENCY = 12,
	PSAMPLE_ATTR_TIMESTAMP = 13,
	PSAMPLE_ATTR_PROTO = 14,
	PSAMPLE_ATTR_USER_COOKIE = 15,
	PSAMPLE_ATTR_SAMPLE_PROBABILITY = 16,
	__PSAMPLE_ATTR_MAX = 17,
};

enum {
	PSS = 0,
	PPC = 1,
};

enum {
	QIF_BLIMITS_B = 0,
	QIF_SPACE_B = 1,
	QIF_ILIMITS_B = 2,
	QIF_INODES_B = 3,
	QIF_BTIME_B = 4,
	QIF_ITIME_B = 5,
};

enum {
	QI_FREE = 0,
	QI_IN_USE = 1,
	QI_DONE = 2,
	QI_ABORT = 3,
};

enum {
	QOS_ENABLE = 0,
	QOS_CTRL = 1,
	NR_QOS_CTRL_PARAMS = 2,
};

enum {
	QOS_RPPM = 0,
	QOS_RLAT = 1,
	QOS_WPPM = 2,
	QOS_WLAT = 3,
	QOS_MIN = 4,
	QOS_MAX = 5,
	NR_QOS_PARAMS = 6,
};

enum {
	QUEUE_FLAG_DYING = 0,
	QUEUE_FLAG_NOMERGES = 1,
	QUEUE_FLAG_SAME_COMP = 2,
	QUEUE_FLAG_FAIL_IO = 3,
	QUEUE_FLAG_NOXMERGES = 4,
	QUEUE_FLAG_SAME_FORCE = 5,
	QUEUE_FLAG_INIT_DONE = 6,
	QUEUE_FLAG_STATS = 7,
	QUEUE_FLAG_REGISTERED = 8,
	QUEUE_FLAG_QUIESCED = 9,
	QUEUE_FLAG_RQ_ALLOC_TIME = 10,
	QUEUE_FLAG_HCTX_ACTIVE = 11,
	QUEUE_FLAG_SQ_SCHED = 12,
	QUEUE_FLAG_MAX = 13,
};

enum {
	QUOTA_NL_A_UNSPEC = 0,
	QUOTA_NL_A_QTYPE = 1,
	QUOTA_NL_A_EXCESS_ID = 2,
	QUOTA_NL_A_WARNING = 3,
	QUOTA_NL_A_DEV_MAJOR = 4,
	QUOTA_NL_A_DEV_MINOR = 5,
	QUOTA_NL_A_CAUSED_ID = 6,
	QUOTA_NL_A_PAD = 7,
	__QUOTA_NL_A_MAX = 8,
};

enum {
	QUOTA_NL_C_UNSPEC = 0,
	QUOTA_NL_C_WARNING = 1,
	__QUOTA_NL_C_MAX = 2,
};

enum {
	Q_REQUEUE_PI_NONE = 0,
	Q_REQUEUE_PI_IGNORE = 1,
	Q_REQUEUE_PI_IN_PROGRESS = 2,
	Q_REQUEUE_PI_WAIT = 3,
	Q_REQUEUE_PI_DONE = 4,
	Q_REQUEUE_PI_LOCKED = 5,
};

enum {
	RADIX_TREE_ITER_TAG_MASK = 15,
	RADIX_TREE_ITER_TAGGED = 16,
	RADIX_TREE_ITER_CONTIG = 32,
};

enum {
	RANGE_BOUNDARY_WRITTEN_EXTENT = 0,
	RANGE_BOUNDARY_PREALLOC_EXTENT = 1,
	RANGE_BOUNDARY_HOLE = 2,
};

enum {
	RB_ADD_STAMP_NONE = 0,
	RB_ADD_STAMP_EXTEND = 2,
	RB_ADD_STAMP_ABSOLUTE = 4,
	RB_ADD_STAMP_FORCE = 8,
};

enum {
	RB_CTX_TRANSITION = 0,
	RB_CTX_NMI = 1,
	RB_CTX_IRQ = 2,
	RB_CTX_SOFTIRQ = 3,
	RB_CTX_NORMAL = 4,
	RB_CTX_MAX = 5,
};

enum {
	RB_LEN_TIME_EXTEND = 8,
	RB_LEN_TIME_STAMP = 8,
};

enum {
	RDS_CONN_DOWN = 0,
	RDS_CONN_CONNECTING = 1,
	RDS_CONN_DISCONNECTING = 2,
	RDS_CONN_UP = 3,
	RDS_CONN_RESETTING = 4,
	RDS_CONN_ERROR = 5,
};

enum {
	READA_NONE = 0,
	READA_BACK = 1,
	READA_FORWARD = 2,
	READA_FORWARD_ALWAYS = 3,
};

enum {
	REASON_BOUNDS = -1,
	REASON_TYPE = -2,
	REASON_PATHS = -3,
	REASON_LIMIT = -4,
	REASON_STACK = -5,
};

enum {
	RED_BELOW_MIN_THRESH = 0,
	RED_BETWEEN_TRESH = 1,
	RED_ABOVE_MAX_TRESH = 2,
};

enum {
	RED_DONT_MARK = 0,
	RED_PROB_MARK = 1,
	RED_HARD_MARK = 2,
};

enum {
	REGION_INTERSECTS = 0,
	REGION_DISJOINT = 1,
	REGION_MIXED = 2,
};

enum {
	REMOVE_WAIT_SHORTTERM = 1,
};

enum {
	REQ_FSEQ_PREFLUSH = 1,
	REQ_FSEQ_DATA = 2,
	REQ_FSEQ_POSTFLUSH = 4,
	REQ_FSEQ_DONE = 8,
	REQ_FSEQ_ACTIONS = 7,
	FLUSH_PENDING_TIMEOUT = 5000,
};

enum {
	REQ_F_FIXED_FILE = 1ULL,
	REQ_F_IO_DRAIN = 2ULL,
	REQ_F_LINK = 4ULL,
	REQ_F_HARDLINK = 8ULL,
	REQ_F_FORCE_ASYNC = 16ULL,
	REQ_F_BUFFER_SELECT = 32ULL,
	REQ_F_CQE_SKIP = 64ULL,
	REQ_F_FAIL = 256ULL,
	REQ_F_INFLIGHT = 512ULL,
	REQ_F_CUR_POS = 1024ULL,
	REQ_F_NOWAIT = 2048ULL,
	REQ_F_LINK_TIMEOUT = 4096ULL,
	REQ_F_NEED_CLEANUP = 8192ULL,
	REQ_F_POLLED = 16384ULL,
	REQ_F_IOPOLL_STATE = 32768ULL,
	REQ_F_BUFFER_SELECTED = 65536ULL,
	REQ_F_BUFFER_RING = 131072ULL,
	REQ_F_REISSUE = 262144ULL,
	REQ_F_SUPPORT_NOWAIT = 536870912ULL,
	REQ_F_ISREG = 1073741824ULL,
	REQ_F_CREDS = 524288ULL,
	REQ_F_REFCOUNT = 1048576ULL,
	REQ_F_ARM_LTIMEOUT = 2097152ULL,
	REQ_F_ASYNC_DATA = 4194304ULL,
	REQ_F_SKIP_LINK_CQES = 8388608ULL,
	REQ_F_SINGLE_POLL = 16777216ULL,
	REQ_F_DOUBLE_POLL = 33554432ULL,
	REQ_F_MULTISHOT = 67108864ULL,
	REQ_F_APOLL_MULTISHOT = 134217728ULL,
	REQ_F_CLEAR_POLLIN = 268435456ULL,
	REQ_F_POLL_NO_LAZY = 2147483648ULL,
	REQ_F_CAN_POLL = 4294967296ULL,
	REQ_F_BL_EMPTY = 8589934592ULL,
	REQ_F_BL_NO_RECYCLE = 17179869184ULL,
	REQ_F_BUFFERS_COMMIT = 34359738368ULL,
	REQ_F_BUF_NODE = 68719476736ULL,
	REQ_F_HAS_METADATA = 137438953472ULL,
};

enum {
	REQ_F_FIXED_FILE_BIT = 0,
	REQ_F_IO_DRAIN_BIT = 1,
	REQ_F_LINK_BIT = 2,
	REQ_F_HARDLINK_BIT = 3,
	REQ_F_FORCE_ASYNC_BIT = 4,
	REQ_F_BUFFER_SELECT_BIT = 5,
	REQ_F_CQE_SKIP_BIT = 6,
	REQ_F_FAIL_BIT = 8,
	REQ_F_INFLIGHT_BIT = 9,
	REQ_F_CUR_POS_BIT = 10,
	REQ_F_NOWAIT_BIT = 11,
	REQ_F_LINK_TIMEOUT_BIT = 12,
	REQ_F_NEED_CLEANUP_BIT = 13,
	REQ_F_POLLED_BIT = 14,
	REQ_F_HYBRID_IOPOLL_STATE_BIT = 15,
	REQ_F_BUFFER_SELECTED_BIT = 16,
	REQ_F_BUFFER_RING_BIT = 17,
	REQ_F_REISSUE_BIT = 18,
	REQ_F_CREDS_BIT = 19,
	REQ_F_REFCOUNT_BIT = 20,
	REQ_F_ARM_LTIMEOUT_BIT = 21,
	REQ_F_ASYNC_DATA_BIT = 22,
	REQ_F_SKIP_LINK_CQES_BIT = 23,
	REQ_F_SINGLE_POLL_BIT = 24,
	REQ_F_DOUBLE_POLL_BIT = 25,
	REQ_F_MULTISHOT_BIT = 26,
	REQ_F_APOLL_MULTISHOT_BIT = 27,
	REQ_F_CLEAR_POLLIN_BIT = 28,
	REQ_F_SUPPORT_NOWAIT_BIT = 29,
	REQ_F_ISREG_BIT = 30,
	REQ_F_POLL_NO_LAZY_BIT = 31,
	REQ_F_CAN_POLL_BIT = 32,
	REQ_F_BL_EMPTY_BIT = 33,
	REQ_F_BL_NO_RECYCLE_BIT = 34,
	REQ_F_BUFFERS_COMMIT_BIT = 35,
	REQ_F_BUF_NODE_BIT = 36,
	REQ_F_HAS_METADATA_BIT = 37,
	__REQ_F_LAST_BIT = 38,
};

enum {
	RES_USAGE = 0,
	RES_RSVD_USAGE = 1,
	RES_LIMIT = 2,
	RES_RSVD_LIMIT = 3,
	RES_MAX_USAGE = 4,
	RES_RSVD_MAX_USAGE = 5,
	RES_FAILCNT = 6,
	RES_RSVD_FAILCNT = 7,
};

enum {
	RPCAUTH_info = 0,
	RPCAUTH_EOF = 1,
};

enum {
	RPCAUTH_lockd = 0,
	RPCAUTH_mount = 1,
	RPCAUTH_nfs = 2,
	RPCAUTH_portmap = 3,
	RPCAUTH_statd = 4,
	RPCAUTH_nfsd4_cb = 5,
	RPCAUTH_cache = 6,
	RPCAUTH_nfsd = 7,
	RPCAUTH_gssd = 8,
	RPCAUTH_RootEOF = 9,
};

enum {
	RPCBPROC_NULL = 0,
	RPCBPROC_SET = 1,
	RPCBPROC_UNSET = 2,
	RPCBPROC_GETPORT = 3,
	RPCBPROC_GETADDR = 3,
	RPCBPROC_DUMP = 4,
	RPCBPROC_CALLIT = 5,
	RPCBPROC_BCAST = 5,
	RPCBPROC_GETTIME = 6,
	RPCBPROC_UADDR2TADDR = 7,
	RPCBPROC_TADDR2UADDR = 8,
	RPCBPROC_GETVERSADDR = 9,
	RPCBPROC_INDIRECT = 10,
	RPCBPROC_GETADDRLIST = 11,
	RPCBPROC_GETSTAT = 12,
};

enum {
	RPC_PIPEFS_MOUNT = 0,
	RPC_PIPEFS_UMOUNT = 1,
};

enum {
	RPC_TASK_RUNNING = 0,
	RPC_TASK_QUEUED = 1,
	RPC_TASK_ACTIVE = 2,
	RPC_TASK_NEED_XMIT = 3,
	RPC_TASK_NEED_RECV = 4,
	RPC_TASK_MSG_PIN_WAIT = 5,
};

enum {
	RPL_IPTUNNEL_UNSPEC = 0,
	RPL_IPTUNNEL_SRH = 1,
	__RPL_IPTUNNEL_MAX = 2,
};

enum {
	RQ_SECURE = 0,
	RQ_LOCAL = 1,
	RQ_USEDEFERRAL = 2,
	RQ_DROPME = 3,
	RQ_VICTIM = 4,
	RQ_DATA = 5,
};

enum {
	RQ_WAIT_BUSY_PCT = 5,
	UNBUSY_THR_PCT = 75,
	MIN_DELAY_THR_PCT = 500,
	MAX_DELAY_THR_PCT = 25000,
	MIN_DELAY = 250,
	MAX_DELAY = 250000,
	DFGV_USAGE_PCT = 50,
	DFGV_PERIOD = 100000,
	MAX_LAGGING_PERIODS = 10,
	IOC_PAGE_SHIFT = 12,
	IOC_PAGE_SIZE = 4096,
	IOC_SECT_TO_PAGE_SHIFT = 3,
	LCOEF_RANDIO_PAGES = 4096,
};

enum {
	RTAX_UNSPEC = 0,
	RTAX_LOCK = 1,
	RTAX_MTU = 2,
	RTAX_WINDOW = 3,
	RTAX_RTT = 4,
	RTAX_RTTVAR = 5,
	RTAX_SSTHRESH = 6,
	RTAX_CWND = 7,
	RTAX_ADVMSS = 8,
	RTAX_REORDERING = 9,
	RTAX_HOPLIMIT = 10,
	RTAX_INITCWND = 11,
	RTAX_FEATURES = 12,
	RTAX_RTO_MIN = 13,
	RTAX_INITRWND = 14,
	RTAX_QUICKACK = 15,
	RTAX_CC_ALGO = 16,
	RTAX_FASTOPEN_NO_COOKIE = 17,
	__RTAX_MAX = 18,
};

enum {
	RTM_BASE = 16,
	RTM_NEWLINK = 16,
	RTM_DELLINK = 17,
	RTM_GETLINK = 18,
	RTM_SETLINK = 19,
	RTM_NEWADDR = 20,
	RTM_DELADDR = 21,
	RTM_GETADDR = 22,
	RTM_NEWROUTE = 24,
	RTM_DELROUTE = 25,
	RTM_GETROUTE = 26,
	RTM_NEWNEIGH = 28,
	RTM_DELNEIGH = 29,
	RTM_GETNEIGH = 30,
	RTM_NEWRULE = 32,
	RTM_DELRULE = 33,
	RTM_GETRULE = 34,
	RTM_NEWQDISC = 36,
	RTM_DELQDISC = 37,
	RTM_GETQDISC = 38,
	RTM_NEWTCLASS = 40,
	RTM_DELTCLASS = 41,
	RTM_GETTCLASS = 42,
	RTM_NEWTFILTER = 44,
	RTM_DELTFILTER = 45,
	RTM_GETTFILTER = 46,
	RTM_NEWACTION = 48,
	RTM_DELACTION = 49,
	RTM_GETACTION = 50,
	RTM_NEWPREFIX = 52,
	RTM_NEWMULTICAST = 56,
	RTM_DELMULTICAST = 57,
	RTM_GETMULTICAST = 58,
	RTM_NEWANYCAST = 60,
	RTM_DELANYCAST = 61,
	RTM_GETANYCAST = 62,
	RTM_NEWNEIGHTBL = 64,
	RTM_GETNEIGHTBL = 66,
	RTM_SETNEIGHTBL = 67,
	RTM_NEWNDUSEROPT = 68,
	RTM_NEWADDRLABEL = 72,
	RTM_DELADDRLABEL = 73,
	RTM_GETADDRLABEL = 74,
	RTM_GETDCB = 78,
	RTM_SETDCB = 79,
	RTM_NEWNETCONF = 80,
	RTM_DELNETCONF = 81,
	RTM_GETNETCONF = 82,
	RTM_NEWMDB = 84,
	RTM_DELMDB = 85,
	RTM_GETMDB = 86,
	RTM_NEWNSID = 88,
	RTM_DELNSID = 89,
	RTM_GETNSID = 90,
	RTM_NEWSTATS = 92,
	RTM_GETSTATS = 94,
	RTM_SETSTATS = 95,
	RTM_NEWCACHEREPORT = 96,
	RTM_NEWCHAIN = 100,
	RTM_DELCHAIN = 101,
	RTM_GETCHAIN = 102,
	RTM_NEWNEXTHOP = 104,
	RTM_DELNEXTHOP = 105,
	RTM_GETNEXTHOP = 106,
	RTM_NEWLINKPROP = 108,
	RTM_DELLINKPROP = 109,
	RTM_GETLINKPROP = 110,
	RTM_NEWVLAN = 112,
	RTM_DELVLAN = 113,
	RTM_GETVLAN = 114,
	RTM_NEWNEXTHOPBUCKET = 116,
	RTM_DELNEXTHOPBUCKET = 117,
	RTM_GETNEXTHOPBUCKET = 118,
	RTM_NEWTUNNEL = 120,
	RTM_DELTUNNEL = 121,
	RTM_GETTUNNEL = 122,
	__RTM_MAX = 123,
};

enum {
	RTN_UNSPEC = 0,
	RTN_UNICAST = 1,
	RTN_LOCAL = 2,
	RTN_BROADCAST = 3,
	RTN_ANYCAST = 4,
	RTN_MULTICAST = 5,
	RTN_BLACKHOLE = 6,
	RTN_UNREACHABLE = 7,
	RTN_PROHIBIT = 8,
	RTN_THROW = 9,
	RTN_NAT = 10,
	RTN_XRESOLVE = 11,
	__RTN_MAX = 12,
};

enum {
	Root_NFS = 255,
	Root_CIFS = 254,
	Root_Generic = 253,
	Root_RAM0 = 1048576,
};

enum {
	Rworksched = 1,
	Rpending = 2,
	Wworksched = 4,
	Wpending = 8,
};

enum {
	SAMPLES = 8,
	MIN_CHANGE = 5,
};

enum {
	SB_UNFROZEN = 0,
	SB_FREEZE_WRITE = 1,
	SB_FREEZE_PAGEFAULT = 2,
	SB_FREEZE_FS = 3,
	SB_FREEZE_COMPLETE = 4,
};

enum {
	SCM_TSTAMP_SND = 0,
	SCM_TSTAMP_SCHED = 1,
	SCM_TSTAMP_ACK = 2,
};

enum {
	SCTP_ADDR_NEW = 0,
	SCTP_ADDR_SRC = 1,
	SCTP_ADDR_DEL = 2,
};

enum {
	SCTP_ARBITRARY_COOKIE_ECHO_LEN = 200,
};

enum {
	SCTP_AUTH_HMAC_ID_RESERVED_0 = 0,
	SCTP_AUTH_HMAC_ID_SHA1 = 1,
	SCTP_AUTH_HMAC_ID_RESERVED_2 = 2,
	SCTP_AUTH_HMAC_ID_SHA256 = 3,
	__SCTP_AUTH_HMAC_MAX = 4,
};

enum {
	SCTP_AUTH_NEW_KEY = 0,
	SCTP_AUTH_FREE_KEY = 1,
	SCTP_AUTH_NO_AUTH = 2,
};

enum {
	SCTP_CHUNK_FLAG_T = 1,
};

enum {
	SCTP_CID_ACTION_DISCARD = 0,
	SCTP_CID_ACTION_DISCARD_ERR = 64,
	SCTP_CID_ACTION_SKIP = 128,
	SCTP_CID_ACTION_SKIP_ERR = 192,
};

enum {
	SCTP_CID_ACTION_MASK = 192,
};

enum {
	SCTP_DATA_FRAG_MASK = 3,
};

enum {
	SCTP_DATA_MIDDLE_FRAG = 0,
	SCTP_DATA_LAST_FRAG = 1,
	SCTP_DATA_FIRST_FRAG = 2,
	SCTP_DATA_NOT_FRAG = 3,
	SCTP_DATA_UNORDERED = 4,
	SCTP_DATA_SACK_IMM = 8,
};

enum {
	SCTP_DEFAULT_INSTREAMS = 65535,
};

enum {
	SCTP_DEFAULT_OUTSTREAMS = 10,
};

enum {
	SCTP_DSCP_SET_MASK = 1,
	SCTP_DSCP_VAL_MASK = 252,
	SCTP_FLOWLABEL_SET_MASK = 1048576,
	SCTP_FLOWLABEL_VAL_MASK = 1048575,
};

enum {
	SCTP_MAX_CHUNK_LEN = 65532,
};

enum {
	SCTP_MAX_DUP_TSNS = 16,
};

enum {
	SCTP_MAX_GABS = 16,
};

enum {
	SCTP_MAX_STREAM = 65535,
};

enum {
	SCTP_MIB_NUM = 0,
	SCTP_MIB_CURRESTAB = 1,
	SCTP_MIB_ACTIVEESTABS = 2,
	SCTP_MIB_PASSIVEESTABS = 3,
	SCTP_MIB_ABORTEDS = 4,
	SCTP_MIB_SHUTDOWNS = 5,
	SCTP_MIB_OUTOFBLUES = 6,
	SCTP_MIB_CHECKSUMERRORS = 7,
	SCTP_MIB_OUTCTRLCHUNKS = 8,
	SCTP_MIB_OUTORDERCHUNKS = 9,
	SCTP_MIB_OUTUNORDERCHUNKS = 10,
	SCTP_MIB_INCTRLCHUNKS = 11,
	SCTP_MIB_INORDERCHUNKS = 12,
	SCTP_MIB_INUNORDERCHUNKS = 13,
	SCTP_MIB_FRAGUSRMSGS = 14,
	SCTP_MIB_REASMUSRMSGS = 15,
	SCTP_MIB_OUTSCTPPACKS = 16,
	SCTP_MIB_INSCTPPACKS = 17,
	SCTP_MIB_T1_INIT_EXPIREDS = 18,
	SCTP_MIB_T1_COOKIE_EXPIREDS = 19,
	SCTP_MIB_T2_SHUTDOWN_EXPIREDS = 20,
	SCTP_MIB_T3_RTX_EXPIREDS = 21,
	SCTP_MIB_T4_RTO_EXPIREDS = 22,
	SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS = 23,
	SCTP_MIB_DELAY_SACK_EXPIREDS = 24,
	SCTP_MIB_AUTOCLOSE_EXPIREDS = 25,
	SCTP_MIB_T1_RETRANSMITS = 26,
	SCTP_MIB_T3_RETRANSMITS = 27,
	SCTP_MIB_PMTUD_RETRANSMITS = 28,
	SCTP_MIB_FAST_RETRANSMITS = 29,
	SCTP_MIB_IN_PKT_SOFTIRQ = 30,
	SCTP_MIB_IN_PKT_BACKLOG = 31,
	SCTP_MIB_IN_PKT_DISCARDS = 32,
	SCTP_MIB_IN_DATA_CHUNK_DISCARDS = 33,
	__SCTP_MIB_MAX = 34,
};

enum {
	SCTP_PARAM_ACTION_DISCARD = 0,
	SCTP_PARAM_ACTION_DISCARD_ERR = 64,
	SCTP_PARAM_ACTION_SKIP = 128,
	SCTP_PARAM_ACTION_SKIP_ERR = 192,
};

enum {
	SCTP_PARAM_ACTION_MASK = 192,
};

enum {
	SCTP_PARTIAL_DELIVERY_ABORTED = 0,
};

enum {
	SCTP_PF_EXPOSE_UNSET = 0,
	SCTP_PF_EXPOSE_DISABLE = 1,
	SCTP_PF_EXPOSE_ENABLE = 2,
};

enum {
	SCTP_SCOPE_POLICY_DISABLE = 0,
	SCTP_SCOPE_POLICY_ENABLE = 1,
	SCTP_SCOPE_POLICY_PRIVATE = 2,
	SCTP_SCOPE_POLICY_LINK = 3,
};

enum {
	SCTP_STRRESET_NOTHING_TO_DO = 0,
	SCTP_STRRESET_PERFORMED = 1,
	SCTP_STRRESET_DENIED = 2,
	SCTP_STRRESET_ERR_WRONG_SSN = 3,
	SCTP_STRRESET_ERR_IN_PROGRESS = 4,
	SCTP_STRRESET_ERR_BAD_SEQNO = 5,
	SCTP_STRRESET_IN_PROGRESS = 6,
};

enum {
	SD_BALANCE_NEWIDLE = 1,
	SD_BALANCE_EXEC = 2,
	SD_BALANCE_FORK = 4,
	SD_BALANCE_WAKE = 8,
	SD_WAKE_AFFINE = 16,
	SD_ASYM_CPUCAPACITY = 32,
	SD_ASYM_CPUCAPACITY_FULL = 64,
	SD_SHARE_CPUCAPACITY = 128,
	SD_CLUSTER = 256,
	SD_SHARE_LLC = 512,
	SD_SERIALIZE = 1024,
	SD_ASYM_PACKING = 2048,
	SD_PREFER_SIBLING = 4096,
	SD_OVERLAP = 8192,
	SD_NUMA = 16384,
};

enum {
	SD_DEF_XFER_BLOCKS = 65535,
	SD_MAX_XFER_BLOCKS = 4294967295,
	SD_MAX_WS10_BLOCKS = 65535,
	SD_MAX_WS16_BLOCKS = 8388607,
};

enum {
	SD_EXT_CDB_SIZE = 32,
	SD_MEMPOOL_SIZE = 2,
};

enum {
	SD_LBP_FULL = 0,
	SD_LBP_UNMAP = 1,
	SD_LBP_WS16 = 2,
	SD_LBP_WS10 = 3,
	SD_LBP_ZERO = 4,
	SD_LBP_DISABLE = 5,
};

enum {
	SD_ZERO_WRITE = 0,
	SD_ZERO_WS = 1,
	SD_ZERO_WS16_UNMAP = 2,
	SD_ZERO_WS10_UNMAP = 3,
};

enum {
	SECTION_MARKED_PRESENT_BIT = 0,
	SECTION_HAS_MEM_MAP_BIT = 1,
	SECTION_IS_ONLINE_BIT = 2,
	SECTION_IS_EARLY_BIT = 3,
	SECTION_MAP_LAST_BIT = 4,
};

enum {
	SEG6_ATTR_UNSPEC = 0,
	SEG6_ATTR_DST = 1,
	SEG6_ATTR_DSTLEN = 2,
	SEG6_ATTR_HMACKEYID = 3,
	SEG6_ATTR_SECRET = 4,
	SEG6_ATTR_SECRETLEN = 5,
	SEG6_ATTR_ALGID = 6,
	SEG6_ATTR_HMACINFO = 7,
	__SEG6_ATTR_MAX = 8,
};

enum {
	SEG6_CMD_UNSPEC = 0,
	SEG6_CMD_SETHMAC = 1,
	SEG6_CMD_DUMPHMAC = 2,
	SEG6_CMD_SET_TUNSRC = 3,
	SEG6_CMD_GET_TUNSRC = 4,
	__SEG6_CMD_MAX = 5,
};

enum {
	SEG6_HMAC_ALGO_SHA1 = 1,
	SEG6_HMAC_ALGO_SHA256 = 2,
};

enum {
	SEG6_IPTUNNEL_UNSPEC = 0,
	SEG6_IPTUNNEL_SRH = 1,
	__SEG6_IPTUNNEL_MAX = 2,
};

enum {
	SEG6_IPTUN_MODE_INLINE = 0,
	SEG6_IPTUN_MODE_ENCAP = 1,
	SEG6_IPTUN_MODE_L2ENCAP = 2,
	SEG6_IPTUN_MODE_ENCAP_RED = 3,
	SEG6_IPTUN_MODE_L2ENCAP_RED = 4,
};

enum {
	SEG6_LOCAL_ACTION_UNSPEC = 0,
	SEG6_LOCAL_ACTION_END = 1,
	SEG6_LOCAL_ACTION_END_X = 2,
	SEG6_LOCAL_ACTION_END_T = 3,
	SEG6_LOCAL_ACTION_END_DX2 = 4,
	SEG6_LOCAL_ACTION_END_DX6 = 5,
	SEG6_LOCAL_ACTION_END_DX4 = 6,
	SEG6_LOCAL_ACTION_END_DT6 = 7,
	SEG6_LOCAL_ACTION_END_DT4 = 8,
	SEG6_LOCAL_ACTION_END_B6 = 9,
	SEG6_LOCAL_ACTION_END_B6_ENCAP = 10,
	SEG6_LOCAL_ACTION_END_BM = 11,
	SEG6_LOCAL_ACTION_END_S = 12,
	SEG6_LOCAL_ACTION_END_AS = 13,
	SEG6_LOCAL_ACTION_END_AM = 14,
	SEG6_LOCAL_ACTION_END_BPF = 15,
	SEG6_LOCAL_ACTION_END_DT46 = 16,
	__SEG6_LOCAL_ACTION_MAX = 17,
};

enum {
	SEG6_LOCAL_BPF_PROG_UNSPEC = 0,
	SEG6_LOCAL_BPF_PROG = 1,
	SEG6_LOCAL_BPF_PROG_NAME = 2,
	__SEG6_LOCAL_BPF_PROG_MAX = 3,
};

enum {
	SEG6_LOCAL_CNT_UNSPEC = 0,
	SEG6_LOCAL_CNT_PAD = 1,
	SEG6_LOCAL_CNT_PACKETS = 2,
	SEG6_LOCAL_CNT_BYTES = 3,
	SEG6_LOCAL_CNT_ERRORS = 4,
	__SEG6_LOCAL_CNT_MAX = 5,
};

enum {
	SEG6_LOCAL_FLV_OP_UNSPEC = 0,
	SEG6_LOCAL_FLV_OP_PSP = 1,
	SEG6_LOCAL_FLV_OP_USP = 2,
	SEG6_LOCAL_FLV_OP_USD = 3,
	SEG6_LOCAL_FLV_OP_NEXT_CSID = 4,
	__SEG6_LOCAL_FLV_OP_MAX = 5,
};

enum {
	SEG6_LOCAL_FLV_UNSPEC = 0,
	SEG6_LOCAL_FLV_OPERATION = 1,
	SEG6_LOCAL_FLV_LCBLOCK_BITS = 2,
	SEG6_LOCAL_FLV_LCNODE_FN_BITS = 3,
	__SEG6_LOCAL_FLV_MAX = 4,
};

enum {
	SEG6_LOCAL_UNSPEC = 0,
	SEG6_LOCAL_ACTION = 1,
	SEG6_LOCAL_SRH = 2,
	SEG6_LOCAL_TABLE = 3,
	SEG6_LOCAL_NH4 = 4,
	SEG6_LOCAL_NH6 = 5,
	SEG6_LOCAL_IIF = 6,
	SEG6_LOCAL_OIF = 7,
	SEG6_LOCAL_BPF = 8,
	SEG6_LOCAL_VRFTABLE = 9,
	SEG6_LOCAL_COUNTERS = 10,
	SEG6_LOCAL_FLAVORS = 11,
	__SEG6_LOCAL_MAX = 12,
};

enum {
	SELF_DOWN_PEER_DOWN = 221,
	SELF_UP_PEER_UP = 170,
	SELF_DOWN_PEER_LEAVING = 209,
	SELF_UP_PEER_COMING = 172,
	SELF_COMING_PEER_UP = 202,
	SELF_LEAVING_PEER_DOWN = 29,
	NODE_FAILINGOVER = 240,
	NODE_SYNCHING = 204,
};

enum {
	SELF_ESTABL_CONTACT_EVT = 3790,
	SELF_LOST_CONTACT_EVT = 462,
	PEER_ESTABL_CONTACT_EVT = 40654,
	PEER_LOST_CONTACT_EVT = 37326,
	NODE_FAILOVER_BEGIN_EVT = 4030,
	NODE_FAILOVER_END_EVT = 4078,
	NODE_SYNCH_BEGIN_EVT = 3262,
	NODE_SYNCH_END_EVT = 3310,
};

enum {
	SFF8024_ID_UNK = 0,
	SFF8024_ID_SFF_8472 = 2,
	SFF8024_ID_SFP = 3,
	SFF8024_ID_DWDM_SFP = 11,
	SFF8024_ID_QSFP_8438 = 12,
	SFF8024_ID_QSFP_8436_8636 = 13,
	SFF8024_ID_QSFP28_8636 = 17,
	SFF8024_ID_QSFP_DD = 24,
	SFF8024_ID_OSFP = 25,
	SFF8024_ID_DSFP = 27,
	SFF8024_ID_QSFP_PLUS_CMIS = 30,
	SFF8024_ID_SFP_DD_CMIS = 31,
	SFF8024_ID_SFP_PLUS_CMIS = 32,
	SFF8024_ENCODING_UNSPEC = 0,
	SFF8024_ENCODING_8B10B = 1,
	SFF8024_ENCODING_4B5B = 2,
	SFF8024_ENCODING_NRZ = 3,
	SFF8024_ENCODING_8472_MANCHESTER = 4,
	SFF8024_ENCODING_8472_SONET = 5,
	SFF8024_ENCODING_8472_64B66B = 6,
	SFF8024_ENCODING_8436_MANCHESTER = 6,
	SFF8024_ENCODING_8436_SONET = 4,
	SFF8024_ENCODING_8436_64B66B = 5,
	SFF8024_ENCODING_256B257B = 7,
	SFF8024_ENCODING_PAM4 = 8,
	SFF8024_CONNECTOR_UNSPEC = 0,
	SFF8024_CONNECTOR_SC = 1,
	SFF8024_CONNECTOR_FIBERJACK = 6,
	SFF8024_CONNECTOR_LC = 7,
	SFF8024_CONNECTOR_MT_RJ = 8,
	SFF8024_CONNECTOR_MU = 9,
	SFF8024_CONNECTOR_SG = 10,
	SFF8024_CONNECTOR_OPTICAL_PIGTAIL = 11,
	SFF8024_CONNECTOR_MPO_1X12 = 12,
	SFF8024_CONNECTOR_MPO_2X16 = 13,
	SFF8024_CONNECTOR_HSSDC_II = 32,
	SFF8024_CONNECTOR_COPPER_PIGTAIL = 33,
	SFF8024_CONNECTOR_RJ45 = 34,
	SFF8024_CONNECTOR_NOSEPARATE = 35,
	SFF8024_CONNECTOR_MXC_2X16 = 36,
	SFF8024_ECC_UNSPEC = 0,
	SFF8024_ECC_100G_25GAUI_C2M_AOC = 1,
	SFF8024_ECC_100GBASE_SR4_25GBASE_SR = 2,
	SFF8024_ECC_100GBASE_LR4_25GBASE_LR = 3,
	SFF8024_ECC_100GBASE_ER4_25GBASE_ER = 4,
	SFF8024_ECC_100GBASE_SR10 = 5,
	SFF8024_ECC_100GBASE_CR4 = 11,
	SFF8024_ECC_25GBASE_CR_S = 12,
	SFF8024_ECC_25GBASE_CR_N = 13,
	SFF8024_ECC_10GBASE_T_SFI = 22,
	SFF8024_ECC_10GBASE_T_SR = 28,
	SFF8024_ECC_5GBASE_T = 29,
	SFF8024_ECC_2_5GBASE_T = 30,
};

enum {
	SFP_PHYS_ID = 0,
	SFP_PHYS_EXT_ID = 1,
	SFP_PHYS_EXT_ID_SFP = 4,
	SFP_CONNECTOR = 2,
	SFP_COMPLIANCE = 3,
	SFP_ENCODING = 11,
	SFP_BR_NOMINAL = 12,
	SFP_RATE_ID = 13,
	SFF_RID_8079 = 1,
	SFF_RID_8431_RX_ONLY = 2,
	SFF_RID_8431_TX_ONLY = 4,
	SFF_RID_8431 = 6,
	SFF_RID_10G8G = 14,
	SFP_LINK_LEN_SM_KM = 14,
	SFP_LINK_LEN_SM_100M = 15,
	SFP_LINK_LEN_50UM_OM2_10M = 16,
	SFP_LINK_LEN_62_5UM_OM1_10M = 17,
	SFP_LINK_LEN_COPPER_1M = 18,
	SFP_LINK_LEN_50UM_OM4_10M = 18,
	SFP_LINK_LEN_50UM_OM3_10M = 19,
	SFP_VENDOR_NAME = 20,
	SFP_VENDOR_OUI = 37,
	SFP_VENDOR_PN = 40,
	SFP_VENDOR_REV = 56,
	SFP_OPTICAL_WAVELENGTH_MSB = 60,
	SFP_OPTICAL_WAVELENGTH_LSB = 61,
	SFP_CABLE_SPEC = 60,
	SFP_CC_BASE = 63,
	SFP_OPTIONS = 64,
	SFP_OPTIONS_HIGH_POWER_LEVEL = 8192,
	SFP_OPTIONS_PAGING_A2 = 4096,
	SFP_OPTIONS_RETIMER = 2048,
	SFP_OPTIONS_COOLED_XCVR = 1024,
	SFP_OPTIONS_POWER_DECL = 512,
	SFP_OPTIONS_RX_LINEAR_OUT = 256,
	SFP_OPTIONS_RX_DECISION_THRESH = 128,
	SFP_OPTIONS_TUNABLE_TX = 64,
	SFP_OPTIONS_RATE_SELECT = 32,
	SFP_OPTIONS_TX_DISABLE = 16,
	SFP_OPTIONS_TX_FAULT = 8,
	SFP_OPTIONS_LOS_INVERTED = 4,
	SFP_OPTIONS_LOS_NORMAL = 2,
	SFP_BR_MAX = 66,
	SFP_BR_MIN = 67,
	SFP_VENDOR_SN = 68,
	SFP_DATECODE = 84,
	SFP_DIAGMON = 92,
	SFP_DIAGMON_DDM = 64,
	SFP_DIAGMON_INT_CAL = 32,
	SFP_DIAGMON_EXT_CAL = 16,
	SFP_DIAGMON_RXPWR_AVG = 8,
	SFP_DIAGMON_ADDRMODE = 4,
	SFP_ENHOPTS = 93,
	SFP_ENHOPTS_ALARMWARN = 128,
	SFP_ENHOPTS_SOFT_TX_DISABLE = 64,
	SFP_ENHOPTS_SOFT_TX_FAULT = 32,
	SFP_ENHOPTS_SOFT_RX_LOS = 16,
	SFP_ENHOPTS_SOFT_RATE_SELECT = 8,
	SFP_ENHOPTS_APP_SELECT_SFF8079 = 4,
	SFP_ENHOPTS_SOFT_RATE_SFF8431 = 2,
	SFP_SFF8472_COMPLIANCE = 94,
	SFP_SFF8472_COMPLIANCE_NONE = 0,
	SFP_SFF8472_COMPLIANCE_REV9_3 = 1,
	SFP_SFF8472_COMPLIANCE_REV9_5 = 2,
	SFP_SFF8472_COMPLIANCE_REV10_2 = 3,
	SFP_SFF8472_COMPLIANCE_REV10_4 = 4,
	SFP_SFF8472_COMPLIANCE_REV11_0 = 5,
	SFP_SFF8472_COMPLIANCE_REV11_3 = 6,
	SFP_SFF8472_COMPLIANCE_REV11_4 = 7,
	SFP_SFF8472_COMPLIANCE_REV12_0 = 8,
	SFP_CC_EXT = 95,
};

enum {
	SKBFL_ZEROCOPY_ENABLE = 1,
	SKBFL_SHARED_FRAG = 2,
	SKBFL_PURE_ZEROCOPY = 4,
	SKBFL_DONT_ORPHAN = 8,
	SKBFL_MANAGED_FRAG_REFS = 16,
};

enum {
	SKBTX_HW_TSTAMP = 1,
	SKBTX_SW_TSTAMP = 2,
	SKBTX_IN_PROGRESS = 4,
	SKBTX_HW_TSTAMP_USE_CYCLES = 8,
	SKBTX_WIFI_STATUS = 16,
	SKBTX_HW_TSTAMP_NETDEV = 32,
	SKBTX_SCHED_TSTAMP = 64,
};

enum {
	SKB_FCLONE_UNAVAILABLE = 0,
	SKB_FCLONE_ORIG = 1,
	SKB_FCLONE_CLONE = 2,
};

enum {
	SKB_GSO_TCPV4 = 1,
	SKB_GSO_DODGY = 2,
	SKB_GSO_TCP_ECN = 4,
	SKB_GSO_TCP_FIXEDID = 8,
	SKB_GSO_TCPV6 = 16,
	SKB_GSO_FCOE = 32,
	SKB_GSO_GRE = 64,
	SKB_GSO_GRE_CSUM = 128,
	SKB_GSO_IPXIP4 = 256,
	SKB_GSO_IPXIP6 = 512,
	SKB_GSO_UDP_TUNNEL = 1024,
	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
	SKB_GSO_PARTIAL = 4096,
	SKB_GSO_TUNNEL_REMCSUM = 8192,
	SKB_GSO_SCTP = 16384,
	SKB_GSO_ESP = 32768,
	SKB_GSO_UDP = 65536,
	SKB_GSO_UDP_L4 = 131072,
	SKB_GSO_FRAGLIST = 262144,
};

enum {
	SKCIPHER_WALK_SLOW = 1,
	SKCIPHER_WALK_COPY = 2,
	SKCIPHER_WALK_DIFF = 4,
	SKCIPHER_WALK_SLEEP = 8,
};

enum {
	SKX_PCI_UNCORE_IMC = 0,
	SKX_PCI_UNCORE_M2M = 1,
	SKX_PCI_UNCORE_UPI = 2,
	SKX_PCI_UNCORE_M2PCIE = 3,
	SKX_PCI_UNCORE_M3UPI = 4,
};

enum {
	SK_DIAG_BPF_STORAGE_NONE = 0,
	SK_DIAG_BPF_STORAGE_PAD = 1,
	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
	__SK_DIAG_BPF_STORAGE_MAX = 4,
};

enum {
	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
	SK_DIAG_BPF_STORAGE = 1,
	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
};

enum {
	SK_MEMINFO_RMEM_ALLOC = 0,
	SK_MEMINFO_RCVBUF = 1,
	SK_MEMINFO_WMEM_ALLOC = 2,
	SK_MEMINFO_SNDBUF = 3,
	SK_MEMINFO_FWD_ALLOC = 4,
	SK_MEMINFO_WMEM_QUEUED = 5,
	SK_MEMINFO_OPTMEM = 6,
	SK_MEMINFO_BACKLOG = 7,
	SK_MEMINFO_DROPS = 8,
	SK_MEMINFO_VARS = 9,
};

enum {
	SNBEP_PCI_QPI_PORT0_FILTER = 0,
	SNBEP_PCI_QPI_PORT1_FILTER = 1,
	BDX_PCI_QPI_PORT2_FILTER = 2,
};

enum {
	SNBEP_PCI_UNCORE_HA = 0,
	SNBEP_PCI_UNCORE_IMC = 1,
	SNBEP_PCI_UNCORE_QPI = 2,
	SNBEP_PCI_UNCORE_R2PCIE = 3,
	SNBEP_PCI_UNCORE_R3QPI = 4,
};

enum {
	SNB_PCI_UNCORE_IMC = 0,
};

enum {
	SNR_PCI_UNCORE_M2M = 0,
	SNR_PCI_UNCORE_PCIE3 = 1,
};

enum {
	SNR_QAT_PMON_ID = 0,
	SNR_CBDMA_DMI_PMON_ID = 1,
	SNR_NIS_PMON_ID = 2,
	SNR_DLB_PMON_ID = 3,
	SNR_PCIE_GEN3_PMON_ID = 4,
};

enum {
	SOCK_WAKE_IO = 0,
	SOCK_WAKE_WAITD = 1,
	SOCK_WAKE_SPACE = 2,
	SOCK_WAKE_URG = 3,
};

enum {
	SOF_TIMESTAMPING_TX_HARDWARE = 1,
	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
	SOF_TIMESTAMPING_RX_HARDWARE = 4,
	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
	SOF_TIMESTAMPING_SOFTWARE = 16,
	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
	SOF_TIMESTAMPING_OPT_ID = 128,
	SOF_TIMESTAMPING_TX_SCHED = 256,
	SOF_TIMESTAMPING_TX_ACK = 512,
	SOF_TIMESTAMPING_OPT_CMSG = 1024,
	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
	SOF_TIMESTAMPING_OPT_STATS = 4096,
	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
	SOF_TIMESTAMPING_BIND_PHC = 32768,
	SOF_TIMESTAMPING_OPT_ID_TCP = 65536,
	SOF_TIMESTAMPING_OPT_RX_FILTER = 131072,
	SOF_TIMESTAMPING_LAST = 131072,
	SOF_TIMESTAMPING_MASK = 262143,
};

enum {
	SPI_BLIST_NOIUS = 1,
};

enum {
	SP_TASK_PENDING = 0,
	SP_NEED_VICTIM = 1,
	SP_VICTIM_REMAINS = 2,
};

enum {
	SR_DMAR_FECTL_REG = 0,
	SR_DMAR_FEDATA_REG = 1,
	SR_DMAR_FEADDR_REG = 2,
	SR_DMAR_FEUADDR_REG = 3,
	MAX_SR_DMAR_REGS = 4,
};

enum {
	START_TS = 0,
	NOW_TS = 1,
	DELTA_TS = 2,
	JUMP_PREDICATE = 3,
	DELTA_TARGET = 4,
	N_CS_GPR = 5,
};

enum {
	STAT_OK = 0,
	STAT_NOK = 1,
	STAT_ASYNC = 2,
	STAT_ASYNC_OK = 3,
	STAT_ASYNC_NOK = 4,
	STAT_BADKEYS = 5,
	STAT_BADMSGS = 5,
	STAT_NOKEYS = 6,
	STAT_SWITCHES = 7,
	MAX_STATS = 8,
};

enum {
	SUNRPC_PIPEFS_NFS_PRIO = 0,
	SUNRPC_PIPEFS_RPC_PRIO = 1,
};

enum {
	SVC_HANDSHAKE_TO = 5000,
};

enum {
	SVC_POOL_AUTO = -1,
	SVC_POOL_GLOBAL = 0,
	SVC_POOL_PERCPU = 1,
	SVC_POOL_PERNODE = 2,
};

enum {
	SWITCHTEC_GAS_MRPC_OFFSET = 0,
	SWITCHTEC_GAS_TOP_CFG_OFFSET = 4096,
	SWITCHTEC_GAS_SW_EVENT_OFFSET = 6144,
	SWITCHTEC_GAS_SYS_INFO_OFFSET = 8192,
	SWITCHTEC_GAS_FLASH_INFO_OFFSET = 8704,
	SWITCHTEC_GAS_PART_CFG_OFFSET = 16384,
	SWITCHTEC_GAS_NTB_OFFSET = 65536,
	SWITCHTEC_GAS_PFF_CSR_OFFSET = 1261568,
};

enum {
	SWITCHTEC_NTB_REG_INFO_OFFSET = 0,
	SWITCHTEC_NTB_REG_CTRL_OFFSET = 16384,
	SWITCHTEC_NTB_REG_DBMSG_OFFSET = 409600,
};

enum {
	SWMII_SPEED_10 = 0,
	SWMII_SPEED_100 = 1,
	SWMII_SPEED_1000 = 2,
	SWMII_DUPLEX_HALF = 0,
	SWMII_DUPLEX_FULL = 1,
};

enum {
	SWP_USED = 1,
	SWP_WRITEOK = 2,
	SWP_DISCARDABLE = 4,
	SWP_DISCARDING = 8,
	SWP_SOLIDSTATE = 16,
	SWP_CONTINUED = 32,
	SWP_BLKDEV = 64,
	SWP_ACTIVATED = 128,
	SWP_FS_OPS = 256,
	SWP_AREA_DISCARD = 512,
	SWP_PAGE_DISCARD = 1024,
	SWP_STABLE_WRITES = 2048,
	SWP_SYNCHRONOUS_IO = 4096,
};

enum {
	SYNAPTICS_INTERTOUCH_NOT_SET = -1,
	SYNAPTICS_INTERTOUCH_OFF = 0,
	SYNAPTICS_INTERTOUCH_ON = 1,
};

enum {
	TASKLET_STATE_SCHED = 0,
	TASKLET_STATE_RUN = 1,
};

enum {
	TASKSTATS_CMD_ATTR_UNSPEC = 0,
	TASKSTATS_CMD_ATTR_PID = 1,
	TASKSTATS_CMD_ATTR_TGID = 2,
	TASKSTATS_CMD_ATTR_REGISTER_CPUMASK = 3,
	TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 4,
	__TASKSTATS_CMD_ATTR_MAX = 5,
};

enum {
	TASKSTATS_CMD_UNSPEC = 0,
	TASKSTATS_CMD_GET = 1,
	TASKSTATS_CMD_NEW = 2,
	__TASKSTATS_CMD_MAX = 3,
};

enum {
	TASKSTATS_TYPE_UNSPEC = 0,
	TASKSTATS_TYPE_PID = 1,
	TASKSTATS_TYPE_TGID = 2,
	TASKSTATS_TYPE_STATS = 3,
	TASKSTATS_TYPE_AGGR_PID = 4,
	TASKSTATS_TYPE_AGGR_TGID = 5,
	TASKSTATS_TYPE_NULL = 6,
	__TASKSTATS_TYPE_MAX = 7,
};

enum {
	TASK_COMM_LEN = 16,
};

enum {
	TCA_ACT_BPF_UNSPEC = 0,
	TCA_ACT_BPF_TM = 1,
	TCA_ACT_BPF_PARMS = 2,
	TCA_ACT_BPF_OPS_LEN = 3,
	TCA_ACT_BPF_OPS = 4,
	TCA_ACT_BPF_FD = 5,
	TCA_ACT_BPF_NAME = 6,
	TCA_ACT_BPF_PAD = 7,
	TCA_ACT_BPF_TAG = 8,
	TCA_ACT_BPF_ID = 9,
	__TCA_ACT_BPF_MAX = 10,
};

enum {
	TCA_ACT_UNSPEC = 0,
	TCA_ACT_KIND = 1,
	TCA_ACT_OPTIONS = 2,
	TCA_ACT_INDEX = 3,
	TCA_ACT_STATS = 4,
	TCA_ACT_PAD = 5,
	TCA_ACT_COOKIE = 6,
	TCA_ACT_FLAGS = 7,
	TCA_ACT_HW_STATS = 8,
	TCA_ACT_USED_HW_STATS = 9,
	TCA_ACT_IN_HW_COUNT = 10,
	__TCA_ACT_MAX = 11,
};

enum {
	TCA_BASIC_UNSPEC = 0,
	TCA_BASIC_CLASSID = 1,
	TCA_BASIC_EMATCHES = 2,
	TCA_BASIC_ACT = 3,
	TCA_BASIC_POLICE = 4,
	TCA_BASIC_PCNT = 5,
	TCA_BASIC_PAD = 6,
	__TCA_BASIC_MAX = 7,
};

enum {
	TCA_BPF_UNSPEC = 0,
	TCA_BPF_ACT = 1,
	TCA_BPF_POLICE = 2,
	TCA_BPF_CLASSID = 3,
	TCA_BPF_OPS_LEN = 4,
	TCA_BPF_OPS = 5,
	TCA_BPF_FD = 6,
	TCA_BPF_NAME = 7,
	TCA_BPF_FLAGS = 8,
	TCA_BPF_FLAGS_GEN = 9,
	TCA_BPF_TAG = 10,
	TCA_BPF_ID = 11,
	__TCA_BPF_MAX = 12,
};

enum {
	TCA_CAKE_UNSPEC = 0,
	TCA_CAKE_PAD = 1,
	TCA_CAKE_BASE_RATE64 = 2,
	TCA_CAKE_DIFFSERV_MODE = 3,
	TCA_CAKE_ATM = 4,
	TCA_CAKE_FLOW_MODE = 5,
	TCA_CAKE_OVERHEAD = 6,
	TCA_CAKE_RTT = 7,
	TCA_CAKE_TARGET = 8,
	TCA_CAKE_AUTORATE = 9,
	TCA_CAKE_MEMORY = 10,
	TCA_CAKE_NAT = 11,
	TCA_CAKE_RAW = 12,
	TCA_CAKE_WASH = 13,
	TCA_CAKE_MPU = 14,
	TCA_CAKE_INGRESS = 15,
	TCA_CAKE_ACK_FILTER = 16,
	TCA_CAKE_SPLIT_GSO = 17,
	TCA_CAKE_FWMARK = 18,
	__TCA_CAKE_MAX = 19,
};

enum {
	TCA_CBS_UNSPEC = 0,
	TCA_CBS_PARMS = 1,
	__TCA_CBS_MAX = 2,
};

enum {
	TCA_CGROUP_UNSPEC = 0,
	TCA_CGROUP_ACT = 1,
	TCA_CGROUP_POLICE = 2,
	TCA_CGROUP_EMATCHES = 3,
	__TCA_CGROUP_MAX = 4,
};

enum {
	TCA_CHOKE_UNSPEC = 0,
	TCA_CHOKE_PARMS = 1,
	TCA_CHOKE_STAB = 2,
	TCA_CHOKE_MAX_P = 3,
	__TCA_CHOKE_MAX = 4,
};

enum {
	TCA_CODEL_UNSPEC = 0,
	TCA_CODEL_TARGET = 1,
	TCA_CODEL_LIMIT = 2,
	TCA_CODEL_INTERVAL = 3,
	TCA_CODEL_ECN = 4,
	TCA_CODEL_CE_THRESHOLD = 5,
	__TCA_CODEL_MAX = 6,
};

enum {
	TCA_CONNMARK_UNSPEC = 0,
	TCA_CONNMARK_PARMS = 1,
	TCA_CONNMARK_TM = 2,
	TCA_CONNMARK_PAD = 3,
	__TCA_CONNMARK_MAX = 4,
};

enum {
	TCA_CSUM_UNSPEC = 0,
	TCA_CSUM_PARMS = 1,
	TCA_CSUM_TM = 2,
	TCA_CSUM_PAD = 3,
	__TCA_CSUM_MAX = 4,
};

enum {
	TCA_CSUM_UPDATE_FLAG_IPV4HDR = 1,
	TCA_CSUM_UPDATE_FLAG_ICMP = 2,
	TCA_CSUM_UPDATE_FLAG_IGMP = 4,
	TCA_CSUM_UPDATE_FLAG_TCP = 8,
	TCA_CSUM_UPDATE_FLAG_UDP = 16,
	TCA_CSUM_UPDATE_FLAG_UDPLITE = 32,
	TCA_CSUM_UPDATE_FLAG_SCTP = 64,
};

enum {
	TCA_CTINFO_UNSPEC = 0,
	TCA_CTINFO_PAD = 1,
	TCA_CTINFO_TM = 2,
	TCA_CTINFO_ACT = 3,
	TCA_CTINFO_ZONE = 4,
	TCA_CTINFO_PARMS_DSCP_MASK = 5,
	TCA_CTINFO_PARMS_DSCP_STATEMASK = 6,
	TCA_CTINFO_PARMS_CPMARK_MASK = 7,
	TCA_CTINFO_STATS_DSCP_SET = 8,
	TCA_CTINFO_STATS_DSCP_ERROR = 9,
	TCA_CTINFO_STATS_CPMARK_SET = 10,
	__TCA_CTINFO_MAX = 11,
};

enum {
	TCA_CT_UNSPEC = 0,
	TCA_CT_PARMS = 1,
	TCA_CT_TM = 2,
	TCA_CT_ACTION = 3,
	TCA_CT_ZONE = 4,
	TCA_CT_MARK = 5,
	TCA_CT_MARK_MASK = 6,
	TCA_CT_LABELS = 7,
	TCA_CT_LABELS_MASK = 8,
	TCA_CT_NAT_IPV4_MIN = 9,
	TCA_CT_NAT_IPV4_MAX = 10,
	TCA_CT_NAT_IPV6_MIN = 11,
	TCA_CT_NAT_IPV6_MAX = 12,
	TCA_CT_NAT_PORT_MIN = 13,
	TCA_CT_NAT_PORT_MAX = 14,
	TCA_CT_PAD = 15,
	TCA_CT_HELPER_NAME = 16,
	TCA_CT_HELPER_FAMILY = 17,
	TCA_CT_HELPER_PROTO = 18,
	__TCA_CT_MAX = 19,
};

enum {
	TCA_DEF_UNSPEC = 0,
	TCA_DEF_TM = 1,
	TCA_DEF_PARMS = 2,
	TCA_DEF_DATA = 3,
	TCA_DEF_PAD = 4,
	__TCA_DEF_MAX = 5,
};

enum {
	TCA_DRR_UNSPEC = 0,
	TCA_DRR_QUANTUM = 1,
	__TCA_DRR_MAX = 2,
};

enum {
	TCA_EMATCH_TREE_UNSPEC = 0,
	TCA_EMATCH_TREE_HDR = 1,
	TCA_EMATCH_TREE_LIST = 2,
	__TCA_EMATCH_TREE_MAX = 3,
};

enum {
	TCA_EM_IPT_UNSPEC = 0,
	TCA_EM_IPT_HOOK = 1,
	TCA_EM_IPT_MATCH_NAME = 2,
	TCA_EM_IPT_MATCH_REVISION = 3,
	TCA_EM_IPT_NFPROTO = 4,
	TCA_EM_IPT_MATCH_DATA = 5,
	__TCA_EM_IPT_MAX = 6,
};

enum {
	TCA_EM_META_UNSPEC = 0,
	TCA_EM_META_HDR = 1,
	TCA_EM_META_LVALUE = 2,
	TCA_EM_META_RVALUE = 3,
	__TCA_EM_META_MAX = 4,
};

enum {
	TCA_ETF_UNSPEC = 0,
	TCA_ETF_PARMS = 1,
	__TCA_ETF_MAX = 2,
};

enum {
	TCA_ETS_UNSPEC = 0,
	TCA_ETS_NBANDS = 1,
	TCA_ETS_NSTRICT = 2,
	TCA_ETS_QUANTA = 3,
	TCA_ETS_QUANTA_BAND = 4,
	TCA_ETS_PRIOMAP = 5,
	TCA_ETS_PRIOMAP_BAND = 6,
	__TCA_ETS_MAX = 7,
};

enum {
	TCA_FLOWER_KEY_CFM_OPT_UNSPEC = 0,
	TCA_FLOWER_KEY_CFM_MD_LEVEL = 1,
	TCA_FLOWER_KEY_CFM_OPCODE = 2,
	__TCA_FLOWER_KEY_CFM_OPT_MAX = 3,
};

enum {
	TCA_FLOWER_KEY_CT_FLAGS_NEW = 1,
	TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED = 2,
	TCA_FLOWER_KEY_CT_FLAGS_RELATED = 4,
	TCA_FLOWER_KEY_CT_FLAGS_TRACKED = 8,
	TCA_FLOWER_KEY_CT_FLAGS_INVALID = 16,
	TCA_FLOWER_KEY_CT_FLAGS_REPLY = 32,
	__TCA_FLOWER_KEY_CT_FLAGS_MAX = 33,
};

enum {
	TCA_FLOWER_KEY_ENC_OPTS_UNSPEC = 0,
	TCA_FLOWER_KEY_ENC_OPTS_GENEVE = 1,
	TCA_FLOWER_KEY_ENC_OPTS_VXLAN = 2,
	TCA_FLOWER_KEY_ENC_OPTS_ERSPAN = 3,
	TCA_FLOWER_KEY_ENC_OPTS_GTP = 4,
	TCA_FLOWER_KEY_ENC_OPTS_PFCP = 5,
	__TCA_FLOWER_KEY_ENC_OPTS_MAX = 6,
};

enum {
	TCA_FLOWER_KEY_ENC_OPT_ERSPAN_UNSPEC = 0,
	TCA_FLOWER_KEY_ENC_OPT_ERSPAN_VER = 1,
	TCA_FLOWER_KEY_ENC_OPT_ERSPAN_INDEX = 2,
	TCA_FLOWER_KEY_ENC_OPT_ERSPAN_DIR = 3,
	TCA_FLOWER_KEY_ENC_OPT_ERSPAN_HWID = 4,
	__TCA_FLOWER_KEY_ENC_OPT_ERSPAN_MAX = 5,
};

enum {
	TCA_FLOWER_KEY_ENC_OPT_GENEVE_UNSPEC = 0,
	TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS = 1,
	TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE = 2,
	TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA = 3,
	__TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX = 4,
};

enum {
	TCA_FLOWER_KEY_ENC_OPT_GTP_UNSPEC = 0,
	TCA_FLOWER_KEY_ENC_OPT_GTP_PDU_TYPE = 1,
	TCA_FLOWER_KEY_ENC_OPT_GTP_QFI = 2,
	__TCA_FLOWER_KEY_ENC_OPT_GTP_MAX = 3,
};

enum {
	TCA_FLOWER_KEY_ENC_OPT_PFCP_UNSPEC = 0,
	TCA_FLOWER_KEY_ENC_OPT_PFCP_TYPE = 1,
	TCA_FLOWER_KEY_ENC_OPT_PFCP_SEID = 2,
	__TCA_FLOWER_KEY_ENC_OPT_PFCP_MAX = 3,
};

enum {
	TCA_FLOWER_KEY_ENC_OPT_VXLAN_UNSPEC = 0,
	TCA_FLOWER_KEY_ENC_OPT_VXLAN_GBP = 1,
	__TCA_FLOWER_KEY_ENC_OPT_VXLAN_MAX = 2,
};

enum {
	TCA_FLOWER_KEY_FLAGS_IS_FRAGMENT = 1,
	TCA_FLOWER_KEY_FLAGS_FRAG_IS_FIRST = 2,
	TCA_FLOWER_KEY_FLAGS_TUNNEL_CSUM = 4,
	TCA_FLOWER_KEY_FLAGS_TUNNEL_DONT_FRAGMENT = 8,
	TCA_FLOWER_KEY_FLAGS_TUNNEL_OAM = 16,
	TCA_FLOWER_KEY_FLAGS_TUNNEL_CRIT_OPT = 32,
	__TCA_FLOWER_KEY_FLAGS_MAX = 33,
};

enum {
	TCA_FLOWER_KEY_MPLS_OPTS_UNSPEC = 0,
	TCA_FLOWER_KEY_MPLS_OPTS_LSE = 1,
	__TCA_FLOWER_KEY_MPLS_OPTS_MAX = 2,
};

enum {
	TCA_FLOWER_KEY_MPLS_OPT_LSE_UNSPEC = 0,
	TCA_FLOWER_KEY_MPLS_OPT_LSE_DEPTH = 1,
	TCA_FLOWER_KEY_MPLS_OPT_LSE_TTL = 2,
	TCA_FLOWER_KEY_MPLS_OPT_LSE_BOS = 3,
	TCA_FLOWER_KEY_MPLS_OPT_LSE_TC = 4,
	TCA_FLOWER_KEY_MPLS_OPT_LSE_LABEL = 5,
	__TCA_FLOWER_KEY_MPLS_OPT_LSE_MAX = 6,
};

enum {
	TCA_FLOWER_UNSPEC = 0,
	TCA_FLOWER_CLASSID = 1,
	TCA_FLOWER_INDEV = 2,
	TCA_FLOWER_ACT = 3,
	TCA_FLOWER_KEY_ETH_DST = 4,
	TCA_FLOWER_KEY_ETH_DST_MASK = 5,
	TCA_FLOWER_KEY_ETH_SRC = 6,
	TCA_FLOWER_KEY_ETH_SRC_MASK = 7,
	TCA_FLOWER_KEY_ETH_TYPE = 8,
	TCA_FLOWER_KEY_IP_PROTO = 9,
	TCA_FLOWER_KEY_IPV4_SRC = 10,
	TCA_FLOWER_KEY_IPV4_SRC_MASK = 11,
	TCA_FLOWER_KEY_IPV4_DST = 12,
	TCA_FLOWER_KEY_IPV4_DST_MASK = 13,
	TCA_FLOWER_KEY_IPV6_SRC = 14,
	TCA_FLOWER_KEY_IPV6_SRC_MASK = 15,
	TCA_FLOWER_KEY_IPV6_DST = 16,
	TCA_FLOWER_KEY_IPV6_DST_MASK = 17,
	TCA_FLOWER_KEY_TCP_SRC = 18,
	TCA_FLOWER_KEY_TCP_DST = 19,
	TCA_FLOWER_KEY_UDP_SRC = 20,
	TCA_FLOWER_KEY_UDP_DST = 21,
	TCA_FLOWER_FLAGS = 22,
	TCA_FLOWER_KEY_VLAN_ID = 23,
	TCA_FLOWER_KEY_VLAN_PRIO = 24,
	TCA_FLOWER_KEY_VLAN_ETH_TYPE = 25,
	TCA_FLOWER_KEY_ENC_KEY_ID = 26,
	TCA_FLOWER_KEY_ENC_IPV4_SRC = 27,
	TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK = 28,
	TCA_FLOWER_KEY_ENC_IPV4_DST = 29,
	TCA_FLOWER_KEY_ENC_IPV4_DST_MASK = 30,
	TCA_FLOWER_KEY_ENC_IPV6_SRC = 31,
	TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK = 32,
	TCA_FLOWER_KEY_ENC_IPV6_DST = 33,
	TCA_FLOWER_KEY_ENC_IPV6_DST_MASK = 34,
	TCA_FLOWER_KEY_TCP_SRC_MASK = 35,
	TCA_FLOWER_KEY_TCP_DST_MASK = 36,
	TCA_FLOWER_KEY_UDP_SRC_MASK = 37,
	TCA_FLOWER_KEY_UDP_DST_MASK = 38,
	TCA_FLOWER_KEY_SCTP_SRC_MASK = 39,
	TCA_FLOWER_KEY_SCTP_DST_MASK = 40,
	TCA_FLOWER_KEY_SCTP_SRC = 41,
	TCA_FLOWER_KEY_SCTP_DST = 42,
	TCA_FLOWER_KEY_ENC_UDP_SRC_PORT = 43,
	TCA_FLOWER_KEY_ENC_UDP_SRC_PORT_MASK = 44,
	TCA_FLOWER_KEY_ENC_UDP_DST_PORT = 45,
	TCA_FLOWER_KEY_ENC_UDP_DST_PORT_MASK = 46,
	TCA_FLOWER_KEY_FLAGS = 47,
	TCA_FLOWER_KEY_FLAGS_MASK = 48,
	TCA_FLOWER_KEY_ICMPV4_CODE = 49,
	TCA_FLOWER_KEY_ICMPV4_CODE_MASK = 50,
	TCA_FLOWER_KEY_ICMPV4_TYPE = 51,
	TCA_FLOWER_KEY_ICMPV4_TYPE_MASK = 52,
	TCA_FLOWER_KEY_ICMPV6_CODE = 53,
	TCA_FLOWER_KEY_ICMPV6_CODE_MASK = 54,
	TCA_FLOWER_KEY_ICMPV6_TYPE = 55,
	TCA_FLOWER_KEY_ICMPV6_TYPE_MASK = 56,
	TCA_FLOWER_KEY_ARP_SIP = 57,
	TCA_FLOWER_KEY_ARP_SIP_MASK = 58,
	TCA_FLOWER_KEY_ARP_TIP = 59,
	TCA_FLOWER_KEY_ARP_TIP_MASK = 60,
	TCA_FLOWER_KEY_ARP_OP = 61,
	TCA_FLOWER_KEY_ARP_OP_MASK = 62,
	TCA_FLOWER_KEY_ARP_SHA = 63,
	TCA_FLOWER_KEY_ARP_SHA_MASK = 64,
	TCA_FLOWER_KEY_ARP_THA = 65,
	TCA_FLOWER_KEY_ARP_THA_MASK = 66,
	TCA_FLOWER_KEY_MPLS_TTL = 67,
	TCA_FLOWER_KEY_MPLS_BOS = 68,
	TCA_FLOWER_KEY_MPLS_TC = 69,
	TCA_FLOWER_KEY_MPLS_LABEL = 70,
	TCA_FLOWER_KEY_TCP_FLAGS = 71,
	TCA_FLOWER_KEY_TCP_FLAGS_MASK = 72,
	TCA_FLOWER_KEY_IP_TOS = 73,
	TCA_FLOWER_KEY_IP_TOS_MASK = 74,
	TCA_FLOWER_KEY_IP_TTL = 75,
	TCA_FLOWER_KEY_IP_TTL_MASK = 76,
	TCA_FLOWER_KEY_CVLAN_ID = 77,
	TCA_FLOWER_KEY_CVLAN_PRIO = 78,
	TCA_FLOWER_KEY_CVLAN_ETH_TYPE = 79,
	TCA_FLOWER_KEY_ENC_IP_TOS = 80,
	TCA_FLOWER_KEY_ENC_IP_TOS_MASK = 81,
	TCA_FLOWER_KEY_ENC_IP_TTL = 82,
	TCA_FLOWER_KEY_ENC_IP_TTL_MASK = 83,
	TCA_FLOWER_KEY_ENC_OPTS = 84,
	TCA_FLOWER_KEY_ENC_OPTS_MASK = 85,
	TCA_FLOWER_IN_HW_COUNT = 86,
	TCA_FLOWER_KEY_PORT_SRC_MIN = 87,
	TCA_FLOWER_KEY_PORT_SRC_MAX = 88,
	TCA_FLOWER_KEY_PORT_DST_MIN = 89,
	TCA_FLOWER_KEY_PORT_DST_MAX = 90,
	TCA_FLOWER_KEY_CT_STATE = 91,
	TCA_FLOWER_KEY_CT_STATE_MASK = 92,
	TCA_FLOWER_KEY_CT_ZONE = 93,
	TCA_FLOWER_KEY_CT_ZONE_MASK = 94,
	TCA_FLOWER_KEY_CT_MARK = 95,
	TCA_FLOWER_KEY_CT_MARK_MASK = 96,
	TCA_FLOWER_KEY_CT_LABELS = 97,
	TCA_FLOWER_KEY_CT_LABELS_MASK = 98,
	TCA_FLOWER_KEY_MPLS_OPTS = 99,
	TCA_FLOWER_KEY_HASH = 100,
	TCA_FLOWER_KEY_HASH_MASK = 101,
	TCA_FLOWER_KEY_NUM_OF_VLANS = 102,
	TCA_FLOWER_KEY_PPPOE_SID = 103,
	TCA_FLOWER_KEY_PPP_PROTO = 104,
	TCA_FLOWER_KEY_L2TPV3_SID = 105,
	TCA_FLOWER_L2_MISS = 106,
	TCA_FLOWER_KEY_CFM = 107,
	TCA_FLOWER_KEY_SPI = 108,
	TCA_FLOWER_KEY_SPI_MASK = 109,
	TCA_FLOWER_KEY_ENC_FLAGS = 110,
	TCA_FLOWER_KEY_ENC_FLAGS_MASK = 111,
	__TCA_FLOWER_MAX = 112,
};

enum {
	TCA_FLOW_UNSPEC = 0,
	TCA_FLOW_KEYS = 1,
	TCA_FLOW_MODE = 2,
	TCA_FLOW_BASECLASS = 3,
	TCA_FLOW_RSHIFT = 4,
	TCA_FLOW_ADDEND = 5,
	TCA_FLOW_MASK = 6,
	TCA_FLOW_XOR = 7,
	TCA_FLOW_DIVISOR = 8,
	TCA_FLOW_ACT = 9,
	TCA_FLOW_POLICE = 10,
	TCA_FLOW_EMATCHES = 11,
	TCA_FLOW_PERTURB = 12,
	__TCA_FLOW_MAX = 13,
};

enum {
	TCA_FQ_CODEL_UNSPEC = 0,
	TCA_FQ_CODEL_TARGET = 1,
	TCA_FQ_CODEL_LIMIT = 2,
	TCA_FQ_CODEL_INTERVAL = 3,
	TCA_FQ_CODEL_ECN = 4,
	TCA_FQ_CODEL_FLOWS = 5,
	TCA_FQ_CODEL_QUANTUM = 6,
	TCA_FQ_CODEL_CE_THRESHOLD = 7,
	TCA_FQ_CODEL_DROP_BATCH_SIZE = 8,
	TCA_FQ_CODEL_MEMORY_LIMIT = 9,
	TCA_FQ_CODEL_CE_THRESHOLD_SELECTOR = 10,
	TCA_FQ_CODEL_CE_THRESHOLD_MASK = 11,
	__TCA_FQ_CODEL_MAX = 12,
};

enum {
	TCA_FQ_CODEL_XSTATS_QDISC = 0,
	TCA_FQ_CODEL_XSTATS_CLASS = 1,
};

enum {
	TCA_FQ_PIE_UNSPEC = 0,
	TCA_FQ_PIE_LIMIT = 1,
	TCA_FQ_PIE_FLOWS = 2,
	TCA_FQ_PIE_TARGET = 3,
	TCA_FQ_PIE_TUPDATE = 4,
	TCA_FQ_PIE_ALPHA = 5,
	TCA_FQ_PIE_BETA = 6,
	TCA_FQ_PIE_QUANTUM = 7,
	TCA_FQ_PIE_MEMORY_LIMIT = 8,
	TCA_FQ_PIE_ECN_PROB = 9,
	TCA_FQ_PIE_ECN = 10,
	TCA_FQ_PIE_BYTEMODE = 11,
	TCA_FQ_PIE_DQ_RATE_ESTIMATOR = 12,
	__TCA_FQ_PIE_MAX = 13,
};

enum {
	TCA_FQ_UNSPEC = 0,
	TCA_FQ_PLIMIT = 1,
	TCA_FQ_FLOW_PLIMIT = 2,
	TCA_FQ_QUANTUM = 3,
	TCA_FQ_INITIAL_QUANTUM = 4,
	TCA_FQ_RATE_ENABLE = 5,
	TCA_FQ_FLOW_DEFAULT_RATE = 6,
	TCA_FQ_FLOW_MAX_RATE = 7,
	TCA_FQ_BUCKETS_LOG = 8,
	TCA_FQ_FLOW_REFILL_DELAY = 9,
	TCA_FQ_ORPHAN_MASK = 10,
	TCA_FQ_LOW_RATE_THRESHOLD = 11,
	TCA_FQ_CE_THRESHOLD = 12,
	TCA_FQ_TIMER_SLACK = 13,
	TCA_FQ_HORIZON = 14,
	TCA_FQ_HORIZON_DROP = 15,
	TCA_FQ_PRIOMAP = 16,
	TCA_FQ_WEIGHTS = 17,
	TCA_FQ_OFFLOAD_HORIZON = 18,
	__TCA_FQ_MAX = 19,
};

enum {
	TCA_FW_UNSPEC = 0,
	TCA_FW_CLASSID = 1,
	TCA_FW_POLICE = 2,
	TCA_FW_INDEV = 3,
	TCA_FW_ACT = 4,
	TCA_FW_MASK = 5,
	__TCA_FW_MAX = 6,
};

enum {
	TCA_GACT_UNSPEC = 0,
	TCA_GACT_TM = 1,
	TCA_GACT_PARMS = 2,
	TCA_GACT_PROB = 3,
	TCA_GACT_PAD = 4,
	__TCA_GACT_MAX = 5,
};

enum {
	TCA_GATE_ENTRY_UNSPEC = 0,
	TCA_GATE_ENTRY_INDEX = 1,
	TCA_GATE_ENTRY_GATE = 2,
	TCA_GATE_ENTRY_INTERVAL = 3,
	TCA_GATE_ENTRY_IPV = 4,
	TCA_GATE_ENTRY_MAX_OCTETS = 5,
	__TCA_GATE_ENTRY_MAX = 6,
};

enum {
	TCA_GATE_ONE_ENTRY_UNSPEC = 0,
	TCA_GATE_ONE_ENTRY = 1,
	__TCA_GATE_ONE_ENTRY_MAX = 2,
};

enum {
	TCA_GATE_UNSPEC = 0,
	TCA_GATE_TM = 1,
	TCA_GATE_PARMS = 2,
	TCA_GATE_PAD = 3,
	TCA_GATE_PRIORITY = 4,
	TCA_GATE_ENTRY_LIST = 5,
	TCA_GATE_BASE_TIME = 6,
	TCA_GATE_CYCLE_TIME = 7,
	TCA_GATE_CYCLE_TIME_EXT = 8,
	TCA_GATE_FLAGS = 9,
	TCA_GATE_CLOCKID = 10,
	__TCA_GATE_MAX = 11,
};

enum {
	TCA_GRED_UNSPEC = 0,
	TCA_GRED_PARMS = 1,
	TCA_GRED_STAB = 2,
	TCA_GRED_DPS = 3,
	TCA_GRED_MAX_P = 4,
	TCA_GRED_LIMIT = 5,
	TCA_GRED_VQ_LIST = 6,
	__TCA_GRED_MAX = 7,
};

enum {
	TCA_GRED_VQ_ENTRY_UNSPEC = 0,
	TCA_GRED_VQ_ENTRY = 1,
	__TCA_GRED_VQ_ENTRY_MAX = 2,
};

enum {
	TCA_GRED_VQ_UNSPEC = 0,
	TCA_GRED_VQ_PAD = 1,
	TCA_GRED_VQ_DP = 2,
	TCA_GRED_VQ_STAT_BYTES = 3,
	TCA_GRED_VQ_STAT_PACKETS = 4,
	TCA_GRED_VQ_STAT_BACKLOG = 5,
	TCA_GRED_VQ_STAT_PROB_DROP = 6,
	TCA_GRED_VQ_STAT_PROB_MARK = 7,
	TCA_GRED_VQ_STAT_FORCED_DROP = 8,
	TCA_GRED_VQ_STAT_FORCED_MARK = 9,
	TCA_GRED_VQ_STAT_PDROP = 10,
	TCA_GRED_VQ_STAT_OTHER = 11,
	TCA_GRED_VQ_FLAGS = 12,
	__TCA_GRED_VQ_MAX = 13,
};

enum {
	TCA_HFSC_UNSPEC = 0,
	TCA_HFSC_RSC = 1,
	TCA_HFSC_FSC = 2,
	TCA_HFSC_USC = 3,
	__TCA_HFSC_MAX = 4,
};

enum {
	TCA_HHF_UNSPEC = 0,
	TCA_HHF_BACKLOG_LIMIT = 1,
	TCA_HHF_QUANTUM = 2,
	TCA_HHF_HH_FLOWS_LIMIT = 3,
	TCA_HHF_RESET_TIMEOUT = 4,
	TCA_HHF_ADMIT_BYTES = 5,
	TCA_HHF_EVICT_TIMEOUT = 6,
	TCA_HHF_NON_HH_WEIGHT = 7,
	__TCA_HHF_MAX = 8,
};

enum {
	TCA_HTB_UNSPEC = 0,
	TCA_HTB_PARMS = 1,
	TCA_HTB_INIT = 2,
	TCA_HTB_CTAB = 3,
	TCA_HTB_RTAB = 4,
	TCA_HTB_DIRECT_QLEN = 5,
	TCA_HTB_RATE64 = 6,
	TCA_HTB_CEIL64 = 7,
	TCA_HTB_PAD = 8,
	TCA_HTB_OFFLOAD = 9,
	__TCA_HTB_MAX = 10,
};

enum {
	TCA_IFE_UNSPEC = 0,
	TCA_IFE_PARMS = 1,
	TCA_IFE_TM = 2,
	TCA_IFE_DMAC = 3,
	TCA_IFE_SMAC = 4,
	TCA_IFE_TYPE = 5,
	TCA_IFE_METALST = 6,
	TCA_IFE_PAD = 7,
	__TCA_IFE_MAX = 8,
};

enum {
	TCA_MATCHALL_UNSPEC = 0,
	TCA_MATCHALL_CLASSID = 1,
	TCA_MATCHALL_ACT = 2,
	TCA_MATCHALL_FLAGS = 3,
	TCA_MATCHALL_PCNT = 4,
	TCA_MATCHALL_PAD = 5,
	__TCA_MATCHALL_MAX = 6,
};

enum {
	TCA_MIRRED_UNSPEC = 0,
	TCA_MIRRED_TM = 1,
	TCA_MIRRED_PARMS = 2,
	TCA_MIRRED_PAD = 3,
	TCA_MIRRED_BLOCKID = 4,
	__TCA_MIRRED_MAX = 5,
};

enum {
	TCA_MPLS_UNSPEC = 0,
	TCA_MPLS_TM = 1,
	TCA_MPLS_PARMS = 2,
	TCA_MPLS_PAD = 3,
	TCA_MPLS_PROTO = 4,
	TCA_MPLS_LABEL = 5,
	TCA_MPLS_TC = 6,
	TCA_MPLS_TTL = 7,
	TCA_MPLS_BOS = 8,
	__TCA_MPLS_MAX = 9,
};

enum {
	TCA_MQPRIO_TC_ENTRY_UNSPEC = 0,
	TCA_MQPRIO_TC_ENTRY_INDEX = 1,
	TCA_MQPRIO_TC_ENTRY_FP = 2,
	__TCA_MQPRIO_TC_ENTRY_CNT = 3,
	TCA_MQPRIO_TC_ENTRY_MAX = 2,
};

enum {
	TCA_MQPRIO_UNSPEC = 0,
	TCA_MQPRIO_MODE = 1,
	TCA_MQPRIO_SHAPER = 2,
	TCA_MQPRIO_MIN_RATE64 = 3,
	TCA_MQPRIO_MAX_RATE64 = 4,
	TCA_MQPRIO_TC_ENTRY = 5,
	__TCA_MQPRIO_MAX = 6,
};

enum {
	TCA_NAT_UNSPEC = 0,
	TCA_NAT_PARMS = 1,
	TCA_NAT_TM = 2,
	TCA_NAT_PAD = 3,
	__TCA_NAT_MAX = 4,
};

enum {
	TCA_NETEM_UNSPEC = 0,
	TCA_NETEM_CORR = 1,
	TCA_NETEM_DELAY_DIST = 2,
	TCA_NETEM_REORDER = 3,
	TCA_NETEM_CORRUPT = 4,
	TCA_NETEM_LOSS = 5,
	TCA_NETEM_RATE = 6,
	TCA_NETEM_ECN = 7,
	TCA_NETEM_RATE64 = 8,
	TCA_NETEM_PAD = 9,
	TCA_NETEM_LATENCY64 = 10,
	TCA_NETEM_JITTER64 = 11,
	TCA_NETEM_SLOT = 12,
	TCA_NETEM_SLOT_DIST = 13,
	TCA_NETEM_PRNG_SEED = 14,
	__TCA_NETEM_MAX = 15,
};

enum {
	TCA_PEDIT_KEY_EX_HTYPE = 1,
	TCA_PEDIT_KEY_EX_CMD = 2,
	__TCA_PEDIT_KEY_EX_MAX = 3,
};

enum {
	TCA_PEDIT_UNSPEC = 0,
	TCA_PEDIT_TM = 1,
	TCA_PEDIT_PARMS = 2,
	TCA_PEDIT_PAD = 3,
	TCA_PEDIT_PARMS_EX = 4,
	TCA_PEDIT_KEYS_EX = 5,
	TCA_PEDIT_KEY_EX = 6,
	__TCA_PEDIT_MAX = 7,
};

enum {
	TCA_PIE_UNSPEC = 0,
	TCA_PIE_TARGET = 1,
	TCA_PIE_LIMIT = 2,
	TCA_PIE_TUPDATE = 3,
	TCA_PIE_ALPHA = 4,
	TCA_PIE_BETA = 5,
	TCA_PIE_ECN = 6,
	TCA_PIE_BYTEMODE = 7,
	TCA_PIE_DQ_RATE_ESTIMATOR = 8,
	__TCA_PIE_MAX = 9,
};

enum {
	TCA_POLICE_UNSPEC = 0,
	TCA_POLICE_TBF = 1,
	TCA_POLICE_RATE = 2,
	TCA_POLICE_PEAKRATE = 3,
	TCA_POLICE_AVRATE = 4,
	TCA_POLICE_RESULT = 5,
	TCA_POLICE_TM = 6,
	TCA_POLICE_PAD = 7,
	TCA_POLICE_RATE64 = 8,
	TCA_POLICE_PEAKRATE64 = 9,
	TCA_POLICE_PKTRATE64 = 10,
	TCA_POLICE_PKTBURST64 = 11,
	__TCA_POLICE_MAX = 12,
};

enum {
	TCA_QFQ_UNSPEC = 0,
	TCA_QFQ_WEIGHT = 1,
	TCA_QFQ_LMAX = 2,
	__TCA_QFQ_MAX = 3,
};

enum {
	TCA_RED_UNSPEC = 0,
	TCA_RED_PARMS = 1,
	TCA_RED_STAB = 2,
	TCA_RED_MAX_P = 3,
	TCA_RED_FLAGS = 4,
	TCA_RED_EARLY_DROP_BLOCK = 5,
	TCA_RED_MARK_BLOCK = 6,
	__TCA_RED_MAX = 7,
};

enum {
	TCA_ROOT_UNSPEC = 0,
	TCA_ROOT_TAB = 1,
	TCA_ROOT_FLAGS = 2,
	TCA_ROOT_COUNT = 3,
	TCA_ROOT_TIME_DELTA = 4,
	TCA_ROOT_EXT_WARN_MSG = 5,
	__TCA_ROOT_MAX = 6,
};

enum {
	TCA_ROUTE4_UNSPEC = 0,
	TCA_ROUTE4_CLASSID = 1,
	TCA_ROUTE4_TO = 2,
	TCA_ROUTE4_FROM = 3,
	TCA_ROUTE4_IIF = 4,
	TCA_ROUTE4_POLICE = 5,
	TCA_ROUTE4_ACT = 6,
	__TCA_ROUTE4_MAX = 7,
};

enum {
	TCA_SAMPLE_UNSPEC = 0,
	TCA_SAMPLE_TM = 1,
	TCA_SAMPLE_PARMS = 2,
	TCA_SAMPLE_RATE = 3,
	TCA_SAMPLE_TRUNC_SIZE = 4,
	TCA_SAMPLE_PSAMPLE_GROUP = 5,
	TCA_SAMPLE_PAD = 6,
	__TCA_SAMPLE_MAX = 7,
};

enum {
	TCA_SFB_UNSPEC = 0,
	TCA_SFB_PARMS = 1,
	__TCA_SFB_MAX = 2,
};

enum {
	TCA_SKBEDIT_UNSPEC = 0,
	TCA_SKBEDIT_TM = 1,
	TCA_SKBEDIT_PARMS = 2,
	TCA_SKBEDIT_PRIORITY = 3,
	TCA_SKBEDIT_QUEUE_MAPPING = 4,
	TCA_SKBEDIT_MARK = 5,
	TCA_SKBEDIT_PAD = 6,
	TCA_SKBEDIT_PTYPE = 7,
	TCA_SKBEDIT_MASK = 8,
	TCA_SKBEDIT_FLAGS = 9,
	TCA_SKBEDIT_QUEUE_MAPPING_MAX = 10,
	__TCA_SKBEDIT_MAX = 11,
};

enum {
	TCA_SKBMOD_UNSPEC = 0,
	TCA_SKBMOD_TM = 1,
	TCA_SKBMOD_PARMS = 2,
	TCA_SKBMOD_DMAC = 3,
	TCA_SKBMOD_SMAC = 4,
	TCA_SKBMOD_ETYPE = 5,
	TCA_SKBMOD_PAD = 6,
	__TCA_SKBMOD_MAX = 7,
};

enum {
	TCA_STAB_UNSPEC = 0,
	TCA_STAB_BASE = 1,
	TCA_STAB_DATA = 2,
	__TCA_STAB_MAX = 3,
};

enum {
	TCA_STATS_UNSPEC = 0,
	TCA_STATS_BASIC = 1,
	TCA_STATS_RATE_EST = 2,
	TCA_STATS_QUEUE = 3,
	TCA_STATS_APP = 4,
	TCA_STATS_RATE_EST64 = 5,
	TCA_STATS_PAD = 6,
	TCA_STATS_BASIC_HW = 7,
	TCA_STATS_PKT64 = 8,
	__TCA_STATS_MAX = 9,
};

enum {
	TCA_TAPRIO_ATTR_UNSPEC = 0,
	TCA_TAPRIO_ATTR_PRIOMAP = 1,
	TCA_TAPRIO_ATTR_SCHED_ENTRY_LIST = 2,
	TCA_TAPRIO_ATTR_SCHED_BASE_TIME = 3,
	TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY = 4,
	TCA_TAPRIO_ATTR_SCHED_CLOCKID = 5,
	TCA_TAPRIO_PAD = 6,
	TCA_TAPRIO_ATTR_ADMIN_SCHED = 7,
	TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME = 8,
	TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION = 9,
	TCA_TAPRIO_ATTR_FLAGS = 10,
	TCA_TAPRIO_ATTR_TXTIME_DELAY = 11,
	TCA_TAPRIO_ATTR_TC_ENTRY = 12,
	__TCA_TAPRIO_ATTR_MAX = 13,
};

enum {
	TCA_TAPRIO_OFFLOAD_STATS_PAD = 1,
	TCA_TAPRIO_OFFLOAD_STATS_WINDOW_DROPS = 2,
	TCA_TAPRIO_OFFLOAD_STATS_TX_OVERRUNS = 3,
	__TCA_TAPRIO_OFFLOAD_STATS_CNT = 4,
	TCA_TAPRIO_OFFLOAD_STATS_MAX = 3,
};

enum {
	TCA_TAPRIO_SCHED_ENTRY_UNSPEC = 0,
	TCA_TAPRIO_SCHED_ENTRY_INDEX = 1,
	TCA_TAPRIO_SCHED_ENTRY_CMD = 2,
	TCA_TAPRIO_SCHED_ENTRY_GATE_MASK = 3,
	TCA_TAPRIO_SCHED_ENTRY_INTERVAL = 4,
	__TCA_TAPRIO_SCHED_ENTRY_MAX = 5,
};

enum {
	TCA_TAPRIO_SCHED_UNSPEC = 0,
	TCA_TAPRIO_SCHED_ENTRY = 1,
	__TCA_TAPRIO_SCHED_MAX = 2,
};

enum {
	TCA_TAPRIO_TC_ENTRY_UNSPEC = 0,
	TCA_TAPRIO_TC_ENTRY_INDEX = 1,
	TCA_TAPRIO_TC_ENTRY_MAX_SDU = 2,
	TCA_TAPRIO_TC_ENTRY_FP = 3,
	__TCA_TAPRIO_TC_ENTRY_CNT = 4,
	TCA_TAPRIO_TC_ENTRY_MAX = 3,
};

enum {
	TCA_TBF_UNSPEC = 0,
	TCA_TBF_PARMS = 1,
	TCA_TBF_RTAB = 2,
	TCA_TBF_PTAB = 3,
	TCA_TBF_RATE64 = 4,
	TCA_TBF_PRATE64 = 5,
	TCA_TBF_BURST = 6,
	TCA_TBF_PBURST = 7,
	TCA_TBF_PAD = 8,
	__TCA_TBF_MAX = 9,
};

enum {
	TCA_TUNNEL_KEY_ENC_OPTS_UNSPEC = 0,
	TCA_TUNNEL_KEY_ENC_OPTS_GENEVE = 1,
	TCA_TUNNEL_KEY_ENC_OPTS_VXLAN = 2,
	TCA_TUNNEL_KEY_ENC_OPTS_ERSPAN = 3,
	__TCA_TUNNEL_KEY_ENC_OPTS_MAX = 4,
};

enum {
	TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_UNSPEC = 0,
	TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_VER = 1,
	TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_INDEX = 2,
	TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_DIR = 3,
	TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_HWID = 4,
	__TCA_TUNNEL_KEY_ENC_OPT_ERSPAN_MAX = 5,
};

enum {
	TCA_TUNNEL_KEY_ENC_OPT_GENEVE_UNSPEC = 0,
	TCA_TUNNEL_KEY_ENC_OPT_GENEVE_CLASS = 1,
	TCA_TUNNEL_KEY_ENC_OPT_GENEVE_TYPE = 2,
	TCA_TUNNEL_KEY_ENC_OPT_GENEVE_DATA = 3,
	__TCA_TUNNEL_KEY_ENC_OPT_GENEVE_MAX = 4,
};

enum {
	TCA_TUNNEL_KEY_ENC_OPT_VXLAN_UNSPEC = 0,
	TCA_TUNNEL_KEY_ENC_OPT_VXLAN_GBP = 1,
	__TCA_TUNNEL_KEY_ENC_OPT_VXLAN_MAX = 2,
};

enum {
	TCA_TUNNEL_KEY_UNSPEC = 0,
	TCA_TUNNEL_KEY_TM = 1,
	TCA_TUNNEL_KEY_PARMS = 2,
	TCA_TUNNEL_KEY_ENC_IPV4_SRC = 3,
	TCA_TUNNEL_KEY_ENC_IPV4_DST = 4,
	TCA_TUNNEL_KEY_ENC_IPV6_SRC = 5,
	TCA_TUNNEL_KEY_ENC_IPV6_DST = 6,
	TCA_TUNNEL_KEY_ENC_KEY_ID = 7,
	TCA_TUNNEL_KEY_PAD = 8,
	TCA_TUNNEL_KEY_ENC_DST_PORT = 9,
	TCA_TUNNEL_KEY_NO_CSUM = 10,
	TCA_TUNNEL_KEY_ENC_OPTS = 11,
	TCA_TUNNEL_KEY_ENC_TOS = 12,
	TCA_TUNNEL_KEY_ENC_TTL = 13,
	TCA_TUNNEL_KEY_NO_FRAG = 14,
	__TCA_TUNNEL_KEY_MAX = 15,
};

enum {
	TCA_U32_UNSPEC = 0,
	TCA_U32_CLASSID = 1,
	TCA_U32_HASH = 2,
	TCA_U32_LINK = 3,
	TCA_U32_DIVISOR = 4,
	TCA_U32_SEL = 5,
	TCA_U32_POLICE = 6,
	TCA_U32_ACT = 7,
	TCA_U32_INDEV = 8,
	TCA_U32_PCNT = 9,
	TCA_U32_MARK = 10,
	TCA_U32_FLAGS = 11,
	TCA_U32_PAD = 12,
	__TCA_U32_MAX = 13,
};

enum {
	TCA_UNSPEC = 0,
	TCA_KIND = 1,
	TCA_OPTIONS = 2,
	TCA_STATS = 3,
	TCA_XSTATS = 4,
	TCA_RATE = 5,
	TCA_FCNT = 6,
	TCA_STATS2 = 7,
	TCA_STAB = 8,
	TCA_PAD = 9,
	TCA_DUMP_INVISIBLE = 10,
	TCA_CHAIN = 11,
	TCA_HW_OFFLOAD = 12,
	TCA_INGRESS_BLOCK = 13,
	TCA_EGRESS_BLOCK = 14,
	TCA_DUMP_FLAGS = 15,
	TCA_EXT_WARN_MSG = 16,
	__TCA_MAX = 17,
};

enum {
	TCA_VLAN_UNSPEC = 0,
	TCA_VLAN_TM = 1,
	TCA_VLAN_PARMS = 2,
	TCA_VLAN_PUSH_VLAN_ID = 3,
	TCA_VLAN_PUSH_VLAN_PROTOCOL = 4,
	TCA_VLAN_PAD = 5,
	TCA_VLAN_PUSH_VLAN_PRIORITY = 6,
	TCA_VLAN_PUSH_ETH_DST = 7,
	TCA_VLAN_PUSH_ETH_SRC = 8,
	__TCA_VLAN_MAX = 9,
};

enum {
	TCF_EM_ALIGN_U8 = 1,
	TCF_EM_ALIGN_U16 = 2,
	TCF_EM_ALIGN_U32 = 4,
};

enum {
	TCF_EM_OPND_EQ = 0,
	TCF_EM_OPND_GT = 1,
	TCF_EM_OPND_LT = 2,
};

enum {
	TCF_LAYER_LINK = 0,
	TCF_LAYER_NETWORK = 1,
	TCF_LAYER_TRANSPORT = 2,
	__TCF_LAYER_MAX = 3,
};

enum {
	TCF_META_ID_VALUE = 0,
	TCF_META_ID_RANDOM = 1,
	TCF_META_ID_LOADAVG_0 = 2,
	TCF_META_ID_LOADAVG_1 = 3,
	TCF_META_ID_LOADAVG_2 = 4,
	TCF_META_ID_DEV = 5,
	TCF_META_ID_PRIORITY = 6,
	TCF_META_ID_PROTOCOL = 7,
	TCF_META_ID_PKTTYPE = 8,
	TCF_META_ID_PKTLEN = 9,
	TCF_META_ID_DATALEN = 10,
	TCF_META_ID_MACLEN = 11,
	TCF_META_ID_NFMARK = 12,
	TCF_META_ID_TCINDEX = 13,
	TCF_META_ID_RTCLASSID = 14,
	TCF_META_ID_RTIIF = 15,
	TCF_META_ID_SK_FAMILY = 16,
	TCF_META_ID_SK_STATE = 17,
	TCF_META_ID_SK_REUSE = 18,
	TCF_META_ID_SK_BOUND_IF = 19,
	TCF_META_ID_SK_REFCNT = 20,
	TCF_META_ID_SK_SHUTDOWN = 21,
	TCF_META_ID_SK_PROTO = 22,
	TCF_META_ID_SK_TYPE = 23,
	TCF_META_ID_SK_RCVBUF = 24,
	TCF_META_ID_SK_RMEM_ALLOC = 25,
	TCF_META_ID_SK_WMEM_ALLOC = 26,
	TCF_META_ID_SK_OMEM_ALLOC = 27,
	TCF_META_ID_SK_WMEM_QUEUED = 28,
	TCF_META_ID_SK_RCV_QLEN = 29,
	TCF_META_ID_SK_SND_QLEN = 30,
	TCF_META_ID_SK_ERR_QLEN = 31,
	TCF_META_ID_SK_FORWARD_ALLOCS = 32,
	TCF_META_ID_SK_SNDBUF = 33,
	TCF_META_ID_SK_ALLOCS = 34,
	__TCF_META_ID_SK_ROUTE_CAPS = 35,
	TCF_META_ID_SK_HASH = 36,
	TCF_META_ID_SK_LINGERTIME = 37,
	TCF_META_ID_SK_ACK_BACKLOG = 38,
	TCF_META_ID_SK_MAX_ACK_BACKLOG = 39,
	TCF_META_ID_SK_PRIO = 40,
	TCF_META_ID_SK_RCVLOWAT = 41,
	TCF_META_ID_SK_RCVTIMEO = 42,
	TCF_META_ID_SK_SNDTIMEO = 43,
	TCF_META_ID_SK_SENDMSG_OFF = 44,
	TCF_META_ID_SK_WRITE_PENDING = 45,
	TCF_META_ID_VLAN_TAG = 46,
	TCF_META_ID_RXHASH = 47,
	__TCF_META_ID_MAX = 48,
};

enum {
	TCF_META_TYPE_VAR = 0,
	TCF_META_TYPE_INT = 1,
	__TCF_META_TYPE_MAX = 2,
};

enum {
	TCPF_ESTABLISHED = 2,
	TCPF_SYN_SENT = 4,
	TCPF_SYN_RECV = 8,
	TCPF_FIN_WAIT1 = 16,
	TCPF_FIN_WAIT2 = 32,
	TCPF_TIME_WAIT = 64,
	TCPF_CLOSE = 128,
	TCPF_CLOSE_WAIT = 256,
	TCPF_LAST_ACK = 512,
	TCPF_LISTEN = 1024,
	TCPF_CLOSING = 2048,
	TCPF_NEW_SYN_RECV = 4096,
	TCPF_BOUND_INACTIVE = 8192,
};

enum {
	TCP_BPF_BASE = 0,
	TCP_BPF_TX = 1,
	TCP_BPF_RX = 2,
	TCP_BPF_TXRX = 3,
	TCP_BPF_NUM_CFGS = 4,
};

enum {
	TCP_BPF_IPV4 = 0,
	TCP_BPF_IPV6 = 1,
	TCP_BPF_NUM_PROTS = 2,
};

enum {
	TCP_BPF_IW = 1001,
	TCP_BPF_SNDCWND_CLAMP = 1002,
	TCP_BPF_DELACK_MAX = 1003,
	TCP_BPF_RTO_MIN = 1004,
	TCP_BPF_SYN = 1005,
	TCP_BPF_SYN_IP = 1006,
	TCP_BPF_SYN_MAC = 1007,
	TCP_BPF_SOCK_OPS_CB_FLAGS = 1008,
};

enum {
	TCP_CMSG_INQ = 1,
	TCP_CMSG_TS = 2,
};

enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT = 2,
	TCP_SYN_RECV = 3,
	TCP_FIN_WAIT1 = 4,
	TCP_FIN_WAIT2 = 5,
	TCP_TIME_WAIT = 6,
	TCP_CLOSE = 7,
	TCP_CLOSE_WAIT = 8,
	TCP_LAST_ACK = 9,
	TCP_LISTEN = 10,
	TCP_CLOSING = 11,
	TCP_NEW_SYN_RECV = 12,
	TCP_BOUND_INACTIVE = 13,
	TCP_MAX_STATES = 14,
};

enum {
	TCP_FLAG_CWR = 32768,
	TCP_FLAG_ECE = 16384,
	TCP_FLAG_URG = 8192,
	TCP_FLAG_ACK = 4096,
	TCP_FLAG_PSH = 2048,
	TCP_FLAG_RST = 1024,
	TCP_FLAG_SYN = 512,
	TCP_FLAG_FIN = 256,
	TCP_RESERVED_BITS = 15,
	TCP_DATA_OFFSET = 240,
};

enum {
	TCP_METRICS_ATTR_UNSPEC = 0,
	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
	TCP_METRICS_ATTR_AGE = 3,
	TCP_METRICS_ATTR_TW_TSVAL = 4,
	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
	TCP_METRICS_ATTR_VALS = 6,
	TCP_METRICS_ATTR_FOPEN_MSS = 7,
	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
	TCP_METRICS_ATTR_PAD = 13,
	__TCP_METRICS_ATTR_MAX = 14,
};

enum {
	TCP_METRICS_CMD_UNSPEC = 0,
	TCP_METRICS_CMD_GET = 1,
	TCP_METRICS_CMD_DEL = 2,
	__TCP_METRICS_CMD_MAX = 3,
};

enum {
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM = 1,
	TCP_MIB_RTOMIN = 2,
	TCP_MIB_RTOMAX = 3,
	TCP_MIB_MAXCONN = 4,
	TCP_MIB_ACTIVEOPENS = 5,
	TCP_MIB_PASSIVEOPENS = 6,
	TCP_MIB_ATTEMPTFAILS = 7,
	TCP_MIB_ESTABRESETS = 8,
	TCP_MIB_CURRESTAB = 9,
	TCP_MIB_INSEGS = 10,
	TCP_MIB_OUTSEGS = 11,
	TCP_MIB_RETRANSSEGS = 12,
	TCP_MIB_INERRS = 13,
	TCP_MIB_OUTRSTS = 14,
	TCP_MIB_CSUMERRORS = 15,
	__TCP_MIB_MAX = 16,
};

enum {
	TCP_NLA_PAD = 0,
	TCP_NLA_BUSY = 1,
	TCP_NLA_RWND_LIMITED = 2,
	TCP_NLA_SNDBUF_LIMITED = 3,
	TCP_NLA_DATA_SEGS_OUT = 4,
	TCP_NLA_TOTAL_RETRANS = 5,
	TCP_NLA_PACING_RATE = 6,
	TCP_NLA_DELIVERY_RATE = 7,
	TCP_NLA_SND_CWND = 8,
	TCP_NLA_REORDERING = 9,
	TCP_NLA_MIN_RTT = 10,
	TCP_NLA_RECUR_RETRANS = 11,
	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
	TCP_NLA_SNDQ_SIZE = 13,
	TCP_NLA_CA_STATE = 14,
	TCP_NLA_SND_SSTHRESH = 15,
	TCP_NLA_DELIVERED = 16,
	TCP_NLA_DELIVERED_CE = 17,
	TCP_NLA_BYTES_SENT = 18,
	TCP_NLA_BYTES_RETRANS = 19,
	TCP_NLA_DSACK_DUPS = 20,
	TCP_NLA_REORD_SEEN = 21,
	TCP_NLA_SRTT = 22,
	TCP_NLA_TIMEOUT_REHASH = 23,
	TCP_NLA_BYTES_NOTSENT = 24,
	TCP_NLA_EDT = 25,
	TCP_NLA_TTL = 26,
	TCP_NLA_REHASH = 27,
};

enum {
	TCP_NO_QUEUE = 0,
	TCP_RECV_QUEUE = 1,
	TCP_SEND_QUEUE = 2,
	TCP_QUEUES_NR = 3,
};

enum {
	TC_FP_EXPRESS = 1,
	TC_FP_PREEMPTIBLE = 2,
};

enum {
	TC_MQPRIO_HW_OFFLOAD_NONE = 0,
	TC_MQPRIO_HW_OFFLOAD_TCS = 1,
	__TC_MQPRIO_HW_OFFLOAD_MAX = 2,
};

enum {
	TC_MQPRIO_MODE_DCB = 0,
	TC_MQPRIO_MODE_CHANNEL = 1,
	__TC_MQPRIO_MODE_MAX = 2,
};

enum {
	TC_MQPRIO_SHAPER_DCB = 0,
	TC_MQPRIO_SHAPER_BW_RATE = 1,
	__TC_MQPRIO_SHAPER_MAX = 2,
};

enum {
	TEST_NONE = 0,
	TEST_CORE = 1,
	TEST_CPUS = 2,
	TEST_PLATFORM = 3,
	TEST_DEVICES = 4,
	TEST_FREEZER = 5,
	__TEST_AFTER_LAST = 6,
};

enum {
	TIPC_DUMP_NONE = 0,
	TIPC_DUMP_TRANSMQ = 1,
	TIPC_DUMP_BACKLOGQ = 2,
	TIPC_DUMP_DEFERDQ = 4,
	TIPC_DUMP_INPUTQ = 8,
	TIPC_DUMP_WAKEUP = 16,
	TIPC_DUMP_SK_SNDQ = 256,
	TIPC_DUMP_SK_RCVQ = 512,
	TIPC_DUMP_SK_BKLGQ = 1024,
	TIPC_DUMP_ALL = 65535,
};

enum {
	TIPC_LINK_UP_EVT = 1,
	TIPC_LINK_DOWN_EVT = 2,
	TIPC_LINK_SND_STATE = 4,
};

enum {
	TIPC_LISTEN = 10,
	TIPC_ESTABLISHED = 1,
	TIPC_OPEN = 7,
	TIPC_DISCONNECTING = 8,
	TIPC_CONNECTING = 2,
};

enum {
	TIPC_NLA_BEARER_UNSPEC = 0,
	TIPC_NLA_BEARER_NAME = 1,
	TIPC_NLA_BEARER_PROP = 2,
	TIPC_NLA_BEARER_DOMAIN = 3,
	TIPC_NLA_BEARER_UDP_OPTS = 4,
	__TIPC_NLA_BEARER_MAX = 5,
	TIPC_NLA_BEARER_MAX = 4,
};

enum {
	TIPC_NLA_CON_UNSPEC = 0,
	TIPC_NLA_CON_FLAG = 1,
	TIPC_NLA_CON_NODE = 2,
	TIPC_NLA_CON_SOCK = 3,
	TIPC_NLA_CON_TYPE = 4,
	TIPC_NLA_CON_INST = 5,
	__TIPC_NLA_CON_MAX = 6,
	TIPC_NLA_CON_MAX = 5,
};

enum {
	TIPC_NLA_LINK_UNSPEC = 0,
	TIPC_NLA_LINK_NAME = 1,
	TIPC_NLA_LINK_DEST = 2,
	TIPC_NLA_LINK_MTU = 3,
	TIPC_NLA_LINK_BROADCAST = 4,
	TIPC_NLA_LINK_UP = 5,
	TIPC_NLA_LINK_ACTIVE = 6,
	TIPC_NLA_LINK_PROP = 7,
	TIPC_NLA_LINK_STATS = 8,
	TIPC_NLA_LINK_RX = 9,
	TIPC_NLA_LINK_TX = 10,
	__TIPC_NLA_LINK_MAX = 11,
	TIPC_NLA_LINK_MAX = 10,
};

enum {
	TIPC_NLA_MEDIA_UNSPEC = 0,
	TIPC_NLA_MEDIA_NAME = 1,
	TIPC_NLA_MEDIA_PROP = 2,
	__TIPC_NLA_MEDIA_MAX = 3,
	TIPC_NLA_MEDIA_MAX = 2,
};

enum {
	TIPC_NLA_MON_PEER_UNSPEC = 0,
	TIPC_NLA_MON_PEER_ADDR = 1,
	TIPC_NLA_MON_PEER_DOMGEN = 2,
	TIPC_NLA_MON_PEER_APPLIED = 3,
	TIPC_NLA_MON_PEER_UPMAP = 4,
	TIPC_NLA_MON_PEER_MEMBERS = 5,
	TIPC_NLA_MON_PEER_UP = 6,
	TIPC_NLA_MON_PEER_HEAD = 7,
	TIPC_NLA_MON_PEER_LOCAL = 8,
	TIPC_NLA_MON_PEER_PAD = 9,
	__TIPC_NLA_MON_PEER_MAX = 10,
	TIPC_NLA_MON_PEER_MAX = 9,
};

enum {
	TIPC_NLA_MON_UNSPEC = 0,
	TIPC_NLA_MON_ACTIVATION_THRESHOLD = 1,
	TIPC_NLA_MON_REF = 2,
	TIPC_NLA_MON_ACTIVE = 3,
	TIPC_NLA_MON_BEARER_NAME = 4,
	TIPC_NLA_MON_PEERCNT = 5,
	TIPC_NLA_MON_LISTGEN = 6,
	__TIPC_NLA_MON_MAX = 7,
	TIPC_NLA_MON_MAX = 6,
};

enum {
	TIPC_NLA_NAME_TABLE_UNSPEC = 0,
	TIPC_NLA_NAME_TABLE_PUBL = 1,
	__TIPC_NLA_NAME_TABLE_MAX = 2,
	TIPC_NLA_NAME_TABLE_MAX = 1,
};

enum {
	TIPC_NLA_NET_UNSPEC = 0,
	TIPC_NLA_NET_ID = 1,
	TIPC_NLA_NET_ADDR = 2,
	TIPC_NLA_NET_NODEID = 3,
	TIPC_NLA_NET_NODEID_W1 = 4,
	TIPC_NLA_NET_ADDR_LEGACY = 5,
	__TIPC_NLA_NET_MAX = 6,
	TIPC_NLA_NET_MAX = 5,
};

enum {
	TIPC_NLA_NODE_UNSPEC = 0,
	TIPC_NLA_NODE_ADDR = 1,
	TIPC_NLA_NODE_UP = 2,
	TIPC_NLA_NODE_ID = 3,
	TIPC_NLA_NODE_KEY = 4,
	TIPC_NLA_NODE_KEY_MASTER = 5,
	TIPC_NLA_NODE_REKEYING = 6,
	__TIPC_NLA_NODE_MAX = 7,
	TIPC_NLA_NODE_MAX = 6,
};

enum {
	TIPC_NLA_PROP_UNSPEC = 0,
	TIPC_NLA_PROP_PRIO = 1,
	TIPC_NLA_PROP_TOL = 2,
	TIPC_NLA_PROP_WIN = 3,
	TIPC_NLA_PROP_MTU = 4,
	TIPC_NLA_PROP_BROADCAST = 5,
	TIPC_NLA_PROP_BROADCAST_RATIO = 6,
	__TIPC_NLA_PROP_MAX = 7,
	TIPC_NLA_PROP_MAX = 6,
};

enum {
	TIPC_NLA_PUBL_UNSPEC = 0,
	TIPC_NLA_PUBL_TYPE = 1,
	TIPC_NLA_PUBL_LOWER = 2,
	TIPC_NLA_PUBL_UPPER = 3,
	TIPC_NLA_PUBL_SCOPE = 4,
	TIPC_NLA_PUBL_NODE = 5,
	TIPC_NLA_PUBL_REF = 6,
	TIPC_NLA_PUBL_KEY = 7,
	__TIPC_NLA_PUBL_MAX = 8,
	TIPC_NLA_PUBL_MAX = 7,
};

enum {
	TIPC_NLA_SOCK_GROUP_ID = 0,
	TIPC_NLA_SOCK_GROUP_OPEN = 1,
	TIPC_NLA_SOCK_GROUP_NODE_SCOPE = 2,
	TIPC_NLA_SOCK_GROUP_CLUSTER_SCOPE = 3,
	TIPC_NLA_SOCK_GROUP_INSTANCE = 4,
	TIPC_NLA_SOCK_GROUP_BC_SEND_NEXT = 5,
	__TIPC_NLA_SOCK_GROUP_MAX = 6,
	TIPC_NLA_SOCK_GROUP_MAX = 5,
};

enum {
	TIPC_NLA_SOCK_STAT_RCVQ = 0,
	TIPC_NLA_SOCK_STAT_SENDQ = 1,
	TIPC_NLA_SOCK_STAT_LINK_CONG = 2,
	TIPC_NLA_SOCK_STAT_CONN_CONG = 3,
	TIPC_NLA_SOCK_STAT_DROP = 4,
	__TIPC_NLA_SOCK_STAT_MAX = 5,
	TIPC_NLA_SOCK_STAT_MAX = 4,
};

enum {
	TIPC_NLA_SOCK_UNSPEC = 0,
	TIPC_NLA_SOCK_ADDR = 1,
	TIPC_NLA_SOCK_REF = 2,
	TIPC_NLA_SOCK_CON = 3,
	TIPC_NLA_SOCK_HAS_PUBL = 4,
	TIPC_NLA_SOCK_STAT = 5,
	TIPC_NLA_SOCK_TYPE = 6,
	TIPC_NLA_SOCK_INO = 7,
	TIPC_NLA_SOCK_UID = 8,
	TIPC_NLA_SOCK_TIPC_STATE = 9,
	TIPC_NLA_SOCK_COOKIE = 10,
	TIPC_NLA_SOCK_PAD = 11,
	TIPC_NLA_SOCK_GROUP = 12,
	__TIPC_NLA_SOCK_MAX = 13,
	TIPC_NLA_SOCK_MAX = 12,
};

enum {
	TIPC_NLA_STATS_UNSPEC = 0,
	TIPC_NLA_STATS_RX_INFO = 1,
	TIPC_NLA_STATS_RX_FRAGMENTS = 2,
	TIPC_NLA_STATS_RX_FRAGMENTED = 3,
	TIPC_NLA_STATS_RX_BUNDLES = 4,
	TIPC_NLA_STATS_RX_BUNDLED = 5,
	TIPC_NLA_STATS_TX_INFO = 6,
	TIPC_NLA_STATS_TX_FRAGMENTS = 7,
	TIPC_NLA_STATS_TX_FRAGMENTED = 8,
	TIPC_NLA_STATS_TX_BUNDLES = 9,
	TIPC_NLA_STATS_TX_BUNDLED = 10,
	TIPC_NLA_STATS_MSG_PROF_TOT = 11,
	TIPC_NLA_STATS_MSG_LEN_CNT = 12,
	TIPC_NLA_STATS_MSG_LEN_TOT = 13,
	TIPC_NLA_STATS_MSG_LEN_P0 = 14,
	TIPC_NLA_STATS_MSG_LEN_P1 = 15,
	TIPC_NLA_STATS_MSG_LEN_P2 = 16,
	TIPC_NLA_STATS_MSG_LEN_P3 = 17,
	TIPC_NLA_STATS_MSG_LEN_P4 = 18,
	TIPC_NLA_STATS_MSG_LEN_P5 = 19,
	TIPC_NLA_STATS_MSG_LEN_P6 = 20,
	TIPC_NLA_STATS_RX_STATES = 21,
	TIPC_NLA_STATS_RX_PROBES = 22,
	TIPC_NLA_STATS_RX_NACKS = 23,
	TIPC_NLA_STATS_RX_DEFERRED = 24,
	TIPC_NLA_STATS_TX_STATES = 25,
	TIPC_NLA_STATS_TX_PROBES = 26,
	TIPC_NLA_STATS_TX_NACKS = 27,
	TIPC_NLA_STATS_TX_ACKS = 28,
	TIPC_NLA_STATS_RETRANSMITTED = 29,
	TIPC_NLA_STATS_DUPLICATES = 30,
	TIPC_NLA_STATS_LINK_CONGS = 31,
	TIPC_NLA_STATS_MAX_QUEUE = 32,
	TIPC_NLA_STATS_AVG_QUEUE = 33,
	__TIPC_NLA_STATS_MAX = 34,
	TIPC_NLA_STATS_MAX = 33,
};

enum {
	TIPC_NLA_UDP_UNSPEC = 0,
	TIPC_NLA_UDP_LOCAL = 1,
	TIPC_NLA_UDP_REMOTE = 2,
	TIPC_NLA_UDP_MULTI_REMOTEIP = 3,
	__TIPC_NLA_UDP_MAX = 4,
	TIPC_NLA_UDP_MAX = 3,
};

enum {
	TIPC_NLA_UNSPEC = 0,
	TIPC_NLA_BEARER = 1,
	TIPC_NLA_SOCK = 2,
	TIPC_NLA_PUBL = 3,
	TIPC_NLA_LINK = 4,
	TIPC_NLA_MEDIA = 5,
	TIPC_NLA_NODE = 6,
	TIPC_NLA_NET = 7,
	TIPC_NLA_NAME_TABLE = 8,
	TIPC_NLA_MON = 9,
	TIPC_NLA_MON_PEER = 10,
	__TIPC_NLA_MAX = 11,
	TIPC_NLA_MAX = 10,
};

enum {
	TIPC_NL_UNSPEC = 0,
	TIPC_NL_LEGACY = 1,
	TIPC_NL_BEARER_DISABLE = 2,
	TIPC_NL_BEARER_ENABLE = 3,
	TIPC_NL_BEARER_GET = 4,
	TIPC_NL_BEARER_SET = 5,
	TIPC_NL_SOCK_GET = 6,
	TIPC_NL_PUBL_GET = 7,
	TIPC_NL_LINK_GET = 8,
	TIPC_NL_LINK_SET = 9,
	TIPC_NL_LINK_RESET_STATS = 10,
	TIPC_NL_MEDIA_GET = 11,
	TIPC_NL_MEDIA_SET = 12,
	TIPC_NL_NODE_GET = 13,
	TIPC_NL_NET_GET = 14,
	TIPC_NL_NET_SET = 15,
	TIPC_NL_NAME_TABLE_GET = 16,
	TIPC_NL_MON_SET = 17,
	TIPC_NL_MON_GET = 18,
	TIPC_NL_MON_PEER_GET = 19,
	TIPC_NL_PEER_REMOVE = 20,
	TIPC_NL_BEARER_ADD = 21,
	TIPC_NL_UDP_GET_REMOTEIP = 22,
	TIPC_NL_KEY_SET = 23,
	TIPC_NL_KEY_FLUSH = 24,
	TIPC_NL_ADDR_LEGACY_GET = 25,
	__TIPC_NL_CMD_MAX = 26,
	TIPC_NL_CMD_MAX = 25,
};

enum {
	TIPC_NOTIFY_NODE_DOWN = 8,
	TIPC_NOTIFY_NODE_UP = 16,
	TIPC_NOTIFY_LINK_UP = 64,
	TIPC_NOTIFY_LINK_DOWN = 128,
};

enum {
	TIPC_SYN_BIT = 1,
	TIPC_BCAST_SYNCH = 2,
	TIPC_BCAST_STATE_NACK = 4,
	TIPC_BLOCK_FLOWCTL = 8,
	TIPC_BCAST_RCAST = 16,
	TIPC_NODE_ID128 = 32,
	TIPC_LINK_PROTO_SEQNO = 64,
	TIPC_MCAST_RBCTL = 128,
	TIPC_GAP_ACK_BLOCK = 256,
	TIPC_TUNNEL_ENHANCED = 512,
	TIPC_NAGLE = 1024,
	TIPC_NAMED_BCAST = 2048,
};

enum {
	TLSV4 = 0,
	TLSV6 = 1,
	TLS_NUM_PROTS = 2,
};

enum {
	TLS_ALERT_DESC_CLOSE_NOTIFY = 0,
	TLS_ALERT_DESC_UNEXPECTED_MESSAGE = 10,
	TLS_ALERT_DESC_BAD_RECORD_MAC = 20,
	TLS_ALERT_DESC_RECORD_OVERFLOW = 22,
	TLS_ALERT_DESC_HANDSHAKE_FAILURE = 40,
	TLS_ALERT_DESC_BAD_CERTIFICATE = 42,
	TLS_ALERT_DESC_UNSUPPORTED_CERTIFICATE = 43,
	TLS_ALERT_DESC_CERTIFICATE_REVOKED = 44,
	TLS_ALERT_DESC_CERTIFICATE_EXPIRED = 45,
	TLS_ALERT_DESC_CERTIFICATE_UNKNOWN = 46,
	TLS_ALERT_DESC_ILLEGAL_PARAMETER = 47,
	TLS_ALERT_DESC_UNKNOWN_CA = 48,
	TLS_ALERT_DESC_ACCESS_DENIED = 49,
	TLS_ALERT_DESC_DECODE_ERROR = 50,
	TLS_ALERT_DESC_DECRYPT_ERROR = 51,
	TLS_ALERT_DESC_TOO_MANY_CIDS_REQUESTED = 52,
	TLS_ALERT_DESC_PROTOCOL_VERSION = 70,
	TLS_ALERT_DESC_INSUFFICIENT_SECURITY = 71,
	TLS_ALERT_DESC_INTERNAL_ERROR = 80,
	TLS_ALERT_DESC_INAPPROPRIATE_FALLBACK = 86,
	TLS_ALERT_DESC_USER_CANCELED = 90,
	TLS_ALERT_DESC_MISSING_EXTENSION = 109,
	TLS_ALERT_DESC_UNSUPPORTED_EXTENSION = 110,
	TLS_ALERT_DESC_UNRECOGNIZED_NAME = 112,
	TLS_ALERT_DESC_BAD_CERTIFICATE_STATUS_RESPONSE = 113,
	TLS_ALERT_DESC_UNKNOWN_PSK_IDENTITY = 115,
	TLS_ALERT_DESC_CERTIFICATE_REQUIRED = 116,
	TLS_ALERT_DESC_NO_APPLICATION_PROTOCOL = 120,
};

enum {
	TLS_ALERT_LEVEL_WARNING = 1,
	TLS_ALERT_LEVEL_FATAL = 2,
};

enum {
	TLS_BASE = 0,
	TLS_SW = 1,
	TLS_HW = 2,
	TLS_HW_RECORD = 3,
	TLS_NUM_CONFIG = 4,
};

enum {
	TLS_INFO_UNSPEC = 0,
	TLS_INFO_VERSION = 1,
	TLS_INFO_CIPHER = 2,
	TLS_INFO_TXCONF = 3,
	TLS_INFO_RXCONF = 4,
	TLS_INFO_ZC_RO_TX = 5,
	TLS_INFO_RX_NO_PAD = 6,
	__TLS_INFO_MAX = 7,
};

enum {
	TLS_NO_KEYRING = 0,
	TLS_NO_PEERID = 0,
	TLS_NO_CERT = 0,
	TLS_NO_PRIVKEY = 0,
};

enum {
	TLS_RECORD_TYPE_CHANGE_CIPHER_SPEC = 20,
	TLS_RECORD_TYPE_ALERT = 21,
	TLS_RECORD_TYPE_HANDSHAKE = 22,
	TLS_RECORD_TYPE_DATA = 23,
	TLS_RECORD_TYPE_HEARTBEAT = 24,
	TLS_RECORD_TYPE_TLS12_CID = 25,
	TLS_RECORD_TYPE_ACK = 26,
};

enum {
	TOO_MANY_CLOSE = -1,
	TOO_MANY_OPEN = -2,
	MISSING_QUOTE = -3,
};

enum {
	TP_ERR_FILE_NOT_FOUND = 0,
	TP_ERR_NO_REGULAR_FILE = 1,
	TP_ERR_BAD_REFCNT = 2,
	TP_ERR_REFCNT_OPEN_BRACE = 3,
	TP_ERR_BAD_REFCNT_SUFFIX = 4,
	TP_ERR_BAD_UPROBE_OFFS = 5,
	TP_ERR_BAD_MAXACT_TYPE = 6,
	TP_ERR_BAD_MAXACT = 7,
	TP_ERR_MAXACT_TOO_BIG = 8,
	TP_ERR_BAD_PROBE_ADDR = 9,
	TP_ERR_NON_UNIQ_SYMBOL = 10,
	TP_ERR_BAD_RETPROBE = 11,
	TP_ERR_NO_TRACEPOINT = 12,
	TP_ERR_BAD_TP_NAME = 13,
	TP_ERR_BAD_ADDR_SUFFIX = 14,
	TP_ERR_NO_GROUP_NAME = 15,
	TP_ERR_GROUP_TOO_LONG = 16,
	TP_ERR_BAD_GROUP_NAME = 17,
	TP_ERR_NO_EVENT_NAME = 18,
	TP_ERR_EVENT_TOO_LONG = 19,
	TP_ERR_BAD_EVENT_NAME = 20,
	TP_ERR_EVENT_EXIST = 21,
	TP_ERR_RETVAL_ON_PROBE = 22,
	TP_ERR_NO_RETVAL = 23,
	TP_ERR_BAD_STACK_NUM = 24,
	TP_ERR_BAD_ARG_NUM = 25,
	TP_ERR_BAD_VAR = 26,
	TP_ERR_BAD_REG_NAME = 27,
	TP_ERR_BAD_MEM_ADDR = 28,
	TP_ERR_BAD_IMM = 29,
	TP_ERR_IMMSTR_NO_CLOSE = 30,
	TP_ERR_FILE_ON_KPROBE = 31,
	TP_ERR_BAD_FILE_OFFS = 32,
	TP_ERR_SYM_ON_UPROBE = 33,
	TP_ERR_TOO_MANY_OPS = 34,
	TP_ERR_DEREF_NEED_BRACE = 35,
	TP_ERR_BAD_DEREF_OFFS = 36,
	TP_ERR_DEREF_OPEN_BRACE = 37,
	TP_ERR_COMM_CANT_DEREF = 38,
	TP_ERR_BAD_FETCH_ARG = 39,
	TP_ERR_ARRAY_NO_CLOSE = 40,
	TP_ERR_BAD_ARRAY_SUFFIX = 41,
	TP_ERR_BAD_ARRAY_NUM = 42,
	TP_ERR_ARRAY_TOO_BIG = 43,
	TP_ERR_BAD_TYPE = 44,
	TP_ERR_BAD_STRING = 45,
	TP_ERR_BAD_SYMSTRING = 46,
	TP_ERR_BAD_BITFIELD = 47,
	TP_ERR_ARG_NAME_TOO_LONG = 48,
	TP_ERR_NO_ARG_NAME = 49,
	TP_ERR_BAD_ARG_NAME = 50,
	TP_ERR_USED_ARG_NAME = 51,
	TP_ERR_ARG_TOO_LONG = 52,
	TP_ERR_NO_ARG_BODY = 53,
	TP_ERR_BAD_INSN_BNDRY = 54,
	TP_ERR_FAIL_REG_PROBE = 55,
	TP_ERR_DIFF_PROBE_TYPE = 56,
	TP_ERR_DIFF_ARG_TYPE = 57,
	TP_ERR_SAME_PROBE = 58,
	TP_ERR_NO_EVENT_INFO = 59,
	TP_ERR_BAD_ATTACH_EVENT = 60,
	TP_ERR_BAD_ATTACH_ARG = 61,
	TP_ERR_NO_EP_FILTER = 62,
	TP_ERR_NOSUP_BTFARG = 63,
	TP_ERR_NO_BTFARG = 64,
	TP_ERR_NO_BTF_ENTRY = 65,
	TP_ERR_BAD_VAR_ARGS = 66,
	TP_ERR_NOFENTRY_ARGS = 67,
	TP_ERR_DOUBLE_ARGS = 68,
	TP_ERR_ARGS_2LONG = 69,
	TP_ERR_ARGIDX_2BIG = 70,
	TP_ERR_NO_PTR_STRCT = 71,
	TP_ERR_NOSUP_DAT_ARG = 72,
	TP_ERR_BAD_HYPHEN = 73,
	TP_ERR_NO_BTF_FIELD = 74,
	TP_ERR_BAD_BTF_TID = 75,
	TP_ERR_BAD_TYPE4STR = 76,
	TP_ERR_NEED_STRING_TYPE = 77,
	TP_ERR_TOO_MANY_ARGS = 78,
	TP_ERR_TOO_MANY_EARGS = 79,
};

enum {
	TRACEFS_EVENT_INODE = 2,
	TRACEFS_GID_PERM_SET = 4,
	TRACEFS_UID_PERM_SET = 8,
	TRACEFS_INSTANCE_INODE = 16,
};

enum {
	TRACE_ARRAY_FL_GLOBAL = 1,
	TRACE_ARRAY_FL_BOOT = 2,
	TRACE_ARRAY_FL_MOD_INIT = 4,
};

enum {
	TRACE_EVENT_FL_CAP_ANY = 1,
	TRACE_EVENT_FL_NO_SET_FILTER = 2,
	TRACE_EVENT_FL_IGNORE_ENABLE = 4,
	TRACE_EVENT_FL_TRACEPOINT = 8,
	TRACE_EVENT_FL_DYNAMIC = 16,
	TRACE_EVENT_FL_KPROBE = 32,
	TRACE_EVENT_FL_UPROBE = 64,
	TRACE_EVENT_FL_EPROBE = 128,
	TRACE_EVENT_FL_FPROBE = 256,
	TRACE_EVENT_FL_CUSTOM = 512,
	TRACE_EVENT_FL_TEST_STR = 1024,
};

enum {
	TRACE_EVENT_FL_CAP_ANY_BIT = 0,
	TRACE_EVENT_FL_NO_SET_FILTER_BIT = 1,
	TRACE_EVENT_FL_IGNORE_ENABLE_BIT = 2,
	TRACE_EVENT_FL_TRACEPOINT_BIT = 3,
	TRACE_EVENT_FL_DYNAMIC_BIT = 4,
	TRACE_EVENT_FL_KPROBE_BIT = 5,
	TRACE_EVENT_FL_UPROBE_BIT = 6,
	TRACE_EVENT_FL_EPROBE_BIT = 7,
	TRACE_EVENT_FL_FPROBE_BIT = 8,
	TRACE_EVENT_FL_CUSTOM_BIT = 9,
	TRACE_EVENT_FL_TEST_STR_BIT = 10,
};

enum {
	TRACE_NOP_OPT_ACCEPT = 1,
	TRACE_NOP_OPT_REFUSE = 2,
};

enum {
	TRACE_PIDS = 1,
	TRACE_NO_PIDS = 2,
};

enum {
	TRACE_SIGNAL_DELIVERED = 0,
	TRACE_SIGNAL_IGNORED = 1,
	TRACE_SIGNAL_ALREADY_PENDING = 2,
	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
	TRACE_SIGNAL_LOSE_INFO = 4,
};

enum {
	TS_FSM_SINGLE = 0,
	TS_FSM_PERHAPS = 1,
	TS_FSM_ANY = 2,
	TS_FSM_MULTI = 3,
	TS_FSM_HEAD_IGNORE = 4,
	__TS_FSM_RECUR_MAX = 5,
};

enum {
	TS_FSM_SPECIFIC = 0,
	TS_FSM_WILDCARD = 1,
	TS_FSM_DIGIT = 2,
	TS_FSM_XDIGIT = 3,
	TS_FSM_PRINT = 4,
	TS_FSM_ALPHA = 5,
	TS_FSM_ALNUM = 6,
	TS_FSM_ASCII = 7,
	TS_FSM_CNTRL = 8,
	TS_FSM_GRAPH = 9,
	TS_FSM_LOWER = 10,
	TS_FSM_UPPER = 11,
	TS_FSM_PUNCT = 12,
	TS_FSM_SPACE = 13,
	__TS_FSM_TYPE_MAX = 14,
};

enum {
	UDP_BPF_IPV4 = 0,
	UDP_BPF_IPV6 = 1,
	UDP_BPF_NUM_PROTS = 2,
};

enum {
	UDP_FLAGS_CORK = 0,
	UDP_FLAGS_NO_CHECK6_TX = 1,
	UDP_FLAGS_NO_CHECK6_RX = 2,
	UDP_FLAGS_GRO_ENABLED = 3,
	UDP_FLAGS_ACCEPT_FRAGLIST = 4,
	UDP_FLAGS_ACCEPT_L4 = 5,
	UDP_FLAGS_ENCAP_ENABLED = 6,
	UDP_FLAGS_UDPLITE_SEND_CC = 7,
	UDP_FLAGS_UDPLITE_RECV_CC = 8,
};

enum {
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS = 1,
	UDP_MIB_NOPORTS = 2,
	UDP_MIB_INERRORS = 3,
	UDP_MIB_OUTDATAGRAMS = 4,
	UDP_MIB_RCVBUFERRORS = 5,
	UDP_MIB_SNDBUFERRORS = 6,
	UDP_MIB_CSUMERRORS = 7,
	UDP_MIB_IGNOREDMULTI = 8,
	UDP_MIB_MEMERRORS = 9,
	__UDP_MIB_MAX = 10,
};

enum {
	UNAME26 = 131072,
	ADDR_NO_RANDOMIZE = 262144,
	FDPIC_FUNCPTRS = 524288,
	MMAP_PAGE_ZERO = 1048576,
	ADDR_COMPAT_LAYOUT = 2097152,
	READ_IMPLIES_EXEC = 4194304,
	ADDR_LIMIT_32BIT = 8388608,
	SHORT_INODE = 16777216,
	WHOLE_SECONDS = 33554432,
	STICKY_TIMEOUTS = 67108864,
	ADDR_LIMIT_3GB = 134217728,
};

enum {
	UNCORE_TYPE_DF = 0,
	UNCORE_TYPE_L3 = 1,
	UNCORE_TYPE_UMC = 2,
	UNCORE_TYPE_MAX = 3,
};

enum {
	UNDEFINED_CAPABLE = 0,
	SYSTEM_INTEL_MSR_CAPABLE = 1,
	SYSTEM_AMD_MSR_CAPABLE = 2,
	SYSTEM_IO_CAPABLE = 3,
};

enum {
	UNIX_DIAG_NAME = 0,
	UNIX_DIAG_VFS = 1,
	UNIX_DIAG_PEER = 2,
	UNIX_DIAG_ICONS = 3,
	UNIX_DIAG_RQLEN = 4,
	UNIX_DIAG_MEMINFO = 5,
	UNIX_DIAG_SHUTDOWN = 6,
	UNIX_DIAG_UID = 7,
	__UNIX_DIAG_MAX = 8,
};

enum {
	VERBOSE_STATUS = 1,
};

enum {
	VERR_NO_ERROR = 0,
	VERR_CR_ASSOC_LEN = 1,
	VERR_CR_ASSOC_RQST_LEN = 2,
	VERR_CR_ASSOC_CMD = 3,
	VERR_CR_ASSOC_CMD_LEN = 4,
	VERR_ERSP_RATIO = 5,
	VERR_ASSOC_ALLOC_FAIL = 6,
	VERR_QUEUE_ALLOC_FAIL = 7,
	VERR_CR_CONN_LEN = 8,
	VERR_CR_CONN_RQST_LEN = 9,
	VERR_ASSOC_ID = 10,
	VERR_ASSOC_ID_LEN = 11,
	VERR_NO_ASSOC = 12,
	VERR_CONN_ID = 13,
	VERR_CONN_ID_LEN = 14,
	VERR_INVAL_CONN = 15,
	VERR_CR_CONN_CMD = 16,
	VERR_CR_CONN_CMD_LEN = 17,
	VERR_DISCONN_LEN = 18,
	VERR_DISCONN_RQST_LEN = 19,
	VERR_DISCONN_CMD = 20,
	VERR_DISCONN_CMD_LEN = 21,
	VERR_DISCONN_SCOPE = 22,
	VERR_RS_LEN = 23,
	VERR_RS_RQST_LEN = 24,
	VERR_RS_CMD = 25,
	VERR_RS_CMD_LEN = 26,
	VERR_RS_RCTL = 27,
	VERR_RS_RO = 28,
	VERR_LSACC = 29,
	VERR_LSDESC_RQST = 30,
	VERR_LSDESC_RQST_LEN = 31,
	VERR_CR_ASSOC = 32,
	VERR_CR_ASSOC_ACC_LEN = 33,
	VERR_CR_CONN = 34,
	VERR_CR_CONN_ACC_LEN = 35,
	VERR_DISCONN = 36,
	VERR_DISCONN_ACC_LEN = 37,
};

enum {
	VETH_INFO_UNSPEC = 0,
	VETH_INFO_PEER = 1,
	__VETH_INFO_MAX = 2,
};

enum {
	VIA_STRFILT_CNT_SHIFT = 16,
	VIA_STRFILT_FAIL = 32768,
	VIA_STRFILT_ENABLE = 16384,
	VIA_RAWBITS_ENABLE = 8192,
	VIA_RNG_ENABLE = 64,
	VIA_NOISESRC1 = 256,
	VIA_NOISESRC2 = 512,
	VIA_XSTORE_CNT_MASK = 15,
	VIA_RNG_CHUNK_8 = 0,
	VIA_RNG_CHUNK_4 = 1,
	VIA_RNG_CHUNK_4_MASK = 4294967295,
	VIA_RNG_CHUNK_2 = 2,
	VIA_RNG_CHUNK_2_MASK = 65535,
	VIA_RNG_CHUNK_1 = 3,
	VIA_RNG_CHUNK_1_MASK = 255,
};

enum {
	VLV_IOSF_SB_BUNIT = 0,
	VLV_IOSF_SB_CCK = 1,
	VLV_IOSF_SB_CCU = 2,
	VLV_IOSF_SB_DPIO = 3,
	VLV_IOSF_SB_FLISDSI = 4,
	VLV_IOSF_SB_GPIO = 5,
	VLV_IOSF_SB_NC = 6,
	VLV_IOSF_SB_PUNIT = 7,
};

enum {
	VNIFILTER_ENTRY_STATS_UNSPEC = 0,
	VNIFILTER_ENTRY_STATS_RX_BYTES = 1,
	VNIFILTER_ENTRY_STATS_RX_PKTS = 2,
	VNIFILTER_ENTRY_STATS_RX_DROPS = 3,
	VNIFILTER_ENTRY_STATS_RX_ERRORS = 4,
	VNIFILTER_ENTRY_STATS_TX_BYTES = 5,
	VNIFILTER_ENTRY_STATS_TX_PKTS = 6,
	VNIFILTER_ENTRY_STATS_TX_DROPS = 7,
	VNIFILTER_ENTRY_STATS_TX_ERRORS = 8,
	VNIFILTER_ENTRY_STATS_PAD = 9,
	__VNIFILTER_ENTRY_STATS_MAX = 10,
};

enum {
	VP_MSIX_CONFIG_VECTOR = 0,
	VP_MSIX_VQ_VECTOR = 1,
};

enum {
	VQ_HIPRIO = 0,
	VQ_REQUEST = 1,
};

enum {
	VSOCK_VQ_RX = 0,
	VSOCK_VQ_TX = 1,
	VSOCK_VQ_EVENT = 2,
	VSOCK_VQ_MAX = 3,
};

enum {
	VTIME_PER_SEC_SHIFT = 37ULL,
	VTIME_PER_SEC = 137438953472ULL,
	VTIME_PER_USEC = 137438ULL,
	VTIME_PER_NSEC = 137ULL,
	VRATE_MIN_PPM = 10000ULL,
	VRATE_MAX_PPM = 100000000ULL,
	VRATE_MIN = 1374ULL,
	VRATE_CLAMP_ADJ_PCT = 4ULL,
	AUTOP_CYCLE_NSEC = 10000000000ULL,
};

enum {
	VXLAN_VNIFILTER_ENTRY_UNSPEC = 0,
	VXLAN_VNIFILTER_ENTRY_START = 1,
	VXLAN_VNIFILTER_ENTRY_END = 2,
	VXLAN_VNIFILTER_ENTRY_GROUP = 3,
	VXLAN_VNIFILTER_ENTRY_GROUP6 = 4,
	VXLAN_VNIFILTER_ENTRY_STATS = 5,
	__VXLAN_VNIFILTER_ENTRY_MAX = 6,
};

enum {
	VXLAN_VNIFILTER_UNSPEC = 0,
	VXLAN_VNIFILTER_ENTRY = 1,
	__VXLAN_VNIFILTER_MAX = 2,
};

enum {
	VXLAN_VNI_STATS_RX = 0,
	VXLAN_VNI_STATS_RX_DROPS = 1,
	VXLAN_VNI_STATS_RX_ERRORS = 2,
	VXLAN_VNI_STATS_TX = 3,
	VXLAN_VNI_STATS_TX_DROPS = 4,
	VXLAN_VNI_STATS_TX_ERRORS = 5,
};

enum {
	WALK_TRAILING = 1,
	WALK_MORE = 2,
	WALK_NOFOLLOW = 4,
};

enum {
	WMI_READ_TAKES_NO_ARGS = 0,
	WMI_GUID_DUPLICATED = 1,
	WMI_NO_EVENT_DATA = 2,
};

enum {
	WORK_DONE_BIT = 0,
	WORK_ORDER_DONE_BIT = 1,
};

enum {
	X25_LINK_STATE_0 = 0,
	X25_LINK_STATE_1 = 1,
	X25_LINK_STATE_2 = 2,
	X25_LINK_STATE_3 = 3,
};

enum {
	X25_STATE_0 = 0,
	X25_STATE_1 = 1,
	X25_STATE_2 = 2,
	X25_STATE_3 = 3,
	X25_STATE_4 = 4,
	X25_STATE_5 = 5,
};

enum {
	X2APIC_OFF = 0,
	X2APIC_DISABLED = 1,
	X2APIC_ON = 2,
	X2APIC_ON_LOCKED = 3,
};

enum {
	X86_BR_NONE = 0,
	X86_BR_USER = 1,
	X86_BR_KERNEL = 2,
	X86_BR_CALL = 4,
	X86_BR_RET = 8,
	X86_BR_SYSCALL = 16,
	X86_BR_SYSRET = 32,
	X86_BR_INT = 64,
	X86_BR_IRET = 128,
	X86_BR_JCC = 256,
	X86_BR_JMP = 512,
	X86_BR_IRQ = 1024,
	X86_BR_IND_CALL = 2048,
	X86_BR_ABORT = 4096,
	X86_BR_IN_TX = 8192,
	X86_BR_NO_TX = 16384,
	X86_BR_ZERO_CALL = 32768,
	X86_BR_CALL_STACK = 65536,
	X86_BR_IND_JMP = 131072,
	X86_BR_TYPE_SAVE = 262144,
};

enum {
	X86_IRQ_ALLOC_LEGACY = 1,
};

enum {
	X86_PERF_KFREE_SHARED = 0,
	X86_PERF_KFREE_EXCL = 1,
	X86_PERF_KFREE_MAX = 2,
};

enum {
	XA_CHECK_SCHED = 4096,
};

enum {
	XDP_ATTACHED_NONE = 0,
	XDP_ATTACHED_DRV = 1,
	XDP_ATTACHED_SKB = 2,
	XDP_ATTACHED_HW = 3,
	XDP_ATTACHED_MULTI = 4,
};

enum {
	XFRM_DEV_OFFLOAD_FLAG_ACQ = 1,
};

enum {
	XFRM_DEV_OFFLOAD_IN = 1,
	XFRM_DEV_OFFLOAD_OUT = 2,
	XFRM_DEV_OFFLOAD_FWD = 3,
};

enum {
	XFRM_DEV_OFFLOAD_UNSPECIFIED = 0,
	XFRM_DEV_OFFLOAD_CRYPTO = 1,
	XFRM_DEV_OFFLOAD_PACKET = 2,
};

enum {
	XFRM_LOOKUP_ICMP = 1,
	XFRM_LOOKUP_QUEUE = 2,
	XFRM_LOOKUP_KEEP_DST_REF = 4,
};

enum {
	XFRM_MODE_FLAG_TUNNEL = 1,
};

enum {
	XFRM_MSG_BASE = 16,
	XFRM_MSG_NEWSA = 16,
	XFRM_MSG_DELSA = 17,
	XFRM_MSG_GETSA = 18,
	XFRM_MSG_NEWPOLICY = 19,
	XFRM_MSG_DELPOLICY = 20,
	XFRM_MSG_GETPOLICY = 21,
	XFRM_MSG_ALLOCSPI = 22,
	XFRM_MSG_ACQUIRE = 23,
	XFRM_MSG_EXPIRE = 24,
	XFRM_MSG_UPDPOLICY = 25,
	XFRM_MSG_UPDSA = 26,
	XFRM_MSG_POLEXPIRE = 27,
	XFRM_MSG_FLUSHSA = 28,
	XFRM_MSG_FLUSHPOLICY = 29,
	XFRM_MSG_NEWAE = 30,
	XFRM_MSG_GETAE = 31,
	XFRM_MSG_REPORT = 32,
	XFRM_MSG_MIGRATE = 33,
	XFRM_MSG_NEWSADINFO = 34,
	XFRM_MSG_GETSADINFO = 35,
	XFRM_MSG_NEWSPDINFO = 36,
	XFRM_MSG_GETSPDINFO = 37,
	XFRM_MSG_MAPPING = 38,
	XFRM_MSG_SETDEFAULT = 39,
	XFRM_MSG_GETDEFAULT = 40,
	__XFRM_MSG_MAX = 41,
};

enum {
	XFRM_POLICY_IN = 0,
	XFRM_POLICY_OUT = 1,
	XFRM_POLICY_FWD = 2,
	XFRM_POLICY_MASK = 3,
	XFRM_POLICY_MAX = 3,
};

enum {
	XFRM_POLICY_TYPE_MAIN = 0,
	XFRM_POLICY_TYPE_SUB = 1,
	XFRM_POLICY_TYPE_MAX = 2,
	XFRM_POLICY_TYPE_ANY = 255,
};

enum {
	XFRM_SHARE_ANY = 0,
	XFRM_SHARE_SESSION = 1,
	XFRM_SHARE_USER = 2,
	XFRM_SHARE_UNIQUE = 3,
};

enum {
	XFRM_STATE_VOID = 0,
	XFRM_STATE_ACQ = 1,
	XFRM_STATE_VALID = 2,
	XFRM_STATE_ERROR = 3,
	XFRM_STATE_EXPIRED = 4,
	XFRM_STATE_DEAD = 5,
};

enum {
	XFS_ERR_DEFAULT = 0,
	XFS_ERR_EIO = 1,
	XFS_ERR_ENOSPC = 2,
	XFS_ERR_ENODEV = 3,
	XFS_ERR_ERRNO_MAX = 4,
};

enum {
	XFS_ERR_METADATA = 0,
	XFS_ERR_CLASS_MAX = 1,
};

enum {
	XFS_LOWSP_1_PCNT = 0,
	XFS_LOWSP_2_PCNT = 1,
	XFS_LOWSP_3_PCNT = 2,
	XFS_LOWSP_4_PCNT = 3,
	XFS_LOWSP_5_PCNT = 4,
	XFS_LOWSP_MAX = 5,
};

enum {
	XFS_QLOWSP_1_PCNT = 0,
	XFS_QLOWSP_3_PCNT = 1,
	XFS_QLOWSP_5_PCNT = 2,
	XFS_QLOWSP_MAX = 3,
};

enum {
	XFS_QM_TRANS_USR = 0,
	XFS_QM_TRANS_GRP = 1,
	XFS_QM_TRANS_PRJ = 2,
	XFS_QM_TRANS_DQTYPES = 3,
};

enum {
	XPT_BUSY = 0,
	XPT_CONN = 1,
	XPT_CLOSE = 2,
	XPT_DATA = 3,
	XPT_TEMP = 4,
	XPT_DEAD = 5,
	XPT_CHNGBUF = 6,
	XPT_DEFERRED = 7,
	XPT_OLD = 8,
	XPT_LISTENER = 9,
	XPT_CACHE_AUTH = 10,
	XPT_LOCAL = 11,
	XPT_KILL_TEMP = 12,
	XPT_CONG_CTRL = 13,
	XPT_HANDSHAKE = 14,
	XPT_TLS_SESSION = 15,
	XPT_PEER_AUTH = 16,
	XPT_PEER_VALID = 17,
};

enum {
	XT_ADDRTYPE_INVERT_SOURCE = 1,
	XT_ADDRTYPE_INVERT_DEST = 2,
	XT_ADDRTYPE_LIMIT_IFACE_IN = 4,
	XT_ADDRTYPE_LIMIT_IFACE_OUT = 8,
};

enum {
	XT_ADDRTYPE_UNSPEC = 1,
	XT_ADDRTYPE_UNICAST = 2,
	XT_ADDRTYPE_LOCAL = 4,
	XT_ADDRTYPE_BROADCAST = 8,
	XT_ADDRTYPE_ANYCAST = 16,
	XT_ADDRTYPE_MULTICAST = 32,
	XT_ADDRTYPE_BLACKHOLE = 64,
	XT_ADDRTYPE_UNREACHABLE = 128,
	XT_ADDRTYPE_PROHIBIT = 256,
	XT_ADDRTYPE_THROW = 512,
	XT_ADDRTYPE_NAT = 1024,
	XT_ADDRTYPE_XRESOLVE = 2048,
};

enum {
	XT_AUDIT_TYPE_ACCEPT = 0,
	XT_AUDIT_TYPE_DROP = 1,
	XT_AUDIT_TYPE_REJECT = 2,
	__XT_AUDIT_TYPE_MAX = 3,
};

enum {
	XT_CONNLIMIT_INVERT = 1,
	XT_CONNLIMIT_DADDR = 2,
};

enum {
	XT_CONNMARK_SET = 0,
	XT_CONNMARK_SAVE = 1,
	XT_CONNMARK_RESTORE = 2,
};

enum {
	XT_CONNTRACK_STATE = 1,
	XT_CONNTRACK_PROTO = 2,
	XT_CONNTRACK_ORIGSRC = 4,
	XT_CONNTRACK_ORIGDST = 8,
	XT_CONNTRACK_REPLSRC = 16,
	XT_CONNTRACK_REPLDST = 32,
	XT_CONNTRACK_STATUS = 64,
	XT_CONNTRACK_EXPIRES = 128,
	XT_CONNTRACK_ORIGSRC_PORT = 256,
	XT_CONNTRACK_ORIGDST_PORT = 512,
	XT_CONNTRACK_REPLSRC_PORT = 1024,
	XT_CONNTRACK_REPLDST_PORT = 2048,
	XT_CONNTRACK_DIRECTION = 4096,
	XT_CONNTRACK_STATE_ALIAS = 8192,
};

enum {
	XT_CT_NOTRACK = 1,
	XT_CT_NOTRACK_ALIAS = 2,
	XT_CT_ZONE_DIR_ORIG = 4,
	XT_CT_ZONE_DIR_REPL = 8,
	XT_CT_ZONE_MARK = 16,
	XT_CT_MASK = 31,
};

enum {
	XT_HASHLIMIT_HASH_DIP = 1,
	XT_HASHLIMIT_HASH_DPT = 2,
	XT_HASHLIMIT_HASH_SIP = 4,
	XT_HASHLIMIT_HASH_SPT = 8,
	XT_HASHLIMIT_INVERT = 16,
	XT_HASHLIMIT_BYTES = 32,
	XT_HASHLIMIT_RATE_MATCH = 64,
};

enum {
	XT_HMARK_SADDR_MASK = 0,
	XT_HMARK_DADDR_MASK = 1,
	XT_HMARK_SPI = 2,
	XT_HMARK_SPI_MASK = 3,
	XT_HMARK_SPORT = 4,
	XT_HMARK_DPORT = 5,
	XT_HMARK_SPORT_MASK = 6,
	XT_HMARK_DPORT_MASK = 7,
	XT_HMARK_PROTO_MASK = 8,
	XT_HMARK_RND = 9,
	XT_HMARK_MODULUS = 10,
	XT_HMARK_OFFSET = 11,
	XT_HMARK_CT = 12,
	XT_HMARK_METHOD_L3 = 13,
	XT_HMARK_METHOD_L3_4 = 14,
};

enum {
	XT_L2TP_TID = 1,
	XT_L2TP_SID = 2,
	XT_L2TP_VERSION = 4,
	XT_L2TP_TYPE = 8,
};

enum {
	XT_OWNER_UID = 1,
	XT_OWNER_GID = 2,
	XT_OWNER_SOCKET = 4,
	XT_OWNER_SUPPL_GROUPS = 8,
};

enum {
	XT_RECENT_CHECK = 1,
	XT_RECENT_SET = 2,
	XT_RECENT_UPDATE = 4,
	XT_RECENT_REMOVE = 8,
	XT_RECENT_TTL = 16,
	XT_RECENT_REAP = 32,
	XT_RECENT_SOURCE = 0,
	XT_RECENT_DEST = 1,
	XT_RECENT_NAME_LEN = 200,
};

enum {
	XT_RPFILTER_LOOSE = 1,
	XT_RPFILTER_VALID_MARK = 2,
	XT_RPFILTER_ACCEPT_LOCAL = 4,
	XT_RPFILTER_INVERT = 8,
	XT_RPFILTER_OPTION_MASK = 15,
};

enum {
	XT_SOCKET_TRANSPARENT = 1,
	XT_SOCKET_NOWILDCARD = 2,
	XT_SOCKET_RESTORESKMARK = 4,
};

enum {
	XT_STRING_FLAG_INVERT = 1,
	XT_STRING_FLAG_IGNORECASE = 2,
};

enum {
	XT_TIME_LOCAL_TZ = 1,
	XT_TIME_CONTIGUOUS = 2,
	XT_TIME_ALL_MONTHDAYS = 4294967294,
	XT_TIME_ALL_WEEKDAYS = 254,
	XT_TIME_MIN_DAYTIME = 0,
	XT_TIME_MAX_DAYTIME = 86399,
};

enum {
	ZONELIST_FALLBACK = 0,
	ZONELIST_NOFALLBACK = 1,
	MAX_ZONELISTS = 2,
};

enum {
	ZSTDbss_compress = 0,
	ZSTDbss_noCompress = 1,
};

enum {
	_DQUOT_USAGE_ENABLED = 0,
	_DQUOT_LIMITS_ENABLED = 1,
	_DQUOT_SUSPENDED = 2,
	_DQUOT_STATE_FLAGS = 3,
};

enum {
	_IRQ_DEFAULT_INIT_FLAGS = 0,
	_IRQ_PER_CPU = 512,
	_IRQ_LEVEL = 256,
	_IRQ_NOPROBE = 1024,
	_IRQ_NOREQUEST = 2048,
	_IRQ_NOTHREAD = 65536,
	_IRQ_NOAUTOEN = 4096,
	_IRQ_NO_BALANCING = 8192,
	_IRQ_NESTED_THREAD = 32768,
	_IRQ_PER_CPU_DEVID = 131072,
	_IRQ_IS_POLLED = 262144,
	_IRQ_DISABLE_UNLAZY = 524288,
	_IRQ_HIDDEN = 1048576,
	_IRQ_NO_DEBUG = 2097152,
	_IRQF_MODIFY_MASK = 2080527,
};

enum {
	__EXTENT_DIRTY_BIT = 0,
	EXTENT_DIRTY = 1,
	__EXTENT_DIRTY_SEQ = 0,
	__EXTENT_UPTODATE_BIT = 1,
	EXTENT_UPTODATE = 2,
	__EXTENT_UPTODATE_SEQ = 1,
	__EXTENT_LOCKED_BIT = 2,
	EXTENT_LOCKED = 4,
	__EXTENT_LOCKED_SEQ = 2,
	__EXTENT_DIO_LOCKED_BIT = 3,
	EXTENT_DIO_LOCKED = 8,
	__EXTENT_DIO_LOCKED_SEQ = 3,
	__EXTENT_NEW_BIT = 4,
	EXTENT_NEW = 16,
	__EXTENT_NEW_SEQ = 4,
	__EXTENT_DELALLOC_BIT = 5,
	EXTENT_DELALLOC = 32,
	__EXTENT_DELALLOC_SEQ = 5,
	__EXTENT_DEFRAG_BIT = 6,
	EXTENT_DEFRAG = 64,
	__EXTENT_DEFRAG_SEQ = 6,
	__EXTENT_BOUNDARY_BIT = 7,
	EXTENT_BOUNDARY = 128,
	__EXTENT_BOUNDARY_SEQ = 7,
	__EXTENT_NODATASUM_BIT = 8,
	EXTENT_NODATASUM = 256,
	__EXTENT_NODATASUM_SEQ = 8,
	__EXTENT_CLEAR_META_RESV_BIT = 9,
	EXTENT_CLEAR_META_RESV = 512,
	__EXTENT_CLEAR_META_RESV_SEQ = 9,
	__EXTENT_NEED_WAIT_BIT = 10,
	EXTENT_NEED_WAIT = 1024,
	__EXTENT_NEED_WAIT_SEQ = 10,
	__EXTENT_NORESERVE_BIT = 11,
	EXTENT_NORESERVE = 2048,
	__EXTENT_NORESERVE_SEQ = 11,
	__EXTENT_QGROUP_RESERVED_BIT = 12,
	EXTENT_QGROUP_RESERVED = 4096,
	__EXTENT_QGROUP_RESERVED_SEQ = 12,
	__EXTENT_CLEAR_DATA_RESV_BIT = 13,
	EXTENT_CLEAR_DATA_RESV = 8192,
	__EXTENT_CLEAR_DATA_RESV_SEQ = 13,
	__EXTENT_DELALLOC_NEW_BIT = 14,
	EXTENT_DELALLOC_NEW = 16384,
	__EXTENT_DELALLOC_NEW_SEQ = 14,
	__EXTENT_ADD_INODE_BYTES_BIT = 15,
	EXTENT_ADD_INODE_BYTES = 32768,
	__EXTENT_ADD_INODE_BYTES_SEQ = 15,
	__EXTENT_CLEAR_ALL_BITS_BIT = 16,
	EXTENT_CLEAR_ALL_BITS = 65536,
	__EXTENT_CLEAR_ALL_BITS_SEQ = 16,
	__EXTENT_NOWAIT_BIT = 17,
	EXTENT_NOWAIT = 131072,
	__EXTENT_NOWAIT_SEQ = 17,
};

enum {
	__EXTENT_FLAG_PINNED_BIT = 0,
	EXTENT_FLAG_PINNED = 1,
	__EXTENT_FLAG_PINNED_SEQ = 0,
	__EXTENT_FLAG_COMPRESS_ZLIB_BIT = 1,
	EXTENT_FLAG_COMPRESS_ZLIB = 2,
	__EXTENT_FLAG_COMPRESS_ZLIB_SEQ = 1,
	__EXTENT_FLAG_COMPRESS_LZO_BIT = 2,
	EXTENT_FLAG_COMPRESS_LZO = 4,
	__EXTENT_FLAG_COMPRESS_LZO_SEQ = 2,
	__EXTENT_FLAG_COMPRESS_ZSTD_BIT = 3,
	EXTENT_FLAG_COMPRESS_ZSTD = 8,
	__EXTENT_FLAG_COMPRESS_ZSTD_SEQ = 3,
	__EXTENT_FLAG_PREALLOC_BIT = 4,
	EXTENT_FLAG_PREALLOC = 16,
	__EXTENT_FLAG_PREALLOC_SEQ = 4,
	__EXTENT_FLAG_LOGGING_BIT = 5,
	EXTENT_FLAG_LOGGING = 32,
	__EXTENT_FLAG_LOGGING_SEQ = 5,
	__EXTENT_FLAG_MERGED_BIT = 6,
	EXTENT_FLAG_MERGED = 64,
	__EXTENT_FLAG_MERGED_SEQ = 6,
};

enum {
	__I915_SAMPLE_FREQ_ACT = 0,
	__I915_SAMPLE_FREQ_REQ = 1,
	__I915_SAMPLE_RC6 = 2,
	__I915_SAMPLE_RC6_LAST_REPORTED = 3,
	__I915_NUM_PMU_SAMPLERS = 4,
};

enum {
	__IOAM6_IPTUNNEL_MODE_MIN = 0,
	IOAM6_IPTUNNEL_MODE_INLINE = 1,
	IOAM6_IPTUNNEL_MODE_ENCAP = 2,
	IOAM6_IPTUNNEL_MODE_AUTO = 3,
	__IOAM6_IPTUNNEL_MODE_MAX = 4,
};

enum {
	__ND_OPT_PREFIX_INFO_END = 0,
	ND_OPT_SOURCE_LL_ADDR = 1,
	ND_OPT_TARGET_LL_ADDR = 2,
	ND_OPT_PREFIX_INFO = 3,
	ND_OPT_REDIRECT_HDR = 4,
	ND_OPT_MTU = 5,
	ND_OPT_NONCE = 14,
	__ND_OPT_ARRAY_MAX = 15,
	ND_OPT_ROUTE_INFO = 24,
	ND_OPT_RDNSS = 25,
	ND_OPT_DNSSL = 31,
	ND_OPT_6CO = 34,
	ND_OPT_CAPTIVE_PORTAL = 37,
	ND_OPT_PREF64 = 38,
	__ND_OPT_MAX = 39,
};

enum {
	__PAGE_UNLOCK_BIT = 0,
	PAGE_UNLOCK = 1,
	__PAGE_UNLOCK_SEQ = 0,
	__PAGE_START_WRITEBACK_BIT = 1,
	PAGE_START_WRITEBACK = 2,
	__PAGE_START_WRITEBACK_SEQ = 1,
	__PAGE_END_WRITEBACK_BIT = 2,
	PAGE_END_WRITEBACK = 4,
	__PAGE_END_WRITEBACK_SEQ = 2,
	__PAGE_SET_ORDERED_BIT = 3,
	PAGE_SET_ORDERED = 8,
	__PAGE_SET_ORDERED_SEQ = 3,
};

enum {
	__PERCPU_REF_ATOMIC = 1,
	__PERCPU_REF_DEAD = 2,
	__PERCPU_REF_ATOMIC_DEAD = 3,
	__PERCPU_REF_FLAG_BITS = 2,
};

enum {
	__QGROUP_RESERVE_BIT = 0,
	QGROUP_RESERVE = 1,
	__QGROUP_RESERVE_SEQ = 0,
	__QGROUP_RELEASE_BIT = 1,
	QGROUP_RELEASE = 2,
	__QGROUP_RELEASE_SEQ = 1,
	__QGROUP_FREE_BIT = 2,
	QGROUP_FREE = 4,
	__QGROUP_FREE_SEQ = 2,
};

enum {
	__SCHED_FEAT_PLACE_LAG = 0,
	__SCHED_FEAT_PLACE_DEADLINE_INITIAL = 1,
	__SCHED_FEAT_PLACE_REL_DEADLINE = 2,
	__SCHED_FEAT_RUN_TO_PARITY = 3,
	__SCHED_FEAT_PREEMPT_SHORT = 4,
	__SCHED_FEAT_NEXT_BUDDY = 5,
	__SCHED_FEAT_PICK_BUDDY = 6,
	__SCHED_FEAT_CACHE_HOT_BUDDY = 7,
	__SCHED_FEAT_DELAY_DEQUEUE = 8,
	__SCHED_FEAT_DELAY_ZERO = 9,
	__SCHED_FEAT_WAKEUP_PREEMPTION = 10,
	__SCHED_FEAT_HRTICK = 11,
	__SCHED_FEAT_HRTICK_DL = 12,
	__SCHED_FEAT_NONTASK_CAPACITY = 13,
	__SCHED_FEAT_TTWU_QUEUE = 14,
	__SCHED_FEAT_SIS_UTIL = 15,
	__SCHED_FEAT_WARN_DOUBLE_CLOCK = 16,
	__SCHED_FEAT_RT_PUSH_IPI = 17,
	__SCHED_FEAT_RT_RUNTIME_SHARE = 18,
	__SCHED_FEAT_LB_MIN = 19,
	__SCHED_FEAT_ATTACH_AGE_LOAD = 20,
	__SCHED_FEAT_WA_IDLE = 21,
	__SCHED_FEAT_WA_WEIGHT = 22,
	__SCHED_FEAT_WA_BIAS = 23,
	__SCHED_FEAT_UTIL_EST = 24,
	__SCHED_FEAT_LATENCY_WARN = 25,
	__SCHED_FEAT_NR = 26,
};

enum {
	__SD_BALANCE_NEWIDLE = 0,
	__SD_BALANCE_EXEC = 1,
	__SD_BALANCE_FORK = 2,
	__SD_BALANCE_WAKE = 3,
	__SD_WAKE_AFFINE = 4,
	__SD_ASYM_CPUCAPACITY = 5,
	__SD_ASYM_CPUCAPACITY_FULL = 6,
	__SD_SHARE_CPUCAPACITY = 7,
	__SD_CLUSTER = 8,
	__SD_SHARE_LLC = 9,
	__SD_SERIALIZE = 10,
	__SD_ASYM_PACKING = 11,
	__SD_PREFER_SIBLING = 12,
	__SD_OVERLAP = 13,
	__SD_NUMA = 14,
	__SD_FLAG_CNT = 15,
};

enum {
	__TCA_CAKE_STATS_INVALID = 0,
	TCA_CAKE_STATS_PAD = 1,
	TCA_CAKE_STATS_CAPACITY_ESTIMATE64 = 2,
	TCA_CAKE_STATS_MEMORY_LIMIT = 3,
	TCA_CAKE_STATS_MEMORY_USED = 4,
	TCA_CAKE_STATS_AVG_NETOFF = 5,
	TCA_CAKE_STATS_MIN_NETLEN = 6,
	TCA_CAKE_STATS_MAX_NETLEN = 7,
	TCA_CAKE_STATS_MIN_ADJLEN = 8,
	TCA_CAKE_STATS_MAX_ADJLEN = 9,
	TCA_CAKE_STATS_TIN_STATS = 10,
	TCA_CAKE_STATS_DEFICIT = 11,
	TCA_CAKE_STATS_COBALT_COUNT = 12,
	TCA_CAKE_STATS_DROPPING = 13,
	TCA_CAKE_STATS_DROP_NEXT_US = 14,
	TCA_CAKE_STATS_P_DROP = 15,
	TCA_CAKE_STATS_BLUE_TIMER_US = 16,
	__TCA_CAKE_STATS_MAX = 17,
};

enum {
	__TCA_CAKE_TIN_STATS_INVALID = 0,
	TCA_CAKE_TIN_STATS_PAD = 1,
	TCA_CAKE_TIN_STATS_SENT_PACKETS = 2,
	TCA_CAKE_TIN_STATS_SENT_BYTES64 = 3,
	TCA_CAKE_TIN_STATS_DROPPED_PACKETS = 4,
	TCA_CAKE_TIN_STATS_DROPPED_BYTES64 = 5,
	TCA_CAKE_TIN_STATS_ACKS_DROPPED_PACKETS = 6,
	TCA_CAKE_TIN_STATS_ACKS_DROPPED_BYTES64 = 7,
	TCA_CAKE_TIN_STATS_ECN_MARKED_PACKETS = 8,
	TCA_CAKE_TIN_STATS_ECN_MARKED_BYTES64 = 9,
	TCA_CAKE_TIN_STATS_BACKLOG_PACKETS = 10,
	TCA_CAKE_TIN_STATS_BACKLOG_BYTES = 11,
	TCA_CAKE_TIN_STATS_THRESHOLD_RATE64 = 12,
	TCA_CAKE_TIN_STATS_TARGET_US = 13,
	TCA_CAKE_TIN_STATS_INTERVAL_US = 14,
	TCA_CAKE_TIN_STATS_WAY_INDIRECT_HITS = 15,
	TCA_CAKE_TIN_STATS_WAY_MISSES = 16,
	TCA_CAKE_TIN_STATS_WAY_COLLISIONS = 17,
	TCA_CAKE_TIN_STATS_PEAK_DELAY_US = 18,
	TCA_CAKE_TIN_STATS_AVG_DELAY_US = 19,
	TCA_CAKE_TIN_STATS_BASE_DELAY_US = 20,
	TCA_CAKE_TIN_STATS_SPARSE_FLOWS = 21,
	TCA_CAKE_TIN_STATS_BULK_FLOWS = 22,
	TCA_CAKE_TIN_STATS_UNRESPONSIVE_FLOWS = 23,
	TCA_CAKE_TIN_STATS_MAX_SKBLEN = 24,
	TCA_CAKE_TIN_STATS_FLOW_QUANTUM = 25,
	__TCA_CAKE_TIN_STATS_MAX = 26,
};

enum {
	__XBTS_lookup = 0,
	__XBTS_compare = 1,
	__XBTS_insrec = 2,
	__XBTS_delrec = 3,
	__XBTS_newroot = 4,
	__XBTS_killroot = 5,
	__XBTS_increment = 6,
	__XBTS_decrement = 7,
	__XBTS_lshift = 8,
	__XBTS_rshift = 9,
	__XBTS_split = 10,
	__XBTS_join = 11,
	__XBTS_alloc = 12,
	__XBTS_free = 13,
	__XBTS_moves = 14,
	__XBTS_MAX = 15,
};

enum {
	___GFP_DMA_BIT = 0,
	___GFP_HIGHMEM_BIT = 1,
	___GFP_DMA32_BIT = 2,
	___GFP_MOVABLE_BIT = 3,
	___GFP_RECLAIMABLE_BIT = 4,
	___GFP_HIGH_BIT = 5,
	___GFP_IO_BIT = 6,
	___GFP_FS_BIT = 7,
	___GFP_ZERO_BIT = 8,
	___GFP_UNUSED_BIT = 9,
	___GFP_DIRECT_RECLAIM_BIT = 10,
	___GFP_KSWAPD_RECLAIM_BIT = 11,
	___GFP_WRITE_BIT = 12,
	___GFP_NOWARN_BIT = 13,
	___GFP_RETRY_MAYFAIL_BIT = 14,
	___GFP_NOFAIL_BIT = 15,
	___GFP_NORETRY_BIT = 16,
	___GFP_MEMALLOC_BIT = 17,
	___GFP_COMP_BIT = 18,
	___GFP_NOMEMALLOC_BIT = 19,
	___GFP_HARDWALL_BIT = 20,
	___GFP_THISNODE_BIT = 21,
	___GFP_ACCOUNT_BIT = 22,
	___GFP_ZEROTAGS_BIT = 23,
	___GFP_NO_OBJ_EXT_BIT = 24,
	___GFP_LAST_BIT = 25,
};

enum {
	____TRANS_FREEZABLE_BIT = 0,
	__TRANS_FREEZABLE = 1,
	____TRANS_FREEZABLE_SEQ = 0,
	____TRANS_START_BIT = 1,
	__TRANS_START = 2,
	____TRANS_START_SEQ = 1,
	____TRANS_ATTACH_BIT = 2,
	__TRANS_ATTACH = 4,
	____TRANS_ATTACH_SEQ = 2,
	____TRANS_JOIN_BIT = 3,
	__TRANS_JOIN = 8,
	____TRANS_JOIN_SEQ = 3,
	____TRANS_JOIN_NOLOCK_BIT = 4,
	__TRANS_JOIN_NOLOCK = 16,
	____TRANS_JOIN_NOLOCK_SEQ = 4,
	____TRANS_DUMMY_BIT = 5,
	__TRANS_DUMMY = 32,
	____TRANS_DUMMY_SEQ = 5,
	____TRANS_JOIN_NOSTART_BIT = 6,
	__TRANS_JOIN_NOSTART = 64,
	____TRANS_JOIN_NOSTART_SEQ = 6,
};

enum {
	__ctx_convertBPF_PROG_TYPE_SOCKET_FILTER = 0,
	__ctx_convertBPF_PROG_TYPE_SCHED_CLS = 1,
	__ctx_convertBPF_PROG_TYPE_SCHED_ACT = 2,
	__ctx_convertBPF_PROG_TYPE_XDP = 3,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SKB = 4,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK = 5,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK_ADDR = 6,
	__ctx_convertBPF_PROG_TYPE_LWT_IN = 7,
	__ctx_convertBPF_PROG_TYPE_LWT_OUT = 8,
	__ctx_convertBPF_PROG_TYPE_LWT_XMIT = 9,
	__ctx_convertBPF_PROG_TYPE_LWT_SEG6LOCAL = 10,
	__ctx_convertBPF_PROG_TYPE_SOCK_OPS = 11,
	__ctx_convertBPF_PROG_TYPE_SK_SKB = 12,
	__ctx_convertBPF_PROG_TYPE_SK_MSG = 13,
	__ctx_convertBPF_PROG_TYPE_FLOW_DISSECTOR = 14,
	__ctx_convertBPF_PROG_TYPE_KPROBE = 15,
	__ctx_convertBPF_PROG_TYPE_TRACEPOINT = 16,
	__ctx_convertBPF_PROG_TYPE_PERF_EVENT = 17,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT = 18,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 19,
	__ctx_convertBPF_PROG_TYPE_TRACING = 20,
	__ctx_convertBPF_PROG_TYPE_CGROUP_DEVICE = 21,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SYSCTL = 22,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCKOPT = 23,
	__ctx_convertBPF_PROG_TYPE_SK_REUSEPORT = 24,
	__ctx_convertBPF_PROG_TYPE_SK_LOOKUP = 25,
	__ctx_convertBPF_PROG_TYPE_STRUCT_OPS = 26,
	__ctx_convertBPF_PROG_TYPE_EXT = 27,
	__ctx_convertBPF_PROG_TYPE_LSM = 28,
	__ctx_convertBPF_PROG_TYPE_SYSCALL = 29,
	__ctx_convertBPF_PROG_TYPE_NETFILTER = 30,
	__ctx_convert_unused = 31,
};

enum {
	attr_noop = 0,
	attr_delayed_allocation_blocks = 1,
	attr_session_write_kbytes = 2,
	attr_lifetime_write_kbytes = 3,
	attr_reserved_clusters = 4,
	attr_sra_exceeded_retry_limit = 5,
	attr_inode_readahead = 6,
	attr_trigger_test_error = 7,
	attr_first_error_time = 8,
	attr_last_error_time = 9,
	attr_clusters_in_group = 10,
	attr_mb_order = 11,
	attr_feature = 12,
	attr_pointer_pi = 13,
	attr_pointer_ui = 14,
	attr_pointer_ul = 15,
	attr_pointer_u64 = 16,
	attr_pointer_u8 = 17,
	attr_pointer_string = 18,
	attr_pointer_atomic = 19,
	attr_journal_task = 20,
};

enum {
	blank_off = 0,
	blank_normal_wait = 1,
	blank_vesa_wait = 2,
};

enum {
	btrfs_bitmap_nr_uptodate = 0,
	btrfs_bitmap_nr_dirty = 1,
	btrfs_bitmap_nr_writeback = 2,
	btrfs_bitmap_nr_ordered = 3,
	btrfs_bitmap_nr_checked = 4,
	btrfs_bitmap_nr_locked = 5,
	btrfs_bitmap_nr_max = 6,
};

enum {
	cpuset = 0,
	possible = 1,
	fail = 2,
};

enum {
	dns_key_data = 0,
	dns_key_error = 1,
};

enum {
	false = 0,
	true = 1,
};

enum {
	none = 0,
	day = 1,
	month = 2,
	year = 3,
};

enum {
	pci_channel_io_normal = 1,
	pci_channel_io_frozen = 2,
	pci_channel_io_perm_failure = 3,
};

enum {
	preempt_dynamic_undefined = -1,
	preempt_dynamic_none = 0,
	preempt_dynamic_voluntary = 1,
	preempt_dynamic_full = 2,
	preempt_dynamic_lazy = 3,
};

enum {
	ptr_explicit = 0,
	ptr_ext4_sb_info_offset = 1,
	ptr_ext4_super_block_offset = 2,
};

enum {
	st_wordstart = 0,
	st_wordcmp = 1,
	st_wordskip = 2,
	st_bufcpy = 3,
};

enum {
	st_wordstart___2 = 0,
	st_wordcmp___2 = 1,
	st_wordskip___2 = 2,
};

enum {
	sysctl_hung_task_timeout_secs = 0,
};

enum {
	x86_lbr_exclusive_lbr = 0,
	x86_lbr_exclusive_bts = 1,
	x86_lbr_exclusive_pt = 2,
	x86_lbr_exclusive_max = 3,
};

typedef enum {
	BIT_DStream_unfinished = 0,
	BIT_DStream_endOfBuffer = 1,
	BIT_DStream_completed = 2,
	BIT_DStream_overflow = 3,
} BIT_DStream_status;

typedef enum {
	ZSTD_error_no_error = 0,
	ZSTD_error_GENERIC = 1,
	ZSTD_error_prefix_unknown = 10,
	ZSTD_error_version_unsupported = 12,
	ZSTD_error_frameParameter_unsupported = 14,
	ZSTD_error_frameParameter_windowTooLarge = 16,
	ZSTD_error_corruption_detected = 20,
	ZSTD_error_checksum_wrong = 22,
	ZSTD_error_dictionary_corrupted = 30,
	ZSTD_error_dictionary_wrong = 32,
	ZSTD_error_dictionaryCreation_failed = 34,
	ZSTD_error_parameter_unsupported = 40,
	ZSTD_error_parameter_outOfBound = 42,
	ZSTD_error_tableLog_tooLarge = 44,
	ZSTD_error_maxSymbolValue_tooLarge = 46,
	ZSTD_error_maxSymbolValue_tooSmall = 48,
	ZSTD_error_stage_wrong = 60,
	ZSTD_error_init_missing = 62,
	ZSTD_error_memory_allocation = 64,
	ZSTD_error_workSpace_tooSmall = 66,
	ZSTD_error_dstSize_tooSmall = 70,
	ZSTD_error_srcSize_wrong = 72,
	ZSTD_error_dstBuffer_null = 74,
	ZSTD_error_frameIndex_tooLarge = 100,
	ZSTD_error_seekableIO = 102,
	ZSTD_error_dstBuffer_wrong = 104,
	ZSTD_error_srcBuffer_wrong = 105,
	ZSTD_error_maxCode = 120,
} ZSTD_ErrorCode;

typedef ZSTD_ErrorCode ERR_enum;

typedef enum {
	FSE_repeat_none = 0,
	FSE_repeat_check = 1,
	FSE_repeat_valid = 2,
} FSE_repeat;

typedef enum {
	trustInput = 0,
	checkMaxSymbolValue = 1,
} HIST_checkInput_e;

typedef enum {
	HUF_singleStream = 0,
	HUF_fourStreams = 1,
} HUF_nbStreams_e;

typedef enum {
	HUF_repeat_none = 0,
	HUF_repeat_check = 1,
	HUF_repeat_valid = 2,
} HUF_repeat;

typedef enum {
	ZSTD_e_continue = 0,
	ZSTD_e_flush = 1,
	ZSTD_e_end = 2,
} ZSTD_EndDirective;

typedef enum {
	zop_dynamic = 0,
	zop_predef = 1,
} ZSTD_OptPrice_e;

typedef enum {
	ZSTD_reset_session_only = 1,
	ZSTD_reset_parameters = 2,
	ZSTD_reset_session_and_parameters = 3,
} ZSTD_ResetDirective;

typedef enum {
	ZSTD_bm_buffered = 0,
	ZSTD_bm_stable = 1,
} ZSTD_bufferMode_e;

typedef enum {
	ZSTDb_not_buffered = 0,
	ZSTDb_buffered = 1,
} ZSTD_buffered_policy_e;

typedef enum {
	ZSTD_cpm_noAttachDict = 0,
	ZSTD_cpm_attachDict = 1,
	ZSTD_cpm_createCDict = 2,
	ZSTD_cpm_unknown = 3,
} ZSTD_cParamMode_e;

typedef enum {
	ZSTD_c_compressionLevel = 100,
	ZSTD_c_windowLog = 101,
	ZSTD_c_hashLog = 102,
	ZSTD_c_chainLog = 103,
	ZSTD_c_searchLog = 104,
	ZSTD_c_minMatch = 105,
	ZSTD_c_targetLength = 106,
	ZSTD_c_strategy = 107,
	ZSTD_c_enableLongDistanceMatching = 160,
	ZSTD_c_ldmHashLog = 161,
	ZSTD_c_ldmMinMatch = 162,
	ZSTD_c_ldmBucketSizeLog = 163,
	ZSTD_c_ldmHashRateLog = 164,
	ZSTD_c_contentSizeFlag = 200,
	ZSTD_c_checksumFlag = 201,
	ZSTD_c_dictIDFlag = 202,
	ZSTD_c_nbWorkers = 400,
	ZSTD_c_jobSize = 401,
	ZSTD_c_overlapLog = 402,
	ZSTD_c_experimentalParam1 = 500,
	ZSTD_c_experimentalParam2 = 10,
	ZSTD_c_experimentalParam3 = 1000,
	ZSTD_c_experimentalParam4 = 1001,
	ZSTD_c_experimentalParam5 = 1002,
	ZSTD_c_experimentalParam6 = 1003,
	ZSTD_c_experimentalParam7 = 1004,
	ZSTD_c_experimentalParam8 = 1005,
	ZSTD_c_experimentalParam9 = 1006,
	ZSTD_c_experimentalParam10 = 1007,
	ZSTD_c_experimentalParam11 = 1008,
	ZSTD_c_experimentalParam12 = 1009,
	ZSTD_c_experimentalParam13 = 1010,
	ZSTD_c_experimentalParam14 = 1011,
	ZSTD_c_experimentalParam15 = 1012,
} ZSTD_cParameter;

typedef enum {
	zcss_init = 0,
	zcss_load = 1,
	zcss_flush = 2,
} ZSTD_cStreamStage;

typedef enum {
	ZSTDcrp_makeClean = 0,
	ZSTDcrp_leaveDirty = 1,
} ZSTD_compResetPolicy_e;

typedef enum {
	ZSTDcs_created = 0,
	ZSTDcs_init = 1,
	ZSTDcs_ongoing = 2,
	ZSTDcs_ending = 3,
} ZSTD_compressionStage_e;

typedef enum {
	ZSTD_cwksp_alloc_objects = 0,
	ZSTD_cwksp_alloc_buffers = 1,
	ZSTD_cwksp_alloc_aligned = 2,
} ZSTD_cwksp_alloc_phase_e;

typedef enum {
	ZSTD_cwksp_dynamic_alloc = 0,
	ZSTD_cwksp_static_alloc = 1,
} ZSTD_cwksp_static_alloc_e;

typedef enum {
	ZSTD_d_windowLogMax = 100,
	ZSTD_d_experimentalParam1 = 1000,
	ZSTD_d_experimentalParam2 = 1001,
	ZSTD_d_experimentalParam3 = 1002,
	ZSTD_d_experimentalParam4 = 1003,
} ZSTD_dParameter;

typedef enum {
	ZSTDds_getFrameHeaderSize = 0,
	ZSTDds_decodeFrameHeader = 1,
	ZSTDds_decodeBlockHeader = 2,
	ZSTDds_decompressBlock = 3,
	ZSTDds_decompressLastBlock = 4,
	ZSTDds_checkChecksum = 5,
	ZSTDds_decodeSkippableHeader = 6,
	ZSTDds_skipFrame = 7,
} ZSTD_dStage;

typedef enum {
	zdss_init = 0,
	zdss_loadHeader = 1,
	zdss_read = 2,
	zdss_load = 3,
	zdss_flush = 4,
} ZSTD_dStreamStage;

typedef enum {
	ZSTD_defaultDisallowed = 0,
	ZSTD_defaultAllowed = 1,
} ZSTD_defaultPolicy_e;

typedef enum {
	ZSTD_dictDefaultAttach = 0,
	ZSTD_dictForceAttach = 1,
	ZSTD_dictForceCopy = 2,
	ZSTD_dictForceLoad = 3,
} ZSTD_dictAttachPref_e;

typedef enum {
	ZSTD_dct_auto = 0,
	ZSTD_dct_rawContent = 1,
	ZSTD_dct_fullDict = 2,
} ZSTD_dictContentType_e;

typedef enum {
	ZSTD_dlm_byCopy = 0,
	ZSTD_dlm_byRef = 1,
} ZSTD_dictLoadMethod_e;

typedef enum {
	ZSTD_noDict = 0,
	ZSTD_extDict = 1,
	ZSTD_dictMatchState = 2,
	ZSTD_dedicatedDictSearch = 3,
} ZSTD_dictMode_e;

typedef enum {
	ZSTD_dtlm_fast = 0,
	ZSTD_dtlm_full = 1,
} ZSTD_dictTableLoadMethod_e;

typedef enum {
	ZSTD_use_indefinitely = -1,
	ZSTD_dont_use = 0,
	ZSTD_use_once = 1,
} ZSTD_dictUses_e;

typedef enum {
	ZSTD_d_validateChecksum = 0,
	ZSTD_d_ignoreChecksum = 1,
} ZSTD_forceIgnoreChecksum_e;

typedef enum {
	ZSTD_f_zstd1 = 0,
	ZSTD_f_zstd1_magicless = 1,
} ZSTD_format_e;

typedef enum {
	ZSTD_frame = 0,
	ZSTD_skippableFrame = 1,
} ZSTD_frameType_e;

typedef enum {
	ZSTDirp_continue = 0,
	ZSTDirp_reset = 1,
} ZSTD_indexResetPolicy_e;

typedef enum {
	ZSTD_not_in_dst = 0,
	ZSTD_in_dst = 1,
	ZSTD_split = 2,
} ZSTD_litLocation_e;

typedef enum {
	ZSTD_llt_none = 0,
	ZSTD_llt_literalLength = 1,
	ZSTD_llt_matchLength = 2,
} ZSTD_longLengthType_e;

typedef enum {
	ZSTD_lo_isRegularOffset = 0,
	ZSTD_lo_isLongOffset = 1,
} ZSTD_longOffset_e;

typedef enum {
	ZSTDnit_frameHeader = 0,
	ZSTDnit_blockHeader = 1,
	ZSTDnit_block = 2,
	ZSTDnit_lastBlock = 3,
	ZSTDnit_checksum = 4,
	ZSTDnit_skippableFrame = 5,
} ZSTD_nextInputType_e;

typedef enum {
	ZSTD_no_overlap = 0,
	ZSTD_overlap_src_before_dst = 1,
} ZSTD_overlap_e;

typedef enum {
	ZSTD_ps_auto = 0,
	ZSTD_ps_enable = 1,
	ZSTD_ps_disable = 2,
} ZSTD_paramSwitch_e;

typedef enum {
	ZSTD_rmd_refSingleDDict = 0,
	ZSTD_rmd_refMultipleDDicts = 1,
} ZSTD_refMultipleDDicts_e;

typedef enum {
	ZSTD_resetTarget_CDict = 0,
	ZSTD_resetTarget_CCtx = 1,
} ZSTD_resetTarget_e;

typedef enum {
	ZSTD_sf_noBlockDelimiters = 0,
	ZSTD_sf_explicitBlockDelimiters = 1,
} ZSTD_sequenceFormat_e;

typedef enum {
	ZSTD_fast = 1,
	ZSTD_dfast = 2,
	ZSTD_greedy = 3,
	ZSTD_lazy = 4,
	ZSTD_lazy2 = 5,
	ZSTD_btlazy2 = 6,
	ZSTD_btopt = 7,
	ZSTD_btultra = 8,
	ZSTD_btultra2 = 9,
} ZSTD_strategy;

typedef enum {
	OSL_GLOBAL_LOCK_HANDLER = 0,
	OSL_NOTIFY_HANDLER = 1,
	OSL_GPE_HANDLER = 2,
	OSL_DEBUGGER_MAIN_THREAD = 3,
	OSL_DEBUGGER_EXEC_THREAD = 4,
	OSL_EC_POLL_HANDLER = 5,
	OSL_EC_BURST_HANDLER = 6,
} acpi_execute_type;

typedef enum {
	ACPI_IMODE_LOAD_PASS1 = 1,
	ACPI_IMODE_LOAD_PASS2 = 2,
	ACPI_IMODE_EXECUTE = 3,
} acpi_interpreter_mode;

typedef enum {
	ACPI_TRACE_AML_METHOD = 0,
	ACPI_TRACE_AML_OPCODE = 1,
	ACPI_TRACE_AML_REGION = 2,
} acpi_trace_event_type;

typedef enum {
	l_set_mac_addr = 0,
	l_del_mac_addr = 1,
	l_svc_setup = 2,
	l_addr_delete = 3,
	l_topology_change = 4,
	l_flush_complete = 5,
	l_arp_update = 6,
	l_narp_req = 7,
	l_config = 8,
	l_flush_tran_id = 9,
	l_set_lecid = 10,
	l_arp_xmt = 11,
	l_rdesc_arp_xmt = 12,
	l_associate_req = 13,
	l_should_bridge = 14,
} atmlec_msg_type;

typedef enum {
	bt_raw = 0,
	bt_rle = 1,
	bt_compressed = 2,
	bt_reserved = 3,
} blockType_e;

typedef enum {
	need_more = 0,
	block_done = 1,
	finish_started = 2,
	finish_done = 3,
} block_state;

typedef enum {
	CODES = 0,
	LENS = 1,
	DISTS = 2,
} codetype;

typedef enum {
	FILE_MEMORY_MIGRATE = 0,
	FILE_CPULIST = 1,
	FILE_MEMLIST = 2,
	FILE_EFFECTIVE_CPULIST = 3,
	FILE_EFFECTIVE_MEMLIST = 4,
	FILE_SUBPARTS_CPULIST = 5,
	FILE_EXCLUSIVE_CPULIST = 6,
	FILE_EFFECTIVE_XCPULIST = 7,
	FILE_ISOLATED_CPULIST = 8,
	FILE_CPU_EXCLUSIVE = 9,
	FILE_MEM_EXCLUSIVE = 10,
	FILE_MEM_HARDWALL = 11,
	FILE_SCHED_LOAD_BALANCE = 12,
	FILE_PARTITION_ROOT = 13,
	FILE_SCHED_RELAX_DOMAIN_LEVEL = 14,
	FILE_MEMORY_PRESSURE_ENABLED = 15,
	FILE_MEMORY_PRESSURE = 16,
	FILE_SPREAD_PAGE = 17,
	FILE_SPREAD_SLAB = 18,
} cpuset_filetype_t;

typedef enum {
	CS_ONLINE = 0,
	CS_CPU_EXCLUSIVE = 1,
	CS_MEM_EXCLUSIVE = 2,
	CS_MEM_HARDWALL = 3,
	CS_MEMORY_MIGRATE = 4,
	CS_SCHED_LOAD_BALANCE = 5,
	CS_SPREAD_PAGE = 6,
	CS_SPREAD_SLAB = 7,
} cpuset_flagbits_t;

typedef enum {
	noDict = 0,
	withPrefix64k = 1,
	usingExtDict = 2,
} dict_directive;

typedef enum {
	EITHER = 0,
	INDEX = 1,
	DIRENT = 2,
	DIRENT_HTREE = 3,
} dirblock_type_t;

typedef enum {
	decode_full_block = 0,
	partial_decode = 1,
} earlyEnd_directive;

typedef enum {
	endOnOutputSize = 0,
	endOnInputSize = 1,
} endCondition_directive;

typedef enum {
	EXT4_IGET_NORMAL = 0,
	EXT4_IGET_SPECIAL = 1,
	EXT4_IGET_HANDLE = 2,
	EXT4_IGET_BAD = 4,
	EXT4_IGET_EA_INODE = 8,
} ext4_iget_flags;

typedef enum {
	HEAD = 0,
	FLAGS = 1,
	TIME = 2,
	OS = 3,
	EXLEN = 4,
	EXTRA = 5,
	NAME = 6,
	COMMENT = 7,
	HCRC = 8,
	DICTID = 9,
	DICT = 10,
	TYPE = 11,
	TYPEDO = 12,
	STORED = 13,
	COPY = 14,
	TABLE = 15,
	LENLENS = 16,
	CODELENS = 17,
	LEN = 18,
	LENEXT = 19,
	DIST = 20,
	DISTEXT = 21,
	MATCH = 22,
	LIT = 23,
	CHECK = 24,
	LENGTH = 25,
	DONE = 26,
	BAD = 27,
	MEM = 28,
	SYNC = 29,
} inflate_mode;

typedef enum {
	IPVL_IPV6 = 0,
	IPVL_ICMPV6 = 1,
	IPVL_IPV4 = 2,
	IPVL_ARP = 3,
} ipvl_hdr_type;

typedef enum {
	ISOLATE_ABORT = 0,
	ISOLATE_NONE = 1,
	ISOLATE_SUCCESS = 2,
} isolate_migrate_t;

typedef enum {
	MAP_CHG_REUSE = 0,
	MAP_CHG_NEEDED = 1,
	MAP_CHG_ENFORCED = 2,
} map_chg_state;

typedef enum {
	PAGE_KEEP = 0,
	PAGE_ACTIVATE = 1,
	PAGE_SUCCESS = 2,
	PAGE_CLEAN = 3,
} pageout_t;

typedef enum {
	PHY_INTERFACE_MODE_NA = 0,
	PHY_INTERFACE_MODE_INTERNAL = 1,
	PHY_INTERFACE_MODE_MII = 2,
	PHY_INTERFACE_MODE_GMII = 3,
	PHY_INTERFACE_MODE_SGMII = 4,
	PHY_INTERFACE_MODE_TBI = 5,
	PHY_INTERFACE_MODE_REVMII = 6,
	PHY_INTERFACE_MODE_RMII = 7,
	PHY_INTERFACE_MODE_REVRMII = 8,
	PHY_INTERFACE_MODE_RGMII = 9,
	PHY_INTERFACE_MODE_RGMII_ID = 10,
	PHY_INTERFACE_MODE_RGMII_RXID = 11,
	PHY_INTERFACE_MODE_RGMII_TXID = 12,
	PHY_INTERFACE_MODE_RTBI = 13,
	PHY_INTERFACE_MODE_SMII = 14,
	PHY_INTERFACE_MODE_XGMII = 15,
	PHY_INTERFACE_MODE_XLGMII = 16,
	PHY_INTERFACE_MODE_MOCA = 17,
	PHY_INTERFACE_MODE_PSGMII = 18,
	PHY_INTERFACE_MODE_QSGMII = 19,
	PHY_INTERFACE_MODE_TRGMII = 20,
	PHY_INTERFACE_MODE_100BASEX = 21,
	PHY_INTERFACE_MODE_1000BASEX = 22,
	PHY_INTERFACE_MODE_2500BASEX = 23,
	PHY_INTERFACE_MODE_5GBASER = 24,
	PHY_INTERFACE_MODE_RXAUI = 25,
	PHY_INTERFACE_MODE_XAUI = 26,
	PHY_INTERFACE_MODE_10GBASER = 27,
	PHY_INTERFACE_MODE_25GBASER = 28,
	PHY_INTERFACE_MODE_USXGMII = 29,
	PHY_INTERFACE_MODE_10GKR = 30,
	PHY_INTERFACE_MODE_QUSGMII = 31,
	PHY_INTERFACE_MODE_1000BASEKX = 32,
	PHY_INTERFACE_MODE_10G_QXGMII = 33,
	PHY_INTERFACE_MODE_MAX = 34,
} phy_interface_t;

typedef enum {
	PSMOUSE_BAD_DATA = 0,
	PSMOUSE_GOOD_DATA = 1,
	PSMOUSE_FULL_PACKET = 2,
} psmouse_ret_t;

typedef enum {
	search_hashChain = 0,
	search_binaryTree = 1,
	search_rowHash = 2,
} searchMethod_e;

typedef enum {
	SS_FREE = 0,
	SS_UNCONNECTED = 1,
	SS_CONNECTING = 2,
	SS_CONNECTED = 3,
	SS_DISCONNECTING = 4,
} socket_state;

typedef enum {
	STATUSTYPE_INFO = 0,
	STATUSTYPE_TABLE = 1,
	STATUSTYPE_IMA = 2,
} status_type_t;

typedef enum {
	not_streaming = 0,
	is_streaming = 1,
} streaming_operation;

typedef enum {
	set_basic = 0,
	set_rle = 1,
	set_compressed = 2,
	set_repeat = 3,
} symbolEncodingType_e;

typedef enum {
	XFS_EXT_NORM = 0,
	XFS_EXT_UNWRITTEN = 1,
} xfs_exntst_t;

typedef enum {
	XFS_LOOKUP_EQi = 0,
	XFS_LOOKUP_LEi = 1,
	XFS_LOOKUP_GEi = 2,
} xfs_lookup_t;

typedef ZSTD_ErrorCode zstd_error_code;

enum CSI_J {
	CSI_J_CURSOR_TO_END = 0,
	CSI_J_START_TO_CURSOR = 1,
	CSI_J_VISIBLE = 2,
	CSI_J_FULL = 3,
};

enum CSI_right_square_bracket {
	CSI_RSB_COLOR_FOR_UNDERLINE = 1,
	CSI_RSB_COLOR_FOR_HALF_BRIGHT = 2,
	CSI_RSB_MAKE_CUR_COLOR_DEFAULT = 8,
	CSI_RSB_BLANKING_INTERVAL = 9,
	CSI_RSB_BELL_FREQUENCY = 10,
	CSI_RSB_BELL_DURATION = 11,
	CSI_RSB_BRING_CONSOLE_TO_FRONT = 12,
	CSI_RSB_UNBLANK = 13,
	CSI_RSB_VESA_OFF_INTERVAL = 14,
	CSI_RSB_BRING_PREV_CONSOLE_TO_FRONT = 15,
	CSI_RSB_CURSOR_BLINK_INTERVAL = 16,
};

enum ENA_XDP_ACTIONS {
	ENA_XDP_PASS = 0,
	ENA_XDP_TX = 1,
	ENA_XDP_REDIRECT = 2,
	ENA_XDP_DROP = 4,
};

enum KTHREAD_BITS {
	KTHREAD_IS_PER_CPU = 0,
	KTHREAD_SHOULD_STOP = 1,
	KTHREAD_SHOULD_PARK = 2,
};

enum OID {
	OID_id_dsa_with_sha1 = 0,
	OID_id_dsa = 1,
	OID_id_ecPublicKey = 2,
	OID_id_prime192v1 = 3,
	OID_id_prime256v1 = 4,
	OID_id_ecdsa_with_sha1 = 5,
	OID_id_ecdsa_with_sha224 = 6,
	OID_id_ecdsa_with_sha256 = 7,
	OID_id_ecdsa_with_sha384 = 8,
	OID_id_ecdsa_with_sha512 = 9,
	OID_rsaEncryption = 10,
	OID_sha1WithRSAEncryption = 11,
	OID_sha256WithRSAEncryption = 12,
	OID_sha384WithRSAEncryption = 13,
	OID_sha512WithRSAEncryption = 14,
	OID_sha224WithRSAEncryption = 15,
	OID_data = 16,
	OID_signed_data = 17,
	OID_email_address = 18,
	OID_contentType = 19,
	OID_messageDigest = 20,
	OID_signingTime = 21,
	OID_smimeCapabilites = 22,
	OID_smimeAuthenticatedAttrs = 23,
	OID_mskrb5 = 24,
	OID_krb5 = 25,
	OID_krb5u2u = 26,
	OID_msIndirectData = 27,
	OID_msStatementType = 28,
	OID_msSpOpusInfo = 29,
	OID_msPeImageDataObjId = 30,
	OID_msIndividualSPKeyPurpose = 31,
	OID_msOutlookExpress = 32,
	OID_ntlmssp = 33,
	OID_negoex = 34,
	OID_spnego = 35,
	OID_IAKerb = 36,
	OID_PKU2U = 37,
	OID_Scram = 38,
	OID_certAuthInfoAccess = 39,
	OID_sha1 = 40,
	OID_id_ansip384r1 = 41,
	OID_id_ansip521r1 = 42,
	OID_sha256 = 43,
	OID_sha384 = 44,
	OID_sha512 = 45,
	OID_sha224 = 46,
	OID_commonName = 47,
	OID_surname = 48,
	OID_countryName = 49,
	OID_locality = 50,
	OID_stateOrProvinceName = 51,
	OID_organizationName = 52,
	OID_organizationUnitName = 53,
	OID_title = 54,
	OID_description = 55,
	OID_name = 56,
	OID_givenName = 57,
	OID_initials = 58,
	OID_generationalQualifier = 59,
	OID_subjectKeyIdentifier = 60,
	OID_keyUsage = 61,
	OID_subjectAltName = 62,
	OID_issuerAltName = 63,
	OID_basicConstraints = 64,
	OID_crlDistributionPoints = 65,
	OID_certPolicies = 66,
	OID_authorityKeyIdentifier = 67,
	OID_extKeyUsage = 68,
	OID_NetlogonMechanism = 69,
	OID_appleLocalKdcSupported = 70,
	OID_gostCPSignA = 71,
	OID_gostCPSignB = 72,
	OID_gostCPSignC = 73,
	OID_gost2012PKey256 = 74,
	OID_gost2012PKey512 = 75,
	OID_gost2012Digest256 = 76,
	OID_gost2012Digest512 = 77,
	OID_gost2012Signature256 = 78,
	OID_gost2012Signature512 = 79,
	OID_gostTC26Sign256A = 80,
	OID_gostTC26Sign256B = 81,
	OID_gostTC26Sign256C = 82,
	OID_gostTC26Sign256D = 83,
	OID_gostTC26Sign512A = 84,
	OID_gostTC26Sign512B = 85,
	OID_gostTC26Sign512C = 86,
	OID_sm2 = 87,
	OID_sm3 = 88,
	OID_SM2_with_SM3 = 89,
	OID_sm3WithRSAEncryption = 90,
	OID_TPMLoadableKey = 91,
	OID_TPMImportableKey = 92,
	OID_TPMSealedData = 93,
	OID_sha3_256 = 94,
	OID_sha3_384 = 95,
	OID_sha3_512 = 96,
	OID_id_ecdsa_with_sha3_256 = 97,
	OID_id_ecdsa_with_sha3_384 = 98,
	OID_id_ecdsa_with_sha3_512 = 99,
	OID_id_rsassa_pkcs1_v1_5_with_sha3_256 = 100,
	OID_id_rsassa_pkcs1_v1_5_with_sha3_384 = 101,
	OID_id_rsassa_pkcs1_v1_5_with_sha3_512 = 102,
	OID__NR = 103,
};

enum P4_ESCR_EMASKS {
	P4_EVENT_TC_DELIVER_MODE__DD = 512,
	P4_EVENT_TC_DELIVER_MODE__DB = 1024,
	P4_EVENT_TC_DELIVER_MODE__DI = 2048,
	P4_EVENT_TC_DELIVER_MODE__BD = 4096,
	P4_EVENT_TC_DELIVER_MODE__BB = 8192,
	P4_EVENT_TC_DELIVER_MODE__BI = 16384,
	P4_EVENT_TC_DELIVER_MODE__ID = 32768,
	P4_EVENT_BPU_FETCH_REQUEST__TCMISS = 512,
	P4_EVENT_ITLB_REFERENCE__HIT = 512,
	P4_EVENT_ITLB_REFERENCE__MISS = 1024,
	P4_EVENT_ITLB_REFERENCE__HIT_UK = 2048,
	P4_EVENT_MEMORY_CANCEL__ST_RB_FULL = 2048,
	P4_EVENT_MEMORY_CANCEL__64K_CONF = 4096,
	P4_EVENT_MEMORY_COMPLETE__LSC = 512,
	P4_EVENT_MEMORY_COMPLETE__SSC = 1024,
	P4_EVENT_LOAD_PORT_REPLAY__SPLIT_LD = 1024,
	P4_EVENT_STORE_PORT_REPLAY__SPLIT_ST = 1024,
	P4_EVENT_MOB_LOAD_REPLAY__NO_STA = 1024,
	P4_EVENT_MOB_LOAD_REPLAY__NO_STD = 4096,
	P4_EVENT_MOB_LOAD_REPLAY__PARTIAL_DATA = 8192,
	P4_EVENT_MOB_LOAD_REPLAY__UNALGN_ADDR = 16384,
	P4_EVENT_PAGE_WALK_TYPE__DTMISS = 512,
	P4_EVENT_PAGE_WALK_TYPE__ITMISS = 1024,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITS = 512,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITE = 1024,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITM = 2048,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITS = 4096,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITE = 8192,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITM = 16384,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_MISS = 131072,
	P4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_MISS = 262144,
	P4_EVENT_BSQ_CACHE_REFERENCE__WR_2ndL_MISS = 524288,
	P4_EVENT_IOQ_ALLOCATION__DEFAULT = 512,
	P4_EVENT_IOQ_ALLOCATION__ALL_READ = 16384,
	P4_EVENT_IOQ_ALLOCATION__ALL_WRITE = 32768,
	P4_EVENT_IOQ_ALLOCATION__MEM_UC = 65536,
	P4_EVENT_IOQ_ALLOCATION__MEM_WC = 131072,
	P4_EVENT_IOQ_ALLOCATION__MEM_WT = 262144,
	P4_EVENT_IOQ_ALLOCATION__MEM_WP = 524288,
	P4_EVENT_IOQ_ALLOCATION__MEM_WB = 1048576,
	P4_EVENT_IOQ_ALLOCATION__OWN = 4194304,
	P4_EVENT_IOQ_ALLOCATION__OTHER = 8388608,
	P4_EVENT_IOQ_ALLOCATION__PREFETCH = 16777216,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__DEFAULT = 512,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__ALL_READ = 16384,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__ALL_WRITE = 32768,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_UC = 65536,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WC = 131072,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WT = 262144,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WP = 524288,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WB = 1048576,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__OWN = 4194304,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__OTHER = 8388608,
	P4_EVENT_IOQ_ACTIVE_ENTRIES__PREFETCH = 16777216,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_DRV = 512,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_OWN = 1024,
	P4_EVENT_FSB_DATA_ACTIVITY__DRDY_OTHER = 2048,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_DRV = 4096,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_OWN = 8192,
	P4_EVENT_FSB_DATA_ACTIVITY__DBSY_OTHER = 16384,
	P4_EVENT_BSQ_ALLOCATION__REQ_TYPE0 = 512,
	P4_EVENT_BSQ_ALLOCATION__REQ_TYPE1 = 1024,
	P4_EVENT_BSQ_ALLOCATION__REQ_LEN0 = 2048,
	P4_EVENT_BSQ_ALLOCATION__REQ_LEN1 = 4096,
	P4_EVENT_BSQ_ALLOCATION__REQ_IO_TYPE = 16384,
	P4_EVENT_BSQ_ALLOCATION__REQ_LOCK_TYPE = 32768,
	P4_EVENT_BSQ_ALLOCATION__REQ_CACHE_TYPE = 65536,
	P4_EVENT_BSQ_ALLOCATION__REQ_SPLIT_TYPE = 131072,
	P4_EVENT_BSQ_ALLOCATION__REQ_DEM_TYPE = 262144,
	P4_EVENT_BSQ_ALLOCATION__REQ_ORD_TYPE = 524288,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE0 = 1048576,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE1 = 2097152,
	P4_EVENT_BSQ_ALLOCATION__MEM_TYPE2 = 4194304,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_TYPE0 = 512,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_TYPE1 = 1024,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LEN0 = 2048,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LEN1 = 4096,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_IO_TYPE = 16384,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LOCK_TYPE = 32768,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_CACHE_TYPE = 65536,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_SPLIT_TYPE = 131072,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_DEM_TYPE = 262144,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_ORD_TYPE = 524288,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE0 = 1048576,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE1 = 2097152,
	P4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE2 = 4194304,
	P4_EVENT_SSE_INPUT_ASSIST__ALL = 16777216,
	P4_EVENT_PACKED_SP_UOP__ALL = 16777216,
	P4_EVENT_PACKED_DP_UOP__ALL = 16777216,
	P4_EVENT_SCALAR_SP_UOP__ALL = 16777216,
	P4_EVENT_SCALAR_DP_UOP__ALL = 16777216,
	P4_EVENT_64BIT_MMX_UOP__ALL = 16777216,
	P4_EVENT_128BIT_MMX_UOP__ALL = 16777216,
	P4_EVENT_X87_FP_UOP__ALL = 16777216,
	P4_EVENT_TC_MISC__FLUSH = 8192,
	P4_EVENT_GLOBAL_POWER_EVENTS__RUNNING = 512,
	P4_EVENT_TC_MS_XFER__CISC = 512,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_TC_BUILD = 512,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_TC_DELIVER = 1024,
	P4_EVENT_UOP_QUEUE_WRITES__FROM_ROM = 2048,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__CONDITIONAL = 1024,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__CALL = 2048,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__RETURN = 4096,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__INDIRECT = 8192,
	P4_EVENT_RETIRED_BRANCH_TYPE__CONDITIONAL = 1024,
	P4_EVENT_RETIRED_BRANCH_TYPE__CALL = 2048,
	P4_EVENT_RETIRED_BRANCH_TYPE__RETURN = 4096,
	P4_EVENT_RETIRED_BRANCH_TYPE__INDIRECT = 8192,
	P4_EVENT_RESOURCE_STALL__SBFULL = 16384,
	P4_EVENT_WC_BUFFER__WCB_EVICTS = 512,
	P4_EVENT_WC_BUFFER__WCB_FULL_EVICTS = 1024,
	P4_EVENT_FRONT_END_EVENT__NBOGUS = 512,
	P4_EVENT_FRONT_END_EVENT__BOGUS = 1024,
	P4_EVENT_EXECUTION_EVENT__NBOGUS0 = 512,
	P4_EVENT_EXECUTION_EVENT__NBOGUS1 = 1024,
	P4_EVENT_EXECUTION_EVENT__NBOGUS2 = 2048,
	P4_EVENT_EXECUTION_EVENT__NBOGUS3 = 4096,
	P4_EVENT_EXECUTION_EVENT__BOGUS0 = 8192,
	P4_EVENT_EXECUTION_EVENT__BOGUS1 = 16384,
	P4_EVENT_EXECUTION_EVENT__BOGUS2 = 32768,
	P4_EVENT_EXECUTION_EVENT__BOGUS3 = 65536,
	P4_EVENT_REPLAY_EVENT__NBOGUS = 512,
	P4_EVENT_REPLAY_EVENT__BOGUS = 1024,
	P4_EVENT_INSTR_RETIRED__NBOGUSNTAG = 512,
	P4_EVENT_INSTR_RETIRED__NBOGUSTAG = 1024,
	P4_EVENT_INSTR_RETIRED__BOGUSNTAG = 2048,
	P4_EVENT_INSTR_RETIRED__BOGUSTAG = 4096,
	P4_EVENT_UOPS_RETIRED__NBOGUS = 512,
	P4_EVENT_UOPS_RETIRED__BOGUS = 1024,
	P4_EVENT_UOP_TYPE__TAGLOADS = 1024,
	P4_EVENT_UOP_TYPE__TAGSTORES = 2048,
	P4_EVENT_BRANCH_RETIRED__MMNP = 512,
	P4_EVENT_BRANCH_RETIRED__MMNM = 1024,
	P4_EVENT_BRANCH_RETIRED__MMTP = 2048,
	P4_EVENT_BRANCH_RETIRED__MMTM = 4096,
	P4_EVENT_MISPRED_BRANCH_RETIRED__NBOGUS = 512,
	P4_EVENT_X87_ASSIST__FPSU = 512,
	P4_EVENT_X87_ASSIST__FPSO = 1024,
	P4_EVENT_X87_ASSIST__POAO = 2048,
	P4_EVENT_X87_ASSIST__POAU = 4096,
	P4_EVENT_X87_ASSIST__PREA = 8192,
	P4_EVENT_MACHINE_CLEAR__CLEAR = 512,
	P4_EVENT_MACHINE_CLEAR__MOCLEAR = 1024,
	P4_EVENT_MACHINE_CLEAR__SMCLEAR = 2048,
	P4_EVENT_INSTR_COMPLETED__NBOGUS = 512,
	P4_EVENT_INSTR_COMPLETED__BOGUS = 1024,
};

enum P4_EVENTS {
	P4_EVENT_TC_DELIVER_MODE = 0,
	P4_EVENT_BPU_FETCH_REQUEST = 1,
	P4_EVENT_ITLB_REFERENCE = 2,
	P4_EVENT_MEMORY_CANCEL = 3,
	P4_EVENT_MEMORY_COMPLETE = 4,
	P4_EVENT_LOAD_PORT_REPLAY = 5,
	P4_EVENT_STORE_PORT_REPLAY = 6,
	P4_EVENT_MOB_LOAD_REPLAY = 7,
	P4_EVENT_PAGE_WALK_TYPE = 8,
	P4_EVENT_BSQ_CACHE_REFERENCE = 9,
	P4_EVENT_IOQ_ALLOCATION = 10,
	P4_EVENT_IOQ_ACTIVE_ENTRIES = 11,
	P4_EVENT_FSB_DATA_ACTIVITY = 12,
	P4_EVENT_BSQ_ALLOCATION = 13,
	P4_EVENT_BSQ_ACTIVE_ENTRIES = 14,
	P4_EVENT_SSE_INPUT_ASSIST = 15,
	P4_EVENT_PACKED_SP_UOP = 16,
	P4_EVENT_PACKED_DP_UOP = 17,
	P4_EVENT_SCALAR_SP_UOP = 18,
	P4_EVENT_SCALAR_DP_UOP = 19,
	P4_EVENT_64BIT_MMX_UOP = 20,
	P4_EVENT_128BIT_MMX_UOP = 21,
	P4_EVENT_X87_FP_UOP = 22,
	P4_EVENT_TC_MISC = 23,
	P4_EVENT_GLOBAL_POWER_EVENTS = 24,
	P4_EVENT_TC_MS_XFER = 25,
	P4_EVENT_UOP_QUEUE_WRITES = 26,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE = 27,
	P4_EVENT_RETIRED_BRANCH_TYPE = 28,
	P4_EVENT_RESOURCE_STALL = 29,
	P4_EVENT_WC_BUFFER = 30,
	P4_EVENT_B2B_CYCLES = 31,
	P4_EVENT_BNR = 32,
	P4_EVENT_SNOOP = 33,
	P4_EVENT_RESPONSE = 34,
	P4_EVENT_FRONT_END_EVENT = 35,
	P4_EVENT_EXECUTION_EVENT = 36,
	P4_EVENT_REPLAY_EVENT = 37,
	P4_EVENT_INSTR_RETIRED = 38,
	P4_EVENT_UOPS_RETIRED = 39,
	P4_EVENT_UOP_TYPE = 40,
	P4_EVENT_BRANCH_RETIRED = 41,
	P4_EVENT_MISPRED_BRANCH_RETIRED = 42,
	P4_EVENT_X87_ASSIST = 43,
	P4_EVENT_MACHINE_CLEAR = 44,
	P4_EVENT_INSTR_COMPLETED = 45,
};

enum P4_EVENT_OPCODES {
	P4_EVENT_TC_DELIVER_MODE_OPCODE = 257,
	P4_EVENT_BPU_FETCH_REQUEST_OPCODE = 768,
	P4_EVENT_ITLB_REFERENCE_OPCODE = 6147,
	P4_EVENT_MEMORY_CANCEL_OPCODE = 517,
	P4_EVENT_MEMORY_COMPLETE_OPCODE = 2050,
	P4_EVENT_LOAD_PORT_REPLAY_OPCODE = 1026,
	P4_EVENT_STORE_PORT_REPLAY_OPCODE = 1282,
	P4_EVENT_MOB_LOAD_REPLAY_OPCODE = 770,
	P4_EVENT_PAGE_WALK_TYPE_OPCODE = 260,
	P4_EVENT_BSQ_CACHE_REFERENCE_OPCODE = 3079,
	P4_EVENT_IOQ_ALLOCATION_OPCODE = 774,
	P4_EVENT_IOQ_ACTIVE_ENTRIES_OPCODE = 6662,
	P4_EVENT_FSB_DATA_ACTIVITY_OPCODE = 5894,
	P4_EVENT_BSQ_ALLOCATION_OPCODE = 1287,
	P4_EVENT_BSQ_ACTIVE_ENTRIES_OPCODE = 1543,
	P4_EVENT_SSE_INPUT_ASSIST_OPCODE = 13313,
	P4_EVENT_PACKED_SP_UOP_OPCODE = 2049,
	P4_EVENT_PACKED_DP_UOP_OPCODE = 3073,
	P4_EVENT_SCALAR_SP_UOP_OPCODE = 2561,
	P4_EVENT_SCALAR_DP_UOP_OPCODE = 3585,
	P4_EVENT_64BIT_MMX_UOP_OPCODE = 513,
	P4_EVENT_128BIT_MMX_UOP_OPCODE = 6657,
	P4_EVENT_X87_FP_UOP_OPCODE = 1025,
	P4_EVENT_TC_MISC_OPCODE = 1537,
	P4_EVENT_GLOBAL_POWER_EVENTS_OPCODE = 4870,
	P4_EVENT_TC_MS_XFER_OPCODE = 1280,
	P4_EVENT_UOP_QUEUE_WRITES_OPCODE = 2304,
	P4_EVENT_RETIRED_MISPRED_BRANCH_TYPE_OPCODE = 1282,
	P4_EVENT_RETIRED_BRANCH_TYPE_OPCODE = 1026,
	P4_EVENT_RESOURCE_STALL_OPCODE = 257,
	P4_EVENT_WC_BUFFER_OPCODE = 1285,
	P4_EVENT_B2B_CYCLES_OPCODE = 5635,
	P4_EVENT_BNR_OPCODE = 2051,
	P4_EVENT_SNOOP_OPCODE = 1539,
	P4_EVENT_RESPONSE_OPCODE = 1027,
	P4_EVENT_FRONT_END_EVENT_OPCODE = 2053,
	P4_EVENT_EXECUTION_EVENT_OPCODE = 3077,
	P4_EVENT_REPLAY_EVENT_OPCODE = 2309,
	P4_EVENT_INSTR_RETIRED_OPCODE = 516,
	P4_EVENT_UOPS_RETIRED_OPCODE = 260,
	P4_EVENT_UOP_TYPE_OPCODE = 514,
	P4_EVENT_BRANCH_RETIRED_OPCODE = 1541,
	P4_EVENT_MISPRED_BRANCH_RETIRED_OPCODE = 772,
	P4_EVENT_X87_ASSIST_OPCODE = 773,
	P4_EVENT_MACHINE_CLEAR_OPCODE = 517,
	P4_EVENT_INSTR_COMPLETED_OPCODE = 1796,
};

enum P4_PEBS_METRIC {
	P4_PEBS_METRIC__none = 0,
	P4_PEBS_METRIC__1stl_cache_load_miss_retired = 1,
	P4_PEBS_METRIC__2ndl_cache_load_miss_retired = 2,
	P4_PEBS_METRIC__dtlb_load_miss_retired = 3,
	P4_PEBS_METRIC__dtlb_store_miss_retired = 4,
	P4_PEBS_METRIC__dtlb_all_miss_retired = 5,
	P4_PEBS_METRIC__tagged_mispred_branch = 6,
	P4_PEBS_METRIC__mob_load_replay_retired = 7,
	P4_PEBS_METRIC__split_load_retired = 8,
	P4_PEBS_METRIC__split_store_retired = 9,
	P4_PEBS_METRIC__max = 10,
};

enum SHIFT_DIRECTION {
	SHIFT_LEFT = 0,
	SHIFT_RIGHT = 1,
};

enum SS4_PACKET_ID {
	SS4_PACKET_ID_IDLE = 0,
	SS4_PACKET_ID_ONE = 1,
	SS4_PACKET_ID_TWO = 2,
	SS4_PACKET_ID_MULTI = 3,
	SS4_PACKET_ID_STICK = 4,
};

enum TPM_OPS_FLAGS {
	TPM_OPS_AUTO_STARTUP = 1,
};

enum V7_PACKET_ID {
	V7_PACKET_ID_IDLE = 0,
	V7_PACKET_ID_TWO = 1,
	V7_PACKET_ID_MULTI = 2,
	V7_PACKET_ID_NEW = 3,
	V7_PACKET_ID_UNKNOWN = 4,
};

enum __sk_action {
	__SK_DROP = 0,
	__SK_PASS = 1,
	__SK_REDIRECT = 2,
	__SK_NONE = 3,
};

enum _cache_type {
	CTYPE_NULL = 0,
	CTYPE_DATA = 1,
	CTYPE_INST = 2,
	CTYPE_UNIFIED = 3,
};

enum _record_type {
	_START_RECORD = 0,
	_COMMIT_RECORD = 1,
};

enum _slab_flag_bits {
	_SLAB_CONSISTENCY_CHECKS = 0,
	_SLAB_RED_ZONE = 1,
	_SLAB_POISON = 2,
	_SLAB_KMALLOC = 3,
	_SLAB_HWCACHE_ALIGN = 4,
	_SLAB_CACHE_DMA = 5,
	_SLAB_CACHE_DMA32 = 6,
	_SLAB_STORE_USER = 7,
	_SLAB_PANIC = 8,
	_SLAB_TYPESAFE_BY_RCU = 9,
	_SLAB_TRACE = 10,
	_SLAB_NOLEAKTRACE = 11,
	_SLAB_NO_MERGE = 12,
	_SLAB_ACCOUNT = 13,
	_SLAB_NO_USER_FLAGS = 14,
	_SLAB_SKIP_KFENCE = 15,
	_SLAB_RECLAIM_ACCOUNT = 16,
	_SLAB_OBJECT_POISON = 17,
	_SLAB_CMPXCHG_DOUBLE = 18,
	_SLAB_NO_OBJ_EXT = 19,
	_SLAB_FLAGS_LAST_BIT = 20,
};

enum access_coordinate_class {
	ACCESS_COORDINATE_LOCAL = 0,
	ACCESS_COORDINATE_CPU = 1,
	ACCESS_COORDINATE_MAX = 2,
};

enum ack_type {
	ACK_CLEAR = 0,
	ACK_SET = 1,
};

enum acpi_attr_enum {
	ACPI_ATTR_LABEL_SHOW = 0,
	ACPI_ATTR_INDEX_SHOW = 1,
};

enum acpi_backlight_type {
	acpi_backlight_undef = -1,
	acpi_backlight_none = 0,
	acpi_backlight_video = 1,
	acpi_backlight_vendor = 2,
	acpi_backlight_native = 3,
	acpi_backlight_nvidia_wmi_ec = 4,
	acpi_backlight_apple_gmux = 5,
	acpi_backlight_dell_uart = 6,
};

enum acpi_bridge_type {
	ACPI_BRIDGE_TYPE_PCIE = 1,
	ACPI_BRIDGE_TYPE_CXL = 2,
};

enum acpi_bus_device_type {
	ACPI_BUS_TYPE_DEVICE = 0,
	ACPI_BUS_TYPE_POWER = 1,
	ACPI_BUS_TYPE_PROCESSOR = 2,
	ACPI_BUS_TYPE_THERMAL = 3,
	ACPI_BUS_TYPE_POWER_BUTTON = 4,
	ACPI_BUS_TYPE_SLEEP_BUTTON = 5,
	ACPI_BUS_TYPE_ECDT_EC = 6,
	ACPI_BUS_DEVICE_TYPE_COUNT = 7,
};

enum acpi_cdat_type {
	ACPI_CDAT_TYPE_DSMAS = 0,
	ACPI_CDAT_TYPE_DSLBIS = 1,
	ACPI_CDAT_TYPE_DSMSCIS = 2,
	ACPI_CDAT_TYPE_DSIS = 3,
	ACPI_CDAT_TYPE_DSEMTS = 4,
	ACPI_CDAT_TYPE_SSLBIS = 5,
	ACPI_CDAT_TYPE_RESERVED = 6,
};

enum acpi_cedt_type {
	ACPI_CEDT_TYPE_CHBS = 0,
	ACPI_CEDT_TYPE_CFMWS = 1,
	ACPI_CEDT_TYPE_CXIMS = 2,
	ACPI_CEDT_TYPE_RDPAS = 3,
	ACPI_CEDT_TYPE_RESERVED = 4,
};

enum acpi_device_swnode_dev_props {
	ACPI_DEVICE_SWNODE_DEV_ROTATION = 0,
	ACPI_DEVICE_SWNODE_DEV_CLOCK_FREQUENCY = 1,
	ACPI_DEVICE_SWNODE_DEV_LED_MAX_MICROAMP = 2,
	ACPI_DEVICE_SWNODE_DEV_FLASH_MAX_MICROAMP = 3,
	ACPI_DEVICE_SWNODE_DEV_FLASH_MAX_TIMEOUT_US = 4,
	ACPI_DEVICE_SWNODE_DEV_NUM_OF = 5,
	ACPI_DEVICE_SWNODE_DEV_NUM_ENTRIES = 6,
};

enum acpi_device_swnode_ep_props {
	ACPI_DEVICE_SWNODE_EP_REMOTE_EP = 0,
	ACPI_DEVICE_SWNODE_EP_BUS_TYPE = 1,
	ACPI_DEVICE_SWNODE_EP_REG = 2,
	ACPI_DEVICE_SWNODE_EP_CLOCK_LANES = 3,
	ACPI_DEVICE_SWNODE_EP_DATA_LANES = 4,
	ACPI_DEVICE_SWNODE_EP_LANE_POLARITIES = 5,
	ACPI_DEVICE_SWNODE_EP_LINK_FREQUENCIES = 6,
	ACPI_DEVICE_SWNODE_EP_NUM_OF = 7,
	ACPI_DEVICE_SWNODE_EP_NUM_ENTRIES = 8,
};

enum acpi_device_swnode_port_props {
	ACPI_DEVICE_SWNODE_PORT_REG = 0,
	ACPI_DEVICE_SWNODE_PORT_NUM_OF = 1,
	ACPI_DEVICE_SWNODE_PORT_NUM_ENTRIES = 2,
};

enum acpi_dmar_scope_type {
	ACPI_DMAR_SCOPE_TYPE_NOT_USED = 0,
	ACPI_DMAR_SCOPE_TYPE_ENDPOINT = 1,
	ACPI_DMAR_SCOPE_TYPE_BRIDGE = 2,
	ACPI_DMAR_SCOPE_TYPE_IOAPIC = 3,
	ACPI_DMAR_SCOPE_TYPE_HPET = 4,
	ACPI_DMAR_SCOPE_TYPE_NAMESPACE = 5,
	ACPI_DMAR_SCOPE_TYPE_RESERVED = 6,
};

enum acpi_dmar_type {
	ACPI_DMAR_TYPE_HARDWARE_UNIT = 0,
	ACPI_DMAR_TYPE_RESERVED_MEMORY = 1,
	ACPI_DMAR_TYPE_ROOT_ATS = 2,
	ACPI_DMAR_TYPE_HARDWARE_AFFINITY = 3,
	ACPI_DMAR_TYPE_NAMESPACE = 4,
	ACPI_DMAR_TYPE_SATC = 5,
	ACPI_DMAR_TYPE_RESERVED = 6,
};

enum acpi_ec_event_state {
	EC_EVENT_READY = 0,
	EC_EVENT_IN_PROGRESS = 1,
	EC_EVENT_COMPLETE = 2,
};

enum acpi_irq_model_id {
	ACPI_IRQ_MODEL_PIC = 0,
	ACPI_IRQ_MODEL_IOAPIC = 1,
	ACPI_IRQ_MODEL_IOSAPIC = 2,
	ACPI_IRQ_MODEL_PLATFORM = 3,
	ACPI_IRQ_MODEL_GIC = 4,
	ACPI_IRQ_MODEL_LPIC = 5,
	ACPI_IRQ_MODEL_RINTC = 6,
	ACPI_IRQ_MODEL_COUNT = 7,
};

enum acpi_madt_multiproc_wakeup_version {
	ACPI_MADT_MP_WAKEUP_VERSION_NONE = 0,
	ACPI_MADT_MP_WAKEUP_VERSION_V1 = 1,
	ACPI_MADT_MP_WAKEUP_VERSION_RESERVED = 2,
};

enum acpi_madt_type {
	ACPI_MADT_TYPE_LOCAL_APIC = 0,
	ACPI_MADT_TYPE_IO_APIC = 1,
	ACPI_MADT_TYPE_INTERRUPT_OVERRIDE = 2,
	ACPI_MADT_TYPE_NMI_SOURCE = 3,
	ACPI_MADT_TYPE_LOCAL_APIC_NMI = 4,
	ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE = 5,
	ACPI_MADT_TYPE_IO_SAPIC = 6,
	ACPI_MADT_TYPE_LOCAL_SAPIC = 7,
	ACPI_MADT_TYPE_INTERRUPT_SOURCE = 8,
	ACPI_MADT_TYPE_LOCAL_X2APIC = 9,
	ACPI_MADT_TYPE_LOCAL_X2APIC_NMI = 10,
	ACPI_MADT_TYPE_GENERIC_INTERRUPT = 11,
	ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR = 12,
	ACPI_MADT_TYPE_GENERIC_MSI_FRAME = 13,
	ACPI_MADT_TYPE_GENERIC_REDISTRIBUTOR = 14,
	ACPI_MADT_TYPE_GENERIC_TRANSLATOR = 15,
	ACPI_MADT_TYPE_MULTIPROC_WAKEUP = 16,
	ACPI_MADT_TYPE_CORE_PIC = 17,
	ACPI_MADT_TYPE_LIO_PIC = 18,
	ACPI_MADT_TYPE_HT_PIC = 19,
	ACPI_MADT_TYPE_EIO_PIC = 20,
	ACPI_MADT_TYPE_MSI_PIC = 21,
	ACPI_MADT_TYPE_BIO_PIC = 22,
	ACPI_MADT_TYPE_LPC_PIC = 23,
	ACPI_MADT_TYPE_RINTC = 24,
	ACPI_MADT_TYPE_IMSIC = 25,
	ACPI_MADT_TYPE_APLIC = 26,
	ACPI_MADT_TYPE_PLIC = 27,
	ACPI_MADT_TYPE_RESERVED = 28,
	ACPI_MADT_TYPE_OEM_RESERVED = 128,
};

enum acpi_pcct_type {
	ACPI_PCCT_TYPE_GENERIC_SUBSPACE = 0,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE = 1,
	ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2 = 2,
	ACPI_PCCT_TYPE_EXT_PCC_MASTER_SUBSPACE = 3,
	ACPI_PCCT_TYPE_EXT_PCC_SLAVE_SUBSPACE = 4,
	ACPI_PCCT_TYPE_HW_REG_COMM_SUBSPACE = 5,
	ACPI_PCCT_TYPE_RESERVED = 6,
};

enum acpi_predicate {
	all_versions = 0,
	less_than_or_equal = 1,
	equal = 2,
	greater_than_or_equal = 3,
};

enum acpi_preferred_pm_profiles {
	PM_UNSPECIFIED = 0,
	PM_DESKTOP = 1,
	PM_MOBILE = 2,
	PM_WORKSTATION = 3,
	PM_ENTERPRISE_SERVER = 4,
	PM_SOHO_SERVER = 5,
	PM_APPLIANCE_PC = 6,
	PM_PERFORMANCE_SERVER = 7,
	PM_TABLET = 8,
	NR_PM_PROFILES = 9,
};

enum acpi_reconfig_event {
	ACPI_RECONFIG_DEVICE_ADD = 0,
	ACPI_RECONFIG_DEVICE_REMOVE = 1,
};

enum acpi_return_package_types {
	ACPI_PTYPE1_FIXED = 1,
	ACPI_PTYPE1_VAR = 2,
	ACPI_PTYPE1_OPTION = 3,
	ACPI_PTYPE2 = 4,
	ACPI_PTYPE2_COUNT = 5,
	ACPI_PTYPE2_PKG_COUNT = 6,
	ACPI_PTYPE2_FIXED = 7,
	ACPI_PTYPE2_MIN = 8,
	ACPI_PTYPE2_REV_FIXED = 9,
	ACPI_PTYPE2_FIX_VAR = 10,
	ACPI_PTYPE2_VAR_VAR = 11,
	ACPI_PTYPE2_UUID_PAIR = 12,
	ACPI_PTYPE_CUSTOM = 13,
};

enum acpi_srat_type {
	ACPI_SRAT_TYPE_CPU_AFFINITY = 0,
	ACPI_SRAT_TYPE_MEMORY_AFFINITY = 1,
	ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY = 2,
	ACPI_SRAT_TYPE_GICC_AFFINITY = 3,
	ACPI_SRAT_TYPE_GIC_ITS_AFFINITY = 4,
	ACPI_SRAT_TYPE_GENERIC_AFFINITY = 5,
	ACPI_SRAT_TYPE_GENERIC_PORT_AFFINITY = 6,
	ACPI_SRAT_TYPE_RINTC_AFFINITY = 7,
	ACPI_SRAT_TYPE_RESERVED = 8,
};

enum acpi_subtable_type {
	ACPI_SUBTABLE_COMMON = 0,
	ACPI_SUBTABLE_HMAT = 1,
	ACPI_SUBTABLE_PRMT = 2,
	ACPI_SUBTABLE_CEDT = 3,
	CDAT_SUBTABLE = 4,
};

enum acpi_video_level_idx {
	ACPI_VIDEO_AC_LEVEL = 0,
	ACPI_VIDEO_BATTERY_LEVEL = 1,
	ACPI_VIDEO_FIRST_LEVEL = 2,
};

enum acpi_viot_node_type {
	ACPI_VIOT_NODE_PCI_RANGE = 1,
	ACPI_VIOT_NODE_MMIO = 2,
	ACPI_VIOT_NODE_VIRTIO_IOMMU_PCI = 3,
	ACPI_VIOT_NODE_VIRTIO_IOMMU_MMIO = 4,
	ACPI_VIOT_RESERVED = 5,
};

enum actions {
	REGISTER = 0,
	DEREGISTER = 1,
	CPU_DONT_CARE = 2,
};

enum addr_type_t {
	UNICAST_ADDR = 0,
	MULTICAST_ADDR = 1,
	ANYCAST_ADDR = 2,
};

enum address_markers_idx {
	USER_SPACE_NR = 0,
	KERNEL_SPACE_NR = 1,
	LDT_NR = 2,
	LOW_KERNEL_NR = 3,
	VMALLOC_START_NR = 4,
	VMEMMAP_START_NR = 5,
	CPU_ENTRY_AREA_NR = 6,
	ESPFIX_START_NR = 7,
	EFI_END_NR = 8,
	HIGH_KERNEL_NR = 9,
	MODULES_VADDR_NR = 10,
	MODULES_END_NR = 11,
	FIXADDR_START_NR = 12,
	END_OF_SPACE_NR = 13,
};

enum af_vsockmon_op {
	AF_VSOCK_OP_UNKNOWN = 0,
	AF_VSOCK_OP_CONNECT = 1,
	AF_VSOCK_OP_DISCONNECT = 2,
	AF_VSOCK_OP_CONTROL = 3,
	AF_VSOCK_OP_PAYLOAD = 4,
};

enum af_vsockmon_transport {
	AF_VSOCK_TRANSPORT_UNKNOWN = 0,
	AF_VSOCK_TRANSPORT_NO_INFO = 1,
	AF_VSOCK_TRANSPORT_VIRTIO = 2,
};

enum alarmtimer_type {
	ALARM_REALTIME = 0,
	ALARM_BOOTTIME = 1,
	ALARM_NUMTYPE = 2,
	ALARM_REALTIME_FREEZER = 3,
	ALARM_BOOTTIME_FREEZER = 4,
};

enum align_flags {
	ALIGN_VA_32 = 1,
	ALIGN_VA_64 = 2,
};

enum allow_write_msrs {
	MSR_WRITES_ON = 0,
	MSR_WRITES_OFF = 1,
	MSR_WRITES_DEFAULT = 2,
};

enum amanda_strings {
	SEARCH_CONNECT = 0,
	SEARCH_NEWLINE = 1,
	SEARCH_DATA = 2,
	SEARCH_MESG = 3,
	SEARCH_INDEX = 4,
	SEARCH_STATE = 5,
};

enum amd_iommu_intr_mode_type {
	AMD_IOMMU_GUEST_IR_LEGACY = 0,
	AMD_IOMMU_GUEST_IR_LEGACY_GA = 1,
	AMD_IOMMU_GUEST_IR_VAPIC = 2,
};

enum amd_pref_core {
	AMD_PREF_CORE_UNKNOWN = 0,
	AMD_PREF_CORE_SUPPORTED = 1,
	AMD_PREF_CORE_UNSUPPORTED = 2,
};

enum amd_pstate_mode {
	AMD_PSTATE_UNDEFINED = 0,
	AMD_PSTATE_DISABLE = 1,
	AMD_PSTATE_PASSIVE = 2,
	AMD_PSTATE_ACTIVE = 3,
	AMD_PSTATE_GUIDED = 4,
	AMD_PSTATE_MAX = 5,
};

enum aper_size_type {
	U8_APER_SIZE = 0,
	U16_APER_SIZE = 1,
	U32_APER_SIZE = 2,
	LVL2_APER_SIZE = 3,
	FIXED_APER_SIZE = 4,
};

enum apic_intr_mode_id {
	APIC_PIC = 0,
	APIC_VIRTUAL_WIRE = 1,
	APIC_VIRTUAL_WIRE_NO_CONFIG = 2,
	APIC_SYMMETRIC_IO = 3,
	APIC_SYMMETRIC_IO_NO_ROUTING = 4,
};

enum array_state {
	clear = 0,
	inactive = 1,
	suspended = 2,
	readonly = 3,
	read_auto = 4,
	clean = 5,
	active = 6,
	write_pending = 7,
	active_idle = 8,
	broken = 9,
	bad_word = 10,
};

enum asn1_class {
	ASN1_UNIV = 0,
	ASN1_APPL = 1,
	ASN1_CONT = 2,
	ASN1_PRIV = 3,
};

enum asn1_method {
	ASN1_PRIM = 0,
	ASN1_CONS = 1,
};

enum asn1_opcode {
	ASN1_OP_MATCH = 0,
	ASN1_OP_MATCH_OR_SKIP = 1,
	ASN1_OP_MATCH_ACT = 2,
	ASN1_OP_MATCH_ACT_OR_SKIP = 3,
	ASN1_OP_MATCH_JUMP = 4,
	ASN1_OP_MATCH_JUMP_OR_SKIP = 5,
	ASN1_OP_MATCH_ANY = 8,
	ASN1_OP_MATCH_ANY_OR_SKIP = 9,
	ASN1_OP_MATCH_ANY_ACT = 10,
	ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 11,
	ASN1_OP_COND_MATCH_OR_SKIP = 17,
	ASN1_OP_COND_MATCH_ACT_OR_SKIP = 19,
	ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 21,
	ASN1_OP_COND_MATCH_ANY = 24,
	ASN1_OP_COND_MATCH_ANY_OR_SKIP = 25,
	ASN1_OP_COND_MATCH_ANY_ACT = 26,
	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 27,
	ASN1_OP_COND_FAIL = 28,
	ASN1_OP_COMPLETE = 29,
	ASN1_OP_ACT = 30,
	ASN1_OP_MAYBE_ACT = 31,
	ASN1_OP_END_SEQ = 32,
	ASN1_OP_END_SET = 33,
	ASN1_OP_END_SEQ_OF = 34,
	ASN1_OP_END_SET_OF = 35,
	ASN1_OP_END_SEQ_ACT = 36,
	ASN1_OP_END_SET_ACT = 37,
	ASN1_OP_END_SEQ_OF_ACT = 38,
	ASN1_OP_END_SET_OF_ACT = 39,
	ASN1_OP_RETURN = 40,
	ASN1_OP__NR = 41,
};

enum asn1_tag {
	ASN1_EOC = 0,
	ASN1_BOOL = 1,
	ASN1_INT = 2,
	ASN1_BTS = 3,
	ASN1_OTS = 4,
	ASN1_NULL = 5,
	ASN1_OID = 6,
	ASN1_ODE = 7,
	ASN1_EXT = 8,
	ASN1_REAL = 9,
	ASN1_ENUM = 10,
	ASN1_EPDV = 11,
	ASN1_UTF8STR = 12,
	ASN1_RELOID = 13,
	ASN1_SEQ = 16,
	ASN1_SET = 17,
	ASN1_NUMSTR = 18,
	ASN1_PRNSTR = 19,
	ASN1_TEXSTR = 20,
	ASN1_VIDSTR = 21,
	ASN1_IA5STR = 22,
	ASN1_UNITIM = 23,
	ASN1_GENTIM = 24,
	ASN1_GRASTR = 25,
	ASN1_VISSTR = 26,
	ASN1_GENSTR = 27,
	ASN1_UNISTR = 28,
	ASN1_CHRSTR = 29,
	ASN1_BMPSTR = 30,
	ASN1_LONG_TAG = 31,
};

enum assoc_array_walk_status {
	assoc_array_walk_tree_empty = 0,
	assoc_array_walk_found_terminal_node = 1,
	assoc_array_walk_found_wrong_shortcut = 2,
};

enum asymmetric_payload_bits {
	asym_crypto = 0,
	asym_subtype = 1,
	asym_key_ids = 2,
	asym_auth = 3,
};

enum ata_quirks {
	__ATA_QUIRK_DIAGNOSTIC = 0,
	__ATA_QUIRK_NODMA = 1,
	__ATA_QUIRK_NONCQ = 2,
	__ATA_QUIRK_MAX_SEC_128 = 3,
	__ATA_QUIRK_BROKEN_HPA = 4,
	__ATA_QUIRK_DISABLE = 5,
	__ATA_QUIRK_HPA_SIZE = 6,
	__ATA_QUIRK_IVB = 7,
	__ATA_QUIRK_STUCK_ERR = 8,
	__ATA_QUIRK_BRIDGE_OK = 9,
	__ATA_QUIRK_ATAPI_MOD16_DMA = 10,
	__ATA_QUIRK_FIRMWARE_WARN = 11,
	__ATA_QUIRK_1_5_GBPS = 12,
	__ATA_QUIRK_NOSETXFER = 13,
	__ATA_QUIRK_BROKEN_FPDMA_AA = 14,
	__ATA_QUIRK_DUMP_ID = 15,
	__ATA_QUIRK_MAX_SEC_LBA48 = 16,
	__ATA_QUIRK_ATAPI_DMADIR = 17,
	__ATA_QUIRK_NO_NCQ_TRIM = 18,
	__ATA_QUIRK_NOLPM = 19,
	__ATA_QUIRK_WD_BROKEN_LPM = 20,
	__ATA_QUIRK_ZERO_AFTER_TRIM = 21,
	__ATA_QUIRK_NO_DMA_LOG = 22,
	__ATA_QUIRK_NOTRIM = 23,
	__ATA_QUIRK_MAX_SEC_1024 = 24,
	__ATA_QUIRK_MAX_TRIM_128M = 25,
	__ATA_QUIRK_NO_NCQ_ON_ATI = 26,
	__ATA_QUIRK_NO_LPM_ON_ATI = 27,
	__ATA_QUIRK_NO_ID_DEV_LOG = 28,
	__ATA_QUIRK_NO_LOG_DIR = 29,
	__ATA_QUIRK_NO_FUA = 30,
	__ATA_QUIRK_MAX = 31,
};

enum atm_addr_type_t {
	ATM_ADDR_LOCAL = 0,
	ATM_ADDR_LECS = 1,
};

enum atmarp_ctrl_type {
	act_invalid = 0,
	act_need = 1,
	act_up = 2,
	act_down = 3,
	act_change = 4,
};

enum atmsvc_msg_type {
	as_catch_null = 0,
	as_bind = 1,
	as_connect = 2,
	as_accept = 3,
	as_reject = 4,
	as_listen = 5,
	as_okay = 6,
	as_error = 7,
	as_indicate = 8,
	as_close = 9,
	as_itf_notify = 10,
	as_modify = 11,
	as_identify = 12,
	as_terminate = 13,
	as_addparty = 14,
	as_dropparty = 15,
};

enum atom_native_id {
	cmt_native_id = 2,
	skt_native_id = 3,
};

enum audit_nfcfgop {
	AUDIT_XT_OP_REGISTER = 0,
	AUDIT_XT_OP_REPLACE = 1,
	AUDIT_XT_OP_UNREGISTER = 2,
	AUDIT_NFT_OP_TABLE_REGISTER = 3,
	AUDIT_NFT_OP_TABLE_UNREGISTER = 4,
	AUDIT_NFT_OP_CHAIN_REGISTER = 5,
	AUDIT_NFT_OP_CHAIN_UNREGISTER = 6,
	AUDIT_NFT_OP_RULE_REGISTER = 7,
	AUDIT_NFT_OP_RULE_UNREGISTER = 8,
	AUDIT_NFT_OP_SET_REGISTER = 9,
	AUDIT_NFT_OP_SET_UNREGISTER = 10,
	AUDIT_NFT_OP_SETELEM_REGISTER = 11,
	AUDIT_NFT_OP_SETELEM_UNREGISTER = 12,
	AUDIT_NFT_OP_GEN_REGISTER = 13,
	AUDIT_NFT_OP_OBJ_REGISTER = 14,
	AUDIT_NFT_OP_OBJ_UNREGISTER = 15,
	AUDIT_NFT_OP_OBJ_RESET = 16,
	AUDIT_NFT_OP_FLOWTABLE_REGISTER = 17,
	AUDIT_NFT_OP_FLOWTABLE_UNREGISTER = 18,
	AUDIT_NFT_OP_SETELEM_RESET = 19,
	AUDIT_NFT_OP_RULE_RESET = 20,
	AUDIT_NFT_OP_INVALID = 21,
};

enum audit_nlgrps {
	AUDIT_NLGRP_NONE = 0,
	AUDIT_NLGRP_READLOG = 1,
	__AUDIT_NLGRP_MAX = 2,
};

enum audit_ntp_type {
	AUDIT_NTP_OFFSET = 0,
	AUDIT_NTP_FREQ = 1,
	AUDIT_NTP_STATUS = 2,
	AUDIT_NTP_TAI = 3,
	AUDIT_NTP_TICK = 4,
	AUDIT_NTP_ADJUST = 5,
	AUDIT_NTP_NVALS = 6,
};

enum audit_state {
	AUDIT_STATE_DISABLED = 0,
	AUDIT_STATE_BUILD = 1,
	AUDIT_STATE_RECORD = 2,
};

enum auditsc_class_t {
	AUDITSC_NATIVE = 0,
	AUDITSC_COMPAT = 1,
	AUDITSC_OPEN = 2,
	AUDITSC_OPENAT = 3,
	AUDITSC_SOCKETCALL = 4,
	AUDITSC_EXECVE = 5,
	AUDITSC_OPENAT2 = 6,
	AUDITSC_NVALS = 7,
};

enum autofs_notify {
	NFY_NONE = 0,
	NFY_MOUNT = 1,
	NFY_EXPIRE = 2,
};

enum aux_ch {
	AUX_CH_NONE = -1,
	AUX_CH_A = 0,
	AUX_CH_B = 1,
	AUX_CH_C = 2,
	AUX_CH_D = 3,
	AUX_CH_E = 4,
	AUX_CH_F = 5,
	AUX_CH_G = 6,
	AUX_CH_H = 7,
	AUX_CH_I = 8,
	AUX_CH_USBC1 = 3,
	AUX_CH_USBC2 = 4,
	AUX_CH_USBC3 = 5,
	AUX_CH_USBC4 = 6,
	AUX_CH_USBC5 = 7,
	AUX_CH_USBC6 = 8,
	AUX_CH_D_XELPD = 7,
	AUX_CH_E_XELPD = 8,
};

enum backlight_scale {
	BACKLIGHT_SCALE_UNKNOWN = 0,
	BACKLIGHT_SCALE_LINEAR = 1,
	BACKLIGHT_SCALE_NON_LINEAR = 2,
};

enum backlight_type {
	BACKLIGHT_RAW = 1,
	BACKLIGHT_PLATFORM = 2,
	BACKLIGHT_FIRMWARE = 3,
	BACKLIGHT_TYPE_MAX = 4,
};

enum backlight_update_reason {
	BACKLIGHT_UPDATE_HOTKEY = 0,
	BACKLIGHT_UPDATE_SYSFS = 1,
};

enum batadv_bla_claimframe {
	BATADV_CLAIM_TYPE_CLAIM = 0,
	BATADV_CLAIM_TYPE_UNCLAIM = 1,
	BATADV_CLAIM_TYPE_ANNOUNCE = 2,
	BATADV_CLAIM_TYPE_REQUEST = 3,
	BATADV_CLAIM_TYPE_LOOPDETECT = 4,
};

enum batadv_boothtype {
	BATADV_HTYPE_ETHERNET = 1,
};

enum batadv_bootpop {
	BATADV_BOOTREPLY = 2,
};

enum batadv_counters {
	BATADV_CNT_TX = 0,
	BATADV_CNT_TX_BYTES = 1,
	BATADV_CNT_TX_DROPPED = 2,
	BATADV_CNT_RX = 3,
	BATADV_CNT_RX_BYTES = 4,
	BATADV_CNT_FORWARD = 5,
	BATADV_CNT_FORWARD_BYTES = 6,
	BATADV_CNT_MGMT_TX = 7,
	BATADV_CNT_MGMT_TX_BYTES = 8,
	BATADV_CNT_MGMT_RX = 9,
	BATADV_CNT_MGMT_RX_BYTES = 10,
	BATADV_CNT_FRAG_TX = 11,
	BATADV_CNT_FRAG_TX_BYTES = 12,
	BATADV_CNT_FRAG_RX = 13,
	BATADV_CNT_FRAG_RX_BYTES = 14,
	BATADV_CNT_FRAG_FWD = 15,
	BATADV_CNT_FRAG_FWD_BYTES = 16,
	BATADV_CNT_TT_REQUEST_TX = 17,
	BATADV_CNT_TT_REQUEST_RX = 18,
	BATADV_CNT_TT_RESPONSE_TX = 19,
	BATADV_CNT_TT_RESPONSE_RX = 20,
	BATADV_CNT_TT_ROAM_ADV_TX = 21,
	BATADV_CNT_TT_ROAM_ADV_RX = 22,
	BATADV_CNT_MCAST_TX = 23,
	BATADV_CNT_MCAST_TX_BYTES = 24,
	BATADV_CNT_MCAST_TX_LOCAL = 25,
	BATADV_CNT_MCAST_TX_LOCAL_BYTES = 26,
	BATADV_CNT_MCAST_RX = 27,
	BATADV_CNT_MCAST_RX_BYTES = 28,
	BATADV_CNT_MCAST_RX_LOCAL = 29,
	BATADV_CNT_MCAST_RX_LOCAL_BYTES = 30,
	BATADV_CNT_MCAST_FWD = 31,
	BATADV_CNT_MCAST_FWD_BYTES = 32,
	BATADV_CNT_DAT_GET_TX = 33,
	BATADV_CNT_DAT_GET_RX = 34,
	BATADV_CNT_DAT_PUT_TX = 35,
	BATADV_CNT_DAT_PUT_RX = 36,
	BATADV_CNT_DAT_CACHED_REPLY_TX = 37,
	BATADV_CNT_NC_CODE = 38,
	BATADV_CNT_NC_CODE_BYTES = 39,
	BATADV_CNT_NC_RECODE = 40,
	BATADV_CNT_NC_RECODE_BYTES = 41,
	BATADV_CNT_NC_BUFFER = 42,
	BATADV_CNT_NC_DECODE = 43,
	BATADV_CNT_NC_DECODE_BYTES = 44,
	BATADV_CNT_NC_DECODE_FAILED = 45,
	BATADV_CNT_NC_SNIFFED = 46,
	BATADV_CNT_NUM = 47,
};

enum batadv_dbg_level {
	BATADV_DBG_BATMAN = 1,
	BATADV_DBG_ROUTES = 2,
	BATADV_DBG_TT = 4,
	BATADV_DBG_BLA = 8,
	BATADV_DBG_DAT = 16,
	BATADV_DBG_NC = 32,
	BATADV_DBG_MCAST = 64,
	BATADV_DBG_TP_METER = 128,
	BATADV_DBG_ALL = 255,
};

enum batadv_dhcp_recipient {
	BATADV_DHCP_NO = 0,
	BATADV_DHCP_TO_SERVER = 1,
	BATADV_DHCP_TO_CLIENT = 2,
};

enum batadv_dhcpoptioncode {
	BATADV_DHCP_OPT_PAD = 0,
	BATADV_DHCP_OPT_MSG_TYPE = 53,
	BATADV_DHCP_OPT_END = 255,
};

enum batadv_dhcptype {
	BATADV_DHCPACK = 5,
};

enum batadv_dup_status {
	BATADV_NO_DUP = 0,
	BATADV_ORIG_DUP = 1,
	BATADV_NEIGH_DUP = 2,
	BATADV_PROTECTED = 3,
};

enum batadv_forw_mode {
	BATADV_FORW_BCAST = 0,
	BATADV_FORW_UCASTS = 1,
	BATADV_FORW_MCAST = 2,
	BATADV_FORW_NONE = 3,
};

enum batadv_genl_ops_flags {
	BATADV_FLAG_NEED_MESH = 1,
	BATADV_FLAG_NEED_HARDIF = 2,
	BATADV_FLAG_NEED_VLAN = 4,
};

enum batadv_gw_modes {
	BATADV_GW_MODE_OFF = 0,
	BATADV_GW_MODE_CLIENT = 1,
	BATADV_GW_MODE_SERVER = 2,
};

enum batadv_hard_if_bcast {
	BATADV_HARDIF_BCAST_OK = 0,
	BATADV_HARDIF_BCAST_NORECIPIENT = 1,
	BATADV_HARDIF_BCAST_DUPFWD = 2,
	BATADV_HARDIF_BCAST_DUPORIG = 3,
};

enum batadv_hard_if_state {
	BATADV_IF_NOT_IN_USE = 0,
	BATADV_IF_TO_BE_REMOVED = 1,
	BATADV_IF_INACTIVE = 2,
	BATADV_IF_ACTIVE = 3,
	BATADV_IF_TO_BE_ACTIVATED = 4,
};

enum batadv_hard_iface_wifi_flags {
	BATADV_HARDIF_WIFI_WEXT_DIRECT = 1,
	BATADV_HARDIF_WIFI_CFG80211_DIRECT = 2,
	BATADV_HARDIF_WIFI_WEXT_INDIRECT = 4,
	BATADV_HARDIF_WIFI_CFG80211_INDIRECT = 8,
};

enum batadv_icmp_packettype {
	BATADV_ECHO_REPLY = 0,
	BATADV_DESTINATION_UNREACHABLE = 3,
	BATADV_ECHO_REQUEST = 8,
	BATADV_TTL_EXCEEDED = 11,
	BATADV_PARAMETER_PROBLEM = 12,
	BATADV_TP = 15,
};

enum batadv_icmp_tp_subtype {
	BATADV_TP_MSG = 0,
	BATADV_TP_ACK = 1,
};

enum batadv_ifla_attrs {
	IFLA_BATADV_UNSPEC = 0,
	IFLA_BATADV_ALGO_NAME = 1,
	__IFLA_BATADV_MAX = 2,
};

enum batadv_iv_flags {
	BATADV_NOT_BEST_NEXT_HOP = 1,
	BATADV_PRIMARIES_FIRST_HOP = 2,
	BATADV_DIRECTLINK = 4,
};

enum batadv_mcast_flags {
	BATADV_MCAST_WANT_ALL_UNSNOOPABLES = 1,
	BATADV_MCAST_WANT_ALL_IPV4 = 2,
	BATADV_MCAST_WANT_ALL_IPV6 = 4,
	BATADV_MCAST_WANT_NO_RTR4 = 8,
	BATADV_MCAST_WANT_NO_RTR6 = 16,
	BATADV_MCAST_HAVE_MC_PTYPE_CAPA = 32,
};

enum batadv_mcast_flags_priv {
	BATADV_MCAST_FLAGS_BRIDGED = 1,
	BATADV_MCAST_FLAGS_QUERIER_IPV4_EXISTS = 2,
	BATADV_MCAST_FLAGS_QUERIER_IPV6_EXISTS = 4,
	BATADV_MCAST_FLAGS_QUERIER_IPV4_SHADOWING = 8,
	BATADV_MCAST_FLAGS_QUERIER_IPV6_SHADOWING = 16,
};

enum batadv_mesh_state {
	BATADV_MESH_INACTIVE = 0,
	BATADV_MESH_ACTIVE = 1,
	BATADV_MESH_DEACTIVATING = 2,
};

enum batadv_netlink_multicast_groups {
	BATADV_NL_MCGRP_CONFIG = 0,
	BATADV_NL_MCGRP_TPMETER = 1,
};

enum batadv_nl_attrs {
	BATADV_ATTR_UNSPEC = 0,
	BATADV_ATTR_VERSION = 1,
	BATADV_ATTR_ALGO_NAME = 2,
	BATADV_ATTR_MESH_IFINDEX = 3,
	BATADV_ATTR_MESH_IFNAME = 4,
	BATADV_ATTR_MESH_ADDRESS = 5,
	BATADV_ATTR_HARD_IFINDEX = 6,
	BATADV_ATTR_HARD_IFNAME = 7,
	BATADV_ATTR_HARD_ADDRESS = 8,
	BATADV_ATTR_ORIG_ADDRESS = 9,
	BATADV_ATTR_TPMETER_RESULT = 10,
	BATADV_ATTR_TPMETER_TEST_TIME = 11,
	BATADV_ATTR_TPMETER_BYTES = 12,
	BATADV_ATTR_TPMETER_COOKIE = 13,
	BATADV_ATTR_PAD = 14,
	BATADV_ATTR_ACTIVE = 15,
	BATADV_ATTR_TT_ADDRESS = 16,
	BATADV_ATTR_TT_TTVN = 17,
	BATADV_ATTR_TT_LAST_TTVN = 18,
	BATADV_ATTR_TT_CRC32 = 19,
	BATADV_ATTR_TT_VID = 20,
	BATADV_ATTR_TT_FLAGS = 21,
	BATADV_ATTR_FLAG_BEST = 22,
	BATADV_ATTR_LAST_SEEN_MSECS = 23,
	BATADV_ATTR_NEIGH_ADDRESS = 24,
	BATADV_ATTR_TQ = 25,
	BATADV_ATTR_THROUGHPUT = 26,
	BATADV_ATTR_BANDWIDTH_UP = 27,
	BATADV_ATTR_BANDWIDTH_DOWN = 28,
	BATADV_ATTR_ROUTER = 29,
	BATADV_ATTR_BLA_OWN = 30,
	BATADV_ATTR_BLA_ADDRESS = 31,
	BATADV_ATTR_BLA_VID = 32,
	BATADV_ATTR_BLA_BACKBONE = 33,
	BATADV_ATTR_BLA_CRC = 34,
	BATADV_ATTR_DAT_CACHE_IP4ADDRESS = 35,
	BATADV_ATTR_DAT_CACHE_HWADDRESS = 36,
	BATADV_ATTR_DAT_CACHE_VID = 37,
	BATADV_ATTR_MCAST_FLAGS = 38,
	BATADV_ATTR_MCAST_FLAGS_PRIV = 39,
	BATADV_ATTR_VLANID = 40,
	BATADV_ATTR_AGGREGATED_OGMS_ENABLED = 41,
	BATADV_ATTR_AP_ISOLATION_ENABLED = 42,
	BATADV_ATTR_ISOLATION_MARK = 43,
	BATADV_ATTR_ISOLATION_MASK = 44,
	BATADV_ATTR_BONDING_ENABLED = 45,
	BATADV_ATTR_BRIDGE_LOOP_AVOIDANCE_ENABLED = 46,
	BATADV_ATTR_DISTRIBUTED_ARP_TABLE_ENABLED = 47,
	BATADV_ATTR_FRAGMENTATION_ENABLED = 48,
	BATADV_ATTR_GW_BANDWIDTH_DOWN = 49,
	BATADV_ATTR_GW_BANDWIDTH_UP = 50,
	BATADV_ATTR_GW_MODE = 51,
	BATADV_ATTR_GW_SEL_CLASS = 52,
	BATADV_ATTR_HOP_PENALTY = 53,
	BATADV_ATTR_LOG_LEVEL = 54,
	BATADV_ATTR_MULTICAST_FORCEFLOOD_ENABLED = 55,
	BATADV_ATTR_NETWORK_CODING_ENABLED = 56,
	BATADV_ATTR_ORIG_INTERVAL = 57,
	BATADV_ATTR_ELP_INTERVAL = 58,
	BATADV_ATTR_THROUGHPUT_OVERRIDE = 59,
	BATADV_ATTR_MULTICAST_FANOUT = 60,
	__BATADV_ATTR_AFTER_LAST = 61,
	NUM_BATADV_ATTR = 61,
	BATADV_ATTR_MAX = 60,
};

enum batadv_nl_commands {
	BATADV_CMD_UNSPEC = 0,
	BATADV_CMD_GET_MESH = 1,
	BATADV_CMD_GET_MESH_INFO = 1,
	BATADV_CMD_TP_METER = 2,
	BATADV_CMD_TP_METER_CANCEL = 3,
	BATADV_CMD_GET_ROUTING_ALGOS = 4,
	BATADV_CMD_GET_HARDIF = 5,
	BATADV_CMD_GET_HARDIFS = 5,
	BATADV_CMD_GET_TRANSTABLE_LOCAL = 6,
	BATADV_CMD_GET_TRANSTABLE_GLOBAL = 7,
	BATADV_CMD_GET_ORIGINATORS = 8,
	BATADV_CMD_GET_NEIGHBORS = 9,
	BATADV_CMD_GET_GATEWAYS = 10,
	BATADV_CMD_GET_BLA_CLAIM = 11,
	BATADV_CMD_GET_BLA_BACKBONE = 12,
	BATADV_CMD_GET_DAT_CACHE = 13,
	BATADV_CMD_GET_MCAST_FLAGS = 14,
	BATADV_CMD_SET_MESH = 15,
	BATADV_CMD_SET_HARDIF = 16,
	BATADV_CMD_GET_VLAN = 17,
	BATADV_CMD_SET_VLAN = 18,
	__BATADV_CMD_AFTER_LAST = 19,
	BATADV_CMD_MAX = 18,
};

enum batadv_orig_capabilities {
	BATADV_ORIG_CAPA_HAS_DAT = 0,
	BATADV_ORIG_CAPA_HAS_NC = 1,
	BATADV_ORIG_CAPA_HAS_TT = 2,
	BATADV_ORIG_CAPA_HAS_MCAST = 3,
};

enum batadv_packettype {
	BATADV_IV_OGM = 0,
	BATADV_BCAST = 1,
	BATADV_CODED = 2,
	BATADV_ELP = 3,
	BATADV_OGM2 = 4,
	BATADV_MCAST = 5,
	BATADV_UNICAST = 64,
	BATADV_UNICAST_FRAG = 65,
	BATADV_UNICAST_4ADDR = 66,
	BATADV_ICMP = 67,
	BATADV_UNICAST_TVLV = 68,
};

enum batadv_subtype {
	BATADV_P_DATA = 1,
	BATADV_P_DAT_DHT_GET = 2,
	BATADV_P_DAT_DHT_PUT = 3,
	BATADV_P_DAT_CACHE_REPLY = 4,
};

enum batadv_tp_meter_reason {
	BATADV_TP_REASON_COMPLETE = 3,
	BATADV_TP_REASON_CANCEL = 4,
	BATADV_TP_REASON_DST_UNREACHABLE = 128,
	BATADV_TP_REASON_RESEND_LIMIT = 129,
	BATADV_TP_REASON_ALREADY_ONGOING = 130,
	BATADV_TP_REASON_MEMORY_ERROR = 131,
	BATADV_TP_REASON_CANT_SEND = 132,
	BATADV_TP_REASON_TOO_MANY = 133,
};

enum batadv_tp_meter_role {
	BATADV_TP_RECEIVER = 0,
	BATADV_TP_SENDER = 1,
};

enum batadv_tt_client_flags {
	BATADV_TT_CLIENT_DEL = 1,
	BATADV_TT_CLIENT_ROAM = 2,
	BATADV_TT_CLIENT_WIFI = 16,
	BATADV_TT_CLIENT_ISOLA = 32,
	BATADV_TT_CLIENT_NOPURGE = 256,
	BATADV_TT_CLIENT_NEW = 512,
	BATADV_TT_CLIENT_PENDING = 1024,
	BATADV_TT_CLIENT_TEMP = 2048,
};

enum batadv_tt_data_flags {
	BATADV_TT_OGM_DIFF = 1,
	BATADV_TT_REQUEST = 2,
	BATADV_TT_RESPONSE = 4,
	BATADV_TT_FULL_TABLE = 16,
};

enum batadv_tvlv_handler_flags {
	BATADV_TVLV_HANDLER_OGM_CIFNOTFND = 2,
	BATADV_TVLV_HANDLER_OGM_CALLED = 4,
};

enum batadv_tvlv_type {
	BATADV_TVLV_GW = 1,
	BATADV_TVLV_DAT = 2,
	BATADV_TVLV_NC = 3,
	BATADV_TVLV_TT = 4,
	BATADV_TVLV_ROAM = 5,
	BATADV_TVLV_MCAST = 6,
	BATADV_TVLV_MCAST_TRACKER = 7,
};

enum batadv_uev_action {
	BATADV_UEV_ADD = 0,
	BATADV_UEV_DEL = 1,
	BATADV_UEV_CHANGE = 2,
	BATADV_UEV_LOOPDETECT = 3,
};

enum batadv_uev_type {
	BATADV_UEV_GW = 0,
	BATADV_UEV_BLA = 1,
};

enum batadv_v_hard_iface_flags {
	BATADV_FULL_DUPLEX = 1,
	BATADV_WARNING_DEFAULT = 2,
};

enum batadv_vlan_flags {
	BATADV_VLAN_HAS_TAG = 32768,
};

enum bbr_mode {
	BBR_STARTUP = 0,
	BBR_DRAIN = 1,
	BBR_PROBE_BW = 2,
	BBR_PROBE_RTT = 3,
};

enum bdb_block_id {
	BDB_GENERAL_FEATURES = 1,
	BDB_GENERAL_DEFINITIONS = 2,
	BDB_DISPLAY_TOGGLE = 3,
	BDB_MODE_SUPPORT_LIST = 4,
	BDB_GENERIC_MODE_TABLE = 5,
	BDB_EXT_MMIO_REGS = 6,
	BDB_SWF_IO = 7,
	BDB_SWF_MMIO = 8,
	BDB_DOT_CLOCK_OVERRIDE_ALM = 9,
	BDB_PSR = 9,
	BDB_MODE_REMOVAL_TABLE = 10,
	BDB_CHILD_DEVICE_TABLE = 11,
	BDB_DRIVER_FEATURES = 12,
	BDB_DRIVER_PERSISTENCE = 13,
	BDB_EXT_TABLE_PTRS = 14,
	BDB_DOT_CLOCK_OVERRIDE = 15,
	BDB_DISPLAY_SELECT_OLD = 16,
	BDB_SV_TEST_FUNCTIONS = 17,
	BDB_DRIVER_ROTATION = 18,
	BDB_DISPLAY_REMOVE_OLD = 19,
	BDB_OEM_CUSTOM = 20,
	BDB_EFP_LIST = 21,
	BDB_SDVO_LVDS_OPTIONS = 22,
	BDB_SDVO_LVDS_DTD = 23,
	BDB_SDVO_LVDS_PNP_ID = 24,
	BDB_SDVO_LVDS_PPS = 25,
	BDB_TV_OPTIONS = 26,
	BDB_EDP = 27,
	BDB_EFP_DTD = 28,
	BDB_DISPLAY_SELECT_IVB = 29,
	BDB_DISPLAY_REMOVE_IVB = 30,
	BDB_DISPLAY_SELECT_HSW = 31,
	BDB_DISPLAY_REMOVE_HSW = 32,
	BDB_LFP_OPTIONS = 40,
	BDB_LFP_DATA_PTRS = 41,
	BDB_LFP_DATA = 42,
	BDB_LFP_BACKLIGHT = 43,
	BDB_LFP_POWER = 44,
	BDB_EDP_BFI = 45,
	BDB_CHROMATICITY = 46,
	BDB_MIPI = 50,
	BDB_FIXED_SET_MODE = 51,
	BDB_MIPI_CONFIG = 52,
	BDB_MIPI_SEQUENCE = 53,
	BDB_RGB_PALETTE = 54,
	BDB_COMPRESSION_PARAMETERS_OLD = 55,
	BDB_COMPRESSION_PARAMETERS = 56,
	BDB_VSWING_PREEMPH = 57,
	BDB_GENERIC_DTD = 58,
	BDB_INT15_HOOK = 252,
	BDB_PRD_TABLE = 253,
	BDB_SKIP = 254,
};

enum behavior {
	EXCLUSIVE = 0,
	SHARED = 1,
	DROP = 2,
};

enum bh_state_bits {
	BH_Uptodate = 0,
	BH_Dirty = 1,
	BH_Lock = 2,
	BH_Req = 3,
	BH_Mapped = 4,
	BH_New = 5,
	BH_Async_Read = 6,
	BH_Async_Write = 7,
	BH_Delay = 8,
	BH_Boundary = 9,
	BH_Write_EIO = 10,
	BH_Unwritten = 11,
	BH_Quiet = 12,
	BH_Meta = 13,
	BH_Prio = 14,
	BH_Defer_Completion = 15,
	BH_PrivateStart = 16,
};

enum bhi_mitigations {
	BHI_MITIGATION_OFF = 0,
	BHI_MITIGATION_ON = 1,
	BHI_MITIGATION_VMEXIT_ONLY = 2,
};

enum bio_merge_status {
	BIO_MERGE_OK = 0,
	BIO_MERGE_NONE = 1,
	BIO_MERGE_FAILED = 2,
};

enum bio_post_read_step {
	STEP_INITIAL = 0,
	STEP_DECRYPT = 1,
	STEP_VERITY = 2,
	STEP_MAX = 3,
};

enum bios_platform_class {
	BIOS_CLIENT = 0,
	BIOS_SERVER = 1,
};

enum bip_flags {
	BIP_BLOCK_INTEGRITY = 1,
	BIP_MAPPED_INTEGRITY = 2,
	BIP_DISK_NOCHECK = 4,
	BIP_IP_CHECKSUM = 8,
	BIP_COPY_USER = 16,
	BIP_CHECK_GUARD = 32,
	BIP_CHECK_REFTAG = 64,
	BIP_CHECK_APPTAG = 128,
};

enum bitmap_page_attr {
	BITMAP_PAGE_DIRTY = 0,
	BITMAP_PAGE_PENDING = 1,
	BITMAP_PAGE_NEEDWRITE = 2,
};

enum bitmap_state {
	BITMAP_STALE = 1,
	BITMAP_WRITE_ERROR = 2,
	BITMAP_HOSTENDIAN = 15,
};

enum blacklist_hash_type {
	BLACKLIST_HASH_X509_TBS = 1,
	BLACKLIST_HASH_BINARY = 2,
};

enum blake2b_iv {
	BLAKE2B_IV0 = 7640891576956012808ULL,
	BLAKE2B_IV1 = 13503953896175478587ULL,
	BLAKE2B_IV2 = 4354685564936845355ULL,
	BLAKE2B_IV3 = 11912009170470909681ULL,
	BLAKE2B_IV4 = 5840696475078001361ULL,
	BLAKE2B_IV5 = 11170449401992604703ULL,
	BLAKE2B_IV6 = 2270897969802886507ULL,
	BLAKE2B_IV7 = 6620516959819538809ULL,
};

enum blake2b_lengths {
	BLAKE2B_BLOCK_SIZE = 128,
	BLAKE2B_HASH_SIZE = 64,
	BLAKE2B_KEY_SIZE = 64,
	BLAKE2B_160_HASH_SIZE = 20,
	BLAKE2B_256_HASH_SIZE = 32,
	BLAKE2B_384_HASH_SIZE = 48,
	BLAKE2B_512_HASH_SIZE = 64,
};

enum blake2s_iv {
	BLAKE2S_IV0 = 1779033703,
	BLAKE2S_IV1 = 3144134277,
	BLAKE2S_IV2 = 1013904242,
	BLAKE2S_IV3 = 2773480762,
	BLAKE2S_IV4 = 1359893119,
	BLAKE2S_IV5 = 2600822924,
	BLAKE2S_IV6 = 528734635,
	BLAKE2S_IV7 = 1541459225,
};

enum blake2s_lengths {
	BLAKE2S_BLOCK_SIZE = 64,
	BLAKE2S_HASH_SIZE = 32,
	BLAKE2S_KEY_SIZE = 32,
	BLAKE2S_128_HASH_SIZE = 16,
	BLAKE2S_160_HASH_SIZE = 20,
	BLAKE2S_224_HASH_SIZE = 28,
	BLAKE2S_256_HASH_SIZE = 32,
};

enum blk_crypto_mode_num {
	BLK_ENCRYPTION_MODE_INVALID = 0,
	BLK_ENCRYPTION_MODE_AES_256_XTS = 1,
	BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV = 2,
	BLK_ENCRYPTION_MODE_ADIANTUM = 3,
	BLK_ENCRYPTION_MODE_SM4_XTS = 4,
	BLK_ENCRYPTION_MODE_MAX = 5,
};

enum blk_default_limits {
	BLK_MAX_SEGMENTS = 128,
	BLK_SAFE_MAX_SECTORS = 255,
	BLK_MAX_SEGMENT_SIZE = 65536,
	BLK_SEG_BOUNDARY_MASK = 4294967295,
};

enum blk_eh_timer_return {
	BLK_EH_DONE = 0,
	BLK_EH_RESET_TIMER = 1,
};

enum blk_integrity_checksum {
	BLK_INTEGRITY_CSUM_NONE = 0,
	BLK_INTEGRITY_CSUM_IP = 1,
	BLK_INTEGRITY_CSUM_CRC = 2,
	BLK_INTEGRITY_CSUM_CRC64 = 3,
} __attribute__((mode(byte)));

enum blk_integrity_flags {
	BLK_INTEGRITY_NOVERIFY = 1,
	BLK_INTEGRITY_NOGENERATE = 2,
	BLK_INTEGRITY_DEVICE_CAPABLE = 4,
	BLK_INTEGRITY_REF_TAG = 8,
	BLK_INTEGRITY_STACKED = 16,
};

enum blk_unique_id {
	BLK_UID_T10 = 1,
	BLK_UID_EUI64 = 2,
	BLK_UID_NAA = 3,
};

enum blkg_iostat_type {
	BLKG_IOSTAT_READ = 0,
	BLKG_IOSTAT_WRITE = 1,
	BLKG_IOSTAT_DISCARD = 2,
	BLKG_IOSTAT_NR = 3,
};

enum blkg_rwstat_type {
	BLKG_RWSTAT_READ = 0,
	BLKG_RWSTAT_WRITE = 1,
	BLKG_RWSTAT_SYNC = 2,
	BLKG_RWSTAT_ASYNC = 3,
	BLKG_RWSTAT_DISCARD = 4,
	BLKG_RWSTAT_NR = 5,
	BLKG_RWSTAT_TOTAL = 5,
};

enum blktrace_act {
	__BLK_TA_QUEUE = 1,
	__BLK_TA_BACKMERGE = 2,
	__BLK_TA_FRONTMERGE = 3,
	__BLK_TA_GETRQ = 4,
	__BLK_TA_SLEEPRQ = 5,
	__BLK_TA_REQUEUE = 6,
	__BLK_TA_ISSUE = 7,
	__BLK_TA_COMPLETE = 8,
	__BLK_TA_PLUG = 9,
	__BLK_TA_UNPLUG_IO = 10,
	__BLK_TA_UNPLUG_TIMER = 11,
	__BLK_TA_INSERT = 12,
	__BLK_TA_SPLIT = 13,
	__BLK_TA_BOUNCE = 14,
	__BLK_TA_REMAP = 15,
	__BLK_TA_ABORT = 16,
	__BLK_TA_DRV_DATA = 17,
	__BLK_TA_CGROUP = 256,
};

enum blktrace_cat {
	BLK_TC_READ = 1,
	BLK_TC_WRITE = 2,
	BLK_TC_FLUSH = 4,
	BLK_TC_SYNC = 8,
	BLK_TC_SYNCIO = 8,
	BLK_TC_QUEUE = 16,
	BLK_TC_REQUEUE = 32,
	BLK_TC_ISSUE = 64,
	BLK_TC_COMPLETE = 128,
	BLK_TC_FS = 256,
	BLK_TC_PC = 512,
	BLK_TC_NOTIFY = 1024,
	BLK_TC_AHEAD = 2048,
	BLK_TC_META = 4096,
	BLK_TC_DISCARD = 8192,
	BLK_TC_DRV_DATA = 16384,
	BLK_TC_FUA = 32768,
	BLK_TC_END = 32768,
};

enum blktrace_notify {
	__BLK_TN_PROCESS = 0,
	__BLK_TN_TIMESTAMP = 1,
	__BLK_TN_MESSAGE = 2,
	__BLK_TN_CGROUP = 256,
};

enum bp_type_idx {
	TYPE_INST = 0,
	TYPE_DATA = 0,
	TYPE_MAX = 1,
};

enum bpf_access_src {
	ACCESS_DIRECT = 1,
	ACCESS_HELPER = 2,
};

enum bpf_access_type {
	BPF_READ = 1,
	BPF_WRITE = 2,
};

enum bpf_addr_space_cast {
	BPF_ADDR_SPACE_CAST = 1,
};

enum bpf_adj_room_mode {
	BPF_ADJ_ROOM_NET = 0,
	BPF_ADJ_ROOM_MAC = 1,
};

enum bpf_arg_type {
	ARG_DONTCARE = 0,
	ARG_CONST_MAP_PTR = 1,
	ARG_PTR_TO_MAP_KEY = 2,
	ARG_PTR_TO_MAP_VALUE = 3,
	ARG_PTR_TO_MEM = 4,
	ARG_PTR_TO_ARENA = 5,
	ARG_CONST_SIZE = 6,
	ARG_CONST_SIZE_OR_ZERO = 7,
	ARG_PTR_TO_CTX = 8,
	ARG_ANYTHING = 9,
	ARG_PTR_TO_SPIN_LOCK = 10,
	ARG_PTR_TO_SOCK_COMMON = 11,
	ARG_PTR_TO_SOCKET = 12,
	ARG_PTR_TO_BTF_ID = 13,
	ARG_PTR_TO_RINGBUF_MEM = 14,
	ARG_CONST_ALLOC_SIZE_OR_ZERO = 15,
	ARG_PTR_TO_BTF_ID_SOCK_COMMON = 16,
	ARG_PTR_TO_PERCPU_BTF_ID = 17,
	ARG_PTR_TO_FUNC = 18,
	ARG_PTR_TO_STACK = 19,
	ARG_PTR_TO_CONST_STR = 20,
	ARG_PTR_TO_TIMER = 21,
	ARG_KPTR_XCHG_DEST = 22,
	ARG_PTR_TO_DYNPTR = 23,
	__BPF_ARG_TYPE_MAX = 24,
	ARG_PTR_TO_MAP_VALUE_OR_NULL = 259,
	ARG_PTR_TO_MEM_OR_NULL = 260,
	ARG_PTR_TO_CTX_OR_NULL = 264,
	ARG_PTR_TO_SOCKET_OR_NULL = 268,
	ARG_PTR_TO_STACK_OR_NULL = 275,
	ARG_PTR_TO_BTF_ID_OR_NULL = 269,
	ARG_PTR_TO_UNINIT_MEM = 67141636,
	ARG_PTR_TO_FIXED_SIZE_MEM = 262148,
	__BPF_ARG_TYPE_LIMIT = 134217727,
};

enum bpf_async_type {
	BPF_ASYNC_TYPE_TIMER = 0,
	BPF_ASYNC_TYPE_WQ = 1,
};

enum bpf_attach_type {
	BPF_CGROUP_INET_INGRESS = 0,
	BPF_CGROUP_INET_EGRESS = 1,
	BPF_CGROUP_INET_SOCK_CREATE = 2,
	BPF_CGROUP_SOCK_OPS = 3,
	BPF_SK_SKB_STREAM_PARSER = 4,
	BPF_SK_SKB_STREAM_VERDICT = 5,
	BPF_CGROUP_DEVICE = 6,
	BPF_SK_MSG_VERDICT = 7,
	BPF_CGROUP_INET4_BIND = 8,
	BPF_CGROUP_INET6_BIND = 9,
	BPF_CGROUP_INET4_CONNECT = 10,
	BPF_CGROUP_INET6_CONNECT = 11,
	BPF_CGROUP_INET4_POST_BIND = 12,
	BPF_CGROUP_INET6_POST_BIND = 13,
	BPF_CGROUP_UDP4_SENDMSG = 14,
	BPF_CGROUP_UDP6_SENDMSG = 15,
	BPF_LIRC_MODE2 = 16,
	BPF_FLOW_DISSECTOR = 17,
	BPF_CGROUP_SYSCTL = 18,
	BPF_CGROUP_UDP4_RECVMSG = 19,
	BPF_CGROUP_UDP6_RECVMSG = 20,
	BPF_CGROUP_GETSOCKOPT = 21,
	BPF_CGROUP_SETSOCKOPT = 22,
	BPF_TRACE_RAW_TP = 23,
	BPF_TRACE_FENTRY = 24,
	BPF_TRACE_FEXIT = 25,
	BPF_MODIFY_RETURN = 26,
	BPF_LSM_MAC = 27,
	BPF_TRACE_ITER = 28,
	BPF_CGROUP_INET4_GETPEERNAME = 29,
	BPF_CGROUP_INET6_GETPEERNAME = 30,
	BPF_CGROUP_INET4_GETSOCKNAME = 31,
	BPF_CGROUP_INET6_GETSOCKNAME = 32,
	BPF_XDP_DEVMAP = 33,
	BPF_CGROUP_INET_SOCK_RELEASE = 34,
	BPF_XDP_CPUMAP = 35,
	BPF_SK_LOOKUP = 36,
	BPF_XDP = 37,
	BPF_SK_SKB_VERDICT = 38,
	BPF_SK_REUSEPORT_SELECT = 39,
	BPF_SK_REUSEPORT_SELECT_OR_MIGRATE = 40,
	BPF_PERF_EVENT = 41,
	BPF_TRACE_KPROBE_MULTI = 42,
	BPF_LSM_CGROUP = 43,
	BPF_STRUCT_OPS = 44,
	BPF_NETFILTER = 45,
	BPF_TCX_INGRESS = 46,
	BPF_TCX_EGRESS = 47,
	BPF_TRACE_UPROBE_MULTI = 48,
	BPF_CGROUP_UNIX_CONNECT = 49,
	BPF_CGROUP_UNIX_SENDMSG = 50,
	BPF_CGROUP_UNIX_RECVMSG = 51,
	BPF_CGROUP_UNIX_GETPEERNAME = 52,
	BPF_CGROUP_UNIX_GETSOCKNAME = 53,
	BPF_NETKIT_PRIMARY = 54,
	BPF_NETKIT_PEER = 55,
	BPF_TRACE_KPROBE_SESSION = 56,
	BPF_TRACE_UPROBE_SESSION = 57,
	__MAX_BPF_ATTACH_TYPE = 58,
};

enum bpf_audit {
	BPF_AUDIT_LOAD = 0,
	BPF_AUDIT_UNLOAD = 1,
	BPF_AUDIT_MAX = 2,
};

enum bpf_cgroup_iter_order {
	BPF_CGROUP_ITER_ORDER_UNSPEC = 0,
	BPF_CGROUP_ITER_SELF_ONLY = 1,
	BPF_CGROUP_ITER_DESCENDANTS_PRE = 2,
	BPF_CGROUP_ITER_DESCENDANTS_POST = 3,
	BPF_CGROUP_ITER_ANCESTORS_UP = 4,
};

enum bpf_cgroup_storage_type {
	BPF_CGROUP_STORAGE_SHARED = 0,
	BPF_CGROUP_STORAGE_PERCPU = 1,
	__BPF_CGROUP_STORAGE_MAX = 2,
};

enum bpf_check_mtu_flags {
	BPF_MTU_CHK_SEGS = 1,
};

enum bpf_check_mtu_ret {
	BPF_MTU_CHK_RET_SUCCESS = 0,
	BPF_MTU_CHK_RET_FRAG_NEEDED = 1,
	BPF_MTU_CHK_RET_SEGS_TOOBIG = 2,
};

enum bpf_cmd {
	BPF_MAP_CREATE = 0,
	BPF_MAP_LOOKUP_ELEM = 1,
	BPF_MAP_UPDATE_ELEM = 2,
	BPF_MAP_DELETE_ELEM = 3,
	BPF_MAP_GET_NEXT_KEY = 4,
	BPF_PROG_LOAD = 5,
	BPF_OBJ_PIN = 6,
	BPF_OBJ_GET = 7,
	BPF_PROG_ATTACH = 8,
	BPF_PROG_DETACH = 9,
	BPF_PROG_TEST_RUN = 10,
	BPF_PROG_RUN = 10,
	BPF_PROG_GET_NEXT_ID = 11,
	BPF_MAP_GET_NEXT_ID = 12,
	BPF_PROG_GET_FD_BY_ID = 13,
	BPF_MAP_GET_FD_BY_ID = 14,
	BPF_OBJ_GET_INFO_BY_FD = 15,
	BPF_PROG_QUERY = 16,
	BPF_RAW_TRACEPOINT_OPEN = 17,
	BPF_BTF_LOAD = 18,
	BPF_BTF_GET_FD_BY_ID = 19,
	BPF_TASK_FD_QUERY = 20,
	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
	BPF_MAP_FREEZE = 22,
	BPF_BTF_GET_NEXT_ID = 23,
	BPF_MAP_LOOKUP_BATCH = 24,
	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
	BPF_MAP_UPDATE_BATCH = 26,
	BPF_MAP_DELETE_BATCH = 27,
	BPF_LINK_CREATE = 28,
	BPF_LINK_UPDATE = 29,
	BPF_LINK_GET_FD_BY_ID = 30,
	BPF_LINK_GET_NEXT_ID = 31,
	BPF_ENABLE_STATS = 32,
	BPF_ITER_CREATE = 33,
	BPF_LINK_DETACH = 34,
	BPF_PROG_BIND_MAP = 35,
	BPF_TOKEN_CREATE = 36,
	__MAX_BPF_CMD = 37,
};

enum bpf_cond_pseudo_jmp {
	BPF_MAY_GOTO = 0,
};

enum bpf_core_relo_kind {
	BPF_CORE_FIELD_BYTE_OFFSET = 0,
	BPF_CORE_FIELD_BYTE_SIZE = 1,
	BPF_CORE_FIELD_EXISTS = 2,
	BPF_CORE_FIELD_SIGNED = 3,
	BPF_CORE_FIELD_LSHIFT_U64 = 4,
	BPF_CORE_FIELD_RSHIFT_U64 = 5,
	BPF_CORE_TYPE_ID_LOCAL = 6,
	BPF_CORE_TYPE_ID_TARGET = 7,
	BPF_CORE_TYPE_EXISTS = 8,
	BPF_CORE_TYPE_SIZE = 9,
	BPF_CORE_ENUMVAL_EXISTS = 10,
	BPF_CORE_ENUMVAL_VALUE = 11,
	BPF_CORE_TYPE_MATCHES = 12,
};

enum bpf_dynptr_type {
	BPF_DYNPTR_TYPE_INVALID = 0,
	BPF_DYNPTR_TYPE_LOCAL = 1,
	BPF_DYNPTR_TYPE_RINGBUF = 2,
	BPF_DYNPTR_TYPE_SKB = 3,
	BPF_DYNPTR_TYPE_XDP = 4,
};

enum bpf_func_id {
	BPF_FUNC_unspec = 0,
	BPF_FUNC_map_lookup_elem = 1,
	BPF_FUNC_map_update_elem = 2,
	BPF_FUNC_map_delete_elem = 3,
	BPF_FUNC_probe_read = 4,
	BPF_FUNC_ktime_get_ns = 5,
	BPF_FUNC_trace_printk = 6,
	BPF_FUNC_get_prandom_u32 = 7,
	BPF_FUNC_get_smp_processor_id = 8,
	BPF_FUNC_skb_store_bytes = 9,
	BPF_FUNC_l3_csum_replace = 10,
	BPF_FUNC_l4_csum_replace = 11,
	BPF_FUNC_tail_call = 12,
	BPF_FUNC_clone_redirect = 13,
	BPF_FUNC_get_current_pid_tgid = 14,
	BPF_FUNC_get_current_uid_gid = 15,
	BPF_FUNC_get_current_comm = 16,
	BPF_FUNC_get_cgroup_classid = 17,
	BPF_FUNC_skb_vlan_push = 18,
	BPF_FUNC_skb_vlan_pop = 19,
	BPF_FUNC_skb_get_tunnel_key = 20,
	BPF_FUNC_skb_set_tunnel_key = 21,
	BPF_FUNC_perf_event_read = 22,
	BPF_FUNC_redirect = 23,
	BPF_FUNC_get_route_realm = 24,
	BPF_FUNC_perf_event_output = 25,
	BPF_FUNC_skb_load_bytes = 26,
	BPF_FUNC_get_stackid = 27,
	BPF_FUNC_csum_diff = 28,
	BPF_FUNC_skb_get_tunnel_opt = 29,
	BPF_FUNC_skb_set_tunnel_opt = 30,
	BPF_FUNC_skb_change_proto = 31,
	BPF_FUNC_skb_change_type = 32,
	BPF_FUNC_skb_under_cgroup = 33,
	BPF_FUNC_get_hash_recalc = 34,
	BPF_FUNC_get_current_task = 35,
	BPF_FUNC_probe_write_user = 36,
	BPF_FUNC_current_task_under_cgroup = 37,
	BPF_FUNC_skb_change_tail = 38,
	BPF_FUNC_skb_pull_data = 39,
	BPF_FUNC_csum_update = 40,
	BPF_FUNC_set_hash_invalid = 41,
	BPF_FUNC_get_numa_node_id = 42,
	BPF_FUNC_skb_change_head = 43,
	BPF_FUNC_xdp_adjust_head = 44,
	BPF_FUNC_probe_read_str = 45,
	BPF_FUNC_get_socket_cookie = 46,
	BPF_FUNC_get_socket_uid = 47,
	BPF_FUNC_set_hash = 48,
	BPF_FUNC_setsockopt = 49,
	BPF_FUNC_skb_adjust_room = 50,
	BPF_FUNC_redirect_map = 51,
	BPF_FUNC_sk_redirect_map = 52,
	BPF_FUNC_sock_map_update = 53,
	BPF_FUNC_xdp_adjust_meta = 54,
	BPF_FUNC_perf_event_read_value = 55,
	BPF_FUNC_perf_prog_read_value = 56,
	BPF_FUNC_getsockopt = 57,
	BPF_FUNC_override_return = 58,
	BPF_FUNC_sock_ops_cb_flags_set = 59,
	BPF_FUNC_msg_redirect_map = 60,
	BPF_FUNC_msg_apply_bytes = 61,
	BPF_FUNC_msg_cork_bytes = 62,
	BPF_FUNC_msg_pull_data = 63,
	BPF_FUNC_bind = 64,
	BPF_FUNC_xdp_adjust_tail = 65,
	BPF_FUNC_skb_get_xfrm_state = 66,
	BPF_FUNC_get_stack = 67,
	BPF_FUNC_skb_load_bytes_relative = 68,
	BPF_FUNC_fib_lookup = 69,
	BPF_FUNC_sock_hash_update = 70,
	BPF_FUNC_msg_redirect_hash = 71,
	BPF_FUNC_sk_redirect_hash = 72,
	BPF_FUNC_lwt_push_encap = 73,
	BPF_FUNC_lwt_seg6_store_bytes = 74,
	BPF_FUNC_lwt_seg6_adjust_srh = 75,
	BPF_FUNC_lwt_seg6_action = 76,
	BPF_FUNC_rc_repeat = 77,
	BPF_FUNC_rc_keydown = 78,
	BPF_FUNC_skb_cgroup_id = 79,
	BPF_FUNC_get_current_cgroup_id = 80,
	BPF_FUNC_get_local_storage = 81,
	BPF_FUNC_sk_select_reuseport = 82,
	BPF_FUNC_skb_ancestor_cgroup_id = 83,
	BPF_FUNC_sk_lookup_tcp = 84,
	BPF_FUNC_sk_lookup_udp = 85,
	BPF_FUNC_sk_release = 86,
	BPF_FUNC_map_push_elem = 87,
	BPF_FUNC_map_pop_elem = 88,
	BPF_FUNC_map_peek_elem = 89,
	BPF_FUNC_msg_push_data = 90,
	BPF_FUNC_msg_pop_data = 91,
	BPF_FUNC_rc_pointer_rel = 92,
	BPF_FUNC_spin_lock = 93,
	BPF_FUNC_spin_unlock = 94,
	BPF_FUNC_sk_fullsock = 95,
	BPF_FUNC_tcp_sock = 96,
	BPF_FUNC_skb_ecn_set_ce = 97,
	BPF_FUNC_get_listener_sock = 98,
	BPF_FUNC_skc_lookup_tcp = 99,
	BPF_FUNC_tcp_check_syncookie = 100,
	BPF_FUNC_sysctl_get_name = 101,
	BPF_FUNC_sysctl_get_current_value = 102,
	BPF_FUNC_sysctl_get_new_value = 103,
	BPF_FUNC_sysctl_set_new_value = 104,
	BPF_FUNC_strtol = 105,
	BPF_FUNC_strtoul = 106,
	BPF_FUNC_sk_storage_get = 107,
	BPF_FUNC_sk_storage_delete = 108,
	BPF_FUNC_send_signal = 109,
	BPF_FUNC_tcp_gen_syncookie = 110,
	BPF_FUNC_skb_output = 111,
	BPF_FUNC_probe_read_user = 112,
	BPF_FUNC_probe_read_kernel = 113,
	BPF_FUNC_probe_read_user_str = 114,
	BPF_FUNC_probe_read_kernel_str = 115,
	BPF_FUNC_tcp_send_ack = 116,
	BPF_FUNC_send_signal_thread = 117,
	BPF_FUNC_jiffies64 = 118,
	BPF_FUNC_read_branch_records = 119,
	BPF_FUNC_get_ns_current_pid_tgid = 120,
	BPF_FUNC_xdp_output = 121,
	BPF_FUNC_get_netns_cookie = 122,
	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
	BPF_FUNC_sk_assign = 124,
	BPF_FUNC_ktime_get_boot_ns = 125,
	BPF_FUNC_seq_printf = 126,
	BPF_FUNC_seq_write = 127,
	BPF_FUNC_sk_cgroup_id = 128,
	BPF_FUNC_sk_ancestor_cgroup_id = 129,
	BPF_FUNC_ringbuf_output = 130,
	BPF_FUNC_ringbuf_reserve = 131,
	BPF_FUNC_ringbuf_submit = 132,
	BPF_FUNC_ringbuf_discard = 133,
	BPF_FUNC_ringbuf_query = 134,
	BPF_FUNC_csum_level = 135,
	BPF_FUNC_skc_to_tcp6_sock = 136,
	BPF_FUNC_skc_to_tcp_sock = 137,
	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
	BPF_FUNC_skc_to_tcp_request_sock = 139,
	BPF_FUNC_skc_to_udp6_sock = 140,
	BPF_FUNC_get_task_stack = 141,
	BPF_FUNC_load_hdr_opt = 142,
	BPF_FUNC_store_hdr_opt = 143,
	BPF_FUNC_reserve_hdr_opt = 144,
	BPF_FUNC_inode_storage_get = 145,
	BPF_FUNC_inode_storage_delete = 146,
	BPF_FUNC_d_path = 147,
	BPF_FUNC_copy_from_user = 148,
	BPF_FUNC_snprintf_btf = 149,
	BPF_FUNC_seq_printf_btf = 150,
	BPF_FUNC_skb_cgroup_classid = 151,
	BPF_FUNC_redirect_neigh = 152,
	BPF_FUNC_per_cpu_ptr = 153,
	BPF_FUNC_this_cpu_ptr = 154,
	BPF_FUNC_redirect_peer = 155,
	BPF_FUNC_task_storage_get = 156,
	BPF_FUNC_task_storage_delete = 157,
	BPF_FUNC_get_current_task_btf = 158,
	BPF_FUNC_bprm_opts_set = 159,
	BPF_FUNC_ktime_get_coarse_ns = 160,
	BPF_FUNC_ima_inode_hash = 161,
	BPF_FUNC_sock_from_file = 162,
	BPF_FUNC_check_mtu = 163,
	BPF_FUNC_for_each_map_elem = 164,
	BPF_FUNC_snprintf = 165,
	BPF_FUNC_sys_bpf = 166,
	BPF_FUNC_btf_find_by_name_kind = 167,
	BPF_FUNC_sys_close = 168,
	BPF_FUNC_timer_init = 169,
	BPF_FUNC_timer_set_callback = 170,
	BPF_FUNC_timer_start = 171,
	BPF_FUNC_timer_cancel = 172,
	BPF_FUNC_get_func_ip = 173,
	BPF_FUNC_get_attach_cookie = 174,
	BPF_FUNC_task_pt_regs = 175,
	BPF_FUNC_get_branch_snapshot = 176,
	BPF_FUNC_trace_vprintk = 177,
	BPF_FUNC_skc_to_unix_sock = 178,
	BPF_FUNC_kallsyms_lookup_name = 179,
	BPF_FUNC_find_vma = 180,
	BPF_FUNC_loop = 181,
	BPF_FUNC_strncmp = 182,
	BPF_FUNC_get_func_arg = 183,
	BPF_FUNC_get_func_ret = 184,
	BPF_FUNC_get_func_arg_cnt = 185,
	BPF_FUNC_get_retval = 186,
	BPF_FUNC_set_retval = 187,
	BPF_FUNC_xdp_get_buff_len = 188,
	BPF_FUNC_xdp_load_bytes = 189,
	BPF_FUNC_xdp_store_bytes = 190,
	BPF_FUNC_copy_from_user_task = 191,
	BPF_FUNC_skb_set_tstamp = 192,
	BPF_FUNC_ima_file_hash = 193,
	BPF_FUNC_kptr_xchg = 194,
	BPF_FUNC_map_lookup_percpu_elem = 195,
	BPF_FUNC_skc_to_mptcp_sock = 196,
	BPF_FUNC_dynptr_from_mem = 197,
	BPF_FUNC_ringbuf_reserve_dynptr = 198,
	BPF_FUNC_ringbuf_submit_dynptr = 199,
	BPF_FUNC_ringbuf_discard_dynptr = 200,
	BPF_FUNC_dynptr_read = 201,
	BPF_FUNC_dynptr_write = 202,
	BPF_FUNC_dynptr_data = 203,
	BPF_FUNC_tcp_raw_gen_syncookie_ipv4 = 204,
	BPF_FUNC_tcp_raw_gen_syncookie_ipv6 = 205,
	BPF_FUNC_tcp_raw_check_syncookie_ipv4 = 206,
	BPF_FUNC_tcp_raw_check_syncookie_ipv6 = 207,
	BPF_FUNC_ktime_get_tai_ns = 208,
	BPF_FUNC_user_ringbuf_drain = 209,
	BPF_FUNC_cgrp_storage_get = 210,
	BPF_FUNC_cgrp_storage_delete = 211,
	__BPF_FUNC_MAX_ID = 212,
};

enum bpf_hdr_start_off {
	BPF_HDR_START_MAC = 0,
	BPF_HDR_START_NET = 1,
};

enum bpf_iter_feature {
	BPF_ITER_RESCHED = 1,
};

enum bpf_iter_state {
	BPF_ITER_STATE_INVALID = 0,
	BPF_ITER_STATE_ACTIVE = 1,
	BPF_ITER_STATE_DRAINED = 2,
};

enum bpf_iter_task_type {
	BPF_TASK_ITER_ALL = 0,
	BPF_TASK_ITER_TID = 1,
	BPF_TASK_ITER_TGID = 2,
};

enum bpf_jit_poke_reason {
	BPF_POKE_REASON_TAIL_CALL = 0,
};

enum bpf_kfunc_flags {
	BPF_F_PAD_ZEROS = 1,
};

enum bpf_link_type {
	BPF_LINK_TYPE_UNSPEC = 0,
	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
	BPF_LINK_TYPE_TRACING = 2,
	BPF_LINK_TYPE_CGROUP = 3,
	BPF_LINK_TYPE_ITER = 4,
	BPF_LINK_TYPE_NETNS = 5,
	BPF_LINK_TYPE_XDP = 6,
	BPF_LINK_TYPE_PERF_EVENT = 7,
	BPF_LINK_TYPE_KPROBE_MULTI = 8,
	BPF_LINK_TYPE_STRUCT_OPS = 9,
	BPF_LINK_TYPE_NETFILTER = 10,
	BPF_LINK_TYPE_TCX = 11,
	BPF_LINK_TYPE_UPROBE_MULTI = 12,
	BPF_LINK_TYPE_NETKIT = 13,
	BPF_LINK_TYPE_SOCKMAP = 14,
	__MAX_BPF_LINK_TYPE = 15,
};

enum bpf_lru_list_type {
	BPF_LRU_LIST_T_ACTIVE = 0,
	BPF_LRU_LIST_T_INACTIVE = 1,
	BPF_LRU_LIST_T_FREE = 2,
	BPF_LRU_LOCAL_LIST_T_FREE = 3,
	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
};

enum bpf_lwt_encap_mode {
	BPF_LWT_ENCAP_SEG6 = 0,
	BPF_LWT_ENCAP_SEG6_INLINE = 1,
	BPF_LWT_ENCAP_IP = 2,
};

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC = 0,
	BPF_MAP_TYPE_HASH = 1,
	BPF_MAP_TYPE_ARRAY = 2,
	BPF_MAP_TYPE_PROG_ARRAY = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
	BPF_MAP_TYPE_PERCPU_HASH = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
	BPF_MAP_TYPE_STACK_TRACE = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
	BPF_MAP_TYPE_LRU_HASH = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
	BPF_MAP_TYPE_LPM_TRIE = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
	BPF_MAP_TYPE_DEVMAP = 14,
	BPF_MAP_TYPE_SOCKMAP = 15,
	BPF_MAP_TYPE_CPUMAP = 16,
	BPF_MAP_TYPE_XSKMAP = 17,
	BPF_MAP_TYPE_SOCKHASH = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED = 19,
	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED = 21,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE = 22,
	BPF_MAP_TYPE_STACK = 23,
	BPF_MAP_TYPE_SK_STORAGE = 24,
	BPF_MAP_TYPE_DEVMAP_HASH = 25,
	BPF_MAP_TYPE_STRUCT_OPS = 26,
	BPF_MAP_TYPE_RINGBUF = 27,
	BPF_MAP_TYPE_INODE_STORAGE = 28,
	BPF_MAP_TYPE_TASK_STORAGE = 29,
	BPF_MAP_TYPE_BLOOM_FILTER = 30,
	BPF_MAP_TYPE_USER_RINGBUF = 31,
	BPF_MAP_TYPE_CGRP_STORAGE = 32,
	BPF_MAP_TYPE_ARENA = 33,
	__MAX_BPF_MAP_TYPE = 34,
};

enum bpf_netdev_command {
	XDP_SETUP_PROG = 0,
	XDP_SETUP_PROG_HW = 1,
	BPF_OFFLOAD_MAP_ALLOC = 2,
	BPF_OFFLOAD_MAP_FREE = 3,
	XDP_SETUP_XSK_POOL = 4,
};

enum bpf_perf_event_type {
	BPF_PERF_EVENT_UNSPEC = 0,
	BPF_PERF_EVENT_UPROBE = 1,
	BPF_PERF_EVENT_URETPROBE = 2,
	BPF_PERF_EVENT_KPROBE = 3,
	BPF_PERF_EVENT_KRETPROBE = 4,
	BPF_PERF_EVENT_TRACEPOINT = 5,
	BPF_PERF_EVENT_EVENT = 6,
};

enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC = 0,
	BPF_PROG_TYPE_SOCKET_FILTER = 1,
	BPF_PROG_TYPE_KPROBE = 2,
	BPF_PROG_TYPE_SCHED_CLS = 3,
	BPF_PROG_TYPE_SCHED_ACT = 4,
	BPF_PROG_TYPE_TRACEPOINT = 5,
	BPF_PROG_TYPE_XDP = 6,
	BPF_PROG_TYPE_PERF_EVENT = 7,
	BPF_PROG_TYPE_CGROUP_SKB = 8,
	BPF_PROG_TYPE_CGROUP_SOCK = 9,
	BPF_PROG_TYPE_LWT_IN = 10,
	BPF_PROG_TYPE_LWT_OUT = 11,
	BPF_PROG_TYPE_LWT_XMIT = 12,
	BPF_PROG_TYPE_SOCK_OPS = 13,
	BPF_PROG_TYPE_SK_SKB = 14,
	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
	BPF_PROG_TYPE_SK_MSG = 16,
	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
	BPF_PROG_TYPE_LIRC_MODE2 = 20,
	BPF_PROG_TYPE_SK_REUSEPORT = 21,
	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
	BPF_PROG_TYPE_TRACING = 26,
	BPF_PROG_TYPE_STRUCT_OPS = 27,
	BPF_PROG_TYPE_EXT = 28,
	BPF_PROG_TYPE_LSM = 29,
	BPF_PROG_TYPE_SK_LOOKUP = 30,
	BPF_PROG_TYPE_SYSCALL = 31,
	BPF_PROG_TYPE_NETFILTER = 32,
	__MAX_BPF_PROG_TYPE = 33,
};

enum bpf_reg_liveness {
	REG_LIVE_NONE = 0,
	REG_LIVE_READ32 = 1,
	REG_LIVE_READ64 = 2,
	REG_LIVE_READ = 3,
	REG_LIVE_WRITTEN = 4,
	REG_LIVE_DONE = 8,
};

enum bpf_reg_type {
	NOT_INIT = 0,
	SCALAR_VALUE = 1,
	PTR_TO_CTX = 2,
	CONST_PTR_TO_MAP = 3,
	PTR_TO_MAP_VALUE = 4,
	PTR_TO_MAP_KEY = 5,
	PTR_TO_STACK = 6,
	PTR_TO_PACKET_META = 7,
	PTR_TO_PACKET = 8,
	PTR_TO_PACKET_END = 9,
	PTR_TO_FLOW_KEYS = 10,
	PTR_TO_SOCKET = 11,
	PTR_TO_SOCK_COMMON = 12,
	PTR_TO_TCP_SOCK = 13,
	PTR_TO_TP_BUFFER = 14,
	PTR_TO_XDP_SOCK = 15,
	PTR_TO_BTF_ID = 16,
	PTR_TO_MEM = 17,
	PTR_TO_ARENA = 18,
	PTR_TO_BUF = 19,
	PTR_TO_FUNC = 20,
	CONST_PTR_TO_DYNPTR = 21,
	__BPF_REG_TYPE_MAX = 22,
	PTR_TO_MAP_VALUE_OR_NULL = 260,
	PTR_TO_SOCKET_OR_NULL = 267,
	PTR_TO_SOCK_COMMON_OR_NULL = 268,
	PTR_TO_TCP_SOCK_OR_NULL = 269,
	PTR_TO_BTF_ID_OR_NULL = 272,
	__BPF_REG_TYPE_LIMIT = 134217727,
};

enum bpf_ret_code {
	BPF_OK = 0,
	BPF_DROP = 2,
	BPF_REDIRECT = 7,
	BPF_LWT_REROUTE = 128,
	BPF_FLOW_DISSECTOR_CONTINUE = 129,
};

enum bpf_return_type {
	RET_INTEGER = 0,
	RET_VOID = 1,
	RET_PTR_TO_MAP_VALUE = 2,
	RET_PTR_TO_SOCKET = 3,
	RET_PTR_TO_TCP_SOCK = 4,
	RET_PTR_TO_SOCK_COMMON = 5,
	RET_PTR_TO_MEM = 6,
	RET_PTR_TO_MEM_OR_BTF_ID = 7,
	RET_PTR_TO_BTF_ID = 8,
	__BPF_RET_TYPE_MAX = 9,
	RET_PTR_TO_MAP_VALUE_OR_NULL = 258,
	RET_PTR_TO_SOCKET_OR_NULL = 259,
	RET_PTR_TO_TCP_SOCK_OR_NULL = 260,
	RET_PTR_TO_SOCK_COMMON_OR_NULL = 261,
	RET_PTR_TO_RINGBUF_MEM_OR_NULL = 1286,
	RET_PTR_TO_DYNPTR_MEM_OR_NULL = 262,
	RET_PTR_TO_BTF_ID_OR_NULL = 264,
	RET_PTR_TO_BTF_ID_TRUSTED = 1048584,
	__BPF_RET_TYPE_LIMIT = 134217727,
};

enum bpf_stack_build_id_status {
	BPF_STACK_BUILD_ID_EMPTY = 0,
	BPF_STACK_BUILD_ID_VALID = 1,
	BPF_STACK_BUILD_ID_IP = 2,
};

enum bpf_stack_slot_type {
	STACK_INVALID = 0,
	STACK_SPILL = 1,
	STACK_MISC = 2,
	STACK_ZERO = 3,
	STACK_DYNPTR = 4,
	STACK_ITER = 5,
	STACK_IRQ_FLAG = 6,
};

enum bpf_stats_type {
	BPF_STATS_RUN_TIME = 0,
};

enum bpf_struct_ops_state {
	BPF_STRUCT_OPS_STATE_INIT = 0,
	BPF_STRUCT_OPS_STATE_INUSE = 1,
	BPF_STRUCT_OPS_STATE_TOBEFREE = 2,
	BPF_STRUCT_OPS_STATE_READY = 3,
};

enum bpf_struct_walk_result {
	WALK_SCALAR = 0,
	WALK_PTR = 1,
	WALK_STRUCT = 2,
};

enum bpf_task_fd_type {
	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
	BPF_FD_TYPE_TRACEPOINT = 1,
	BPF_FD_TYPE_KPROBE = 2,
	BPF_FD_TYPE_KRETPROBE = 3,
	BPF_FD_TYPE_UPROBE = 4,
	BPF_FD_TYPE_URETPROBE = 5,
};

enum bpf_task_vma_iter_find_op {
	task_vma_iter_first_vma = 0,
	task_vma_iter_next_vma = 1,
	task_vma_iter_find_vma = 2,
};

enum bpf_text_poke_type {
	BPF_MOD_CALL = 0,
	BPF_MOD_JUMP = 1,
};

enum bpf_tramp_prog_type {
	BPF_TRAMP_FENTRY = 0,
	BPF_TRAMP_FEXIT = 1,
	BPF_TRAMP_MODIFY_RETURN = 2,
	BPF_TRAMP_MAX = 3,
	BPF_TRAMP_REPLACE = 4,
};

enum bpf_type {
	BPF_TYPE_UNSPEC = 0,
	BPF_TYPE_PROG = 1,
	BPF_TYPE_MAP = 2,
	BPF_TYPE_LINK = 3,
};

enum bpf_type_flag {
	PTR_MAYBE_NULL = 256,
	MEM_RDONLY = 512,
	MEM_RINGBUF = 1024,
	MEM_USER = 2048,
	MEM_PERCPU = 4096,
	OBJ_RELEASE = 8192,
	PTR_UNTRUSTED = 16384,
	MEM_UNINIT = 32768,
	DYNPTR_TYPE_LOCAL = 65536,
	DYNPTR_TYPE_RINGBUF = 131072,
	MEM_FIXED_SIZE = 262144,
	MEM_ALLOC = 524288,
	PTR_TRUSTED = 1048576,
	MEM_RCU = 2097152,
	NON_OWN_REF = 4194304,
	DYNPTR_TYPE_SKB = 8388608,
	DYNPTR_TYPE_XDP = 16777216,
	MEM_ALIGNED = 33554432,
	MEM_WRITE = 67108864,
	__BPF_TYPE_FLAG_MAX = 67108865,
	__BPF_TYPE_LAST_FLAG = 67108864,
};

enum bpf_xdp_mode {
	XDP_MODE_SKB = 0,
	XDP_MODE_DRV = 1,
	XDP_MODE_HW = 2,
	__MAX_XDP_MODE = 3,
};

enum br2684_encaps {
	e_vc = 0,
	e_llc = 1,
};

enum br2684_payload {
	p_routed = 0,
	p_bridged = 1,
};

enum br_boolopt_id {
	BR_BOOLOPT_NO_LL_LEARN = 0,
	BR_BOOLOPT_MCAST_VLAN_SNOOPING = 1,
	BR_BOOLOPT_MST_ENABLE = 2,
	BR_BOOLOPT_MAX = 3,
};

enum br_cfm_ccm_interval {
	BR_CFM_CCM_INTERVAL_NONE = 0,
	BR_CFM_CCM_INTERVAL_3_3_MS = 1,
	BR_CFM_CCM_INTERVAL_10_MS = 2,
	BR_CFM_CCM_INTERVAL_100_MS = 3,
	BR_CFM_CCM_INTERVAL_1_SEC = 4,
	BR_CFM_CCM_INTERVAL_10_SEC = 5,
	BR_CFM_CCM_INTERVAL_1_MIN = 6,
	BR_CFM_CCM_INTERVAL_10_MIN = 7,
};

enum br_cfm_domain {
	BR_CFM_PORT = 0,
	BR_CFM_VLAN = 1,
};

enum br_cfm_mep_direction {
	BR_CFM_MEP_DIRECTION_DOWN = 0,
	BR_CFM_MEP_DIRECTION_UP = 1,
};

enum br_cfm_opcodes {
	BR_CFM_OPCODE_CCM = 1,
};

enum br_mrp_hw_support {
	BR_MRP_NONE = 0,
	BR_MRP_SW = 1,
	BR_MRP_HW = 2,
};

enum br_mrp_in_role_type {
	BR_MRP_IN_ROLE_DISABLED = 0,
	BR_MRP_IN_ROLE_MIC = 1,
	BR_MRP_IN_ROLE_MIM = 2,
};

enum br_mrp_in_state_type {
	BR_MRP_IN_STATE_OPEN = 0,
	BR_MRP_IN_STATE_CLOSED = 1,
};

enum br_mrp_port_role_type {
	BR_MRP_PORT_ROLE_PRIMARY = 0,
	BR_MRP_PORT_ROLE_SECONDARY = 1,
	BR_MRP_PORT_ROLE_INTER = 2,
};

enum br_mrp_port_state_type {
	BR_MRP_PORT_STATE_DISABLED = 0,
	BR_MRP_PORT_STATE_BLOCKED = 1,
	BR_MRP_PORT_STATE_FORWARDING = 2,
	BR_MRP_PORT_STATE_NOT_CONNECTED = 3,
};

enum br_mrp_ring_role_type {
	BR_MRP_RING_ROLE_DISABLED = 0,
	BR_MRP_RING_ROLE_MRC = 1,
	BR_MRP_RING_ROLE_MRM = 2,
	BR_MRP_RING_ROLE_MRA = 3,
};

enum br_mrp_ring_state_type {
	BR_MRP_RING_STATE_OPEN = 0,
	BR_MRP_RING_STATE_CLOSED = 1,
};

enum br_mrp_sub_tlv_header_type {
	BR_MRP_SUB_TLV_HEADER_TEST_MGR_NACK = 1,
	BR_MRP_SUB_TLV_HEADER_TEST_PROPAGATE = 2,
	BR_MRP_SUB_TLV_HEADER_TEST_AUTO_MGR = 3,
};

enum br_mrp_tlv_header_type {
	BR_MRP_TLV_HEADER_END = 0,
	BR_MRP_TLV_HEADER_COMMON = 1,
	BR_MRP_TLV_HEADER_RING_TEST = 2,
	BR_MRP_TLV_HEADER_RING_TOPO = 3,
	BR_MRP_TLV_HEADER_RING_LINK_DOWN = 4,
	BR_MRP_TLV_HEADER_RING_LINK_UP = 5,
	BR_MRP_TLV_HEADER_IN_TEST = 6,
	BR_MRP_TLV_HEADER_IN_TOPO = 7,
	BR_MRP_TLV_HEADER_IN_LINK_DOWN = 8,
	BR_MRP_TLV_HEADER_IN_LINK_UP = 9,
	BR_MRP_TLV_HEADER_IN_LINK_STATUS = 10,
	BR_MRP_TLV_HEADER_OPTION = 127,
};

enum br_pkt_type {
	BR_PKT_UNICAST = 0,
	BR_PKT_MULTICAST = 1,
	BR_PKT_BROADCAST = 2,
};

enum btf_arg_tag {
	ARG_TAG_CTX = 1,
	ARG_TAG_NONNULL = 2,
	ARG_TAG_TRUSTED = 4,
	ARG_TAG_NULLABLE = 8,
	ARG_TAG_ARENA = 16,
};

enum btf_field_iter_kind {
	BTF_FIELD_ITER_IDS = 0,
	BTF_FIELD_ITER_STRS = 1,
};

enum btf_field_type {
	BPF_SPIN_LOCK = 1,
	BPF_TIMER = 2,
	BPF_KPTR_UNREF = 4,
	BPF_KPTR_REF = 8,
	BPF_KPTR_PERCPU = 16,
	BPF_KPTR = 28,
	BPF_LIST_HEAD = 32,
	BPF_LIST_NODE = 64,
	BPF_RB_ROOT = 128,
	BPF_RB_NODE = 256,
	BPF_GRAPH_NODE = 320,
	BPF_GRAPH_ROOT = 160,
	BPF_REFCOUNT = 512,
	BPF_WORKQUEUE = 1024,
	BPF_UPTR = 2048,
};

enum btf_func_linkage {
	BTF_FUNC_STATIC = 0,
	BTF_FUNC_GLOBAL = 1,
	BTF_FUNC_EXTERN = 2,
};

enum btf_kfunc_hook {
	BTF_KFUNC_HOOK_COMMON = 0,
	BTF_KFUNC_HOOK_XDP = 1,
	BTF_KFUNC_HOOK_TC = 2,
	BTF_KFUNC_HOOK_STRUCT_OPS = 3,
	BTF_KFUNC_HOOK_TRACING = 4,
	BTF_KFUNC_HOOK_SYSCALL = 5,
	BTF_KFUNC_HOOK_FMODRET = 6,
	BTF_KFUNC_HOOK_CGROUP = 7,
	BTF_KFUNC_HOOK_SCHED_ACT = 8,
	BTF_KFUNC_HOOK_SK_SKB = 9,
	BTF_KFUNC_HOOK_SOCKET_FILTER = 10,
	BTF_KFUNC_HOOK_LWT = 11,
	BTF_KFUNC_HOOK_NETFILTER = 12,
	BTF_KFUNC_HOOK_KPROBE = 13,
	BTF_KFUNC_HOOK_MAX = 14,
};

enum btrfs_block_group_flags {
	BLOCK_GROUP_FLAG_IREF = 0,
	BLOCK_GROUP_FLAG_REMOVED = 1,
	BLOCK_GROUP_FLAG_TO_COPY = 2,
	BLOCK_GROUP_FLAG_RELOCATING_REPAIR = 3,
	BLOCK_GROUP_FLAG_CHUNK_ITEM_INSERTED = 4,
	BLOCK_GROUP_FLAG_ZONE_IS_ACTIVE = 5,
	BLOCK_GROUP_FLAG_ZONED_DATA_RELOC = 6,
	BLOCK_GROUP_FLAG_NEEDS_FREE_SPACE = 7,
	BLOCK_GROUP_FLAG_SEQUENTIAL_ZONE = 8,
	BLOCK_GROUP_FLAG_NEW = 9,
};

enum btrfs_block_group_size_class {
	BTRFS_BG_SZ_NONE = 0,
	BTRFS_BG_SZ_SMALL = 1,
	BTRFS_BG_SZ_MEDIUM = 2,
	BTRFS_BG_SZ_LARGE = 3,
};

enum btrfs_caching_type {
	BTRFS_CACHE_NO = 0,
	BTRFS_CACHE_STARTED = 1,
	BTRFS_CACHE_FINISHED = 2,
	BTRFS_CACHE_ERROR = 3,
};

enum btrfs_chunk_alloc_enum {
	CHUNK_ALLOC_NO_FORCE = 0,
	CHUNK_ALLOC_LIMITED = 1,
	CHUNK_ALLOC_FORCE = 2,
	CHUNK_ALLOC_FORCE_FOR_EXTENT = 3,
};

enum btrfs_chunk_allocation_policy {
	BTRFS_CHUNK_ALLOC_REGULAR = 0,
	BTRFS_CHUNK_ALLOC_ZONED = 1,
};

enum btrfs_compare_tree_result {
	BTRFS_COMPARE_TREE_NEW = 0,
	BTRFS_COMPARE_TREE_DELETED = 1,
	BTRFS_COMPARE_TREE_CHANGED = 2,
	BTRFS_COMPARE_TREE_SAME = 3,
};

enum btrfs_compression_type {
	BTRFS_COMPRESS_NONE = 0,
	BTRFS_COMPRESS_ZLIB = 1,
	BTRFS_COMPRESS_LZO = 2,
	BTRFS_COMPRESS_ZSTD = 3,
	BTRFS_NR_COMPRESS_TYPES = 4,
};

enum btrfs_csum_type {
	BTRFS_CSUM_TYPE_CRC32 = 0,
	BTRFS_CSUM_TYPE_XXHASH = 1,
	BTRFS_CSUM_TYPE_SHA256 = 2,
	BTRFS_CSUM_TYPE_BLAKE2 = 3,
};

enum btrfs_delayed_item_type {
	BTRFS_DELAYED_INSERTION_ITEM = 0,
	BTRFS_DELAYED_DELETION_ITEM = 1,
};

enum btrfs_delayed_ref_action {
	BTRFS_ADD_DELAYED_REF = 1,
	BTRFS_DROP_DELAYED_REF = 2,
	BTRFS_ADD_DELAYED_EXTENT = 3,
	BTRFS_UPDATE_DELAYED_HEAD = 4,
} __attribute__((mode(byte)));

enum btrfs_delayed_ref_flags {
	BTRFS_DELAYED_REFS_FLUSHING = 0,
};

enum btrfs_dev_stat_values {
	BTRFS_DEV_STAT_WRITE_ERRS = 0,
	BTRFS_DEV_STAT_READ_ERRS = 1,
	BTRFS_DEV_STAT_FLUSH_ERRS = 2,
	BTRFS_DEV_STAT_CORRUPTION_ERRS = 3,
	BTRFS_DEV_STAT_GENERATION_ERRS = 4,
	BTRFS_DEV_STAT_VALUES_MAX = 5,
};

enum btrfs_discard_state {
	BTRFS_DISCARD_EXTENTS = 0,
	BTRFS_DISCARD_BITMAPS = 1,
	BTRFS_DISCARD_RESET_CURSOR = 2,
};

enum btrfs_disk_cache_state {
	BTRFS_DC_WRITTEN = 0,
	BTRFS_DC_ERROR = 1,
	BTRFS_DC_CLEAR = 2,
	BTRFS_DC_SETUP = 3,
};

enum btrfs_err_code {
	BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET = 1,
	BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET = 2,
	BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET = 3,
	BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET = 4,
	BTRFS_ERROR_DEV_TGT_REPLACE = 5,
	BTRFS_ERROR_DEV_MISSING_NOT_FOUND = 6,
	BTRFS_ERROR_DEV_ONLY_WRITABLE = 7,
	BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS = 8,
	BTRFS_ERROR_DEV_RAID1C3_MIN_NOT_MET = 9,
	BTRFS_ERROR_DEV_RAID1C4_MIN_NOT_MET = 10,
};

enum btrfs_exclusive_operation {
	BTRFS_EXCLOP_NONE = 0,
	BTRFS_EXCLOP_BALANCE_PAUSED = 1,
	BTRFS_EXCLOP_BALANCE = 2,
	BTRFS_EXCLOP_DEV_ADD = 3,
	BTRFS_EXCLOP_DEV_REMOVE = 4,
	BTRFS_EXCLOP_DEV_REPLACE = 5,
	BTRFS_EXCLOP_RESIZE = 6,
	BTRFS_EXCLOP_SWAP_ACTIVATE = 7,
};

enum btrfs_extent_allocation_policy {
	BTRFS_EXTENT_ALLOC_CLUSTERED = 0,
	BTRFS_EXTENT_ALLOC_ZONED = 1,
};

enum btrfs_feature_set {
	FEAT_COMPAT = 0,
	FEAT_COMPAT_RO = 1,
	FEAT_INCOMPAT = 2,
	FEAT_MAX = 3,
};

enum btrfs_flush_state {
	FLUSH_DELAYED_ITEMS_NR = 1,
	FLUSH_DELAYED_ITEMS = 2,
	FLUSH_DELAYED_REFS_NR = 3,
	FLUSH_DELAYED_REFS = 4,
	FLUSH_DELALLOC = 5,
	FLUSH_DELALLOC_WAIT = 6,
	FLUSH_DELALLOC_FULL = 7,
	ALLOC_CHUNK = 8,
	ALLOC_CHUNK_FORCE = 9,
	RUN_DELAYED_IPUTS = 10,
	COMMIT_TRANS = 11,
	RESET_ZONES = 12,
};

enum btrfs_ilock_type {
	__BTRFS_ILOCK_SHARED_BIT = 0,
	BTRFS_ILOCK_SHARED = 1,
	__BTRFS_ILOCK_SHARED_SEQ = 0,
	__BTRFS_ILOCK_TRY_BIT = 1,
	BTRFS_ILOCK_TRY = 2,
	__BTRFS_ILOCK_TRY_SEQ = 1,
	__BTRFS_ILOCK_MMAP_BIT = 2,
	BTRFS_ILOCK_MMAP = 4,
	__BTRFS_ILOCK_MMAP_SEQ = 2,
};

enum btrfs_inline_ref_type {
	BTRFS_REF_TYPE_INVALID = 0,
	BTRFS_REF_TYPE_BLOCK = 1,
	BTRFS_REF_TYPE_DATA = 2,
	BTRFS_REF_TYPE_ANY = 3,
};

enum btrfs_lock_nesting {
	BTRFS_NESTING_NORMAL = 0,
	BTRFS_NESTING_COW = 1,
	BTRFS_NESTING_LEFT = 2,
	BTRFS_NESTING_RIGHT = 3,
	BTRFS_NESTING_LEFT_COW = 4,
	BTRFS_NESTING_RIGHT_COW = 5,
	BTRFS_NESTING_SPLIT = 6,
	BTRFS_NESTING_NEW_ROOT = 7,
	BTRFS_NESTING_MAX = 8,
};

enum btrfs_loop_type {
	LOOP_CACHING_NOWAIT = 0,
	LOOP_CACHING_WAIT = 1,
	LOOP_UNSET_SIZE_CLASS = 2,
	LOOP_ALLOC_CHUNK = 3,
	LOOP_WRONG_SIZE_CLASS = 4,
	LOOP_NO_EMPTY_SIZE = 5,
};

enum btrfs_map_op {
	BTRFS_MAP_READ = 0,
	BTRFS_MAP_WRITE = 1,
	BTRFS_MAP_GET_READ_MIRRORS = 2,
};

enum btrfs_mod_log_op {
	BTRFS_MOD_LOG_KEY_REPLACE = 0,
	BTRFS_MOD_LOG_KEY_ADD = 1,
	BTRFS_MOD_LOG_KEY_REMOVE = 2,
	BTRFS_MOD_LOG_KEY_REMOVE_WHILE_FREEING = 3,
	BTRFS_MOD_LOG_KEY_REMOVE_WHILE_MOVING = 4,
	BTRFS_MOD_LOG_MOVE_KEYS = 5,
	BTRFS_MOD_LOG_ROOT_REPLACE = 6,
};

enum btrfs_qgroup_mode {
	BTRFS_QGROUP_MODE_DISABLED = 0,
	BTRFS_QGROUP_MODE_FULL = 1,
	BTRFS_QGROUP_MODE_SIMPLE = 2,
};

enum btrfs_qgroup_rsv_type {
	BTRFS_QGROUP_RSV_DATA = 0,
	BTRFS_QGROUP_RSV_META_PERTRANS = 1,
	BTRFS_QGROUP_RSV_META_PREALLOC = 2,
	BTRFS_QGROUP_RSV_LAST = 3,
};

enum btrfs_raid_types {
	BTRFS_RAID_SINGLE = 0,
	BTRFS_RAID_RAID0 = 1,
	BTRFS_RAID_RAID1 = 2,
	BTRFS_RAID_DUP = 3,
	BTRFS_RAID_RAID10 = 4,
	BTRFS_RAID_RAID5 = 5,
	BTRFS_RAID_RAID6 = 6,
	BTRFS_RAID_RAID1C3 = 7,
	BTRFS_RAID_RAID1C4 = 8,
	BTRFS_NR_RAID_TYPES = 9,
};

enum btrfs_rbio_ops {
	BTRFS_RBIO_WRITE = 0,
	BTRFS_RBIO_READ_REBUILD = 1,
	BTRFS_RBIO_PARITY_SCRUB = 2,
};

enum btrfs_read_policy {
	BTRFS_READ_POLICY_PID = 0,
	BTRFS_NR_READ_POLICY = 1,
};

enum btrfs_ref_type {
	BTRFS_REF_NOT_SET = 0,
	BTRFS_REF_DATA = 1,
	BTRFS_REF_METADATA = 2,
	BTRFS_REF_LAST = 3,
} __attribute__((mode(byte)));

enum btrfs_reserve_flush_enum {
	BTRFS_RESERVE_NO_FLUSH = 0,
	BTRFS_RESERVE_FLUSH_LIMIT = 1,
	BTRFS_RESERVE_FLUSH_EVICT = 2,
	BTRFS_RESERVE_FLUSH_DATA = 3,
	BTRFS_RESERVE_FLUSH_FREE_SPACE_INODE = 4,
	BTRFS_RESERVE_FLUSH_ALL = 5,
	BTRFS_RESERVE_FLUSH_ALL_STEAL = 6,
	BTRFS_RESERVE_FLUSH_EMERGENCY = 7,
};

enum btrfs_rsv_type {
	BTRFS_BLOCK_RSV_GLOBAL = 0,
	BTRFS_BLOCK_RSV_DELALLOC = 1,
	BTRFS_BLOCK_RSV_TRANS = 2,
	BTRFS_BLOCK_RSV_CHUNK = 3,
	BTRFS_BLOCK_RSV_DELOPS = 4,
	BTRFS_BLOCK_RSV_DELREFS = 5,
	BTRFS_BLOCK_RSV_EMPTY = 6,
	BTRFS_BLOCK_RSV_TEMP = 7,
};

enum btrfs_send_cmd {
	BTRFS_SEND_C_UNSPEC = 0,
	BTRFS_SEND_C_SUBVOL = 1,
	BTRFS_SEND_C_SNAPSHOT = 2,
	BTRFS_SEND_C_MKFILE = 3,
	BTRFS_SEND_C_MKDIR = 4,
	BTRFS_SEND_C_MKNOD = 5,
	BTRFS_SEND_C_MKFIFO = 6,
	BTRFS_SEND_C_MKSOCK = 7,
	BTRFS_SEND_C_SYMLINK = 8,
	BTRFS_SEND_C_RENAME = 9,
	BTRFS_SEND_C_LINK = 10,
	BTRFS_SEND_C_UNLINK = 11,
	BTRFS_SEND_C_RMDIR = 12,
	BTRFS_SEND_C_SET_XATTR = 13,
	BTRFS_SEND_C_REMOVE_XATTR = 14,
	BTRFS_SEND_C_WRITE = 15,
	BTRFS_SEND_C_CLONE = 16,
	BTRFS_SEND_C_TRUNCATE = 17,
	BTRFS_SEND_C_CHMOD = 18,
	BTRFS_SEND_C_CHOWN = 19,
	BTRFS_SEND_C_UTIMES = 20,
	BTRFS_SEND_C_END = 21,
	BTRFS_SEND_C_UPDATE_EXTENT = 22,
	BTRFS_SEND_C_MAX_V1 = 22,
	BTRFS_SEND_C_FALLOCATE = 23,
	BTRFS_SEND_C_FILEATTR = 24,
	BTRFS_SEND_C_ENCODED_WRITE = 25,
	BTRFS_SEND_C_MAX_V2 = 25,
	BTRFS_SEND_C_ENABLE_VERITY = 26,
	BTRFS_SEND_C_MAX_V3 = 26,
	BTRFS_SEND_C_MAX = 26,
};

enum btrfs_subpage_type {
	BTRFS_SUBPAGE_METADATA = 0,
	BTRFS_SUBPAGE_DATA = 1,
};

enum btrfs_trans_state {
	TRANS_STATE_RUNNING = 0,
	TRANS_STATE_COMMIT_PREP = 1,
	TRANS_STATE_COMMIT_START = 2,
	TRANS_STATE_COMMIT_DOING = 3,
	TRANS_STATE_UNBLOCKED = 4,
	TRANS_STATE_SUPER_COMMITTED = 5,
	TRANS_STATE_COMPLETED = 6,
	TRANS_STATE_MAX = 7,
};

enum btrfs_tree_block_status {
	BTRFS_TREE_BLOCK_CLEAN = 0,
	BTRFS_TREE_BLOCK_INVALID_NRITEMS = 1,
	BTRFS_TREE_BLOCK_INVALID_PARENT_KEY = 2,
	BTRFS_TREE_BLOCK_BAD_KEY_ORDER = 3,
	BTRFS_TREE_BLOCK_INVALID_LEVEL = 4,
	BTRFS_TREE_BLOCK_INVALID_FREE_SPACE = 5,
	BTRFS_TREE_BLOCK_INVALID_OFFSETS = 6,
	BTRFS_TREE_BLOCK_INVALID_BLOCKPTR = 7,
	BTRFS_TREE_BLOCK_INVALID_ITEM = 8,
	BTRFS_TREE_BLOCK_INVALID_OWNER = 9,
	BTRFS_TREE_BLOCK_WRITTEN_NOT_SET = 10,
};

enum btrfs_trim_state {
	BTRFS_TRIM_STATE_UNTRIMMED = 0,
	BTRFS_TRIM_STATE_TRIMMED = 1,
	BTRFS_TRIM_STATE_TRIMMING = 2,
};

enum bug_trap_type {
	BUG_TRAP_TYPE_NONE = 0,
	BUG_TRAP_TYPE_WARN = 1,
	BUG_TRAP_TYPE_BUG = 2,
};

enum bus_notifier_event {
	BUS_NOTIFY_ADD_DEVICE = 0,
	BUS_NOTIFY_DEL_DEVICE = 1,
	BUS_NOTIFY_REMOVED_DEVICE = 2,
	BUS_NOTIFY_BIND_DRIVER = 3,
	BUS_NOTIFY_BOUND_DRIVER = 4,
	BUS_NOTIFY_UNBIND_DRIVER = 5,
	BUS_NOTIFY_UNBOUND_DRIVER = 6,
	BUS_NOTIFY_DRIVER_NOT_BOUND = 7,
};

enum cache_tag_type {
	CACHE_TAG_IOTLB = 0,
	CACHE_TAG_DEVTLB = 1,
	CACHE_TAG_NESTING_IOTLB = 2,
	CACHE_TAG_NESTING_DEVTLB = 3,
};

enum cache_type {
	CACHE_TYPE_NOCACHE = 0,
	CACHE_TYPE_INST = 1,
	CACHE_TYPE_DATA = 2,
	CACHE_TYPE_SEPARATE = 3,
	CACHE_TYPE_UNIFIED = 4,
};

enum cc_attr {
	CC_ATTR_MEM_ENCRYPT = 0,
	CC_ATTR_HOST_MEM_ENCRYPT = 1,
	CC_ATTR_GUEST_MEM_ENCRYPT = 2,
	CC_ATTR_GUEST_STATE_ENCRYPT = 3,
	CC_ATTR_GUEST_UNROLL_STRING_IO = 4,
	CC_ATTR_GUEST_SEV_SNP = 5,
	CC_ATTR_GUEST_SNP_SECURE_TSC = 6,
	CC_ATTR_HOST_SEV_SNP = 7,
};

enum cc_vendor {
	CC_VENDOR_NONE = 0,
	CC_VENDOR_AMD = 1,
	CC_VENDOR_INTEL = 2,
};

enum ccid3_fback_type {
	CCID3_FBACK_NONE = 0,
	CCID3_FBACK_INITIAL = 1,
	CCID3_FBACK_PERIODIC = 2,
	CCID3_FBACK_PARAM_CHANGE = 3,
};

enum ccid3_hc_rx_states {
	TFRC_RSTATE_NO_DATA = 1,
	TFRC_RSTATE_DATA = 2,
};

enum ccid3_hc_tx_states {
	TFRC_SSTATE_NO_SENT = 1,
	TFRC_SSTATE_NO_FBACK = 2,
	TFRC_SSTATE_FBACK = 3,
};

enum ccid3_options {
	TFRC_OPT_LOSS_EVENT_RATE = 192,
	TFRC_OPT_LOSS_INTERVALS = 193,
	TFRC_OPT_RECEIVE_RATE = 194,
};

enum ccid_dequeueing_decision {
	CCID_PACKET_SEND_AT_ONCE = 0,
	CCID_PACKET_DELAY_MAX = 65535,
	CCID_PACKET_DELAY = 65536,
	CCID_PACKET_WILL_DEQUEUE_LATER = 131072,
	CCID_PACKET_ERR = 983040,
};

enum cdg_state {
	CDG_UNKNOWN = 0,
	CDG_NONFULL = 1,
	CDG_FULL = 2,
	CDG_BACKOFF = 3,
};

enum cee_attrs {
	DCB_ATTR_CEE_UNSPEC = 0,
	DCB_ATTR_CEE_PEER_PG = 1,
	DCB_ATTR_CEE_PEER_PFC = 2,
	DCB_ATTR_CEE_PEER_APP_TABLE = 3,
	DCB_ATTR_CEE_TX_PG = 4,
	DCB_ATTR_CEE_RX_PG = 5,
	DCB_ATTR_CEE_PFC = 6,
	DCB_ATTR_CEE_APP_TABLE = 7,
	DCB_ATTR_CEE_FEAT = 8,
	__DCB_ATTR_CEE_MAX = 9,
};

enum cfi_mode {
	CFI_AUTO = 0,
	CFI_OFF = 1,
	CFI_KCFI = 2,
	CFI_FINEIBT = 3,
};

enum cgroup1_param {
	Opt_all = 0,
	Opt_clone_children = 1,
	Opt_cpuset_v2_mode = 2,
	Opt_name = 3,
	Opt_none = 4,
	Opt_noprefix = 5,
	Opt_release_agent = 6,
	Opt_xattr = 7,
	Opt_favordynmods = 8,
	Opt_nofavordynmods = 9,
};

enum cgroup2_param {
	Opt_nsdelegate = 0,
	Opt_favordynmods___2 = 1,
	Opt_memory_localevents = 2,
	Opt_memory_recursiveprot = 3,
	Opt_memory_hugetlb_accounting = 4,
	Opt_pids_localevents = 5,
	nr__cgroup2_params = 6,
};

enum cgroup_bpf_attach_type {
	CGROUP_BPF_ATTACH_TYPE_INVALID = -1,
	CGROUP_INET_INGRESS = 0,
	CGROUP_INET_EGRESS = 1,
	CGROUP_INET_SOCK_CREATE = 2,
	CGROUP_SOCK_OPS = 3,
	CGROUP_DEVICE = 4,
	CGROUP_INET4_BIND = 5,
	CGROUP_INET6_BIND = 6,
	CGROUP_INET4_CONNECT = 7,
	CGROUP_INET6_CONNECT = 8,
	CGROUP_UNIX_CONNECT = 9,
	CGROUP_INET4_POST_BIND = 10,
	CGROUP_INET6_POST_BIND = 11,
	CGROUP_UDP4_SENDMSG = 12,
	CGROUP_UDP6_SENDMSG = 13,
	CGROUP_UNIX_SENDMSG = 14,
	CGROUP_SYSCTL = 15,
	CGROUP_UDP4_RECVMSG = 16,
	CGROUP_UDP6_RECVMSG = 17,
	CGROUP_UNIX_RECVMSG = 18,
	CGROUP_GETSOCKOPT = 19,
	CGROUP_SETSOCKOPT = 20,
	CGROUP_INET4_GETPEERNAME = 21,
	CGROUP_INET6_GETPEERNAME = 22,
	CGROUP_UNIX_GETPEERNAME = 23,
	CGROUP_INET4_GETSOCKNAME = 24,
	CGROUP_INET6_GETSOCKNAME = 25,
	CGROUP_UNIX_GETSOCKNAME = 26,
	CGROUP_INET_SOCK_RELEASE = 27,
	CGROUP_LSM_START = 28,
	CGROUP_LSM_END = 37,
	MAX_CGROUP_BPF_ATTACH_TYPE = 38,
};

enum cgroup_filetype {
	CGROUP_FILE_PROCS = 0,
	CGROUP_FILE_TASKS = 1,
};

enum cgroup_opt_features {
	OPT_FEATURE_PRESSURE = 0,
	OPT_FEATURE_COUNT = 1,
};

enum cgroup_subsys_id {
	cpuset_cgrp_id = 0,
	cpu_cgrp_id = 1,
	cpuacct_cgrp_id = 2,
	io_cgrp_id = 3,
	memory_cgrp_id = 4,
	devices_cgrp_id = 5,
	freezer_cgrp_id = 6,
	net_cls_cgrp_id = 7,
	perf_event_cgrp_id = 8,
	net_prio_cgrp_id = 9,
	hugetlb_cgrp_id = 10,
	pids_cgrp_id = 11,
	rdma_cgrp_id = 12,
	misc_cgrp_id = 13,
	debug_cgrp_id = 14,
	CGROUP_SUBSYS_COUNT = 15,
};

enum chacha_constants {
	CHACHA_CONSTANT_EXPA = 1634760805,
	CHACHA_CONSTANT_ND_3 = 857760878,
	CHACHA_CONSTANT_2_BY = 2036477234,
	CHACHA_CONSTANT_TE_K = 1797285236,
};

enum check_link_response {
	HDCP_LINK_PROTECTED = 0,
	HDCP_TOPOLOGY_CHANGE = 1,
	HDCP_LINK_INTEGRITY_FAILURE = 2,
	HDCP_REAUTH_REQUEST = 3,
};

enum chipset_type {
	NOT_SUPPORTED = 0,
	SUPPORTED = 1,
};

enum class_map_type {
	DD_CLASS_TYPE_DISJOINT_BITS = 0,
	DD_CLASS_TYPE_LEVEL_NUM = 1,
	DD_CLASS_TYPE_DISJOINT_NAMES = 2,
	DD_CLASS_TYPE_LEVEL_NAMES = 3,
};

enum cleanup_prefix_rt_t {
	CLEANUP_PREFIX_RT_NOP = 0,
	CLEANUP_PREFIX_RT_DEL = 1,
	CLEANUP_PREFIX_RT_EXPIRE = 2,
};

enum clear_refs_types {
	CLEAR_REFS_ALL = 1,
	CLEAR_REFS_ANON = 2,
	CLEAR_REFS_MAPPED = 3,
	CLEAR_REFS_SOFT_DIRTY = 4,
	CLEAR_REFS_MM_HIWATER_RSS = 5,
	CLEAR_REFS_LAST = 6,
};

enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED = 0,
	CLOCK_EVT_STATE_SHUTDOWN = 1,
	CLOCK_EVT_STATE_PERIODIC = 2,
	CLOCK_EVT_STATE_ONESHOT = 3,
	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
};

enum clocksource_ids {
	CSID_GENERIC = 0,
	CSID_ARM_ARCH_COUNTER = 1,
	CSID_S390_TOD = 2,
	CSID_X86_TSC_EARLY = 3,
	CSID_X86_TSC = 4,
	CSID_X86_KVM_CLK = 5,
	CSID_X86_ART = 6,
	CSID_MAX = 7,
};

enum cmis_cdb_fw_write_mechanism {
	CMIS_CDB_FW_WRITE_MECHANISM_NONE = 0,
	CMIS_CDB_FW_WRITE_MECHANISM_LPL = 1,
	CMIS_CDB_FW_WRITE_MECHANISM_EPL = 16,
	CMIS_CDB_FW_WRITE_MECHANISM_BOTH = 17,
};

enum cntl_msg_types {
	IPCTNL_MSG_CT_NEW = 0,
	IPCTNL_MSG_CT_GET = 1,
	IPCTNL_MSG_CT_DELETE = 2,
	IPCTNL_MSG_CT_GET_CTRZERO = 3,
	IPCTNL_MSG_CT_GET_STATS_CPU = 4,
	IPCTNL_MSG_CT_GET_STATS = 5,
	IPCTNL_MSG_CT_GET_DYING = 6,
	IPCTNL_MSG_CT_GET_UNCONFIRMED = 7,
	IPCTNL_MSG_MAX = 8,
};

enum compact_priority {
	COMPACT_PRIO_SYNC_FULL = 0,
	MIN_COMPACT_PRIORITY = 0,
	COMPACT_PRIO_SYNC_LIGHT = 1,
	MIN_COMPACT_COSTLY_PRIORITY = 1,
	DEF_COMPACT_PRIORITY = 1,
	COMPACT_PRIO_ASYNC = 2,
	INIT_COMPACT_PRIORITY = 2,
};

enum compact_result {
	COMPACT_NOT_SUITABLE_ZONE = 0,
	COMPACT_SKIPPED = 1,
	COMPACT_DEFERRED = 2,
	COMPACT_NO_SUITABLE_PAGE = 3,
	COMPACT_CONTINUE = 4,
	COMPACT_COMPLETE = 5,
	COMPACT_PARTIAL_SKIPPED = 6,
	COMPACT_CONTENDED = 7,
	COMPACT_SUCCESS = 8,
};

enum con_flush_mode {
	CONSOLE_FLUSH_PENDING = 0,
	CONSOLE_REPLAY_ALL = 1,
};

enum con_msg_format_flags {
	MSG_FORMAT_DEFAULT = 0,
	MSG_FORMAT_SYSLOG = 1,
};

enum con_scroll {
	SM_UP = 0,
	SM_DOWN = 1,
};

enum cons_flags {
	CON_PRINTBUFFER = 1,
	CON_CONSDEV = 2,
	CON_ENABLED = 4,
	CON_BOOT = 8,
	CON_ANYTIME = 16,
	CON_BRL = 32,
	CON_EXTENDED = 64,
	CON_SUSPENDED = 128,
	CON_NBCON = 256,
};

enum context {
	IN_KERNEL = 1,
	IN_USER = 2,
	IN_KERNEL_RECOV = 3,
};

enum cp_error_code {
	CP_EC = 32767,
	CP_RET = 1,
	CP_IRET = 2,
	CP_ENDBR = 3,
	CP_RSTRORSSP = 4,
	CP_SETSSBSY = 5,
	CP_ENCL = 32768,
};

enum cpa_warn {
	CPA_CONFLICT = 0,
	CPA_PROTECT = 1,
	CPA_DETECT = 2,
};

enum cpio_fields {
	C_MAGIC = 0,
	C_INO = 1,
	C_MODE = 2,
	C_UID = 3,
	C_GID = 4,
	C_NLINK = 5,
	C_MTIME = 6,
	C_FILESIZE = 7,
	C_MAJ = 8,
	C_MIN = 9,
	C_RMAJ = 10,
	C_RMIN = 11,
	C_NAMESIZE = 12,
	C_CHKSUM = 13,
	C_NFIELDS = 14,
};

enum cppc_regs {
	HIGHEST_PERF = 0,
	NOMINAL_PERF = 1,
	LOW_NON_LINEAR_PERF = 2,
	LOWEST_PERF = 3,
	GUARANTEED_PERF = 4,
	DESIRED_PERF = 5,
	MIN_PERF = 6,
	MAX_PERF = 7,
	PERF_REDUC_TOLERANCE = 8,
	TIME_WINDOW = 9,
	CTR_WRAP_TIME = 10,
	REFERENCE_CTR = 11,
	DELIVERED_CTR = 12,
	PERF_LIMITED = 13,
	ENABLE = 14,
	AUTO_SEL_ENABLE = 15,
	AUTO_ACT_WINDOW = 16,
	ENERGY_PERF = 17,
	REFERENCE_PERF = 18,
	LOWEST_FREQ = 19,
	NOMINAL_FREQ = 20,
};

enum cpu_idle_type {
	__CPU_NOT_IDLE = 0,
	CPU_IDLE = 1,
	CPU_NEWLY_IDLE = 2,
	CPU_MAX_IDLE_TYPES = 3,
};

enum cpu_mitigations {
	CPU_MITIGATIONS_OFF = 0,
	CPU_MITIGATIONS_AUTO = 1,
	CPU_MITIGATIONS_AUTO_NOSMT = 2,
};

enum cpu_usage_stat {
	CPUTIME_USER = 0,
	CPUTIME_NICE = 1,
	CPUTIME_SYSTEM = 2,
	CPUTIME_SOFTIRQ = 3,
	CPUTIME_IRQ = 4,
	CPUTIME_IDLE = 5,
	CPUTIME_IOWAIT = 6,
	CPUTIME_STEAL = 7,
	CPUTIME_GUEST = 8,
	CPUTIME_GUEST_NICE = 9,
	NR_STATS = 10,
};

enum cpuacct_stat_index {
	CPUACCT_STAT_USER = 0,
	CPUACCT_STAT_SYSTEM = 1,
	CPUACCT_STAT_NSTATS = 2,
};

enum cpufreq_table_sorting {
	CPUFREQ_TABLE_UNSORTED = 0,
	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
};

enum cpuhp_smt_control {
	CPU_SMT_ENABLED = 0,
	CPU_SMT_DISABLED = 1,
	CPU_SMT_FORCE_DISABLED = 2,
	CPU_SMT_NOT_SUPPORTED = 3,
	CPU_SMT_NOT_IMPLEMENTED = 4,
};

enum cpuhp_state {
	CPUHP_INVALID = -1,
	CPUHP_OFFLINE = 0,
	CPUHP_CREATE_THREADS = 1,
	CPUHP_PERF_PREPARE = 2,
	CPUHP_PERF_X86_PREPARE = 3,
	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
	CPUHP_PERF_POWER = 5,
	CPUHP_PERF_SUPERH = 6,
	CPUHP_X86_HPET_DEAD = 7,
	CPUHP_X86_MCE_DEAD = 8,
	CPUHP_VIRT_NET_DEAD = 9,
	CPUHP_IBMVNIC_DEAD = 10,
	CPUHP_SLUB_DEAD = 11,
	CPUHP_DEBUG_OBJ_DEAD = 12,
	CPUHP_MM_WRITEBACK_DEAD = 13,
	CPUHP_MM_VMSTAT_DEAD = 14,
	CPUHP_SOFTIRQ_DEAD = 15,
	CPUHP_NET_MVNETA_DEAD = 16,
	CPUHP_CPUIDLE_DEAD = 17,
	CPUHP_ARM64_FPSIMD_DEAD = 18,
	CPUHP_ARM_OMAP_WAKE_DEAD = 19,
	CPUHP_IRQ_POLL_DEAD = 20,
	CPUHP_BLOCK_SOFTIRQ_DEAD = 21,
	CPUHP_BIO_DEAD = 22,
	CPUHP_ACPI_CPUDRV_DEAD = 23,
	CPUHP_S390_PFAULT_DEAD = 24,
	CPUHP_BLK_MQ_DEAD = 25,
	CPUHP_FS_BUFF_DEAD = 26,
	CPUHP_PRINTK_DEAD = 27,
	CPUHP_MM_MEMCQ_DEAD = 28,
	CPUHP_PERCPU_CNT_DEAD = 29,
	CPUHP_RADIX_DEAD = 30,
	CPUHP_PAGE_ALLOC = 31,
	CPUHP_NET_DEV_DEAD = 32,
	CPUHP_PCI_XGENE_DEAD = 33,
	CPUHP_IOMMU_IOVA_DEAD = 34,
	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 35,
	CPUHP_PADATA_DEAD = 36,
	CPUHP_AP_DTPM_CPU_DEAD = 37,
	CPUHP_RANDOM_PREPARE = 38,
	CPUHP_WORKQUEUE_PREP = 39,
	CPUHP_POWER_NUMA_PREPARE = 40,
	CPUHP_HRTIMERS_PREPARE = 41,
	CPUHP_X2APIC_PREPARE = 42,
	CPUHP_SMPCFD_PREPARE = 43,
	CPUHP_RELAY_PREPARE = 44,
	CPUHP_MD_RAID5_PREPARE = 45,
	CPUHP_RCUTREE_PREP = 46,
	CPUHP_CPUIDLE_COUPLED_PREPARE = 47,
	CPUHP_POWERPC_PMAC_PREPARE = 48,
	CPUHP_POWERPC_MMU_CTX_PREPARE = 49,
	CPUHP_XEN_PREPARE = 50,
	CPUHP_XEN_EVTCHN_PREPARE = 51,
	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 52,
	CPUHP_SH_SH3X_PREPARE = 53,
	CPUHP_TOPOLOGY_PREPARE = 54,
	CPUHP_NET_IUCV_PREPARE = 55,
	CPUHP_ARM_BL_PREPARE = 56,
	CPUHP_TRACE_RB_PREPARE = 57,
	CPUHP_MM_ZS_PREPARE = 58,
	CPUHP_MM_ZSWP_POOL_PREPARE = 59,
	CPUHP_KVM_PPC_BOOK3S_PREPARE = 60,
	CPUHP_ZCOMP_PREPARE = 61,
	CPUHP_TIMERS_PREPARE = 62,
	CPUHP_TMIGR_PREPARE = 63,
	CPUHP_MIPS_SOC_PREPARE = 64,
	CPUHP_BP_PREPARE_DYN = 65,
	CPUHP_BP_PREPARE_DYN_END = 85,
	CPUHP_BP_KICK_AP = 86,
	CPUHP_BRINGUP_CPU = 87,
	CPUHP_AP_IDLE_DEAD = 88,
	CPUHP_AP_OFFLINE = 89,
	CPUHP_AP_CACHECTRL_STARTING = 90,
	CPUHP_AP_SCHED_STARTING = 91,
	CPUHP_AP_RCUTREE_DYING = 92,
	CPUHP_AP_CPU_PM_STARTING = 93,
	CPUHP_AP_IRQ_GIC_STARTING = 94,
	CPUHP_AP_IRQ_HIP04_STARTING = 95,
	CPUHP_AP_IRQ_APPLE_AIC_STARTING = 96,
	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 97,
	CPUHP_AP_IRQ_BCM2836_STARTING = 98,
	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 99,
	CPUHP_AP_IRQ_EIOINTC_STARTING = 100,
	CPUHP_AP_IRQ_AVECINTC_STARTING = 101,
	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 102,
	CPUHP_AP_IRQ_THEAD_ACLINT_SSWI_STARTING = 103,
	CPUHP_AP_IRQ_RISCV_IMSIC_STARTING = 104,
	CPUHP_AP_IRQ_RISCV_SBI_IPI_STARTING = 105,
	CPUHP_AP_ARM_MVEBU_COHERENCY = 106,
	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 107,
	CPUHP_AP_PERF_X86_STARTING = 108,
	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 109,
	CPUHP_AP_PERF_XTENSA_STARTING = 110,
	CPUHP_AP_ARM_VFP_STARTING = 111,
	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 112,
	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 113,
	CPUHP_AP_PERF_ARM_ACPI_STARTING = 114,
	CPUHP_AP_PERF_ARM_STARTING = 115,
	CPUHP_AP_PERF_RISCV_STARTING = 116,
	CPUHP_AP_ARM_L2X0_STARTING = 117,
	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 118,
	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 119,
	CPUHP_AP_ARM_ARCH_TIMER_EVTSTRM_STARTING = 120,
	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 121,
	CPUHP_AP_JCORE_TIMER_STARTING = 122,
	CPUHP_AP_ARM_TWD_STARTING = 123,
	CPUHP_AP_QCOM_TIMER_STARTING = 124,
	CPUHP_AP_TEGRA_TIMER_STARTING = 125,
	CPUHP_AP_ARMADA_TIMER_STARTING = 126,
	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 127,
	CPUHP_AP_ARC_TIMER_STARTING = 128,
	CPUHP_AP_REALTEK_TIMER_STARTING = 129,
	CPUHP_AP_RISCV_TIMER_STARTING = 130,
	CPUHP_AP_CLINT_TIMER_STARTING = 131,
	CPUHP_AP_CSKY_TIMER_STARTING = 132,
	CPUHP_AP_TI_GP_TIMER_STARTING = 133,
	CPUHP_AP_HYPERV_TIMER_STARTING = 134,
	CPUHP_AP_DUMMY_TIMER_STARTING = 135,
	CPUHP_AP_ARM_XEN_STARTING = 136,
	CPUHP_AP_ARM_XEN_RUNSTATE_STARTING = 137,
	CPUHP_AP_ARM_CORESIGHT_STARTING = 138,
	CPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 139,
	CPUHP_AP_ARM64_ISNDEP_STARTING = 140,
	CPUHP_AP_SMPCFD_DYING = 141,
	CPUHP_AP_HRTIMERS_DYING = 142,
	CPUHP_AP_TICK_DYING = 143,
	CPUHP_AP_X86_TBOOT_DYING = 144,
	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 145,
	CPUHP_AP_ONLINE = 146,
	CPUHP_TEARDOWN_CPU = 147,
	CPUHP_AP_ONLINE_IDLE = 148,
	CPUHP_AP_HYPERV_ONLINE = 149,
	CPUHP_AP_KVM_ONLINE = 150,
	CPUHP_AP_SCHED_WAIT_EMPTY = 151,
	CPUHP_AP_SMPBOOT_THREADS = 152,
	CPUHP_AP_IRQ_AFFINITY_ONLINE = 153,
	CPUHP_AP_BLK_MQ_ONLINE = 154,
	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 155,
	CPUHP_AP_X86_INTEL_EPB_ONLINE = 156,
	CPUHP_AP_PERF_ONLINE = 157,
	CPUHP_AP_PERF_X86_ONLINE = 158,
	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 159,
	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 160,
	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 161,
	CPUHP_AP_PERF_S390_CF_ONLINE = 162,
	CPUHP_AP_PERF_S390_SF_ONLINE = 163,
	CPUHP_AP_PERF_ARM_CCI_ONLINE = 164,
	CPUHP_AP_PERF_ARM_CCN_ONLINE = 165,
	CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE = 166,
	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 167,
	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 168,
	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 169,
	CPUHP_AP_PERF_ARM_HISI_PA_ONLINE = 170,
	CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE = 171,
	CPUHP_AP_PERF_ARM_HISI_PCIE_PMU_ONLINE = 172,
	CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE = 173,
	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 174,
	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 175,
	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 176,
	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 177,
	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 178,
	CPUHP_AP_PERF_ARM_MARVELL_CN10K_DDR_ONLINE = 179,
	CPUHP_AP_PERF_ARM_MRVL_PEM_ONLINE = 180,
	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 181,
	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 182,
	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 183,
	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 184,
	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 185,
	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 186,
	CPUHP_AP_PERF_CSKY_ONLINE = 187,
	CPUHP_AP_TMIGR_ONLINE = 188,
	CPUHP_AP_WATCHDOG_ONLINE = 189,
	CPUHP_AP_WORKQUEUE_ONLINE = 190,
	CPUHP_AP_RANDOM_ONLINE = 191,
	CPUHP_AP_RCUTREE_ONLINE = 192,
	CPUHP_AP_KTHREADS_ONLINE = 193,
	CPUHP_AP_BASE_CACHEINFO_ONLINE = 194,
	CPUHP_AP_ONLINE_DYN = 195,
	CPUHP_AP_ONLINE_DYN_END = 235,
	CPUHP_AP_X86_HPET_ONLINE = 236,
	CPUHP_AP_X86_KVM_CLK_ONLINE = 237,
	CPUHP_AP_ACTIVE = 238,
	CPUHP_ONLINE = 239,
};

enum cpuhp_sync_state {
	SYNC_STATE_DEAD = 0,
	SYNC_STATE_KICKED = 1,
	SYNC_STATE_SHOULD_DIE = 2,
	SYNC_STATE_ALIVE = 3,
	SYNC_STATE_SHOULD_ONLINE = 4,
	SYNC_STATE_ONLINE = 5,
};

enum cpuid_leafs {
	CPUID_1_EDX = 0,
	CPUID_8000_0001_EDX = 1,
	CPUID_8086_0001_EDX = 2,
	CPUID_LNX_1 = 3,
	CPUID_1_ECX = 4,
	CPUID_C000_0001_EDX = 5,
	CPUID_8000_0001_ECX = 6,
	CPUID_LNX_2 = 7,
	CPUID_LNX_3 = 8,
	CPUID_7_0_EBX = 9,
	CPUID_D_1_EAX = 10,
	CPUID_LNX_4 = 11,
	CPUID_7_1_EAX = 12,
	CPUID_8000_0008_EBX = 13,
	CPUID_6_EAX = 14,
	CPUID_8000_000A_EDX = 15,
	CPUID_7_ECX = 16,
	CPUID_8000_0007_EBX = 17,
	CPUID_7_EDX = 18,
	CPUID_8000_001F_EAX = 19,
	CPUID_8000_0021_EAX = 20,
	CPUID_LNX_5 = 21,
	NR_CPUID_WORDS = 22,
};

enum cpuid_regs_idx {
	CPUID_EAX = 0,
	CPUID_EBX = 1,
	CPUID_ECX = 2,
	CPUID_EDX = 3,
};

enum crb_cancel {
	CRB_CANCEL_INVOKE = 1,
};

enum crb_ctrl_req {
	CRB_CTRL_REQ_CMD_READY = 1,
	CRB_CTRL_REQ_GO_IDLE = 2,
};

enum crb_ctrl_sts {
	CRB_CTRL_STS_ERROR = 1,
	CRB_CTRL_STS_TPM_IDLE = 2,
};

enum crb_defaults {
	CRB_ACPI_START_REVISION_ID = 1,
	CRB_ACPI_START_INDEX = 1,
};

enum crb_loc_ctrl {
	CRB_LOC_CTRL_REQUEST_ACCESS = 1,
	CRB_LOC_CTRL_RELINQUISH = 2,
};

enum crb_loc_state {
	CRB_LOC_STATE_LOC_ASSIGNED = 2,
	CRB_LOC_STATE_TPM_REG_VALID_STS = 128,
};

enum crb_start {
	CRB_START_INVOKE = 1,
};

enum crb_status {
	CRB_DRV_STS_COMPLETE = 1,
};

enum createmode4 {
	NFS4_CREATE_UNCHECKED = 0,
	NFS4_CREATE_GUARDED = 1,
	NFS4_CREATE_EXCLUSIVE = 2,
	NFS4_CREATE_EXCLUSIVE4_1 = 3,
};

enum criteria {
	CR_POWER2_ALIGNED = 0,
	CR_GOAL_LEN_FAST = 1,
	CR_BEST_AVAIL_LEN = 2,
	CR_GOAL_LEN_SLOW = 3,
	CR_ANY_FREE = 4,
	EXT4_MB_NUM_CRS = 5,
};

enum ct_dccp_roles {
	CT_DCCP_ROLE_CLIENT = 0,
	CT_DCCP_ROLE_SERVER = 1,
	__CT_DCCP_ROLE_MAX = 2,
};

enum ct_dccp_states {
	CT_DCCP_NONE = 0,
	CT_DCCP_REQUEST = 1,
	CT_DCCP_RESPOND = 2,
	CT_DCCP_PARTOPEN = 3,
	CT_DCCP_OPEN = 4,
	CT_DCCP_CLOSEREQ = 5,
	CT_DCCP_CLOSING = 6,
	CT_DCCP_TIMEWAIT = 7,
	CT_DCCP_IGNORE = 8,
	CT_DCCP_INVALID = 9,
	__CT_DCCP_MAX = 10,
};

enum ctattr_counters {
	CTA_COUNTERS_UNSPEC = 0,
	CTA_COUNTERS_PACKETS = 1,
	CTA_COUNTERS_BYTES = 2,
	CTA_COUNTERS32_PACKETS = 3,
	CTA_COUNTERS32_BYTES = 4,
	CTA_COUNTERS_PAD = 5,
	__CTA_COUNTERS_MAX = 6,
};

enum ctattr_expect {
	CTA_EXPECT_UNSPEC = 0,
	CTA_EXPECT_MASTER = 1,
	CTA_EXPECT_TUPLE = 2,
	CTA_EXPECT_MASK = 3,
	CTA_EXPECT_TIMEOUT = 4,
	CTA_EXPECT_ID = 5,
	CTA_EXPECT_HELP_NAME = 6,
	CTA_EXPECT_ZONE = 7,
	CTA_EXPECT_FLAGS = 8,
	CTA_EXPECT_CLASS = 9,
	CTA_EXPECT_NAT = 10,
	CTA_EXPECT_FN = 11,
	__CTA_EXPECT_MAX = 12,
};

enum ctattr_expect_nat {
	CTA_EXPECT_NAT_UNSPEC = 0,
	CTA_EXPECT_NAT_DIR = 1,
	CTA_EXPECT_NAT_TUPLE = 2,
	__CTA_EXPECT_NAT_MAX = 3,
};

enum ctattr_expect_stats {
	CTA_STATS_EXP_UNSPEC = 0,
	CTA_STATS_EXP_NEW = 1,
	CTA_STATS_EXP_CREATE = 2,
	CTA_STATS_EXP_DELETE = 3,
	__CTA_STATS_EXP_MAX = 4,
};

enum ctattr_filter {
	CTA_FILTER_UNSPEC = 0,
	CTA_FILTER_ORIG_FLAGS = 1,
	CTA_FILTER_REPLY_FLAGS = 2,
	__CTA_FILTER_MAX = 3,
};

enum ctattr_help {
	CTA_HELP_UNSPEC = 0,
	CTA_HELP_NAME = 1,
	CTA_HELP_INFO = 2,
	__CTA_HELP_MAX = 3,
};

enum ctattr_ip {
	CTA_IP_UNSPEC = 0,
	CTA_IP_V4_SRC = 1,
	CTA_IP_V4_DST = 2,
	CTA_IP_V6_SRC = 3,
	CTA_IP_V6_DST = 4,
	__CTA_IP_MAX = 5,
};

enum ctattr_l4proto {
	CTA_PROTO_UNSPEC = 0,
	CTA_PROTO_NUM = 1,
	CTA_PROTO_SRC_PORT = 2,
	CTA_PROTO_DST_PORT = 3,
	CTA_PROTO_ICMP_ID = 4,
	CTA_PROTO_ICMP_TYPE = 5,
	CTA_PROTO_ICMP_CODE = 6,
	CTA_PROTO_ICMPV6_ID = 7,
	CTA_PROTO_ICMPV6_TYPE = 8,
	CTA_PROTO_ICMPV6_CODE = 9,
	__CTA_PROTO_MAX = 10,
};

enum ctattr_nat {
	CTA_NAT_UNSPEC = 0,
	CTA_NAT_V4_MINIP = 1,
	CTA_NAT_V4_MAXIP = 2,
	CTA_NAT_PROTO = 3,
	CTA_NAT_V6_MINIP = 4,
	CTA_NAT_V6_MAXIP = 5,
	__CTA_NAT_MAX = 6,
};

enum ctattr_protoinfo {
	CTA_PROTOINFO_UNSPEC = 0,
	CTA_PROTOINFO_TCP = 1,
	CTA_PROTOINFO_DCCP = 2,
	CTA_PROTOINFO_SCTP = 3,
	__CTA_PROTOINFO_MAX = 4,
};

enum ctattr_protoinfo_dccp {
	CTA_PROTOINFO_DCCP_UNSPEC = 0,
	CTA_PROTOINFO_DCCP_STATE = 1,
	CTA_PROTOINFO_DCCP_ROLE = 2,
	CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ = 3,
	CTA_PROTOINFO_DCCP_PAD = 4,
	__CTA_PROTOINFO_DCCP_MAX = 5,
};

enum ctattr_protoinfo_sctp {
	CTA_PROTOINFO_SCTP_UNSPEC = 0,
	CTA_PROTOINFO_SCTP_STATE = 1,
	CTA_PROTOINFO_SCTP_VTAG_ORIGINAL = 2,
	CTA_PROTOINFO_SCTP_VTAG_REPLY = 3,
	__CTA_PROTOINFO_SCTP_MAX = 4,
};

enum ctattr_protoinfo_tcp {
	CTA_PROTOINFO_TCP_UNSPEC = 0,
	CTA_PROTOINFO_TCP_STATE = 1,
	CTA_PROTOINFO_TCP_WSCALE_ORIGINAL = 2,
	CTA_PROTOINFO_TCP_WSCALE_REPLY = 3,
	CTA_PROTOINFO_TCP_FLAGS_ORIGINAL = 4,
	CTA_PROTOINFO_TCP_FLAGS_REPLY = 5,
	__CTA_PROTOINFO_TCP_MAX = 6,
};

enum ctattr_protonat {
	CTA_PROTONAT_UNSPEC = 0,
	CTA_PROTONAT_PORT_MIN = 1,
	CTA_PROTONAT_PORT_MAX = 2,
	__CTA_PROTONAT_MAX = 3,
};

enum ctattr_secctx {
	CTA_SECCTX_UNSPEC = 0,
	CTA_SECCTX_NAME = 1,
	__CTA_SECCTX_MAX = 2,
};

enum ctattr_seqadj {
	CTA_SEQADJ_UNSPEC = 0,
	CTA_SEQADJ_CORRECTION_POS = 1,
	CTA_SEQADJ_OFFSET_BEFORE = 2,
	CTA_SEQADJ_OFFSET_AFTER = 3,
	__CTA_SEQADJ_MAX = 4,
};

enum ctattr_stats_cpu {
	CTA_STATS_UNSPEC = 0,
	CTA_STATS_SEARCHED = 1,
	CTA_STATS_FOUND = 2,
	CTA_STATS_NEW = 3,
	CTA_STATS_INVALID = 4,
	CTA_STATS_IGNORE = 5,
	CTA_STATS_DELETE = 6,
	CTA_STATS_DELETE_LIST = 7,
	CTA_STATS_INSERT = 8,
	CTA_STATS_INSERT_FAILED = 9,
	CTA_STATS_DROP = 10,
	CTA_STATS_EARLY_DROP = 11,
	CTA_STATS_ERROR = 12,
	CTA_STATS_SEARCH_RESTART = 13,
	CTA_STATS_CLASH_RESOLVE = 14,
	CTA_STATS_CHAIN_TOOLONG = 15,
	__CTA_STATS_MAX = 16,
};

enum ctattr_stats_global {
	CTA_STATS_GLOBAL_UNSPEC = 0,
	CTA_STATS_GLOBAL_ENTRIES = 1,
	CTA_STATS_GLOBAL_MAX_ENTRIES = 2,
	__CTA_STATS_GLOBAL_MAX = 3,
};

enum ctattr_synproxy {
	CTA_SYNPROXY_UNSPEC = 0,
	CTA_SYNPROXY_ISN = 1,
	CTA_SYNPROXY_ITS = 2,
	CTA_SYNPROXY_TSOFF = 3,
	__CTA_SYNPROXY_MAX = 4,
};

enum ctattr_timeout {
	CTA_TIMEOUT_UNSPEC = 0,
	CTA_TIMEOUT_NAME = 1,
	CTA_TIMEOUT_L3PROTO = 2,
	CTA_TIMEOUT_L4PROTO = 3,
	CTA_TIMEOUT_DATA = 4,
	CTA_TIMEOUT_USE = 5,
	__CTA_TIMEOUT_MAX = 6,
};

enum ctattr_timeout_dccp {
	CTA_TIMEOUT_DCCP_UNSPEC = 0,
	CTA_TIMEOUT_DCCP_REQUEST = 1,
	CTA_TIMEOUT_DCCP_RESPOND = 2,
	CTA_TIMEOUT_DCCP_PARTOPEN = 3,
	CTA_TIMEOUT_DCCP_OPEN = 4,
	CTA_TIMEOUT_DCCP_CLOSEREQ = 5,
	CTA_TIMEOUT_DCCP_CLOSING = 6,
	CTA_TIMEOUT_DCCP_TIMEWAIT = 7,
	__CTA_TIMEOUT_DCCP_MAX = 8,
};

enum ctattr_timeout_generic {
	CTA_TIMEOUT_GENERIC_UNSPEC = 0,
	CTA_TIMEOUT_GENERIC_TIMEOUT = 1,
	__CTA_TIMEOUT_GENERIC_MAX = 2,
};

enum ctattr_timeout_gre {
	CTA_TIMEOUT_GRE_UNSPEC = 0,
	CTA_TIMEOUT_GRE_UNREPLIED = 1,
	CTA_TIMEOUT_GRE_REPLIED = 2,
	__CTA_TIMEOUT_GRE_MAX = 3,
};

enum ctattr_timeout_icmp {
	CTA_TIMEOUT_ICMP_UNSPEC = 0,
	CTA_TIMEOUT_ICMP_TIMEOUT = 1,
	__CTA_TIMEOUT_ICMP_MAX = 2,
};

enum ctattr_timeout_icmpv6 {
	CTA_TIMEOUT_ICMPV6_UNSPEC = 0,
	CTA_TIMEOUT_ICMPV6_TIMEOUT = 1,
	__CTA_TIMEOUT_ICMPV6_MAX = 2,
};

enum ctattr_timeout_sctp {
	CTA_TIMEOUT_SCTP_UNSPEC = 0,
	CTA_TIMEOUT_SCTP_CLOSED = 1,
	CTA_TIMEOUT_SCTP_COOKIE_WAIT = 2,
	CTA_TIMEOUT_SCTP_COOKIE_ECHOED = 3,
	CTA_TIMEOUT_SCTP_ESTABLISHED = 4,
	CTA_TIMEOUT_SCTP_SHUTDOWN_SENT = 5,
	CTA_TIMEOUT_SCTP_SHUTDOWN_RECD = 6,
	CTA_TIMEOUT_SCTP_SHUTDOWN_ACK_SENT = 7,
	CTA_TIMEOUT_SCTP_HEARTBEAT_SENT = 8,
	CTA_TIMEOUT_SCTP_HEARTBEAT_ACKED = 9,
	__CTA_TIMEOUT_SCTP_MAX = 10,
};

enum ctattr_timeout_tcp {
	CTA_TIMEOUT_TCP_UNSPEC = 0,
	CTA_TIMEOUT_TCP_SYN_SENT = 1,
	CTA_TIMEOUT_TCP_SYN_RECV = 2,
	CTA_TIMEOUT_TCP_ESTABLISHED = 3,
	CTA_TIMEOUT_TCP_FIN_WAIT = 4,
	CTA_TIMEOUT_TCP_CLOSE_WAIT = 5,
	CTA_TIMEOUT_TCP_LAST_ACK = 6,
	CTA_TIMEOUT_TCP_TIME_WAIT = 7,
	CTA_TIMEOUT_TCP_CLOSE = 8,
	CTA_TIMEOUT_TCP_SYN_SENT2 = 9,
	CTA_TIMEOUT_TCP_RETRANS = 10,
	CTA_TIMEOUT_TCP_UNACK = 11,
	__CTA_TIMEOUT_TCP_MAX = 12,
};

enum ctattr_timeout_udp {
	CTA_TIMEOUT_UDP_UNSPEC = 0,
	CTA_TIMEOUT_UDP_UNREPLIED = 1,
	CTA_TIMEOUT_UDP_REPLIED = 2,
	__CTA_TIMEOUT_UDP_MAX = 3,
};

enum ctattr_tstamp {
	CTA_TIMESTAMP_UNSPEC = 0,
	CTA_TIMESTAMP_START = 1,
	CTA_TIMESTAMP_STOP = 2,
	CTA_TIMESTAMP_PAD = 3,
	__CTA_TIMESTAMP_MAX = 4,
};

enum ctattr_tuple {
	CTA_TUPLE_UNSPEC = 0,
	CTA_TUPLE_IP = 1,
	CTA_TUPLE_PROTO = 2,
	CTA_TUPLE_ZONE = 3,
	__CTA_TUPLE_MAX = 4,
};

enum ctattr_type {
	CTA_UNSPEC = 0,
	CTA_TUPLE_ORIG = 1,
	CTA_TUPLE_REPLY = 2,
	CTA_STATUS = 3,
	CTA_PROTOINFO = 4,
	CTA_HELP = 5,
	CTA_NAT_SRC = 6,
	CTA_TIMEOUT = 7,
	CTA_MARK = 8,
	CTA_COUNTERS_ORIG = 9,
	CTA_COUNTERS_REPLY = 10,
	CTA_USE = 11,
	CTA_ID = 12,
	CTA_NAT_DST = 13,
	CTA_TUPLE_MASTER = 14,
	CTA_SEQ_ADJ_ORIG = 15,
	CTA_NAT_SEQ_ADJ_ORIG = 15,
	CTA_SEQ_ADJ_REPLY = 16,
	CTA_NAT_SEQ_ADJ_REPLY = 16,
	CTA_SECMARK = 17,
	CTA_ZONE = 18,
	CTA_SECCTX = 19,
	CTA_TIMESTAMP = 20,
	CTA_MARK_MASK = 21,
	CTA_LABELS = 22,
	CTA_LABELS_MASK = 23,
	CTA_SYNPROXY = 24,
	CTA_FILTER = 25,
	CTA_STATUS_MASK = 26,
	CTA_TIMESTAMP_EVENT = 27,
	__CTA_MAX = 28,
};

enum cti_port_type {
	CTI_PORT_TYPE_NONE = 0,
	CTI_PORT_TYPE_RS232 = 1,
	CTI_PORT_TYPE_RS422_485 = 2,
	CTI_PORT_TYPE_RS232_422_485_HW = 3,
	CTI_PORT_TYPE_RS232_422_485_SW = 4,
	CTI_PORT_TYPE_RS232_422_485_4B = 5,
	CTI_PORT_TYPE_RS232_422_485_2B = 6,
	CTI_PORT_TYPE_MAX = 7,
};

enum ctnl_exp_msg_types {
	IPCTNL_MSG_EXP_NEW = 0,
	IPCTNL_MSG_EXP_GET = 1,
	IPCTNL_MSG_EXP_DELETE = 2,
	IPCTNL_MSG_EXP_GET_STATS_CPU = 3,
	IPCTNL_MSG_EXP_MAX = 4,
};

enum ctnl_timeout_msg_types {
	IPCTNL_MSG_TIMEOUT_NEW = 0,
	IPCTNL_MSG_TIMEOUT_GET = 1,
	IPCTNL_MSG_TIMEOUT_DELETE = 2,
	IPCTNL_MSG_TIMEOUT_DEFAULT_SET = 3,
	IPCTNL_MSG_TIMEOUT_DEFAULT_GET = 4,
	IPCTNL_MSG_TIMEOUT_MAX = 5,
};

enum ctx_state {
	CT_STATE_DISABLED = -1,
	CT_STATE_KERNEL = 0,
	CT_STATE_IDLE = 1,
	CT_STATE_USER = 2,
	CT_STATE_GUEST = 3,
	CT_STATE_MAX = 4,
};

enum d_real_type {
	D_REAL_DATA = 0,
	D_REAL_METADATA = 1,
};

enum d_walk_ret {
	D_WALK_CONTINUE = 0,
	D_WALK_QUIT = 1,
	D_WALK_NORETRY = 2,
	D_WALK_SKIP = 3,
};

enum data_formats {
	DATA_FMT_DIGEST = 0,
	DATA_FMT_DIGEST_WITH_ALGO = 1,
	DATA_FMT_DIGEST_WITH_TYPE_AND_ALGO = 2,
	DATA_FMT_STRING = 3,
	DATA_FMT_HEX = 4,
	DATA_FMT_UINT = 5,
};

enum data_mode {
	DATA_MODE_SLAB = 0,
	DATA_MODE_KMALLOC = 1,
	DATA_MODE_GET_FREE_PAGES = 2,
	DATA_MODE_VMALLOC = 3,
	DATA_MODE_LIMIT = 4,
};

enum dax_access_mode {
	DAX_ACCESS = 0,
	DAX_RECOVERY_WRITE = 1,
};

enum dbgfs_get_mode {
	DBGFS_GET_ALREADY = 0,
	DBGFS_GET_REGULAR = 1,
	DBGFS_GET_SHORT = 2,
};

enum dbuf_slice {
	DBUF_S1 = 0,
	DBUF_S2 = 1,
	DBUF_S3 = 2,
	DBUF_S4 = 3,
	I915_MAX_DBUF_SLICES = 4,
};

enum dcb_general_attr_values {
	DCB_ATTR_VALUE_UNDEFINED = 255,
};

enum dcbevent_notif_type {
	DCB_APP_EVENT = 1,
};

enum dcbnl_app_attrs {
	DCB_APP_ATTR_UNDEFINED = 0,
	DCB_APP_ATTR_IDTYPE = 1,
	DCB_APP_ATTR_ID = 2,
	DCB_APP_ATTR_PRIORITY = 3,
	__DCB_APP_ATTR_ENUM_MAX = 4,
	DCB_APP_ATTR_MAX = 3,
};

enum dcbnl_attrs {
	DCB_ATTR_UNDEFINED = 0,
	DCB_ATTR_IFNAME = 1,
	DCB_ATTR_STATE = 2,
	DCB_ATTR_PFC_STATE = 3,
	DCB_ATTR_PFC_CFG = 4,
	DCB_ATTR_NUM_TC = 5,
	DCB_ATTR_PG_CFG = 6,
	DCB_ATTR_SET_ALL = 7,
	DCB_ATTR_PERM_HWADDR = 8,
	DCB_ATTR_CAP = 9,
	DCB_ATTR_NUMTCS = 10,
	DCB_ATTR_BCN = 11,
	DCB_ATTR_APP = 12,
	DCB_ATTR_IEEE = 13,
	DCB_ATTR_DCBX = 14,
	DCB_ATTR_FEATCFG = 15,
	DCB_ATTR_CEE = 16,
	__DCB_ATTR_ENUM_MAX = 17,
	DCB_ATTR_MAX = 16,
};

enum dcbnl_bcn_attrs {
	DCB_BCN_ATTR_UNDEFINED = 0,
	DCB_BCN_ATTR_RP_0 = 1,
	DCB_BCN_ATTR_RP_1 = 2,
	DCB_BCN_ATTR_RP_2 = 3,
	DCB_BCN_ATTR_RP_3 = 4,
	DCB_BCN_ATTR_RP_4 = 5,
	DCB_BCN_ATTR_RP_5 = 6,
	DCB_BCN_ATTR_RP_6 = 7,
	DCB_BCN_ATTR_RP_7 = 8,
	DCB_BCN_ATTR_RP_ALL = 9,
	DCB_BCN_ATTR_BCNA_0 = 10,
	DCB_BCN_ATTR_BCNA_1 = 11,
	DCB_BCN_ATTR_ALPHA = 12,
	DCB_BCN_ATTR_BETA = 13,
	DCB_BCN_ATTR_GD = 14,
	DCB_BCN_ATTR_GI = 15,
	DCB_BCN_ATTR_TMAX = 16,
	DCB_BCN_ATTR_TD = 17,
	DCB_BCN_ATTR_RMIN = 18,
	DCB_BCN_ATTR_W = 19,
	DCB_BCN_ATTR_RD = 20,
	DCB_BCN_ATTR_RU = 21,
	DCB_BCN_ATTR_WRTT = 22,
	DCB_BCN_ATTR_RI = 23,
	DCB_BCN_ATTR_C = 24,
	DCB_BCN_ATTR_ALL = 25,
	__DCB_BCN_ATTR_ENUM_MAX = 26,
	DCB_BCN_ATTR_MAX = 25,
};

enum dcbnl_cap_attrs {
	DCB_CAP_ATTR_UNDEFINED = 0,
	DCB_CAP_ATTR_ALL = 1,
	DCB_CAP_ATTR_PG = 2,
	DCB_CAP_ATTR_PFC = 3,
	DCB_CAP_ATTR_UP2TC = 4,
	DCB_CAP_ATTR_PG_TCS = 5,
	DCB_CAP_ATTR_PFC_TCS = 6,
	DCB_CAP_ATTR_GSP = 7,
	DCB_CAP_ATTR_BCN = 8,
	DCB_CAP_ATTR_DCBX = 9,
	__DCB_CAP_ATTR_ENUM_MAX = 10,
	DCB_CAP_ATTR_MAX = 9,
};

enum dcbnl_commands {
	DCB_CMD_UNDEFINED = 0,
	DCB_CMD_GSTATE = 1,
	DCB_CMD_SSTATE = 2,
	DCB_CMD_PGTX_GCFG = 3,
	DCB_CMD_PGTX_SCFG = 4,
	DCB_CMD_PGRX_GCFG = 5,
	DCB_CMD_PGRX_SCFG = 6,
	DCB_CMD_PFC_GCFG = 7,
	DCB_CMD_PFC_SCFG = 8,
	DCB_CMD_SET_ALL = 9,
	DCB_CMD_GPERM_HWADDR = 10,
	DCB_CMD_GCAP = 11,
	DCB_CMD_GNUMTCS = 12,
	DCB_CMD_SNUMTCS = 13,
	DCB_CMD_PFC_GSTATE = 14,
	DCB_CMD_PFC_SSTATE = 15,
	DCB_CMD_BCN_GCFG = 16,
	DCB_CMD_BCN_SCFG = 17,
	DCB_CMD_GAPP = 18,
	DCB_CMD_SAPP = 19,
	DCB_CMD_IEEE_SET = 20,
	DCB_CMD_IEEE_GET = 21,
	DCB_CMD_GDCBX = 22,
	DCB_CMD_SDCBX = 23,
	DCB_CMD_GFEATCFG = 24,
	DCB_CMD_SFEATCFG = 25,
	DCB_CMD_CEE_GET = 26,
	DCB_CMD_IEEE_DEL = 27,
	__DCB_CMD_ENUM_MAX = 28,
	DCB_CMD_MAX = 27,
};

enum dcbnl_featcfg_attrs {
	DCB_FEATCFG_ATTR_UNDEFINED = 0,
	DCB_FEATCFG_ATTR_ALL = 1,
	DCB_FEATCFG_ATTR_PG = 2,
	DCB_FEATCFG_ATTR_PFC = 3,
	DCB_FEATCFG_ATTR_APP = 4,
	__DCB_FEATCFG_ATTR_ENUM_MAX = 5,
	DCB_FEATCFG_ATTR_MAX = 4,
};

enum dcbnl_numtcs_attrs {
	DCB_NUMTCS_ATTR_UNDEFINED = 0,
	DCB_NUMTCS_ATTR_ALL = 1,
	DCB_NUMTCS_ATTR_PG = 2,
	DCB_NUMTCS_ATTR_PFC = 3,
	__DCB_NUMTCS_ATTR_ENUM_MAX = 4,
	DCB_NUMTCS_ATTR_MAX = 3,
};

enum dcbnl_pfc_up_attrs {
	DCB_PFC_UP_ATTR_UNDEFINED = 0,
	DCB_PFC_UP_ATTR_0 = 1,
	DCB_PFC_UP_ATTR_1 = 2,
	DCB_PFC_UP_ATTR_2 = 3,
	DCB_PFC_UP_ATTR_3 = 4,
	DCB_PFC_UP_ATTR_4 = 5,
	DCB_PFC_UP_ATTR_5 = 6,
	DCB_PFC_UP_ATTR_6 = 7,
	DCB_PFC_UP_ATTR_7 = 8,
	DCB_PFC_UP_ATTR_ALL = 9,
	__DCB_PFC_UP_ATTR_ENUM_MAX = 10,
	DCB_PFC_UP_ATTR_MAX = 9,
};

enum dcbnl_pg_attrs {
	DCB_PG_ATTR_UNDEFINED = 0,
	DCB_PG_ATTR_TC_0 = 1,
	DCB_PG_ATTR_TC_1 = 2,
	DCB_PG_ATTR_TC_2 = 3,
	DCB_PG_ATTR_TC_3 = 4,
	DCB_PG_ATTR_TC_4 = 5,
	DCB_PG_ATTR_TC_5 = 6,
	DCB_PG_ATTR_TC_6 = 7,
	DCB_PG_ATTR_TC_7 = 8,
	DCB_PG_ATTR_TC_MAX = 9,
	DCB_PG_ATTR_TC_ALL = 10,
	DCB_PG_ATTR_BW_ID_0 = 11,
	DCB_PG_ATTR_BW_ID_1 = 12,
	DCB_PG_ATTR_BW_ID_2 = 13,
	DCB_PG_ATTR_BW_ID_3 = 14,
	DCB_PG_ATTR_BW_ID_4 = 15,
	DCB_PG_ATTR_BW_ID_5 = 16,
	DCB_PG_ATTR_BW_ID_6 = 17,
	DCB_PG_ATTR_BW_ID_7 = 18,
	DCB_PG_ATTR_BW_ID_MAX = 19,
	DCB_PG_ATTR_BW_ID_ALL = 20,
	__DCB_PG_ATTR_ENUM_MAX = 21,
	DCB_PG_ATTR_MAX = 20,
};

enum dcbnl_tc_attrs {
	DCB_TC_ATTR_PARAM_UNDEFINED = 0,
	DCB_TC_ATTR_PARAM_PGID = 1,
	DCB_TC_ATTR_PARAM_UP_MAPPING = 2,
	DCB_TC_ATTR_PARAM_STRICT_PRIO = 3,
	DCB_TC_ATTR_PARAM_BW_PCT = 4,
	DCB_TC_ATTR_PARAM_ALL = 5,
	__DCB_TC_ATTR_PARAM_ENUM_MAX = 6,
	DCB_TC_ATTR_PARAM_MAX = 5,
};

enum dccp_ackvec_states {
	DCCPAV_RECEIVED = 0,
	DCCPAV_ECN_MARKED = 64,
	DCCPAV_RESERVED = 128,
	DCCPAV_NOT_RECEIVED = 192,
};

enum dccp_cmsg_type {
	DCCP_SCM_PRIORITY = 1,
	DCCP_SCM_QPOLICY_MAX = 65535,
	DCCP_SCM_MAX = 65536,
};

enum dccp_feat_state {
	FEAT_DEFAULT = 0,
	FEAT_INITIALISING = 1,
	FEAT_CHANGING = 2,
	FEAT_UNSTABLE = 3,
	FEAT_STABLE = 4,
};

enum dccp_feat_type {
	FEAT_AT_RX = 1,
	FEAT_AT_TX = 2,
	FEAT_SP = 4,
	FEAT_NN = 8,
	FEAT_UNKNOWN = 255,
};

enum dccp_feature_numbers {
	DCCPF_RESERVED = 0,
	DCCPF_CCID = 1,
	DCCPF_SHORT_SEQNOS = 2,
	DCCPF_SEQUENCE_WINDOW = 3,
	DCCPF_ECN_INCAPABLE = 4,
	DCCPF_ACK_RATIO = 5,
	DCCPF_SEND_ACK_VECTOR = 6,
	DCCPF_SEND_NDP_COUNT = 7,
	DCCPF_MIN_CSUM_COVER = 8,
	DCCPF_DATA_CHECKSUM = 9,
	DCCPF_MIN_CCID_SPECIFIC = 128,
	DCCPF_SEND_LEV_RATE = 192,
	DCCPF_MAX_CCID_SPECIFIC = 255,
};

enum dccp_packet_dequeueing_policy {
	DCCPQ_POLICY_SIMPLE = 0,
	DCCPQ_POLICY_PRIO = 1,
	DCCPQ_POLICY_MAX = 2,
};

enum dccp_pkt_type {
	DCCP_PKT_REQUEST = 0,
	DCCP_PKT_RESPONSE = 1,
	DCCP_PKT_DATA = 2,
	DCCP_PKT_ACK = 3,
	DCCP_PKT_DATAACK = 4,
	DCCP_PKT_CLOSEREQ = 5,
	DCCP_PKT_CLOSE = 6,
	DCCP_PKT_RESET = 7,
	DCCP_PKT_SYNC = 8,
	DCCP_PKT_SYNCACK = 9,
	DCCP_PKT_INVALID = 10,
};

enum dccp_reset_codes {
	DCCP_RESET_CODE_UNSPECIFIED = 0,
	DCCP_RESET_CODE_CLOSED = 1,
	DCCP_RESET_CODE_ABORTED = 2,
	DCCP_RESET_CODE_NO_CONNECTION = 3,
	DCCP_RESET_CODE_PACKET_ERROR = 4,
	DCCP_RESET_CODE_OPTION_ERROR = 5,
	DCCP_RESET_CODE_MANDATORY_ERROR = 6,
	DCCP_RESET_CODE_CONNECTION_REFUSED = 7,
	DCCP_RESET_CODE_BAD_SERVICE_CODE = 8,
	DCCP_RESET_CODE_TOO_BUSY = 9,
	DCCP_RESET_CODE_BAD_INIT_COOKIE = 10,
	DCCP_RESET_CODE_AGGRESSION_PENALTY = 11,
	DCCP_MAX_RESET_CODES = 12,
};

enum dccp_role {
	DCCP_ROLE_UNDEFINED = 0,
	DCCP_ROLE_LISTEN = 1,
	DCCP_ROLE_CLIENT = 2,
	DCCP_ROLE_SERVER = 3,
};

enum dccp_state {
	DCCP_OPEN = 1,
	DCCP_REQUESTING = 2,
	DCCP_LISTEN = 10,
	DCCP_RESPOND = 3,
	DCCP_ACTIVE_CLOSEREQ = 4,
	DCCP_PASSIVE_CLOSE = 8,
	DCCP_CLOSING = 11,
	DCCP_TIME_WAIT = 6,
	DCCP_CLOSED = 7,
	DCCP_NEW_SYN_RECV = 12,
	DCCP_PARTOPEN = 14,
	DCCP_PASSIVE_CLOSEREQ = 15,
	DCCP_MAX_STATES = 16,
};

enum dd_data_dir {
	DD_READ = 0,
	DD_WRITE = 1,
};

enum dd_prio {
	DD_RT_PRIO = 0,
	DD_BE_PRIO = 1,
	DD_IDLE_PRIO = 2,
	DD_PRIO_MAX = 2,
};

enum dentry_d_lock_class {
	DENTRY_D_LOCK_NORMAL = 0,
	DENTRY_D_LOCK_NESTED = 1,
};

enum depot_counter_id {
	DEPOT_COUNTER_REFD_ALLOCS = 0,
	DEPOT_COUNTER_REFD_FREES = 1,
	DEPOT_COUNTER_REFD_INUSE = 2,
	DEPOT_COUNTER_FREELIST_SIZE = 3,
	DEPOT_COUNTER_PERSIST_COUNT = 4,
	DEPOT_COUNTER_PERSIST_BYTES = 5,
	DEPOT_COUNTER_COUNT = 6,
};

enum desc_state {
	desc_miss = -1,
	desc_reserved = 0,
	desc_committed = 1,
	desc_finalized = 2,
	desc_reusable = 3,
};

enum dev_dma_attr {
	DEV_DMA_NOT_SUPPORTED = 0,
	DEV_DMA_NON_COHERENT = 1,
	DEV_DMA_COHERENT = 2,
};

enum dev_pm_qos_req_type {
	DEV_PM_QOS_RESUME_LATENCY = 1,
	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
	DEV_PM_QOS_MIN_FREQUENCY = 3,
	DEV_PM_QOS_MAX_FREQUENCY = 4,
	DEV_PM_QOS_FLAGS = 5,
};

enum dev_prop_type {
	DEV_PROP_U8 = 0,
	DEV_PROP_U16 = 1,
	DEV_PROP_U32 = 2,
	DEV_PROP_U64 = 3,
	DEV_PROP_STRING = 4,
	DEV_PROP_REF = 5,
};

enum devcg_behavior {
	DEVCG_DEFAULT_NONE = 0,
	DEVCG_DEFAULT_ALLOW = 1,
	DEVCG_DEFAULT_DENY = 2,
};

enum device_link_state {
	DL_STATE_NONE = -1,
	DL_STATE_DORMANT = 0,
	DL_STATE_AVAILABLE = 1,
	DL_STATE_CONSUMER_PROBE = 2,
	DL_STATE_ACTIVE = 3,
	DL_STATE_SUPPLIER_UNBIND = 4,
};

enum device_physical_location_horizontal_position {
	DEVICE_HORI_POS_LEFT = 0,
	DEVICE_HORI_POS_CENTER = 1,
	DEVICE_HORI_POS_RIGHT = 2,
};

enum device_physical_location_panel {
	DEVICE_PANEL_TOP = 0,
	DEVICE_PANEL_BOTTOM = 1,
	DEVICE_PANEL_LEFT = 2,
	DEVICE_PANEL_RIGHT = 3,
	DEVICE_PANEL_FRONT = 4,
	DEVICE_PANEL_BACK = 5,
	DEVICE_PANEL_UNKNOWN = 6,
};

enum device_physical_location_vertical_position {
	DEVICE_VERT_POS_UPPER = 0,
	DEVICE_VERT_POS_CENTER = 1,
	DEVICE_VERT_POS_LOWER = 2,
};

enum device_removable {
	DEVICE_REMOVABLE_NOT_SUPPORTED = 0,
	DEVICE_REMOVABLE_UNKNOWN = 1,
	DEVICE_FIXED = 2,
	DEVICE_REMOVABLE = 3,
};

enum devkmsg_log_bits {
	__DEVKMSG_LOG_BIT_ON = 0,
	__DEVKMSG_LOG_BIT_OFF = 1,
	__DEVKMSG_LOG_BIT_LOCK = 2,
};

enum devkmsg_log_masks {
	DEVKMSG_LOG_MASK_ON = 1,
	DEVKMSG_LOG_MASK_OFF = 2,
	DEVKMSG_LOG_MASK_LOCK = 4,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
	DEVLINK_PORT_FLAVOUR_CPU = 1,
	DEVLINK_PORT_FLAVOUR_DSA = 2,
	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
	DEVLINK_PORT_FLAVOUR_VIRTUAL = 5,
	DEVLINK_PORT_FLAVOUR_UNUSED = 6,
	DEVLINK_PORT_FLAVOUR_PCI_SF = 7,
};

enum devlink_port_fn_opstate {
	DEVLINK_PORT_FN_OPSTATE_DETACHED = 0,
	DEVLINK_PORT_FN_OPSTATE_ATTACHED = 1,
};

enum devlink_port_fn_state {
	DEVLINK_PORT_FN_STATE_INACTIVE = 0,
	DEVLINK_PORT_FN_STATE_ACTIVE = 1,
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET = 0,
	DEVLINK_PORT_TYPE_AUTO = 1,
	DEVLINK_PORT_TYPE_ETH = 2,
	DEVLINK_PORT_TYPE_IB = 3,
};

enum devlink_rate_type {
	DEVLINK_RATE_TYPE_LEAF = 0,
	DEVLINK_RATE_TYPE_NODE = 1,
};

enum devm_ioremap_type {
	DEVM_IOREMAP = 0,
	DEVM_IOREMAP_UC = 1,
	DEVM_IOREMAP_WC = 2,
	DEVM_IOREMAP_NP = 3,
};

enum die_val {
	DIE_OOPS = 1,
	DIE_INT3 = 2,
	DIE_DEBUG = 3,
	DIE_PANIC = 4,
	DIE_NMI = 5,
	DIE_DIE = 6,
	DIE_KERNELDEBUG = 7,
	DIE_TRAP = 8,
	DIE_GPF = 9,
	DIE_CALL = 10,
	DIE_PAGE_FAULT = 11,
	DIE_NMIUNKNOWN = 12,
};

enum digest_type {
	DIGEST_TYPE_IMA = 0,
	DIGEST_TYPE_VERITY = 1,
	DIGEST_TYPE__LAST = 2,
};

enum dim_cq_period_mode {
	DIM_CQ_PERIOD_MODE_START_FROM_EQE = 0,
	DIM_CQ_PERIOD_MODE_START_FROM_CQE = 1,
	DIM_CQ_PERIOD_NUM_MODES = 2,
};

enum dim_state {
	DIM_START_MEASURE = 0,
	DIM_MEASURE_IN_PROGRESS = 1,
	DIM_APPLY_NEW_PROFILE = 2,
};

enum dim_stats_state {
	DIM_STATS_WORSE = 0,
	DIM_STATS_SAME = 1,
	DIM_STATS_BETTER = 2,
};

enum dim_step_result {
	DIM_STEPPED = 0,
	DIM_TOO_TIRED = 1,
	DIM_ON_EDGE = 2,
};

enum dim_tune_state {
	DIM_PARKING_ON_TOP = 0,
	DIM_PARKING_TIRED = 1,
	DIM_GOING_RIGHT = 2,
	DIM_GOING_LEFT = 3,
};

enum dl_bw_request {
	dl_bw_req_deactivate = 0,
	dl_bw_req_alloc = 1,
	dl_bw_req_free = 2,
};

enum dl_dev_state {
	DL_DEV_NO_DRIVER = 0,
	DL_DEV_PROBING = 1,
	DL_DEV_DRIVER_BOUND = 2,
	DL_DEV_UNBINDING = 3,
};

enum dl_param {
	DL_RUNTIME = 0,
	DL_PERIOD = 1,
};

enum dm_io_mem_type {
	DM_IO_PAGE_LIST = 0,
	DM_IO_BIO = 1,
	DM_IO_VMA = 2,
	DM_IO_KMEM = 3,
};

enum dm_queue_mode {
	DM_TYPE_NONE = 0,
	DM_TYPE_BIO_BASED = 1,
	DM_TYPE_REQUEST_BASED = 2,
	DM_TYPE_DAX_BIO_BASED = 3,
};

enum dm_raid1_error {
	DM_RAID1_WRITE_ERROR = 0,
	DM_RAID1_FLUSH_ERROR = 1,
	DM_RAID1_SYNC_ERROR = 2,
	DM_RAID1_READ_ERROR = 3,
};

enum dm_rh_region_states {
	DM_RH_CLEAN = 1,
	DM_RH_DIRTY = 2,
	DM_RH_NOSYNC = 4,
	DM_RH_RECOVERING = 8,
};

enum dma_ctrl_flags {
	DMA_PREP_INTERRUPT = 1,
	DMA_CTRL_ACK = 2,
	DMA_PREP_PQ_DISABLE_P = 4,
	DMA_PREP_PQ_DISABLE_Q = 8,
	DMA_PREP_CONTINUE = 16,
	DMA_PREP_FENCE = 32,
	DMA_CTRL_REUSE = 64,
	DMA_PREP_CMD = 128,
	DMA_PREP_REPEAT = 256,
	DMA_PREP_LOAD_EOT = 512,
};

enum dma_data_direction {
	DMA_BIDIRECTIONAL = 0,
	DMA_TO_DEVICE = 1,
	DMA_FROM_DEVICE = 2,
	DMA_NONE = 3,
};

enum dma_desc_metadata_mode {
	DESC_METADATA_NONE = 0,
	DESC_METADATA_CLIENT = 1,
	DESC_METADATA_ENGINE = 2,
};

enum dma_fence_flag_bits {
	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
	DMA_FENCE_FLAG_USER_BITS = 3,
};

enum dma_residue_granularity {
	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
	DMA_RESIDUE_GRANULARITY_BURST = 2,
};

enum dma_resv_usage {
	DMA_RESV_USAGE_KERNEL = 0,
	DMA_RESV_USAGE_WRITE = 1,
	DMA_RESV_USAGE_READ = 2,
	DMA_RESV_USAGE_BOOKKEEP = 3,
};

enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
	DMA_SLAVE_BUSWIDTH_128_BYTES = 128,
};

enum dma_status {
	DMA_COMPLETE = 0,
	DMA_IN_PROGRESS = 1,
	DMA_PAUSED = 2,
	DMA_ERROR = 3,
	DMA_OUT_OF_ORDER = 4,
};

enum dma_transaction_type {
	DMA_MEMCPY = 0,
	DMA_XOR = 1,
	DMA_PQ = 2,
	DMA_XOR_VAL = 3,
	DMA_PQ_VAL = 4,
	DMA_MEMSET = 5,
	DMA_MEMSET_SG = 6,
	DMA_INTERRUPT = 7,
	DMA_PRIVATE = 8,
	DMA_ASYNC_TX = 9,
	DMA_SLAVE = 10,
	DMA_CYCLIC = 11,
	DMA_INTERLEAVE = 12,
	DMA_COMPLETION_NO_ORDER = 13,
	DMA_REPEAT = 14,
	DMA_LOAD_EOT = 15,
	DMA_TX_TYPE_END = 16,
};

enum dma_transfer_direction {
	DMA_MEM_TO_MEM = 0,
	DMA_MEM_TO_DEV = 1,
	DMA_DEV_TO_MEM = 2,
	DMA_DEV_TO_DEV = 3,
	DMA_TRANS_NONE = 4,
};

enum dmaengine_alignment {
	DMAENGINE_ALIGN_1_BYTE = 0,
	DMAENGINE_ALIGN_2_BYTES = 1,
	DMAENGINE_ALIGN_4_BYTES = 2,
	DMAENGINE_ALIGN_8_BYTES = 3,
	DMAENGINE_ALIGN_16_BYTES = 4,
	DMAENGINE_ALIGN_32_BYTES = 5,
	DMAENGINE_ALIGN_64_BYTES = 6,
	DMAENGINE_ALIGN_128_BYTES = 7,
	DMAENGINE_ALIGN_256_BYTES = 8,
};

enum dmaengine_tx_result {
	DMA_TRANS_NOERROR = 0,
	DMA_TRANS_READ_FAILED = 1,
	DMA_TRANS_WRITE_FAILED = 2,
	DMA_TRANS_ABORTED = 3,
};

enum dmi_device_type {
	DMI_DEV_TYPE_ANY = 0,
	DMI_DEV_TYPE_OTHER = 1,
	DMI_DEV_TYPE_UNKNOWN = 2,
	DMI_DEV_TYPE_VIDEO = 3,
	DMI_DEV_TYPE_SCSI = 4,
	DMI_DEV_TYPE_ETHERNET = 5,
	DMI_DEV_TYPE_TOKENRING = 6,
	DMI_DEV_TYPE_SOUND = 7,
	DMI_DEV_TYPE_PATA = 8,
	DMI_DEV_TYPE_SATA = 9,
	DMI_DEV_TYPE_SAS = 10,
	DMI_DEV_TYPE_IPMI = -1,
	DMI_DEV_TYPE_OEM_STRING = -2,
	DMI_DEV_TYPE_DEV_ONBOARD = -3,
	DMI_DEV_TYPE_DEV_SLOT = -4,
};

enum dmi_entry_type {
	DMI_ENTRY_BIOS = 0,
	DMI_ENTRY_SYSTEM = 1,
	DMI_ENTRY_BASEBOARD = 2,
	DMI_ENTRY_CHASSIS = 3,
	DMI_ENTRY_PROCESSOR = 4,
	DMI_ENTRY_MEM_CONTROLLER = 5,
	DMI_ENTRY_MEM_MODULE = 6,
	DMI_ENTRY_CACHE = 7,
	DMI_ENTRY_PORT_CONNECTOR = 8,
	DMI_ENTRY_SYSTEM_SLOT = 9,
	DMI_ENTRY_ONBOARD_DEVICE = 10,
	DMI_ENTRY_OEMSTRINGS = 11,
	DMI_ENTRY_SYSCONF = 12,
	DMI_ENTRY_BIOS_LANG = 13,
	DMI_ENTRY_GROUP_ASSOC = 14,
	DMI_ENTRY_SYSTEM_EVENT_LOG = 15,
	DMI_ENTRY_PHYS_MEM_ARRAY = 16,
	DMI_ENTRY_MEM_DEVICE = 17,
	DMI_ENTRY_32_MEM_ERROR = 18,
	DMI_ENTRY_MEM_ARRAY_MAPPED_ADDR = 19,
	DMI_ENTRY_MEM_DEV_MAPPED_ADDR = 20,
	DMI_ENTRY_BUILTIN_POINTING_DEV = 21,
	DMI_ENTRY_PORTABLE_BATTERY = 22,
	DMI_ENTRY_SYSTEM_RESET = 23,
	DMI_ENTRY_HW_SECURITY = 24,
	DMI_ENTRY_SYSTEM_POWER_CONTROLS = 25,
	DMI_ENTRY_VOLTAGE_PROBE = 26,
	DMI_ENTRY_COOLING_DEV = 27,
	DMI_ENTRY_TEMP_PROBE = 28,
	DMI_ENTRY_ELECTRICAL_CURRENT_PROBE = 29,
	DMI_ENTRY_OOB_REMOTE_ACCESS = 30,
	DMI_ENTRY_BIS_ENTRY = 31,
	DMI_ENTRY_SYSTEM_BOOT = 32,
	DMI_ENTRY_MGMT_DEV = 33,
	DMI_ENTRY_MGMT_DEV_COMPONENT = 34,
	DMI_ENTRY_MGMT_DEV_THRES = 35,
	DMI_ENTRY_MEM_CHANNEL = 36,
	DMI_ENTRY_IPMI_DEV = 37,
	DMI_ENTRY_SYS_POWER_SUPPLY = 38,
	DMI_ENTRY_ADDITIONAL = 39,
	DMI_ENTRY_ONBOARD_DEV_EXT = 40,
	DMI_ENTRY_MGMT_CONTROLLER_HOST = 41,
	DMI_ENTRY_INACTIVE = 126,
	DMI_ENTRY_END_OF_TABLE = 127,
};

enum dmi_field {
	DMI_NONE = 0,
	DMI_BIOS_VENDOR = 1,
	DMI_BIOS_VERSION = 2,
	DMI_BIOS_DATE = 3,
	DMI_BIOS_RELEASE = 4,
	DMI_EC_FIRMWARE_RELEASE = 5,
	DMI_SYS_VENDOR = 6,
	DMI_PRODUCT_NAME = 7,
	DMI_PRODUCT_VERSION = 8,
	DMI_PRODUCT_SERIAL = 9,
	DMI_PRODUCT_UUID = 10,
	DMI_PRODUCT_SKU = 11,
	DMI_PRODUCT_FAMILY = 12,
	DMI_BOARD_VENDOR = 13,
	DMI_BOARD_NAME = 14,
	DMI_BOARD_VERSION = 15,
	DMI_BOARD_SERIAL = 16,
	DMI_BOARD_ASSET_TAG = 17,
	DMI_CHASSIS_VENDOR = 18,
	DMI_CHASSIS_TYPE = 19,
	DMI_CHASSIS_VERSION = 20,
	DMI_CHASSIS_SERIAL = 21,
	DMI_CHASSIS_ASSET_TAG = 22,
	DMI_STRING_MAX = 23,
	DMI_OEM_STRING = 24,
};

enum dns_lookup_status {
	DNS_LOOKUP_NOT_DONE = 0,
	DNS_LOOKUP_GOOD = 1,
	DNS_LOOKUP_GOOD_WITH_BAD = 2,
	DNS_LOOKUP_BAD = 3,
	DNS_LOOKUP_GOT_NOT_FOUND = 4,
	DNS_LOOKUP_GOT_LOCAL_FAILURE = 5,
	DNS_LOOKUP_GOT_TEMP_FAILURE = 6,
	DNS_LOOKUP_GOT_NS_FAILURE = 7,
	NR__dns_lookup_status = 8,
};

enum dns_payload_content_type {
	DNS_PAYLOAD_IS_SERVER_LIST = 0,
};

enum dock_callback_type {
	DOCK_CALL_HANDLER = 0,
	DOCK_CALL_FIXUP = 1,
	DOCK_CALL_UEVENT = 2,
};

enum dp_colorimetry {
	DP_COLORIMETRY_DEFAULT = 0,
	DP_COLORIMETRY_RGB_WIDE_FIXED = 1,
	DP_COLORIMETRY_BT709_YCC = 1,
	DP_COLORIMETRY_RGB_WIDE_FLOAT = 2,
	DP_COLORIMETRY_XVYCC_601 = 2,
	DP_COLORIMETRY_OPRGB = 3,
	DP_COLORIMETRY_XVYCC_709 = 3,
	DP_COLORIMETRY_DCI_P3_RGB = 4,
	DP_COLORIMETRY_SYCC_601 = 4,
	DP_COLORIMETRY_RGB_CUSTOM = 5,
	DP_COLORIMETRY_OPYCC_601 = 5,
	DP_COLORIMETRY_BT2020_RGB = 6,
	DP_COLORIMETRY_BT2020_CYCC = 6,
	DP_COLORIMETRY_BT2020_YCC = 7,
};

enum dp_content_type {
	DP_CONTENT_TYPE_NOT_DEFINED = 0,
	DP_CONTENT_TYPE_GRAPHICS = 1,
	DP_CONTENT_TYPE_PHOTO = 2,
	DP_CONTENT_TYPE_VIDEO = 3,
	DP_CONTENT_TYPE_GAME = 4,
};

enum dp_dynamic_range {
	DP_DYNAMIC_RANGE_VESA = 0,
	DP_DYNAMIC_RANGE_CTA = 1,
};

enum dp_pixelformat {
	DP_PIXELFORMAT_RGB = 0,
	DP_PIXELFORMAT_YUV444 = 1,
	DP_PIXELFORMAT_YUV422 = 2,
	DP_PIXELFORMAT_YUV420 = 3,
	DP_PIXELFORMAT_Y_ONLY = 4,
	DP_PIXELFORMAT_RAW = 5,
	DP_PIXELFORMAT_RESERVED = 6,
};

enum dpio_channel {
	DPIO_CH0 = 0,
	DPIO_CH1 = 1,
};

enum dpio_phy {
	DPIO_PHY0 = 0,
	DPIO_PHY1 = 1,
	DPIO_PHY2 = 2,
};

enum dpm_order {
	DPM_ORDER_NONE = 0,
	DPM_ORDER_DEV_AFTER_PARENT = 1,
	DPM_ORDER_PARENT_BEFORE_DEV = 2,
	DPM_ORDER_DEV_LAST = 3,
};

enum drbg_prefixes {
	DRBG_PREFIX0 = 0,
	DRBG_PREFIX1 = 1,
	DRBG_PREFIX2 = 2,
	DRBG_PREFIX3 = 3,
};

enum drbg_seed_state {
	DRBG_SEED_STATE_UNSEEDED = 0,
	DRBG_SEED_STATE_PARTIAL = 1,
	DRBG_SEED_STATE_FULL = 2,
};

enum drm_bridge_attach_flags {
	DRM_BRIDGE_ATTACH_NO_CONNECTOR = 1,
};

enum drm_bridge_ops {
	DRM_BRIDGE_OP_DETECT = 1,
	DRM_BRIDGE_OP_EDID = 2,
	DRM_BRIDGE_OP_HPD = 4,
	DRM_BRIDGE_OP_MODES = 8,
	DRM_BRIDGE_OP_HDMI = 16,
};

enum drm_color_encoding {
	DRM_COLOR_YCBCR_BT601 = 0,
	DRM_COLOR_YCBCR_BT709 = 1,
	DRM_COLOR_YCBCR_BT2020 = 2,
	DRM_COLOR_ENCODING_MAX = 3,
};

enum drm_color_lut_tests {
	DRM_COLOR_LUT_EQUAL_CHANNELS = 1,
	DRM_COLOR_LUT_NON_DECREASING = 2,
};

enum drm_color_range {
	DRM_COLOR_YCBCR_LIMITED_RANGE = 0,
	DRM_COLOR_YCBCR_FULL_RANGE = 1,
	DRM_COLOR_RANGE_MAX = 2,
};

enum drm_colorspace {
	DRM_MODE_COLORIMETRY_DEFAULT = 0,
	DRM_MODE_COLORIMETRY_NO_DATA = 0,
	DRM_MODE_COLORIMETRY_SMPTE_170M_YCC = 1,
	DRM_MODE_COLORIMETRY_BT709_YCC = 2,
	DRM_MODE_COLORIMETRY_XVYCC_601 = 3,
	DRM_MODE_COLORIMETRY_XVYCC_709 = 4,
	DRM_MODE_COLORIMETRY_SYCC_601 = 5,
	DRM_MODE_COLORIMETRY_OPYCC_601 = 6,
	DRM_MODE_COLORIMETRY_OPRGB = 7,
	DRM_MODE_COLORIMETRY_BT2020_CYCC = 8,
	DRM_MODE_COLORIMETRY_BT2020_RGB = 9,
	DRM_MODE_COLORIMETRY_BT2020_YCC = 10,
	DRM_MODE_COLORIMETRY_DCI_P3_RGB_D65 = 11,
	DRM_MODE_COLORIMETRY_DCI_P3_RGB_THEATER = 12,
	DRM_MODE_COLORIMETRY_RGB_WIDE_FIXED = 13,
	DRM_MODE_COLORIMETRY_RGB_WIDE_FLOAT = 14,
	DRM_MODE_COLORIMETRY_BT601_YCC = 15,
	DRM_MODE_COLORIMETRY_COUNT = 16,
};

enum drm_connector_force {
	DRM_FORCE_UNSPECIFIED = 0,
	DRM_FORCE_OFF = 1,
	DRM_FORCE_ON = 2,
	DRM_FORCE_ON_DIGITAL = 3,
};

enum drm_connector_registration_state {
	DRM_CONNECTOR_INITIALIZING = 0,
	DRM_CONNECTOR_REGISTERED = 1,
	DRM_CONNECTOR_UNREGISTERED = 2,
};

enum drm_connector_status {
	connector_status_connected = 1,
	connector_status_disconnected = 2,
	connector_status_unknown = 3,
};

enum drm_connector_tv_mode {
	DRM_MODE_TV_MODE_NTSC = 0,
	DRM_MODE_TV_MODE_NTSC_443 = 1,
	DRM_MODE_TV_MODE_NTSC_J = 2,
	DRM_MODE_TV_MODE_PAL = 3,
	DRM_MODE_TV_MODE_PAL_M = 4,
	DRM_MODE_TV_MODE_PAL_N = 5,
	DRM_MODE_TV_MODE_SECAM = 6,
	DRM_MODE_TV_MODE_MONOCHROME = 7,
	DRM_MODE_TV_MODE_MAX = 8,
};

enum drm_debug_category {
	DRM_UT_CORE = 0,
	DRM_UT_DRIVER = 1,
	DRM_UT_KMS = 2,
	DRM_UT_PRIME = 3,
	DRM_UT_ATOMIC = 4,
	DRM_UT_VBL = 5,
	DRM_UT_STATE = 6,
	DRM_UT_LEASE = 7,
	DRM_UT_DP = 8,
	DRM_UT_DRMRES = 9,
};

enum drm_dp_dual_mode_type {
	DRM_DP_DUAL_MODE_NONE = 0,
	DRM_DP_DUAL_MODE_UNKNOWN = 1,
	DRM_DP_DUAL_MODE_TYPE1_DVI = 2,
	DRM_DP_DUAL_MODE_TYPE1_HDMI = 3,
	DRM_DP_DUAL_MODE_TYPE2_DVI = 4,
	DRM_DP_DUAL_MODE_TYPE2_HDMI = 5,
	DRM_DP_DUAL_MODE_LSPCON = 6,
};

enum drm_dp_mst_mode {
	DRM_DP_SST = 0,
	DRM_DP_MST = 1,
	DRM_DP_SST_SIDEBAND_MSG = 2,
};

enum drm_dp_mst_payload_allocation {
	DRM_DP_MST_PAYLOAD_ALLOCATION_NONE = 0,
	DRM_DP_MST_PAYLOAD_ALLOCATION_LOCAL = 1,
	DRM_DP_MST_PAYLOAD_ALLOCATION_DFP = 2,
	DRM_DP_MST_PAYLOAD_ALLOCATION_REMOTE = 3,
};

enum drm_dp_phy {
	DP_PHY_DPRX = 0,
	DP_PHY_LTTPR1 = 1,
	DP_PHY_LTTPR2 = 2,
	DP_PHY_LTTPR3 = 3,
	DP_PHY_LTTPR4 = 4,
	DP_PHY_LTTPR5 = 5,
	DP_PHY_LTTPR6 = 6,
	DP_PHY_LTTPR7 = 7,
	DP_PHY_LTTPR8 = 8,
	DP_MAX_LTTPR_COUNT = 8,
};

enum drm_dp_quirk {
	DP_DPCD_QUIRK_CONSTANT_N = 0,
	DP_DPCD_QUIRK_NO_PSR = 1,
	DP_DPCD_QUIRK_NO_SINK_COUNT = 2,
	DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD = 3,
	DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS = 4,
	DP_DPCD_QUIRK_HBLANK_EXPANSION_REQUIRES_DSC = 5,
};

enum drm_driver_feature {
	DRIVER_GEM = 1,
	DRIVER_MODESET = 2,
	DRIVER_RENDER = 8,
	DRIVER_ATOMIC = 16,
	DRIVER_SYNCOBJ = 32,
	DRIVER_SYNCOBJ_TIMELINE = 64,
	DRIVER_COMPUTE_ACCEL = 128,
	DRIVER_GEM_GPUVA = 256,
	DRIVER_CURSOR_HOTSPOT = 512,
	DRIVER_USE_AGP = 33554432,
	DRIVER_LEGACY = 67108864,
	DRIVER_PCI_DMA = 134217728,
	DRIVER_SG = 268435456,
	DRIVER_HAVE_DMA = 536870912,
	DRIVER_HAVE_IRQ = 1073741824,
};

enum drm_dsc_params_type {
	DRM_DSC_1_2_444 = 0,
	DRM_DSC_1_1_PRE_SCR = 1,
	DRM_DSC_1_2_422 = 2,
	DRM_DSC_1_2_420 = 3,
};

enum drm_gem_object_status {
	DRM_GEM_OBJECT_RESIDENT = 1,
	DRM_GEM_OBJECT_PURGEABLE = 2,
	DRM_GEM_OBJECT_ACTIVE = 4,
};

enum drm_gpuva_flags {
	DRM_GPUVA_INVALIDATED = 1,
	DRM_GPUVA_SPARSE = 2,
	DRM_GPUVA_USERBITS = 4,
};

enum drm_gpuva_op_type {
	DRM_GPUVA_OP_MAP = 0,
	DRM_GPUVA_OP_REMAP = 1,
	DRM_GPUVA_OP_UNMAP = 2,
	DRM_GPUVA_OP_PREFETCH = 3,
};

enum drm_gpuvm_flags {
	DRM_GPUVM_RESV_PROTECTED = 1,
	DRM_GPUVM_USERBITS = 2,
};

enum drm_hdmi_broadcast_rgb {
	DRM_HDMI_BROADCAST_RGB_AUTO = 0,
	DRM_HDMI_BROADCAST_RGB_FULL = 1,
	DRM_HDMI_BROADCAST_RGB_LIMITED = 2,
};

enum drm_i915_gem_engine_class {
	I915_ENGINE_CLASS_RENDER = 0,
	I915_ENGINE_CLASS_COPY = 1,
	I915_ENGINE_CLASS_VIDEO = 2,
	I915_ENGINE_CLASS_VIDEO_ENHANCE = 3,
	I915_ENGINE_CLASS_COMPUTE = 4,
	I915_ENGINE_CLASS_INVALID = -1,
};

enum drm_i915_gem_memory_class {
	I915_MEMORY_CLASS_SYSTEM = 0,
	I915_MEMORY_CLASS_DEVICE = 1,
};

enum drm_i915_oa_format {
	I915_OA_FORMAT_A13 = 1,
	I915_OA_FORMAT_A29 = 2,
	I915_OA_FORMAT_A13_B8_C8 = 3,
	I915_OA_FORMAT_B4_C8 = 4,
	I915_OA_FORMAT_A45_B8_C8 = 5,
	I915_OA_FORMAT_B4_C8_A16 = 6,
	I915_OA_FORMAT_C4_B8 = 7,
	I915_OA_FORMAT_A12 = 8,
	I915_OA_FORMAT_A12_B8_C8 = 9,
	I915_OA_FORMAT_A32u40_A4u32_B8_C8 = 10,
	I915_OAR_FORMAT_A32u40_A4u32_B8_C8 = 11,
	I915_OA_FORMAT_A24u40_A14u32_B8_C8 = 12,
	I915_OAM_FORMAT_MPEC8u64_B8_C8 = 13,
	I915_OAM_FORMAT_MPEC8u32_B8_C8 = 14,
	I915_OA_FORMAT_MAX = 15,
};

enum drm_i915_perf_property_id {
	DRM_I915_PERF_PROP_CTX_HANDLE = 1,
	DRM_I915_PERF_PROP_SAMPLE_OA = 2,
	DRM_I915_PERF_PROP_OA_METRICS_SET = 3,
	DRM_I915_PERF_PROP_OA_FORMAT = 4,
	DRM_I915_PERF_PROP_OA_EXPONENT = 5,
	DRM_I915_PERF_PROP_HOLD_PREEMPTION = 6,
	DRM_I915_PERF_PROP_GLOBAL_SSEU = 7,
	DRM_I915_PERF_PROP_POLL_OA_PERIOD = 8,
	DRM_I915_PERF_PROP_OA_ENGINE_CLASS = 9,
	DRM_I915_PERF_PROP_OA_ENGINE_INSTANCE = 10,
	DRM_I915_PERF_PROP_MAX = 11,
};

enum drm_i915_perf_record_type {
	DRM_I915_PERF_RECORD_SAMPLE = 1,
	DRM_I915_PERF_RECORD_OA_REPORT_LOST = 2,
	DRM_I915_PERF_RECORD_OA_BUFFER_LOST = 3,
	DRM_I915_PERF_RECORD_MAX = 4,
};

enum drm_i915_pmu_engine_sample {
	I915_SAMPLE_BUSY = 0,
	I915_SAMPLE_WAIT = 1,
	I915_SAMPLE_SEMA = 2,
};

enum drm_ioctl_flags {
	DRM_AUTH = 1,
	DRM_MASTER = 2,
	DRM_ROOT_ONLY = 4,
	DRM_RENDER_ALLOW = 32,
};

enum drm_link_status {
	DRM_LINK_STATUS_GOOD = 0,
	DRM_LINK_STATUS_BAD = 1,
};

enum drm_lspcon_mode {
	DRM_LSPCON_MODE_INVALID = 0,
	DRM_LSPCON_MODE_LS = 1,
	DRM_LSPCON_MODE_PCON = 2,
};

enum drm_minor_type {
	DRM_MINOR_PRIMARY = 0,
	DRM_MINOR_CONTROL = 1,
	DRM_MINOR_RENDER = 2,
	DRM_MINOR_ACCEL = 32,
};

enum drm_mm_insert_mode {
	DRM_MM_INSERT_BEST = 0,
	DRM_MM_INSERT_LOW = 1,
	DRM_MM_INSERT_HIGH = 2,
	DRM_MM_INSERT_EVICT = 3,
	DRM_MM_INSERT_ONCE = 2147483648,
	DRM_MM_INSERT_HIGHEST = 2147483650,
	DRM_MM_INSERT_LOWEST = 2147483649,
};

enum drm_mode_analog {
	DRM_MODE_ANALOG_NTSC = 0,
	DRM_MODE_ANALOG_PAL = 1,
};

enum drm_mode_status {
	MODE_OK = 0,
	MODE_HSYNC = 1,
	MODE_VSYNC = 2,
	MODE_H_ILLEGAL = 3,
	MODE_V_ILLEGAL = 4,
	MODE_BAD_WIDTH = 5,
	MODE_NOMODE = 6,
	MODE_NO_INTERLACE = 7,
	MODE_NO_DBLESCAN = 8,
	MODE_NO_VSCAN = 9,
	MODE_MEM = 10,
	MODE_VIRTUAL_X = 11,
	MODE_VIRTUAL_Y = 12,
	MODE_MEM_VIRT = 13,
	MODE_NOCLOCK = 14,
	MODE_CLOCK_HIGH = 15,
	MODE_CLOCK_LOW = 16,
	MODE_CLOCK_RANGE = 17,
	MODE_BAD_HVALUE = 18,
	MODE_BAD_VVALUE = 19,
	MODE_BAD_VSCAN = 20,
	MODE_HSYNC_NARROW = 21,
	MODE_HSYNC_WIDE = 22,
	MODE_HBLANK_NARROW = 23,
	MODE_HBLANK_WIDE = 24,
	MODE_VSYNC_NARROW = 25,
	MODE_VSYNC_WIDE = 26,
	MODE_VBLANK_NARROW = 27,
	MODE_VBLANK_WIDE = 28,
	MODE_PANEL = 29,
	MODE_INTERLACE_WIDTH = 30,
	MODE_ONE_WIDTH = 31,
	MODE_ONE_HEIGHT = 32,
	MODE_ONE_SIZE = 33,
	MODE_NO_REDUCED = 34,
	MODE_NO_STEREO = 35,
	MODE_NO_420 = 36,
	MODE_STALE = -3,
	MODE_BAD = -2,
	MODE_ERROR = -1,
};

enum drm_mode_subconnector {
	DRM_MODE_SUBCONNECTOR_Automatic = 0,
	DRM_MODE_SUBCONNECTOR_Unknown = 0,
	DRM_MODE_SUBCONNECTOR_VGA = 1,
	DRM_MODE_SUBCONNECTOR_DVID = 3,
	DRM_MODE_SUBCONNECTOR_DVIA = 4,
	DRM_MODE_SUBCONNECTOR_Composite = 5,
	DRM_MODE_SUBCONNECTOR_SVIDEO = 6,
	DRM_MODE_SUBCONNECTOR_Component = 8,
	DRM_MODE_SUBCONNECTOR_SCART = 9,
	DRM_MODE_SUBCONNECTOR_DisplayPort = 10,
	DRM_MODE_SUBCONNECTOR_HDMIA = 11,
	DRM_MODE_SUBCONNECTOR_Native = 15,
	DRM_MODE_SUBCONNECTOR_Wireless = 18,
};

enum drm_panel_orientation {
	DRM_MODE_PANEL_ORIENTATION_UNKNOWN = -1,
	DRM_MODE_PANEL_ORIENTATION_NORMAL = 0,
	DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP = 1,
	DRM_MODE_PANEL_ORIENTATION_LEFT_UP = 2,
	DRM_MODE_PANEL_ORIENTATION_RIGHT_UP = 3,
};

enum drm_plane_type {
	DRM_PLANE_TYPE_OVERLAY = 0,
	DRM_PLANE_TYPE_PRIMARY = 1,
	DRM_PLANE_TYPE_CURSOR = 2,
};

enum drm_privacy_screen_status {
	PRIVACY_SCREEN_DISABLED = 0,
	PRIVACY_SCREEN_ENABLED = 1,
	PRIVACY_SCREEN_DISABLED_LOCKED = 2,
	PRIVACY_SCREEN_ENABLED_LOCKED = 3,
};

enum drm_scaling_filter {
	DRM_SCALING_FILTER_DEFAULT = 0,
	DRM_SCALING_FILTER_NEAREST_NEIGHBOR = 1,
};

enum drm_stat_type {
	_DRM_STAT_LOCK = 0,
	_DRM_STAT_OPENS = 1,
	_DRM_STAT_CLOSES = 2,
	_DRM_STAT_IOCTLS = 3,
	_DRM_STAT_LOCKS = 4,
	_DRM_STAT_UNLOCKS = 5,
	_DRM_STAT_VALUE = 6,
	_DRM_STAT_BYTE = 7,
	_DRM_STAT_COUNT = 8,
	_DRM_STAT_IRQ = 9,
	_DRM_STAT_PRIMARY = 10,
	_DRM_STAT_SECONDARY = 11,
	_DRM_STAT_DMA = 12,
	_DRM_STAT_SPECIAL = 13,
	_DRM_STAT_MISSED = 14,
};

enum drm_vblank_seq_type {
	_DRM_VBLANK_ABSOLUTE = 0,
	_DRM_VBLANK_RELATIVE = 1,
	_DRM_VBLANK_HIGH_CRTC_MASK = 62,
	_DRM_VBLANK_EVENT = 67108864,
	_DRM_VBLANK_FLIP = 134217728,
	_DRM_VBLANK_NEXTONMISS = 268435456,
	_DRM_VBLANK_SECONDARY = 536870912,
	_DRM_VBLANK_SIGNAL = 1073741824,
};

enum drrs_refresh_rate {
	DRRS_REFRESH_RATE_HIGH = 0,
	DRRS_REFRESH_RATE_LOW = 1,
};

enum drrs_type {
	DRRS_TYPE_NONE = 0,
	DRRS_TYPE_STATIC = 1,
	DRRS_TYPE_SEAMLESS = 2,
};

enum dw_dma_fc {
	DW_DMA_FC_D_M2M = 0,
	DW_DMA_FC_D_M2P = 1,
	DW_DMA_FC_D_P2M = 2,
	DW_DMA_FC_D_P2P = 3,
	DW_DMA_FC_P_P2M = 4,
	DW_DMA_FC_SP_P2P = 5,
	DW_DMA_FC_P_M2P = 6,
	DW_DMA_FC_DP_P2P = 7,
};

enum dw_dmac_flags {
	DW_DMA_IS_CYCLIC = 0,
	DW_DMA_IS_SOFT_LLP = 1,
	DW_DMA_IS_PAUSED = 2,
	DW_DMA_IS_INITIALIZED = 3,
};

enum dynevent_type {
	DYNEVENT_TYPE_SYNTH = 1,
	DYNEVENT_TYPE_KPROBE = 2,
	DYNEVENT_TYPE_NONE = 3,
};

enum e820_type {
	E820_TYPE_RAM = 1,
	E820_TYPE_RESERVED = 2,
	E820_TYPE_ACPI = 3,
	E820_TYPE_NVS = 4,
	E820_TYPE_UNUSABLE = 5,
	E820_TYPE_PMEM = 7,
	E820_TYPE_PRAM = 12,
	E820_TYPE_SOFT_RESERVED = 4026531839,
	E820_TYPE_RESERVED_KERN = 128,
};

enum ec_command {
	ACPI_EC_COMMAND_READ = 128,
	ACPI_EC_COMMAND_WRITE = 129,
	ACPI_EC_BURST_ENABLE = 130,
	ACPI_EC_BURST_DISABLE = 131,
	ACPI_EC_COMMAND_QUERY = 132,
};

enum edid_block_status {
	EDID_BLOCK_OK = 0,
	EDID_BLOCK_READ_FAIL = 1,
	EDID_BLOCK_NULL = 2,
	EDID_BLOCK_ZERO = 3,
	EDID_BLOCK_HEADER_CORRUPT = 4,
	EDID_BLOCK_HEADER_REPAIR = 5,
	EDID_BLOCK_HEADER_FIXED = 6,
	EDID_BLOCK_CHECKSUM = 7,
	EDID_BLOCK_VERSION = 8,
};

enum efi_rts_ids {
	EFI_NONE = 0,
	EFI_GET_TIME = 1,
	EFI_SET_TIME = 2,
	EFI_GET_WAKEUP_TIME = 3,
	EFI_SET_WAKEUP_TIME = 4,
	EFI_GET_VARIABLE = 5,
	EFI_GET_NEXT_VARIABLE = 6,
	EFI_SET_VARIABLE = 7,
	EFI_QUERY_VARIABLE_INFO = 8,
	EFI_GET_NEXT_HIGH_MONO_COUNT = 9,
	EFI_RESET_SYSTEM = 10,
	EFI_UPDATE_CAPSULE = 11,
	EFI_QUERY_CAPSULE_CAPS = 12,
	EFI_ACPI_PRM_HANDLER = 13,
};

enum efi_secureboot_mode {
	efi_secureboot_mode_unset = 0,
	efi_secureboot_mode_unknown = 1,
	efi_secureboot_mode_disabled = 2,
	efi_secureboot_mode_enabled = 3,
};

enum elv_merge {
	ELEVATOR_NO_MERGE = 0,
	ELEVATOR_FRONT_MERGE = 1,
	ELEVATOR_BACK_MERGE = 2,
	ELEVATOR_DISCARD_MERGE = 3,
};

enum ena_admin_accel_mode_feat {
	ENA_ADMIN_DISABLE_META_CACHING = 0,
	ENA_ADMIN_LIMIT_TX_BURST = 1,
};

enum ena_admin_aenq_group {
	ENA_ADMIN_LINK_CHANGE = 0,
	ENA_ADMIN_FATAL_ERROR = 1,
	ENA_ADMIN_WARNING = 2,
	ENA_ADMIN_NOTIFICATION = 3,
	ENA_ADMIN_KEEP_ALIVE = 4,
	ENA_ADMIN_AENQ_GROUPS_NUM = 5,
};

enum ena_admin_aenq_notification_syndrome {
	ENA_ADMIN_UPDATE_HINTS = 2,
};

enum ena_admin_aq_caps_id {
	ENA_ADMIN_ENI_STATS = 0,
	ENA_ADMIN_ENA_SRD_INFO = 1,
	ENA_ADMIN_CUSTOMER_METRICS = 2,
};

enum ena_admin_aq_completion_status {
	ENA_ADMIN_SUCCESS = 0,
	ENA_ADMIN_RESOURCE_ALLOCATION_FAILURE = 1,
	ENA_ADMIN_BAD_OPCODE = 2,
	ENA_ADMIN_UNSUPPORTED_OPCODE = 3,
	ENA_ADMIN_MALFORMED_REQUEST = 4,
	ENA_ADMIN_ILLEGAL_PARAMETER = 5,
	ENA_ADMIN_UNKNOWN_ERROR = 6,
	ENA_ADMIN_RESOURCE_BUSY = 7,
};

enum ena_admin_aq_feature_id {
	ENA_ADMIN_DEVICE_ATTRIBUTES = 1,
	ENA_ADMIN_MAX_QUEUES_NUM = 2,
	ENA_ADMIN_HW_HINTS = 3,
	ENA_ADMIN_LLQ = 4,
	ENA_ADMIN_MAX_QUEUES_EXT = 7,
	ENA_ADMIN_RSS_HASH_FUNCTION = 10,
	ENA_ADMIN_STATELESS_OFFLOAD_CONFIG = 11,
	ENA_ADMIN_RSS_INDIRECTION_TABLE_CONFIG = 12,
	ENA_ADMIN_MTU = 14,
	ENA_ADMIN_RSS_HASH_INPUT = 18,
	ENA_ADMIN_INTERRUPT_MODERATION = 20,
	ENA_ADMIN_AENQ_CONFIG = 26,
	ENA_ADMIN_LINK_CONFIG = 27,
	ENA_ADMIN_HOST_ATTR_CONFIG = 28,
	ENA_ADMIN_FEATURES_OPCODE_NUM = 32,
};

enum ena_admin_aq_opcode {
	ENA_ADMIN_CREATE_SQ = 1,
	ENA_ADMIN_DESTROY_SQ = 2,
	ENA_ADMIN_CREATE_CQ = 3,
	ENA_ADMIN_DESTROY_CQ = 4,
	ENA_ADMIN_GET_FEATURE = 8,
	ENA_ADMIN_SET_FEATURE = 9,
	ENA_ADMIN_GET_STATS = 11,
};

enum ena_admin_completion_policy_type {
	ENA_ADMIN_COMPLETION_POLICY_DESC = 0,
	ENA_ADMIN_COMPLETION_POLICY_DESC_ON_DEMAND = 1,
	ENA_ADMIN_COMPLETION_POLICY_HEAD_ON_DEMAND = 2,
	ENA_ADMIN_COMPLETION_POLICY_HEAD = 3,
};

enum ena_admin_customer_metrics_id {
	ENA_ADMIN_BW_IN_ALLOWANCE_EXCEEDED = 0,
	ENA_ADMIN_BW_OUT_ALLOWANCE_EXCEEDED = 1,
	ENA_ADMIN_PPS_ALLOWANCE_EXCEEDED = 2,
	ENA_ADMIN_CONNTRACK_ALLOWANCE_EXCEEDED = 3,
	ENA_ADMIN_LINKLOCAL_ALLOWANCE_EXCEEDED = 4,
	ENA_ADMIN_CONNTRACK_ALLOWANCE_AVAILABLE = 5,
};

enum ena_admin_flow_hash_fields {
	ENA_ADMIN_RSS_L2_DA = 1,
	ENA_ADMIN_RSS_L2_SA = 2,
	ENA_ADMIN_RSS_L3_DA = 4,
	ENA_ADMIN_RSS_L3_SA = 8,
	ENA_ADMIN_RSS_L4_DP = 16,
	ENA_ADMIN_RSS_L4_SP = 32,
};

enum ena_admin_flow_hash_proto {
	ENA_ADMIN_RSS_TCP4 = 0,
	ENA_ADMIN_RSS_UDP4 = 1,
	ENA_ADMIN_RSS_TCP6 = 2,
	ENA_ADMIN_RSS_UDP6 = 3,
	ENA_ADMIN_RSS_IP4 = 4,
	ENA_ADMIN_RSS_IP6 = 5,
	ENA_ADMIN_RSS_IP4_FRAG = 6,
	ENA_ADMIN_RSS_NOT_IP = 7,
	ENA_ADMIN_RSS_TCP6_EX = 8,
	ENA_ADMIN_RSS_IP6_EX = 9,
	ENA_ADMIN_RSS_PROTO_NUM = 16,
};

enum ena_admin_get_stats_type {
	ENA_ADMIN_GET_STATS_TYPE_BASIC = 0,
	ENA_ADMIN_GET_STATS_TYPE_EXTENDED = 1,
	ENA_ADMIN_GET_STATS_TYPE_ENI = 2,
	ENA_ADMIN_GET_STATS_TYPE_ENA_SRD = 3,
	ENA_ADMIN_GET_STATS_TYPE_CUSTOMER_METRICS = 4,
};

enum ena_admin_hash_functions {
	ENA_ADMIN_TOEPLITZ = 1,
	ENA_ADMIN_CRC32 = 2,
};

enum ena_admin_llq_header_location {
	ENA_ADMIN_INLINE_HEADER = 1,
	ENA_ADMIN_HEADER_RING = 2,
};

enum ena_admin_llq_num_descs_before_header {
	ENA_ADMIN_LLQ_NUM_DESCS_BEFORE_HEADER_0 = 0,
	ENA_ADMIN_LLQ_NUM_DESCS_BEFORE_HEADER_1 = 1,
	ENA_ADMIN_LLQ_NUM_DESCS_BEFORE_HEADER_2 = 2,
	ENA_ADMIN_LLQ_NUM_DESCS_BEFORE_HEADER_4 = 4,
	ENA_ADMIN_LLQ_NUM_DESCS_BEFORE_HEADER_8 = 8,
};

enum ena_admin_llq_ring_entry_size {
	ENA_ADMIN_LIST_ENTRY_SIZE_128B = 1,
	ENA_ADMIN_LIST_ENTRY_SIZE_192B = 2,
	ENA_ADMIN_LIST_ENTRY_SIZE_256B = 4,
};

enum ena_admin_llq_stride_ctrl {
	ENA_ADMIN_SINGLE_DESC_PER_ENTRY = 1,
	ENA_ADMIN_MULTIPLE_DESCS_PER_ENTRY = 2,
};

enum ena_admin_os_type {
	ENA_ADMIN_OS_LINUX = 1,
	ENA_ADMIN_OS_WIN = 2,
	ENA_ADMIN_OS_DPDK = 3,
	ENA_ADMIN_OS_FREEBSD = 4,
	ENA_ADMIN_OS_IPXE = 5,
	ENA_ADMIN_OS_ESXI = 6,
	ENA_ADMIN_OS_GROUPS_NUM = 6,
};

enum ena_admin_placement_policy_type {
	ENA_ADMIN_PLACEMENT_POLICY_HOST = 1,
	ENA_ADMIN_PLACEMENT_POLICY_DEV = 3,
};

enum ena_admin_sq_direction {
	ENA_ADMIN_SQ_DIRECTION_TX = 1,
	ENA_ADMIN_SQ_DIRECTION_RX = 2,
};

enum ena_cmd_status {
	ENA_CMD_SUBMITTED = 0,
	ENA_CMD_COMPLETED = 1,
	ENA_CMD_ABORTED = 2,
};

enum ena_eth_io_l3_proto_index {
	ENA_ETH_IO_L3_PROTO_UNKNOWN = 0,
	ENA_ETH_IO_L3_PROTO_IPV4 = 8,
	ENA_ETH_IO_L3_PROTO_IPV6 = 11,
	ENA_ETH_IO_L3_PROTO_FCOE = 21,
	ENA_ETH_IO_L3_PROTO_ROCE = 22,
};

enum ena_eth_io_l4_proto_index {
	ENA_ETH_IO_L4_PROTO_UNKNOWN = 0,
	ENA_ETH_IO_L4_PROTO_TCP = 12,
	ENA_ETH_IO_L4_PROTO_UDP = 13,
	ENA_ETH_IO_L4_PROTO_ROUTEABLE_ROCE = 23,
};

enum ena_flags_t {
	ENA_FLAG_DEVICE_RUNNING = 0,
	ENA_FLAG_DEV_UP = 1,
	ENA_FLAG_LINK_UP = 2,
	ENA_FLAG_MSIX_ENABLED = 3,
	ENA_FLAG_TRIGGER_RESET = 4,
	ENA_FLAG_ONGOING_RESET = 5,
};

enum ena_regs_reset_reason_types {
	ENA_REGS_RESET_NORMAL = 0,
	ENA_REGS_RESET_KEEP_ALIVE_TO = 1,
	ENA_REGS_RESET_ADMIN_TO = 2,
	ENA_REGS_RESET_MISS_TX_CMPL = 3,
	ENA_REGS_RESET_INV_RX_REQ_ID = 4,
	ENA_REGS_RESET_INV_TX_REQ_ID = 5,
	ENA_REGS_RESET_TOO_MANY_RX_DESCS = 6,
	ENA_REGS_RESET_INIT_ERR = 7,
	ENA_REGS_RESET_DRIVER_INVALID_STATE = 8,
	ENA_REGS_RESET_OS_TRIGGER = 9,
	ENA_REGS_RESET_OS_NETDEV_WD = 10,
	ENA_REGS_RESET_SHUTDOWN = 11,
	ENA_REGS_RESET_USER_TRIGGER = 12,
	ENA_REGS_RESET_GENERIC = 13,
	ENA_REGS_RESET_MISS_INTERRUPT = 14,
	ENA_REGS_RESET_SUSPECTED_POLL_STARVATION = 15,
	ENA_REGS_RESET_RX_DESCRIPTOR_MALFORMED = 16,
};

enum ena_xdp_errors_t {
	ENA_XDP_ALLOWED = 0,
	ENA_XDP_CURRENT_MTU_TOO_LARGE = 1,
	ENA_XDP_NO_ENOUGH_QUEUES = 2,
};

enum enable_type {
	undefined = -1,
	user_disabled = 0,
	auto_disabled = 1,
	user_enabled = 2,
	auto_enabled = 3,
};

enum energy_perf_value_index {
	EPB_INDEX_PERFORMANCE = 0,
	EPB_INDEX_BALANCE_PERFORMANCE = 1,
	EPB_INDEX_NORMAL = 2,
	EPB_INDEX_BALANCE_POWERSAVE = 3,
	EPB_INDEX_POWERSAVE = 4,
};

enum energy_perf_value_index___2 {
	EPP_INDEX_DEFAULT = 0,
	EPP_INDEX_PERFORMANCE = 1,
	EPP_INDEX_BALANCE_PERFORMANCE = 2,
	EPP_INDEX_BALANCE_POWERSAVE = 3,
	EPP_INDEX_POWERSAVE = 4,
};

enum error_detector {
	ERROR_DETECTOR_KFENCE = 0,
	ERROR_DETECTOR_KASAN = 1,
	ERROR_DETECTOR_WARN = 2,
};

enum erspan_bso {
	BSO_NOERROR = 0,
	BSO_SHORT = 1,
	BSO_OVERSIZED = 2,
	BSO_BAD = 3,
};

enum erspan_encap_type {
	ERSPAN_ENCAP_NOVLAN = 0,
	ERSPAN_ENCAP_ISL = 1,
	ERSPAN_ENCAP_8021Q = 2,
	ERSPAN_ENCAP_INFRAME = 3,
};

enum ethnl_sock_type {
	ETHTOOL_SOCK_TYPE_MODULE_FW_FLASH = 0,
};

enum ethtool_c33_pse_admin_state {
	ETHTOOL_C33_PSE_ADMIN_STATE_UNKNOWN = 1,
	ETHTOOL_C33_PSE_ADMIN_STATE_DISABLED = 2,
	ETHTOOL_C33_PSE_ADMIN_STATE_ENABLED = 3,
};

enum ethtool_c33_pse_ext_state {
	ETHTOOL_C33_PSE_EXT_STATE_ERROR_CONDITION = 1,
	ETHTOOL_C33_PSE_EXT_STATE_MR_MPS_VALID = 2,
	ETHTOOL_C33_PSE_EXT_STATE_MR_PSE_ENABLE = 3,
	ETHTOOL_C33_PSE_EXT_STATE_OPTION_DETECT_TED = 4,
	ETHTOOL_C33_PSE_EXT_STATE_OPTION_VPORT_LIM = 5,
	ETHTOOL_C33_PSE_EXT_STATE_OVLD_DETECTED = 6,
	ETHTOOL_C33_PSE_EXT_STATE_PD_DLL_POWER_TYPE = 7,
	ETHTOOL_C33_PSE_EXT_STATE_POWER_NOT_AVAILABLE = 8,
	ETHTOOL_C33_PSE_EXT_STATE_SHORT_DETECTED = 9,
};

enum ethtool_c33_pse_ext_substate_error_condition {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_NON_EXISTING_PORT = 1,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_UNDEFINED_PORT = 2,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_INTERNAL_HW_FAULT = 3,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_COMM_ERROR_AFTER_FORCE_ON = 4,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_UNKNOWN_PORT_STATUS = 5,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_HOST_CRASH_TURN_OFF = 6,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_HOST_CRASH_FORCE_SHUTDOWN = 7,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_CONFIG_CHANGE = 8,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_ERROR_CONDITION_DETECTED_OVER_TEMP = 9,
};

enum ethtool_c33_pse_ext_substate_mr_pse_enable {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_MR_PSE_ENABLE_DISABLE_PIN_ACTIVE = 1,
};

enum ethtool_c33_pse_ext_substate_option_detect_ted {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_DETECT_TED_DET_IN_PROCESS = 1,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_DETECT_TED_CONNECTION_CHECK_ERROR = 2,
};

enum ethtool_c33_pse_ext_substate_option_vport_lim {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_HIGH_VOLTAGE = 1,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_LOW_VOLTAGE = 2,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OPTION_VPORT_LIM_VOLTAGE_INJECTION = 3,
};

enum ethtool_c33_pse_ext_substate_ovld_detected {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_OVLD_DETECTED_OVERLOAD = 1,
};

enum ethtool_c33_pse_ext_substate_power_not_available {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_BUDGET_EXCEEDED = 1,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_PORT_PW_LIMIT_EXCEEDS_CONTROLLER_BUDGET = 2,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_PD_REQUEST_EXCEEDS_PORT_LIMIT = 3,
	ETHTOOL_C33_PSE_EXT_SUBSTATE_POWER_NOT_AVAILABLE_HW_PW_LIMIT = 4,
};

enum ethtool_c33_pse_ext_substate_short_detected {
	ETHTOOL_C33_PSE_EXT_SUBSTATE_SHORT_DETECTED_SHORT_CONDITION = 1,
};

enum ethtool_c33_pse_pw_d_status {
	ETHTOOL_C33_PSE_PW_D_STATUS_UNKNOWN = 1,
	ETHTOOL_C33_PSE_PW_D_STATUS_DISABLED = 2,
	ETHTOOL_C33_PSE_PW_D_STATUS_SEARCHING = 3,
	ETHTOOL_C33_PSE_PW_D_STATUS_DELIVERING = 4,
	ETHTOOL_C33_PSE_PW_D_STATUS_TEST = 5,
	ETHTOOL_C33_PSE_PW_D_STATUS_FAULT = 6,
	ETHTOOL_C33_PSE_PW_D_STATUS_OTHERFAULT = 7,
};

enum ethtool_cmis_cdb_cmd_id {
	ETHTOOL_CMIS_CDB_CMD_QUERY_STATUS = 0,
	ETHTOOL_CMIS_CDB_CMD_MODULE_FEATURES = 64,
	ETHTOOL_CMIS_CDB_CMD_FW_MANAGMENT_FEATURES = 65,
	ETHTOOL_CMIS_CDB_CMD_START_FW_DOWNLOAD = 257,
	ETHTOOL_CMIS_CDB_CMD_WRITE_FW_BLOCK_LPL = 259,
	ETHTOOL_CMIS_CDB_CMD_WRITE_FW_BLOCK_EPL = 260,
	ETHTOOL_CMIS_CDB_CMD_COMPLETE_FW_DOWNLOAD = 263,
	ETHTOOL_CMIS_CDB_CMD_RUN_FW_IMAGE = 265,
	ETHTOOL_CMIS_CDB_CMD_COMMIT_FW_IMAGE = 266,
};

enum ethtool_fec_config_bits {
	ETHTOOL_FEC_NONE_BIT = 0,
	ETHTOOL_FEC_AUTO_BIT = 1,
	ETHTOOL_FEC_OFF_BIT = 2,
	ETHTOOL_FEC_RS_BIT = 3,
	ETHTOOL_FEC_BASER_BIT = 4,
	ETHTOOL_FEC_LLRS_BIT = 5,
};

enum ethtool_flags {
	ETH_FLAG_TXVLAN = 128,
	ETH_FLAG_RXVLAN = 256,
	ETH_FLAG_LRO = 32768,
	ETH_FLAG_NTUPLE = 134217728,
	ETH_FLAG_RXHASH = 268435456,
};

enum ethtool_header_flags {
	ETHTOOL_FLAG_COMPACT_BITSETS = 1,
	ETHTOOL_FLAG_OMIT_REPLY = 2,
	ETHTOOL_FLAG_STATS = 4,
};

enum ethtool_link_ext_state {
	ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
	ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
	ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9,
	ETHTOOL_LINK_EXT_STATE_MODULE = 10,
};

enum ethtool_link_ext_substate_autoneg {
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6,
};

enum ethtool_link_ext_substate_bad_signal_integrity {
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS = 4,
};

enum ethtool_link_ext_substate_cable_issue {
	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2,
};

enum ethtool_link_ext_substate_link_logical_mismatch {
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5,
};

enum ethtool_link_ext_substate_link_training {
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4,
};

enum ethtool_link_ext_substate_module {
	ETHTOOL_LINK_EXT_SUBSTATE_MODULE_CMIS_NOT_READY = 1,
};

enum ethtool_link_mode_bit_indices {
	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
	ETHTOOL_LINK_MODE_TP_BIT = 7,
	ETHTOOL_LINK_MODE_AUI_BIT = 8,
	ETHTOOL_LINK_MODE_MII_BIT = 9,
	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
	ETHTOOL_LINK_MODE_BNC_BIT = 11,
	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
	ETHTOOL_LINK_MODE_Pause_BIT = 13,
	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
	ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
	ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
	ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
	ETHTOOL_LINK_MODE_10baseT1L_Full_BIT = 92,
	ETHTOOL_LINK_MODE_800000baseCR8_Full_BIT = 93,
	ETHTOOL_LINK_MODE_800000baseKR8_Full_BIT = 94,
	ETHTOOL_LINK_MODE_800000baseDR8_Full_BIT = 95,
	ETHTOOL_LINK_MODE_800000baseDR8_2_Full_BIT = 96,
	ETHTOOL_LINK_MODE_800000baseSR8_Full_BIT = 97,
	ETHTOOL_LINK_MODE_800000baseVR8_Full_BIT = 98,
	ETHTOOL_LINK_MODE_10baseT1S_Full_BIT = 99,
	ETHTOOL_LINK_MODE_10baseT1S_Half_BIT = 100,
	ETHTOOL_LINK_MODE_10baseT1S_P2MP_Half_BIT = 101,
	ETHTOOL_LINK_MODE_10baseT1BRR_Full_BIT = 102,
	__ETHTOOL_LINK_MODE_MASK_NBITS = 103,
};

enum ethtool_mac_stats_src {
	ETHTOOL_MAC_STATS_SRC_AGGREGATE = 0,
	ETHTOOL_MAC_STATS_SRC_EMAC = 1,
	ETHTOOL_MAC_STATS_SRC_PMAC = 2,
};

enum ethtool_mm_verify_status {
	ETHTOOL_MM_VERIFY_STATUS_UNKNOWN = 0,
	ETHTOOL_MM_VERIFY_STATUS_INITIAL = 1,
	ETHTOOL_MM_VERIFY_STATUS_VERIFYING = 2,
	ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED = 3,
	ETHTOOL_MM_VERIFY_STATUS_FAILED = 4,
	ETHTOOL_MM_VERIFY_STATUS_DISABLED = 5,
};

enum ethtool_module_fw_flash_status {
	ETHTOOL_MODULE_FW_FLASH_STATUS_STARTED = 1,
	ETHTOOL_MODULE_FW_FLASH_STATUS_IN_PROGRESS = 2,
	ETHTOOL_MODULE_FW_FLASH_STATUS_COMPLETED = 3,
	ETHTOOL_MODULE_FW_FLASH_STATUS_ERROR = 4,
};

enum ethtool_module_power_mode {
	ETHTOOL_MODULE_POWER_MODE_LOW = 1,
	ETHTOOL_MODULE_POWER_MODE_HIGH = 2,
};

enum ethtool_module_power_mode_policy {
	ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH = 1,
	ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO = 2,
};

enum ethtool_multicast_groups {
	ETHNL_MCGRP_MONITOR = 0,
};

enum ethtool_phys_id_state {
	ETHTOOL_ID_INACTIVE = 0,
	ETHTOOL_ID_ACTIVE = 1,
	ETHTOOL_ID_ON = 2,
	ETHTOOL_ID_OFF = 3,
};

enum ethtool_podl_pse_admin_state {
	ETHTOOL_PODL_PSE_ADMIN_STATE_UNKNOWN = 1,
	ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED = 2,
	ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED = 3,
};

enum ethtool_podl_pse_pw_d_status {
	ETHTOOL_PODL_PSE_PW_D_STATUS_UNKNOWN = 1,
	ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED = 2,
	ETHTOOL_PODL_PSE_PW_D_STATUS_SEARCHING = 3,
	ETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING = 4,
	ETHTOOL_PODL_PSE_PW_D_STATUS_SLEEP = 5,
	ETHTOOL_PODL_PSE_PW_D_STATUS_IDLE = 6,
	ETHTOOL_PODL_PSE_PW_D_STATUS_ERROR = 7,
};

enum ethtool_reset_flags {
	ETH_RESET_MGMT = 1,
	ETH_RESET_IRQ = 2,
	ETH_RESET_DMA = 4,
	ETH_RESET_FILTER = 8,
	ETH_RESET_OFFLOAD = 16,
	ETH_RESET_MAC = 32,
	ETH_RESET_PHY = 64,
	ETH_RESET_RAM = 128,
	ETH_RESET_AP = 256,
	ETH_RESET_DEDICATED = 65535,
	ETH_RESET_ALL = 4294967295,
};

enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT = 0,
	ETHTOOL_F_WISH__BIT = 1,
	ETHTOOL_F_COMPAT__BIT = 2,
};

enum ethtool_stringset {
	ETH_SS_TEST = 0,
	ETH_SS_STATS = 1,
	ETH_SS_PRIV_FLAGS = 2,
	ETH_SS_NTUPLE_FILTERS = 3,
	ETH_SS_FEATURES = 4,
	ETH_SS_RSS_HASH_FUNCS = 5,
	ETH_SS_TUNABLES = 6,
	ETH_SS_PHY_STATS = 7,
	ETH_SS_PHY_TUNABLES = 8,
	ETH_SS_LINK_MODES = 9,
	ETH_SS_MSG_CLASSES = 10,
	ETH_SS_WOL_MODES = 11,
	ETH_SS_SOF_TIMESTAMPING = 12,
	ETH_SS_TS_TX_TYPES = 13,
	ETH_SS_TS_RX_FILTERS = 14,
	ETH_SS_UDP_TUNNEL_TYPES = 15,
	ETH_SS_STATS_STD = 16,
	ETH_SS_STATS_ETH_PHY = 17,
	ETH_SS_STATS_ETH_MAC = 18,
	ETH_SS_STATS_ETH_CTRL = 19,
	ETH_SS_STATS_RMON = 20,
	ETH_SS_STATS_PHY = 21,
	ETH_SS_TS_FLAGS = 22,
	ETH_SS_COUNT = 23,
};

enum ethtool_supported_ring_param {
	ETHTOOL_RING_USE_RX_BUF_LEN = 1,
	ETHTOOL_RING_USE_CQE_SIZE = 2,
	ETHTOOL_RING_USE_TX_PUSH = 4,
	ETHTOOL_RING_USE_RX_PUSH = 8,
	ETHTOOL_RING_USE_TX_PUSH_BUF_LEN = 16,
	ETHTOOL_RING_USE_TCP_DATA_SPLIT = 32,
	ETHTOOL_RING_USE_HDS_THRS = 64,
};

enum ethtool_tcp_data_split {
	ETHTOOL_TCP_DATA_SPLIT_UNKNOWN = 0,
	ETHTOOL_TCP_DATA_SPLIT_DISABLED = 1,
	ETHTOOL_TCP_DATA_SPLIT_ENABLED = 2,
};

enum ethtool_test_flags {
	ETH_TEST_FL_OFFLINE = 1,
	ETH_TEST_FL_FAILED = 2,
	ETH_TEST_FL_EXTERNAL_LB = 4,
	ETH_TEST_FL_EXTERNAL_LB_DONE = 8,
};

enum event_command_flags {
	EVENT_CMD_FL_POST_TRIGGER = 1,
	EVENT_CMD_FL_NEEDS_REC = 2,
};

enum event_trigger_type {
	ETT_NONE = 0,
	ETT_TRACE_ONOFF = 1,
	ETT_SNAPSHOT = 2,
	ETT_STACKTRACE = 4,
	ETT_EVENT_ENABLE = 8,
	ETT_EVENT_HIST = 16,
	ETT_HIST_ENABLE = 32,
	ETT_EVENT_EPROBE = 64,
};

enum event_type_t {
	EVENT_FLEXIBLE = 1,
	EVENT_PINNED = 2,
	EVENT_TIME = 4,
	EVENT_FROZEN = 8,
	EVENT_CPU = 16,
	EVENT_CGROUP = 32,
	EVENT_ALL = 3,
	EVENT_TIME_FROZEN = 12,
};

enum evict_result {
	ER_EVICT = 0,
	ER_DONT_EVICT = 1,
	ER_STOP = 2,
};

enum evm_ima_xattr_type {
	IMA_XATTR_DIGEST = 1,
	EVM_XATTR_HMAC = 2,
	EVM_IMA_XATTR_DIGSIG = 3,
	IMA_XATTR_DIGEST_NG = 4,
	EVM_XATTR_PORTABLE_DIGSIG = 5,
	IMA_VERITY_DIGSIG = 6,
	IMA_XATTR_LAST = 7,
};

enum exact_level {
	NOT_EXACT = 0,
	EXACT = 1,
	RANGE_WITHIN = 2,
};

enum exception {
	EXCP_CONTEXT = 1,
	NO_EXCP = 2,
};

enum exception_stack_ordering {
	ESTACK_DF = 0,
	ESTACK_NMI = 1,
	ESTACK_DB = 2,
	ESTACK_MCE = 3,
	ESTACK_VC = 4,
	ESTACK_VC2 = 5,
	N_EXCEPTION_STACKS = 6,
};

enum execmem_range_flags {
	EXECMEM_KASAN_SHADOW = 1,
	EXECMEM_ROX_CACHE = 2,
};

enum execmem_type {
	EXECMEM_DEFAULT = 0,
	EXECMEM_MODULE_TEXT = 0,
	EXECMEM_KPROBES = 1,
	EXECMEM_FTRACE = 2,
	EXECMEM_BPF = 3,
	EXECMEM_MODULE_DATA = 4,
	EXECMEM_TYPE_MAX = 5,
};

enum exit_fastpath_completion {
	EXIT_FASTPATH_NONE = 0,
	EXIT_FASTPATH_REENTER_GUEST = 1,
	EXIT_FASTPATH_EXIT_HANDLED = 2,
	EXIT_FASTPATH_EXIT_USERSPACE = 3,
};

enum ext4_journal_trigger_type {
	EXT4_JTR_ORPHAN_FILE = 0,
	EXT4_JTR_NONE = 1,
};

enum ext4_li_mode {
	EXT4_LI_MODE_PREFETCH_BBITMAP = 0,
	EXT4_LI_MODE_ITABLE = 1,
};

enum extra_reg_type {
	EXTRA_REG_NONE = -1,
	EXTRA_REG_RSP_0 = 0,
	EXTRA_REG_RSP_1 = 1,
	EXTRA_REG_LBR = 2,
	EXTRA_REG_LDLAT = 3,
	EXTRA_REG_FE = 4,
	EXTRA_REG_SNOOP_0 = 5,
	EXTRA_REG_SNOOP_1 = 6,
	EXTRA_REG_MAX = 7,
};

enum fail_dup_mod_reason {
	FAIL_DUP_MOD_BECOMING = 0,
	FAIL_DUP_MOD_LOAD = 1,
};

enum fault_flag {
	FAULT_FLAG_WRITE = 1,
	FAULT_FLAG_MKWRITE = 2,
	FAULT_FLAG_ALLOW_RETRY = 4,
	FAULT_FLAG_RETRY_NOWAIT = 8,
	FAULT_FLAG_KILLABLE = 16,
	FAULT_FLAG_TRIED = 32,
	FAULT_FLAG_USER = 64,
	FAULT_FLAG_REMOTE = 128,
	FAULT_FLAG_INSTRUCTION = 256,
	FAULT_FLAG_INTERRUPTIBLE = 512,
	FAULT_FLAG_UNSHARE = 1024,
	FAULT_FLAG_ORIG_PTE_VALID = 2048,
	FAULT_FLAG_VMA_LOCK = 4096,
};

enum faulttype {
	DMA_REMAP = 0,
	INTR_REMAP = 1,
	UNKNOWN = 2,
};

enum fb_op_origin {
	ORIGIN_CPU = 0,
	ORIGIN_CS = 1,
	ORIGIN_FLIP = 2,
	ORIGIN_DIRTYFB = 3,
	ORIGIN_CURSOR_UPDATE = 4,
};

enum fbq_type {
	regular = 0,
	remote = 1,
	all = 2,
};

enum fc_fh_type {
	FC_TYPE_BLS = 0,
	FC_TYPE_ELS = 1,
	FC_TYPE_IP = 5,
	FC_TYPE_FCP = 8,
	FC_TYPE_CT = 32,
	FC_TYPE_ILS = 34,
	FC_TYPE_NVME = 40,
};

enum fcnvme_ls_rjt_explan {
	FCNVME_RJT_EXP_NONE = 0,
	FCNVME_RJT_EXP_OXID_RXID = 23,
	FCNVME_RJT_EXP_UNAB_DATA = 42,
	FCNVME_RJT_EXP_INV_LEN = 45,
	FCNVME_RJT_EXP_INV_ERSP_RAT = 64,
	FCNVME_RJT_EXP_INV_CTLR_ID = 65,
	FCNVME_RJT_EXP_INV_QUEUE_ID = 66,
	FCNVME_RJT_EXP_INV_SQSIZE = 67,
	FCNVME_RJT_EXP_INV_HOSTID = 68,
	FCNVME_RJT_EXP_INV_HOSTNQN = 69,
	FCNVME_RJT_EXP_INV_SUBNQN = 70,
};

enum fcnvme_ls_rjt_reason {
	FCNVME_RJT_RC_NONE = 0,
	FCNVME_RJT_RC_INVAL = 1,
	FCNVME_RJT_RC_LOGIC = 3,
	FCNVME_RJT_RC_UNAB = 9,
	FCNVME_RJT_RC_UNSUP = 11,
	FCNVME_RJT_RC_INV_ASSOC = 64,
	FCNVME_RJT_RC_INV_CONN = 65,
	FCNVME_RJT_RC_INV_PARAM = 66,
	FCNVME_RJT_RC_INSUF_RES = 67,
	FCNVME_RJT_RC_VENDOR = 255,
};

enum fetch_op {
	FETCH_OP_NOP = 0,
	FETCH_OP_REG = 1,
	FETCH_OP_STACK = 2,
	FETCH_OP_STACKP = 3,
	FETCH_OP_RETVAL = 4,
	FETCH_OP_IMM = 5,
	FETCH_OP_COMM = 6,
	FETCH_OP_ARG = 7,
	FETCH_OP_FOFFS = 8,
	FETCH_OP_DATA = 9,
	FETCH_OP_EDATA = 10,
	FETCH_OP_DEREF = 11,
	FETCH_OP_UDEREF = 12,
	FETCH_OP_ST_RAW = 13,
	FETCH_OP_ST_MEM = 14,
	FETCH_OP_ST_UMEM = 15,
	FETCH_OP_ST_STRING = 16,
	FETCH_OP_ST_USTRING = 17,
	FETCH_OP_ST_SYMSTR = 18,
	FETCH_OP_ST_EDATA = 19,
	FETCH_OP_MOD_BF = 20,
	FETCH_OP_LP_ARRAY = 21,
	FETCH_OP_TP_ARG = 22,
	FETCH_OP_END = 23,
	FETCH_NOP_SYMBOL = 24,
};

enum fib6_walk_state {
	FWS_S = 0,
	FWS_L = 1,
	FWS_R = 2,
	FWS_C = 3,
	FWS_U = 4,
};

enum fib_event_type {
	FIB_EVENT_ENTRY_REPLACE = 0,
	FIB_EVENT_ENTRY_APPEND = 1,
	FIB_EVENT_ENTRY_ADD = 2,
	FIB_EVENT_ENTRY_DEL = 3,
	FIB_EVENT_RULE_ADD = 4,
	FIB_EVENT_RULE_DEL = 5,
	FIB_EVENT_NH_ADD = 6,
	FIB_EVENT_NH_DEL = 7,
	FIB_EVENT_VIF_ADD = 8,
	FIB_EVENT_VIF_DEL = 9,
};

enum fid_type {
	FILEID_ROOT = 0,
	FILEID_INO32_GEN = 1,
	FILEID_INO32_GEN_PARENT = 2,
	FILEID_BTRFS_WITHOUT_PARENT = 77,
	FILEID_BTRFS_WITH_PARENT = 78,
	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
	FILEID_UDF_WITHOUT_PARENT = 81,
	FILEID_UDF_WITH_PARENT = 82,
	FILEID_NILFS_WITHOUT_PARENT = 97,
	FILEID_NILFS_WITH_PARENT = 98,
	FILEID_FAT_WITHOUT_PARENT = 113,
	FILEID_FAT_WITH_PARENT = 114,
	FILEID_INO64_GEN = 129,
	FILEID_INO64_GEN_PARENT = 130,
	FILEID_LUSTRE = 151,
	FILEID_BCACHEFS_WITHOUT_PARENT = 177,
	FILEID_BCACHEFS_WITH_PARENT = 178,
	FILEID_KERNFS = 254,
	FILEID_INVALID = 255,
};

enum file_state {
	MEI_FILE_UNINITIALIZED = 0,
	MEI_FILE_INITIALIZING = 1,
	MEI_FILE_CONNECTING = 2,
	MEI_FILE_CONNECTED = 3,
	MEI_FILE_DISCONNECTING = 4,
	MEI_FILE_DISCONNECT_REPLY = 5,
	MEI_FILE_DISCONNECT_REQUIRED = 6,
	MEI_FILE_DISCONNECTED = 7,
};

enum file_time_flags {
	S_ATIME = 1,
	S_MTIME = 2,
	S_CTIME = 4,
	S_VERSION = 8,
};

enum filter_op_ids {
	OP_GLOB = 0,
	OP_NE = 1,
	OP_EQ = 2,
	OP_LE = 3,
	OP_LT = 4,
	OP_GE = 5,
	OP_GT = 6,
	OP_BAND = 7,
	OP_MAX = 8,
};

enum filter_pred_fn {
	FILTER_PRED_FN_NOP = 0,
	FILTER_PRED_FN_64 = 1,
	FILTER_PRED_FN_64_CPUMASK = 2,
	FILTER_PRED_FN_S64 = 3,
	FILTER_PRED_FN_U64 = 4,
	FILTER_PRED_FN_32 = 5,
	FILTER_PRED_FN_32_CPUMASK = 6,
	FILTER_PRED_FN_S32 = 7,
	FILTER_PRED_FN_U32 = 8,
	FILTER_PRED_FN_16 = 9,
	FILTER_PRED_FN_16_CPUMASK = 10,
	FILTER_PRED_FN_S16 = 11,
	FILTER_PRED_FN_U16 = 12,
	FILTER_PRED_FN_8 = 13,
	FILTER_PRED_FN_8_CPUMASK = 14,
	FILTER_PRED_FN_S8 = 15,
	FILTER_PRED_FN_U8 = 16,
	FILTER_PRED_FN_COMM = 17,
	FILTER_PRED_FN_STRING = 18,
	FILTER_PRED_FN_STRLOC = 19,
	FILTER_PRED_FN_STRRELLOC = 20,
	FILTER_PRED_FN_PCHAR_USER = 21,
	FILTER_PRED_FN_PCHAR = 22,
	FILTER_PRED_FN_CPU = 23,
	FILTER_PRED_FN_CPU_CPUMASK = 24,
	FILTER_PRED_FN_CPUMASK = 25,
	FILTER_PRED_FN_CPUMASK_CPU = 26,
	FILTER_PRED_FN_FUNCTION = 27,
	FILTER_PRED_FN_ = 28,
	FILTER_PRED_TEST_VISITED = 29,
};

enum fit_type {
	NOTHING_FIT = 0,
	FL_FIT_TYPE = 1,
	LE_FIT_TYPE = 2,
	RE_FIT_TYPE = 3,
	NE_FIT_TYPE = 4,
};

enum fixed_addresses {
	VSYSCALL_PAGE = 511,
	FIX_DBGP_BASE = 512,
	FIX_EARLYCON_MEM_BASE = 513,
	FIX_APIC_BASE = 514,
	FIX_IO_APIC_BASE_0 = 515,
	FIX_IO_APIC_BASE_END = 642,
	__end_of_permanent_fixed_addresses = 643,
	FIX_BTMAP_END = 1024,
	FIX_BTMAP_BEGIN = 1535,
	__end_of_fixed_addresses = 1536,
};

enum flag_bits {
	Faulty = 0,
	In_sync = 1,
	Bitmap_sync = 2,
	WriteMostly = 3,
	AutoDetected = 4,
	Blocked = 5,
	WriteErrorSeen = 6,
	FaultRecorded = 7,
	BlockedBadBlocks = 8,
	WantReplacement = 9,
	Replacement = 10,
	Candidate = 11,
	Journal = 12,
	ClusterRemove = 13,
	ExternalBbl = 14,
	FailFast = 15,
	LastDev = 16,
	CollisionCheck = 17,
	Nonrot = 18,
};

enum flow_action_hw_stats {
	FLOW_ACTION_HW_STATS_IMMEDIATE = 1,
	FLOW_ACTION_HW_STATS_DELAYED = 2,
	FLOW_ACTION_HW_STATS_ANY = 3,
	FLOW_ACTION_HW_STATS_DISABLED = 4,
	FLOW_ACTION_HW_STATS_DONT_CARE = 7,
};

enum flow_action_hw_stats_bit {
	FLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,
	FLOW_ACTION_HW_STATS_DELAYED_BIT = 1,
	FLOW_ACTION_HW_STATS_DISABLED_BIT = 2,
	FLOW_ACTION_HW_STATS_NUM_BITS = 3,
};

enum flow_action_id {
	FLOW_ACTION_ACCEPT = 0,
	FLOW_ACTION_DROP = 1,
	FLOW_ACTION_TRAP = 2,
	FLOW_ACTION_GOTO = 3,
	FLOW_ACTION_REDIRECT = 4,
	FLOW_ACTION_MIRRED = 5,
	FLOW_ACTION_REDIRECT_INGRESS = 6,
	FLOW_ACTION_MIRRED_INGRESS = 7,
	FLOW_ACTION_VLAN_PUSH = 8,
	FLOW_ACTION_VLAN_POP = 9,
	FLOW_ACTION_VLAN_MANGLE = 10,
	FLOW_ACTION_TUNNEL_ENCAP = 11,
	FLOW_ACTION_TUNNEL_DECAP = 12,
	FLOW_ACTION_MANGLE = 13,
	FLOW_ACTION_ADD = 14,
	FLOW_ACTION_CSUM = 15,
	FLOW_ACTION_MARK = 16,
	FLOW_ACTION_PTYPE = 17,
	FLOW_ACTION_PRIORITY = 18,
	FLOW_ACTION_RX_QUEUE_MAPPING = 19,
	FLOW_ACTION_WAKE = 20,
	FLOW_ACTION_QUEUE = 21,
	FLOW_ACTION_SAMPLE = 22,
	FLOW_ACTION_POLICE = 23,
	FLOW_ACTION_CT = 24,
	FLOW_ACTION_CT_METADATA = 25,
	FLOW_ACTION_MPLS_PUSH = 26,
	FLOW_ACTION_MPLS_POP = 27,
	FLOW_ACTION_MPLS_MANGLE = 28,
	FLOW_ACTION_GATE = 29,
	FLOW_ACTION_PPPOE_PUSH = 30,
	FLOW_ACTION_JUMP = 31,
	FLOW_ACTION_PIPE = 32,
	FLOW_ACTION_VLAN_PUSH_ETH = 33,
	FLOW_ACTION_VLAN_POP_ETH = 34,
	FLOW_ACTION_CONTINUE = 35,
	NUM_FLOW_ACTIONS = 36,
};

enum flow_action_mangle_base {
	FLOW_ACT_MANGLE_UNSPEC = 0,
	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
};

enum flow_block_binder_type {
	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
	FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP = 3,
	FLOW_BLOCK_BINDER_TYPE_RED_MARK = 4,
};

enum flow_block_command {
	FLOW_BLOCK_BIND = 0,
	FLOW_BLOCK_UNBIND = 1,
};

enum flow_cls_command {
	FLOW_CLS_REPLACE = 0,
	FLOW_CLS_DESTROY = 1,
	FLOW_CLS_STATS = 2,
	FLOW_CLS_TMPLT_CREATE = 3,
	FLOW_CLS_TMPLT_DESTROY = 4,
};

enum flow_dissect_ret {
	FLOW_DISSECT_RET_OUT_GOOD = 0,
	FLOW_DISSECT_RET_OUT_BAD = 1,
	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
	FLOW_DISSECT_RET_CONTINUE = 4,
};

enum flow_dissector_ctrl_flags {
	FLOW_DIS_IS_FRAGMENT = 1,
	FLOW_DIS_FIRST_FRAG = 2,
	FLOW_DIS_F_TUNNEL_CSUM = 4,
	FLOW_DIS_F_TUNNEL_DONT_FRAGMENT = 8,
	FLOW_DIS_F_TUNNEL_OAM = 16,
	FLOW_DIS_F_TUNNEL_CRIT_OPT = 32,
	FLOW_DIS_ENCAPSULATION = 64,
};

enum flow_dissector_key_id {
	FLOW_DISSECTOR_KEY_CONTROL = 0,
	FLOW_DISSECTOR_KEY_BASIC = 1,
	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
	FLOW_DISSECTOR_KEY_PORTS = 4,
	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
	FLOW_DISSECTOR_KEY_ICMP = 6,
	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
	FLOW_DISSECTOR_KEY_TIPC = 8,
	FLOW_DISSECTOR_KEY_ARP = 9,
	FLOW_DISSECTOR_KEY_VLAN = 10,
	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
	FLOW_DISSECTOR_KEY_MPLS = 19,
	FLOW_DISSECTOR_KEY_TCP = 20,
	FLOW_DISSECTOR_KEY_IP = 21,
	FLOW_DISSECTOR_KEY_CVLAN = 22,
	FLOW_DISSECTOR_KEY_ENC_IP = 23,
	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
	FLOW_DISSECTOR_KEY_META = 25,
	FLOW_DISSECTOR_KEY_CT = 26,
	FLOW_DISSECTOR_KEY_HASH = 27,
	FLOW_DISSECTOR_KEY_NUM_OF_VLANS = 28,
	FLOW_DISSECTOR_KEY_PPPOE = 29,
	FLOW_DISSECTOR_KEY_L2TPV3 = 30,
	FLOW_DISSECTOR_KEY_CFM = 31,
	FLOW_DISSECTOR_KEY_IPSEC = 32,
	FLOW_DISSECTOR_KEY_MAX = 33,
};

enum flow_offload_tuple_dir {
	FLOW_OFFLOAD_DIR_ORIGINAL = 0,
	FLOW_OFFLOAD_DIR_REPLY = 1,
};

enum flow_offload_type {
	NF_FLOW_OFFLOAD_UNSPEC = 0,
	NF_FLOW_OFFLOAD_ROUTE = 1,
};

enum flow_offload_xmit_type {
	FLOW_OFFLOAD_XMIT_UNSPEC = 0,
	FLOW_OFFLOAD_XMIT_NEIGH = 1,
	FLOW_OFFLOAD_XMIT_XFRM = 2,
	FLOW_OFFLOAD_XMIT_DIRECT = 3,
	FLOW_OFFLOAD_XMIT_TC = 4,
};

enum flowlabel_reflect {
	FLOWLABEL_REFLECT_ESTABLISHED = 1,
	FLOWLABEL_REFLECT_TCP_RESET = 2,
	FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
};

enum folio_references {
	FOLIOREF_RECLAIM = 0,
	FOLIOREF_RECLAIM_CLEAN = 1,
	FOLIOREF_KEEP = 2,
	FOLIOREF_ACTIVATE = 3,
};

enum folio_walk_level {
	FW_LEVEL_PTE = 0,
	FW_LEVEL_PMD = 1,
	FW_LEVEL_PUD = 2,
};

enum forcewake_domain_id {
	FW_DOMAIN_ID_RENDER = 0,
	FW_DOMAIN_ID_GT = 1,
	FW_DOMAIN_ID_MEDIA = 2,
	FW_DOMAIN_ID_MEDIA_VDBOX0 = 3,
	FW_DOMAIN_ID_MEDIA_VDBOX1 = 4,
	FW_DOMAIN_ID_MEDIA_VDBOX2 = 5,
	FW_DOMAIN_ID_MEDIA_VDBOX3 = 6,
	FW_DOMAIN_ID_MEDIA_VDBOX4 = 7,
	FW_DOMAIN_ID_MEDIA_VDBOX5 = 8,
	FW_DOMAIN_ID_MEDIA_VDBOX6 = 9,
	FW_DOMAIN_ID_MEDIA_VDBOX7 = 10,
	FW_DOMAIN_ID_MEDIA_VEBOX0 = 11,
	FW_DOMAIN_ID_MEDIA_VEBOX1 = 12,
	FW_DOMAIN_ID_MEDIA_VEBOX2 = 13,
	FW_DOMAIN_ID_MEDIA_VEBOX3 = 14,
	FW_DOMAIN_ID_GSC = 15,
	FW_DOMAIN_ID_COUNT = 16,
};

enum forcewake_domains {
	FORCEWAKE_RENDER = 1,
	FORCEWAKE_GT = 2,
	FORCEWAKE_MEDIA = 4,
	FORCEWAKE_MEDIA_VDBOX0 = 8,
	FORCEWAKE_MEDIA_VDBOX1 = 16,
	FORCEWAKE_MEDIA_VDBOX2 = 32,
	FORCEWAKE_MEDIA_VDBOX3 = 64,
	FORCEWAKE_MEDIA_VDBOX4 = 128,
	FORCEWAKE_MEDIA_VDBOX5 = 256,
	FORCEWAKE_MEDIA_VDBOX6 = 512,
	FORCEWAKE_MEDIA_VDBOX7 = 1024,
	FORCEWAKE_MEDIA_VEBOX0 = 2048,
	FORCEWAKE_MEDIA_VEBOX1 = 4096,
	FORCEWAKE_MEDIA_VEBOX2 = 8192,
	FORCEWAKE_MEDIA_VEBOX3 = 16384,
	FORCEWAKE_GSC = 32768,
	FORCEWAKE_ALL = 65535,
};

enum format_state {
	FORMAT_STATE_NONE = 0,
	FORMAT_STATE_NUM = 1,
	FORMAT_STATE_WIDTH = 2,
	FORMAT_STATE_PRECISION = 3,
	FORMAT_STATE_CHAR = 4,
	FORMAT_STATE_STR = 5,
	FORMAT_STATE_PTR = 6,
	FORMAT_STATE_PERCENT_CHAR = 7,
	FORMAT_STATE_INVALID = 8,
};

enum fortify_func {
	FORTIFY_FUNC_strncpy = 0,
	FORTIFY_FUNC_strnlen = 1,
	FORTIFY_FUNC_strlen = 2,
	FORTIFY_FUNC_strscpy = 3,
	FORTIFY_FUNC_strlcat = 4,
	FORTIFY_FUNC_strcat = 5,
	FORTIFY_FUNC_strncat = 6,
	FORTIFY_FUNC_memset = 7,
	FORTIFY_FUNC_memcpy = 8,
	FORTIFY_FUNC_memmove = 9,
	FORTIFY_FUNC_memscan = 10,
	FORTIFY_FUNC_memcmp = 11,
	FORTIFY_FUNC_memchr = 12,
	FORTIFY_FUNC_memchr_inv = 13,
	FORTIFY_FUNC_kmemdup = 14,
	FORTIFY_FUNC_strcpy = 15,
	FORTIFY_FUNC_UNKNOWN = 16,
};

enum freeze_holder {
	FREEZE_HOLDER_KERNEL = 1,
	FREEZE_HOLDER_USERSPACE = 2,
	FREEZE_MAY_NEST = 4,
};

enum freezer_state_flags {
	CGROUP_FREEZER_ONLINE = 1,
	CGROUP_FREEZING_SELF = 2,
	CGROUP_FREEZING_PARENT = 4,
	CGROUP_FROZEN = 8,
	CGROUP_FREEZING = 6,
};

enum freq_qos_req_type {
	FREQ_QOS_MIN = 1,
	FREQ_QOS_MAX = 2,
};

enum fs_context_phase {
	FS_CONTEXT_CREATE_PARAMS = 0,
	FS_CONTEXT_CREATING = 1,
	FS_CONTEXT_AWAITING_MOUNT = 2,
	FS_CONTEXT_AWAITING_RECONF = 3,
	FS_CONTEXT_RECONF_PARAMS = 4,
	FS_CONTEXT_RECONFIGURING = 5,
	FS_CONTEXT_FAILED = 6,
};

enum fs_context_purpose {
	FS_CONTEXT_FOR_MOUNT = 0,
	FS_CONTEXT_FOR_SUBMOUNT = 1,
	FS_CONTEXT_FOR_RECONFIGURE = 2,
};

enum fs_value_type {
	fs_value_is_undefined = 0,
	fs_value_is_flag = 1,
	fs_value_is_string = 2,
	fs_value_is_blob = 3,
	fs_value_is_filename = 4,
	fs_value_is_file = 5,
};

enum fscache_cache_state {
	FSCACHE_CACHE_IS_NOT_PRESENT = 0,
	FSCACHE_CACHE_IS_PREPARING = 1,
	FSCACHE_CACHE_IS_ACTIVE = 2,
	FSCACHE_CACHE_GOT_IOERROR = 3,
	FSCACHE_CACHE_IS_WITHDRAWN = 4,
};

enum fscache_cookie_state {
	FSCACHE_COOKIE_STATE_QUIESCENT = 0,
	FSCACHE_COOKIE_STATE_LOOKING_UP = 1,
	FSCACHE_COOKIE_STATE_CREATING = 2,
	FSCACHE_COOKIE_STATE_ACTIVE = 3,
	FSCACHE_COOKIE_STATE_INVALIDATING = 4,
	FSCACHE_COOKIE_STATE_FAILED = 5,
	FSCACHE_COOKIE_STATE_LRU_DISCARDING = 6,
	FSCACHE_COOKIE_STATE_WITHDRAWING = 7,
	FSCACHE_COOKIE_STATE_RELINQUISHING = 8,
	FSCACHE_COOKIE_STATE_DROPPED = 9,
} __attribute__((mode(byte)));

enum fscache_want_state {
	FSCACHE_WANT_PARAMS = 0,
	FSCACHE_WANT_WRITE = 1,
	FSCACHE_WANT_READ = 2,
};

enum fsconfig_command {
	FSCONFIG_SET_FLAG = 0,
	FSCONFIG_SET_STRING = 1,
	FSCONFIG_SET_BINARY = 2,
	FSCONFIG_SET_PATH = 3,
	FSCONFIG_SET_PATH_EMPTY = 4,
	FSCONFIG_SET_FD = 5,
	FSCONFIG_CMD_CREATE = 6,
	FSCONFIG_CMD_RECONFIGURE = 7,
	FSCONFIG_CMD_CREATE_EXCL = 8,
};

enum fsl_mc_pool_type {
	FSL_MC_POOL_DPMCP = 0,
	FSL_MC_POOL_DPBP = 1,
	FSL_MC_POOL_DPCON = 2,
	FSL_MC_POOL_IRQ = 3,
	FSL_MC_NUM_POOL_TYPES = 4,
};

enum fsnotify_data_type {
	FSNOTIFY_EVENT_NONE = 0,
	FSNOTIFY_EVENT_FILE_RANGE = 1,
	FSNOTIFY_EVENT_PATH = 2,
	FSNOTIFY_EVENT_INODE = 3,
	FSNOTIFY_EVENT_DENTRY = 4,
	FSNOTIFY_EVENT_ERROR = 5,
};

enum fsnotify_group_prio {
	FSNOTIFY_PRIO_NORMAL = 0,
	FSNOTIFY_PRIO_CONTENT = 1,
	FSNOTIFY_PRIO_PRE_CONTENT = 2,
	__FSNOTIFY_PRIO_NUM = 3,
};

enum fsnotify_iter_type {
	FSNOTIFY_ITER_TYPE_INODE = 0,
	FSNOTIFY_ITER_TYPE_VFSMOUNT = 1,
	FSNOTIFY_ITER_TYPE_SB = 2,
	FSNOTIFY_ITER_TYPE_PARENT = 3,
	FSNOTIFY_ITER_TYPE_INODE2 = 4,
	FSNOTIFY_ITER_TYPE_COUNT = 5,
};

enum fsnotify_obj_type {
	FSNOTIFY_OBJ_TYPE_ANY = -1,
	FSNOTIFY_OBJ_TYPE_INODE = 0,
	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 1,
	FSNOTIFY_OBJ_TYPE_SB = 2,
	FSNOTIFY_OBJ_TYPE_COUNT = 3,
	FSNOTIFY_OBJ_TYPE_DETACHED = 3,
};

enum ftrace_dump_mode {
	DUMP_NONE = 0,
	DUMP_ALL = 1,
	DUMP_ORIG = 2,
	DUMP_PARAM = 3,
};

enum fuse_dax_mode {
	FUSE_DAX_INODE_DEFAULT = 0,
	FUSE_DAX_ALWAYS = 1,
	FUSE_DAX_NEVER = 2,
	FUSE_DAX_INODE_USER = 3,
};

enum fuse_ext_type {
	FUSE_MAX_NR_SECCTX = 31,
	FUSE_EXT_GROUPS = 32,
};

enum fuse_notify_code {
	FUSE_NOTIFY_POLL = 1,
	FUSE_NOTIFY_INVAL_INODE = 2,
	FUSE_NOTIFY_INVAL_ENTRY = 3,
	FUSE_NOTIFY_STORE = 4,
	FUSE_NOTIFY_RETRIEVE = 5,
	FUSE_NOTIFY_DELETE = 6,
	FUSE_NOTIFY_RESEND = 7,
	FUSE_NOTIFY_CODE_MAX = 8,
};

enum fuse_opcode {
	FUSE_LOOKUP = 1,
	FUSE_FORGET = 2,
	FUSE_GETATTR = 3,
	FUSE_SETATTR = 4,
	FUSE_READLINK = 5,
	FUSE_SYMLINK = 6,
	FUSE_MKNOD = 8,
	FUSE_MKDIR = 9,
	FUSE_UNLINK = 10,
	FUSE_RMDIR = 11,
	FUSE_RENAME = 12,
	FUSE_LINK = 13,
	FUSE_OPEN = 14,
	FUSE_READ = 15,
	FUSE_WRITE = 16,
	FUSE_STATFS = 17,
	FUSE_RELEASE = 18,
	FUSE_FSYNC = 20,
	FUSE_SETXATTR = 21,
	FUSE_GETXATTR = 22,
	FUSE_LISTXATTR = 23,
	FUSE_REMOVEXATTR = 24,
	FUSE_FLUSH = 25,
	FUSE_INIT = 26,
	FUSE_OPENDIR = 27,
	FUSE_READDIR = 28,
	FUSE_RELEASEDIR = 29,
	FUSE_FSYNCDIR = 30,
	FUSE_GETLK = 31,
	FUSE_SETLK = 32,
	FUSE_SETLKW = 33,
	FUSE_ACCESS = 34,
	FUSE_CREATE = 35,
	FUSE_INTERRUPT = 36,
	FUSE_BMAP = 37,
	FUSE_DESTROY = 38,
	FUSE_IOCTL = 39,
	FUSE_POLL = 40,
	FUSE_NOTIFY_REPLY = 41,
	FUSE_BATCH_FORGET = 42,
	FUSE_FALLOCATE = 43,
	FUSE_READDIRPLUS = 44,
	FUSE_RENAME2 = 45,
	FUSE_LSEEK = 46,
	FUSE_COPY_FILE_RANGE = 47,
	FUSE_SETUPMAPPING = 48,
	FUSE_REMOVEMAPPING = 49,
	FUSE_SYNCFS = 50,
	FUSE_TMPFILE = 51,
	FUSE_STATX = 52,
	CUSE_INIT = 4096,
	CUSE_INIT_BSWAP_RESERVED = 1048576,
	FUSE_INIT_BSWAP_RESERVED = 436207616,
};

enum fuse_parse_result {
	FOUND_ERR = -1,
	FOUND_NONE = 0,
	FOUND_SOME = 1,
	FOUND_ALL = 2,
};

enum fuse_req_flag {
	FR_ISREPLY = 0,
	FR_FORCE = 1,
	FR_BACKGROUND = 2,
	FR_WAITING = 3,
	FR_ABORTED = 4,
	FR_INTERRUPTED = 5,
	FR_LOCKED = 6,
	FR_PENDING = 7,
	FR_SENT = 8,
	FR_FINISHED = 9,
	FR_PRIVATE = 10,
	FR_ASYNC = 11,
	FR_URING = 12,
};

enum fuse_ring_req_state {
	FRRS_INVALID = 0,
	FRRS_COMMIT = 1,
	FRRS_AVAILABLE = 2,
	FRRS_FUSE_REQ = 3,
	FRRS_USERSPACE = 4,
	FRRS_TEARDOWN = 5,
	FRRS_RELEASED = 6,
};

enum fuse_uring_cmd {
	FUSE_IO_URING_CMD_INVALID = 0,
	FUSE_IO_URING_CMD_REGISTER = 1,
	FUSE_IO_URING_CMD_COMMIT_AND_FETCH = 2,
};

enum futex_access {
	FUTEX_READ = 0,
	FUTEX_WRITE = 1,
};

enum fw_hdcp_status {
	FW_HDCP_STATUS_SUCCESS = 0,
	FW_HDCP_STATUS_INTERNAL_ERROR = 4096,
	FW_HDCP_STATUS_UNKNOWN_ERROR = 4097,
	FW_HDCP_STATUS_INCORRECT_API_VERSION = 4098,
	FW_HDCP_STATUS_INVALID_FUNCTION = 4099,
	FW_HDCP_STATUS_INVALID_BUFFER_LENGTH = 4100,
	FW_HDCP_STATUS_INVALID_PARAMS = 4101,
	FW_HDCP_STATUS_AUTHENTICATION_FAILED = 4102,
	FW_HDCP_INVALID_SESSION_STATE = 24576,
	FW_HDCP_SRM_FRAGMENT_UNEXPECTED = 24577,
	FW_HDCP_SRM_INVALID_LENGTH = 24578,
	FW_HDCP_SRM_FRAGMENT_OFFSET_INVALID = 24579,
	FW_HDCP_SRM_VERIFICATION_FAILED = 24580,
	FW_HDCP_SRM_VERSION_TOO_OLD = 24581,
	FW_HDCP_RX_CERT_VERIFICATION_FAILED = 24582,
	FW_HDCP_RX_REVOKED = 24583,
	FW_HDCP_H_VERIFICATION_FAILED = 24584,
	FW_HDCP_REPEATER_CHECK_UNEXPECTED = 24585,
	FW_HDCP_TOPOLOGY_MAX_EXCEEDED = 24586,
	FW_HDCP_V_VERIFICATION_FAILED = 24587,
	FW_HDCP_L_VERIFICATION_FAILED = 24588,
	FW_HDCP_STREAM_KEY_ALLOC_FAILED = 24589,
	FW_HDCP_BASE_KEY_RESET_FAILED = 24590,
	FW_HDCP_NONCE_GENERATION_FAILED = 24591,
	FW_HDCP_STATUS_INVALID_E_KEY_STATE = 24592,
	FW_HDCP_STATUS_INVALID_CS_ICV = 24593,
	FW_HDCP_STATUS_INVALID_KB_KEY_STATE = 24594,
	FW_HDCP_STATUS_INVALID_PAVP_MODE_ICV = 24595,
	FW_HDCP_STATUS_INVALID_PAVP_MODE = 24596,
	FW_HDCP_STATUS_LC_MAX_ATTEMPTS = 24597,
	FW_HDCP_STATUS_MISMATCH_IN_M = 24598,
	FW_HDCP_STATUS_RX_PROV_NOT_ALLOWED = 24599,
	FW_HDCP_STATUS_RX_PROV_WRONG_SUBJECT = 24600,
	FW_HDCP_RX_NEEDS_PROVISIONING = 24601,
	FW_HDCP_BKSV_ICV_AUTH_FAILED = 24608,
	FW_HDCP_STATUS_INVALID_STREAM_ID = 24609,
	FW_HDCP_STATUS_CHAIN_NOT_INITIALIZED = 24610,
	FW_HDCP_FAIL_NOT_EXPECTED = 24611,
	FW_HDCP_FAIL_HDCP_OFF = 24612,
	FW_HDCP_FAIL_INVALID_PAVP_MEMORY_MODE = 24613,
	FW_HDCP_FAIL_AES_ECB_FAILURE = 24614,
	FW_HDCP_FEATURE_NOT_SUPPORTED = 24615,
	FW_HDCP_DMA_READ_ERROR = 24616,
	FW_HDCP_DMA_WRITE_ERROR = 24617,
	FW_HDCP_FAIL_INVALID_PACKET_SIZE = 24624,
	FW_HDCP_H264_PARSING_ERROR = 24625,
	FW_HDCP_HDCP2_ERRATA_VIDEO_VIOLATION = 24626,
	FW_HDCP_HDCP2_ERRATA_AUDIO_VIOLATION = 24627,
	FW_HDCP_TX_ACTIVE_ERROR = 24628,
	FW_HDCP_MODE_CHANGE_ERROR = 24629,
	FW_HDCP_STREAM_TYPE_ERROR = 24630,
	FW_HDCP_STREAM_MANAGE_NOT_POSSIBLE = 24631,
	FW_HDCP_STATUS_PORT_INVALID_COMMAND = 24632,
	FW_HDCP_STATUS_UNSUPPORTED_PROTOCOL = 24633,
	FW_HDCP_STATUS_INVALID_PORT_INDEX = 24634,
	FW_HDCP_STATUS_TX_AUTH_NEEDED = 24635,
	FW_HDCP_STATUS_NOT_INTEGRATED_PORT = 24636,
	FW_HDCP_STATUS_SESSION_MAX_REACHED = 24637,
	FW_HDCP_STATUS_NOT_HDCP_CAPABLE = 24641,
	FW_HDCP_STATUS_INVALID_STREAM_COUNT = 24642,
};

enum fw_opt {
	FW_OPT_UEVENT = 1,
	FW_OPT_NOWAIT = 2,
	FW_OPT_USERHELPER = 4,
	FW_OPT_NO_WARN = 8,
	FW_OPT_NOCACHE = 16,
	FW_OPT_NOFALLBACK_SYSFS = 32,
	FW_OPT_FALLBACK_PLATFORM = 64,
	FW_OPT_PARTIAL = 128,
};

enum fw_status {
	FW_STATUS_UNKNOWN = 0,
	FW_STATUS_LOADING = 1,
	FW_STATUS_DONE = 2,
	FW_STATUS_ABORTED = 3,
};

enum g4x_wm_level {
	G4X_WM_LEVEL_NORMAL = 0,
	G4X_WM_LEVEL_SR = 1,
	G4X_WM_LEVEL_HPLL = 2,
	NUM_G4X_WM_LEVELS = 3,
};

enum gds_mitigations {
	GDS_MITIGATION_OFF = 0,
	GDS_MITIGATION_UCODE_NEEDED = 1,
	GDS_MITIGATION_FORCE = 2,
	GDS_MITIGATION_FULL = 3,
	GDS_MITIGATION_FULL_LOCKED = 4,
	GDS_MITIGATION_HYPERVISOR = 5,
};

enum genl_validate_flags {
	GENL_DONT_VALIDATE_STRICT = 1,
	GENL_DONT_VALIDATE_DUMP = 2,
	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
};

enum gmbus_gpio {
	GPIOA = 0,
	GPIOB = 1,
	GPIOC = 2,
	GPIOD = 3,
	GPIOE = 4,
	GPIOF = 5,
	GPIOG = 6,
	GPIOH = 7,
	__GPIOI_UNUSED = 8,
	GPIOJ = 9,
	GPIOK = 10,
	GPIOL = 11,
	GPIOM = 12,
	GPION = 13,
	GPIOO = 14,
};

enum gpio_lookup_flags {
	GPIO_ACTIVE_HIGH = 0,
	GPIO_ACTIVE_LOW = 1,
	GPIO_OPEN_DRAIN = 2,
	GPIO_OPEN_SOURCE = 4,
	GPIO_PERSISTENT = 0,
	GPIO_TRANSITORY = 8,
	GPIO_PULL_UP = 16,
	GPIO_PULL_DOWN = 32,
	GPIO_PULL_DISABLE = 64,
	GPIO_LOOKUP_FLAGS_DEFAULT = 0,
};

enum gpiod_flags {
	GPIOD_ASIS = 0,
	GPIOD_IN = 1,
	GPIOD_OUT_LOW = 3,
	GPIOD_OUT_HIGH = 7,
	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
};

enum gre_conntrack {
	GRE_CT_UNREPLIED = 0,
	GRE_CT_REPLIED = 1,
	GRE_CT_MAX = 2,
};

enum gro_result {
	GRO_MERGED = 0,
	GRO_MERGED_FREE = 1,
	GRO_HELD = 2,
	GRO_NORMAL = 3,
	GRO_CONSUMED = 4,
};

typedef enum gro_result gro_result_t;

enum group_type {
	group_has_spare = 0,
	group_fully_busy = 1,
	group_misfit_task = 2,
	group_smt_balance = 3,
	group_asym_packing = 4,
	group_imbalanced = 5,
	group_overloaded = 6,
};

enum guc_capture_group_types {
	GUC_STATE_CAPTURE_GROUP_TYPE_FULL = 0,
	GUC_STATE_CAPTURE_GROUP_TYPE_PARTIAL = 1,
	GUC_STATE_CAPTURE_GROUP_TYPE_MAX = 2,
};

enum guc_capture_type {
	GUC_CAPTURE_LIST_TYPE_GLOBAL = 0,
	GUC_CAPTURE_LIST_TYPE_ENGINE_CLASS = 1,
	GUC_CAPTURE_LIST_TYPE_ENGINE_INSTANCE = 2,
	GUC_CAPTURE_LIST_TYPE_MAX = 3,
};

enum guc_log_buffer_type {
	GUC_DEBUG_LOG_BUFFER = 0,
	GUC_CRASH_DUMP_LOG_BUFFER = 1,
	GUC_CAPTURE_LOG_BUFFER = 2,
	GUC_MAX_LOG_BUFFER = 3,
};

enum gve_adminq_extended_cmd_opcodes {
	GVE_ADMINQ_CONFIGURE_FLOW_RULE = 257,
};

enum gve_adminq_flow_rule_cfg_opcode {
	GVE_FLOW_RULE_CFG_ADD = 0,
	GVE_FLOW_RULE_CFG_DEL = 1,
	GVE_FLOW_RULE_CFG_RESET = 2,
};

enum gve_adminq_flow_rule_query_opcode {
	GVE_FLOW_RULE_QUERY_RULES = 0,
	GVE_FLOW_RULE_QUERY_IDS = 1,
	GVE_FLOW_RULE_QUERY_STATS = 2,
};

enum gve_adminq_flow_type {
	GVE_FLOW_TYPE_TCPV4 = 0,
	GVE_FLOW_TYPE_UDPV4 = 1,
	GVE_FLOW_TYPE_SCTPV4 = 2,
	GVE_FLOW_TYPE_AHV4 = 3,
	GVE_FLOW_TYPE_ESPV4 = 4,
	GVE_FLOW_TYPE_TCPV6 = 5,
	GVE_FLOW_TYPE_UDPV6 = 6,
	GVE_FLOW_TYPE_SCTPV6 = 7,
	GVE_FLOW_TYPE_AHV6 = 8,
	GVE_FLOW_TYPE_ESPV6 = 9,
};

enum gve_adminq_opcodes {
	GVE_ADMINQ_DESCRIBE_DEVICE = 1,
	GVE_ADMINQ_CONFIGURE_DEVICE_RESOURCES = 2,
	GVE_ADMINQ_REGISTER_PAGE_LIST = 3,
	GVE_ADMINQ_UNREGISTER_PAGE_LIST = 4,
	GVE_ADMINQ_CREATE_TX_QUEUE = 5,
	GVE_ADMINQ_CREATE_RX_QUEUE = 6,
	GVE_ADMINQ_DESTROY_TX_QUEUE = 7,
	GVE_ADMINQ_DESTROY_RX_QUEUE = 8,
	GVE_ADMINQ_DECONFIGURE_DEVICE_RESOURCES = 9,
	GVE_ADMINQ_CONFIGURE_RSS = 10,
	GVE_ADMINQ_SET_DRIVER_PARAMETER = 11,
	GVE_ADMINQ_REPORT_STATS = 12,
	GVE_ADMINQ_REPORT_LINK_SPEED = 13,
	GVE_ADMINQ_GET_PTYPE_MAP = 14,
	GVE_ADMINQ_VERIFY_DRIVER_COMPATIBILITY = 15,
	GVE_ADMINQ_QUERY_FLOW_RULES = 16,
	GVE_ADMINQ_QUERY_RSS = 18,
	GVE_ADMINQ_EXTENDED_COMMAND = 255,
};

enum gve_adminq_statuses {
	GVE_ADMINQ_COMMAND_UNSET = 0,
	GVE_ADMINQ_COMMAND_PASSED = 1,
	GVE_ADMINQ_COMMAND_ERROR_ABORTED = 4294967280,
	GVE_ADMINQ_COMMAND_ERROR_ALREADY_EXISTS = 4294967281,
	GVE_ADMINQ_COMMAND_ERROR_CANCELLED = 4294967282,
	GVE_ADMINQ_COMMAND_ERROR_DATALOSS = 4294967283,
	GVE_ADMINQ_COMMAND_ERROR_DEADLINE_EXCEEDED = 4294967284,
	GVE_ADMINQ_COMMAND_ERROR_FAILED_PRECONDITION = 4294967285,
	GVE_ADMINQ_COMMAND_ERROR_INTERNAL_ERROR = 4294967286,
	GVE_ADMINQ_COMMAND_ERROR_INVALID_ARGUMENT = 4294967287,
	GVE_ADMINQ_COMMAND_ERROR_NOT_FOUND = 4294967288,
	GVE_ADMINQ_COMMAND_ERROR_OUT_OF_RANGE = 4294967289,
	GVE_ADMINQ_COMMAND_ERROR_PERMISSION_DENIED = 4294967290,
	GVE_ADMINQ_COMMAND_ERROR_UNAUTHENTICATED = 4294967291,
	GVE_ADMINQ_COMMAND_ERROR_RESOURCE_EXHAUSTED = 4294967292,
	GVE_ADMINQ_COMMAND_ERROR_UNAVAILABLE = 4294967293,
	GVE_ADMINQ_COMMAND_ERROR_UNIMPLEMENTED = 4294967294,
	GVE_ADMINQ_COMMAND_ERROR_UNKNOWN_ERROR = 4294967295,
};

enum gve_dev_opt_id {
	GVE_DEV_OPT_ID_GQI_RAW_ADDRESSING = 1,
	GVE_DEV_OPT_ID_GQI_RDA = 2,
	GVE_DEV_OPT_ID_GQI_QPL = 3,
	GVE_DEV_OPT_ID_DQO_RDA = 4,
	GVE_DEV_OPT_ID_MODIFY_RING = 6,
	GVE_DEV_OPT_ID_DQO_QPL = 7,
	GVE_DEV_OPT_ID_JUMBO_FRAMES = 8,
	GVE_DEV_OPT_ID_BUFFER_SIZES = 10,
	GVE_DEV_OPT_ID_FLOW_STEERING = 11,
	GVE_DEV_OPT_ID_RSS_CONFIG = 14,
};

enum gve_dev_opt_req_feat_mask {
	GVE_DEV_OPT_REQ_FEAT_MASK_GQI_RAW_ADDRESSING = 0,
	GVE_DEV_OPT_REQ_FEAT_MASK_GQI_RDA = 0,
	GVE_DEV_OPT_REQ_FEAT_MASK_GQI_QPL = 0,
	GVE_DEV_OPT_REQ_FEAT_MASK_DQO_RDA = 0,
	GVE_DEV_OPT_REQ_FEAT_MASK_JUMBO_FRAMES = 0,
	GVE_DEV_OPT_REQ_FEAT_MASK_DQO_QPL = 0,
	GVE_DEV_OPT_REQ_FEAT_MASK_BUFFER_SIZES = 0,
	GVE_DEV_OPT_REQ_FEAT_MASK_MODIFY_RING = 0,
	GVE_DEV_OPT_REQ_FEAT_MASK_FLOW_STEERING = 0,
	GVE_DEV_OPT_REQ_FEAT_MASK_RSS_CONFIG = 0,
};

enum gve_device_status_flags {
	GVE_DEVICE_STATUS_RESET_MASK = 2,
	GVE_DEVICE_STATUS_LINK_STATUS_MASK = 4,
	GVE_DEVICE_STATUS_REPORT_STATS_MASK = 8,
	GVE_DEVICE_STATUS_DEVICE_IS_RESET = 16,
};

enum gve_driver_capbility {
	gve_driver_capability_gqi_qpl = 0,
	gve_driver_capability_gqi_rda = 1,
	gve_driver_capability_dqo_qpl = 2,
	gve_driver_capability_dqo_rda = 3,
	gve_driver_capability_alt_miss_compl = 4,
	gve_driver_capability_flexible_buffer_size = 5,
	gve_driver_capability_flexible_rss_size = 6,
};

enum gve_driver_status_flags {
	GVE_DRIVER_STATUS_RUN_MASK = 1,
	GVE_DRIVER_STATUS_RESET_MASK = 2,
};

enum gve_ethtool_flags_bit {
	GVE_PRIV_FLAGS_REPORT_STATS = 0,
};

enum gve_l3_type {
	GVE_L3_TYPE_UNKNOWN = 0,
	GVE_L3_TYPE_OTHER = 1,
	GVE_L3_TYPE_IPV4 = 2,
	GVE_L3_TYPE_IPV6 = 3,
};

enum gve_l4_type {
	GVE_L4_TYPE_UNKNOWN = 0,
	GVE_L4_TYPE_OTHER = 1,
	GVE_L4_TYPE_TCP = 2,
	GVE_L4_TYPE_UDP = 3,
	GVE_L4_TYPE_ICMP = 4,
	GVE_L4_TYPE_SCTP = 5,
};

enum gve_packet_state {
	GVE_PACKET_STATE_UNALLOCATED = 0,
	GVE_PACKET_STATE_PENDING_DATA_COMPL = 1,
	GVE_PACKET_STATE_PENDING_REINJECT_COMPL = 2,
	GVE_PACKET_STATE_TIMED_OUT_COMPL = 3,
};

enum gve_queue_format {
	GVE_QUEUE_FORMAT_UNSPECIFIED = 0,
	GVE_GQI_RDA_FORMAT = 1,
	GVE_GQI_QPL_FORMAT = 2,
	GVE_DQO_RDA_FORMAT = 3,
	GVE_DQO_QPL_FORMAT = 4,
};

enum gve_rss_hash_type {
	GVE_RSS_HASH_IPV4 = 0,
	GVE_RSS_HASH_TCPV4 = 1,
	GVE_RSS_HASH_IPV6 = 2,
	GVE_RSS_HASH_IPV6_EX = 3,
	GVE_RSS_HASH_TCPV6 = 4,
	GVE_RSS_HASH_TCPV6_EX = 5,
	GVE_RSS_HASH_UDPV4 = 6,
	GVE_RSS_HASH_UDPV6 = 7,
	GVE_RSS_HASH_UDPV6_EX = 8,
};

enum gve_service_task_flags_bit {
	GVE_PRIV_FLAGS_DO_RESET = 1,
	GVE_PRIV_FLAGS_RESET_IN_PROGRESS = 2,
	GVE_PRIV_FLAGS_PROBE_IN_PROGRESS = 3,
	GVE_PRIV_FLAGS_DO_REPORT_STATS = 4,
};

enum gve_stat_names {
	TX_WAKE_CNT = 1,
	TX_STOP_CNT = 2,
	TX_FRAMES_SENT = 3,
	TX_BYTES_SENT = 4,
	TX_LAST_COMPLETION_PROCESSED = 5,
	RX_NEXT_EXPECTED_SEQUENCE = 6,
	RX_BUFFERS_POSTED = 7,
	TX_TIMEOUT_CNT = 8,
	RX_QUEUE_DROP_CNT = 65,
	RX_NO_BUFFERS_POSTED = 66,
	RX_DROPS_PACKET_OVER_MRU = 67,
	RX_DROPS_INVALID_CHECKSUM = 68,
};

enum gve_state_flags_bit {
	GVE_PRIV_FLAGS_ADMIN_QUEUE_OK = 1,
	GVE_PRIV_FLAGS_DEVICE_RESOURCES_OK = 2,
	GVE_PRIV_FLAGS_DEVICE_RINGS_OK = 3,
	GVE_PRIV_FLAGS_NAPI_ENABLED = 4,
};

enum gve_sup_feature_mask {
	GVE_SUP_MODIFY_RING_MASK = 1,
	GVE_SUP_JUMBO_FRAMES_MASK = 4,
	GVE_SUP_BUFFER_SIZES_MASK = 16,
	GVE_SUP_FLOW_STEERING_MASK = 32,
	GVE_SUP_RSS_CONFIG_MASK = 128,
};

enum handle_to_path_flags {
	HANDLE_CHECK_PERMS = 1,
	HANDLE_CHECK_SUBTREE = 2,
};

enum handshake_auth {
	HANDSHAKE_AUTH_UNSPEC = 0,
	HANDSHAKE_AUTH_UNAUTH = 1,
	HANDSHAKE_AUTH_PSK = 2,
	HANDSHAKE_AUTH_X509 = 3,
};

enum handshake_handler_class {
	HANDSHAKE_HANDLER_CLASS_NONE = 0,
	HANDSHAKE_HANDLER_CLASS_TLSHD = 1,
	HANDSHAKE_HANDLER_CLASS_MAX = 2,
};

enum handshake_msg_type {
	HANDSHAKE_MSG_TYPE_UNSPEC = 0,
	HANDSHAKE_MSG_TYPE_CLIENTHELLO = 1,
	HANDSHAKE_MSG_TYPE_SERVERHELLO = 2,
};

enum hash_algo {
	HASH_ALGO_MD4 = 0,
	HASH_ALGO_MD5 = 1,
	HASH_ALGO_SHA1 = 2,
	HASH_ALGO_RIPE_MD_160 = 3,
	HASH_ALGO_SHA256 = 4,
	HASH_ALGO_SHA384 = 5,
	HASH_ALGO_SHA512 = 6,
	HASH_ALGO_SHA224 = 7,
	HASH_ALGO_RIPE_MD_128 = 8,
	HASH_ALGO_RIPE_MD_256 = 9,
	HASH_ALGO_RIPE_MD_320 = 10,
	HASH_ALGO_WP_256 = 11,
	HASH_ALGO_WP_384 = 12,
	HASH_ALGO_WP_512 = 13,
	HASH_ALGO_TGR_128 = 14,
	HASH_ALGO_TGR_160 = 15,
	HASH_ALGO_TGR_192 = 16,
	HASH_ALGO_SM3_256 = 17,
	HASH_ALGO_STREEBOG_256 = 18,
	HASH_ALGO_STREEBOG_512 = 19,
	HASH_ALGO_SHA3_256 = 20,
	HASH_ALGO_SHA3_384 = 21,
	HASH_ALGO_SHA3_512 = 22,
	HASH_ALGO__LAST = 23,
};

enum hbm_host_enum_flags {
	MEI_HBM_ENUM_F_ALLOW_ADD = 1,
	MEI_HBM_ENUM_F_IMMEDIATE_ENUM = 2,
};

enum hctx_type {
	HCTX_TYPE_DEFAULT = 0,
	HCTX_TYPE_READ = 1,
	HCTX_TYPE_POLL = 2,
	HCTX_MAX_TYPES = 3,
};

enum hdcp_command_id {
	_WIDI_COMMAND_BASE = 196608,
	WIDI_INITIATE_HDCP2_SESSION = 196608,
	HDCP_GET_SRM_STATUS = 196609,
	HDCP_SEND_SRM_FRAGMENT = 196610,
	_WIRED_COMMAND_BASE = 200704,
	WIRED_INITIATE_HDCP2_SESSION = 200704,
	WIRED_VERIFY_RECEIVER_CERT = 200705,
	WIRED_AKE_SEND_HPRIME = 200706,
	WIRED_AKE_SEND_PAIRING_INFO = 200707,
	WIRED_INIT_LOCALITY_CHECK = 200708,
	WIRED_VALIDATE_LOCALITY = 200709,
	WIRED_GET_SESSION_KEY = 200710,
	WIRED_ENABLE_AUTH = 200711,
	WIRED_VERIFY_REPEATER = 200712,
	WIRED_REPEATER_AUTH_STREAM_REQ = 200713,
	WIRED_CLOSE_SESSION = 200714,
	_WIRED_COMMANDS_COUNT = 200715,
};

enum hdcp_ddi {
	HDCP_DDI_INVALID_PORT = 0,
	HDCP_DDI_B = 1,
	HDCP_DDI_C = 2,
	HDCP_DDI_D = 3,
	HDCP_DDI_E = 4,
	HDCP_DDI_F = 5,
	HDCP_DDI_A = 7,
	HDCP_DDI_RANGE_END = 7,
};

enum hdcp_port_type {
	HDCP_PORT_TYPE_INVALID = 0,
	HDCP_PORT_TYPE_INTEGRATED = 1,
	HDCP_PORT_TYPE_LSPCON = 2,
	HDCP_PORT_TYPE_CPDP = 3,
};

enum hdcp_transcoder {
	HDCP_INVALID_TRANSCODER = 0,
	HDCP_TRANSCODER_EDP = 1,
	HDCP_TRANSCODER_DSI0 = 2,
	HDCP_TRANSCODER_DSI1 = 3,
	HDCP_TRANSCODER_A = 16,
	HDCP_TRANSCODER_B = 17,
	HDCP_TRANSCODER_C = 18,
	HDCP_TRANSCODER_D = 19,
};

enum hdcp_wired_protocol {
	HDCP_PROTOCOL_INVALID = 0,
	HDCP_PROTOCOL_HDMI = 1,
	HDCP_PROTOCOL_DP = 2,
};

enum hdmi_3d_structure {
	HDMI_3D_STRUCTURE_INVALID = -1,
	HDMI_3D_STRUCTURE_FRAME_PACKING = 0,
	HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE = 1,
	HDMI_3D_STRUCTURE_LINE_ALTERNATIVE = 2,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL = 3,
	HDMI_3D_STRUCTURE_L_DEPTH = 4,
	HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH = 5,
	HDMI_3D_STRUCTURE_TOP_AND_BOTTOM = 6,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF = 8,
};

enum hdmi_active_aspect {
	HDMI_ACTIVE_ASPECT_16_9_TOP = 2,
	HDMI_ACTIVE_ASPECT_14_9_TOP = 3,
	HDMI_ACTIVE_ASPECT_16_9_CENTER = 4,
	HDMI_ACTIVE_ASPECT_PICTURE = 8,
	HDMI_ACTIVE_ASPECT_4_3 = 9,
	HDMI_ACTIVE_ASPECT_16_9 = 10,
	HDMI_ACTIVE_ASPECT_14_9 = 11,
	HDMI_ACTIVE_ASPECT_4_3_SP_14_9 = 13,
	HDMI_ACTIVE_ASPECT_16_9_SP_14_9 = 14,
	HDMI_ACTIVE_ASPECT_16_9_SP_4_3 = 15,
};

enum hdmi_audio_coding_type {
	HDMI_AUDIO_CODING_TYPE_STREAM = 0,
	HDMI_AUDIO_CODING_TYPE_PCM = 1,
	HDMI_AUDIO_CODING_TYPE_AC3 = 2,
	HDMI_AUDIO_CODING_TYPE_MPEG1 = 3,
	HDMI_AUDIO_CODING_TYPE_MP3 = 4,
	HDMI_AUDIO_CODING_TYPE_MPEG2 = 5,
	HDMI_AUDIO_CODING_TYPE_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_DTS = 7,
	HDMI_AUDIO_CODING_TYPE_ATRAC = 8,
	HDMI_AUDIO_CODING_TYPE_DSD = 9,
	HDMI_AUDIO_CODING_TYPE_EAC3 = 10,
	HDMI_AUDIO_CODING_TYPE_DTS_HD = 11,
	HDMI_AUDIO_CODING_TYPE_MLP = 12,
	HDMI_AUDIO_CODING_TYPE_DST = 13,
	HDMI_AUDIO_CODING_TYPE_WMA_PRO = 14,
	HDMI_AUDIO_CODING_TYPE_CXT = 15,
};

enum hdmi_audio_coding_type_ext {
	HDMI_AUDIO_CODING_TYPE_EXT_CT = 0,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC = 1,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2 = 2,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND = 3,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC = 4,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2 = 5,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_EXT_DRA = 7,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND = 8,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND = 10,
};

enum hdmi_audio_sample_frequency {
	HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM = 0,
	HDMI_AUDIO_SAMPLE_FREQUENCY_32000 = 1,
	HDMI_AUDIO_SAMPLE_FREQUENCY_44100 = 2,
	HDMI_AUDIO_SAMPLE_FREQUENCY_48000 = 3,
	HDMI_AUDIO_SAMPLE_FREQUENCY_88200 = 4,
	HDMI_AUDIO_SAMPLE_FREQUENCY_96000 = 5,
	HDMI_AUDIO_SAMPLE_FREQUENCY_176400 = 6,
	HDMI_AUDIO_SAMPLE_FREQUENCY_192000 = 7,
};

enum hdmi_audio_sample_size {
	HDMI_AUDIO_SAMPLE_SIZE_STREAM = 0,
	HDMI_AUDIO_SAMPLE_SIZE_16 = 1,
	HDMI_AUDIO_SAMPLE_SIZE_20 = 2,
	HDMI_AUDIO_SAMPLE_SIZE_24 = 3,
};

enum hdmi_colorimetry {
	HDMI_COLORIMETRY_NONE = 0,
	HDMI_COLORIMETRY_ITU_601 = 1,
	HDMI_COLORIMETRY_ITU_709 = 2,
	HDMI_COLORIMETRY_EXTENDED = 3,
};

enum hdmi_colorspace {
	HDMI_COLORSPACE_RGB = 0,
	HDMI_COLORSPACE_YUV422 = 1,
	HDMI_COLORSPACE_YUV444 = 2,
	HDMI_COLORSPACE_YUV420 = 3,
	HDMI_COLORSPACE_RESERVED4 = 4,
	HDMI_COLORSPACE_RESERVED5 = 5,
	HDMI_COLORSPACE_RESERVED6 = 6,
	HDMI_COLORSPACE_IDO_DEFINED = 7,
};

enum hdmi_content_type {
	HDMI_CONTENT_TYPE_GRAPHICS = 0,
	HDMI_CONTENT_TYPE_PHOTO = 1,
	HDMI_CONTENT_TYPE_CINEMA = 2,
	HDMI_CONTENT_TYPE_GAME = 3,
};

enum hdmi_eotf {
	HDMI_EOTF_TRADITIONAL_GAMMA_SDR = 0,
	HDMI_EOTF_TRADITIONAL_GAMMA_HDR = 1,
	HDMI_EOTF_SMPTE_ST2084 = 2,
	HDMI_EOTF_BT_2100_HLG = 3,
};

enum hdmi_extended_colorimetry {
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_601 = 0,
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_709 = 1,
	HDMI_EXTENDED_COLORIMETRY_S_YCC_601 = 2,
	HDMI_EXTENDED_COLORIMETRY_OPYCC_601 = 3,
	HDMI_EXTENDED_COLORIMETRY_OPRGB = 4,
	HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM = 5,
	HDMI_EXTENDED_COLORIMETRY_BT2020 = 6,
	HDMI_EXTENDED_COLORIMETRY_RESERVED = 7,
};

enum hdmi_force_audio {
	HDMI_AUDIO_OFF_DVI = -2,
	HDMI_AUDIO_OFF = -1,
	HDMI_AUDIO_AUTO = 0,
	HDMI_AUDIO_ON = 1,
};

enum hdmi_infoframe_type {
	HDMI_INFOFRAME_TYPE_VENDOR = 129,
	HDMI_INFOFRAME_TYPE_AVI = 130,
	HDMI_INFOFRAME_TYPE_SPD = 131,
	HDMI_INFOFRAME_TYPE_AUDIO = 132,
	HDMI_INFOFRAME_TYPE_DRM = 135,
};

enum hdmi_metadata_type {
	HDMI_STATIC_METADATA_TYPE1 = 0,
};

enum hdmi_nups {
	HDMI_NUPS_UNKNOWN = 0,
	HDMI_NUPS_HORIZONTAL = 1,
	HDMI_NUPS_VERTICAL = 2,
	HDMI_NUPS_BOTH = 3,
};

enum hdmi_packet_type {
	HDMI_PACKET_TYPE_NULL = 0,
	HDMI_PACKET_TYPE_AUDIO_CLOCK_REGEN = 1,
	HDMI_PACKET_TYPE_AUDIO_SAMPLE = 2,
	HDMI_PACKET_TYPE_GENERAL_CONTROL = 3,
	HDMI_PACKET_TYPE_ACP = 4,
	HDMI_PACKET_TYPE_ISRC1 = 5,
	HDMI_PACKET_TYPE_ISRC2 = 6,
	HDMI_PACKET_TYPE_ONE_BIT_AUDIO_SAMPLE = 7,
	HDMI_PACKET_TYPE_DST_AUDIO = 8,
	HDMI_PACKET_TYPE_HBR_AUDIO_STREAM = 9,
	HDMI_PACKET_TYPE_GAMUT_METADATA = 10,
};

enum hdmi_picture_aspect {
	HDMI_PICTURE_ASPECT_NONE = 0,
	HDMI_PICTURE_ASPECT_4_3 = 1,
	HDMI_PICTURE_ASPECT_16_9 = 2,
	HDMI_PICTURE_ASPECT_64_27 = 3,
	HDMI_PICTURE_ASPECT_256_135 = 4,
	HDMI_PICTURE_ASPECT_RESERVED = 5,
};

enum hdmi_quantization_range {
	HDMI_QUANTIZATION_RANGE_DEFAULT = 0,
	HDMI_QUANTIZATION_RANGE_LIMITED = 1,
	HDMI_QUANTIZATION_RANGE_FULL = 2,
	HDMI_QUANTIZATION_RANGE_RESERVED = 3,
};

enum hdmi_scan_mode {
	HDMI_SCAN_MODE_NONE = 0,
	HDMI_SCAN_MODE_OVERSCAN = 1,
	HDMI_SCAN_MODE_UNDERSCAN = 2,
	HDMI_SCAN_MODE_RESERVED = 3,
};

enum hdmi_spd_sdi {
	HDMI_SPD_SDI_UNKNOWN = 0,
	HDMI_SPD_SDI_DSTB = 1,
	HDMI_SPD_SDI_DVDP = 2,
	HDMI_SPD_SDI_DVHS = 3,
	HDMI_SPD_SDI_HDDVR = 4,
	HDMI_SPD_SDI_DVC = 5,
	HDMI_SPD_SDI_DSC = 6,
	HDMI_SPD_SDI_VCD = 7,
	HDMI_SPD_SDI_GAME = 8,
	HDMI_SPD_SDI_PC = 9,
	HDMI_SPD_SDI_BD = 10,
	HDMI_SPD_SDI_SACD = 11,
	HDMI_SPD_SDI_HDDVD = 12,
	HDMI_SPD_SDI_PMP = 13,
};

enum hdmi_ycc_quantization_range {
	HDMI_YCC_QUANTIZATION_RANGE_LIMITED = 0,
	HDMI_YCC_QUANTIZATION_RANGE_FULL = 1,
};

enum header_fields {
	HDR_PCR = 0,
	HDR_DIGEST = 1,
	HDR_TEMPLATE_NAME = 2,
	HDR_TEMPLATE_DATA = 3,
	HDR__LAST = 4,
};

enum hfsc_class_flags {
	HFSC_RSC = 1,
	HFSC_FSC = 2,
	HFSC_USC = 4,
};

enum hk_flags {
	HK_FLAG_DOMAIN = 1,
	HK_FLAG_MANAGED_IRQ = 2,
	HK_FLAG_KERNEL_NOISE = 4,
};

enum hk_type {
	HK_TYPE_DOMAIN = 0,
	HK_TYPE_MANAGED_IRQ = 1,
	HK_TYPE_KERNEL_NOISE = 2,
	HK_TYPE_MAX = 3,
	HK_TYPE_TICK = 2,
	HK_TYPE_TIMER = 2,
	HK_TYPE_RCU = 2,
	HK_TYPE_MISC = 2,
	HK_TYPE_WQ = 2,
	HK_TYPE_KTHREAD = 2,
};

enum hn_flags_bits {
	HANDSHAKE_F_NET_DRAINING = 0,
};

enum hp_flags_bits {
	HANDSHAKE_F_PROTO_NOTIFY = 0,
};

enum hpd_pin {
	HPD_NONE = 0,
	HPD_TV = 0,
	HPD_CRT = 1,
	HPD_SDVO_B = 2,
	HPD_SDVO_C = 3,
	HPD_PORT_A = 4,
	HPD_PORT_B = 5,
	HPD_PORT_C = 6,
	HPD_PORT_D = 7,
	HPD_PORT_E = 8,
	HPD_PORT_TC1 = 9,
	HPD_PORT_TC2 = 10,
	HPD_PORT_TC3 = 11,
	HPD_PORT_TC4 = 12,
	HPD_PORT_TC5 = 13,
	HPD_PORT_TC6 = 14,
	HPD_NUM_PINS = 15,
};

enum hpet_mode {
	HPET_MODE_UNUSED = 0,
	HPET_MODE_LEGACY = 1,
	HPET_MODE_CLOCKEVT = 2,
	HPET_MODE_DEVICE = 3,
};

enum hprobe_state {
	HPROBE_LEASED = 0,
	HPROBE_STABLE = 1,
	HPROBE_GONE = 2,
	HPROBE_CONSUMED = 3,
};

enum hpx_type3_cfg_loc {
	HPX_CFG_PCICFG = 0,
	HPX_CFG_PCIE_CAP = 1,
	HPX_CFG_PCIE_CAP_EXT = 2,
	HPX_CFG_VEND_CAP = 3,
	HPX_CFG_DVSEC = 4,
	HPX_CFG_MAX = 5,
};

enum hpx_type3_dev_type {
	HPX_TYPE_ENDPOINT = 1,
	HPX_TYPE_LEG_END = 2,
	HPX_TYPE_RC_END = 4,
	HPX_TYPE_RC_EC = 8,
	HPX_TYPE_ROOT_PORT = 16,
	HPX_TYPE_UPSTREAM = 32,
	HPX_TYPE_DOWNSTREAM = 64,
	HPX_TYPE_PCI_BRIDGE = 128,
	HPX_TYPE_PCIE_BRIDGE = 256,
};

enum hpx_type3_fn_type {
	HPX_FN_NORMAL = 1,
	HPX_FN_SRIOV_PHYS = 2,
	HPX_FN_SRIOV_VIRT = 4,
};

enum hr_flags_bits {
	HANDSHAKE_F_REQ_COMPLETED = 0,
	HANDSHAKE_F_REQ_SESSION = 1,
};

enum hrtimer_base_type {
	HRTIMER_BASE_MONOTONIC = 0,
	HRTIMER_BASE_REALTIME = 1,
	HRTIMER_BASE_BOOTTIME = 2,
	HRTIMER_BASE_TAI = 3,
	HRTIMER_BASE_MONOTONIC_SOFT = 4,
	HRTIMER_BASE_REALTIME_SOFT = 5,
	HRTIMER_BASE_BOOTTIME_SOFT = 6,
	HRTIMER_BASE_TAI_SOFT = 7,
	HRTIMER_MAX_CLOCK_BASES = 8,
};

enum hrtimer_mode {
	HRTIMER_MODE_ABS = 0,
	HRTIMER_MODE_REL = 1,
	HRTIMER_MODE_PINNED = 2,
	HRTIMER_MODE_SOFT = 4,
	HRTIMER_MODE_HARD = 8,
	HRTIMER_MODE_ABS_PINNED = 2,
	HRTIMER_MODE_REL_PINNED = 3,
	HRTIMER_MODE_ABS_SOFT = 4,
	HRTIMER_MODE_REL_SOFT = 5,
	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
	HRTIMER_MODE_REL_PINNED_SOFT = 7,
	HRTIMER_MODE_ABS_HARD = 8,
	HRTIMER_MODE_REL_HARD = 9,
	HRTIMER_MODE_ABS_PINNED_HARD = 10,
	HRTIMER_MODE_REL_PINNED_HARD = 11,
};

enum hrtimer_restart {
	HRTIMER_NORESTART = 0,
	HRTIMER_RESTART = 1,
};

enum hsr_port_type {
	HSR_PT_NONE = 0,
	HSR_PT_SLAVE_A = 1,
	HSR_PT_SLAVE_B = 2,
	HSR_PT_INTERLINK = 3,
	HSR_PT_MASTER = 4,
	HSR_PT_PORTS = 5,
};

enum hsr_version {
	HSR_V0 = 0,
	HSR_V1 = 1,
	PRP_V1 = 2,
};

enum htb_cmode {
	HTB_CANT_SEND = 0,
	HTB_MAY_BORROW = 1,
	HTB_CAN_SEND = 2,
};

enum hugetlb_memory_event {
	HUGETLB_MAX = 0,
	HUGETLB_NR_MEMORY_EVENTS = 1,
};

enum hugetlb_page_flags {
	HPG_restore_reserve = 0,
	HPG_migratable = 1,
	HPG_temporary = 2,
	HPG_freed = 3,
	HPG_vmemmap_optimized = 4,
	HPG_raw_hwp_unreliable = 5,
	__NR_HPAGEFLAGS = 6,
};

enum hugetlb_param {
	Opt_gid___8 = 0,
	Opt_min_size = 1,
	Opt_mode___5 = 2,
	Opt_nr_inodes = 3,
	Opt_pagesize = 4,
	Opt_size = 5,
	Opt_uid___8 = 6,
};

enum hugetlbfs_size_type {
	NO_SIZE = 0,
	SIZE_STD = 1,
	SIZE_PERCENT = 2,
};

enum hv_isolation_type {
	HV_ISOLATION_TYPE_NONE = 0,
	HV_ISOLATION_TYPE_VBS = 1,
	HV_ISOLATION_TYPE_SNP = 2,
	HV_ISOLATION_TYPE_TDX = 3,
};

enum hv_tlb_flush_fifos {
	HV_L1_TLB_FLUSH_FIFO = 0,
	HV_L2_TLB_FLUSH_FIFO = 1,
	HV_NR_TLB_FLUSH_FIFOS = 2,
};

enum hv_tsc_page_status {
	HV_TSC_PAGE_UNSET = 0,
	HV_TSC_PAGE_GUEST_CHANGED = 1,
	HV_TSC_PAGE_HOST_CHANGED = 2,
	HV_TSC_PAGE_SET = 3,
	HV_TSC_PAGE_BROKEN = 4,
};

enum hw_protection_action {
	HWPROT_ACT_SHUTDOWN = 0,
	HWPROT_ACT_REBOOT = 1,
};

enum hwmon_chip_attributes {
	hwmon_chip_temp_reset_history = 0,
	hwmon_chip_in_reset_history = 1,
	hwmon_chip_curr_reset_history = 2,
	hwmon_chip_power_reset_history = 3,
	hwmon_chip_register_tz = 4,
	hwmon_chip_update_interval = 5,
	hwmon_chip_alarms = 6,
	hwmon_chip_samples = 7,
	hwmon_chip_curr_samples = 8,
	hwmon_chip_in_samples = 9,
	hwmon_chip_power_samples = 10,
	hwmon_chip_temp_samples = 11,
	hwmon_chip_beep_enable = 12,
	hwmon_chip_pec = 13,
};

enum hwmon_curr_attributes {
	hwmon_curr_enable = 0,
	hwmon_curr_input = 1,
	hwmon_curr_min = 2,
	hwmon_curr_max = 3,
	hwmon_curr_lcrit = 4,
	hwmon_curr_crit = 5,
	hwmon_curr_average = 6,
	hwmon_curr_lowest = 7,
	hwmon_curr_highest = 8,
	hwmon_curr_reset_history = 9,
	hwmon_curr_label = 10,
	hwmon_curr_alarm = 11,
	hwmon_curr_min_alarm = 12,
	hwmon_curr_max_alarm = 13,
	hwmon_curr_lcrit_alarm = 14,
	hwmon_curr_crit_alarm = 15,
	hwmon_curr_rated_min = 16,
	hwmon_curr_rated_max = 17,
	hwmon_curr_beep = 18,
};

enum hwmon_energy_attributes {
	hwmon_energy_enable = 0,
	hwmon_energy_input = 1,
	hwmon_energy_label = 2,
};

enum hwmon_fan_attributes {
	hwmon_fan_enable = 0,
	hwmon_fan_input = 1,
	hwmon_fan_label = 2,
	hwmon_fan_min = 3,
	hwmon_fan_max = 4,
	hwmon_fan_div = 5,
	hwmon_fan_pulses = 6,
	hwmon_fan_target = 7,
	hwmon_fan_alarm = 8,
	hwmon_fan_min_alarm = 9,
	hwmon_fan_max_alarm = 10,
	hwmon_fan_fault = 11,
	hwmon_fan_beep = 12,
};

enum hwmon_humidity_attributes {
	hwmon_humidity_enable = 0,
	hwmon_humidity_input = 1,
	hwmon_humidity_label = 2,
	hwmon_humidity_min = 3,
	hwmon_humidity_min_hyst = 4,
	hwmon_humidity_max = 5,
	hwmon_humidity_max_hyst = 6,
	hwmon_humidity_alarm = 7,
	hwmon_humidity_fault = 8,
	hwmon_humidity_rated_min = 9,
	hwmon_humidity_rated_max = 10,
	hwmon_humidity_min_alarm = 11,
	hwmon_humidity_max_alarm = 12,
};

enum hwmon_in_attributes {
	hwmon_in_enable = 0,
	hwmon_in_input = 1,
	hwmon_in_min = 2,
	hwmon_in_max = 3,
	hwmon_in_lcrit = 4,
	hwmon_in_crit = 5,
	hwmon_in_average = 6,
	hwmon_in_lowest = 7,
	hwmon_in_highest = 8,
	hwmon_in_reset_history = 9,
	hwmon_in_label = 10,
	hwmon_in_alarm = 11,
	hwmon_in_min_alarm = 12,
	hwmon_in_max_alarm = 13,
	hwmon_in_lcrit_alarm = 14,
	hwmon_in_crit_alarm = 15,
	hwmon_in_rated_min = 16,
	hwmon_in_rated_max = 17,
	hwmon_in_beep = 18,
	hwmon_in_fault = 19,
};

enum hwmon_intrusion_attributes {
	hwmon_intrusion_alarm = 0,
	hwmon_intrusion_beep = 1,
};

enum hwmon_power_attributes {
	hwmon_power_enable = 0,
	hwmon_power_average = 1,
	hwmon_power_average_interval = 2,
	hwmon_power_average_interval_max = 3,
	hwmon_power_average_interval_min = 4,
	hwmon_power_average_highest = 5,
	hwmon_power_average_lowest = 6,
	hwmon_power_average_max = 7,
	hwmon_power_average_min = 8,
	hwmon_power_input = 9,
	hwmon_power_input_highest = 10,
	hwmon_power_input_lowest = 11,
	hwmon_power_reset_history = 12,
	hwmon_power_accuracy = 13,
	hwmon_power_cap = 14,
	hwmon_power_cap_hyst = 15,
	hwmon_power_cap_max = 16,
	hwmon_power_cap_min = 17,
	hwmon_power_min = 18,
	hwmon_power_max = 19,
	hwmon_power_crit = 20,
	hwmon_power_lcrit = 21,
	hwmon_power_label = 22,
	hwmon_power_alarm = 23,
	hwmon_power_cap_alarm = 24,
	hwmon_power_min_alarm = 25,
	hwmon_power_max_alarm = 26,
	hwmon_power_lcrit_alarm = 27,
	hwmon_power_crit_alarm = 28,
	hwmon_power_rated_min = 29,
	hwmon_power_rated_max = 30,
};

enum hwmon_pwm_attributes {
	hwmon_pwm_input = 0,
	hwmon_pwm_enable = 1,
	hwmon_pwm_mode = 2,
	hwmon_pwm_freq = 3,
	hwmon_pwm_auto_channels_temp = 4,
};

enum hwmon_sensor_types {
	hwmon_chip = 0,
	hwmon_temp = 1,
	hwmon_in = 2,
	hwmon_curr = 3,
	hwmon_power = 4,
	hwmon_energy = 5,
	hwmon_humidity = 6,
	hwmon_fan = 7,
	hwmon_pwm = 8,
	hwmon_intrusion = 9,
	hwmon_max = 10,
};

enum hwmon_temp_attributes {
	hwmon_temp_enable = 0,
	hwmon_temp_input = 1,
	hwmon_temp_type = 2,
	hwmon_temp_lcrit = 3,
	hwmon_temp_lcrit_hyst = 4,
	hwmon_temp_min = 5,
	hwmon_temp_min_hyst = 6,
	hwmon_temp_max = 7,
	hwmon_temp_max_hyst = 8,
	hwmon_temp_crit = 9,
	hwmon_temp_crit_hyst = 10,
	hwmon_temp_emergency = 11,
	hwmon_temp_emergency_hyst = 12,
	hwmon_temp_alarm = 13,
	hwmon_temp_lcrit_alarm = 14,
	hwmon_temp_min_alarm = 15,
	hwmon_temp_max_alarm = 16,
	hwmon_temp_crit_alarm = 17,
	hwmon_temp_emergency_alarm = 18,
	hwmon_temp_fault = 19,
	hwmon_temp_offset = 20,
	hwmon_temp_label = 21,
	hwmon_temp_lowest = 22,
	hwmon_temp_highest = 23,
	hwmon_temp_reset_history = 24,
	hwmon_temp_rated_min = 25,
	hwmon_temp_rated_max = 26,
	hwmon_temp_beep = 27,
};

enum hwparam_type {
	hwparam_ioport = 0,
	hwparam_iomem = 1,
	hwparam_ioport_or_iomem = 2,
	hwparam_irq = 3,
	hwparam_dma = 4,
	hwparam_dma_addr = 5,
	hwparam_other = 6,
};

enum hwtstamp_flags {
	HWTSTAMP_FLAG_BONDED_PHC_INDEX = 1,
	HWTSTAMP_FLAG_LAST = 1,
	HWTSTAMP_FLAG_MASK = 1,
};

enum hwtstamp_provider_qualifier {
	HWTSTAMP_PROVIDER_QUALIFIER_PRECISE = 0,
	HWTSTAMP_PROVIDER_QUALIFIER_APPROX = 1,
	HWTSTAMP_PROVIDER_QUALIFIER_CNT = 2,
};

enum hwtstamp_rx_filters {
	HWTSTAMP_FILTER_NONE = 0,
	HWTSTAMP_FILTER_ALL = 1,
	HWTSTAMP_FILTER_SOME = 2,
	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
	HWTSTAMP_FILTER_NTP_ALL = 15,
	__HWTSTAMP_FILTER_CNT = 16,
};

enum hwtstamp_source {
	HWTSTAMP_SOURCE_UNSPEC = 0,
	HWTSTAMP_SOURCE_NETDEV = 1,
	HWTSTAMP_SOURCE_PHYLIB = 2,
};

enum hwtstamp_tx_types {
	HWTSTAMP_TX_OFF = 0,
	HWTSTAMP_TX_ON = 1,
	HWTSTAMP_TX_ONESTEP_SYNC = 2,
	HWTSTAMP_TX_ONESTEP_P2P = 3,
	__HWTSTAMP_TX_CNT = 4,
};

enum hybrid_cpu_type {
	HYBRID_INTEL_NONE = 0,
	HYBRID_INTEL_ATOM = 32,
	HYBRID_INTEL_CORE = 64,
};

enum hybrid_pmu_type {
	not_hybrid = 0,
	hybrid_small = 1,
	hybrid_big = 2,
	hybrid_tiny = 4,
	hybrid_big_small = 3,
	hybrid_small_tiny = 5,
	hybrid_big_small_tiny = 7,
};

enum i2c_alert_protocol {
	I2C_PROTOCOL_SMBUS_ALERT = 0,
	I2C_PROTOCOL_SMBUS_HOST_NOTIFY = 1,
};

enum i2c_driver_flags {
	I2C_DRV_ACPI_WAIVE_D0_PROBE = 1,
};

enum i8042_controller_reset_mode {
	I8042_RESET_NEVER = 0,
	I8042_RESET_ALWAYS = 1,
	I8042_RESET_ON_S2RAM = 2,
};

enum i915_cache_level {
	I915_CACHE_NONE = 0,
	I915_CACHE_LLC = 1,
	I915_CACHE_L3_LLC = 2,
	I915_CACHE_WT = 3,
	I915_MAX_CACHE_LEVEL = 4,
};

enum i915_component_type {
	I915_COMPONENT_AUDIO = 1,
	I915_COMPONENT_HDCP = 2,
	I915_COMPONENT_PXP = 3,
	I915_COMPONENT_GSC_PROXY = 4,
};

enum i915_gem_engine_type {
	I915_GEM_ENGINE_TYPE_INVALID = 0,
	I915_GEM_ENGINE_TYPE_PHYSICAL = 1,
	I915_GEM_ENGINE_TYPE_BALANCED = 2,
	I915_GEM_ENGINE_TYPE_PARALLEL = 3,
};

enum i915_gtt_view_type {
	I915_GTT_VIEW_NORMAL = 0,
	I915_GTT_VIEW_ROTATED = 24,
	I915_GTT_VIEW_PARTIAL = 12,
	I915_GTT_VIEW_REMAPPED = 52,
};

enum i915_map_type {
	I915_MAP_WB = 0,
	I915_MAP_WC = 1,
	I915_MAP_FORCE_WB = 2147483648,
	I915_MAP_FORCE_WC = 2147483649,
};

enum i915_mmap_type {
	I915_MMAP_TYPE_GTT = 0,
	I915_MMAP_TYPE_WC = 1,
	I915_MMAP_TYPE_WB = 2,
	I915_MMAP_TYPE_UC = 3,
	I915_MMAP_TYPE_FIXED = 4,
};

enum i915_mocs_table_index {
	I915_MOCS_UNCACHED = 0,
	I915_MOCS_PTE = 1,
	I915_MOCS_CACHED = 2,
};

enum i915_pmu_tracked_events {
	__I915_PMU_ACTUAL_FREQUENCY_ENABLED = 0,
	__I915_PMU_REQUESTED_FREQUENCY_ENABLED = 1,
	__I915_PMU_RC6_RESIDENCY_ENABLED = 2,
	__I915_PMU_TRACKED_EVENT_COUNT = 3,
};

enum i915_power_well_id {
	DISP_PW_ID_NONE = 0,
	VLV_DISP_PW_DISP2D = 1,
	BXT_DISP_PW_DPIO_CMN_A = 2,
	VLV_DISP_PW_DPIO_CMN_BC = 3,
	GLK_DISP_PW_DPIO_CMN_C = 4,
	CHV_DISP_PW_DPIO_CMN_D = 5,
	HSW_DISP_PW_GLOBAL = 6,
	SKL_DISP_PW_MISC_IO = 7,
	SKL_DISP_PW_1 = 8,
	SKL_DISP_PW_2 = 9,
	ICL_DISP_PW_3 = 10,
	SKL_DISP_DC_OFF = 11,
	TGL_DISP_PW_TC_COLD_OFF = 12,
};

enum i915_request_state {
	I915_REQUEST_UNKNOWN = 0,
	I915_REQUEST_COMPLETE = 1,
	I915_REQUEST_PENDING = 2,
	I915_REQUEST_QUEUED = 3,
	I915_REQUEST_ACTIVE = 4,
};

enum i915_sw_fence_notify {
	FENCE_COMPLETE = 0,
	FENCE_FREE = 1,
};

enum i9xx_plane_id {
	PLANE_A = 0,
	PLANE_B = 1,
	PLANE_C = 2,
};

enum iana_options {
	OSFOPT_EOL = 0,
	OSFOPT_NOP = 1,
	OSFOPT_MSS = 2,
	OSFOPT_WSO = 3,
	OSFOPT_SACKP = 4,
	OSFOPT_SACK = 5,
	OSFOPT_ECHO = 6,
	OSFOPT_ECHOREPLY = 7,
	OSFOPT_TS = 8,
	OSFOPT_POCP = 9,
	OSFOPT_POSP = 10,
	OSFOPT_EMPTY = 255,
};

enum ib_atomic_cap {
	IB_ATOMIC_NONE = 0,
	IB_ATOMIC_HCA = 1,
	IB_ATOMIC_GLOB = 2,
};

enum ib_cq_notify_flags {
	IB_CQ_SOLICITED = 1,
	IB_CQ_NEXT_COMP = 2,
	IB_CQ_SOLICITED_MASK = 3,
	IB_CQ_REPORT_MISSED_EVENTS = 4,
};

enum ib_event_type {
	IB_EVENT_CQ_ERR = 0,
	IB_EVENT_QP_FATAL = 1,
	IB_EVENT_QP_REQ_ERR = 2,
	IB_EVENT_QP_ACCESS_ERR = 3,
	IB_EVENT_COMM_EST = 4,
	IB_EVENT_SQ_DRAINED = 5,
	IB_EVENT_PATH_MIG = 6,
	IB_EVENT_PATH_MIG_ERR = 7,
	IB_EVENT_DEVICE_FATAL = 8,
	IB_EVENT_PORT_ACTIVE = 9,
	IB_EVENT_PORT_ERR = 10,
	IB_EVENT_LID_CHANGE = 11,
	IB_EVENT_PKEY_CHANGE = 12,
	IB_EVENT_SM_CHANGE = 13,
	IB_EVENT_SRQ_ERR = 14,
	IB_EVENT_SRQ_LIMIT_REACHED = 15,
	IB_EVENT_QP_LAST_WQE_REACHED = 16,
	IB_EVENT_CLIENT_REREGISTER = 17,
	IB_EVENT_GID_CHANGE = 18,
	IB_EVENT_WQ_FATAL = 19,
};

enum ib_flow_action_type {
	IB_FLOW_ACTION_UNSPECIFIED = 0,
	IB_FLOW_ACTION_ESP = 1,
};

enum ib_flow_attr_type {
	IB_FLOW_ATTR_NORMAL = 0,
	IB_FLOW_ATTR_ALL_DEFAULT = 1,
	IB_FLOW_ATTR_MC_DEFAULT = 2,
	IB_FLOW_ATTR_SNIFFER = 3,
};

enum ib_flow_spec_type {
	IB_FLOW_SPEC_ETH = 32,
	IB_FLOW_SPEC_IB = 34,
	IB_FLOW_SPEC_IPV4 = 48,
	IB_FLOW_SPEC_IPV6 = 49,
	IB_FLOW_SPEC_ESP = 52,
	IB_FLOW_SPEC_TCP = 64,
	IB_FLOW_SPEC_UDP = 65,
	IB_FLOW_SPEC_VXLAN_TUNNEL = 80,
	IB_FLOW_SPEC_GRE = 81,
	IB_FLOW_SPEC_MPLS = 96,
	IB_FLOW_SPEC_INNER = 256,
	IB_FLOW_SPEC_ACTION_TAG = 4096,
	IB_FLOW_SPEC_ACTION_DROP = 4097,
	IB_FLOW_SPEC_ACTION_HANDLE = 4098,
	IB_FLOW_SPEC_ACTION_COUNT = 4099,
};

enum ib_gid_type {
	IB_GID_TYPE_IB = 0,
	IB_GID_TYPE_ROCE = 1,
	IB_GID_TYPE_ROCE_UDP_ENCAP = 2,
	IB_GID_TYPE_SIZE = 3,
};

enum ib_mig_state {
	IB_MIG_MIGRATED = 0,
	IB_MIG_REARM = 1,
	IB_MIG_ARMED = 2,
};

enum ib_mr_type {
	IB_MR_TYPE_MEM_REG = 0,
	IB_MR_TYPE_SG_GAPS = 1,
	IB_MR_TYPE_DM = 2,
	IB_MR_TYPE_USER = 3,
	IB_MR_TYPE_DMA = 4,
	IB_MR_TYPE_INTEGRITY = 5,
};

enum ib_mtu {
	IB_MTU_256 = 1,
	IB_MTU_512 = 2,
	IB_MTU_1024 = 3,
	IB_MTU_2048 = 4,
	IB_MTU_4096 = 5,
};

enum ib_mw_type {
	IB_MW_TYPE_1 = 1,
	IB_MW_TYPE_2 = 2,
};

enum ib_poll_context {
	IB_POLL_SOFTIRQ = 0,
	IB_POLL_WORKQUEUE = 1,
	IB_POLL_UNBOUND_WORKQUEUE = 2,
	IB_POLL_LAST_POOL_TYPE = 2,
	IB_POLL_DIRECT = 3,
};

enum ib_port_state {
	IB_PORT_NOP = 0,
	IB_PORT_DOWN = 1,
	IB_PORT_INIT = 2,
	IB_PORT_ARMED = 3,
	IB_PORT_ACTIVE = 4,
	IB_PORT_ACTIVE_DEFER = 5,
};

enum ib_qp_state {
	IB_QPS_RESET = 0,
	IB_QPS_INIT = 1,
	IB_QPS_RTR = 2,
	IB_QPS_RTS = 3,
	IB_QPS_SQD = 4,
	IB_QPS_SQE = 5,
	IB_QPS_ERR = 6,
};

enum ib_qp_type {
	IB_QPT_SMI = 0,
	IB_QPT_GSI = 1,
	IB_QPT_RC = 2,
	IB_QPT_UC = 3,
	IB_QPT_UD = 4,
	IB_QPT_RAW_IPV6 = 5,
	IB_QPT_RAW_ETHERTYPE = 6,
	IB_QPT_RAW_PACKET = 8,
	IB_QPT_XRC_INI = 9,
	IB_QPT_XRC_TGT = 10,
	IB_QPT_MAX = 11,
	IB_QPT_DRIVER = 255,
	IB_QPT_RESERVED1 = 4096,
	IB_QPT_RESERVED2 = 4097,
	IB_QPT_RESERVED3 = 4098,
	IB_QPT_RESERVED4 = 4099,
	IB_QPT_RESERVED5 = 4100,
	IB_QPT_RESERVED6 = 4101,
	IB_QPT_RESERVED7 = 4102,
	IB_QPT_RESERVED8 = 4103,
	IB_QPT_RESERVED9 = 4104,
	IB_QPT_RESERVED10 = 4105,
};

enum ib_sig_err_type {
	IB_SIG_BAD_GUARD = 0,
	IB_SIG_BAD_REFTAG = 1,
	IB_SIG_BAD_APPTAG = 2,
};

enum ib_sig_type {
	IB_SIGNAL_ALL_WR = 0,
	IB_SIGNAL_REQ_WR = 1,
};

enum ib_signature_type {
	IB_SIG_TYPE_NONE = 0,
	IB_SIG_TYPE_T10_DIF = 1,
};

enum ib_srq_attr_mask {
	IB_SRQ_MAX_WR = 1,
	IB_SRQ_LIMIT = 2,
};

enum ib_srq_type {
	IB_SRQT_BASIC = 0,
	IB_SRQT_XRC = 1,
	IB_SRQT_TM = 2,
};

enum ib_t10_dif_bg_type {
	IB_T10DIF_CRC = 0,
	IB_T10DIF_CSUM = 1,
};

enum ib_uverbs_access_flags {
	IB_UVERBS_ACCESS_LOCAL_WRITE = 1,
	IB_UVERBS_ACCESS_REMOTE_WRITE = 2,
	IB_UVERBS_ACCESS_REMOTE_READ = 4,
	IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8,
	IB_UVERBS_ACCESS_MW_BIND = 16,
	IB_UVERBS_ACCESS_ZERO_BASED = 32,
	IB_UVERBS_ACCESS_ON_DEMAND = 64,
	IB_UVERBS_ACCESS_HUGETLB = 128,
	IB_UVERBS_ACCESS_FLUSH_GLOBAL = 256,
	IB_UVERBS_ACCESS_FLUSH_PERSISTENT = 512,
	IB_UVERBS_ACCESS_RELAXED_ORDERING = 1048576,
	IB_UVERBS_ACCESS_OPTIONAL_RANGE = 1072693248,
};

enum ib_uverbs_advise_mr_advice {
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = 0,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = 1,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT = 2,
};

enum ib_uverbs_create_qp_mask {
	IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1,
};

enum ib_uverbs_device_cap_flags {
	IB_UVERBS_DEVICE_RESIZE_MAX_WR = 1ULL,
	IB_UVERBS_DEVICE_BAD_PKEY_CNTR = 2ULL,
	IB_UVERBS_DEVICE_BAD_QKEY_CNTR = 4ULL,
	IB_UVERBS_DEVICE_RAW_MULTI = 8ULL,
	IB_UVERBS_DEVICE_AUTO_PATH_MIG = 16ULL,
	IB_UVERBS_DEVICE_CHANGE_PHY_PORT = 32ULL,
	IB_UVERBS_DEVICE_UD_AV_PORT_ENFORCE = 64ULL,
	IB_UVERBS_DEVICE_CURR_QP_STATE_MOD = 128ULL,
	IB_UVERBS_DEVICE_SHUTDOWN_PORT = 256ULL,
	IB_UVERBS_DEVICE_PORT_ACTIVE_EVENT = 1024ULL,
	IB_UVERBS_DEVICE_SYS_IMAGE_GUID = 2048ULL,
	IB_UVERBS_DEVICE_RC_RNR_NAK_GEN = 4096ULL,
	IB_UVERBS_DEVICE_SRQ_RESIZE = 8192ULL,
	IB_UVERBS_DEVICE_N_NOTIFY_CQ = 16384ULL,
	IB_UVERBS_DEVICE_MEM_WINDOW = 131072ULL,
	IB_UVERBS_DEVICE_UD_IP_CSUM = 262144ULL,
	IB_UVERBS_DEVICE_XRC = 1048576ULL,
	IB_UVERBS_DEVICE_MEM_MGT_EXTENSIONS = 2097152ULL,
	IB_UVERBS_DEVICE_MEM_WINDOW_TYPE_2A = 8388608ULL,
	IB_UVERBS_DEVICE_MEM_WINDOW_TYPE_2B = 16777216ULL,
	IB_UVERBS_DEVICE_RC_IP_CSUM = 33554432ULL,
	IB_UVERBS_DEVICE_RAW_IP_CSUM = 67108864ULL,
	IB_UVERBS_DEVICE_MANAGED_FLOW_STEERING = 536870912ULL,
	IB_UVERBS_DEVICE_RAW_SCATTER_FCS = 17179869184ULL,
	IB_UVERBS_DEVICE_PCI_WRITE_END_PADDING = 68719476736ULL,
	IB_UVERBS_DEVICE_FLUSH_GLOBAL = 274877906944ULL,
	IB_UVERBS_DEVICE_FLUSH_PERSISTENT = 549755813888ULL,
	IB_UVERBS_DEVICE_ATOMIC_WRITE = 1099511627776ULL,
};

enum ib_uverbs_gid_type {
	IB_UVERBS_GID_TYPE_IB = 0,
	IB_UVERBS_GID_TYPE_ROCE_V1 = 1,
	IB_UVERBS_GID_TYPE_ROCE_V2 = 2,
};

enum ib_uverbs_qp_create_flags {
	IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
	IB_UVERBS_QP_CREATE_SCATTER_FCS = 256,
	IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = 512,
	IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = 2048,
	IB_UVERBS_QP_CREATE_SQ_SIG_ALL = 4096,
};

enum ib_uverbs_qp_type {
	IB_UVERBS_QPT_RC = 2,
	IB_UVERBS_QPT_UC = 3,
	IB_UVERBS_QPT_UD = 4,
	IB_UVERBS_QPT_RAW_PACKET = 8,
	IB_UVERBS_QPT_XRC_INI = 9,
	IB_UVERBS_QPT_XRC_TGT = 10,
	IB_UVERBS_QPT_DRIVER = 255,
};

enum ib_uverbs_raw_packet_caps {
	IB_UVERBS_RAW_PACKET_CAP_CVLAN_STRIPPING = 1,
	IB_UVERBS_RAW_PACKET_CAP_SCATTER_FCS = 2,
	IB_UVERBS_RAW_PACKET_CAP_IP_CSUM = 4,
	IB_UVERBS_RAW_PACKET_CAP_DELAY_DROP = 8,
};

enum ib_uverbs_srq_type {
	IB_UVERBS_SRQT_BASIC = 0,
	IB_UVERBS_SRQT_XRC = 1,
	IB_UVERBS_SRQT_TM = 2,
};

enum ib_uverbs_wc_opcode {
	IB_UVERBS_WC_SEND = 0,
	IB_UVERBS_WC_RDMA_WRITE = 1,
	IB_UVERBS_WC_RDMA_READ = 2,
	IB_UVERBS_WC_COMP_SWAP = 3,
	IB_UVERBS_WC_FETCH_ADD = 4,
	IB_UVERBS_WC_BIND_MW = 5,
	IB_UVERBS_WC_LOCAL_INV = 6,
	IB_UVERBS_WC_TSO = 7,
	IB_UVERBS_WC_FLUSH = 8,
	IB_UVERBS_WC_ATOMIC_WRITE = 9,
};

enum ib_uverbs_wq_flags {
	IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = 1,
	IB_UVERBS_WQ_FLAGS_SCATTER_FCS = 2,
	IB_UVERBS_WQ_FLAGS_DELAY_DROP = 4,
	IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = 8,
};

enum ib_uverbs_wq_type {
	IB_UVERBS_WQT_RQ = 0,
};

enum ib_uverbs_wr_opcode {
	IB_UVERBS_WR_RDMA_WRITE = 0,
	IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_UVERBS_WR_SEND = 2,
	IB_UVERBS_WR_SEND_WITH_IMM = 3,
	IB_UVERBS_WR_RDMA_READ = 4,
	IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_UVERBS_WR_LOCAL_INV = 7,
	IB_UVERBS_WR_BIND_MW = 8,
	IB_UVERBS_WR_SEND_WITH_INV = 9,
	IB_UVERBS_WR_TSO = 10,
	IB_UVERBS_WR_RDMA_READ_WITH_INV = 11,
	IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
	IB_UVERBS_WR_FLUSH = 14,
	IB_UVERBS_WR_ATOMIC_WRITE = 15,
};

enum ib_uverbs_write_cmds {
	IB_USER_VERBS_CMD_GET_CONTEXT = 0,
	IB_USER_VERBS_CMD_QUERY_DEVICE = 1,
	IB_USER_VERBS_CMD_QUERY_PORT = 2,
	IB_USER_VERBS_CMD_ALLOC_PD = 3,
	IB_USER_VERBS_CMD_DEALLOC_PD = 4,
	IB_USER_VERBS_CMD_CREATE_AH = 5,
	IB_USER_VERBS_CMD_MODIFY_AH = 6,
	IB_USER_VERBS_CMD_QUERY_AH = 7,
	IB_USER_VERBS_CMD_DESTROY_AH = 8,
	IB_USER_VERBS_CMD_REG_MR = 9,
	IB_USER_VERBS_CMD_REG_SMR = 10,
	IB_USER_VERBS_CMD_REREG_MR = 11,
	IB_USER_VERBS_CMD_QUERY_MR = 12,
	IB_USER_VERBS_CMD_DEREG_MR = 13,
	IB_USER_VERBS_CMD_ALLOC_MW = 14,
	IB_USER_VERBS_CMD_BIND_MW = 15,
	IB_USER_VERBS_CMD_DEALLOC_MW = 16,
	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17,
	IB_USER_VERBS_CMD_CREATE_CQ = 18,
	IB_USER_VERBS_CMD_RESIZE_CQ = 19,
	IB_USER_VERBS_CMD_DESTROY_CQ = 20,
	IB_USER_VERBS_CMD_POLL_CQ = 21,
	IB_USER_VERBS_CMD_PEEK_CQ = 22,
	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23,
	IB_USER_VERBS_CMD_CREATE_QP = 24,
	IB_USER_VERBS_CMD_QUERY_QP = 25,
	IB_USER_VERBS_CMD_MODIFY_QP = 26,
	IB_USER_VERBS_CMD_DESTROY_QP = 27,
	IB_USER_VERBS_CMD_POST_SEND = 28,
	IB_USER_VERBS_CMD_POST_RECV = 29,
	IB_USER_VERBS_CMD_ATTACH_MCAST = 30,
	IB_USER_VERBS_CMD_DETACH_MCAST = 31,
	IB_USER_VERBS_CMD_CREATE_SRQ = 32,
	IB_USER_VERBS_CMD_MODIFY_SRQ = 33,
	IB_USER_VERBS_CMD_QUERY_SRQ = 34,
	IB_USER_VERBS_CMD_DESTROY_SRQ = 35,
	IB_USER_VERBS_CMD_POST_SRQ_RECV = 36,
	IB_USER_VERBS_CMD_OPEN_XRCD = 37,
	IB_USER_VERBS_CMD_CLOSE_XRCD = 38,
	IB_USER_VERBS_CMD_CREATE_XSRQ = 39,
	IB_USER_VERBS_CMD_OPEN_QP = 40,
};

enum ib_wc_opcode {
	IB_WC_SEND = 0,
	IB_WC_RDMA_WRITE = 1,
	IB_WC_RDMA_READ = 2,
	IB_WC_COMP_SWAP = 3,
	IB_WC_FETCH_ADD = 4,
	IB_WC_BIND_MW = 5,
	IB_WC_LOCAL_INV = 6,
	IB_WC_LSO = 7,
	IB_WC_ATOMIC_WRITE = 9,
	IB_WC_REG_MR = 10,
	IB_WC_MASKED_COMP_SWAP = 11,
	IB_WC_MASKED_FETCH_ADD = 12,
	IB_WC_FLUSH = 8,
	IB_WC_RECV = 128,
	IB_WC_RECV_RDMA_WITH_IMM = 129,
};

enum ib_wc_status {
	IB_WC_SUCCESS = 0,
	IB_WC_LOC_LEN_ERR = 1,
	IB_WC_LOC_QP_OP_ERR = 2,
	IB_WC_LOC_EEC_OP_ERR = 3,
	IB_WC_LOC_PROT_ERR = 4,
	IB_WC_WR_FLUSH_ERR = 5,
	IB_WC_MW_BIND_ERR = 6,
	IB_WC_BAD_RESP_ERR = 7,
	IB_WC_LOC_ACCESS_ERR = 8,
	IB_WC_REM_INV_REQ_ERR = 9,
	IB_WC_REM_ACCESS_ERR = 10,
	IB_WC_REM_OP_ERR = 11,
	IB_WC_RETRY_EXC_ERR = 12,
	IB_WC_RNR_RETRY_EXC_ERR = 13,
	IB_WC_LOC_RDD_VIOL_ERR = 14,
	IB_WC_REM_INV_RD_REQ_ERR = 15,
	IB_WC_REM_ABORT_ERR = 16,
	IB_WC_INV_EECN_ERR = 17,
	IB_WC_INV_EEC_STATE_ERR = 18,
	IB_WC_FATAL_ERR = 19,
	IB_WC_RESP_TIMEOUT_ERR = 20,
	IB_WC_GENERAL_ERR = 21,
};

enum ib_wq_state {
	IB_WQS_RESET = 0,
	IB_WQS_RDY = 1,
	IB_WQS_ERR = 2,
};

enum ib_wq_type {
	IB_WQT_RQ = 0,
};

enum ib_wr_opcode {
	IB_WR_RDMA_WRITE = 0,
	IB_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_WR_SEND = 2,
	IB_WR_SEND_WITH_IMM = 3,
	IB_WR_RDMA_READ = 4,
	IB_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_WR_BIND_MW = 8,
	IB_WR_LSO = 10,
	IB_WR_SEND_WITH_INV = 9,
	IB_WR_RDMA_READ_WITH_INV = 11,
	IB_WR_LOCAL_INV = 7,
	IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
	IB_WR_FLUSH = 14,
	IB_WR_ATOMIC_WRITE = 15,
	IB_WR_REG_MR = 32,
	IB_WR_REG_MR_INTEGRITY = 33,
	IB_WR_RESERVED1 = 240,
	IB_WR_RESERVED2 = 241,
	IB_WR_RESERVED3 = 242,
	IB_WR_RESERVED4 = 243,
	IB_WR_RESERVED5 = 244,
	IB_WR_RESERVED6 = 245,
	IB_WR_RESERVED7 = 246,
	IB_WR_RESERVED8 = 247,
	IB_WR_RESERVED9 = 248,
	IB_WR_RESERVED10 = 249,
};

enum ibs_states {
	IBS_ENABLED = 0,
	IBS_STARTED = 1,
	IBS_STOPPING = 2,
	IBS_STOPPED = 3,
	IBS_MAX_STATES = 4,
};

enum icl_port_dpll_id {
	ICL_PORT_DPLL_DEFAULT = 0,
	ICL_PORT_DPLL_MG_PHY = 1,
	ICL_PORT_DPLL_COUNT = 2,
};

enum idle_boot_override {
	IDLE_NO_OVERRIDE = 0,
	IDLE_HALT = 1,
	IDLE_NOMWAIT = 2,
	IDLE_POLL = 3,
};

enum ieee802154_filtering_level {
	IEEE802154_FILTERING_NONE = 0,
	IEEE802154_FILTERING_1_FCS = 1,
	IEEE802154_FILTERING_2_PROMISCUOUS = 2,
	IEEE802154_FILTERING_3_SCAN = 3,
	IEEE802154_FILTERING_4_FRAME_FIELDS = 4,
};

enum ieee_attrs {
	DCB_ATTR_IEEE_UNSPEC = 0,
	DCB_ATTR_IEEE_ETS = 1,
	DCB_ATTR_IEEE_PFC = 2,
	DCB_ATTR_IEEE_APP_TABLE = 3,
	DCB_ATTR_IEEE_PEER_ETS = 4,
	DCB_ATTR_IEEE_PEER_PFC = 5,
	DCB_ATTR_IEEE_PEER_APP = 6,
	DCB_ATTR_IEEE_MAXRATE = 7,
	DCB_ATTR_IEEE_QCN = 8,
	DCB_ATTR_IEEE_QCN_STATS = 9,
	DCB_ATTR_DCB_BUFFER = 10,
	DCB_ATTR_DCB_APP_TRUST_TABLE = 11,
	DCB_ATTR_DCB_REWR_TABLE = 12,
	__DCB_ATTR_IEEE_MAX = 13,
};

enum ieee_attrs_app {
	DCB_ATTR_IEEE_APP_UNSPEC = 0,
	DCB_ATTR_IEEE_APP = 1,
	DCB_ATTR_DCB_APP = 2,
	__DCB_ATTR_IEEE_APP_MAX = 3,
};

enum ifla_vxlan_df {
	VXLAN_DF_UNSET = 0,
	VXLAN_DF_SET = 1,
	VXLAN_DF_INHERIT = 2,
	__VXLAN_DF_END = 3,
	VXLAN_DF_MAX = 2,
};

enum ifla_vxlan_label_policy {
	VXLAN_LABEL_FIXED = 0,
	VXLAN_LABEL_INHERIT = 1,
	__VXLAN_LABEL_END = 2,
	VXLAN_LABEL_MAX = 1,
};

enum ima_fs_flags {
	IMA_FS_BUSY = 0,
};

enum ima_hooks {
	NONE___2 = 0,
	FILE_CHECK = 1,
	MMAP_CHECK = 2,
	MMAP_CHECK_REQPROT = 3,
	BPRM_CHECK = 4,
	CREDS_CHECK = 5,
	POST_SETATTR = 6,
	MODULE_CHECK = 7,
	FIRMWARE_CHECK = 8,
	KEXEC_KERNEL_CHECK = 9,
	KEXEC_INITRAMFS_CHECK = 10,
	POLICY_CHECK = 11,
	KEXEC_CMDLINE = 12,
	KEY_CHECK = 13,
	CRITICAL_DATA = 14,
	SETXATTR_CHECK = 15,
	MAX_CHECK = 16,
};

enum ima_show_type {
	IMA_SHOW_BINARY = 0,
	IMA_SHOW_BINARY_NO_FIELD_LEN = 1,
	IMA_SHOW_BINARY_OLD_STRING_FMT = 2,
	IMA_SHOW_ASCII = 3,
};

enum in6_addr_gen_mode {
	IN6_ADDR_GEN_MODE_EUI64 = 0,
	IN6_ADDR_GEN_MODE_NONE = 1,
	IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
	IN6_ADDR_GEN_MODE_RANDOM = 3,
};

enum inet_csk_ack_state_t {
	ICSK_ACK_SCHED = 1,
	ICSK_ACK_TIMER = 2,
	ICSK_ACK_PUSHED = 4,
	ICSK_ACK_PUSHED2 = 8,
	ICSK_ACK_NOW = 16,
	ICSK_ACK_NOMEM = 32,
};

enum inode_i_mutex_lock_class {
	I_MUTEX_NORMAL = 0,
	I_MUTEX_PARENT = 1,
	I_MUTEX_CHILD = 2,
	I_MUTEX_XATTR = 3,
	I_MUTEX_NONDIR2 = 4,
	I_MUTEX_PARENT2 = 5,
};

enum inode_state {
	inode_state_no_change = 0,
	inode_state_will_create = 1,
	inode_state_did_create = 2,
	inode_state_will_delete = 3,
	inode_state_did_delete = 4,
};

enum input_clock_type {
	INPUT_CLK_REAL = 0,
	INPUT_CLK_MONO = 1,
	INPUT_CLK_BOOT = 2,
	INPUT_CLK_MAX = 3,
};

enum insn_mmio_type {
	INSN_MMIO_DECODE_FAILED = 0,
	INSN_MMIO_WRITE = 1,
	INSN_MMIO_WRITE_IMM = 2,
	INSN_MMIO_READ = 3,
	INSN_MMIO_READ_ZERO_EXTEND = 4,
	INSN_MMIO_READ_SIGN_EXTEND = 5,
	INSN_MMIO_MOVS = 6,
};

enum insn_mode {
	INSN_MODE_32 = 0,
	INSN_MODE_64 = 1,
	INSN_MODE_KERN = 2,
	INSN_NUM_MODES = 3,
};

enum insn_type {
	CALL = 0,
	NOP = 1,
	JMP = 2,
	RET = 3,
	JCC = 4,
};

enum integrity_status {
	INTEGRITY_PASS = 0,
	INTEGRITY_PASS_IMMUTABLE = 1,
	INTEGRITY_FAIL = 2,
	INTEGRITY_FAIL_IMMUTABLE = 3,
	INTEGRITY_NOLABEL = 4,
	INTEGRITY_NOXATTRS = 5,
	INTEGRITY_UNKNOWN = 6,
};

enum intel_backlight_type {
	INTEL_BACKLIGHT_PMIC = 0,
	INTEL_BACKLIGHT_LPSS = 1,
	INTEL_BACKLIGHT_DISPLAY_DDI = 2,
	INTEL_BACKLIGHT_DSI_DCS = 3,
	INTEL_BACKLIGHT_PANEL_DRIVER_INTERFACE = 4,
	INTEL_BACKLIGHT_VESA_EDP_AUX_INTERFACE = 5,
};

enum intel_bootrom_load_status {
	INTEL_BOOTROM_STATUS_NO_KEY_FOUND = 19,
	INTEL_BOOTROM_STATUS_AES_PROD_KEY_FOUND = 26,
	INTEL_BOOTROM_STATUS_PROD_KEY_CHECK_FAILURE = 43,
	INTEL_BOOTROM_STATUS_RSA_FAILED = 80,
	INTEL_BOOTROM_STATUS_PAVPC_FAILED = 115,
	INTEL_BOOTROM_STATUS_WOPCM_FAILED = 116,
	INTEL_BOOTROM_STATUS_LOADLOC_FAILED = 117,
	INTEL_BOOTROM_STATUS_JUMP_PASSED = 118,
	INTEL_BOOTROM_STATUS_JUMP_FAILED = 119,
	INTEL_BOOTROM_STATUS_RC6CTXCONFIG_FAILED = 121,
	INTEL_BOOTROM_STATUS_MPUMAP_INCORRECT = 122,
	INTEL_BOOTROM_STATUS_EXCEPTION = 126,
};

enum intel_broadcast_rgb {
	INTEL_BROADCAST_RGB_AUTO = 0,
	INTEL_BROADCAST_RGB_FULL = 1,
	INTEL_BROADCAST_RGB_LIMITED = 2,
};

enum intel_cpu_type {
	INTEL_CPU_TYPE_ATOM = 32,
	INTEL_CPU_TYPE_CORE = 64,
};

enum intel_ddb_partitioning {
	INTEL_DDB_PART_1_2 = 0,
	INTEL_DDB_PART_5_6 = 1,
};

enum intel_display_power_domain {
	POWER_DOMAIN_DISPLAY_CORE = 0,
	POWER_DOMAIN_PIPE_A = 1,
	POWER_DOMAIN_PIPE_B = 2,
	POWER_DOMAIN_PIPE_C = 3,
	POWER_DOMAIN_PIPE_D = 4,
	POWER_DOMAIN_PIPE_PANEL_FITTER_A = 5,
	POWER_DOMAIN_PIPE_PANEL_FITTER_B = 6,
	POWER_DOMAIN_PIPE_PANEL_FITTER_C = 7,
	POWER_DOMAIN_PIPE_PANEL_FITTER_D = 8,
	POWER_DOMAIN_TRANSCODER_A = 9,
	POWER_DOMAIN_TRANSCODER_B = 10,
	POWER_DOMAIN_TRANSCODER_C = 11,
	POWER_DOMAIN_TRANSCODER_D = 12,
	POWER_DOMAIN_TRANSCODER_EDP = 13,
	POWER_DOMAIN_TRANSCODER_DSI_A = 14,
	POWER_DOMAIN_TRANSCODER_DSI_C = 15,
	POWER_DOMAIN_TRANSCODER_VDSC_PW2 = 16,
	POWER_DOMAIN_PORT_DDI_LANES_A = 17,
	POWER_DOMAIN_PORT_DDI_LANES_B = 18,
	POWER_DOMAIN_PORT_DDI_LANES_C = 19,
	POWER_DOMAIN_PORT_DDI_LANES_D = 20,
	POWER_DOMAIN_PORT_DDI_LANES_E = 21,
	POWER_DOMAIN_PORT_DDI_LANES_F = 22,
	POWER_DOMAIN_PORT_DDI_LANES_TC1 = 23,
	POWER_DOMAIN_PORT_DDI_LANES_TC2 = 24,
	POWER_DOMAIN_PORT_DDI_LANES_TC3 = 25,
	POWER_DOMAIN_PORT_DDI_LANES_TC4 = 26,
	POWER_DOMAIN_PORT_DDI_LANES_TC5 = 27,
	POWER_DOMAIN_PORT_DDI_LANES_TC6 = 28,
	POWER_DOMAIN_PORT_DDI_IO_A = 29,
	POWER_DOMAIN_PORT_DDI_IO_B = 30,
	POWER_DOMAIN_PORT_DDI_IO_C = 31,
	POWER_DOMAIN_PORT_DDI_IO_D = 32,
	POWER_DOMAIN_PORT_DDI_IO_E = 33,
	POWER_DOMAIN_PORT_DDI_IO_F = 34,
	POWER_DOMAIN_PORT_DDI_IO_TC1 = 35,
	POWER_DOMAIN_PORT_DDI_IO_TC2 = 36,
	POWER_DOMAIN_PORT_DDI_IO_TC3 = 37,
	POWER_DOMAIN_PORT_DDI_IO_TC4 = 38,
	POWER_DOMAIN_PORT_DDI_IO_TC5 = 39,
	POWER_DOMAIN_PORT_DDI_IO_TC6 = 40,
	POWER_DOMAIN_PORT_DSI = 41,
	POWER_DOMAIN_PORT_CRT = 42,
	POWER_DOMAIN_PORT_OTHER = 43,
	POWER_DOMAIN_VGA = 44,
	POWER_DOMAIN_AUDIO_MMIO = 45,
	POWER_DOMAIN_AUDIO_PLAYBACK = 46,
	POWER_DOMAIN_AUX_IO_A = 47,
	POWER_DOMAIN_AUX_IO_B = 48,
	POWER_DOMAIN_AUX_IO_C = 49,
	POWER_DOMAIN_AUX_IO_D = 50,
	POWER_DOMAIN_AUX_IO_E = 51,
	POWER_DOMAIN_AUX_IO_F = 52,
	POWER_DOMAIN_AUX_A = 53,
	POWER_DOMAIN_AUX_B = 54,
	POWER_DOMAIN_AUX_C = 55,
	POWER_DOMAIN_AUX_D = 56,
	POWER_DOMAIN_AUX_E = 57,
	POWER_DOMAIN_AUX_F = 58,
	POWER_DOMAIN_AUX_USBC1 = 59,
	POWER_DOMAIN_AUX_USBC2 = 60,
	POWER_DOMAIN_AUX_USBC3 = 61,
	POWER_DOMAIN_AUX_USBC4 = 62,
	POWER_DOMAIN_AUX_USBC5 = 63,
	POWER_DOMAIN_AUX_USBC6 = 64,
	POWER_DOMAIN_AUX_TBT1 = 65,
	POWER_DOMAIN_AUX_TBT2 = 66,
	POWER_DOMAIN_AUX_TBT3 = 67,
	POWER_DOMAIN_AUX_TBT4 = 68,
	POWER_DOMAIN_AUX_TBT5 = 69,
	POWER_DOMAIN_AUX_TBT6 = 70,
	POWER_DOMAIN_GMBUS = 71,
	POWER_DOMAIN_GT_IRQ = 72,
	POWER_DOMAIN_DC_OFF = 73,
	POWER_DOMAIN_TC_COLD_OFF = 74,
	POWER_DOMAIN_INIT = 75,
	POWER_DOMAIN_NUM = 76,
	POWER_DOMAIN_INVALID = 76,
};

enum intel_dmc_id {
	DMC_FW_MAIN = 0,
	DMC_FW_PIPEA = 1,
	DMC_FW_PIPEB = 2,
	DMC_FW_PIPEC = 3,
	DMC_FW_PIPED = 4,
	DMC_FW_MAX = 5,
};

enum intel_dp_aux_backlight_modparam {
	INTEL_DP_AUX_BACKLIGHT_AUTO = -1,
	INTEL_DP_AUX_BACKLIGHT_OFF = 0,
	INTEL_DP_AUX_BACKLIGHT_ON = 1,
	INTEL_DP_AUX_BACKLIGHT_FORCE_VESA = 2,
	INTEL_DP_AUX_BACKLIGHT_FORCE_INTEL = 3,
};

enum intel_dpll_id {
	DPLL_ID_PRIVATE = -1,
	DPLL_ID_PCH_PLL_A = 0,
	DPLL_ID_PCH_PLL_B = 1,
	DPLL_ID_WRPLL1 = 0,
	DPLL_ID_WRPLL2 = 1,
	DPLL_ID_SPLL = 2,
	DPLL_ID_LCPLL_810 = 3,
	DPLL_ID_LCPLL_1350 = 4,
	DPLL_ID_LCPLL_2700 = 5,
	DPLL_ID_SKL_DPLL0 = 0,
	DPLL_ID_SKL_DPLL1 = 1,
	DPLL_ID_SKL_DPLL2 = 2,
	DPLL_ID_SKL_DPLL3 = 3,
	DPLL_ID_ICL_DPLL0 = 0,
	DPLL_ID_ICL_DPLL1 = 1,
	DPLL_ID_EHL_DPLL4 = 2,
	DPLL_ID_ICL_TBTPLL = 2,
	DPLL_ID_ICL_MGPLL1 = 3,
	DPLL_ID_ICL_MGPLL2 = 4,
	DPLL_ID_ICL_MGPLL3 = 5,
	DPLL_ID_ICL_MGPLL4 = 6,
	DPLL_ID_TGL_MGPLL5 = 7,
	DPLL_ID_TGL_MGPLL6 = 8,
	DPLL_ID_DG1_DPLL0 = 0,
	DPLL_ID_DG1_DPLL1 = 1,
	DPLL_ID_DG1_DPLL2 = 2,
	DPLL_ID_DG1_DPLL3 = 3,
};

enum intel_dram_type {
	INTEL_DRAM_UNKNOWN = 0,
	INTEL_DRAM_DDR3 = 1,
	INTEL_DRAM_DDR4 = 2,
	INTEL_DRAM_LPDDR3 = 3,
	INTEL_DRAM_LPDDR4 = 4,
	INTEL_DRAM_DDR5 = 5,
	INTEL_DRAM_LPDDR5 = 6,
	INTEL_DRAM_GDDR = 7,
};

enum intel_dsb_id {
	INTEL_DSB_0 = 0,
	INTEL_DSB_1 = 1,
	INTEL_DSB_2 = 2,
	I915_MAX_DSBS = 3,
};

enum intel_engine_id {
	RCS0 = 0,
	BCS0 = 1,
	BCS1 = 2,
	BCS2 = 3,
	BCS3 = 4,
	BCS4 = 5,
	BCS5 = 6,
	BCS6 = 7,
	BCS7 = 8,
	BCS8 = 9,
	VCS0 = 10,
	VCS1 = 11,
	VCS2 = 12,
	VCS3 = 13,
	VCS4 = 14,
	VCS5 = 15,
	VCS6 = 16,
	VCS7 = 17,
	VECS0 = 18,
	VECS1 = 19,
	VECS2 = 20,
	VECS3 = 21,
	CCS0 = 22,
	CCS1 = 23,
	CCS2 = 24,
	CCS3 = 25,
	GSC0 = 26,
	I915_NUM_ENGINES = 27,
};

enum intel_excl_state_type {
	INTEL_EXCL_UNUSED = 0,
	INTEL_EXCL_SHARED = 1,
	INTEL_EXCL_EXCLUSIVE = 2,
};

enum intel_fbc_id {
	INTEL_FBC_A = 0,
	INTEL_FBC_B = 1,
	INTEL_FBC_C = 2,
	INTEL_FBC_D = 3,
	I915_MAX_FBCS = 4,
};

enum intel_gsc_proxy_type {
	GSC_PROXY_MSG_TYPE_PROXY_INVALID = 0,
	GSC_PROXY_MSG_TYPE_PROXY_QUERY = 1,
	GSC_PROXY_MSG_TYPE_PROXY_PAYLOAD = 2,
	GSC_PROXY_MSG_TYPE_PROXY_END = 3,
	GSC_PROXY_MSG_TYPE_PROXY_NOTIFICATION = 4,
};

enum intel_gt_scratch_field {
	INTEL_GT_SCRATCH_FIELD_DEFAULT = 0,
	INTEL_GT_SCRATCH_FIELD_RENDER_FLUSH = 128,
	INTEL_GT_SCRATCH_FIELD_COHERENTL3_WA = 256,
};

enum intel_gt_sysfs_op {
	INTEL_GT_SYSFS_MIN = 0,
	INTEL_GT_SYSFS_MAX = 1,
};

enum intel_gt_type {
	GT_PRIMARY = 0,
	GT_TILE = 1,
	GT_MEDIA = 2,
};

enum intel_guc_action {
	INTEL_GUC_ACTION_DEFAULT = 0,
	INTEL_GUC_ACTION_REQUEST_PREEMPTION = 2,
	INTEL_GUC_ACTION_REQUEST_ENGINE_RESET = 3,
	INTEL_GUC_ACTION_ALLOCATE_DOORBELL = 16,
	INTEL_GUC_ACTION_DEALLOCATE_DOORBELL = 32,
	INTEL_GUC_ACTION_LOG_BUFFER_FILE_FLUSH_COMPLETE = 48,
	INTEL_GUC_ACTION_UK_LOG_ENABLE_LOGGING = 64,
	INTEL_GUC_ACTION_FORCE_LOG_BUFFER_FLUSH = 770,
	INTEL_GUC_ACTION_ENTER_S_STATE = 1281,
	INTEL_GUC_ACTION_EXIT_S_STATE = 1282,
	INTEL_GUC_ACTION_GLOBAL_SCHED_POLICY_CHANGE = 1286,
	INTEL_GUC_ACTION_UPDATE_SCHEDULING_POLICIES_KLV = 1289,
	INTEL_GUC_ACTION_SCHED_CONTEXT = 4096,
	INTEL_GUC_ACTION_SCHED_CONTEXT_MODE_SET = 4097,
	INTEL_GUC_ACTION_SCHED_CONTEXT_MODE_DONE = 4098,
	INTEL_GUC_ACTION_SCHED_ENGINE_MODE_SET = 4099,
	INTEL_GUC_ACTION_SCHED_ENGINE_MODE_DONE = 4100,
	INTEL_GUC_ACTION_V69_SET_CONTEXT_PRIORITY = 4101,
	INTEL_GUC_ACTION_V69_SET_CONTEXT_EXECUTION_QUANTUM = 4102,
	INTEL_GUC_ACTION_V69_SET_CONTEXT_PREEMPTION_TIMEOUT = 4103,
	INTEL_GUC_ACTION_CONTEXT_RESET_NOTIFICATION = 4104,
	INTEL_GUC_ACTION_ENGINE_FAILURE_NOTIFICATION = 4105,
	INTEL_GUC_ACTION_HOST2GUC_UPDATE_CONTEXT_POLICIES = 4107,
	INTEL_GUC_ACTION_SETUP_PC_GUCRC = 12292,
	INTEL_GUC_ACTION_AUTHENTICATE_HUC = 16384,
	INTEL_GUC_ACTION_GET_HWCONFIG = 16640,
	INTEL_GUC_ACTION_REGISTER_CONTEXT = 17666,
	INTEL_GUC_ACTION_DEREGISTER_CONTEXT = 17667,
	INTEL_GUC_ACTION_DEREGISTER_CONTEXT_DONE = 17920,
	INTEL_GUC_ACTION_REGISTER_CONTEXT_MULTI_LRC = 17921,
	INTEL_GUC_ACTION_CLIENT_SOFT_RESET = 21767,
	INTEL_GUC_ACTION_SET_ENG_UTIL_BUFF = 21770,
	INTEL_GUC_ACTION_TLB_INVALIDATION = 28672,
	INTEL_GUC_ACTION_TLB_INVALIDATION_DONE = 28673,
	INTEL_GUC_ACTION_STATE_CAPTURE_NOTIFICATION = 32770,
	INTEL_GUC_ACTION_NOTIFY_FLUSH_LOG_BUFFER_TO_FILE = 32771,
	INTEL_GUC_ACTION_NOTIFY_CRASH_DUMP_POSTED = 32772,
	INTEL_GUC_ACTION_NOTIFY_EXCEPTION = 32773,
	INTEL_GUC_ACTION_LIMIT = 32774,
};

enum intel_guc_load_status {
	INTEL_GUC_LOAD_STATUS_DEFAULT = 0,
	INTEL_GUC_LOAD_STATUS_START = 1,
	INTEL_GUC_LOAD_STATUS_ERROR_DEVID_BUILD_MISMATCH = 2,
	INTEL_GUC_LOAD_STATUS_GUC_PREPROD_BUILD_MISMATCH = 3,
	INTEL_GUC_LOAD_STATUS_ERROR_DEVID_INVALID_GUCTYPE = 4,
	INTEL_GUC_LOAD_STATUS_HWCONFIG_START = 5,
	INTEL_GUC_LOAD_STATUS_HWCONFIG_DONE = 6,
	INTEL_GUC_LOAD_STATUS_HWCONFIG_ERROR = 7,
	INTEL_GUC_LOAD_STATUS_GDT_DONE = 16,
	INTEL_GUC_LOAD_STATUS_IDT_DONE = 32,
	INTEL_GUC_LOAD_STATUS_LAPIC_DONE = 48,
	INTEL_GUC_LOAD_STATUS_GUCINT_DONE = 64,
	INTEL_GUC_LOAD_STATUS_DPC_READY = 80,
	INTEL_GUC_LOAD_STATUS_DPC_ERROR = 96,
	INTEL_GUC_LOAD_STATUS_EXCEPTION = 112,
	INTEL_GUC_LOAD_STATUS_INIT_DATA_INVALID = 113,
	INTEL_GUC_LOAD_STATUS_PXP_TEARDOWN_CTRL_ENABLED = 114,
	INTEL_GUC_LOAD_STATUS_INVALID_INIT_DATA_RANGE_START = 115,
	INTEL_GUC_LOAD_STATUS_MPU_DATA_INVALID = 115,
	INTEL_GUC_LOAD_STATUS_INIT_MMIO_SAVE_RESTORE_INVALID = 116,
	INTEL_GUC_LOAD_STATUS_KLV_WORKAROUND_INIT_ERROR = 117,
	INTEL_GUC_LOAD_STATUS_INVALID_INIT_DATA_RANGE_END = 118,
	INTEL_GUC_LOAD_STATUS_READY = 240,
};

enum intel_guc_rc_options {
	INTEL_GUCRC_HOST_CONTROL = 0,
	INTEL_GUCRC_FIRMWARE_CONTROL = 1,
};

enum intel_guc_recv_message {
	INTEL_GUC_RECV_MSG_CRASH_DUMP_POSTED = 2,
	INTEL_GUC_RECV_MSG_EXCEPTION = 1073741824,
};

enum intel_guc_state_capture_event_status {
	INTEL_GUC_STATE_CAPTURE_EVENT_STATUS_SUCCESS = 0,
	INTEL_GUC_STATE_CAPTURE_EVENT_STATUS_NOSPACE = 1,
};

enum intel_guc_tlb_inval_mode {
	INTEL_GUC_TLB_INVAL_MODE_HEAVY = 0,
	INTEL_GUC_TLB_INVAL_MODE_LITE = 1,
};

enum intel_guc_tlb_invalidation_type {
	INTEL_GUC_TLB_INVAL_ENGINES = 0,
	INTEL_GUC_TLB_INVAL_GUC = 3,
};

enum intel_hotplug_state {
	INTEL_HOTPLUG_UNCHANGED = 0,
	INTEL_HOTPLUG_CHANGED = 1,
	INTEL_HOTPLUG_RETRY = 2,
};

enum intel_huc_authentication_type {
	INTEL_HUC_AUTH_BY_GUC = 0,
	INTEL_HUC_AUTH_BY_GSC = 1,
	INTEL_HUC_AUTH_MAX_MODES = 2,
};

enum intel_huc_delayed_load_status {
	INTEL_HUC_WAITING_ON_GSC = 0,
	INTEL_HUC_WAITING_ON_PXP = 1,
	INTEL_HUC_DELAYED_LOAD_ERROR = 2,
};

enum intel_memory_type {
	INTEL_MEMORY_SYSTEM = 0,
	INTEL_MEMORY_LOCAL = 1,
	INTEL_MEMORY_STOLEN_SYSTEM = 2,
	INTEL_MEMORY_STOLEN_LOCAL = 3,
	INTEL_MEMORY_MOCK = 4,
};

enum intel_output_format {
	INTEL_OUTPUT_FORMAT_RGB = 0,
	INTEL_OUTPUT_FORMAT_YCBCR420 = 1,
	INTEL_OUTPUT_FORMAT_YCBCR444 = 2,
};

enum intel_output_type {
	INTEL_OUTPUT_UNUSED = 0,
	INTEL_OUTPUT_ANALOG = 1,
	INTEL_OUTPUT_DVO = 2,
	INTEL_OUTPUT_SDVO = 3,
	INTEL_OUTPUT_LVDS = 4,
	INTEL_OUTPUT_TVOUT = 5,
	INTEL_OUTPUT_HDMI = 6,
	INTEL_OUTPUT_DP = 7,
	INTEL_OUTPUT_EDP = 8,
	INTEL_OUTPUT_DSI = 9,
	INTEL_OUTPUT_DDI = 10,
	INTEL_OUTPUT_DP_MST = 11,
};

enum intel_pch {
	PCH_NOP = -1,
	PCH_NONE = 0,
	PCH_IBX = 1,
	PCH_CPT = 2,
	PCH_LPT = 3,
	PCH_SPT = 4,
	PCH_CNP = 5,
	PCH_ICP = 6,
	PCH_TGP = 7,
	PCH_ADP = 8,
	PCH_DG1 = 1024,
	PCH_DG2 = 1025,
	PCH_MTL = 1026,
	PCH_LNL = 1027,
};

enum intel_pipe_crc_source {
	INTEL_PIPE_CRC_SOURCE_NONE = 0,
	INTEL_PIPE_CRC_SOURCE_PLANE1 = 1,
	INTEL_PIPE_CRC_SOURCE_PLANE2 = 2,
	INTEL_PIPE_CRC_SOURCE_PLANE3 = 3,
	INTEL_PIPE_CRC_SOURCE_PLANE4 = 4,
	INTEL_PIPE_CRC_SOURCE_PLANE5 = 5,
	INTEL_PIPE_CRC_SOURCE_PLANE6 = 6,
	INTEL_PIPE_CRC_SOURCE_PLANE7 = 7,
	INTEL_PIPE_CRC_SOURCE_PIPE = 8,
	INTEL_PIPE_CRC_SOURCE_TV = 9,
	INTEL_PIPE_CRC_SOURCE_DP_B = 10,
	INTEL_PIPE_CRC_SOURCE_DP_C = 11,
	INTEL_PIPE_CRC_SOURCE_DP_D = 12,
	INTEL_PIPE_CRC_SOURCE_AUTO = 13,
	INTEL_PIPE_CRC_SOURCE_MAX = 14,
};

enum intel_platform {
	INTEL_PLATFORM_UNINITIALIZED = 0,
	INTEL_I830 = 1,
	INTEL_I845G = 2,
	INTEL_I85X = 3,
	INTEL_I865G = 4,
	INTEL_I915G = 5,
	INTEL_I915GM = 6,
	INTEL_I945G = 7,
	INTEL_I945GM = 8,
	INTEL_G33 = 9,
	INTEL_PINEVIEW = 10,
	INTEL_I965G = 11,
	INTEL_I965GM = 12,
	INTEL_G45 = 13,
	INTEL_GM45 = 14,
	INTEL_IRONLAKE = 15,
	INTEL_SANDYBRIDGE = 16,
	INTEL_IVYBRIDGE = 17,
	INTEL_VALLEYVIEW = 18,
	INTEL_HASWELL = 19,
	INTEL_BROADWELL = 20,
	INTEL_CHERRYVIEW = 21,
	INTEL_SKYLAKE = 22,
	INTEL_BROXTON = 23,
	INTEL_KABYLAKE = 24,
	INTEL_GEMINILAKE = 25,
	INTEL_COFFEELAKE = 26,
	INTEL_COMETLAKE = 27,
	INTEL_ICELAKE = 28,
	INTEL_ELKHARTLAKE = 29,
	INTEL_JASPERLAKE = 30,
	INTEL_TIGERLAKE = 31,
	INTEL_ROCKETLAKE = 32,
	INTEL_DG1 = 33,
	INTEL_ALDERLAKE_S = 34,
	INTEL_ALDERLAKE_P = 35,
	INTEL_DG2 = 36,
	INTEL_METEORLAKE = 37,
	INTEL_MAX_PLATFORMS = 38,
};

enum intel_ppgtt_type {
	INTEL_PPGTT_NONE = 0,
	INTEL_PPGTT_ALIASING = 1,
	INTEL_PPGTT_FULL = 2,
};

enum intel_quirk_id {
	QUIRK_BACKLIGHT_PRESENT = 0,
	QUIRK_INCREASE_DDI_DISABLED_TIME = 1,
	QUIRK_INCREASE_T12_DELAY = 2,
	QUIRK_INVERT_BRIGHTNESS = 3,
	QUIRK_LVDS_SSC_DISABLE = 4,
	QUIRK_NO_PPS_BACKLIGHT_POWER_HOOK = 5,
	QUIRK_FW_SYNC_LEN = 6,
};

enum intel_rc6_res_type {
	INTEL_RC6_RES_RC6_LOCKED = 0,
	INTEL_RC6_RES_RC6 = 1,
	INTEL_RC6_RES_RC6p = 2,
	INTEL_RC6_RES_RC6pp = 3,
	INTEL_RC6_RES_MAX = 4,
	INTEL_RC6_RES_VLV_MEDIA = 2,
};

enum intel_region_id {
	INTEL_REGION_SMEM = 0,
	INTEL_REGION_LMEM_0 = 1,
	INTEL_REGION_LMEM_1 = 2,
	INTEL_REGION_LMEM_2 = 3,
	INTEL_REGION_LMEM_3 = 4,
	INTEL_REGION_STOLEN_SMEM = 5,
	INTEL_REGION_STOLEN_LMEM = 6,
	INTEL_REGION_UNKNOWN = 7,
};

enum intel_sbi_destination {
	SBI_ICLK = 0,
	SBI_MPHY = 1,
};

enum intel_steering_type {
	L3BANK = 0,
	MSLICE = 1,
	LNCF = 2,
	GAM = 3,
	DSS = 4,
	OADDRM = 5,
	INSTANCE0 = 6,
	NUM_STEERING_TYPES = 7,
};

enum intel_step {
	STEP_NONE = 0,
	STEP_A0 = 1,
	STEP_A1 = 2,
	STEP_A2 = 3,
	STEP_A3 = 4,
	STEP_B0 = 5,
	STEP_B1 = 6,
	STEP_B2 = 7,
	STEP_B3 = 8,
	STEP_C0 = 9,
	STEP_C1 = 10,
	STEP_C2 = 11,
	STEP_C3 = 12,
	STEP_D0 = 13,
	STEP_D1 = 14,
	STEP_D2 = 15,
	STEP_D3 = 16,
	STEP_E0 = 17,
	STEP_E1 = 18,
	STEP_E2 = 19,
	STEP_E3 = 20,
	STEP_F0 = 21,
	STEP_F1 = 22,
	STEP_F2 = 23,
	STEP_F3 = 24,
	STEP_G0 = 25,
	STEP_G1 = 26,
	STEP_G2 = 27,
	STEP_G3 = 28,
	STEP_H0 = 29,
	STEP_H1 = 30,
	STEP_H2 = 31,
	STEP_H3 = 32,
	STEP_I0 = 33,
	STEP_I1 = 34,
	STEP_I2 = 35,
	STEP_I3 = 36,
	STEP_J0 = 37,
	STEP_J1 = 38,
	STEP_J2 = 39,
	STEP_J3 = 40,
	STEP_FUTURE = 41,
	STEP_FOREVER = 42,
};

enum intel_submission_method {
	INTEL_SUBMISSION_RING = 0,
	INTEL_SUBMISSION_ELSP = 1,
	INTEL_SUBMISSION_GUC = 2,
};

enum intel_uc_fw_status {
	INTEL_UC_FIRMWARE_NOT_SUPPORTED = -1,
	INTEL_UC_FIRMWARE_UNINITIALIZED = 0,
	INTEL_UC_FIRMWARE_DISABLED = 1,
	INTEL_UC_FIRMWARE_SELECTED = 2,
	INTEL_UC_FIRMWARE_MISSING = 3,
	INTEL_UC_FIRMWARE_ERROR = 4,
	INTEL_UC_FIRMWARE_AVAILABLE = 5,
	INTEL_UC_FIRMWARE_INIT_FAIL = 6,
	INTEL_UC_FIRMWARE_LOADABLE = 7,
	INTEL_UC_FIRMWARE_LOAD_FAIL = 8,
	INTEL_UC_FIRMWARE_TRANSFERRED = 9,
	INTEL_UC_FIRMWARE_RUNNING = 10,
};

enum intel_uc_fw_type {
	INTEL_UC_FW_TYPE_GUC = 0,
	INTEL_UC_FW_TYPE_HUC = 1,
	INTEL_UC_FW_TYPE_GSC = 2,
};

enum intercept_words {
	INTERCEPT_CR = 0,
	INTERCEPT_DR = 1,
	INTERCEPT_EXCEPTION = 2,
	INTERCEPT_WORD3 = 3,
	INTERCEPT_WORD4 = 4,
	INTERCEPT_WORD5 = 5,
	MAX_INTERCEPT = 6,
};

enum io_pgtable_caps {
	IO_PGTABLE_CAP_CUSTOM_ALLOCATOR = 1,
};

enum io_pgtable_fmt {
	ARM_32_LPAE_S1 = 0,
	ARM_32_LPAE_S2 = 1,
	ARM_64_LPAE_S1 = 2,
	ARM_64_LPAE_S2 = 3,
	ARM_V7S = 4,
	ARM_MALI_LPAE = 5,
	AMD_IOMMU_V1 = 6,
	AMD_IOMMU_V2 = 7,
	APPLE_DART = 8,
	APPLE_DART2 = 9,
	IO_PGTABLE_NUM_FMTS = 10,
};

enum io_uring_cmd_flags {
	IO_URING_F_COMPLETE_DEFER = 1,
	IO_URING_F_UNLOCKED = 2,
	IO_URING_F_MULTISHOT = 4,
	IO_URING_F_IOWQ = 8,
	IO_URING_F_NONBLOCK = -2147483648,
	IO_URING_F_SQE128 = 256,
	IO_URING_F_CQE32 = 512,
	IO_URING_F_IOPOLL = 1024,
	IO_URING_F_CANCEL = 2048,
	IO_URING_F_COMPAT = 4096,
	IO_URING_F_TASK_DEAD = 8192,
};

enum io_uring_msg_ring_flags {
	IORING_MSG_DATA = 0,
	IORING_MSG_SEND_FD = 1,
};

enum io_uring_napi_op {
	IO_URING_NAPI_REGISTER_OP = 0,
	IO_URING_NAPI_STATIC_ADD_ID = 1,
	IO_URING_NAPI_STATIC_DEL_ID = 2,
};

enum io_uring_napi_tracking_strategy {
	IO_URING_NAPI_TRACKING_DYNAMIC = 0,
	IO_URING_NAPI_TRACKING_STATIC = 1,
	IO_URING_NAPI_TRACKING_INACTIVE = 255,
};

enum io_uring_op {
	IORING_OP_NOP = 0,
	IORING_OP_READV = 1,
	IORING_OP_WRITEV = 2,
	IORING_OP_FSYNC = 3,
	IORING_OP_READ_FIXED = 4,
	IORING_OP_WRITE_FIXED = 5,
	IORING_OP_POLL_ADD = 6,
	IORING_OP_POLL_REMOVE = 7,
	IORING_OP_SYNC_FILE_RANGE = 8,
	IORING_OP_SENDMSG = 9,
	IORING_OP_RECVMSG = 10,
	IORING_OP_TIMEOUT = 11,
	IORING_OP_TIMEOUT_REMOVE = 12,
	IORING_OP_ACCEPT = 13,
	IORING_OP_ASYNC_CANCEL = 14,
	IORING_OP_LINK_TIMEOUT = 15,
	IORING_OP_CONNECT = 16,
	IORING_OP_FALLOCATE = 17,
	IORING_OP_OPENAT = 18,
	IORING_OP_CLOSE = 19,
	IORING_OP_FILES_UPDATE = 20,
	IORING_OP_STATX = 21,
	IORING_OP_READ = 22,
	IORING_OP_WRITE = 23,
	IORING_OP_FADVISE = 24,
	IORING_OP_MADVISE = 25,
	IORING_OP_SEND = 26,
	IORING_OP_RECV = 27,
	IORING_OP_OPENAT2 = 28,
	IORING_OP_EPOLL_CTL = 29,
	IORING_OP_SPLICE = 30,
	IORING_OP_PROVIDE_BUFFERS = 31,
	IORING_OP_REMOVE_BUFFERS = 32,
	IORING_OP_TEE = 33,
	IORING_OP_SHUTDOWN = 34,
	IORING_OP_RENAMEAT = 35,
	IORING_OP_UNLINKAT = 36,
	IORING_OP_MKDIRAT = 37,
	IORING_OP_SYMLINKAT = 38,
	IORING_OP_LINKAT = 39,
	IORING_OP_MSG_RING = 40,
	IORING_OP_FSETXATTR = 41,
	IORING_OP_SETXATTR = 42,
	IORING_OP_FGETXATTR = 43,
	IORING_OP_GETXATTR = 44,
	IORING_OP_SOCKET = 45,
	IORING_OP_URING_CMD = 46,
	IORING_OP_SEND_ZC = 47,
	IORING_OP_SENDMSG_ZC = 48,
	IORING_OP_READ_MULTISHOT = 49,
	IORING_OP_WAITID = 50,
	IORING_OP_FUTEX_WAIT = 51,
	IORING_OP_FUTEX_WAKE = 52,
	IORING_OP_FUTEX_WAITV = 53,
	IORING_OP_FIXED_FD_INSTALL = 54,
	IORING_OP_FTRUNCATE = 55,
	IORING_OP_BIND = 56,
	IORING_OP_LISTEN = 57,
	IORING_OP_LAST = 58,
};

enum io_uring_register_op {
	IORING_REGISTER_BUFFERS = 0,
	IORING_UNREGISTER_BUFFERS = 1,
	IORING_REGISTER_FILES = 2,
	IORING_UNREGISTER_FILES = 3,
	IORING_REGISTER_EVENTFD = 4,
	IORING_UNREGISTER_EVENTFD = 5,
	IORING_REGISTER_FILES_UPDATE = 6,
	IORING_REGISTER_EVENTFD_ASYNC = 7,
	IORING_REGISTER_PROBE = 8,
	IORING_REGISTER_PERSONALITY = 9,
	IORING_UNREGISTER_PERSONALITY = 10,
	IORING_REGISTER_RESTRICTIONS = 11,
	IORING_REGISTER_ENABLE_RINGS = 12,
	IORING_REGISTER_FILES2 = 13,
	IORING_REGISTER_FILES_UPDATE2 = 14,
	IORING_REGISTER_BUFFERS2 = 15,
	IORING_REGISTER_BUFFERS_UPDATE = 16,
	IORING_REGISTER_IOWQ_AFF = 17,
	IORING_UNREGISTER_IOWQ_AFF = 18,
	IORING_REGISTER_IOWQ_MAX_WORKERS = 19,
	IORING_REGISTER_RING_FDS = 20,
	IORING_UNREGISTER_RING_FDS = 21,
	IORING_REGISTER_PBUF_RING = 22,
	IORING_UNREGISTER_PBUF_RING = 23,
	IORING_REGISTER_SYNC_CANCEL = 24,
	IORING_REGISTER_FILE_ALLOC_RANGE = 25,
	IORING_REGISTER_PBUF_STATUS = 26,
	IORING_REGISTER_NAPI = 27,
	IORING_UNREGISTER_NAPI = 28,
	IORING_REGISTER_CLOCK = 29,
	IORING_REGISTER_CLONE_BUFFERS = 30,
	IORING_REGISTER_SEND_MSG_RING = 31,
	IORING_REGISTER_RESIZE_RINGS = 33,
	IORING_REGISTER_MEM_REGION = 34,
	IORING_REGISTER_LAST = 35,
	IORING_REGISTER_USE_REGISTERED_RING = 2147483648,
};

enum io_uring_register_pbuf_ring_flags {
	IOU_PBUF_RING_MMAP = 1,
	IOU_PBUF_RING_INC = 2,
};

enum io_uring_register_restriction_op {
	IORING_RESTRICTION_REGISTER_OP = 0,
	IORING_RESTRICTION_SQE_OP = 1,
	IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2,
	IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3,
	IORING_RESTRICTION_LAST = 4,
};

enum io_uring_socket_op {
	SOCKET_URING_OP_SIOCINQ = 0,
	SOCKET_URING_OP_SIOCOUTQ = 1,
	SOCKET_URING_OP_GETSOCKOPT = 2,
	SOCKET_URING_OP_SETSOCKOPT = 3,
};

enum io_uring_sqe_flags_bit {
	IOSQE_FIXED_FILE_BIT = 0,
	IOSQE_IO_DRAIN_BIT = 1,
	IOSQE_IO_LINK_BIT = 2,
	IOSQE_IO_HARDLINK_BIT = 3,
	IOSQE_ASYNC_BIT = 4,
	IOSQE_BUFFER_SELECT_BIT = 5,
	IOSQE_CQE_SKIP_SUCCESS_BIT = 6,
};

enum io_wq_cancel {
	IO_WQ_CANCEL_OK = 0,
	IO_WQ_CANCEL_RUNNING = 1,
	IO_WQ_CANCEL_NOTFOUND = 2,
};

enum io_wq_type {
	IO_WQ_BOUND = 0,
	IO_WQ_UNBOUND = 1,
};

enum ioam6_event_attr {
	IOAM6_EVENT_ATTR_UNSPEC = 0,
	IOAM6_EVENT_ATTR_TRACE_NAMESPACE = 1,
	IOAM6_EVENT_ATTR_TRACE_NODELEN = 2,
	IOAM6_EVENT_ATTR_TRACE_TYPE = 3,
	IOAM6_EVENT_ATTR_TRACE_DATA = 4,
	__IOAM6_EVENT_ATTR_MAX = 5,
};

enum ioam6_event_type {
	IOAM6_EVENT_UNSPEC = 0,
	IOAM6_EVENT_TRACE = 1,
};

enum ioapic_domain_type {
	IOAPIC_DOMAIN_INVALID = 0,
	IOAPIC_DOMAIN_LEGACY = 1,
	IOAPIC_DOMAIN_STRICT = 2,
	IOAPIC_DOMAIN_DYNAMIC = 3,
};

enum ioc_running {
	IOC_IDLE = 0,
	IOC_RUNNING = 1,
	IOC_STOP = 2,
};

enum iommu_cap {
	IOMMU_CAP_CACHE_COHERENCY = 0,
	IOMMU_CAP_NOEXEC = 1,
	IOMMU_CAP_PRE_BOOT_PROTECTION = 2,
	IOMMU_CAP_ENFORCE_CACHE_COHERENCY = 3,
	IOMMU_CAP_DEFERRED_FLUSH = 4,
	IOMMU_CAP_DIRTY_TRACKING = 5,
};

enum iommu_dev_features {
	IOMMU_DEV_FEAT_SVA = 0,
	IOMMU_DEV_FEAT_IOPF = 1,
};

enum iommu_dma_cookie_type {
	IOMMU_DMA_IOVA_COOKIE = 0,
	IOMMU_DMA_MSI_COOKIE = 1,
};

enum iommu_dma_queue_type {
	IOMMU_DMA_OPTS_PER_CPU_QUEUE = 0,
	IOMMU_DMA_OPTS_SINGLE_QUEUE = 1,
};

enum iommu_fault_type {
	IOMMU_FAULT_PAGE_REQ = 1,
};

enum iommu_hw_info_type {
	IOMMU_HW_INFO_TYPE_NONE = 0,
	IOMMU_HW_INFO_TYPE_INTEL_VTD = 1,
	IOMMU_HW_INFO_TYPE_ARM_SMMUV3 = 2,
};

enum iommu_hw_info_vtd_flags {
	IOMMU_HW_INFO_VTD_ERRATA_772415_SPR17 = 1,
};

enum iommu_hwpt_data_type {
	IOMMU_HWPT_DATA_NONE = 0,
	IOMMU_HWPT_DATA_VTD_S1 = 1,
	IOMMU_HWPT_DATA_ARM_SMMUV3 = 2,
};

enum iommu_hwpt_invalidate_data_type {
	IOMMU_HWPT_INVALIDATE_DATA_VTD_S1 = 0,
	IOMMU_VIOMMU_INVALIDATE_DATA_ARM_SMMUV3 = 1,
};

enum iommu_hwpt_vtd_s1_flags {
	IOMMU_VTD_S1_SRE = 1,
	IOMMU_VTD_S1_EAFE = 2,
	IOMMU_VTD_S1_WPE = 4,
};

enum iommu_hwpt_vtd_s1_invalidate_flags {
	IOMMU_VTD_INV_FLAGS_LEAF = 1,
};

enum iommu_init_state {
	IOMMU_START_STATE = 0,
	IOMMU_IVRS_DETECTED = 1,
	IOMMU_ACPI_FINISHED = 2,
	IOMMU_ENABLED = 3,
	IOMMU_PCI_INIT = 4,
	IOMMU_INTERRUPTS_EN = 5,
	IOMMU_INITIALIZED = 6,
	IOMMU_NOT_FOUND = 7,
	IOMMU_INIT_ERROR = 8,
	IOMMU_CMDLINE_DISABLED = 9,
};

enum iommu_page_response_code {
	IOMMU_PAGE_RESP_SUCCESS = 0,
	IOMMU_PAGE_RESP_INVALID = 1,
	IOMMU_PAGE_RESP_FAILURE = 2,
};

enum iommu_resv_type {
	IOMMU_RESV_DIRECT = 0,
	IOMMU_RESV_DIRECT_RELAXABLE = 1,
	IOMMU_RESV_RESERVED = 2,
	IOMMU_RESV_MSI = 3,
	IOMMU_RESV_SW_MSI = 4,
};

enum iommu_viommu_type {
	IOMMU_VIOMMU_TYPE_DEFAULT = 0,
	IOMMU_VIOMMU_TYPE_ARM_SMMUV3 = 1,
};

enum iommufd_hw_capabilities {
	IOMMU_HW_CAP_DIRTY_TRACKING = 1,
};

enum iommufd_hwpt_alloc_flags {
	IOMMU_HWPT_ALLOC_NEST_PARENT = 1,
	IOMMU_HWPT_ALLOC_DIRTY_TRACKING = 2,
	IOMMU_HWPT_FAULT_ID_VALID = 4,
	IOMMU_HWPT_ALLOC_PASID = 8,
};

enum iommufd_hwpt_get_dirty_bitmap_flags {
	IOMMU_HWPT_GET_DIRTY_BITMAP_NO_CLEAR = 1,
};

enum iommufd_hwpt_set_dirty_tracking_flags {
	IOMMU_HWPT_DIRTY_TRACKING_ENABLE = 1,
};

enum iommufd_ioas_map_flags {
	IOMMU_IOAS_MAP_FIXED_IOVA = 1,
	IOMMU_IOAS_MAP_WRITEABLE = 2,
	IOMMU_IOAS_MAP_READABLE = 4,
};

enum iommufd_object_type {
	IOMMUFD_OBJ_NONE = 0,
	IOMMUFD_OBJ_ANY = 0,
	IOMMUFD_OBJ_DEVICE = 1,
	IOMMUFD_OBJ_HWPT_PAGING = 2,
	IOMMUFD_OBJ_HWPT_NESTED = 3,
	IOMMUFD_OBJ_IOAS = 4,
	IOMMUFD_OBJ_ACCESS = 5,
	IOMMUFD_OBJ_FAULT = 6,
	IOMMUFD_OBJ_VIOMMU = 7,
	IOMMUFD_OBJ_VDEVICE = 8,
	IOMMUFD_OBJ_MAX = 9,
};

enum iommufd_option {
	IOMMU_OPTION_RLIMIT_MODE = 0,
	IOMMU_OPTION_HUGE_PAGES = 1,
};

enum iommufd_option_ops {
	IOMMU_OPTION_OP_SET = 0,
	IOMMU_OPTION_OP_GET = 1,
};

enum iommufd_page_response_code {
	IOMMUFD_PAGE_RESP_SUCCESS = 0,
	IOMMUFD_PAGE_RESP_INVALID = 1,
};

enum iommufd_vfio_ioas_op {
	IOMMU_VFIO_IOAS_GET = 0,
	IOMMU_VFIO_IOAS_SET = 1,
	IOMMU_VFIO_IOAS_CLEAR = 2,
};

enum iopt_address_type {
	IOPT_ADDRESS_USER = 0,
	IOPT_ADDRESS_FILE = 1,
};

enum ip6_defrag_users {
	IP6_DEFRAG_LOCAL_DELIVER = 0,
	IP6_DEFRAG_CONNTRACK_IN = 1,
	__IP6_DEFRAG_CONNTRACK_IN = 65536,
	IP6_DEFRAG_CONNTRACK_OUT = 65537,
	__IP6_DEFRAG_CONNTRACK_OUT = 131072,
	IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 131073,
	__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 196608,
};

enum ip6t_reject_with {
	IP6T_ICMP6_NO_ROUTE = 0,
	IP6T_ICMP6_ADM_PROHIBITED = 1,
	IP6T_ICMP6_NOT_NEIGHBOUR = 2,
	IP6T_ICMP6_ADDR_UNREACH = 3,
	IP6T_ICMP6_PORT_UNREACH = 4,
	IP6T_ICMP6_ECHOREPLY = 5,
	IP6T_TCP_RESET = 6,
	IP6T_ICMP6_POLICY_FAIL = 7,
	IP6T_ICMP6_REJECT_ROUTE = 8,
};

enum ip_conntrack_dir {
	IP_CT_DIR_ORIGINAL = 0,
	IP_CT_DIR_REPLY = 1,
	IP_CT_DIR_MAX = 2,
};

enum ip_conntrack_events {
	IPCT_NEW = 0,
	IPCT_RELATED = 1,
	IPCT_DESTROY = 2,
	IPCT_REPLY = 3,
	IPCT_ASSURED = 4,
	IPCT_PROTOINFO = 5,
	IPCT_HELPER = 6,
	IPCT_MARK = 7,
	IPCT_SEQADJ = 8,
	IPCT_NATSEQADJ = 8,
	IPCT_SECMARK = 9,
	IPCT_LABEL = 10,
	IPCT_SYNPROXY = 11,
	__IPCT_MAX = 12,
};

enum ip_conntrack_expect_events {
	IPEXP_NEW = 0,
	IPEXP_DESTROY = 1,
};

enum ip_conntrack_info {
	IP_CT_ESTABLISHED = 0,
	IP_CT_RELATED = 1,
	IP_CT_NEW = 2,
	IP_CT_IS_REPLY = 3,
	IP_CT_ESTABLISHED_REPLY = 3,
	IP_CT_RELATED_REPLY = 4,
	IP_CT_NUMBER = 5,
	IP_CT_UNTRACKED = 7,
};

enum ip_conntrack_status {
	IPS_EXPECTED_BIT = 0,
	IPS_EXPECTED = 1,
	IPS_SEEN_REPLY_BIT = 1,
	IPS_SEEN_REPLY = 2,
	IPS_ASSURED_BIT = 2,
	IPS_ASSURED = 4,
	IPS_CONFIRMED_BIT = 3,
	IPS_CONFIRMED = 8,
	IPS_SRC_NAT_BIT = 4,
	IPS_SRC_NAT = 16,
	IPS_DST_NAT_BIT = 5,
	IPS_DST_NAT = 32,
	IPS_NAT_MASK = 48,
	IPS_SEQ_ADJUST_BIT = 6,
	IPS_SEQ_ADJUST = 64,
	IPS_SRC_NAT_DONE_BIT = 7,
	IPS_SRC_NAT_DONE = 128,
	IPS_DST_NAT_DONE_BIT = 8,
	IPS_DST_NAT_DONE = 256,
	IPS_NAT_DONE_MASK = 384,
	IPS_DYING_BIT = 9,
	IPS_DYING = 512,
	IPS_FIXED_TIMEOUT_BIT = 10,
	IPS_FIXED_TIMEOUT = 1024,
	IPS_TEMPLATE_BIT = 11,
	IPS_TEMPLATE = 2048,
	IPS_UNTRACKED_BIT = 12,
	IPS_UNTRACKED = 4096,
	IPS_NAT_CLASH_BIT = 12,
	IPS_NAT_CLASH = 4096,
	IPS_HELPER_BIT = 13,
	IPS_HELPER = 8192,
	IPS_OFFLOAD_BIT = 14,
	IPS_OFFLOAD = 16384,
	IPS_HW_OFFLOAD_BIT = 15,
	IPS_HW_OFFLOAD = 32768,
	IPS_UNCHANGEABLE_MASK = 56313,
	__IPS_MAX_BIT = 16,
};

enum ip_defrag_users {
	IP_DEFRAG_LOCAL_DELIVER = 0,
	IP_DEFRAG_CALL_RA_CHAIN = 1,
	IP_DEFRAG_CONNTRACK_IN = 2,
	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
	IP_DEFRAG_CONNTRACK_OUT = 65538,
	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
	IP_DEFRAG_VS_IN = 196610,
	IP_DEFRAG_VS_OUT = 196611,
	IP_DEFRAG_VS_FWD = 196612,
	IP_DEFRAG_AF_PACKET = 196613,
	IP_DEFRAG_MACVLAN = 196614,
};

enum ip_set_dim {
	IPSET_DIM_ZERO = 0,
	IPSET_DIM_ONE = 1,
	IPSET_DIM_TWO = 2,
	IPSET_DIM_THREE = 3,
	IPSET_DIM_MAX = 6,
	IPSET_BIT_RETURN_NOMATCH = 7,
};

enum ip_set_ext_id {
	IPSET_EXT_ID_COUNTER = 0,
	IPSET_EXT_ID_TIMEOUT = 1,
	IPSET_EXT_ID_SKBINFO = 2,
	IPSET_EXT_ID_COMMENT = 3,
	IPSET_EXT_ID_MAX = 4,
};

enum ip_set_extension {
	IPSET_EXT_BIT_TIMEOUT = 0,
	IPSET_EXT_TIMEOUT = 1,
	IPSET_EXT_BIT_COUNTER = 1,
	IPSET_EXT_COUNTER = 2,
	IPSET_EXT_BIT_COMMENT = 2,
	IPSET_EXT_COMMENT = 4,
	IPSET_EXT_BIT_SKBINFO = 3,
	IPSET_EXT_SKBINFO = 8,
	IPSET_EXT_BIT_DESTROY = 7,
	IPSET_EXT_DESTROY = 128,
};

enum ip_set_feature {
	IPSET_TYPE_IP_FLAG = 0,
	IPSET_TYPE_IP = 1,
	IPSET_TYPE_PORT_FLAG = 1,
	IPSET_TYPE_PORT = 2,
	IPSET_TYPE_MAC_FLAG = 2,
	IPSET_TYPE_MAC = 4,
	IPSET_TYPE_IP2_FLAG = 3,
	IPSET_TYPE_IP2 = 8,
	IPSET_TYPE_NAME_FLAG = 4,
	IPSET_TYPE_NAME = 16,
	IPSET_TYPE_IFACE_FLAG = 5,
	IPSET_TYPE_IFACE = 32,
	IPSET_TYPE_MARK_FLAG = 6,
	IPSET_TYPE_MARK = 64,
	IPSET_TYPE_NOMATCH_FLAG = 7,
	IPSET_TYPE_NOMATCH = 128,
	IPSET_DUMP_LAST_FLAG = 8,
	IPSET_DUMP_LAST = 256,
};

enum ip_set_kopt {
	IPSET_INV_MATCH = 1,
	IPSET_DIM_ONE_SRC = 2,
	IPSET_DIM_TWO_SRC = 4,
	IPSET_DIM_THREE_SRC = 8,
	IPSET_RETURN_NOMATCH = 128,
};

enum ipset_adt {
	IPSET_ADD = 0,
	IPSET_DEL = 1,
	IPSET_TEST = 2,
	IPSET_ADT_MAX = 3,
	IPSET_CREATE = 3,
	IPSET_CADT_MAX = 4,
};

enum ipset_cadt_flags {
	IPSET_FLAG_BIT_BEFORE = 0,
	IPSET_FLAG_BEFORE = 1,
	IPSET_FLAG_BIT_PHYSDEV = 1,
	IPSET_FLAG_PHYSDEV = 2,
	IPSET_FLAG_BIT_NOMATCH = 2,
	IPSET_FLAG_NOMATCH = 4,
	IPSET_FLAG_BIT_WITH_COUNTERS = 3,
	IPSET_FLAG_WITH_COUNTERS = 8,
	IPSET_FLAG_BIT_WITH_COMMENT = 4,
	IPSET_FLAG_WITH_COMMENT = 16,
	IPSET_FLAG_BIT_WITH_FORCEADD = 5,
	IPSET_FLAG_WITH_FORCEADD = 32,
	IPSET_FLAG_BIT_WITH_SKBINFO = 6,
	IPSET_FLAG_WITH_SKBINFO = 64,
	IPSET_FLAG_BIT_IFACE_WILDCARD = 7,
	IPSET_FLAG_IFACE_WILDCARD = 128,
	IPSET_FLAG_CADT_MAX = 15,
};

enum ipset_cmd {
	IPSET_CMD_NONE = 0,
	IPSET_CMD_PROTOCOL = 1,
	IPSET_CMD_CREATE = 2,
	IPSET_CMD_DESTROY = 3,
	IPSET_CMD_FLUSH = 4,
	IPSET_CMD_RENAME = 5,
	IPSET_CMD_SWAP = 6,
	IPSET_CMD_LIST = 7,
	IPSET_CMD_SAVE = 8,
	IPSET_CMD_ADD = 9,
	IPSET_CMD_DEL = 10,
	IPSET_CMD_TEST = 11,
	IPSET_CMD_HEADER = 12,
	IPSET_CMD_TYPE = 13,
	IPSET_CMD_GET_BYNAME = 14,
	IPSET_CMD_GET_BYINDEX = 15,
	IPSET_MSG_MAX = 16,
	IPSET_CMD_RESTORE = 16,
	IPSET_CMD_HELP = 17,
	IPSET_CMD_VERSION = 18,
	IPSET_CMD_QUIT = 19,
	IPSET_CMD_MAX = 20,
	IPSET_CMD_COMMIT = 20,
};

enum ipset_cmd_flags {
	IPSET_FLAG_BIT_EXIST = 0,
	IPSET_FLAG_EXIST = 1,
	IPSET_FLAG_BIT_LIST_SETNAME = 1,
	IPSET_FLAG_LIST_SETNAME = 2,
	IPSET_FLAG_BIT_LIST_HEADER = 2,
	IPSET_FLAG_LIST_HEADER = 4,
	IPSET_FLAG_BIT_SKIP_COUNTER_UPDATE = 3,
	IPSET_FLAG_SKIP_COUNTER_UPDATE = 8,
	IPSET_FLAG_BIT_SKIP_SUBCOUNTER_UPDATE = 4,
	IPSET_FLAG_SKIP_SUBCOUNTER_UPDATE = 16,
	IPSET_FLAG_BIT_MATCH_COUNTERS = 5,
	IPSET_FLAG_MATCH_COUNTERS = 32,
	IPSET_FLAG_BIT_RETURN_NOMATCH = 7,
	IPSET_FLAG_RETURN_NOMATCH = 128,
	IPSET_FLAG_BIT_MAP_SKBMARK = 8,
	IPSET_FLAG_MAP_SKBMARK = 256,
	IPSET_FLAG_BIT_MAP_SKBPRIO = 9,
	IPSET_FLAG_MAP_SKBPRIO = 512,
	IPSET_FLAG_BIT_MAP_SKBQUEUE = 10,
	IPSET_FLAG_MAP_SKBQUEUE = 1024,
	IPSET_FLAG_CMD_MAX = 15,
};

enum ipset_create_flags {
	IPSET_CREATE_FLAG_BIT_FORCEADD = 0,
	IPSET_CREATE_FLAG_FORCEADD = 1,
	IPSET_CREATE_FLAG_BIT_BUCKETSIZE = 1,
	IPSET_CREATE_FLAG_BUCKETSIZE = 2,
	IPSET_CREATE_FLAG_BIT_MAX = 7,
};

enum ipset_errno {
	IPSET_ERR_PRIVATE = 4096,
	IPSET_ERR_PROTOCOL = 4097,
	IPSET_ERR_FIND_TYPE = 4098,
	IPSET_ERR_MAX_SETS = 4099,
	IPSET_ERR_BUSY = 4100,
	IPSET_ERR_EXIST_SETNAME2 = 4101,
	IPSET_ERR_TYPE_MISMATCH = 4102,
	IPSET_ERR_EXIST = 4103,
	IPSET_ERR_INVALID_CIDR = 4104,
	IPSET_ERR_INVALID_NETMASK = 4105,
	IPSET_ERR_INVALID_FAMILY = 4106,
	IPSET_ERR_TIMEOUT = 4107,
	IPSET_ERR_REFERENCED = 4108,
	IPSET_ERR_IPADDR_IPV4 = 4109,
	IPSET_ERR_IPADDR_IPV6 = 4110,
	IPSET_ERR_COUNTER = 4111,
	IPSET_ERR_COMMENT = 4112,
	IPSET_ERR_INVALID_MARKMASK = 4113,
	IPSET_ERR_SKBINFO = 4114,
	IPSET_ERR_BITMASK_NETMASK_EXCL = 4115,
	IPSET_ERR_TYPE_SPECIFIC = 4352,
};

enum ipt_reject_with {
	IPT_ICMP_NET_UNREACHABLE = 0,
	IPT_ICMP_HOST_UNREACHABLE = 1,
	IPT_ICMP_PROT_UNREACHABLE = 2,
	IPT_ICMP_PORT_UNREACHABLE = 3,
	IPT_ICMP_ECHOREPLY = 4,
	IPT_ICMP_NET_PROHIBITED = 5,
	IPT_ICMP_HOST_PROHIBITED = 6,
	IPT_TCP_RESET = 7,
	IPT_ICMP_ADMIN_PROHIBITED = 8,
};

enum ipvlan_mode {
	IPVLAN_MODE_L2 = 0,
	IPVLAN_MODE_L3 = 1,
	IPVLAN_MODE_L3S = 2,
	IPVLAN_MODE_MAX = 3,
};

enum irq_alloc_type {
	X86_IRQ_ALLOC_TYPE_IOAPIC = 1,
	X86_IRQ_ALLOC_TYPE_HPET = 2,
	X86_IRQ_ALLOC_TYPE_PCI_MSI = 3,
	X86_IRQ_ALLOC_TYPE_PCI_MSIX = 4,
	X86_IRQ_ALLOC_TYPE_DMAR = 5,
	X86_IRQ_ALLOC_TYPE_AMDVI = 6,
	X86_IRQ_ALLOC_TYPE_UV = 7,
};

enum irq_domain_bus_token {
	DOMAIN_BUS_ANY = 0,
	DOMAIN_BUS_WIRED = 1,
	DOMAIN_BUS_GENERIC_MSI = 2,
	DOMAIN_BUS_PCI_MSI = 3,
	DOMAIN_BUS_PLATFORM_MSI = 4,
	DOMAIN_BUS_NEXUS = 5,
	DOMAIN_BUS_IPI = 6,
	DOMAIN_BUS_FSL_MC_MSI = 7,
	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
	DOMAIN_BUS_WAKEUP = 9,
	DOMAIN_BUS_VMD_MSI = 10,
	DOMAIN_BUS_PCI_DEVICE_MSI = 11,
	DOMAIN_BUS_PCI_DEVICE_MSIX = 12,
	DOMAIN_BUS_DMAR = 13,
	DOMAIN_BUS_AMDVI = 14,
	DOMAIN_BUS_DEVICE_MSI = 15,
	DOMAIN_BUS_WIRED_TO_MSI = 16,
};

enum irq_gc_flags {
	IRQ_GC_INIT_MASK_CACHE = 1,
	IRQ_GC_INIT_NESTED_LOCK = 2,
	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
	IRQ_GC_NO_MASK = 8,
	IRQ_GC_BE_IO = 16,
};

enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING = 0,
	IRQCHIP_STATE_ACTIVE = 1,
	IRQCHIP_STATE_MASKED = 2,
	IRQCHIP_STATE_LINE_LEVEL = 3,
};

enum irqreturn {
	IRQ_NONE = 0,
	IRQ_HANDLED = 1,
	IRQ_WAKE_THREAD = 2,
};

typedef enum irqreturn irqreturn_t;

enum isofs_file_format {
	isofs_file_normal = 0,
	isofs_file_sparse = 1,
	isofs_file_compressed = 2,
};

enum it_action {
	IT_NEXT = 0,
	IT_COMPLETE = 1,
};

enum iter_type {
	ITER_UBUF = 0,
	ITER_IOVEC = 1,
	ITER_BVEC = 2,
	ITER_KVEC = 3,
	ITER_FOLIOQ = 4,
	ITER_XARRAY = 5,
	ITER_DISCARD = 6,
};

enum jbd2_shrink_type {
	JBD2_SHRINK_DESTROY = 0,
	JBD2_SHRINK_BUSY_STOP = 1,
	JBD2_SHRINK_BUSY_SKIP = 2,
};

enum jbd_state_bits {
	BH_JBD = 16,
	BH_JWrite = 17,
	BH_Freed = 18,
	BH_Revoked = 19,
	BH_RevokeValid = 20,
	BH_JBDDirty = 21,
	BH_JournalHead = 22,
	BH_Shadow = 23,
	BH_Verified = 24,
	BH_JBDPrivateStart = 25,
};

enum jump_label_type {
	JUMP_LABEL_NOP = 0,
	JUMP_LABEL_JMP = 1,
};

enum kcmp_type {
	KCMP_FILE = 0,
	KCMP_VM = 1,
	KCMP_FILES = 2,
	KCMP_FS = 3,
	KCMP_SIGHAND = 4,
	KCMP_IO = 5,
	KCMP_SYSVSEM = 6,
	KCMP_EPOLL_TFD = 7,
	KCMP_TYPES = 8,
};

enum kcore_type {
	KCORE_TEXT = 0,
	KCORE_VMALLOC = 1,
	KCORE_RAM = 2,
	KCORE_VMEMMAP = 3,
	KCORE_USER = 4,
};

enum kernel_gp_hint {
	GP_NO_HINT = 0,
	GP_NON_CANONICAL = 1,
	GP_CANONICAL = 2,
};

enum kernel_load_data_id {
	LOADING_UNKNOWN = 0,
	LOADING_FIRMWARE = 1,
	LOADING_MODULE = 2,
	LOADING_KEXEC_IMAGE = 3,
	LOADING_KEXEC_INITRAMFS = 4,
	LOADING_POLICY = 5,
	LOADING_X509_CERTIFICATE = 6,
	LOADING_MAX_ID = 7,
};

enum kernel_pkey_operation {
	kernel_pkey_encrypt = 0,
	kernel_pkey_decrypt = 1,
	kernel_pkey_sign = 2,
	kernel_pkey_verify = 3,
};

enum kernel_read_file_id {
	READING_UNKNOWN = 0,
	READING_FIRMWARE = 1,
	READING_MODULE = 2,
	READING_KEXEC_IMAGE = 3,
	READING_KEXEC_INITRAMFS = 4,
	READING_POLICY = 5,
	READING_X509_CERTIFICATE = 6,
	READING_MAX_ID = 7,
};

enum kernfs_node_flag {
	KERNFS_ACTIVATED = 16,
	KERNFS_NS = 32,
	KERNFS_HAS_SEQ_SHOW = 64,
	KERNFS_HAS_MMAP = 128,
	KERNFS_LOCKDEP = 256,
	KERNFS_HIDDEN = 512,
	KERNFS_SUICIDAL = 1024,
	KERNFS_SUICIDED = 2048,
	KERNFS_EMPTY_DIR = 4096,
	KERNFS_HAS_RELEASE = 8192,
	KERNFS_REMOVING = 16384,
};

enum kernfs_node_type {
	KERNFS_DIR = 1,
	KERNFS_FILE = 2,
	KERNFS_LINK = 4,
};

enum kernfs_root_flag {
	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
	KERNFS_ROOT_SUPPORT_USER_XATTR = 8,
};

enum key_being_used_for {
	VERIFYING_MODULE_SIGNATURE = 0,
	VERIFYING_FIRMWARE_SIGNATURE = 1,
	VERIFYING_KEXEC_PE_SIGNATURE = 2,
	VERIFYING_KEY_SIGNATURE = 3,
	VERIFYING_KEY_SELF_SIGNATURE = 4,
	VERIFYING_UNSPECIFIED_SIGNATURE = 5,
	NR__KEY_BEING_USED_FOR = 6,
};

enum key_lookup_flag {
	KEY_LOOKUP_CREATE = 1,
	KEY_LOOKUP_PARTIAL = 2,
	KEY_LOOKUP_ALL = 3,
};

enum key_need_perm {
	KEY_NEED_UNSPECIFIED = 0,
	KEY_NEED_VIEW = 1,
	KEY_NEED_READ = 2,
	KEY_NEED_WRITE = 3,
	KEY_NEED_SEARCH = 4,
	KEY_NEED_LINK = 5,
	KEY_NEED_SETATTR = 6,
	KEY_NEED_UNLINK = 7,
	KEY_SYSADMIN_OVERRIDE = 8,
	KEY_AUTHTOKEN_OVERRIDE = 9,
	KEY_DEFER_PERM_CHECK = 10,
};

enum key_notification_subtype {
	NOTIFY_KEY_INSTANTIATED = 0,
	NOTIFY_KEY_UPDATED = 1,
	NOTIFY_KEY_LINKED = 2,
	NOTIFY_KEY_UNLINKED = 3,
	NOTIFY_KEY_CLEARED = 4,
	NOTIFY_KEY_REVOKED = 5,
	NOTIFY_KEY_INVALIDATED = 6,
	NOTIFY_KEY_SETATTR = 7,
};

enum key_state {
	KEY_IS_UNINSTANTIATED = 0,
	KEY_IS_POSITIVE = 1,
};

enum kfence_counter_id {
	KFENCE_COUNTER_ALLOCATED = 0,
	KFENCE_COUNTER_ALLOCS = 1,
	KFENCE_COUNTER_FREES = 2,
	KFENCE_COUNTER_ZOMBIES = 3,
	KFENCE_COUNTER_BUGS = 4,
	KFENCE_COUNTER_SKIP_INCOMPAT = 5,
	KFENCE_COUNTER_SKIP_CAPACITY = 6,
	KFENCE_COUNTER_SKIP_COVERED = 7,
	KFENCE_COUNTER_COUNT = 8,
};

enum kfence_error_type {
	KFENCE_ERROR_OOB = 0,
	KFENCE_ERROR_UAF = 1,
	KFENCE_ERROR_CORRUPTION = 2,
	KFENCE_ERROR_INVALID = 3,
	KFENCE_ERROR_INVALID_FREE = 4,
};

enum kfence_object_state {
	KFENCE_OBJECT_UNUSED = 0,
	KFENCE_OBJECT_ALLOCATED = 1,
	KFENCE_OBJECT_RCU_FREEING = 2,
	KFENCE_OBJECT_FREED = 3,
};

enum kfunc_ptr_arg_type {
	KF_ARG_PTR_TO_CTX = 0,
	KF_ARG_PTR_TO_ALLOC_BTF_ID = 1,
	KF_ARG_PTR_TO_REFCOUNTED_KPTR = 2,
	KF_ARG_PTR_TO_DYNPTR = 3,
	KF_ARG_PTR_TO_ITER = 4,
	KF_ARG_PTR_TO_LIST_HEAD = 5,
	KF_ARG_PTR_TO_LIST_NODE = 6,
	KF_ARG_PTR_TO_BTF_ID = 7,
	KF_ARG_PTR_TO_MEM = 8,
	KF_ARG_PTR_TO_MEM_SIZE = 9,
	KF_ARG_PTR_TO_CALLBACK = 10,
	KF_ARG_PTR_TO_RB_ROOT = 11,
	KF_ARG_PTR_TO_RB_NODE = 12,
	KF_ARG_PTR_TO_NULL = 13,
	KF_ARG_PTR_TO_CONST_STR = 14,
	KF_ARG_PTR_TO_MAP = 15,
	KF_ARG_PTR_TO_WORKQUEUE = 16,
	KF_ARG_PTR_TO_IRQ_FLAG = 17,
};

enum kmalloc_cache_type {
	KMALLOC_NORMAL = 0,
	KMALLOC_RANDOM_START = 0,
	KMALLOC_RANDOM_END = 15,
	KMALLOC_RECLAIM = 16,
	KMALLOC_DMA = 17,
	KMALLOC_CGROUP = 18,
	NR_KMALLOC_TYPES = 19,
};

enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF = 0,
	KMSG_DUMP_PANIC = 1,
	KMSG_DUMP_OOPS = 2,
	KMSG_DUMP_EMERG = 3,
	KMSG_DUMP_SHUTDOWN = 4,
	KMSG_DUMP_MAX = 5,
};

enum kobj_ns_type {
	KOBJ_NS_TYPE_NONE = 0,
	KOBJ_NS_TYPE_NET = 1,
	KOBJ_NS_TYPES = 2,
};

enum kobject_action {
	KOBJ_ADD = 0,
	KOBJ_REMOVE = 1,
	KOBJ_CHANGE = 2,
	KOBJ_MOVE = 3,
	KOBJ_ONLINE = 4,
	KOBJ_OFFLINE = 5,
	KOBJ_BIND = 6,
	KOBJ_UNBIND = 7,
};

enum kprobe_slot_state {
	SLOT_CLEAN = 0,
	SLOT_DIRTY = 1,
	SLOT_USED = 2,
};

enum kvm_apic_logical_mode {
	KVM_APIC_MODE_SW_DISABLED = 0,
	KVM_APIC_MODE_XAPIC_CLUSTER = 1,
	KVM_APIC_MODE_XAPIC_FLAT = 2,
	KVM_APIC_MODE_X2APIC = 3,
	KVM_APIC_MODE_MAP_DISABLED = 4,
};

enum kvm_bus {
	KVM_MMIO_BUS = 0,
	KVM_PIO_BUS = 1,
	KVM_VIRTIO_CCW_NOTIFY_BUS = 2,
	KVM_FAST_MMIO_BUS = 3,
	KVM_IOCSR_BUS = 4,
	KVM_NR_BUSES = 5,
};

enum kvm_irqchip_mode {
	KVM_IRQCHIP_NONE = 0,
	KVM_IRQCHIP_KERNEL = 1,
	KVM_IRQCHIP_SPLIT = 2,
};

enum kvm_only_cpuid_leafs {
	CPUID_12_EAX = 22,
	CPUID_7_1_EDX = 23,
	CPUID_8000_0007_EDX = 24,
	CPUID_8000_0022_EAX = 25,
	CPUID_7_2_EDX = 26,
	CPUID_24_0_EBX = 27,
	NR_KVM_CPU_CAPS = 28,
	NKVMCAPINTS = 6,
};

enum kvm_reg {
	VCPU_REGS_RAX = 0,
	VCPU_REGS_RCX = 1,
	VCPU_REGS_RDX = 2,
	VCPU_REGS_RBX = 3,
	VCPU_REGS_RSP = 4,
	VCPU_REGS_RBP = 5,
	VCPU_REGS_RSI = 6,
	VCPU_REGS_RDI = 7,
	VCPU_REGS_R8 = 8,
	VCPU_REGS_R9 = 9,
	VCPU_REGS_R10 = 10,
	VCPU_REGS_R11 = 11,
	VCPU_REGS_R12 = 12,
	VCPU_REGS_R13 = 13,
	VCPU_REGS_R14 = 14,
	VCPU_REGS_R15 = 15,
	VCPU_REGS_RIP = 16,
	NR_VCPU_REGS = 17,
	VCPU_EXREG_PDPTR = 17,
	VCPU_EXREG_CR0 = 18,
	VCPU_EXREG_CR3 = 19,
	VCPU_EXREG_CR4 = 20,
	VCPU_EXREG_RFLAGS = 21,
	VCPU_EXREG_SEGMENTS = 22,
	VCPU_EXREG_EXIT_INFO_1 = 23,
	VCPU_EXREG_EXIT_INFO_2 = 24,
};

enum kvm_stat_kind {
	KVM_STAT_VM = 0,
	KVM_STAT_VCPU = 1,
};

enum l1d_flush_mitigations {
	L1D_FLUSH_OFF = 0,
	L1D_FLUSH_ON = 1,
};

enum l1tf_mitigations {
	L1TF_MITIGATION_OFF = 0,
	L1TF_MITIGATION_FLUSH_NOWARN = 1,
	L1TF_MITIGATION_FLUSH = 2,
	L1TF_MITIGATION_FLUSH_NOSMT = 3,
	L1TF_MITIGATION_FULL = 4,
	L1TF_MITIGATION_FULL_FORCE = 5,
};

enum l2tp_debug_flags {
	L2TP_MSG_DEBUG = 1,
	L2TP_MSG_CONTROL = 2,
	L2TP_MSG_SEQ = 4,
	L2TP_MSG_DATA = 8,
};

enum l2tp_encap_type {
	L2TP_ENCAPTYPE_UDP = 0,
	L2TP_ENCAPTYPE_IP = 1,
};

enum l2tp_l2spec_type {
	L2TP_L2SPECTYPE_NONE = 0,
	L2TP_L2SPECTYPE_DEFAULT = 1,
};

enum l2tp_pwtype {
	L2TP_PWTYPE_NONE = 0,
	L2TP_PWTYPE_ETH_VLAN = 4,
	L2TP_PWTYPE_ETH = 5,
	L2TP_PWTYPE_PPP = 7,
	L2TP_PWTYPE_PPP_AC = 8,
	L2TP_PWTYPE_IP = 11,
	__L2TP_PWTYPE_MAX = 12,
};

enum l3mdev_type {
	L3MDEV_TYPE_UNSPEC = 0,
	L3MDEV_TYPE_VRF = 1,
	__L3MDEV_TYPE_MAX = 2,
};

enum latency_count {
	COUNTS_10e2 = 0,
	COUNTS_10e3 = 1,
	COUNTS_10e4 = 2,
	COUNTS_10e5 = 3,
	COUNTS_10e6 = 4,
	COUNTS_10e7 = 5,
	COUNTS_10e8_plus = 6,
	COUNTS_MIN = 7,
	COUNTS_MAX = 8,
	COUNTS_SUM = 9,
	COUNTS_NUM = 10,
};

enum latency_type {
	DMAR_LATENCY_INV_IOTLB = 0,
	DMAR_LATENCY_INV_DEVTLB = 1,
	DMAR_LATENCY_INV_IEC = 2,
	DMAR_LATENCY_NUM = 3,
};

enum layout_break_reason {
	BREAK_WRITE = 0,
	BREAK_UNMAP = 1,
};

enum led_brightness {
	LED_OFF = 0,
	LED_ON = 1,
	LED_HALF = 127,
	LED_FULL = 255,
};

enum led_default_state {
	LEDS_DEFSTATE_OFF = 0,
	LEDS_DEFSTATE_ON = 1,
	LEDS_DEFSTATE_KEEP = 2,
};

enum legacy_fs_param {
	LEGACY_FS_UNSET_PARAMS = 0,
	LEGACY_FS_MONOLITHIC_PARAMS = 1,
	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
};

enum limit_by4 {
	NFS4_LIMIT_SIZE = 1,
	NFS4_LIMIT_BLOCKS = 2,
};

enum link_inband_signalling {
	LINK_INBAND_DISABLE = 1,
	LINK_INBAND_ENABLE = 2,
	LINK_INBAND_BYPASS = 4,
};

enum linux_mptcp_mib_field {
	MPTCP_MIB_NUM = 0,
	MPTCP_MIB_MPCAPABLEPASSIVE = 1,
	MPTCP_MIB_MPCAPABLEACTIVE = 2,
	MPTCP_MIB_MPCAPABLEACTIVEACK = 3,
	MPTCP_MIB_MPCAPABLEPASSIVEACK = 4,
	MPTCP_MIB_MPCAPABLEPASSIVEFALLBACK = 5,
	MPTCP_MIB_MPCAPABLEACTIVEFALLBACK = 6,
	MPTCP_MIB_MPCAPABLEACTIVEDROP = 7,
	MPTCP_MIB_MPCAPABLEACTIVEDISABLED = 8,
	MPTCP_MIB_MPCAPABLEENDPATTEMPT = 9,
	MPTCP_MIB_TOKENFALLBACKINIT = 10,
	MPTCP_MIB_RETRANSSEGS = 11,
	MPTCP_MIB_JOINNOTOKEN = 12,
	MPTCP_MIB_JOINSYNRX = 13,
	MPTCP_MIB_JOINSYNBACKUPRX = 14,
	MPTCP_MIB_JOINSYNACKRX = 15,
	MPTCP_MIB_JOINSYNACKBACKUPRX = 16,
	MPTCP_MIB_JOINSYNACKMAC = 17,
	MPTCP_MIB_JOINACKRX = 18,
	MPTCP_MIB_JOINACKMAC = 19,
	MPTCP_MIB_JOINSYNTX = 20,
	MPTCP_MIB_JOINSYNTXCREATSKERR = 21,
	MPTCP_MIB_JOINSYNTXBINDERR = 22,
	MPTCP_MIB_JOINSYNTXCONNECTERR = 23,
	MPTCP_MIB_DSSNOMATCH = 24,
	MPTCP_MIB_DSSCORRUPTIONFALLBACK = 25,
	MPTCP_MIB_DSSCORRUPTIONRESET = 26,
	MPTCP_MIB_INFINITEMAPTX = 27,
	MPTCP_MIB_INFINITEMAPRX = 28,
	MPTCP_MIB_DSSTCPMISMATCH = 29,
	MPTCP_MIB_DATACSUMERR = 30,
	MPTCP_MIB_OFOQUEUETAIL = 31,
	MPTCP_MIB_OFOQUEUE = 32,
	MPTCP_MIB_OFOMERGE = 33,
	MPTCP_MIB_NODSSWINDOW = 34,
	MPTCP_MIB_DUPDATA = 35,
	MPTCP_MIB_ADDADDR = 36,
	MPTCP_MIB_ADDADDRTX = 37,
	MPTCP_MIB_ADDADDRTXDROP = 38,
	MPTCP_MIB_ECHOADD = 39,
	MPTCP_MIB_ECHOADDTX = 40,
	MPTCP_MIB_ECHOADDTXDROP = 41,
	MPTCP_MIB_PORTADD = 42,
	MPTCP_MIB_ADDADDRDROP = 43,
	MPTCP_MIB_JOINPORTSYNRX = 44,
	MPTCP_MIB_JOINPORTSYNACKRX = 45,
	MPTCP_MIB_JOINPORTACKRX = 46,
	MPTCP_MIB_MISMATCHPORTSYNRX = 47,
	MPTCP_MIB_MISMATCHPORTACKRX = 48,
	MPTCP_MIB_RMADDR = 49,
	MPTCP_MIB_RMADDRDROP = 50,
	MPTCP_MIB_RMADDRTX = 51,
	MPTCP_MIB_RMADDRTXDROP = 52,
	MPTCP_MIB_RMSUBFLOW = 53,
	MPTCP_MIB_MPPRIOTX = 54,
	MPTCP_MIB_MPPRIORX = 55,
	MPTCP_MIB_MPFAILTX = 56,
	MPTCP_MIB_MPFAILRX = 57,
	MPTCP_MIB_MPFASTCLOSETX = 58,
	MPTCP_MIB_MPFASTCLOSERX = 59,
	MPTCP_MIB_MPRSTTX = 60,
	MPTCP_MIB_MPRSTRX = 61,
	MPTCP_MIB_RCVPRUNED = 62,
	MPTCP_MIB_SUBFLOWSTALE = 63,
	MPTCP_MIB_SUBFLOWRECOVER = 64,
	MPTCP_MIB_SNDWNDSHARED = 65,
	MPTCP_MIB_RCVWNDSHARED = 66,
	MPTCP_MIB_RCVWNDCONFLICTUPDATE = 67,
	MPTCP_MIB_RCVWNDCONFLICT = 68,
	MPTCP_MIB_CURRESTAB = 69,
	MPTCP_MIB_BLACKHOLE = 70,
	__MPTCP_MIB_MAX = 71,
};

enum llc_sockopts {
	LLC_OPT_UNKNOWN = 0,
	LLC_OPT_RETRY = 1,
	LLC_OPT_SIZE = 2,
	LLC_OPT_ACK_TMR_EXP = 3,
	LLC_OPT_P_TMR_EXP = 4,
	LLC_OPT_REJ_TMR_EXP = 5,
	LLC_OPT_BUSY_TMR_EXP = 6,
	LLC_OPT_TX_WIN = 7,
	LLC_OPT_RX_WIN = 8,
	LLC_OPT_PKTINFO = 9,
	LLC_OPT_MAX = 10,
};

enum lock_type4 {
	NFS4_UNLOCK_LT = 0,
	NFS4_READ_LT = 1,
	NFS4_WRITE_LT = 2,
	NFS4_READW_LT = 3,
	NFS4_WRITEW_LT = 4,
};

enum lockdep_ok {
	LOCKDEP_STILL_OK = 0,
	LOCKDEP_NOW_UNRELIABLE = 1,
};

enum lockdown_reason {
	LOCKDOWN_NONE = 0,
	LOCKDOWN_MODULE_SIGNATURE = 1,
	LOCKDOWN_DEV_MEM = 2,
	LOCKDOWN_EFI_TEST = 3,
	LOCKDOWN_KEXEC = 4,
	LOCKDOWN_HIBERNATION = 5,
	LOCKDOWN_PCI_ACCESS = 6,
	LOCKDOWN_IOPORT = 7,
	LOCKDOWN_MSR = 8,
	LOCKDOWN_ACPI_TABLES = 9,
	LOCKDOWN_DEVICE_TREE = 10,
	LOCKDOWN_PCMCIA_CIS = 11,
	LOCKDOWN_TIOCSSERIAL = 12,
	LOCKDOWN_MODULE_PARAMETERS = 13,
	LOCKDOWN_MMIOTRACE = 14,
	LOCKDOWN_DEBUGFS = 15,
	LOCKDOWN_XMON_WR = 16,
	LOCKDOWN_BPF_WRITE_USER = 17,
	LOCKDOWN_DBG_WRITE_KERNEL = 18,
	LOCKDOWN_RTAS_ERROR_INJECTION = 19,
	LOCKDOWN_INTEGRITY_MAX = 20,
	LOCKDOWN_KCORE = 21,
	LOCKDOWN_KPROBES = 22,
	LOCKDOWN_BPF_READ_KERNEL = 23,
	LOCKDOWN_DBG_READ_KERNEL = 24,
	LOCKDOWN_PERF = 25,
	LOCKDOWN_TRACEFS = 26,
	LOCKDOWN_XMON_RW = 27,
	LOCKDOWN_XFRM_SECRET = 28,
	LOCKDOWN_CONFIDENTIALITY_MAX = 29,
};

enum lowpan_iphc_ctx_flags {
	LOWPAN_IPHC_CTX_FLAG_ACTIVE = 0,
	LOWPAN_IPHC_CTX_FLAG_COMPRESSION = 1,
};

enum lowpan_lltypes {
	LOWPAN_LLTYPE_BTLE = 0,
	LOWPAN_LLTYPE_IEEE802154 = 1,
};

enum lru_list {
	LRU_INACTIVE_ANON = 0,
	LRU_ACTIVE_ANON = 1,
	LRU_INACTIVE_FILE = 2,
	LRU_ACTIVE_FILE = 3,
	LRU_UNEVICTABLE = 4,
	NR_LRU_LISTS = 5,
};

enum lru_status {
	LRU_REMOVED = 0,
	LRU_REMOVED_RETRY = 1,
	LRU_ROTATE = 2,
	LRU_SKIP = 3,
	LRU_RETRY = 4,
	LRU_STOP = 5,
};

enum lruvec_flags {
	LRUVEC_CGROUP_CONGESTED = 0,
	LRUVEC_NODE_CONGESTED = 1,
};

enum lsm_event {
	LSM_POLICY_CHANGE = 0,
};

enum lsm_integrity_type {
	LSM_INT_DMVERITY_SIG_VALID = 0,
	LSM_INT_DMVERITY_ROOTHASH = 1,
	LSM_INT_FSVERITY_BUILTINSIG_VALID = 2,
};

enum lsm_order {
	LSM_ORDER_FIRST = -1,
	LSM_ORDER_MUTABLE = 0,
	LSM_ORDER_LAST = 1,
};

enum lsm_rule_types {
	LSM_OBJ_USER = 0,
	LSM_OBJ_ROLE = 1,
	LSM_OBJ_TYPE = 2,
	LSM_SUBJ_USER = 3,
	LSM_SUBJ_ROLE = 4,
	LSM_SUBJ_TYPE = 5,
};

enum lspcon_vendor {
	LSPCON_VENDOR_MCA = 0,
	LSPCON_VENDOR_PARADE = 1,
};

enum lw_bits {
	LW_URGENT = 0,
};

enum lwtunnel_encap_types {
	LWTUNNEL_ENCAP_NONE = 0,
	LWTUNNEL_ENCAP_MPLS = 1,
	LWTUNNEL_ENCAP_IP = 2,
	LWTUNNEL_ENCAP_ILA = 3,
	LWTUNNEL_ENCAP_IP6 = 4,
	LWTUNNEL_ENCAP_SEG6 = 5,
	LWTUNNEL_ENCAP_BPF = 6,
	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
	LWTUNNEL_ENCAP_RPL = 8,
	LWTUNNEL_ENCAP_IOAM6 = 9,
	LWTUNNEL_ENCAP_XFRM = 10,
	__LWTUNNEL_ENCAP_MAX = 11,
};

enum lwtunnel_ip6_t {
	LWTUNNEL_IP6_UNSPEC = 0,
	LWTUNNEL_IP6_ID = 1,
	LWTUNNEL_IP6_DST = 2,
	LWTUNNEL_IP6_SRC = 3,
	LWTUNNEL_IP6_HOPLIMIT = 4,
	LWTUNNEL_IP6_TC = 5,
	LWTUNNEL_IP6_FLAGS = 6,
	LWTUNNEL_IP6_PAD = 7,
	LWTUNNEL_IP6_OPTS = 8,
	__LWTUNNEL_IP6_MAX = 9,
};

enum lwtunnel_ip_t {
	LWTUNNEL_IP_UNSPEC = 0,
	LWTUNNEL_IP_ID = 1,
	LWTUNNEL_IP_DST = 2,
	LWTUNNEL_IP_SRC = 3,
	LWTUNNEL_IP_TTL = 4,
	LWTUNNEL_IP_TOS = 5,
	LWTUNNEL_IP_FLAGS = 6,
	LWTUNNEL_IP_PAD = 7,
	LWTUNNEL_IP_OPTS = 8,
	__LWTUNNEL_IP_MAX = 9,
};

enum lzma2_seq {
	SEQ_CONTROL = 0,
	SEQ_UNCOMPRESSED_1 = 1,
	SEQ_UNCOMPRESSED_2 = 2,
	SEQ_COMPRESSED_0 = 3,
	SEQ_COMPRESSED_1 = 4,
	SEQ_PROPERTIES = 5,
	SEQ_LZMA_PREPARE = 6,
	SEQ_LZMA_RUN = 7,
	SEQ_COPY = 8,
};

enum lzma_state {
	STATE_LIT_LIT = 0,
	STATE_MATCH_LIT_LIT = 1,
	STATE_REP_LIT_LIT = 2,
	STATE_SHORTREP_LIT_LIT = 3,
	STATE_MATCH_LIT = 4,
	STATE_REP_LIT = 5,
	STATE_SHORTREP_LIT = 6,
	STATE_LIT_MATCH = 7,
	STATE_LIT_LONGREP = 8,
	STATE_LIT_SHORTREP = 9,
	STATE_NONLIT_MATCH = 10,
	STATE_NONLIT_REP = 11,
};

enum macvlan_macaddr_mode {
	MACVLAN_MACADDR_ADD = 0,
	MACVLAN_MACADDR_DEL = 1,
	MACVLAN_MACADDR_FLUSH = 2,
	MACVLAN_MACADDR_SET = 3,
};

enum macvlan_mode {
	MACVLAN_MODE_PRIVATE = 1,
	MACVLAN_MODE_VEPA = 2,
	MACVLAN_MODE_BRIDGE = 4,
	MACVLAN_MODE_PASSTHRU = 8,
	MACVLAN_MODE_SOURCE = 16,
};

enum maple_status {
	ma_active = 0,
	ma_start = 1,
	ma_root = 2,
	ma_none = 3,
	ma_pause = 4,
	ma_overflow = 5,
	ma_underflow = 6,
	ma_error = 7,
};

enum maple_type {
	maple_dense = 0,
	maple_leaf_64 = 1,
	maple_range_64 = 2,
	maple_arange_64 = 3,
};

enum mapping_flags {
	AS_EIO = 0,
	AS_ENOSPC = 1,
	AS_MM_ALL_LOCKS = 2,
	AS_UNEVICTABLE = 3,
	AS_EXITING = 4,
	AS_NO_WRITEBACK_TAGS = 5,
	AS_RELEASE_ALWAYS = 6,
	AS_STABLE_WRITES = 7,
	AS_INACCESSIBLE = 8,
	AS_FOLIO_ORDER_BITS = 5,
	AS_FOLIO_ORDER_MIN = 16,
	AS_FOLIO_ORDER_MAX = 21,
};

enum mapping_status {
	MAPPING_OK = 0,
	MAPPING_INVALID = 1,
	MAPPING_EMPTY = 2,
	MAPPING_DATA_FIN = 3,
	MAPPING_DUMMY = 4,
	MAPPING_BAD_CSUM = 5,
	MAPPING_NODSS = 6,
};

enum mbr_state {
	MBR_JOINING = 0,
	MBR_PUBLISHED = 1,
	MBR_JOINED = 2,
	MBR_PENDING = 3,
	MBR_ACTIVE = 4,
	MBR_RECLAIMING = 5,
	MBR_REMITTED = 6,
	MBR_LEAVING = 7,
};

enum mca_msr {
	MCA_CTL = 0,
	MCA_STATUS = 1,
	MCA_ADDR = 2,
	MCA_MISC = 3,
};

enum mce_notifier_prios {
	MCE_PRIO_LOWEST = 0,
	MCE_PRIO_MCELOG = 1,
	MCE_PRIO_EDAC = 2,
	MCE_PRIO_NFIT = 3,
	MCE_PRIO_EXTLOG = 4,
	MCE_PRIO_UC = 5,
	MCE_PRIO_EARLY = 6,
	MCE_PRIO_CEC = 7,
	MCE_PRIO_HIGHEST = 7,
};

enum mcp_flags {
	MCP_TIMESTAMP = 1,
	MCP_UC = 2,
	MCP_DONTLOG = 4,
	MCP_QUEUE_LOG = 8,
};

enum md_ro_state {
	MD_RDWR = 0,
	MD_RDONLY = 1,
	MD_AUTO_READ = 2,
	MD_MAX_STATE = 3,
};

enum mddev_flags {
	MD_ARRAY_FIRST_USE = 0,
	MD_CLOSING = 1,
	MD_JOURNAL_CLEAN = 2,
	MD_HAS_JOURNAL = 3,
	MD_CLUSTER_RESYNC_LOCKED = 4,
	MD_FAILFAST_SUPPORTED = 5,
	MD_HAS_PPL = 6,
	MD_HAS_MULTIPLE_PPLS = 7,
	MD_NOT_READY = 8,
	MD_BROKEN = 9,
	MD_DELETED = 10,
};

enum mddev_sb_flags {
	MD_SB_CHANGE_DEVS = 0,
	MD_SB_CHANGE_CLEAN = 1,
	MD_SB_CHANGE_PENDING = 2,
	MD_SB_NEED_REWRITE = 3,
};

enum mds_mitigations {
	MDS_MITIGATION_OFF = 0,
	MDS_MITIGATION_FULL = 1,
	MDS_MITIGATION_VMWERV = 2,
};

enum mei_cb_file_ops {
	MEI_FOP_READ = 0,
	MEI_FOP_WRITE = 1,
	MEI_FOP_CONNECT = 2,
	MEI_FOP_DISCONNECT = 3,
	MEI_FOP_DISCONNECT_RSP = 4,
	MEI_FOP_NOTIFY_START = 5,
	MEI_FOP_NOTIFY_STOP = 6,
	MEI_FOP_DMA_MAP = 7,
	MEI_FOP_DMA_UNMAP = 8,
};

enum mei_cfg_idx {
	MEI_ME_UNDEF_CFG = 0,
	MEI_ME_ICH_CFG = 1,
	MEI_ME_ICH10_CFG = 2,
	MEI_ME_PCH6_CFG = 3,
	MEI_ME_PCH7_CFG = 4,
	MEI_ME_PCH_CPT_PBG_CFG = 5,
	MEI_ME_PCH8_CFG = 6,
	MEI_ME_PCH8_ITOUCH_CFG = 7,
	MEI_ME_PCH8_SPS_4_CFG = 8,
	MEI_ME_PCH12_CFG = 9,
	MEI_ME_PCH12_SPS_4_CFG = 10,
	MEI_ME_PCH12_SPS_CFG = 11,
	MEI_ME_PCH12_SPS_ITOUCH_CFG = 12,
	MEI_ME_PCH15_CFG = 13,
	MEI_ME_PCH15_SPS_CFG = 14,
	MEI_ME_GSC_CFG = 15,
	MEI_ME_GSCFI_CFG = 16,
	MEI_ME_NUM_CFG = 17,
};

enum mei_cl_connect_status {
	MEI_CL_CONN_SUCCESS = 0,
	MEI_CL_CONN_NOT_FOUND = 1,
	MEI_CL_CONN_ALREADY_STARTED = 2,
	MEI_CL_CONN_OUT_OF_RESOURCES = 3,
	MEI_CL_CONN_MESSAGE_SMALL = 4,
	MEI_CL_CONN_NOT_ALLOWED = 5,
};

enum mei_cl_disconnect_status {
	MEI_CL_DISCONN_SUCCESS = 0,
};

enum mei_cl_io_mode {
	MEI_CL_IO_TX_BLOCKING = 1,
	MEI_CL_IO_TX_INTERNAL = 2,
	MEI_CL_IO_RX_NONBLOCK = 4,
	MEI_CL_IO_SGL = 8,
};

enum mei_dev_pxp_mode {
	MEI_DEV_PXP_DEFAULT = 0,
	MEI_DEV_PXP_INIT = 1,
	MEI_DEV_PXP_SETUP = 2,
	MEI_DEV_PXP_READY = 3,
};

enum mei_dev_reset_to_pxp {
	MEI_DEV_RESET_TO_PXP_DEFAULT = 0,
	MEI_DEV_RESET_TO_PXP_PERFORMED = 1,
	MEI_DEV_RESET_TO_PXP_DONE = 2,
};

enum mei_dev_state {
	MEI_DEV_INITIALIZING = 0,
	MEI_DEV_INIT_CLIENTS = 1,
	MEI_DEV_ENABLED = 2,
	MEI_DEV_RESETTING = 3,
	MEI_DEV_DISABLED = 4,
	MEI_DEV_POWERING_DOWN = 5,
	MEI_DEV_POWER_DOWN = 6,
	MEI_DEV_POWER_UP = 7,
};

enum mei_ext_hdr_type {
	MEI_EXT_HDR_NONE = 0,
	MEI_EXT_HDR_VTAG = 1,
	MEI_EXT_HDR_GSC = 2,
};

enum mei_file_transaction_states {
	MEI_IDLE = 0,
	MEI_WRITING = 1,
	MEI_WRITE_COMPLETE = 2,
};

enum mei_hbm_state {
	MEI_HBM_IDLE = 0,
	MEI_HBM_STARTING = 1,
	MEI_HBM_CAP_SETUP = 2,
	MEI_HBM_DR_SETUP = 3,
	MEI_HBM_ENUM_CLIENTS = 4,
	MEI_HBM_CLIENT_PROPERTIES = 5,
	MEI_HBM_STARTED = 6,
	MEI_HBM_STOPPED = 7,
};

enum mei_hbm_status {
	MEI_HBMS_SUCCESS = 0,
	MEI_HBMS_CLIENT_NOT_FOUND = 1,
	MEI_HBMS_ALREADY_EXISTS = 2,
	MEI_HBMS_REJECTED = 3,
	MEI_HBMS_INVALID_PARAMETER = 4,
	MEI_HBMS_NOT_ALLOWED = 5,
	MEI_HBMS_ALREADY_STARTED = 6,
	MEI_HBMS_NOT_STARTED = 7,
	MEI_HBMS_MAX = 8,
};

enum mei_pg_event {
	MEI_PG_EVENT_IDLE = 0,
	MEI_PG_EVENT_WAIT = 1,
	MEI_PG_EVENT_RECEIVED = 2,
	MEI_PG_EVENT_INTR_WAIT = 3,
	MEI_PG_EVENT_INTR_RECEIVED = 4,
};

enum mei_pg_state {
	MEI_PG_OFF = 0,
	MEI_PG_ON = 1,
};

enum mei_stop_reason_types {
	DRIVER_STOP_REQUEST = 0,
	DEVICE_D1_ENTRY = 1,
	DEVICE_D2_ENTRY = 2,
	DEVICE_D3_ENTRY = 3,
	SYSTEM_S1_ENTRY = 4,
	SYSTEM_S2_ENTRY = 5,
	SYSTEM_S3_ENTRY = 6,
	SYSTEM_S4_ENTRY = 7,
	SYSTEM_S5_ENTRY = 8,
};

enum membarrier_cmd {
	MEMBARRIER_CMD_QUERY = 0,
	MEMBARRIER_CMD_GLOBAL = 1,
	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ = 128,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ = 256,
	MEMBARRIER_CMD_GET_REGISTRATIONS = 512,
	MEMBARRIER_CMD_SHARED = 1,
};

enum membarrier_cmd_flag {
	MEMBARRIER_CMD_FLAG_CPU = 1,
};

enum memblock_flags {
	MEMBLOCK_NONE = 0,
	MEMBLOCK_HOTPLUG = 1,
	MEMBLOCK_MIRROR = 2,
	MEMBLOCK_NOMAP = 4,
	MEMBLOCK_DRIVER_MANAGED = 8,
	MEMBLOCK_RSRV_NOINIT = 16,
};

enum memcg_memory_event {
	MEMCG_LOW = 0,
	MEMCG_HIGH = 1,
	MEMCG_MAX = 2,
	MEMCG_OOM = 3,
	MEMCG_OOM_KILL = 4,
	MEMCG_OOM_GROUP_KILL = 5,
	MEMCG_SWAP_HIGH = 6,
	MEMCG_SWAP_MAX = 7,
	MEMCG_SWAP_FAIL = 8,
	MEMCG_NR_MEMORY_EVENTS = 9,
};

enum memcg_stat_item {
	MEMCG_SWAP = 46,
	MEMCG_SOCK = 47,
	MEMCG_PERCPU_B = 48,
	MEMCG_VMALLOC = 49,
	MEMCG_KMEM = 50,
	MEMCG_ZSWAP_B = 51,
	MEMCG_ZSWAPPED = 52,
	MEMCG_NR_STAT = 53,
};

enum meminit_context {
	MEMINIT_EARLY = 0,
	MEMINIT_HOTPLUG = 1,
};

enum memory_type {
	MEMORY_DEVICE_PRIVATE = 1,
	MEMORY_DEVICE_COHERENT = 2,
	MEMORY_DEVICE_FS_DAX = 3,
	MEMORY_DEVICE_GENERIC = 4,
	MEMORY_DEVICE_PCI_P2PDMA = 5,
};

enum metadata_type {
	METADATA_IP_TUNNEL = 0,
	METADATA_HW_PORT_MUX = 1,
	METADATA_MACSEC = 2,
	METADATA_XFRM = 3,
};

enum mf_flags {
	MF_COUNT_INCREASED = 1,
	MF_ACTION_REQUIRED = 2,
	MF_MUST_KILL = 4,
	MF_SOFT_OFFLINE = 8,
	MF_UNPOISON = 16,
	MF_SW_SIMULATED = 32,
	MF_NO_RETRY = 64,
	MF_MEM_PRE_REMOVE = 128,
};

enum migrate_mode {
	MIGRATE_ASYNC = 0,
	MIGRATE_SYNC_LIGHT = 1,
	MIGRATE_SYNC = 2,
};

enum migrate_reason {
	MR_COMPACTION = 0,
	MR_MEMORY_FAILURE = 1,
	MR_MEMORY_HOTPLUG = 2,
	MR_SYSCALL = 3,
	MR_MEMPOLICY_MBIND = 4,
	MR_NUMA_MISPLACED = 5,
	MR_CONTIG_RANGE = 6,
	MR_LONGTERM_PIN = 7,
	MR_DEMOTION = 8,
	MR_DAMON = 9,
	MR_TYPES = 10,
};

enum migratetype {
	MIGRATE_UNMOVABLE = 0,
	MIGRATE_MOVABLE = 1,
	MIGRATE_RECLAIMABLE = 2,
	MIGRATE_PCPTYPES = 3,
	MIGRATE_HIGHATOMIC = 3,
	MIGRATE_ISOLATE = 4,
	MIGRATE_TYPES = 5,
};

enum migration_type {
	migrate_load = 0,
	migrate_util = 1,
	migrate_task = 2,
	migrate_misfit = 3,
};

enum mipi_dsi_compression_algo {
	MIPI_DSI_COMPRESSION_DSC = 0,
	MIPI_DSI_COMPRESSION_VENDOR = 3,
};

enum mipi_dsi_dcs_tear_mode {
	MIPI_DSI_DCS_TEAR_MODE_VBLANK = 0,
	MIPI_DSI_DCS_TEAR_MODE_VHBLANK = 1,
};

enum mipi_dsi_pixel_format {
	MIPI_DSI_FMT_RGB888 = 0,
	MIPI_DSI_FMT_RGB666 = 1,
	MIPI_DSI_FMT_RGB666_PACKED = 2,
	MIPI_DSI_FMT_RGB565 = 3,
};

enum mipi_seq {
	MIPI_SEQ_END = 0,
	MIPI_SEQ_DEASSERT_RESET = 1,
	MIPI_SEQ_INIT_OTP = 2,
	MIPI_SEQ_DISPLAY_ON = 3,
	MIPI_SEQ_DISPLAY_OFF = 4,
	MIPI_SEQ_ASSERT_RESET = 5,
	MIPI_SEQ_BACKLIGHT_ON = 6,
	MIPI_SEQ_BACKLIGHT_OFF = 7,
	MIPI_SEQ_TEAR_ON = 8,
	MIPI_SEQ_TEAR_OFF = 9,
	MIPI_SEQ_POWER_ON = 10,
	MIPI_SEQ_POWER_OFF = 11,
	MIPI_SEQ_MAX = 12,
};

enum mipi_seq_element {
	MIPI_SEQ_ELEM_END = 0,
	MIPI_SEQ_ELEM_SEND_PKT = 1,
	MIPI_SEQ_ELEM_DELAY = 2,
	MIPI_SEQ_ELEM_GPIO = 3,
	MIPI_SEQ_ELEM_I2C = 4,
	MIPI_SEQ_ELEM_SPI = 5,
	MIPI_SEQ_ELEM_PMIC = 6,
	MIPI_SEQ_ELEM_MAX = 7,
};

enum misc_res_type {
	MISC_CG_RES_TYPES = 0,
};

enum mm_cid_state {
	MM_CID_UNSET = 4294967295,
	MM_CID_LAZY_PUT = 2147483648,
};

enum mminit_level {
	MMINIT_WARNING = 0,
	MMINIT_VERIFY = 1,
	MMINIT_TRACE = 2,
};

enum mmio_mitigations {
	MMIO_MITIGATION_OFF = 0,
	MMIO_MITIGATION_UCODE_NEEDED = 1,
	MMIO_MITIGATION_VERW = 2,
};

enum mmu_notifier_event {
	MMU_NOTIFY_UNMAP = 0,
	MMU_NOTIFY_CLEAR = 1,
	MMU_NOTIFY_PROTECTION_VMA = 2,
	MMU_NOTIFY_PROTECTION_PAGE = 3,
	MMU_NOTIFY_SOFT_DIRTY = 4,
	MMU_NOTIFY_RELEASE = 5,
	MMU_NOTIFY_MIGRATE = 6,
	MMU_NOTIFY_EXCLUSIVE = 7,
};

enum mnt_tree_flags_t {
	MNT_TREE_MOVE = 1,
	MNT_TREE_BENEATH = 2,
};

enum mod_license {
	NOT_GPL_ONLY = 0,
	GPL_ONLY = 1,
};

enum mod_mem_type {
	MOD_TEXT = 0,
	MOD_DATA = 1,
	MOD_RODATA = 2,
	MOD_RO_AFTER_INIT = 3,
	MOD_INIT_TEXT = 4,
	MOD_INIT_DATA = 5,
	MOD_INIT_RODATA = 6,
	MOD_MEM_NUM_TYPES = 7,
	MOD_INVALID = -1,
};

enum mode_set_atomic {
	LEAVE_ATOMIC_MODE_SET = 0,
	ENTER_ATOMIC_MODE_SET = 1,
};

enum module_state {
	MODULE_STATE_LIVE = 0,
	MODULE_STATE_COMING = 1,
	MODULE_STATE_GOING = 2,
	MODULE_STATE_UNFORMED = 3,
};

enum mountstat {
	MNT_OK = 0,
	MNT_EPERM = 1,
	MNT_ENOENT = 2,
	MNT_EACCES = 13,
	MNT_EINVAL = 22,
};

enum mountstat3 {
	MNT3_OK = 0,
	MNT3ERR_PERM = 1,
	MNT3ERR_NOENT = 2,
	MNT3ERR_IO = 5,
	MNT3ERR_ACCES = 13,
	MNT3ERR_NOTDIR = 20,
	MNT3ERR_INVAL = 22,
	MNT3ERR_NAMETOOLONG = 63,
	MNT3ERR_NOTSUPP = 10004,
	MNT3ERR_SERVERFAULT = 10006,
};

enum mp_irq_source_types {
	mp_INT = 0,
	mp_NMI = 1,
	mp_SMI = 2,
	mp_ExtINT = 3,
};

enum mptcp_addr_signal_status {
	MPTCP_ADD_ADDR_SIGNAL = 0,
	MPTCP_ADD_ADDR_ECHO = 1,
	MPTCP_RM_ADDR_SIGNAL = 2,
};

enum mptcp_event_attr {
	MPTCP_ATTR_UNSPEC = 0,
	MPTCP_ATTR_TOKEN = 1,
	MPTCP_ATTR_FAMILY = 2,
	MPTCP_ATTR_LOC_ID = 3,
	MPTCP_ATTR_REM_ID = 4,
	MPTCP_ATTR_SADDR4 = 5,
	MPTCP_ATTR_SADDR6 = 6,
	MPTCP_ATTR_DADDR4 = 7,
	MPTCP_ATTR_DADDR6 = 8,
	MPTCP_ATTR_SPORT = 9,
	MPTCP_ATTR_DPORT = 10,
	MPTCP_ATTR_BACKUP = 11,
	MPTCP_ATTR_ERROR = 12,
	MPTCP_ATTR_FLAGS = 13,
	MPTCP_ATTR_TIMEOUT = 14,
	MPTCP_ATTR_IF_IDX = 15,
	MPTCP_ATTR_RESET_REASON = 16,
	MPTCP_ATTR_RESET_FLAGS = 17,
	MPTCP_ATTR_SERVER_SIDE = 18,
	__MPTCP_ATTR_MAX = 19,
};

enum mptcp_event_type {
	MPTCP_EVENT_UNSPEC = 0,
	MPTCP_EVENT_CREATED = 1,
	MPTCP_EVENT_ESTABLISHED = 2,
	MPTCP_EVENT_CLOSED = 3,
	MPTCP_EVENT_ANNOUNCED = 6,
	MPTCP_EVENT_REMOVED = 7,
	MPTCP_EVENT_SUB_ESTABLISHED = 10,
	MPTCP_EVENT_SUB_CLOSED = 11,
	MPTCP_EVENT_SUB_PRIORITY = 13,
	MPTCP_EVENT_LISTENER_CREATED = 15,
	MPTCP_EVENT_LISTENER_CLOSED = 16,
};

enum mptcp_pm_status {
	MPTCP_PM_ADD_ADDR_RECEIVED = 0,
	MPTCP_PM_ADD_ADDR_SEND_ACK = 1,
	MPTCP_PM_RM_ADDR_RECEIVED = 2,
	MPTCP_PM_ESTABLISHED = 3,
	MPTCP_PM_SUBFLOW_ESTABLISHED = 4,
	MPTCP_PM_ALREADY_ESTABLISHED = 5,
	MPTCP_PM_MPC_ENDPOINT_ACCOUNTED = 6,
};

enum mptcp_pm_type {
	MPTCP_PM_TYPE_KERNEL = 0,
	MPTCP_PM_TYPE_USERSPACE = 1,
	__MPTCP_PM_TYPE_NR = 2,
	__MPTCP_PM_TYPE_MAX = 1,
};

enum mq_rq_state {
	MQ_RQ_IDLE = 0,
	MQ_RQ_IN_FLIGHT = 1,
	MQ_RQ_COMPLETE = 2,
};

enum msdos_sys_ind {
	DOS_EXTENDED_PARTITION = 5,
	LINUX_EXTENDED_PARTITION = 133,
	WIN98_EXTENDED_PARTITION = 15,
	LINUX_DATA_PARTITION = 131,
	LINUX_LVM_PARTITION = 142,
	LINUX_RAID_PARTITION = 253,
	SOLARIS_X86_PARTITION = 130,
	NEW_SOLARIS_X86_PARTITION = 191,
	DM6_AUX1PARTITION = 81,
	DM6_AUX3PARTITION = 83,
	DM6_PARTITION = 84,
	EZD_PARTITION = 85,
	FREEBSD_PARTITION = 165,
	OPENBSD_PARTITION = 166,
	NETBSD_PARTITION = 169,
	BSDI_PARTITION = 183,
	MINIX_PARTITION = 129,
	UNIXWARE_PARTITION = 99,
};

enum msi_desc_filter {
	MSI_DESC_ALL = 0,
	MSI_DESC_NOTASSOCIATED = 1,
	MSI_DESC_ASSOCIATED = 2,
};

enum msi_domain_ids {
	MSI_DEFAULT_DOMAIN = 0,
	MSI_MAX_DEVICE_IRQDOMAINS = 1,
};

enum mthp_stat_item {
	MTHP_STAT_ANON_FAULT_ALLOC = 0,
	MTHP_STAT_ANON_FAULT_FALLBACK = 1,
	MTHP_STAT_ANON_FAULT_FALLBACK_CHARGE = 2,
	MTHP_STAT_ZSWPOUT = 3,
	MTHP_STAT_SWPIN = 4,
	MTHP_STAT_SWPIN_FALLBACK = 5,
	MTHP_STAT_SWPIN_FALLBACK_CHARGE = 6,
	MTHP_STAT_SWPOUT = 7,
	MTHP_STAT_SWPOUT_FALLBACK = 8,
	MTHP_STAT_SHMEM_ALLOC = 9,
	MTHP_STAT_SHMEM_FALLBACK = 10,
	MTHP_STAT_SHMEM_FALLBACK_CHARGE = 11,
	MTHP_STAT_SPLIT = 12,
	MTHP_STAT_SPLIT_FAILED = 13,
	MTHP_STAT_SPLIT_DEFERRED = 14,
	MTHP_STAT_NR_ANON = 15,
	MTHP_STAT_NR_ANON_PARTIALLY_MAPPED = 16,
	__MTHP_STAT_COUNT = 17,
};

enum multi_stop_state {
	MULTI_STOP_NONE = 0,
	MULTI_STOP_PREPARE = 1,
	MULTI_STOP_DISABLE_IRQ = 2,
	MULTI_STOP_RUN = 3,
	MULTI_STOP_EXIT = 4,
};

enum nbcon_prio {
	NBCON_PRIO_NONE = 0,
	NBCON_PRIO_NORMAL = 1,
	NBCON_PRIO_EMERGENCY = 2,
	NBCON_PRIO_PANIC = 3,
	NBCON_PRIO_MAX = 4,
};

enum net_bridge_opts {
	BROPT_VLAN_ENABLED = 0,
	BROPT_VLAN_STATS_ENABLED = 1,
	BROPT_NF_CALL_IPTABLES = 2,
	BROPT_NF_CALL_IP6TABLES = 3,
	BROPT_NF_CALL_ARPTABLES = 4,
	BROPT_GROUP_ADDR_SET = 5,
	BROPT_MULTICAST_ENABLED = 6,
	BROPT_MULTICAST_QUERY_USE_IFADDR = 7,
	BROPT_MULTICAST_STATS_ENABLED = 8,
	BROPT_HAS_IPV6_ADDR = 9,
	BROPT_NEIGH_SUPPRESS_ENABLED = 10,
	BROPT_MTU_SET_BY_USER = 11,
	BROPT_VLAN_STATS_PER_PORT = 12,
	BROPT_NO_LL_LEARN = 13,
	BROPT_VLAN_BRIDGE_BINDING = 14,
	BROPT_MCAST_VLAN_SNOOPING_ENABLED = 15,
	BROPT_MST_ENABLED = 16,
};

enum net_device_flags {
	IFF_UP = 1,
	IFF_BROADCAST = 2,
	IFF_DEBUG = 4,
	IFF_LOOPBACK = 8,
	IFF_POINTOPOINT = 16,
	IFF_NOTRAILERS = 32,
	IFF_RUNNING = 64,
	IFF_NOARP = 128,
	IFF_PROMISC = 256,
	IFF_ALLMULTI = 512,
	IFF_MASTER = 1024,
	IFF_SLAVE = 2048,
	IFF_MULTICAST = 4096,
	IFF_PORTSEL = 8192,
	IFF_AUTOMEDIA = 16384,
	IFF_DYNAMIC = 32768,
	IFF_LOWER_UP = 65536,
	IFF_DORMANT = 131072,
	IFF_ECHO = 262144,
};

enum net_device_path_type {
	DEV_PATH_ETHERNET = 0,
	DEV_PATH_VLAN = 1,
	DEV_PATH_BRIDGE = 2,
	DEV_PATH_PPPOE = 3,
	DEV_PATH_DSA = 4,
	DEV_PATH_MTK_WDMA = 5,
};

enum net_xmit_qdisc_t {
	__NET_XMIT_STOLEN = 65536,
	__NET_XMIT_BYPASS = 131072,
};

enum netdev_cmd {
	NETDEV_UP = 1,
	NETDEV_DOWN = 2,
	NETDEV_REBOOT = 3,
	NETDEV_CHANGE = 4,
	NETDEV_REGISTER = 5,
	NETDEV_UNREGISTER = 6,
	NETDEV_CHANGEMTU = 7,
	NETDEV_CHANGEADDR = 8,
	NETDEV_PRE_CHANGEADDR = 9,
	NETDEV_GOING_DOWN = 10,
	NETDEV_CHANGENAME = 11,
	NETDEV_FEAT_CHANGE = 12,
	NETDEV_BONDING_FAILOVER = 13,
	NETDEV_PRE_UP = 14,
	NETDEV_PRE_TYPE_CHANGE = 15,
	NETDEV_POST_TYPE_CHANGE = 16,
	NETDEV_POST_INIT = 17,
	NETDEV_PRE_UNINIT = 18,
	NETDEV_RELEASE = 19,
	NETDEV_NOTIFY_PEERS = 20,
	NETDEV_JOIN = 21,
	NETDEV_CHANGEUPPER = 22,
	NETDEV_RESEND_IGMP = 23,
	NETDEV_PRECHANGEMTU = 24,
	NETDEV_CHANGEINFODATA = 25,
	NETDEV_BONDING_INFO = 26,
	NETDEV_PRECHANGEUPPER = 27,
	NETDEV_CHANGELOWERSTATE = 28,
	NETDEV_UDP_TUNNEL_PUSH_INFO = 29,
	NETDEV_UDP_TUNNEL_DROP_INFO = 30,
	NETDEV_CHANGE_TX_QUEUE_LEN = 31,
	NETDEV_CVLAN_FILTER_PUSH_INFO = 32,
	NETDEV_CVLAN_FILTER_DROP_INFO = 33,
	NETDEV_SVLAN_FILTER_PUSH_INFO = 34,
	NETDEV_SVLAN_FILTER_DROP_INFO = 35,
	NETDEV_OFFLOAD_XSTATS_ENABLE = 36,
	NETDEV_OFFLOAD_XSTATS_DISABLE = 37,
	NETDEV_OFFLOAD_XSTATS_REPORT_USED = 38,
	NETDEV_OFFLOAD_XSTATS_REPORT_DELTA = 39,
	NETDEV_XDP_FEAT_CHANGE = 40,
};

enum netdev_lag_hash {
	NETDEV_LAG_HASH_NONE = 0,
	NETDEV_LAG_HASH_L2 = 1,
	NETDEV_LAG_HASH_L34 = 2,
	NETDEV_LAG_HASH_L23 = 3,
	NETDEV_LAG_HASH_E23 = 4,
	NETDEV_LAG_HASH_E34 = 5,
	NETDEV_LAG_HASH_VLAN_SRCMAC = 6,
	NETDEV_LAG_HASH_UNKNOWN = 7,
};

enum netdev_lag_tx_type {
	NETDEV_LAG_TX_TYPE_UNKNOWN = 0,
	NETDEV_LAG_TX_TYPE_RANDOM = 1,
	NETDEV_LAG_TX_TYPE_BROADCAST = 2,
	NETDEV_LAG_TX_TYPE_ROUNDROBIN = 3,
	NETDEV_LAG_TX_TYPE_ACTIVEBACKUP = 4,
	NETDEV_LAG_TX_TYPE_HASH = 5,
};

enum netdev_ml_priv_type {
	ML_PRIV_NONE = 0,
	ML_PRIV_CAN = 1,
};

enum netdev_offload_xstats_type {
	NETDEV_OFFLOAD_XSTATS_TYPE_L3 = 1,
};

enum netdev_priv_flags {
	IFF_802_1Q_VLAN = 1,
	IFF_EBRIDGE = 2,
	IFF_BONDING = 4,
	IFF_ISATAP = 8,
	IFF_WAN_HDLC = 16,
	IFF_XMIT_DST_RELEASE = 32,
	IFF_DONT_BRIDGE = 64,
	IFF_DISABLE_NETPOLL = 128,
	IFF_MACVLAN_PORT = 256,
	IFF_BRIDGE_PORT = 512,
	IFF_OVS_DATAPATH = 1024,
	IFF_TX_SKB_SHARING = 2048,
	IFF_UNICAST_FLT = 4096,
	IFF_TEAM_PORT = 8192,
	IFF_SUPP_NOFCS = 16384,
	IFF_LIVE_ADDR_CHANGE = 32768,
	IFF_MACVLAN = 65536,
	IFF_XMIT_DST_RELEASE_PERM = 131072,
	IFF_L3MDEV_MASTER = 262144,
	IFF_NO_QUEUE = 524288,
	IFF_OPENVSWITCH = 1048576,
	IFF_L3MDEV_SLAVE = 2097152,
	IFF_TEAM = 4194304,
	IFF_RXFH_CONFIGURED = 8388608,
	IFF_PHONY_HEADROOM = 16777216,
	IFF_MACSEC = 33554432,
	IFF_NO_RX_HANDLER = 67108864,
	IFF_FAILOVER = 134217728,
	IFF_FAILOVER_SLAVE = 268435456,
	IFF_L3MDEV_RX_HANDLER = 536870912,
	IFF_NO_ADDRCONF = 1073741824,
	IFF_TX_SKB_NO_LINEAR = 2147483648,
};

enum netdev_qstats_scope {
	NETDEV_QSTATS_SCOPE_QUEUE = 1,
};

enum netdev_queue_state_t {
	__QUEUE_STATE_DRV_XOFF = 0,
	__QUEUE_STATE_STACK_XOFF = 1,
	__QUEUE_STATE_FROZEN = 2,
};

enum netdev_queue_type {
	NETDEV_QUEUE_TYPE_RX = 0,
	NETDEV_QUEUE_TYPE_TX = 1,
};

enum netdev_reg_state {
	NETREG_UNINITIALIZED = 0,
	NETREG_REGISTERED = 1,
	NETREG_UNREGISTERING = 2,
	NETREG_UNREGISTERED = 3,
	NETREG_RELEASED = 4,
	NETREG_DUMMY = 5,
};

enum netdev_stat_type {
	NETDEV_PCPU_STAT_NONE = 0,
	NETDEV_PCPU_STAT_LSTATS = 1,
	NETDEV_PCPU_STAT_TSTATS = 2,
	NETDEV_PCPU_STAT_DSTATS = 3,
};

enum netdev_state_t {
	__LINK_STATE_START = 0,
	__LINK_STATE_PRESENT = 1,
	__LINK_STATE_NOCARRIER = 2,
	__LINK_STATE_LINKWATCH_PENDING = 3,
	__LINK_STATE_DORMANT = 4,
	__LINK_STATE_TESTING = 5,
};

enum netdev_tx {
	__NETDEV_TX_MIN = -2147483648,
	NETDEV_TX_OK = 0,
	NETDEV_TX_BUSY = 16,
};

typedef enum netdev_tx netdev_tx_t;

enum netdev_xdp_act {
	NETDEV_XDP_ACT_BASIC = 1,
	NETDEV_XDP_ACT_REDIRECT = 2,
	NETDEV_XDP_ACT_NDO_XMIT = 4,
	NETDEV_XDP_ACT_XSK_ZEROCOPY = 8,
	NETDEV_XDP_ACT_HW_OFFLOAD = 16,
	NETDEV_XDP_ACT_RX_SG = 32,
	NETDEV_XDP_ACT_NDO_XMIT_SG = 64,
	NETDEV_XDP_ACT_MASK = 127,
};

enum netdev_xdp_rx_metadata {
	NETDEV_XDP_RX_METADATA_TIMESTAMP = 1,
	NETDEV_XDP_RX_METADATA_HASH = 2,
	NETDEV_XDP_RX_METADATA_VLAN_TAG = 4,
};

enum netdev_xsk_flags {
	NETDEV_XSK_FLAGS_TX_TIMESTAMP = 1,
	NETDEV_XSK_FLAGS_TX_CHECKSUM = 2,
	NETDEV_XSK_FLAGS_TX_LAUNCH_TIME_FIFO = 4,
};

enum netevent_notif_type {
	NETEVENT_NEIGH_UPDATE = 1,
	NETEVENT_REDIRECT = 2,
	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
};

enum netfs_collect_contig_trace {
	netfs_contig_trace_collect = 0,
	netfs_contig_trace_jump = 1,
	netfs_contig_trace_unlock = 2,
} __attribute__((mode(byte)));

enum netfs_donate_trace {
	netfs_trace_donate_tail_to_prev = 0,
	netfs_trace_donate_to_prev = 1,
	netfs_trace_donate_to_next = 2,
	netfs_trace_donate_to_deferred_next = 3,
} __attribute__((mode(byte)));

enum netfs_failure {
	netfs_fail_check_write_begin = 0,
	netfs_fail_copy_to_cache = 1,
	netfs_fail_dio_read_short = 2,
	netfs_fail_dio_read_zero = 3,
	netfs_fail_read = 4,
	netfs_fail_short_read = 5,
	netfs_fail_prepare_write = 6,
	netfs_fail_write = 7,
} __attribute__((mode(byte)));

enum netfs_folio_trace {
	netfs_folio_is_uptodate = 0,
	netfs_just_prefetch = 1,
	netfs_whole_folio_modify = 2,
	netfs_modify_and_clear = 3,
	netfs_streaming_write = 4,
	netfs_streaming_write_cont = 5,
	netfs_flush_content = 6,
	netfs_streaming_filled_page = 7,
	netfs_streaming_cont_filled_page = 8,
	netfs_folio_trace_abandon = 9,
	netfs_folio_trace_alloc_buffer = 10,
	netfs_folio_trace_cancel_copy = 11,
	netfs_folio_trace_cancel_store = 12,
	netfs_folio_trace_clear = 13,
	netfs_folio_trace_clear_cc = 14,
	netfs_folio_trace_clear_g = 15,
	netfs_folio_trace_clear_s = 16,
	netfs_folio_trace_copy_to_cache = 17,
	netfs_folio_trace_end_copy = 18,
	netfs_folio_trace_filled_gaps = 19,
	netfs_folio_trace_kill = 20,
	netfs_folio_trace_kill_cc = 21,
	netfs_folio_trace_kill_g = 22,
	netfs_folio_trace_kill_s = 23,
	netfs_folio_trace_mkwrite = 24,
	netfs_folio_trace_mkwrite_plus = 25,
	netfs_folio_trace_not_under_wback = 26,
	netfs_folio_trace_not_locked = 27,
	netfs_folio_trace_put = 28,
	netfs_folio_trace_read = 29,
	netfs_folio_trace_read_done = 30,
	netfs_folio_trace_read_gaps = 31,
	netfs_folio_trace_read_unlock = 32,
	netfs_folio_trace_redirtied = 33,
	netfs_folio_trace_store = 34,
	netfs_folio_trace_store_copy = 35,
	netfs_folio_trace_store_plus = 36,
	netfs_folio_trace_wthru = 37,
	netfs_folio_trace_wthru_plus = 38,
} __attribute__((mode(byte)));

enum netfs_folioq_trace {
	netfs_trace_folioq_alloc_buffer = 0,
	netfs_trace_folioq_clear = 1,
	netfs_trace_folioq_delete = 2,
	netfs_trace_folioq_make_space = 3,
	netfs_trace_folioq_rollbuf_init = 4,
	netfs_trace_folioq_read_progress = 5,
} __attribute__((mode(byte)));

enum netfs_io_origin {
	NETFS_READAHEAD = 0,
	NETFS_READPAGE = 1,
	NETFS_READ_GAPS = 2,
	NETFS_READ_SINGLE = 3,
	NETFS_READ_FOR_WRITE = 4,
	NETFS_DIO_READ = 5,
	NETFS_WRITEBACK = 6,
	NETFS_WRITEBACK_SINGLE = 7,
	NETFS_WRITETHROUGH = 8,
	NETFS_UNBUFFERED_WRITE = 9,
	NETFS_DIO_WRITE = 10,
	NETFS_PGPRIV2_COPY_TO_CACHE = 11,
	nr__netfs_io_origin = 12,
} __attribute__((mode(byte)));

enum netfs_io_source {
	NETFS_SOURCE_UNKNOWN = 0,
	NETFS_FILL_WITH_ZEROES = 1,
	NETFS_DOWNLOAD_FROM_SERVER = 2,
	NETFS_READ_FROM_CACHE = 3,
	NETFS_INVALID_READ = 4,
	NETFS_UPLOAD_TO_SERVER = 5,
	NETFS_WRITE_TO_CACHE = 6,
	NETFS_INVALID_WRITE = 7,
} __attribute__((mode(byte)));

enum netfs_read_from_hole {
	NETFS_READ_HOLE_IGNORE = 0,
	NETFS_READ_HOLE_CLEAR = 1,
	NETFS_READ_HOLE_FAIL = 2,
};

enum netfs_read_trace {
	netfs_read_trace_dio_read = 0,
	netfs_read_trace_expanded = 1,
	netfs_read_trace_readahead = 2,
	netfs_read_trace_readpage = 3,
	netfs_read_trace_read_gaps = 4,
	netfs_read_trace_read_single = 5,
	netfs_read_trace_prefetch_for_write = 6,
	netfs_read_trace_write_begin = 7,
} __attribute__((mode(byte)));

enum netfs_rreq_ref_trace {
	netfs_rreq_trace_get_for_outstanding = 0,
	netfs_rreq_trace_get_subreq = 1,
	netfs_rreq_trace_get_work = 2,
	netfs_rreq_trace_put_complete = 3,
	netfs_rreq_trace_put_discard = 4,
	netfs_rreq_trace_put_failed = 5,
	netfs_rreq_trace_put_no_submit = 6,
	netfs_rreq_trace_put_return = 7,
	netfs_rreq_trace_put_subreq = 8,
	netfs_rreq_trace_put_work = 9,
	netfs_rreq_trace_put_work_complete = 10,
	netfs_rreq_trace_put_work_nq = 11,
	netfs_rreq_trace_see_work = 12,
	netfs_rreq_trace_new = 13,
} __attribute__((mode(byte)));

enum netfs_rreq_trace {
	netfs_rreq_trace_assess = 0,
	netfs_rreq_trace_copy = 1,
	netfs_rreq_trace_collect = 2,
	netfs_rreq_trace_complete = 3,
	netfs_rreq_trace_dirty = 4,
	netfs_rreq_trace_done = 5,
	netfs_rreq_trace_free = 6,
	netfs_rreq_trace_redirty = 7,
	netfs_rreq_trace_resubmit = 8,
	netfs_rreq_trace_set_abandon = 9,
	netfs_rreq_trace_set_pause = 10,
	netfs_rreq_trace_unlock = 11,
	netfs_rreq_trace_unlock_pgpriv2 = 12,
	netfs_rreq_trace_unmark = 13,
	netfs_rreq_trace_wait_ip = 14,
	netfs_rreq_trace_wait_pause = 15,
	netfs_rreq_trace_wait_queue = 16,
	netfs_rreq_trace_wake_ip = 17,
	netfs_rreq_trace_wake_queue = 18,
	netfs_rreq_trace_woke_queue = 19,
	netfs_rreq_trace_unpause = 20,
	netfs_rreq_trace_write_done = 21,
} __attribute__((mode(byte)));

enum netfs_sreq_ref_trace {
	netfs_sreq_trace_get_copy_to_cache = 0,
	netfs_sreq_trace_get_resubmit = 1,
	netfs_sreq_trace_get_submit = 2,
	netfs_sreq_trace_get_short_read = 3,
	netfs_sreq_trace_new = 4,
	netfs_sreq_trace_put_abandon = 5,
	netfs_sreq_trace_put_cancel = 6,
	netfs_sreq_trace_put_clear = 7,
	netfs_sreq_trace_put_consumed = 8,
	netfs_sreq_trace_put_done = 9,
	netfs_sreq_trace_put_failed = 10,
	netfs_sreq_trace_put_merged = 11,
	netfs_sreq_trace_put_no_copy = 12,
	netfs_sreq_trace_put_oom = 13,
	netfs_sreq_trace_put_wip = 14,
	netfs_sreq_trace_put_work = 15,
	netfs_sreq_trace_put_terminated = 16,
} __attribute__((mode(byte)));

enum netfs_sreq_trace {
	netfs_sreq_trace_add_donations = 0,
	netfs_sreq_trace_added = 1,
	netfs_sreq_trace_cache_nowrite = 2,
	netfs_sreq_trace_cache_prepare = 3,
	netfs_sreq_trace_cache_write = 4,
	netfs_sreq_trace_cancel = 5,
	netfs_sreq_trace_clear = 6,
	netfs_sreq_trace_discard = 7,
	netfs_sreq_trace_donate_to_prev = 8,
	netfs_sreq_trace_donate_to_next = 9,
	netfs_sreq_trace_download_instead = 10,
	netfs_sreq_trace_fail = 11,
	netfs_sreq_trace_free = 12,
	netfs_sreq_trace_hit_eof = 13,
	netfs_sreq_trace_io_progress = 14,
	netfs_sreq_trace_limited = 15,
	netfs_sreq_trace_need_clear = 16,
	netfs_sreq_trace_partial_read = 17,
	netfs_sreq_trace_need_retry = 18,
	netfs_sreq_trace_prepare = 19,
	netfs_sreq_trace_prep_failed = 20,
	netfs_sreq_trace_progress = 21,
	netfs_sreq_trace_reprep_failed = 22,
	netfs_sreq_trace_retry = 23,
	netfs_sreq_trace_short = 24,
	netfs_sreq_trace_split = 25,
	netfs_sreq_trace_submit = 26,
	netfs_sreq_trace_superfluous = 27,
	netfs_sreq_trace_terminated = 28,
	netfs_sreq_trace_wait_for = 29,
	netfs_sreq_trace_write = 30,
	netfs_sreq_trace_write_skip = 31,
	netfs_sreq_trace_write_term = 32,
} __attribute__((mode(byte)));

enum netfs_write_trace {
	netfs_write_trace_copy_to_cache = 0,
	netfs_write_trace_dio_write = 1,
	netfs_write_trace_unbuffered_write = 2,
	netfs_write_trace_writeback = 3,
	netfs_write_trace_writethrough = 4,
} __attribute__((mode(byte)));

enum netlink_attribute_type {
	NL_ATTR_TYPE_INVALID = 0,
	NL_ATTR_TYPE_FLAG = 1,
	NL_ATTR_TYPE_U8 = 2,
	NL_ATTR_TYPE_U16 = 3,
	NL_ATTR_TYPE_U32 = 4,
	NL_ATTR_TYPE_U64 = 5,
	NL_ATTR_TYPE_S8 = 6,
	NL_ATTR_TYPE_S16 = 7,
	NL_ATTR_TYPE_S32 = 8,
	NL_ATTR_TYPE_S64 = 9,
	NL_ATTR_TYPE_BINARY = 10,
	NL_ATTR_TYPE_STRING = 11,
	NL_ATTR_TYPE_NUL_STRING = 12,
	NL_ATTR_TYPE_NESTED = 13,
	NL_ATTR_TYPE_NESTED_ARRAY = 14,
	NL_ATTR_TYPE_BITFIELD32 = 15,
	NL_ATTR_TYPE_SINT = 16,
	NL_ATTR_TYPE_UINT = 17,
};

enum netlink_policy_type_attr {
	NL_POLICY_TYPE_ATTR_UNSPEC = 0,
	NL_POLICY_TYPE_ATTR_TYPE = 1,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5,
	NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6,
	NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7,
	NL_POLICY_TYPE_ATTR_POLICY_IDX = 8,
	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9,
	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10,
	NL_POLICY_TYPE_ATTR_PAD = 11,
	NL_POLICY_TYPE_ATTR_MASK = 12,
	__NL_POLICY_TYPE_ATTR_MAX = 13,
	NL_POLICY_TYPE_ATTR_MAX = 12,
};

enum netlink_skb_flags {
	NETLINK_SKB_DST = 8,
};

enum netlink_validation {
	NL_VALIDATE_LIBERAL = 0,
	NL_VALIDATE_TRAILING = 1,
	NL_VALIDATE_MAXTYPE = 2,
	NL_VALIDATE_UNSPEC = 4,
	NL_VALIDATE_STRICT_ATTRS = 8,
	NL_VALIDATE_NESTED = 16,
};

enum netns_bpf_attach_type {
	NETNS_BPF_INVALID = -1,
	NETNS_BPF_FLOW_DISSECTOR = 0,
	NETNS_BPF_SK_LOOKUP = 1,
	MAX_NETNS_BPF_ATTACH_TYPE = 2,
};

enum new_flag {
	NF_FRESH = 0,
	NF_READ = 1,
	NF_GET = 2,
	NF_PREFETCH = 3,
};

enum new_flow {
	NEW_FLOW = 0,
	OLD_FLOW = 1,
};

enum nexthop_event_type {
	NEXTHOP_EVENT_DEL = 0,
	NEXTHOP_EVENT_REPLACE = 1,
	NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE = 2,
	NEXTHOP_EVENT_BUCKET_REPLACE = 3,
	NEXTHOP_EVENT_HW_STATS_REPORT_DELTA = 4,
};

enum nf_br_hook_priorities {
	NF_BR_PRI_FIRST = -2147483648,
	NF_BR_PRI_NAT_DST_BRIDGED = -300,
	NF_BR_PRI_FILTER_BRIDGED = -200,
	NF_BR_PRI_BRNF = 0,
	NF_BR_PRI_NAT_DST_OTHER = 100,
	NF_BR_PRI_FILTER_OTHER = 200,
	NF_BR_PRI_NAT_SRC = 300,
	NF_BR_PRI_LAST = 2147483647,
};

enum nf_ct_ecache_state {
	NFCT_ECACHE_DESTROY_FAIL = 0,
	NFCT_ECACHE_DESTROY_SENT = 1,
};

enum nf_ct_ext_id {
	NF_CT_EXT_HELPER = 0,
	NF_CT_EXT_NAT = 1,
	NF_CT_EXT_SEQADJ = 2,
	NF_CT_EXT_ACCT = 3,
	NF_CT_EXT_ECACHE = 4,
	NF_CT_EXT_TSTAMP = 5,
	NF_CT_EXT_TIMEOUT = 6,
	NF_CT_EXT_LABELS = 7,
	NF_CT_EXT_SYNPROXY = 8,
	NF_CT_EXT_ACT_CT = 9,
	NF_CT_EXT_NUM = 10,
};

enum nf_ct_ftp_type {
	NF_CT_FTP_PORT = 0,
	NF_CT_FTP_PASV = 1,
	NF_CT_FTP_EPRT = 2,
	NF_CT_FTP_EPSV = 3,
};

enum nf_ct_helper_flags {
	NF_CT_HELPER_F_USERSPACE = 1,
	NF_CT_HELPER_F_CONFIGURED = 2,
};

enum nf_ct_sysctl_index {
	NF_SYSCTL_CT_MAX = 0,
	NF_SYSCTL_CT_COUNT = 1,
	NF_SYSCTL_CT_BUCKETS = 2,
	NF_SYSCTL_CT_CHECKSUM = 3,
	NF_SYSCTL_CT_LOG_INVALID = 4,
	NF_SYSCTL_CT_EXPECT_MAX = 5,
	NF_SYSCTL_CT_ACCT = 6,
	NF_SYSCTL_CT_EVENTS = 7,
	NF_SYSCTL_CT_TIMESTAMP = 8,
	NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC = 9,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_SENT = 10,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_RECV = 11,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_ESTABLISHED = 12,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_FIN_WAIT = 13,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE_WAIT = 14,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_LAST_ACK = 15,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_TIME_WAIT = 16,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE = 17,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_RETRANS = 18,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_UNACK = 19,
	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_OFFLOAD = 20,
	NF_SYSCTL_CT_PROTO_TCP_LOOSE = 21,
	NF_SYSCTL_CT_PROTO_TCP_LIBERAL = 22,
	NF_SYSCTL_CT_PROTO_TCP_IGNORE_INVALID_RST = 23,
	NF_SYSCTL_CT_PROTO_TCP_MAX_RETRANS = 24,
	NF_SYSCTL_CT_PROTO_TIMEOUT_UDP = 25,
	NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM = 26,
	NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_OFFLOAD = 27,
	NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP = 28,
	NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6 = 29,
	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_CLOSED = 30,
	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_WAIT = 31,
	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_ECHOED = 32,
	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_ESTABLISHED = 33,
	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_SENT = 34,
	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_RECD = 35,
	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_ACK_SENT = 36,
	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_SENT = 37,
	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_REQUEST = 38,
	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_RESPOND = 39,
	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_PARTOPEN = 40,
	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_OPEN = 41,
	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSEREQ = 42,
	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSING = 43,
	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_TIMEWAIT = 44,
	NF_SYSCTL_CT_PROTO_DCCP_LOOSE = 45,
	NF_SYSCTL_CT_PROTO_TIMEOUT_GRE = 46,
	NF_SYSCTL_CT_PROTO_TIMEOUT_GRE_STREAM = 47,
	NF_SYSCTL_CT_LAST_SYSCTL = 48,
};

enum nf_ct_tcp_action {
	NFCT_TCP_IGNORE = 0,
	NFCT_TCP_INVALID = 1,
	NFCT_TCP_ACCEPT = 2,
};

enum nf_dev_hooks {
	NF_NETDEV_INGRESS = 0,
	NF_NETDEV_EGRESS = 1,
	NF_NETDEV_NUMHOOKS = 2,
};

enum nf_flow_flags {
	NF_FLOW_SNAT = 0,
	NF_FLOW_DNAT = 1,
	NF_FLOW_CLOSING = 2,
	NF_FLOW_TEARDOWN = 3,
	NF_FLOW_HW = 4,
	NF_FLOW_HW_DYING = 5,
	NF_FLOW_HW_DEAD = 6,
	NF_FLOW_HW_PENDING = 7,
	NF_FLOW_HW_BIDIRECTIONAL = 8,
	NF_FLOW_HW_ESTABLISHED = 9,
};

enum nf_flowtable_flags {
	NF_FLOWTABLE_HW_OFFLOAD = 1,
	NF_FLOWTABLE_COUNTER = 2,
};

enum nf_hook_ops_type {
	NF_HOOK_OP_UNDEFINED = 0,
	NF_HOOK_OP_NF_TABLES = 1,
	NF_HOOK_OP_BPF = 2,
};

enum nf_inet_hooks {
	NF_INET_PRE_ROUTING = 0,
	NF_INET_LOCAL_IN = 1,
	NF_INET_FORWARD = 2,
	NF_INET_LOCAL_OUT = 3,
	NF_INET_POST_ROUTING = 4,
	NF_INET_NUMHOOKS = 5,
	NF_INET_INGRESS = 5,
};

enum nf_ip6_hook_priorities {
	NF_IP6_PRI_FIRST = -2147483648,
	NF_IP6_PRI_RAW_BEFORE_DEFRAG = -450,
	NF_IP6_PRI_CONNTRACK_DEFRAG = -400,
	NF_IP6_PRI_RAW = -300,
	NF_IP6_PRI_SELINUX_FIRST = -225,
	NF_IP6_PRI_CONNTRACK = -200,
	NF_IP6_PRI_MANGLE = -150,
	NF_IP6_PRI_NAT_DST = -100,
	NF_IP6_PRI_FILTER = 0,
	NF_IP6_PRI_SECURITY = 50,
	NF_IP6_PRI_NAT_SRC = 100,
	NF_IP6_PRI_SELINUX_LAST = 225,
	NF_IP6_PRI_CONNTRACK_HELPER = 300,
	NF_IP6_PRI_LAST = 2147483647,
};

enum nf_ip_hook_priorities {
	NF_IP_PRI_FIRST = -2147483648,
	NF_IP_PRI_RAW_BEFORE_DEFRAG = -450,
	NF_IP_PRI_CONNTRACK_DEFRAG = -400,
	NF_IP_PRI_RAW = -300,
	NF_IP_PRI_SELINUX_FIRST = -225,
	NF_IP_PRI_CONNTRACK = -200,
	NF_IP_PRI_MANGLE = -150,
	NF_IP_PRI_NAT_DST = -100,
	NF_IP_PRI_FILTER = 0,
	NF_IP_PRI_SECURITY = 50,
	NF_IP_PRI_NAT_SRC = 100,
	NF_IP_PRI_SELINUX_LAST = 225,
	NF_IP_PRI_CONNTRACK_HELPER = 300,
	NF_IP_PRI_CONNTRACK_CONFIRM = 2147483647,
	NF_IP_PRI_LAST = 2147483647,
};

enum nf_log_type {
	NF_LOG_TYPE_LOG = 0,
	NF_LOG_TYPE_ULOG = 1,
	NF_LOG_TYPE_MAX = 2,
};

enum nf_nat_manip_type {
	NF_NAT_MANIP_SRC = 0,
	NF_NAT_MANIP_DST = 1,
};

enum nf_nat_snmp_basic_actions {
	ACT_snmp_helper = 0,
	ACT_snmp_version = 1,
	NR__nf_nat_snmp_basic_actions = 2,
};

enum nf_osf_attr_type {
	OSF_ATTR_UNSPEC = 0,
	OSF_ATTR_FINGER = 1,
	OSF_ATTR_MAX = 2,
};

enum nf_osf_msg_types {
	OSF_MSG_ADD = 0,
	OSF_MSG_REMOVE = 1,
	OSF_MSG_MAX = 2,
};

enum nf_osf_window_size_options {
	OSF_WSS_PLAIN = 0,
	OSF_WSS_MSS = 1,
	OSF_WSS_MTU = 2,
	OSF_WSS_MODULO = 3,
	OSF_WSS_MAX = 4,
};

enum nf_tables_msg_types {
	NFT_MSG_NEWTABLE = 0,
	NFT_MSG_GETTABLE = 1,
	NFT_MSG_DELTABLE = 2,
	NFT_MSG_NEWCHAIN = 3,
	NFT_MSG_GETCHAIN = 4,
	NFT_MSG_DELCHAIN = 5,
	NFT_MSG_NEWRULE = 6,
	NFT_MSG_GETRULE = 7,
	NFT_MSG_DELRULE = 8,
	NFT_MSG_NEWSET = 9,
	NFT_MSG_GETSET = 10,
	NFT_MSG_DELSET = 11,
	NFT_MSG_NEWSETELEM = 12,
	NFT_MSG_GETSETELEM = 13,
	NFT_MSG_DELSETELEM = 14,
	NFT_MSG_NEWGEN = 15,
	NFT_MSG_GETGEN = 16,
	NFT_MSG_TRACE = 17,
	NFT_MSG_NEWOBJ = 18,
	NFT_MSG_GETOBJ = 19,
	NFT_MSG_DELOBJ = 20,
	NFT_MSG_GETOBJ_RESET = 21,
	NFT_MSG_NEWFLOWTABLE = 22,
	NFT_MSG_GETFLOWTABLE = 23,
	NFT_MSG_DELFLOWTABLE = 24,
	NFT_MSG_GETRULE_RESET = 25,
	NFT_MSG_DESTROYTABLE = 26,
	NFT_MSG_DESTROYCHAIN = 27,
	NFT_MSG_DESTROYRULE = 28,
	NFT_MSG_DESTROYSET = 29,
	NFT_MSG_DESTROYSETELEM = 30,
	NFT_MSG_DESTROYOBJ = 31,
	NFT_MSG_DESTROYFLOWTABLE = 32,
	NFT_MSG_GETSETELEM_RESET = 33,
	NFT_MSG_MAX = 34,
};

enum nf_tproxy_lookup_t {
	NF_TPROXY_LOOKUP_LISTENER = 0,
	NF_TPROXY_LOOKUP_ESTABLISHED = 1,
};

enum nfnetlink_groups {
	NFNLGRP_NONE = 0,
	NFNLGRP_CONNTRACK_NEW = 1,
	NFNLGRP_CONNTRACK_UPDATE = 2,
	NFNLGRP_CONNTRACK_DESTROY = 3,
	NFNLGRP_CONNTRACK_EXP_NEW = 4,
	NFNLGRP_CONNTRACK_EXP_UPDATE = 5,
	NFNLGRP_CONNTRACK_EXP_DESTROY = 6,
	NFNLGRP_NFTABLES = 7,
	NFNLGRP_ACCT_QUOTA = 8,
	NFNLGRP_NFTRACE = 9,
	__NFNLGRP_MAX = 10,
};

enum nfnl_abort_action {
	NFNL_ABORT_NONE = 0,
	NFNL_ABORT_AUTOLOAD = 1,
	NFNL_ABORT_VALIDATE = 2,
};

enum nfnl_acct_flags {
	NFACCT_F_QUOTA_PKTS = 1,
	NFACCT_F_QUOTA_BYTES = 2,
	NFACCT_F_OVERQUOTA = 4,
};

enum nfnl_acct_msg_types {
	NFNL_MSG_ACCT_NEW = 0,
	NFNL_MSG_ACCT_GET = 1,
	NFNL_MSG_ACCT_GET_CTRZERO = 2,
	NFNL_MSG_ACCT_DEL = 3,
	NFNL_MSG_ACCT_OVERQUOTA = 4,
	NFNL_MSG_ACCT_MAX = 5,
};

enum nfnl_acct_type {
	NFACCT_UNSPEC = 0,
	NFACCT_NAME = 1,
	NFACCT_PKTS = 2,
	NFACCT_BYTES = 3,
	NFACCT_USE = 4,
	NFACCT_FLAGS = 5,
	NFACCT_QUOTA = 6,
	NFACCT_FILTER = 7,
	NFACCT_PAD = 8,
	__NFACCT_MAX = 9,
};

enum nfnl_attr_filter_type {
	NFACCT_FILTER_UNSPEC = 0,
	NFACCT_FILTER_MASK = 1,
	NFACCT_FILTER_VALUE = 2,
	__NFACCT_FILTER_MAX = 3,
};

enum nfnl_batch_attributes {
	NFNL_BATCH_UNSPEC = 0,
	NFNL_BATCH_GENID = 1,
	__NFNL_BATCH_MAX = 2,
};

enum nfnl_callback_type {
	NFNL_CB_UNSPEC = 0,
	NFNL_CB_MUTEX = 1,
	NFNL_CB_RCU = 2,
	NFNL_CB_BATCH = 3,
};

enum nfnl_cthelper_msg_types {
	NFNL_MSG_CTHELPER_NEW = 0,
	NFNL_MSG_CTHELPER_GET = 1,
	NFNL_MSG_CTHELPER_DEL = 2,
	NFNL_MSG_CTHELPER_MAX = 3,
};

enum nfnl_cthelper_pol_type {
	NFCTH_POLICY_UNSPEC = 0,
	NFCTH_POLICY_NAME = 1,
	NFCTH_POLICY_EXPECT_MAX = 2,
	NFCTH_POLICY_EXPECT_TIMEOUT = 3,
	__NFCTH_POLICY_MAX = 4,
};

enum nfnl_cthelper_policy_type {
	NFCTH_POLICY_SET_UNSPEC = 0,
	NFCTH_POLICY_SET_NUM = 1,
	NFCTH_POLICY_SET = 2,
	NFCTH_POLICY_SET1 = 2,
	NFCTH_POLICY_SET2 = 3,
	NFCTH_POLICY_SET3 = 4,
	NFCTH_POLICY_SET4 = 5,
	__NFCTH_POLICY_SET_MAX = 6,
};

enum nfnl_cthelper_tuple_type {
	NFCTH_TUPLE_UNSPEC = 0,
	NFCTH_TUPLE_L3PROTONUM = 1,
	NFCTH_TUPLE_L4PROTONUM = 2,
	__NFCTH_TUPLE_MAX = 3,
};

enum nfnl_cthelper_type {
	NFCTH_UNSPEC = 0,
	NFCTH_NAME = 1,
	NFCTH_TUPLE = 2,
	NFCTH_QUEUE_NUM = 3,
	NFCTH_POLICY = 4,
	NFCTH_PRIV_DATA_LEN = 5,
	NFCTH_STATUS = 6,
	__NFCTH_MAX = 7,
};

enum nfqnl_attr_config {
	NFQA_CFG_UNSPEC = 0,
	NFQA_CFG_CMD = 1,
	NFQA_CFG_PARAMS = 2,
	NFQA_CFG_QUEUE_MAXLEN = 3,
	NFQA_CFG_MASK = 4,
	NFQA_CFG_FLAGS = 5,
	__NFQA_CFG_MAX = 6,
};

enum nfqnl_attr_type {
	NFQA_UNSPEC = 0,
	NFQA_PACKET_HDR = 1,
	NFQA_VERDICT_HDR = 2,
	NFQA_MARK = 3,
	NFQA_TIMESTAMP = 4,
	NFQA_IFINDEX_INDEV = 5,
	NFQA_IFINDEX_OUTDEV = 6,
	NFQA_IFINDEX_PHYSINDEV = 7,
	NFQA_IFINDEX_PHYSOUTDEV = 8,
	NFQA_HWADDR = 9,
	NFQA_PAYLOAD = 10,
	NFQA_CT = 11,
	NFQA_CT_INFO = 12,
	NFQA_CAP_LEN = 13,
	NFQA_SKB_INFO = 14,
	NFQA_EXP = 15,
	NFQA_UID = 16,
	NFQA_GID = 17,
	NFQA_SECCTX = 18,
	NFQA_VLAN = 19,
	NFQA_L2HDR = 20,
	NFQA_PRIORITY = 21,
	NFQA_CGROUP_CLASSID = 22,
	__NFQA_MAX = 23,
};

enum nfqnl_config_mode {
	NFQNL_COPY_NONE = 0,
	NFQNL_COPY_META = 1,
	NFQNL_COPY_PACKET = 2,
};

enum nfqnl_msg_config_cmds {
	NFQNL_CFG_CMD_NONE = 0,
	NFQNL_CFG_CMD_BIND = 1,
	NFQNL_CFG_CMD_UNBIND = 2,
	NFQNL_CFG_CMD_PF_BIND = 3,
	NFQNL_CFG_CMD_PF_UNBIND = 4,
};

enum nfqnl_msg_types {
	NFQNL_MSG_PACKET = 0,
	NFQNL_MSG_VERDICT = 1,
	NFQNL_MSG_CONFIG = 2,
	NFQNL_MSG_VERDICT_BATCH = 3,
	NFQNL_MSG_MAX = 4,
};

enum nfqnl_vlan_attr {
	NFQA_VLAN_UNSPEC = 0,
	NFQA_VLAN_PROTO = 1,
	NFQA_VLAN_TCI = 2,
	__NFQA_VLAN_MAX = 3,
};

enum nfs3_createmode {
	NFS3_CREATE_UNCHECKED = 0,
	NFS3_CREATE_GUARDED = 1,
	NFS3_CREATE_EXCLUSIVE = 2,
};

enum nfs3_ftype {
	NF3NON = 0,
	NF3REG = 1,
	NF3DIR = 2,
	NF3BLK = 3,
	NF3CHR = 4,
	NF3LNK = 5,
	NF3SOCK = 6,
	NF3FIFO = 7,
	NF3BAD = 8,
};

enum nfs3_stable_how {
	NFS_UNSTABLE = 0,
	NFS_DATA_SYNC = 1,
	NFS_FILE_SYNC = 2,
	NFS_INVALID_STABLE_HOW = -1,
};

enum nfs4_acl_type {
	NFS4ACL_NONE = 0,
	NFS4ACL_ACL = 1,
	NFS4ACL_DACL = 2,
	NFS4ACL_SACL = 3,
};

enum nfs4_callback_procnum {
	CB_NULL = 0,
	CB_COMPOUND = 1,
};

enum nfs4_change_attr_type {
	NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR = 0,
	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER = 1,
	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS = 2,
	NFS4_CHANGE_TYPE_IS_TIME_METADATA = 3,
	NFS4_CHANGE_TYPE_IS_UNDEFINED = 4,
};

enum nfs4_client_state {
	NFS4CLNT_MANAGER_RUNNING = 0,
	NFS4CLNT_CHECK_LEASE = 1,
	NFS4CLNT_LEASE_EXPIRED = 2,
	NFS4CLNT_RECLAIM_REBOOT = 3,
	NFS4CLNT_RECLAIM_NOGRACE = 4,
	NFS4CLNT_DELEGRETURN = 5,
	NFS4CLNT_SESSION_RESET = 6,
	NFS4CLNT_LEASE_CONFIRM = 7,
	NFS4CLNT_SERVER_SCOPE_MISMATCH = 8,
	NFS4CLNT_PURGE_STATE = 9,
	NFS4CLNT_BIND_CONN_TO_SESSION = 10,
	NFS4CLNT_MOVED = 11,
	NFS4CLNT_LEASE_MOVED = 12,
	NFS4CLNT_DELEGATION_EXPIRED = 13,
	NFS4CLNT_RUN_MANAGER = 14,
	NFS4CLNT_MANAGER_AVAILABLE = 15,
	NFS4CLNT_RECALL_RUNNING = 16,
	NFS4CLNT_RECALL_ANY_LAYOUT_READ = 17,
	NFS4CLNT_RECALL_ANY_LAYOUT_RW = 18,
	NFS4CLNT_DELEGRETURN_DELAYED = 19,
};

enum nfs4_open_delegation_type4 {
	NFS4_OPEN_DELEGATE_NONE = 0,
	NFS4_OPEN_DELEGATE_READ = 1,
	NFS4_OPEN_DELEGATE_WRITE = 2,
	NFS4_OPEN_DELEGATE_NONE_EXT = 3,
	NFS4_OPEN_DELEGATE_READ_ATTRS_DELEG = 4,
	NFS4_OPEN_DELEGATE_WRITE_ATTRS_DELEG = 5,
};

enum nfs4_slot_tbl_state {
	NFS4_SLOT_TBL_DRAINING = 0,
};

enum nfs_cb_opnum4 {
	OP_CB_GETATTR = 3,
	OP_CB_RECALL = 4,
	OP_CB_LAYOUTRECALL = 5,
	OP_CB_NOTIFY = 6,
	OP_CB_PUSH_DELEG = 7,
	OP_CB_RECALL_ANY = 8,
	OP_CB_RECALLABLE_OBJ_AVAIL = 9,
	OP_CB_RECALL_SLOT = 10,
	OP_CB_SEQUENCE = 11,
	OP_CB_WANTS_CANCELLED = 12,
	OP_CB_NOTIFY_LOCK = 13,
	OP_CB_NOTIFY_DEVICEID = 14,
	OP_CB_OFFLOAD = 15,
	OP_CB_ILLEGAL = 10044,
};

enum nfs_ftype4 {
	NF4BAD = 0,
	NF4REG = 1,
	NF4DIR = 2,
	NF4BLK = 3,
	NF4CHR = 4,
	NF4LNK = 5,
	NF4SOCK = 6,
	NF4FIFO = 7,
	NF4ATTRDIR = 8,
	NF4NAMEDATTR = 9,
};

enum nfs_lock_status {
	NFS_LOCK_NOT_SET = 0,
	NFS_LOCK_LOCK = 1,
	NFS_LOCK_NOLOCK = 2,
};

enum nfs_opnum4 {
	OP_ACCESS = 3,
	OP_CLOSE = 4,
	OP_COMMIT = 5,
	OP_CREATE = 6,
	OP_DELEGPURGE = 7,
	OP_DELEGRETURN = 8,
	OP_GETATTR = 9,
	OP_GETFH = 10,
	OP_LINK = 11,
	OP_LOCK = 12,
	OP_LOCKT = 13,
	OP_LOCKU = 14,
	OP_LOOKUP = 15,
	OP_LOOKUPP = 16,
	OP_NVERIFY = 17,
	OP_OPEN = 18,
	OP_OPENATTR = 19,
	OP_OPEN_CONFIRM = 20,
	OP_OPEN_DOWNGRADE = 21,
	OP_PUTFH = 22,
	OP_PUTPUBFH = 23,
	OP_PUTROOTFH = 24,
	OP_READ = 25,
	OP_READDIR = 26,
	OP_READLINK = 27,
	OP_REMOVE = 28,
	OP_RENAME = 29,
	OP_RENEW = 30,
	OP_RESTOREFH = 31,
	OP_SAVEFH = 32,
	OP_SECINFO = 33,
	OP_SETATTR = 34,
	OP_SETCLIENTID = 35,
	OP_SETCLIENTID_CONFIRM = 36,
	OP_VERIFY = 37,
	OP_WRITE = 38,
	OP_RELEASE_LOCKOWNER = 39,
	OP_BACKCHANNEL_CTL = 40,
	OP_BIND_CONN_TO_SESSION = 41,
	OP_EXCHANGE_ID = 42,
	OP_CREATE_SESSION = 43,
	OP_DESTROY_SESSION = 44,
	OP_FREE_STATEID = 45,
	OP_GET_DIR_DELEGATION = 46,
	OP_GETDEVICEINFO = 47,
	OP_GETDEVICELIST = 48,
	OP_LAYOUTCOMMIT = 49,
	OP_LAYOUTGET = 50,
	OP_LAYOUTRETURN = 51,
	OP_SECINFO_NO_NAME = 52,
	OP_SEQUENCE = 53,
	OP_SET_SSV = 54,
	OP_TEST_STATEID = 55,
	OP_WANT_DELEGATION = 56,
	OP_DESTROY_CLIENTID = 57,
	OP_RECLAIM_COMPLETE = 58,
	OP_ALLOCATE = 59,
	OP_COPY = 60,
	OP_COPY_NOTIFY = 61,
	OP_DEALLOCATE = 62,
	OP_IO_ADVISE = 63,
	OP_LAYOUTERROR = 64,
	OP_LAYOUTSTATS = 65,
	OP_OFFLOAD_CANCEL = 66,
	OP_OFFLOAD_STATUS = 67,
	OP_READ_PLUS = 68,
	OP_SEEK = 69,
	OP_WRITE_SAME = 70,
	OP_CLONE = 71,
	OP_GETXATTR = 72,
	OP_SETXATTR = 73,
	OP_LISTXATTRS = 74,
	OP_REMOVEXATTR = 75,
	OP_ILLEGAL = 10044,
};

enum nfs_param {
	Opt_ac = 0,
	Opt_acdirmax = 1,
	Opt_acdirmin = 2,
	Opt_acl___3 = 3,
	Opt_acregmax = 4,
	Opt_acregmin = 5,
	Opt_actimeo = 6,
	Opt_addr = 7,
	Opt_bg = 8,
	Opt_bsize = 9,
	Opt_clientaddr = 10,
	Opt_cto = 11,
	Opt_alignwrite = 12,
	Opt_fg = 13,
	Opt_fscache = 14,
	Opt_fscache_flag = 15,
	Opt_hard = 16,
	Opt_intr = 17,
	Opt_local_lock = 18,
	Opt_lock = 19,
	Opt_lookupcache = 20,
	Opt_migration = 21,
	Opt_minorversion = 22,
	Opt_mountaddr = 23,
	Opt_mounthost = 24,
	Opt_mountport = 25,
	Opt_mountproto = 26,
	Opt_mountvers = 27,
	Opt_namelen = 28,
	Opt_nconnect = 29,
	Opt_max_connect = 30,
	Opt_port___2 = 31,
	Opt_posix = 32,
	Opt_proto = 33,
	Opt_rdirplus = 34,
	Opt_rdma = 35,
	Opt_resvport = 36,
	Opt_retrans = 37,
	Opt_retry = 38,
	Opt_rsize = 39,
	Opt_sec = 40,
	Opt_sharecache = 41,
	Opt_sloppy = 42,
	Opt_soft = 43,
	Opt_softerr = 44,
	Opt_softreval = 45,
	Opt_source___2 = 46,
	Opt_tcp = 47,
	Opt_timeo = 48,
	Opt_trunkdiscovery = 49,
	Opt_udp = 50,
	Opt_v = 51,
	Opt_vers = 52,
	Opt_wsize = 53,
	Opt_write = 54,
	Opt_xprtsec = 55,
};

enum nfs_stat {
	NFS_OK = 0,
	NFSERR_PERM = 1,
	NFSERR_NOENT = 2,
	NFSERR_IO = 5,
	NFSERR_NXIO = 6,
	NFSERR_EAGAIN = 11,
	NFSERR_ACCES = 13,
	NFSERR_EXIST = 17,
	NFSERR_XDEV = 18,
	NFSERR_NODEV = 19,
	NFSERR_NOTDIR = 20,
	NFSERR_ISDIR = 21,
	NFSERR_INVAL = 22,
	NFSERR_FBIG = 27,
	NFSERR_NOSPC = 28,
	NFSERR_ROFS = 30,
	NFSERR_MLINK = 31,
	NFSERR_NAMETOOLONG = 63,
	NFSERR_NOTEMPTY = 66,
	NFSERR_DQUOT = 69,
	NFSERR_STALE = 70,
	NFSERR_REMOTE = 71,
	NFSERR_WFLUSH = 99,
	NFSERR_BADHANDLE = 10001,
	NFSERR_NOT_SYNC = 10002,
	NFSERR_BAD_COOKIE = 10003,
	NFSERR_NOTSUPP = 10004,
	NFSERR_TOOSMALL = 10005,
	NFSERR_SERVERFAULT = 10006,
	NFSERR_BADTYPE = 10007,
	NFSERR_JUKEBOX = 10008,
	NFSERR_SAME = 10009,
	NFSERR_DENIED = 10010,
	NFSERR_EXPIRED = 10011,
	NFSERR_LOCKED = 10012,
	NFSERR_GRACE = 10013,
	NFSERR_FHEXPIRED = 10014,
	NFSERR_SHARE_DENIED = 10015,
	NFSERR_WRONGSEC = 10016,
	NFSERR_CLID_INUSE = 10017,
	NFSERR_RESOURCE = 10018,
	NFSERR_MOVED = 10019,
	NFSERR_NOFILEHANDLE = 10020,
	NFSERR_MINOR_VERS_MISMATCH = 10021,
	NFSERR_STALE_CLIENTID = 10022,
	NFSERR_STALE_STATEID = 10023,
	NFSERR_OLD_STATEID = 10024,
	NFSERR_BAD_STATEID = 10025,
	NFSERR_BAD_SEQID = 10026,
	NFSERR_NOT_SAME = 10027,
	NFSERR_LOCK_RANGE = 10028,
	NFSERR_SYMLINK = 10029,
	NFSERR_RESTOREFH = 10030,
	NFSERR_LEASE_MOVED = 10031,
	NFSERR_ATTRNOTSUPP = 10032,
	NFSERR_NO_GRACE = 10033,
	NFSERR_RECLAIM_BAD = 10034,
	NFSERR_RECLAIM_CONFLICT = 10035,
	NFSERR_BAD_XDR = 10036,
	NFSERR_LOCKS_HELD = 10037,
	NFSERR_OPENMODE = 10038,
	NFSERR_BADOWNER = 10039,
	NFSERR_BADCHAR = 10040,
	NFSERR_BADNAME = 10041,
	NFSERR_BAD_RANGE = 10042,
	NFSERR_LOCK_NOTSUPP = 10043,
	NFSERR_OP_ILLEGAL = 10044,
	NFSERR_DEADLOCK = 10045,
	NFSERR_FILE_OPEN = 10046,
	NFSERR_ADMIN_REVOKED = 10047,
	NFSERR_CB_PATH_DOWN = 10048,
};

enum nfs_stat_bytecounters {
	NFSIOS_NORMALREADBYTES = 0,
	NFSIOS_NORMALWRITTENBYTES = 1,
	NFSIOS_DIRECTREADBYTES = 2,
	NFSIOS_DIRECTWRITTENBYTES = 3,
	NFSIOS_SERVERREADBYTES = 4,
	NFSIOS_SERVERWRITTENBYTES = 5,
	NFSIOS_READPAGES = 6,
	NFSIOS_WRITEPAGES = 7,
	__NFSIOS_BYTESMAX = 8,
};

enum nfs_stat_eventcounters {
	NFSIOS_INODEREVALIDATE = 0,
	NFSIOS_DENTRYREVALIDATE = 1,
	NFSIOS_DATAINVALIDATE = 2,
	NFSIOS_ATTRINVALIDATE = 3,
	NFSIOS_VFSOPEN = 4,
	NFSIOS_VFSLOOKUP = 5,
	NFSIOS_VFSACCESS = 6,
	NFSIOS_VFSUPDATEPAGE = 7,
	NFSIOS_VFSREADPAGE = 8,
	NFSIOS_VFSREADPAGES = 9,
	NFSIOS_VFSWRITEPAGE = 10,
	NFSIOS_VFSWRITEPAGES = 11,
	NFSIOS_VFSGETDENTS = 12,
	NFSIOS_VFSSETATTR = 13,
	NFSIOS_VFSFLUSH = 14,
	NFSIOS_VFSFSYNC = 15,
	NFSIOS_VFSLOCK = 16,
	NFSIOS_VFSRELEASE = 17,
	NFSIOS_CONGESTIONWAIT = 18,
	NFSIOS_SETATTRTRUNC = 19,
	NFSIOS_EXTENDWRITE = 20,
	NFSIOS_SILLYRENAME = 21,
	NFSIOS_SHORTREAD = 22,
	NFSIOS_SHORTWRITE = 23,
	NFSIOS_DELAY = 24,
	NFSIOS_PNFS_READ = 25,
	NFSIOS_PNFS_WRITE = 26,
	__NFSIOS_COUNTSMAX = 27,
};

enum nfsstat4 {
	NFS4_OK = 0,
	NFS4ERR_PERM = 1,
	NFS4ERR_NOENT = 2,
	NFS4ERR_IO = 5,
	NFS4ERR_NXIO = 6,
	NFS4ERR_ACCESS = 13,
	NFS4ERR_EXIST = 17,
	NFS4ERR_XDEV = 18,
	NFS4ERR_NOTDIR = 20,
	NFS4ERR_ISDIR = 21,
	NFS4ERR_INVAL = 22,
	NFS4ERR_FBIG = 27,
	NFS4ERR_NOSPC = 28,
	NFS4ERR_ROFS = 30,
	NFS4ERR_MLINK = 31,
	NFS4ERR_NAMETOOLONG = 63,
	NFS4ERR_NOTEMPTY = 66,
	NFS4ERR_DQUOT = 69,
	NFS4ERR_STALE = 70,
	NFS4ERR_BADHANDLE = 10001,
	NFS4ERR_BAD_COOKIE = 10003,
	NFS4ERR_NOTSUPP = 10004,
	NFS4ERR_TOOSMALL = 10005,
	NFS4ERR_SERVERFAULT = 10006,
	NFS4ERR_BADTYPE = 10007,
	NFS4ERR_DELAY = 10008,
	NFS4ERR_SAME = 10009,
	NFS4ERR_DENIED = 10010,
	NFS4ERR_EXPIRED = 10011,
	NFS4ERR_LOCKED = 10012,
	NFS4ERR_GRACE = 10013,
	NFS4ERR_FHEXPIRED = 10014,
	NFS4ERR_SHARE_DENIED = 10015,
	NFS4ERR_WRONGSEC = 10016,
	NFS4ERR_CLID_INUSE = 10017,
	NFS4ERR_RESOURCE = 10018,
	NFS4ERR_MOVED = 10019,
	NFS4ERR_NOFILEHANDLE = 10020,
	NFS4ERR_MINOR_VERS_MISMATCH = 10021,
	NFS4ERR_STALE_CLIENTID = 10022,
	NFS4ERR_STALE_STATEID = 10023,
	NFS4ERR_OLD_STATEID = 10024,
	NFS4ERR_BAD_STATEID = 10025,
	NFS4ERR_BAD_SEQID = 10026,
	NFS4ERR_NOT_SAME = 10027,
	NFS4ERR_LOCK_RANGE = 10028,
	NFS4ERR_SYMLINK = 10029,
	NFS4ERR_RESTOREFH = 10030,
	NFS4ERR_LEASE_MOVED = 10031,
	NFS4ERR_ATTRNOTSUPP = 10032,
	NFS4ERR_NO_GRACE = 10033,
	NFS4ERR_RECLAIM_BAD = 10034,
	NFS4ERR_RECLAIM_CONFLICT = 10035,
	NFS4ERR_BADXDR = 10036,
	NFS4ERR_LOCKS_HELD = 10037,
	NFS4ERR_OPENMODE = 10038,
	NFS4ERR_BADOWNER = 10039,
	NFS4ERR_BADCHAR = 10040,
	NFS4ERR_BADNAME = 10041,
	NFS4ERR_BAD_RANGE = 10042,
	NFS4ERR_LOCK_NOTSUPP = 10043,
	NFS4ERR_OP_ILLEGAL = 10044,
	NFS4ERR_DEADLOCK = 10045,
	NFS4ERR_FILE_OPEN = 10046,
	NFS4ERR_ADMIN_REVOKED = 10047,
	NFS4ERR_CB_PATH_DOWN = 10048,
	NFS4ERR_BADIOMODE = 10049,
	NFS4ERR_BADLAYOUT = 10050,
	NFS4ERR_BAD_SESSION_DIGEST = 10051,
	NFS4ERR_BADSESSION = 10052,
	NFS4ERR_BADSLOT = 10053,
	NFS4ERR_COMPLETE_ALREADY = 10054,
	NFS4ERR_CONN_NOT_BOUND_TO_SESSION = 10055,
	NFS4ERR_DELEG_ALREADY_WANTED = 10056,
	NFS4ERR_BACK_CHAN_BUSY = 10057,
	NFS4ERR_LAYOUTTRYLATER = 10058,
	NFS4ERR_LAYOUTUNAVAILABLE = 10059,
	NFS4ERR_NOMATCHING_LAYOUT = 10060,
	NFS4ERR_RECALLCONFLICT = 10061,
	NFS4ERR_UNKNOWN_LAYOUTTYPE = 10062,
	NFS4ERR_SEQ_MISORDERED = 10063,
	NFS4ERR_SEQUENCE_POS = 10064,
	NFS4ERR_REQ_TOO_BIG = 10065,
	NFS4ERR_REP_TOO_BIG = 10066,
	NFS4ERR_REP_TOO_BIG_TO_CACHE = 10067,
	NFS4ERR_RETRY_UNCACHED_REP = 10068,
	NFS4ERR_UNSAFE_COMPOUND = 10069,
	NFS4ERR_TOO_MANY_OPS = 10070,
	NFS4ERR_OP_NOT_IN_SESSION = 10071,
	NFS4ERR_HASH_ALG_UNSUPP = 10072,
	NFS4ERR_CLIENTID_BUSY = 10074,
	NFS4ERR_PNFS_IO_HOLE = 10075,
	NFS4ERR_SEQ_FALSE_RETRY = 10076,
	NFS4ERR_BAD_HIGH_SLOT = 10077,
	NFS4ERR_DEADSESSION = 10078,
	NFS4ERR_ENCR_ALG_UNSUPP = 10079,
	NFS4ERR_PNFS_NO_LAYOUT = 10080,
	NFS4ERR_NOT_ONLY_OP = 10081,
	NFS4ERR_WRONG_CRED = 10082,
	NFS4ERR_WRONG_TYPE = 10083,
	NFS4ERR_DIRDELEG_UNAVAIL = 10084,
	NFS4ERR_REJECT_DELEG = 10085,
	NFS4ERR_RETURNCONFLICT = 10086,
	NFS4ERR_DELEG_REVOKED = 10087,
	NFS4ERR_PARTNER_NOTSUPP = 10088,
	NFS4ERR_PARTNER_NO_AUTH = 10089,
	NFS4ERR_UNION_NOTSUPP = 10090,
	NFS4ERR_OFFLOAD_DENIED = 10091,
	NFS4ERR_WRONG_LFS = 10092,
	NFS4ERR_BADLABEL = 10093,
	NFS4ERR_OFFLOAD_NO_REQS = 10094,
	NFS4ERR_NOXATTR = 10095,
	NFS4ERR_XATTR2BIG = 10096,
	NFS4ERR_FIRST_FREE = 10097,
};

enum nft_bitwise_attributes {
	NFTA_BITWISE_UNSPEC = 0,
	NFTA_BITWISE_SREG = 1,
	NFTA_BITWISE_DREG = 2,
	NFTA_BITWISE_LEN = 3,
	NFTA_BITWISE_MASK = 4,
	NFTA_BITWISE_XOR = 5,
	NFTA_BITWISE_OP = 6,
	NFTA_BITWISE_DATA = 7,
	NFTA_BITWISE_SREG2 = 8,
	__NFTA_BITWISE_MAX = 9,
};

enum nft_bitwise_ops {
	NFT_BITWISE_MASK_XOR = 0,
	NFT_BITWISE_LSHIFT = 1,
	NFT_BITWISE_RSHIFT = 2,
	NFT_BITWISE_AND = 3,
	NFT_BITWISE_OR = 4,
	NFT_BITWISE_XOR = 5,
};

enum nft_byteorder_attributes {
	NFTA_BYTEORDER_UNSPEC = 0,
	NFTA_BYTEORDER_SREG = 1,
	NFTA_BYTEORDER_DREG = 2,
	NFTA_BYTEORDER_OP = 3,
	NFTA_BYTEORDER_LEN = 4,
	NFTA_BYTEORDER_SIZE = 5,
	__NFTA_BYTEORDER_MAX = 6,
};

enum nft_byteorder_ops {
	NFT_BYTEORDER_NTOH = 0,
	NFT_BYTEORDER_HTON = 1,
};

enum nft_chain_attributes {
	NFTA_CHAIN_UNSPEC = 0,
	NFTA_CHAIN_TABLE = 1,
	NFTA_CHAIN_HANDLE = 2,
	NFTA_CHAIN_NAME = 3,
	NFTA_CHAIN_HOOK = 4,
	NFTA_CHAIN_POLICY = 5,
	NFTA_CHAIN_USE = 6,
	NFTA_CHAIN_TYPE = 7,
	NFTA_CHAIN_COUNTERS = 8,
	NFTA_CHAIN_PAD = 9,
	NFTA_CHAIN_FLAGS = 10,
	NFTA_CHAIN_ID = 11,
	NFTA_CHAIN_USERDATA = 12,
	__NFTA_CHAIN_MAX = 13,
};

enum nft_chain_flags {
	NFT_CHAIN_BASE = 1,
	NFT_CHAIN_HW_OFFLOAD = 2,
	NFT_CHAIN_BINDING = 4,
};

enum nft_chain_types {
	NFT_CHAIN_T_DEFAULT = 0,
	NFT_CHAIN_T_ROUTE = 1,
	NFT_CHAIN_T_NAT = 2,
	NFT_CHAIN_T_MAX = 3,
};

enum nft_cmp_attributes {
	NFTA_CMP_UNSPEC = 0,
	NFTA_CMP_SREG = 1,
	NFTA_CMP_OP = 2,
	NFTA_CMP_DATA = 3,
	__NFTA_CMP_MAX = 4,
};

enum nft_cmp_ops {
	NFT_CMP_EQ = 0,
	NFT_CMP_NEQ = 1,
	NFT_CMP_LT = 2,
	NFT_CMP_LTE = 3,
	NFT_CMP_GT = 4,
	NFT_CMP_GTE = 5,
};

enum nft_connlimit_attributes {
	NFTA_CONNLIMIT_UNSPEC = 0,
	NFTA_CONNLIMIT_COUNT = 1,
	NFTA_CONNLIMIT_FLAGS = 2,
	__NFTA_CONNLIMIT_MAX = 3,
};

enum nft_connlimit_flags {
	NFT_CONNLIMIT_F_INV = 1,
};

enum nft_counter_attributes {
	NFTA_COUNTER_UNSPEC = 0,
	NFTA_COUNTER_BYTES = 1,
	NFTA_COUNTER_PACKETS = 2,
	NFTA_COUNTER_PAD = 3,
	__NFTA_COUNTER_MAX = 4,
};

enum nft_ct_attributes {
	NFTA_CT_UNSPEC = 0,
	NFTA_CT_DREG = 1,
	NFTA_CT_KEY = 2,
	NFTA_CT_DIRECTION = 3,
	NFTA_CT_SREG = 4,
	__NFTA_CT_MAX = 5,
};

enum nft_ct_expectation_attributes {
	NFTA_CT_EXPECT_UNSPEC = 0,
	NFTA_CT_EXPECT_L3PROTO = 1,
	NFTA_CT_EXPECT_L4PROTO = 2,
	NFTA_CT_EXPECT_DPORT = 3,
	NFTA_CT_EXPECT_TIMEOUT = 4,
	NFTA_CT_EXPECT_SIZE = 5,
	__NFTA_CT_EXPECT_MAX = 6,
};

enum nft_ct_helper_attributes {
	NFTA_CT_HELPER_UNSPEC = 0,
	NFTA_CT_HELPER_NAME = 1,
	NFTA_CT_HELPER_L3PROTO = 2,
	NFTA_CT_HELPER_L4PROTO = 3,
	__NFTA_CT_HELPER_MAX = 4,
};

enum nft_ct_keys {
	NFT_CT_STATE = 0,
	NFT_CT_DIRECTION = 1,
	NFT_CT_STATUS = 2,
	NFT_CT_MARK = 3,
	NFT_CT_SECMARK = 4,
	NFT_CT_EXPIRATION = 5,
	NFT_CT_HELPER = 6,
	NFT_CT_L3PROTOCOL = 7,
	NFT_CT_SRC = 8,
	NFT_CT_DST = 9,
	NFT_CT_PROTOCOL = 10,
	NFT_CT_PROTO_SRC = 11,
	NFT_CT_PROTO_DST = 12,
	NFT_CT_LABELS = 13,
	NFT_CT_PKTS = 14,
	NFT_CT_BYTES = 15,
	NFT_CT_AVGPKT = 16,
	NFT_CT_ZONE = 17,
	NFT_CT_EVENTMASK = 18,
	NFT_CT_SRC_IP = 19,
	NFT_CT_DST_IP = 20,
	NFT_CT_SRC_IP6 = 21,
	NFT_CT_DST_IP6 = 22,
	NFT_CT_ID = 23,
	__NFT_CT_MAX = 24,
};

enum nft_ct_timeout_timeout_attributes {
	NFTA_CT_TIMEOUT_UNSPEC = 0,
	NFTA_CT_TIMEOUT_L3PROTO = 1,
	NFTA_CT_TIMEOUT_L4PROTO = 2,
	NFTA_CT_TIMEOUT_DATA = 3,
	__NFTA_CT_TIMEOUT_MAX = 4,
};

enum nft_data_attributes {
	NFTA_DATA_UNSPEC = 0,
	NFTA_DATA_VALUE = 1,
	NFTA_DATA_VERDICT = 2,
	__NFTA_DATA_MAX = 3,
};

enum nft_data_desc_flags {
	NFT_DATA_DESC_SETELEM = 1,
};

enum nft_data_types {
	NFT_DATA_VALUE = 0,
	NFT_DATA_VERDICT = 4294967040,
};

enum nft_devices_attributes {
	NFTA_DEVICE_UNSPEC = 0,
	NFTA_DEVICE_NAME = 1,
	__NFTA_DEVICE_MAX = 2,
};

enum nft_dup_attributes {
	NFTA_DUP_UNSPEC = 0,
	NFTA_DUP_SREG_ADDR = 1,
	NFTA_DUP_SREG_DEV = 2,
	__NFTA_DUP_MAX = 3,
};

enum nft_dynset_attributes {
	NFTA_DYNSET_UNSPEC = 0,
	NFTA_DYNSET_SET_NAME = 1,
	NFTA_DYNSET_SET_ID = 2,
	NFTA_DYNSET_OP = 3,
	NFTA_DYNSET_SREG_KEY = 4,
	NFTA_DYNSET_SREG_DATA = 5,
	NFTA_DYNSET_TIMEOUT = 6,
	NFTA_DYNSET_EXPR = 7,
	NFTA_DYNSET_PAD = 8,
	NFTA_DYNSET_FLAGS = 9,
	NFTA_DYNSET_EXPRESSIONS = 10,
	__NFTA_DYNSET_MAX = 11,
};

enum nft_dynset_flags {
	NFT_DYNSET_F_INV = 1,
	NFT_DYNSET_F_EXPR = 2,
};

enum nft_dynset_ops {
	NFT_DYNSET_OP_ADD = 0,
	NFT_DYNSET_OP_UPDATE = 1,
	NFT_DYNSET_OP_DELETE = 2,
};

enum nft_expr_attributes {
	NFTA_EXPR_UNSPEC = 0,
	NFTA_EXPR_NAME = 1,
	NFTA_EXPR_DATA = 2,
	__NFTA_EXPR_MAX = 3,
};

enum nft_exthdr_attributes {
	NFTA_EXTHDR_UNSPEC = 0,
	NFTA_EXTHDR_DREG = 1,
	NFTA_EXTHDR_TYPE = 2,
	NFTA_EXTHDR_OFFSET = 3,
	NFTA_EXTHDR_LEN = 4,
	NFTA_EXTHDR_FLAGS = 5,
	NFTA_EXTHDR_OP = 6,
	NFTA_EXTHDR_SREG = 7,
	__NFTA_EXTHDR_MAX = 8,
};

enum nft_exthdr_flags {
	NFT_EXTHDR_F_PRESENT = 1,
};

enum nft_exthdr_op {
	NFT_EXTHDR_OP_IPV6 = 0,
	NFT_EXTHDR_OP_TCPOPT = 1,
	NFT_EXTHDR_OP_IPV4 = 2,
	NFT_EXTHDR_OP_SCTP = 3,
	NFT_EXTHDR_OP_DCCP = 4,
	__NFT_EXTHDR_OP_MAX = 5,
};

enum nft_fib_attributes {
	NFTA_FIB_UNSPEC = 0,
	NFTA_FIB_DREG = 1,
	NFTA_FIB_RESULT = 2,
	NFTA_FIB_FLAGS = 3,
	__NFTA_FIB_MAX = 4,
};

enum nft_fib_flags {
	NFTA_FIB_F_SADDR = 1,
	NFTA_FIB_F_DADDR = 2,
	NFTA_FIB_F_MARK = 4,
	NFTA_FIB_F_IIF = 8,
	NFTA_FIB_F_OIF = 16,
	NFTA_FIB_F_PRESENT = 32,
};

enum nft_fib_result {
	NFT_FIB_RESULT_UNSPEC = 0,
	NFT_FIB_RESULT_OIF = 1,
	NFT_FIB_RESULT_OIFNAME = 2,
	NFT_FIB_RESULT_ADDRTYPE = 3,
	__NFT_FIB_RESULT_MAX = 4,
};

enum nft_flowtable_attributes {
	NFTA_FLOWTABLE_UNSPEC = 0,
	NFTA_FLOWTABLE_TABLE = 1,
	NFTA_FLOWTABLE_NAME = 2,
	NFTA_FLOWTABLE_HOOK = 3,
	NFTA_FLOWTABLE_USE = 4,
	NFTA_FLOWTABLE_HANDLE = 5,
	NFTA_FLOWTABLE_PAD = 6,
	NFTA_FLOWTABLE_FLAGS = 7,
	__NFTA_FLOWTABLE_MAX = 8,
};

enum nft_flowtable_flags {
	NFT_FLOWTABLE_HW_OFFLOAD = 1,
	NFT_FLOWTABLE_COUNTER = 2,
	NFT_FLOWTABLE_MASK = 3,
};

enum nft_flowtable_hook_attributes {
	NFTA_FLOWTABLE_HOOK_UNSPEC = 0,
	NFTA_FLOWTABLE_HOOK_NUM = 1,
	NFTA_FLOWTABLE_HOOK_PRIORITY = 2,
	NFTA_FLOWTABLE_HOOK_DEVS = 3,
	__NFTA_FLOWTABLE_HOOK_MAX = 4,
};

enum nft_fwd_attributes {
	NFTA_FWD_UNSPEC = 0,
	NFTA_FWD_SREG_DEV = 1,
	NFTA_FWD_SREG_ADDR = 2,
	NFTA_FWD_NFPROTO = 3,
	__NFTA_FWD_MAX = 4,
};

enum nft_gen_attributes {
	NFTA_GEN_UNSPEC = 0,
	NFTA_GEN_ID = 1,
	NFTA_GEN_PROC_PID = 2,
	NFTA_GEN_PROC_NAME = 3,
	__NFTA_GEN_MAX = 4,
};

enum nft_hash_attributes {
	NFTA_HASH_UNSPEC = 0,
	NFTA_HASH_SREG = 1,
	NFTA_HASH_DREG = 2,
	NFTA_HASH_LEN = 3,
	NFTA_HASH_MODULUS = 4,
	NFTA_HASH_SEED = 5,
	NFTA_HASH_OFFSET = 6,
	NFTA_HASH_TYPE = 7,
	NFTA_HASH_SET_NAME = 8,
	NFTA_HASH_SET_ID = 9,
	__NFTA_HASH_MAX = 10,
};

enum nft_hash_types {
	NFT_HASH_JENKINS = 0,
	NFT_HASH_SYM = 1,
};

enum nft_hook_attributes {
	NFTA_HOOK_UNSPEC = 0,
	NFTA_HOOK_HOOKNUM = 1,
	NFTA_HOOK_PRIORITY = 2,
	NFTA_HOOK_DEV = 3,
	NFTA_HOOK_DEVS = 4,
	__NFTA_HOOK_MAX = 5,
};

enum nft_immediate_attributes {
	NFTA_IMMEDIATE_UNSPEC = 0,
	NFTA_IMMEDIATE_DREG = 1,
	NFTA_IMMEDIATE_DATA = 2,
	__NFTA_IMMEDIATE_MAX = 3,
};

enum nft_inner_attributes {
	NFTA_INNER_UNSPEC = 0,
	NFTA_INNER_NUM = 1,
	NFTA_INNER_TYPE = 2,
	NFTA_INNER_FLAGS = 3,
	NFTA_INNER_HDRSIZE = 4,
	NFTA_INNER_EXPR = 5,
	__NFTA_INNER_MAX = 6,
};

enum nft_inner_flags {
	NFT_INNER_HDRSIZE = 1,
	NFT_INNER_LL = 2,
	NFT_INNER_NH = 4,
	NFT_INNER_TH = 8,
};

enum nft_inner_type {
	NFT_INNER_UNSPEC = 0,
	NFT_INNER_VXLAN = 1,
	NFT_INNER_GENEVE = 2,
};

enum nft_iter_type {
	NFT_ITER_UNSPEC = 0,
	NFT_ITER_READ = 1,
	NFT_ITER_UPDATE = 2,
};

enum nft_last_attributes {
	NFTA_LAST_UNSPEC = 0,
	NFTA_LAST_SET = 1,
	NFTA_LAST_MSECS = 2,
	NFTA_LAST_PAD = 3,
	__NFTA_LAST_MAX = 4,
};

enum nft_limit_attributes {
	NFTA_LIMIT_UNSPEC = 0,
	NFTA_LIMIT_RATE = 1,
	NFTA_LIMIT_UNIT = 2,
	NFTA_LIMIT_BURST = 3,
	NFTA_LIMIT_TYPE = 4,
	NFTA_LIMIT_FLAGS = 5,
	NFTA_LIMIT_PAD = 6,
	__NFTA_LIMIT_MAX = 7,
};

enum nft_limit_flags {
	NFT_LIMIT_F_INV = 1,
};

enum nft_limit_type {
	NFT_LIMIT_PKTS = 0,
	NFT_LIMIT_PKT_BYTES = 1,
};

enum nft_list_attributes {
	NFTA_LIST_UNSPEC = 0,
	NFTA_LIST_ELEM = 1,
	__NFTA_LIST_MAX = 2,
};

enum nft_log_attributes {
	NFTA_LOG_UNSPEC = 0,
	NFTA_LOG_GROUP = 1,
	NFTA_LOG_PREFIX = 2,
	NFTA_LOG_SNAPLEN = 3,
	NFTA_LOG_QTHRESHOLD = 4,
	NFTA_LOG_LEVEL = 5,
	NFTA_LOG_FLAGS = 6,
	__NFTA_LOG_MAX = 7,
};

enum nft_log_level {
	NFT_LOGLEVEL_EMERG = 0,
	NFT_LOGLEVEL_ALERT = 1,
	NFT_LOGLEVEL_CRIT = 2,
	NFT_LOGLEVEL_ERR = 3,
	NFT_LOGLEVEL_WARNING = 4,
	NFT_LOGLEVEL_NOTICE = 5,
	NFT_LOGLEVEL_INFO = 6,
	NFT_LOGLEVEL_DEBUG = 7,
	NFT_LOGLEVEL_AUDIT = 8,
	__NFT_LOGLEVEL_MAX = 9,
};

enum nft_lookup_attributes {
	NFTA_LOOKUP_UNSPEC = 0,
	NFTA_LOOKUP_SET = 1,
	NFTA_LOOKUP_SREG = 2,
	NFTA_LOOKUP_DREG = 3,
	NFTA_LOOKUP_SET_ID = 4,
	NFTA_LOOKUP_FLAGS = 5,
	__NFTA_LOOKUP_MAX = 6,
};

enum nft_lookup_flags {
	NFT_LOOKUP_F_INV = 1,
};

enum nft_masq_attributes {
	NFTA_MASQ_UNSPEC = 0,
	NFTA_MASQ_FLAGS = 1,
	NFTA_MASQ_REG_PROTO_MIN = 2,
	NFTA_MASQ_REG_PROTO_MAX = 3,
	__NFTA_MASQ_MAX = 4,
};

enum nft_match_attributes {
	NFTA_MATCH_UNSPEC = 0,
	NFTA_MATCH_NAME = 1,
	NFTA_MATCH_REV = 2,
	NFTA_MATCH_INFO = 3,
	__NFTA_MATCH_MAX = 4,
};

enum nft_meta_attributes {
	NFTA_META_UNSPEC = 0,
	NFTA_META_DREG = 1,
	NFTA_META_KEY = 2,
	NFTA_META_SREG = 3,
	__NFTA_META_MAX = 4,
};

enum nft_meta_keys {
	NFT_META_LEN = 0,
	NFT_META_PROTOCOL = 1,
	NFT_META_PRIORITY = 2,
	NFT_META_MARK = 3,
	NFT_META_IIF = 4,
	NFT_META_OIF = 5,
	NFT_META_IIFNAME = 6,
	NFT_META_OIFNAME = 7,
	NFT_META_IFTYPE = 8,
	NFT_META_OIFTYPE = 9,
	NFT_META_SKUID = 10,
	NFT_META_SKGID = 11,
	NFT_META_NFTRACE = 12,
	NFT_META_RTCLASSID = 13,
	NFT_META_SECMARK = 14,
	NFT_META_NFPROTO = 15,
	NFT_META_L4PROTO = 16,
	NFT_META_BRI_IIFNAME = 17,
	NFT_META_BRI_OIFNAME = 18,
	NFT_META_PKTTYPE = 19,
	NFT_META_CPU = 20,
	NFT_META_IIFGROUP = 21,
	NFT_META_OIFGROUP = 22,
	NFT_META_CGROUP = 23,
	NFT_META_PRANDOM = 24,
	NFT_META_SECPATH = 25,
	NFT_META_IIFKIND = 26,
	NFT_META_OIFKIND = 27,
	NFT_META_BRI_IIFPVID = 28,
	NFT_META_BRI_IIFVPROTO = 29,
	NFT_META_TIME_NS = 30,
	NFT_META_TIME_DAY = 31,
	NFT_META_TIME_HOUR = 32,
	NFT_META_SDIF = 33,
	NFT_META_SDIFNAME = 34,
	NFT_META_BRI_BROUTE = 35,
	__NFT_META_IIFTYPE = 36,
};

enum nft_nat_attributes {
	NFTA_NAT_UNSPEC = 0,
	NFTA_NAT_TYPE = 1,
	NFTA_NAT_FAMILY = 2,
	NFTA_NAT_REG_ADDR_MIN = 3,
	NFTA_NAT_REG_ADDR_MAX = 4,
	NFTA_NAT_REG_PROTO_MIN = 5,
	NFTA_NAT_REG_PROTO_MAX = 6,
	NFTA_NAT_FLAGS = 7,
	__NFTA_NAT_MAX = 8,
};

enum nft_nat_types {
	NFT_NAT_SNAT = 0,
	NFT_NAT_DNAT = 1,
};

enum nft_ng_attributes {
	NFTA_NG_UNSPEC = 0,
	NFTA_NG_DREG = 1,
	NFTA_NG_MODULUS = 2,
	NFTA_NG_TYPE = 3,
	NFTA_NG_OFFSET = 4,
	NFTA_NG_SET_NAME = 5,
	NFTA_NG_SET_ID = 6,
	__NFTA_NG_MAX = 7,
};

enum nft_ng_types {
	NFT_NG_INCREMENTAL = 0,
	NFT_NG_RANDOM = 1,
	__NFT_NG_MAX = 2,
};

enum nft_object_attributes {
	NFTA_OBJ_UNSPEC = 0,
	NFTA_OBJ_TABLE = 1,
	NFTA_OBJ_NAME = 2,
	NFTA_OBJ_TYPE = 3,
	NFTA_OBJ_DATA = 4,
	NFTA_OBJ_USE = 5,
	NFTA_OBJ_HANDLE = 6,
	NFTA_OBJ_PAD = 7,
	NFTA_OBJ_USERDATA = 8,
	__NFTA_OBJ_MAX = 9,
};

enum nft_objref_attributes {
	NFTA_OBJREF_UNSPEC = 0,
	NFTA_OBJREF_IMM_TYPE = 1,
	NFTA_OBJREF_IMM_NAME = 2,
	NFTA_OBJREF_SET_SREG = 3,
	NFTA_OBJREF_SET_NAME = 4,
	NFTA_OBJREF_SET_ID = 5,
	__NFTA_OBJREF_MAX = 6,
};

enum nft_offload_dep_type {
	NFT_OFFLOAD_DEP_UNSPEC = 0,
	NFT_OFFLOAD_DEP_NETWORK = 1,
	NFT_OFFLOAD_DEP_TRANSPORT = 2,
};

enum nft_offload_reg_flags {
	NFT_OFFLOAD_F_NETWORK2HOST = 1,
};

enum nft_osf_attributes {
	NFTA_OSF_UNSPEC = 0,
	NFTA_OSF_DREG = 1,
	NFTA_OSF_TTL = 2,
	NFTA_OSF_FLAGS = 3,
	__NFTA_OSF_MAX = 4,
};

enum nft_osf_flags {
	NFT_OSF_F_VERSION = 1,
};

enum nft_payload_attributes {
	NFTA_PAYLOAD_UNSPEC = 0,
	NFTA_PAYLOAD_DREG = 1,
	NFTA_PAYLOAD_BASE = 2,
	NFTA_PAYLOAD_OFFSET = 3,
	NFTA_PAYLOAD_LEN = 4,
	NFTA_PAYLOAD_SREG = 5,
	NFTA_PAYLOAD_CSUM_TYPE = 6,
	NFTA_PAYLOAD_CSUM_OFFSET = 7,
	NFTA_PAYLOAD_CSUM_FLAGS = 8,
	__NFTA_PAYLOAD_MAX = 9,
};

enum nft_payload_bases {
	NFT_PAYLOAD_LL_HEADER = 0,
	NFT_PAYLOAD_NETWORK_HEADER = 1,
	NFT_PAYLOAD_TRANSPORT_HEADER = 2,
	NFT_PAYLOAD_INNER_HEADER = 3,
	NFT_PAYLOAD_TUN_HEADER = 4,
};

enum nft_payload_csum_flags {
	NFT_PAYLOAD_L4CSUM_PSEUDOHDR = 1,
};

enum nft_payload_csum_types {
	NFT_PAYLOAD_CSUM_NONE = 0,
	NFT_PAYLOAD_CSUM_INET = 1,
	NFT_PAYLOAD_CSUM_SCTP = 2,
};

enum nft_queue_attributes {
	NFTA_QUEUE_UNSPEC = 0,
	NFTA_QUEUE_NUM = 1,
	NFTA_QUEUE_TOTAL = 2,
	NFTA_QUEUE_FLAGS = 3,
	NFTA_QUEUE_SREG_QNUM = 4,
	__NFTA_QUEUE_MAX = 5,
};

enum nft_quota_attributes {
	NFTA_QUOTA_UNSPEC = 0,
	NFTA_QUOTA_BYTES = 1,
	NFTA_QUOTA_FLAGS = 2,
	NFTA_QUOTA_PAD = 3,
	NFTA_QUOTA_CONSUMED = 4,
	__NFTA_QUOTA_MAX = 5,
};

enum nft_quota_flags {
	NFT_QUOTA_F_INV = 1,
	NFT_QUOTA_F_DEPLETED = 2,
};

enum nft_range_attributes {
	NFTA_RANGE_UNSPEC = 0,
	NFTA_RANGE_SREG = 1,
	NFTA_RANGE_OP = 2,
	NFTA_RANGE_FROM_DATA = 3,
	NFTA_RANGE_TO_DATA = 4,
	__NFTA_RANGE_MAX = 5,
};

enum nft_range_ops {
	NFT_RANGE_EQ = 0,
	NFT_RANGE_NEQ = 1,
};

enum nft_redir_attributes {
	NFTA_REDIR_UNSPEC = 0,
	NFTA_REDIR_REG_PROTO_MIN = 1,
	NFTA_REDIR_REG_PROTO_MAX = 2,
	NFTA_REDIR_FLAGS = 3,
	__NFTA_REDIR_MAX = 4,
};

enum nft_registers {
	NFT_REG_VERDICT = 0,
	NFT_REG_1 = 1,
	NFT_REG_2 = 2,
	NFT_REG_3 = 3,
	NFT_REG_4 = 4,
	__NFT_REG_MAX = 5,
	NFT_REG32_00 = 8,
	NFT_REG32_01 = 9,
	NFT_REG32_02 = 10,
	NFT_REG32_03 = 11,
	NFT_REG32_04 = 12,
	NFT_REG32_05 = 13,
	NFT_REG32_06 = 14,
	NFT_REG32_07 = 15,
	NFT_REG32_08 = 16,
	NFT_REG32_09 = 17,
	NFT_REG32_10 = 18,
	NFT_REG32_11 = 19,
	NFT_REG32_12 = 20,
	NFT_REG32_13 = 21,
	NFT_REG32_14 = 22,
	NFT_REG32_15 = 23,
};

enum nft_reject_attributes {
	NFTA_REJECT_UNSPEC = 0,
	NFTA_REJECT_TYPE = 1,
	NFTA_REJECT_ICMP_CODE = 2,
	__NFTA_REJECT_MAX = 3,
};

enum nft_reject_inet_code {
	NFT_REJECT_ICMPX_NO_ROUTE = 0,
	NFT_REJECT_ICMPX_PORT_UNREACH = 1,
	NFT_REJECT_ICMPX_HOST_UNREACH = 2,
	NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 3,
	__NFT_REJECT_ICMPX_MAX = 4,
};

enum nft_reject_types {
	NFT_REJECT_ICMP_UNREACH = 0,
	NFT_REJECT_TCP_RST = 1,
	NFT_REJECT_ICMPX_UNREACH = 2,
};

enum nft_rt_attributes {
	NFTA_RT_UNSPEC = 0,
	NFTA_RT_DREG = 1,
	NFTA_RT_KEY = 2,
	__NFTA_RT_MAX = 3,
};

enum nft_rt_keys {
	NFT_RT_CLASSID = 0,
	NFT_RT_NEXTHOP4 = 1,
	NFT_RT_NEXTHOP6 = 2,
	NFT_RT_TCPMSS = 3,
	NFT_RT_XFRM = 4,
	__NFT_RT_MAX = 5,
};

enum nft_rule_attributes {
	NFTA_RULE_UNSPEC = 0,
	NFTA_RULE_TABLE = 1,
	NFTA_RULE_CHAIN = 2,
	NFTA_RULE_HANDLE = 3,
	NFTA_RULE_EXPRESSIONS = 4,
	NFTA_RULE_COMPAT = 5,
	NFTA_RULE_POSITION = 6,
	NFTA_RULE_USERDATA = 7,
	NFTA_RULE_PAD = 8,
	NFTA_RULE_ID = 9,
	NFTA_RULE_POSITION_ID = 10,
	NFTA_RULE_CHAIN_ID = 11,
	__NFTA_RULE_MAX = 12,
};

enum nft_rule_compat_attributes {
	NFTA_RULE_COMPAT_UNSPEC = 0,
	NFTA_RULE_COMPAT_PROTO = 1,
	NFTA_RULE_COMPAT_FLAGS = 2,
	__NFTA_RULE_COMPAT_MAX = 3,
};

enum nft_rule_compat_flags {
	NFT_RULE_COMPAT_F_UNUSED = 1,
	NFT_RULE_COMPAT_F_INV = 2,
	NFT_RULE_COMPAT_F_MASK = 2,
};

enum nft_secmark_attributes {
	NFTA_SECMARK_UNSPEC = 0,
	NFTA_SECMARK_CTX = 1,
	__NFTA_SECMARK_MAX = 2,
};

enum nft_set_attributes {
	NFTA_SET_UNSPEC = 0,
	NFTA_SET_TABLE = 1,
	NFTA_SET_NAME = 2,
	NFTA_SET_FLAGS = 3,
	NFTA_SET_KEY_TYPE = 4,
	NFTA_SET_KEY_LEN = 5,
	NFTA_SET_DATA_TYPE = 6,
	NFTA_SET_DATA_LEN = 7,
	NFTA_SET_POLICY = 8,
	NFTA_SET_DESC = 9,
	NFTA_SET_ID = 10,
	NFTA_SET_TIMEOUT = 11,
	NFTA_SET_GC_INTERVAL = 12,
	NFTA_SET_USERDATA = 13,
	NFTA_SET_PAD = 14,
	NFTA_SET_OBJ_TYPE = 15,
	NFTA_SET_HANDLE = 16,
	NFTA_SET_EXPR = 17,
	NFTA_SET_EXPRESSIONS = 18,
	__NFTA_SET_MAX = 19,
};

enum nft_set_class {
	NFT_SET_CLASS_O_1 = 0,
	NFT_SET_CLASS_O_LOG_N = 1,
	NFT_SET_CLASS_O_N = 2,
};

enum nft_set_desc_attributes {
	NFTA_SET_DESC_UNSPEC = 0,
	NFTA_SET_DESC_SIZE = 1,
	NFTA_SET_DESC_CONCAT = 2,
	__NFTA_SET_DESC_MAX = 3,
};

enum nft_set_elem_attributes {
	NFTA_SET_ELEM_UNSPEC = 0,
	NFTA_SET_ELEM_KEY = 1,
	NFTA_SET_ELEM_DATA = 2,
	NFTA_SET_ELEM_FLAGS = 3,
	NFTA_SET_ELEM_TIMEOUT = 4,
	NFTA_SET_ELEM_EXPIRATION = 5,
	NFTA_SET_ELEM_USERDATA = 6,
	NFTA_SET_ELEM_EXPR = 7,
	NFTA_SET_ELEM_PAD = 8,
	NFTA_SET_ELEM_OBJREF = 9,
	NFTA_SET_ELEM_KEY_END = 10,
	NFTA_SET_ELEM_EXPRESSIONS = 11,
	__NFTA_SET_ELEM_MAX = 12,
};

enum nft_set_elem_flags {
	NFT_SET_ELEM_INTERVAL_END = 1,
	NFT_SET_ELEM_CATCHALL = 2,
};

enum nft_set_elem_list_attributes {
	NFTA_SET_ELEM_LIST_UNSPEC = 0,
	NFTA_SET_ELEM_LIST_TABLE = 1,
	NFTA_SET_ELEM_LIST_SET = 2,
	NFTA_SET_ELEM_LIST_ELEMENTS = 3,
	NFTA_SET_ELEM_LIST_SET_ID = 4,
	__NFTA_SET_ELEM_LIST_MAX = 5,
};

enum nft_set_extensions {
	NFT_SET_EXT_KEY = 0,
	NFT_SET_EXT_KEY_END = 1,
	NFT_SET_EXT_DATA = 2,
	NFT_SET_EXT_FLAGS = 3,
	NFT_SET_EXT_TIMEOUT = 4,
	NFT_SET_EXT_USERDATA = 5,
	NFT_SET_EXT_EXPRESSIONS = 6,
	NFT_SET_EXT_OBJREF = 7,
	NFT_SET_EXT_NUM = 8,
};

enum nft_set_field_attributes {
	NFTA_SET_FIELD_UNSPEC = 0,
	NFTA_SET_FIELD_LEN = 1,
	__NFTA_SET_FIELD_MAX = 2,
};

enum nft_set_flags {
	NFT_SET_ANONYMOUS = 1,
	NFT_SET_CONSTANT = 2,
	NFT_SET_INTERVAL = 4,
	NFT_SET_MAP = 8,
	NFT_SET_TIMEOUT = 16,
	NFT_SET_EVAL = 32,
	NFT_SET_OBJECT = 64,
	NFT_SET_CONCAT = 128,
	NFT_SET_EXPR = 256,
};

enum nft_set_policies {
	NFT_SET_POL_PERFORMANCE = 0,
	NFT_SET_POL_MEMORY = 1,
};

enum nft_socket_attributes {
	NFTA_SOCKET_UNSPEC = 0,
	NFTA_SOCKET_KEY = 1,
	NFTA_SOCKET_DREG = 2,
	NFTA_SOCKET_LEVEL = 3,
	__NFTA_SOCKET_MAX = 4,
};

enum nft_socket_keys {
	NFT_SOCKET_TRANSPARENT = 0,
	NFT_SOCKET_MARK = 1,
	NFT_SOCKET_WILDCARD = 2,
	NFT_SOCKET_CGROUPV2 = 3,
	__NFT_SOCKET_MAX = 4,
};

enum nft_synproxy_attributes {
	NFTA_SYNPROXY_UNSPEC = 0,
	NFTA_SYNPROXY_MSS = 1,
	NFTA_SYNPROXY_WSCALE = 2,
	NFTA_SYNPROXY_FLAGS = 3,
	__NFTA_SYNPROXY_MAX = 4,
};

enum nft_table_attributes {
	NFTA_TABLE_UNSPEC = 0,
	NFTA_TABLE_NAME = 1,
	NFTA_TABLE_FLAGS = 2,
	NFTA_TABLE_USE = 3,
	NFTA_TABLE_HANDLE = 4,
	NFTA_TABLE_PAD = 5,
	NFTA_TABLE_USERDATA = 6,
	NFTA_TABLE_OWNER = 7,
	__NFTA_TABLE_MAX = 8,
};

enum nft_table_flags {
	NFT_TABLE_F_DORMANT = 1,
	NFT_TABLE_F_OWNER = 2,
	NFT_TABLE_F_PERSIST = 4,
};

enum nft_target_attributes {
	NFTA_TARGET_UNSPEC = 0,
	NFTA_TARGET_NAME = 1,
	NFTA_TARGET_REV = 2,
	NFTA_TARGET_INFO = 3,
	__NFTA_TARGET_MAX = 4,
};

enum nft_tproxy_attributes {
	NFTA_TPROXY_UNSPEC = 0,
	NFTA_TPROXY_FAMILY = 1,
	NFTA_TPROXY_REG_ADDR = 2,
	NFTA_TPROXY_REG_PORT = 3,
	__NFTA_TPROXY_MAX = 4,
};

enum nft_trace_attributes {
	NFTA_TRACE_UNSPEC = 0,
	NFTA_TRACE_TABLE = 1,
	NFTA_TRACE_CHAIN = 2,
	NFTA_TRACE_RULE_HANDLE = 3,
	NFTA_TRACE_TYPE = 4,
	NFTA_TRACE_VERDICT = 5,
	NFTA_TRACE_ID = 6,
	NFTA_TRACE_LL_HEADER = 7,
	NFTA_TRACE_NETWORK_HEADER = 8,
	NFTA_TRACE_TRANSPORT_HEADER = 9,
	NFTA_TRACE_IIF = 10,
	NFTA_TRACE_IIFTYPE = 11,
	NFTA_TRACE_OIF = 12,
	NFTA_TRACE_OIFTYPE = 13,
	NFTA_TRACE_MARK = 14,
	NFTA_TRACE_NFPROTO = 15,
	NFTA_TRACE_POLICY = 16,
	NFTA_TRACE_PAD = 17,
	__NFTA_TRACE_MAX = 18,
};

enum nft_trace_types {
	NFT_TRACETYPE_UNSPEC = 0,
	NFT_TRACETYPE_POLICY = 1,
	NFT_TRACETYPE_RETURN = 2,
	NFT_TRACETYPE_RULE = 3,
	__NFT_TRACETYPE_MAX = 4,
};

enum nft_trans_elem_flags {
	NFT_TRANS_UPD_TIMEOUT = 1,
	NFT_TRANS_UPD_EXPIRATION = 2,
};

enum nft_trans_phase {
	NFT_TRANS_PREPARE = 0,
	NFT_TRANS_PREPARE_ERROR = 1,
	NFT_TRANS_ABORT = 2,
	NFT_TRANS_COMMIT = 3,
	NFT_TRANS_RELEASE = 4,
};

enum nft_tunnel_attributes {
	NFTA_TUNNEL_UNSPEC = 0,
	NFTA_TUNNEL_KEY = 1,
	NFTA_TUNNEL_DREG = 2,
	NFTA_TUNNEL_MODE = 3,
	__NFTA_TUNNEL_MAX = 4,
};

enum nft_tunnel_flags {
	NFT_TUNNEL_F_ZERO_CSUM_TX = 1,
	NFT_TUNNEL_F_DONT_FRAGMENT = 2,
	NFT_TUNNEL_F_SEQ_NUMBER = 4,
};

enum nft_tunnel_ip6_attributes {
	NFTA_TUNNEL_KEY_IP6_UNSPEC = 0,
	NFTA_TUNNEL_KEY_IP6_SRC = 1,
	NFTA_TUNNEL_KEY_IP6_DST = 2,
	NFTA_TUNNEL_KEY_IP6_FLOWLABEL = 3,
	__NFTA_TUNNEL_KEY_IP6_MAX = 4,
};

enum nft_tunnel_key_attributes {
	NFTA_TUNNEL_KEY_UNSPEC = 0,
	NFTA_TUNNEL_KEY_ID = 1,
	NFTA_TUNNEL_KEY_IP = 2,
	NFTA_TUNNEL_KEY_IP6 = 3,
	NFTA_TUNNEL_KEY_FLAGS = 4,
	NFTA_TUNNEL_KEY_TOS = 5,
	NFTA_TUNNEL_KEY_TTL = 6,
	NFTA_TUNNEL_KEY_SPORT = 7,
	NFTA_TUNNEL_KEY_DPORT = 8,
	NFTA_TUNNEL_KEY_OPTS = 9,
	__NFTA_TUNNEL_KEY_MAX = 10,
};

enum nft_tunnel_key_ip_attributes {
	NFTA_TUNNEL_KEY_IP_UNSPEC = 0,
	NFTA_TUNNEL_KEY_IP_SRC = 1,
	NFTA_TUNNEL_KEY_IP_DST = 2,
	__NFTA_TUNNEL_KEY_IP_MAX = 3,
};

enum nft_tunnel_keys {
	NFT_TUNNEL_PATH = 0,
	NFT_TUNNEL_ID = 1,
	__NFT_TUNNEL_MAX = 2,
};

enum nft_tunnel_mode {
	NFT_TUNNEL_MODE_NONE = 0,
	NFT_TUNNEL_MODE_RX = 1,
	NFT_TUNNEL_MODE_TX = 2,
	__NFT_TUNNEL_MODE_MAX = 3,
};

enum nft_tunnel_opts_attributes {
	NFTA_TUNNEL_KEY_OPTS_UNSPEC = 0,
	NFTA_TUNNEL_KEY_OPTS_VXLAN = 1,
	NFTA_TUNNEL_KEY_OPTS_ERSPAN = 2,
	NFTA_TUNNEL_KEY_OPTS_GENEVE = 3,
	__NFTA_TUNNEL_KEY_OPTS_MAX = 4,
};

enum nft_tunnel_opts_erspan_attributes {
	NFTA_TUNNEL_KEY_ERSPAN_UNSPEC = 0,
	NFTA_TUNNEL_KEY_ERSPAN_VERSION = 1,
	NFTA_TUNNEL_KEY_ERSPAN_V1_INDEX = 2,
	NFTA_TUNNEL_KEY_ERSPAN_V2_HWID = 3,
	NFTA_TUNNEL_KEY_ERSPAN_V2_DIR = 4,
	__NFTA_TUNNEL_KEY_ERSPAN_MAX = 5,
};

enum nft_tunnel_opts_geneve_attributes {
	NFTA_TUNNEL_KEY_GENEVE_UNSPEC = 0,
	NFTA_TUNNEL_KEY_GENEVE_CLASS = 1,
	NFTA_TUNNEL_KEY_GENEVE_TYPE = 2,
	NFTA_TUNNEL_KEY_GENEVE_DATA = 3,
	__NFTA_TUNNEL_KEY_GENEVE_MAX = 4,
};

enum nft_tunnel_opts_vxlan_attributes {
	NFTA_TUNNEL_KEY_VXLAN_UNSPEC = 0,
	NFTA_TUNNEL_KEY_VXLAN_GBP = 1,
	__NFTA_TUNNEL_KEY_VXLAN_MAX = 2,
};

enum nft_verdict_attributes {
	NFTA_VERDICT_UNSPEC = 0,
	NFTA_VERDICT_CODE = 1,
	NFTA_VERDICT_CHAIN = 2,
	NFTA_VERDICT_CHAIN_ID = 3,
	__NFTA_VERDICT_MAX = 4,
};

enum nft_verdicts {
	NFT_CONTINUE = -1,
	NFT_BREAK = -2,
	NFT_JUMP = -3,
	NFT_GOTO = -4,
	NFT_RETURN = -5,
};

enum nft_xfrm_attributes {
	NFTA_XFRM_UNSPEC = 0,
	NFTA_XFRM_DREG = 1,
	NFTA_XFRM_KEY = 2,
	NFTA_XFRM_DIR = 3,
	NFTA_XFRM_SPNUM = 4,
	__NFTA_XFRM_MAX = 5,
};

enum nft_xfrm_keys {
	NFT_XFRM_KEY_UNSPEC = 0,
	NFT_XFRM_KEY_DADDR_IP4 = 1,
	NFT_XFRM_KEY_DADDR_IP6 = 2,
	NFT_XFRM_KEY_SADDR_IP4 = 3,
	NFT_XFRM_KEY_SADDR_IP6 = 4,
	NFT_XFRM_KEY_REQID = 5,
	NFT_XFRM_KEY_SPI = 6,
	__NFT_XFRM_KEY_MAX = 7,
};

enum nfulnl_attr_config {
	NFULA_CFG_UNSPEC = 0,
	NFULA_CFG_CMD = 1,
	NFULA_CFG_MODE = 2,
	NFULA_CFG_NLBUFSIZ = 3,
	NFULA_CFG_TIMEOUT = 4,
	NFULA_CFG_QTHRESH = 5,
	NFULA_CFG_FLAGS = 6,
	__NFULA_CFG_MAX = 7,
};

enum nfulnl_attr_type {
	NFULA_UNSPEC = 0,
	NFULA_PACKET_HDR = 1,
	NFULA_MARK = 2,
	NFULA_TIMESTAMP = 3,
	NFULA_IFINDEX_INDEV = 4,
	NFULA_IFINDEX_OUTDEV = 5,
	NFULA_IFINDEX_PHYSINDEV = 6,
	NFULA_IFINDEX_PHYSOUTDEV = 7,
	NFULA_HWADDR = 8,
	NFULA_PAYLOAD = 9,
	NFULA_PREFIX = 10,
	NFULA_UID = 11,
	NFULA_SEQ = 12,
	NFULA_SEQ_GLOBAL = 13,
	NFULA_GID = 14,
	NFULA_HWTYPE = 15,
	NFULA_HWHEADER = 16,
	NFULA_HWLEN = 17,
	NFULA_CT = 18,
	NFULA_CT_INFO = 19,
	NFULA_VLAN = 20,
	NFULA_L2HDR = 21,
	__NFULA_MAX = 22,
};

enum nfulnl_msg_config_cmds {
	NFULNL_CFG_CMD_NONE = 0,
	NFULNL_CFG_CMD_BIND = 1,
	NFULNL_CFG_CMD_UNBIND = 2,
	NFULNL_CFG_CMD_PF_BIND = 3,
	NFULNL_CFG_CMD_PF_UNBIND = 4,
};

enum nfulnl_msg_types {
	NFULNL_MSG_PACKET = 0,
	NFULNL_MSG_CONFIG = 1,
	NFULNL_MSG_MAX = 2,
};

enum nfulnl_vlan_attr {
	NFULA_VLAN_UNSPEC = 0,
	NFULA_VLAN_PROTO = 1,
	NFULA_VLAN_TCI = 2,
	__NFULA_VLAN_MAX = 3,
};

enum nh_notifier_info_type {
	NH_NOTIFIER_INFO_TYPE_SINGLE = 0,
	NH_NOTIFIER_INFO_TYPE_GRP = 1,
	NH_NOTIFIER_INFO_TYPE_RES_TABLE = 2,
	NH_NOTIFIER_INFO_TYPE_RES_BUCKET = 3,
	NH_NOTIFIER_INFO_TYPE_GRP_HW_STATS = 4,
};

enum nl80211_mesh_power_mode {
	NL80211_MESH_POWER_UNKNOWN = 0,
	NL80211_MESH_POWER_ACTIVE = 1,
	NL80211_MESH_POWER_LIGHT_SLEEP = 2,
	NL80211_MESH_POWER_DEEP_SLEEP = 3,
	__NL80211_MESH_POWER_AFTER_LAST = 4,
	NL80211_MESH_POWER_MAX = 3,
};

enum nl80211_sta_info {
	__NL80211_STA_INFO_INVALID = 0,
	NL80211_STA_INFO_INACTIVE_TIME = 1,
	NL80211_STA_INFO_RX_BYTES = 2,
	NL80211_STA_INFO_TX_BYTES = 3,
	NL80211_STA_INFO_LLID = 4,
	NL80211_STA_INFO_PLID = 5,
	NL80211_STA_INFO_PLINK_STATE = 6,
	NL80211_STA_INFO_SIGNAL = 7,
	NL80211_STA_INFO_TX_BITRATE = 8,
	NL80211_STA_INFO_RX_PACKETS = 9,
	NL80211_STA_INFO_TX_PACKETS = 10,
	NL80211_STA_INFO_TX_RETRIES = 11,
	NL80211_STA_INFO_TX_FAILED = 12,
	NL80211_STA_INFO_SIGNAL_AVG = 13,
	NL80211_STA_INFO_RX_BITRATE = 14,
	NL80211_STA_INFO_BSS_PARAM = 15,
	NL80211_STA_INFO_CONNECTED_TIME = 16,
	NL80211_STA_INFO_STA_FLAGS = 17,
	NL80211_STA_INFO_BEACON_LOSS = 18,
	NL80211_STA_INFO_T_OFFSET = 19,
	NL80211_STA_INFO_LOCAL_PM = 20,
	NL80211_STA_INFO_PEER_PM = 21,
	NL80211_STA_INFO_NONPEER_PM = 22,
	NL80211_STA_INFO_RX_BYTES64 = 23,
	NL80211_STA_INFO_TX_BYTES64 = 24,
	NL80211_STA_INFO_CHAIN_SIGNAL = 25,
	NL80211_STA_INFO_CHAIN_SIGNAL_AVG = 26,
	NL80211_STA_INFO_EXPECTED_THROUGHPUT = 27,
	NL80211_STA_INFO_RX_DROP_MISC = 28,
	NL80211_STA_INFO_BEACON_RX = 29,
	NL80211_STA_INFO_BEACON_SIGNAL_AVG = 30,
	NL80211_STA_INFO_TID_STATS = 31,
	NL80211_STA_INFO_RX_DURATION = 32,
	NL80211_STA_INFO_PAD = 33,
	NL80211_STA_INFO_ACK_SIGNAL = 34,
	NL80211_STA_INFO_ACK_SIGNAL_AVG = 35,
	NL80211_STA_INFO_RX_MPDUS = 36,
	NL80211_STA_INFO_FCS_ERROR_COUNT = 37,
	NL80211_STA_INFO_CONNECTED_TO_GATE = 38,
	NL80211_STA_INFO_TX_DURATION = 39,
	NL80211_STA_INFO_AIRTIME_WEIGHT = 40,
	NL80211_STA_INFO_AIRTIME_LINK_METRIC = 41,
	NL80211_STA_INFO_ASSOC_AT_BOOTTIME = 42,
	NL80211_STA_INFO_CONNECTED_TO_AS = 43,
	__NL80211_STA_INFO_AFTER_LAST = 44,
	NL80211_STA_INFO_MAX = 43,
};

enum nl802154_cca_modes {
	__NL802154_CCA_INVALID = 0,
	NL802154_CCA_ENERGY = 1,
	NL802154_CCA_CARRIER = 2,
	NL802154_CCA_ENERGY_CARRIER = 3,
	NL802154_CCA_ALOHA = 4,
	NL802154_CCA_UWB_SHR = 5,
	NL802154_CCA_UWB_MULTIPLEXED = 6,
	__NL802154_CCA_ATTR_AFTER_LAST = 7,
	NL802154_CCA_ATTR_MAX = 6,
};

enum nl802154_cca_opts {
	NL802154_CCA_OPT_ENERGY_CARRIER_AND = 0,
	NL802154_CCA_OPT_ENERGY_CARRIER_OR = 1,
	__NL802154_CCA_OPT_ATTR_AFTER_LAST = 2,
	NL802154_CCA_OPT_ATTR_MAX = 1,
};

enum nl802154_supported_bool_states {
	NL802154_SUPPORTED_BOOL_FALSE = 0,
	NL802154_SUPPORTED_BOOL_TRUE = 1,
	__NL802154_SUPPORTED_BOOL_INVALD = 2,
	NL802154_SUPPORTED_BOOL_BOTH = 3,
	__NL802154_SUPPORTED_BOOL_AFTER_LAST = 4,
	NL802154_SUPPORTED_BOOL_MAX = 3,
};

enum nla_policy_validation {
	NLA_VALIDATE_NONE = 0,
	NLA_VALIDATE_RANGE = 1,
	NLA_VALIDATE_RANGE_WARN_TOO_LONG = 2,
	NLA_VALIDATE_MIN = 3,
	NLA_VALIDATE_MAX = 4,
	NLA_VALIDATE_MASK = 5,
	NLA_VALIDATE_RANGE_PTR = 6,
	NLA_VALIDATE_FUNCTION = 7,
};

enum nlmsgerr_attrs {
	NLMSGERR_ATTR_UNUSED = 0,
	NLMSGERR_ATTR_MSG = 1,
	NLMSGERR_ATTR_OFFS = 2,
	NLMSGERR_ATTR_COOKIE = 3,
	NLMSGERR_ATTR_POLICY = 4,
	NLMSGERR_ATTR_MISS_TYPE = 5,
	NLMSGERR_ATTR_MISS_NEST = 6,
	__NLMSGERR_ATTR_MAX = 7,
	NLMSGERR_ATTR_MAX = 6,
};

enum nmi_states {
	NMI_NOT_RUNNING = 0,
	NMI_EXECUTING = 1,
	NMI_LATCHED = 2,
};

enum node_stat_item {
	NR_LRU_BASE = 0,
	NR_INACTIVE_ANON = 0,
	NR_ACTIVE_ANON = 1,
	NR_INACTIVE_FILE = 2,
	NR_ACTIVE_FILE = 3,
	NR_UNEVICTABLE = 4,
	NR_SLAB_RECLAIMABLE_B = 5,
	NR_SLAB_UNRECLAIMABLE_B = 6,
	NR_ISOLATED_ANON = 7,
	NR_ISOLATED_FILE = 8,
	WORKINGSET_NODES = 9,
	WORKINGSET_REFAULT_BASE = 10,
	WORKINGSET_REFAULT_ANON = 10,
	WORKINGSET_REFAULT_FILE = 11,
	WORKINGSET_ACTIVATE_BASE = 12,
	WORKINGSET_ACTIVATE_ANON = 12,
	WORKINGSET_ACTIVATE_FILE = 13,
	WORKINGSET_RESTORE_BASE = 14,
	WORKINGSET_RESTORE_ANON = 14,
	WORKINGSET_RESTORE_FILE = 15,
	WORKINGSET_NODERECLAIM = 16,
	NR_ANON_MAPPED = 17,
	NR_FILE_MAPPED = 18,
	NR_FILE_PAGES = 19,
	NR_FILE_DIRTY = 20,
	NR_WRITEBACK = 21,
	NR_WRITEBACK_TEMP = 22,
	NR_SHMEM = 23,
	NR_SHMEM_THPS = 24,
	NR_SHMEM_PMDMAPPED = 25,
	NR_FILE_THPS = 26,
	NR_FILE_PMDMAPPED = 27,
	NR_ANON_THPS = 28,
	NR_VMSCAN_WRITE = 29,
	NR_VMSCAN_IMMEDIATE = 30,
	NR_DIRTIED = 31,
	NR_WRITTEN = 32,
	NR_THROTTLED_WRITTEN = 33,
	NR_KERNEL_MISC_RECLAIMABLE = 34,
	NR_FOLL_PIN_ACQUIRED = 35,
	NR_FOLL_PIN_RELEASED = 36,
	NR_KERNEL_STACK_KB = 37,
	NR_PAGETABLE = 38,
	NR_SECONDARY_PAGETABLE = 39,
	NR_IOMMU_PAGES = 40,
	NR_SWAPCACHE = 41,
	PGDEMOTE_KSWAPD = 42,
	PGDEMOTE_DIRECT = 43,
	PGDEMOTE_KHUGEPAGED = 44,
	NR_HUGETLB = 45,
	NR_VM_NODE_STAT_ITEMS = 46,
};

enum node_states {
	N_POSSIBLE = 0,
	N_ONLINE = 1,
	N_NORMAL_MEMORY = 2,
	N_HIGH_MEMORY = 2,
	N_MEMORY = 3,
	N_CPU = 4,
	N_GENERIC_INITIATOR = 5,
	NR_NODE_STATES = 6,
};

enum notify_state {
	SECCOMP_NOTIFY_INIT = 0,
	SECCOMP_NOTIFY_SENT = 1,
	SECCOMP_NOTIFY_REPLIED = 2,
};

enum numa_stat_item {
	NUMA_HIT = 0,
	NUMA_MISS = 1,
	NUMA_FOREIGN = 2,
	NUMA_INTERLEAVE_HIT = 3,
	NUMA_LOCAL = 4,
	NUMA_OTHER = 5,
	NR_VM_NUMA_EVENT_ITEMS = 6,
};

enum numa_topology_type {
	NUMA_DIRECT = 0,
	NUMA_GLUELESS_MESH = 1,
	NUMA_BACKPLANE = 2,
};

enum nvme_admin_opcode {
	nvme_admin_delete_sq = 0,
	nvme_admin_create_sq = 1,
	nvme_admin_get_log_page = 2,
	nvme_admin_delete_cq = 4,
	nvme_admin_create_cq = 5,
	nvme_admin_identify = 6,
	nvme_admin_abort_cmd = 8,
	nvme_admin_set_features = 9,
	nvme_admin_get_features = 10,
	nvme_admin_async_event = 12,
	nvme_admin_ns_mgmt = 13,
	nvme_admin_activate_fw = 16,
	nvme_admin_download_fw = 17,
	nvme_admin_dev_self_test = 20,
	nvme_admin_ns_attach = 21,
	nvme_admin_keep_alive = 24,
	nvme_admin_directive_send = 25,
	nvme_admin_directive_recv = 26,
	nvme_admin_virtual_mgmt = 28,
	nvme_admin_nvme_mi_send = 29,
	nvme_admin_nvme_mi_recv = 30,
	nvme_admin_dbbuf = 124,
	nvme_admin_format_nvm = 128,
	nvme_admin_security_send = 129,
	nvme_admin_security_recv = 130,
	nvme_admin_sanitize_nvm = 132,
	nvme_admin_get_lba_status = 134,
	nvme_admin_vendor_start = 192,
};

enum nvme_ana_state {
	NVME_ANA_OPTIMIZED = 1,
	NVME_ANA_NONOPTIMIZED = 2,
	NVME_ANA_INACCESSIBLE = 3,
	NVME_ANA_PERSISTENT_LOSS = 4,
	NVME_ANA_CHANGE = 15,
};

enum nvme_ctrl_attr {
	NVME_CTRL_ATTR_HID_128_BIT = 1,
	NVME_CTRL_ATTR_TBKAS = 64,
	NVME_CTRL_ATTR_ELBAS = 32768,
	NVME_CTRL_ATTR_RHII = 262144,
};

enum nvme_ctrl_flags {
	NVME_CTRL_FAILFAST_EXPIRED = 0,
	NVME_CTRL_ADMIN_Q_STOPPED = 1,
	NVME_CTRL_STARTED_ONCE = 2,
	NVME_CTRL_STOPPED = 3,
	NVME_CTRL_SKIP_ID_CNS_CS = 4,
	NVME_CTRL_DIRTY_CAPABILITY = 5,
	NVME_CTRL_FROZEN = 6,
};

enum nvme_ctrl_state {
	NVME_CTRL_NEW = 0,
	NVME_CTRL_LIVE = 1,
	NVME_CTRL_RESETTING = 2,
	NVME_CTRL_CONNECTING = 3,
	NVME_CTRL_DELETING = 4,
	NVME_CTRL_DELETING_NOIO = 5,
	NVME_CTRL_DEAD = 6,
};

enum nvme_ctrl_type {
	NVME_CTRL_IO = 1,
	NVME_CTRL_DISC = 2,
	NVME_CTRL_ADMIN = 3,
};

enum nvme_dctype {
	NVME_DCTYPE_NOT_REPORTED = 0,
	NVME_DCTYPE_DDC = 1,
	NVME_DCTYPE_CDC = 2,
};

enum nvme_disposition {
	COMPLETE = 0,
	RETRY = 1,
	FAILOVER = 2,
	AUTHENTICATE = 3,
};

enum nvme_eds {
	NVME_EXTENDED_DATA_STRUCT = 1,
};

enum nvme_fc_obj_state {
	FC_OBJSTATE_UNKNOWN = 0,
	FC_OBJSTATE_NOTPRESENT = 1,
	FC_OBJSTATE_ONLINE = 2,
	FC_OBJSTATE_OFFLINE = 3,
	FC_OBJSTATE_BLOCKED = 4,
	FC_OBJSTATE_BYPASSED = 5,
	FC_OBJSTATE_DIAGNOSTICS = 6,
	FC_OBJSTATE_LINKDOWN = 7,
	FC_OBJSTATE_ERROR = 8,
	FC_OBJSTATE_LOOPBACK = 9,
	FC_OBJSTATE_DELETED = 10,
};

enum nvme_fc_queue_flags {
	NVME_FC_Q_CONNECTED = 0,
	NVME_FC_Q_LIVE = 1,
};

enum nvme_fcop_flags {
	FCOP_FLAGS_TERMIO = 1,
	FCOP_FLAGS_AEN = 2,
};

enum nvme_fcpop_state {
	FCPOP_STATE_UNINIT = 0,
	FCPOP_STATE_IDLE = 1,
	FCPOP_STATE_ACTIVE = 2,
	FCPOP_STATE_ABORTED = 3,
	FCPOP_STATE_COMPLETE = 4,
};

enum nvme_iopolicy {
	NVME_IOPOLICY_NUMA = 0,
	NVME_IOPOLICY_RR = 1,
	NVME_IOPOLICY_QD = 2,
};

enum nvme_ns_features {
	NVME_NS_EXT_LBAS = 1,
	NVME_NS_METADATA_SUPPORTED = 2,
	NVME_NS_DEAC = 4,
};

enum nvme_opcode {
	nvme_cmd_flush = 0,
	nvme_cmd_write = 1,
	nvme_cmd_read = 2,
	nvme_cmd_write_uncor = 4,
	nvme_cmd_compare = 5,
	nvme_cmd_write_zeroes = 8,
	nvme_cmd_dsm = 9,
	nvme_cmd_verify = 12,
	nvme_cmd_resv_register = 13,
	nvme_cmd_resv_report = 14,
	nvme_cmd_resv_acquire = 17,
	nvme_cmd_resv_release = 21,
	nvme_cmd_zone_mgmt_send = 121,
	nvme_cmd_zone_mgmt_recv = 122,
	nvme_cmd_zone_append = 125,
	nvme_cmd_vendor_start = 128,
};

enum nvme_pr_acquire_action {
	NVME_PR_ACQUIRE_ACT_ACQUIRE = 0,
	NVME_PR_ACQUIRE_ACT_PREEMPT = 1,
	NVME_PR_ACQUIRE_ACT_PREEMPT_AND_ABORT = 2,
};

enum nvme_pr_change_ptpl {
	NVME_PR_CPTPL_NO_CHANGE = 0,
	NVME_PR_CPTPL_RESV = 1073741824,
	NVME_PR_CPTPL_CLEARED = -2147483648,
	NVME_PR_CPTPL_PERSIST = -1073741824,
};

enum nvme_pr_register_action {
	NVME_PR_REGISTER_ACT_REG = 0,
	NVME_PR_REGISTER_ACT_UNREG = 1,
	NVME_PR_REGISTER_ACT_REPLACE = 2,
};

enum nvme_pr_release_action {
	NVME_PR_RELEASE_ACT_RELEASE = 0,
	NVME_PR_RELEASE_ACT_CLEAR = 1,
};

enum nvme_pr_type {
	NVME_PR_WRITE_EXCLUSIVE = 1,
	NVME_PR_EXCLUSIVE_ACCESS = 2,
	NVME_PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	NVME_PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	NVME_PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	NVME_PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

enum nvme_quirks {
	NVME_QUIRK_STRIPE_SIZE = 1,
	NVME_QUIRK_IDENTIFY_CNS = 2,
	NVME_QUIRK_DEALLOCATE_ZEROES = 4,
	NVME_QUIRK_DELAY_BEFORE_CHK_RDY = 8,
	NVME_QUIRK_NO_APST = 16,
	NVME_QUIRK_NO_DEEPEST_PS = 32,
	NVME_QUIRK_QDEPTH_ONE = 64,
	NVME_QUIRK_MEDIUM_PRIO_SQ = 128,
	NVME_QUIRK_IGNORE_DEV_SUBNQN = 256,
	NVME_QUIRK_DISABLE_WRITE_ZEROES = 512,
	NVME_QUIRK_SIMPLE_SUSPEND = 1024,
	NVME_QUIRK_SINGLE_VECTOR = 2048,
	NVME_QUIRK_128_BYTES_SQES = 4096,
	NVME_QUIRK_SHARED_TAGS = 8192,
	NVME_QUIRK_NO_TEMP_THRESH_CHANGE = 16384,
	NVME_QUIRK_NO_NS_DESC_LIST = 32768,
	NVME_QUIRK_DMA_ADDRESS_BITS_48 = 65536,
	NVME_QUIRK_SKIP_CID_GEN = 131072,
	NVME_QUIRK_BOGUS_NID = 262144,
	NVME_QUIRK_NO_SECONDARY_TEMP_THRESH = 524288,
	NVME_QUIRK_FORCE_NO_SIMPLE_SUSPEND = 1048576,
	NVME_QUIRK_BROKEN_MSI = 2097152,
	NVME_QUIRK_DMAPOOL_ALIGN_512 = 4194304,
};

enum nvme_subsys_type {
	NVME_NQN_DISC = 1,
	NVME_NQN_NVME = 2,
	NVME_NQN_CURR = 3,
};

enum nvme_zone_mgmt_action {
	NVME_ZONE_CLOSE = 1,
	NVME_ZONE_FINISH = 2,
	NVME_ZONE_OPEN = 3,
	NVME_ZONE_RESET = 4,
	NVME_ZONE_OFFLINE = 5,
	NVME_ZONE_SET_DESC_EXT = 16,
};

enum nvmefc_fcp_datadir {
	NVMEFC_FCP_NODATA = 0,
	NVMEFC_FCP_WRITE = 1,
	NVMEFC_FCP_READ = 2,
};

enum nvmem_type {
	NVMEM_TYPE_UNKNOWN = 0,
	NVMEM_TYPE_EEPROM = 1,
	NVMEM_TYPE_OTP = 2,
	NVMEM_TYPE_BATTERY_BACKED = 3,
	NVMEM_TYPE_FRAM = 4,
};

enum nvmf_capsule_command {
	nvme_fabrics_type_property_set = 0,
	nvme_fabrics_type_connect = 1,
	nvme_fabrics_type_property_get = 4,
	nvme_fabrics_type_auth_send = 5,
	nvme_fabrics_type_auth_receive = 6,
};

enum nvmf_fabrics_opcode {
	nvme_fabrics_command = 127,
};

enum oa_type {
	TYPE_OAG = 0,
	TYPE_OAM = 1,
};

enum objext_flags {
	OBJEXTS_ALLOC_FAIL = 4,
	__NR_OBJEXTS_FLAGS = 8,
};

enum offload_act_command {
	FLOW_ACT_REPLACE = 0,
	FLOW_ACT_DESTROY = 1,
	FLOW_ACT_STATS = 2,
};

enum ofp12_ipv6exthdr_flags {
	OFPIEH12_NONEXT = 1,
	OFPIEH12_ESP = 2,
	OFPIEH12_AUTH = 4,
	OFPIEH12_DEST = 8,
	OFPIEH12_FRAG = 16,
	OFPIEH12_ROUTER = 32,
	OFPIEH12_HOP = 64,
	OFPIEH12_UNREP = 128,
	OFPIEH12_UNSEQ = 256,
};

enum oom_constraint {
	CONSTRAINT_NONE = 0,
	CONSTRAINT_CPUSET = 1,
	CONSTRAINT_MEMORY_POLICY = 2,
	CONSTRAINT_MEMCG = 3,
};

enum open_claim_type4 {
	NFS4_OPEN_CLAIM_NULL = 0,
	NFS4_OPEN_CLAIM_PREVIOUS = 1,
	NFS4_OPEN_CLAIM_DELEGATE_CUR = 2,
	NFS4_OPEN_CLAIM_DELEGATE_PREV = 3,
	NFS4_OPEN_CLAIM_FH = 4,
	NFS4_OPEN_CLAIM_DELEG_CUR_FH = 5,
	NFS4_OPEN_CLAIM_DELEG_PREV_FH = 6,
};

enum opentype4 {
	NFS4_OPEN_NOCREATE = 0,
	NFS4_OPEN_CREATE = 1,
};

enum operation_mode {
	DP_AS_SDP_AVT_DYNAMIC_VTOTAL = 0,
	DP_AS_SDP_AVT_FIXED_VTOTAL = 1,
	DP_AS_SDP_FAVT_TRR_NOT_REACHED = 2,
	DP_AS_SDP_FAVT_TRR_REACHED = 3,
};

enum osf_fmatch_states {
	FMATCH_WRONG = 0,
	FMATCH_OK = 1,
	FMATCH_OPT_WRONG = 2,
};

enum ovl_copyop {
	OVL_COPY = 0,
	OVL_CLONE = 1,
	OVL_DEDUPE = 2,
};

enum ovl_entry_flag {
	OVL_E_UPPER_ALIAS = 0,
	OVL_E_OPAQUE = 1,
	OVL_E_CONNECTED = 2,
	OVL_E_XWHITEOUTS = 3,
};

enum ovl_inode_flag {
	OVL_IMPURE = 0,
	OVL_WHITEOUTS = 1,
	OVL_INDEX = 2,
	OVL_UPPERDATA = 3,
	OVL_CONST_INO = 4,
	OVL_HAS_DIGEST = 5,
	OVL_VERIFIED_DIGEST = 6,
};

enum ovl_opt {
	Opt_lowerdir = 0,
	Opt_lowerdir_add = 1,
	Opt_datadir_add = 2,
	Opt_upperdir = 3,
	Opt_workdir = 4,
	Opt_default_permissions = 5,
	Opt_redirect_dir = 6,
	Opt_index = 7,
	Opt_uuid = 8,
	Opt_nfs_export = 9,
	Opt_userxattr = 10,
	Opt_xino = 11,
	Opt_metacopy = 12,
	Opt_verity = 13,
	Opt_volatile = 14,
};

enum ovl_path_type {
	__OVL_PATH_UPPER = 1,
	__OVL_PATH_MERGE = 2,
	__OVL_PATH_ORIGIN = 4,
};

enum ovl_xattr {
	OVL_XATTR_OPAQUE = 0,
	OVL_XATTR_REDIRECT = 1,
	OVL_XATTR_ORIGIN = 2,
	OVL_XATTR_IMPURE = 3,
	OVL_XATTR_NLINK = 4,
	OVL_XATTR_UPPER = 5,
	OVL_XATTR_UUID = 6,
	OVL_XATTR_METACOPY = 7,
	OVL_XATTR_PROTATTR = 8,
	OVL_XATTR_XWHITEOUT = 9,
};

enum ovs_action_attr {
	OVS_ACTION_ATTR_UNSPEC = 0,
	OVS_ACTION_ATTR_OUTPUT = 1,
	OVS_ACTION_ATTR_USERSPACE = 2,
	OVS_ACTION_ATTR_SET = 3,
	OVS_ACTION_ATTR_PUSH_VLAN = 4,
	OVS_ACTION_ATTR_POP_VLAN = 5,
	OVS_ACTION_ATTR_SAMPLE = 6,
	OVS_ACTION_ATTR_RECIRC = 7,
	OVS_ACTION_ATTR_HASH = 8,
	OVS_ACTION_ATTR_PUSH_MPLS = 9,
	OVS_ACTION_ATTR_POP_MPLS = 10,
	OVS_ACTION_ATTR_SET_MASKED = 11,
	OVS_ACTION_ATTR_CT = 12,
	OVS_ACTION_ATTR_TRUNC = 13,
	OVS_ACTION_ATTR_PUSH_ETH = 14,
	OVS_ACTION_ATTR_POP_ETH = 15,
	OVS_ACTION_ATTR_CT_CLEAR = 16,
	OVS_ACTION_ATTR_PUSH_NSH = 17,
	OVS_ACTION_ATTR_POP_NSH = 18,
	OVS_ACTION_ATTR_METER = 19,
	OVS_ACTION_ATTR_CLONE = 20,
	OVS_ACTION_ATTR_CHECK_PKT_LEN = 21,
	OVS_ACTION_ATTR_ADD_MPLS = 22,
	OVS_ACTION_ATTR_DEC_TTL = 23,
	OVS_ACTION_ATTR_DROP = 24,
	OVS_ACTION_ATTR_PSAMPLE = 25,
	__OVS_ACTION_ATTR_MAX = 26,
	OVS_ACTION_ATTR_SET_TO_MASKED = 27,
};

enum ovs_band_attr {
	OVS_BAND_ATTR_UNSPEC = 0,
	OVS_BAND_ATTR_TYPE = 1,
	OVS_BAND_ATTR_RATE = 2,
	OVS_BAND_ATTR_BURST = 3,
	OVS_BAND_ATTR_STATS = 4,
	__OVS_BAND_ATTR_MAX = 5,
};

enum ovs_check_pkt_len_attr {
	OVS_CHECK_PKT_LEN_ATTR_UNSPEC = 0,
	OVS_CHECK_PKT_LEN_ATTR_PKT_LEN = 1,
	OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_GREATER = 2,
	OVS_CHECK_PKT_LEN_ATTR_ACTIONS_IF_LESS_EQUAL = 3,
	__OVS_CHECK_PKT_LEN_ATTR_MAX = 4,
	OVS_CHECK_PKT_LEN_ATTR_ARG = 5,
};

enum ovs_ct_attr {
	OVS_CT_ATTR_UNSPEC = 0,
	OVS_CT_ATTR_COMMIT = 1,
	OVS_CT_ATTR_ZONE = 2,
	OVS_CT_ATTR_MARK = 3,
	OVS_CT_ATTR_LABELS = 4,
	OVS_CT_ATTR_HELPER = 5,
	OVS_CT_ATTR_NAT = 6,
	OVS_CT_ATTR_FORCE_COMMIT = 7,
	OVS_CT_ATTR_EVENTMASK = 8,
	OVS_CT_ATTR_TIMEOUT = 9,
	__OVS_CT_ATTR_MAX = 10,
};

enum ovs_ct_limit_attr {
	OVS_CT_LIMIT_ATTR_UNSPEC = 0,
	OVS_CT_LIMIT_ATTR_ZONE_LIMIT = 1,
	__OVS_CT_LIMIT_ATTR_MAX = 2,
};

enum ovs_ct_limit_cmd {
	OVS_CT_LIMIT_CMD_UNSPEC = 0,
	OVS_CT_LIMIT_CMD_SET = 1,
	OVS_CT_LIMIT_CMD_DEL = 2,
	OVS_CT_LIMIT_CMD_GET = 3,
};

enum ovs_ct_nat {
	OVS_CT_NAT = 1,
	OVS_CT_SRC_NAT = 2,
	OVS_CT_DST_NAT = 4,
};

enum ovs_datapath_attr {
	OVS_DP_ATTR_UNSPEC = 0,
	OVS_DP_ATTR_NAME = 1,
	OVS_DP_ATTR_UPCALL_PID = 2,
	OVS_DP_ATTR_STATS = 3,
	OVS_DP_ATTR_MEGAFLOW_STATS = 4,
	OVS_DP_ATTR_USER_FEATURES = 5,
	OVS_DP_ATTR_PAD = 6,
	OVS_DP_ATTR_MASKS_CACHE_SIZE = 7,
	OVS_DP_ATTR_PER_CPU_PIDS = 8,
	OVS_DP_ATTR_IFINDEX = 9,
	__OVS_DP_ATTR_MAX = 10,
};

enum ovs_datapath_cmd {
	OVS_DP_CMD_UNSPEC = 0,
	OVS_DP_CMD_NEW = 1,
	OVS_DP_CMD_DEL = 2,
	OVS_DP_CMD_GET = 3,
	OVS_DP_CMD_SET = 4,
};

enum ovs_dec_ttl_attr {
	OVS_DEC_TTL_ATTR_UNSPEC = 0,
	OVS_DEC_TTL_ATTR_ACTION = 1,
	__OVS_DEC_TTL_ATTR_MAX = 2,
};

enum ovs_drop_reason {
	__OVS_DROP_REASON = 196608,
	OVS_DROP_LAST_ACTION = 196609,
	OVS_DROP_ACTION_ERROR = 196610,
	OVS_DROP_EXPLICIT = 196611,
	OVS_DROP_EXPLICIT_WITH_ERROR = 196612,
	OVS_DROP_METER = 196613,
	OVS_DROP_RECURSION_LIMIT = 196614,
	OVS_DROP_DEFERRED_LIMIT = 196615,
	OVS_DROP_FRAG_L2_TOO_LONG = 196616,
	OVS_DROP_FRAG_INVALID_PROTO = 196617,
	OVS_DROP_CONNTRACK = 196618,
	OVS_DROP_IP_TTL = 196619,
	OVS_DROP_MAX = 196620,
};

enum ovs_flow_attr {
	OVS_FLOW_ATTR_UNSPEC = 0,
	OVS_FLOW_ATTR_KEY = 1,
	OVS_FLOW_ATTR_ACTIONS = 2,
	OVS_FLOW_ATTR_STATS = 3,
	OVS_FLOW_ATTR_TCP_FLAGS = 4,
	OVS_FLOW_ATTR_USED = 5,
	OVS_FLOW_ATTR_CLEAR = 6,
	OVS_FLOW_ATTR_MASK = 7,
	OVS_FLOW_ATTR_PROBE = 8,
	OVS_FLOW_ATTR_UFID = 9,
	OVS_FLOW_ATTR_UFID_FLAGS = 10,
	OVS_FLOW_ATTR_PAD = 11,
	__OVS_FLOW_ATTR_MAX = 12,
};

enum ovs_flow_cmd {
	OVS_FLOW_CMD_UNSPEC = 0,
	OVS_FLOW_CMD_NEW = 1,
	OVS_FLOW_CMD_DEL = 2,
	OVS_FLOW_CMD_GET = 3,
	OVS_FLOW_CMD_SET = 4,
};

enum ovs_frag_type {
	OVS_FRAG_TYPE_NONE = 0,
	OVS_FRAG_TYPE_FIRST = 1,
	OVS_FRAG_TYPE_LATER = 2,
	__OVS_FRAG_TYPE_MAX = 3,
};

enum ovs_hash_alg {
	OVS_HASH_ALG_L4 = 0,
	OVS_HASH_ALG_SYM_L4 = 1,
};

enum ovs_key_attr {
	OVS_KEY_ATTR_UNSPEC = 0,
	OVS_KEY_ATTR_ENCAP = 1,
	OVS_KEY_ATTR_PRIORITY = 2,
	OVS_KEY_ATTR_IN_PORT = 3,
	OVS_KEY_ATTR_ETHERNET = 4,
	OVS_KEY_ATTR_VLAN = 5,
	OVS_KEY_ATTR_ETHERTYPE = 6,
	OVS_KEY_ATTR_IPV4 = 7,
	OVS_KEY_ATTR_IPV6 = 8,
	OVS_KEY_ATTR_TCP = 9,
	OVS_KEY_ATTR_UDP = 10,
	OVS_KEY_ATTR_ICMP = 11,
	OVS_KEY_ATTR_ICMPV6 = 12,
	OVS_KEY_ATTR_ARP = 13,
	OVS_KEY_ATTR_ND = 14,
	OVS_KEY_ATTR_SKB_MARK = 15,
	OVS_KEY_ATTR_TUNNEL = 16,
	OVS_KEY_ATTR_SCTP = 17,
	OVS_KEY_ATTR_TCP_FLAGS = 18,
	OVS_KEY_ATTR_DP_HASH = 19,
	OVS_KEY_ATTR_RECIRC_ID = 20,
	OVS_KEY_ATTR_MPLS = 21,
	OVS_KEY_ATTR_CT_STATE = 22,
	OVS_KEY_ATTR_CT_ZONE = 23,
	OVS_KEY_ATTR_CT_MARK = 24,
	OVS_KEY_ATTR_CT_LABELS = 25,
	OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV4 = 26,
	OVS_KEY_ATTR_CT_ORIG_TUPLE_IPV6 = 27,
	OVS_KEY_ATTR_NSH = 28,
	OVS_KEY_ATTR_PACKET_TYPE = 29,
	OVS_KEY_ATTR_ND_EXTENSIONS = 30,
	OVS_KEY_ATTR_TUNNEL_INFO = 31,
	OVS_KEY_ATTR_IPV6_EXTHDRS = 32,
	__OVS_KEY_ATTR_MAX = 33,
};

enum ovs_meter_attr {
	OVS_METER_ATTR_UNSPEC = 0,
	OVS_METER_ATTR_ID = 1,
	OVS_METER_ATTR_KBPS = 2,
	OVS_METER_ATTR_STATS = 3,
	OVS_METER_ATTR_BANDS = 4,
	OVS_METER_ATTR_USED = 5,
	OVS_METER_ATTR_CLEAR = 6,
	OVS_METER_ATTR_MAX_METERS = 7,
	OVS_METER_ATTR_MAX_BANDS = 8,
	OVS_METER_ATTR_PAD = 9,
	__OVS_METER_ATTR_MAX = 10,
};

enum ovs_meter_band_type {
	OVS_METER_BAND_TYPE_UNSPEC = 0,
	OVS_METER_BAND_TYPE_DROP = 1,
	__OVS_METER_BAND_TYPE_MAX = 2,
};

enum ovs_meter_cmd {
	OVS_METER_CMD_UNSPEC = 0,
	OVS_METER_CMD_FEATURES = 1,
	OVS_METER_CMD_SET = 2,
	OVS_METER_CMD_DEL = 3,
	OVS_METER_CMD_GET = 4,
};

enum ovs_nat_attr {
	OVS_NAT_ATTR_UNSPEC = 0,
	OVS_NAT_ATTR_SRC = 1,
	OVS_NAT_ATTR_DST = 2,
	OVS_NAT_ATTR_IP_MIN = 3,
	OVS_NAT_ATTR_IP_MAX = 4,
	OVS_NAT_ATTR_PROTO_MIN = 5,
	OVS_NAT_ATTR_PROTO_MAX = 6,
	OVS_NAT_ATTR_PERSISTENT = 7,
	OVS_NAT_ATTR_PROTO_HASH = 8,
	OVS_NAT_ATTR_PROTO_RANDOM = 9,
	__OVS_NAT_ATTR_MAX = 10,
};

enum ovs_nsh_key_attr {
	OVS_NSH_KEY_ATTR_UNSPEC = 0,
	OVS_NSH_KEY_ATTR_BASE = 1,
	OVS_NSH_KEY_ATTR_MD1 = 2,
	OVS_NSH_KEY_ATTR_MD2 = 3,
	__OVS_NSH_KEY_ATTR_MAX = 4,
};

enum ovs_packet_attr {
	OVS_PACKET_ATTR_UNSPEC = 0,
	OVS_PACKET_ATTR_PACKET = 1,
	OVS_PACKET_ATTR_KEY = 2,
	OVS_PACKET_ATTR_ACTIONS = 3,
	OVS_PACKET_ATTR_USERDATA = 4,
	OVS_PACKET_ATTR_EGRESS_TUN_KEY = 5,
	OVS_PACKET_ATTR_UNUSED1 = 6,
	OVS_PACKET_ATTR_UNUSED2 = 7,
	OVS_PACKET_ATTR_PROBE = 8,
	OVS_PACKET_ATTR_MRU = 9,
	OVS_PACKET_ATTR_LEN = 10,
	OVS_PACKET_ATTR_HASH = 11,
	__OVS_PACKET_ATTR_MAX = 12,
};

enum ovs_packet_cmd {
	OVS_PACKET_CMD_UNSPEC = 0,
	OVS_PACKET_CMD_MISS = 1,
	OVS_PACKET_CMD_ACTION = 2,
	OVS_PACKET_CMD_EXECUTE = 3,
};

enum ovs_pkt_hash_types {
	OVS_PACKET_HASH_SW_BIT = 4294967296ULL,
	OVS_PACKET_HASH_L4_BIT = 8589934592ULL,
};

enum ovs_psample_attr {
	OVS_PSAMPLE_ATTR_GROUP = 1,
	OVS_PSAMPLE_ATTR_COOKIE = 2,
	__OVS_PSAMPLE_ATTR_MAX = 3,
};

enum ovs_sample_attr {
	OVS_SAMPLE_ATTR_UNSPEC = 0,
	OVS_SAMPLE_ATTR_PROBABILITY = 1,
	OVS_SAMPLE_ATTR_ACTIONS = 2,
	__OVS_SAMPLE_ATTR_MAX = 3,
	OVS_SAMPLE_ATTR_ARG = 4,
};

enum ovs_tunnel_key_attr {
	OVS_TUNNEL_KEY_ATTR_ID = 0,
	OVS_TUNNEL_KEY_ATTR_IPV4_SRC = 1,
	OVS_TUNNEL_KEY_ATTR_IPV4_DST = 2,
	OVS_TUNNEL_KEY_ATTR_TOS = 3,
	OVS_TUNNEL_KEY_ATTR_TTL = 4,
	OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT = 5,
	OVS_TUNNEL_KEY_ATTR_CSUM = 6,
	OVS_TUNNEL_KEY_ATTR_OAM = 7,
	OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS = 8,
	OVS_TUNNEL_KEY_ATTR_TP_SRC = 9,
	OVS_TUNNEL_KEY_ATTR_TP_DST = 10,
	OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS = 11,
	OVS_TUNNEL_KEY_ATTR_IPV6_SRC = 12,
	OVS_TUNNEL_KEY_ATTR_IPV6_DST = 13,
	OVS_TUNNEL_KEY_ATTR_PAD = 14,
	OVS_TUNNEL_KEY_ATTR_ERSPAN_OPTS = 15,
	OVS_TUNNEL_KEY_ATTR_IPV4_INFO_BRIDGE = 16,
	__OVS_TUNNEL_KEY_ATTR_MAX = 17,
};

enum ovs_userspace_attr {
	OVS_USERSPACE_ATTR_UNSPEC = 0,
	OVS_USERSPACE_ATTR_PID = 1,
	OVS_USERSPACE_ATTR_USERDATA = 2,
	OVS_USERSPACE_ATTR_EGRESS_TUN_PORT = 3,
	OVS_USERSPACE_ATTR_ACTIONS = 4,
	__OVS_USERSPACE_ATTR_MAX = 5,
};

enum ovs_vport_attr {
	OVS_VPORT_ATTR_UNSPEC = 0,
	OVS_VPORT_ATTR_PORT_NO = 1,
	OVS_VPORT_ATTR_TYPE = 2,
	OVS_VPORT_ATTR_NAME = 3,
	OVS_VPORT_ATTR_OPTIONS = 4,
	OVS_VPORT_ATTR_UPCALL_PID = 5,
	OVS_VPORT_ATTR_STATS = 6,
	OVS_VPORT_ATTR_PAD = 7,
	OVS_VPORT_ATTR_IFINDEX = 8,
	OVS_VPORT_ATTR_NETNSID = 9,
	OVS_VPORT_ATTR_UPCALL_STATS = 10,
	__OVS_VPORT_ATTR_MAX = 11,
};

enum ovs_vport_cmd {
	OVS_VPORT_CMD_UNSPEC = 0,
	OVS_VPORT_CMD_NEW = 1,
	OVS_VPORT_CMD_DEL = 2,
	OVS_VPORT_CMD_GET = 3,
	OVS_VPORT_CMD_SET = 4,
};

enum ovs_vport_type {
	OVS_VPORT_TYPE_UNSPEC = 0,
	OVS_VPORT_TYPE_NETDEV = 1,
	OVS_VPORT_TYPE_INTERNAL = 2,
	OVS_VPORT_TYPE_GRE = 3,
	OVS_VPORT_TYPE_VXLAN = 4,
	OVS_VPORT_TYPE_GENEVE = 5,
	__OVS_VPORT_TYPE_MAX = 6,
};

enum ovs_vport_upcall_attr {
	OVS_VPORT_UPCALL_ATTR_SUCCESS = 0,
	OVS_VPORT_UPCALL_ATTR_FAIL = 1,
	__OVS_VPORT_UPCALL_ATTR_MAX = 2,
};

enum owner_state {
	OWNER_NULL = 1,
	OWNER_WRITER = 2,
	OWNER_READER = 4,
	OWNER_NONSPINNABLE = 8,
};

enum p9_cache_bits {
	CACHE_NONE = 0,
	CACHE_FILE = 1,
	CACHE_META = 2,
	CACHE_WRITEBACK = 4,
	CACHE_LOOSE = 8,
	CACHE_FSCACHE = 128,
};

enum p9_cache_shortcuts {
	CACHE_SC_NONE = 0,
	CACHE_SC_READAHEAD = 1,
	CACHE_SC_MMAP = 5,
	CACHE_SC_LOOSE = 15,
	CACHE_SC_FSCACHE = 143,
};

enum p9_fid_reftype {
	P9_FID_REF_CREATE = 0,
	P9_FID_REF_GET = 1,
	P9_FID_REF_PUT = 2,
	P9_FID_REF_DESTROY = 3,
} __attribute__((mode(byte)));

enum p9_msg_t {
	P9_TLERROR = 6,
	P9_RLERROR = 7,
	P9_TSTATFS = 8,
	P9_RSTATFS = 9,
	P9_TLOPEN = 12,
	P9_RLOPEN = 13,
	P9_TLCREATE = 14,
	P9_RLCREATE = 15,
	P9_TSYMLINK = 16,
	P9_RSYMLINK = 17,
	P9_TMKNOD = 18,
	P9_RMKNOD = 19,
	P9_TRENAME = 20,
	P9_RRENAME = 21,
	P9_TREADLINK = 22,
	P9_RREADLINK = 23,
	P9_TGETATTR = 24,
	P9_RGETATTR = 25,
	P9_TSETATTR = 26,
	P9_RSETATTR = 27,
	P9_TXATTRWALK = 30,
	P9_RXATTRWALK = 31,
	P9_TXATTRCREATE = 32,
	P9_RXATTRCREATE = 33,
	P9_TREADDIR = 40,
	P9_RREADDIR = 41,
	P9_TFSYNC = 50,
	P9_RFSYNC = 51,
	P9_TLOCK = 52,
	P9_RLOCK = 53,
	P9_TGETLOCK = 54,
	P9_RGETLOCK = 55,
	P9_TLINK = 70,
	P9_RLINK = 71,
	P9_TMKDIR = 72,
	P9_RMKDIR = 73,
	P9_TRENAMEAT = 74,
	P9_RRENAMEAT = 75,
	P9_TUNLINKAT = 76,
	P9_RUNLINKAT = 77,
	P9_TVERSION = 100,
	P9_RVERSION = 101,
	P9_TAUTH = 102,
	P9_RAUTH = 103,
	P9_TATTACH = 104,
	P9_RATTACH = 105,
	P9_TERROR = 106,
	P9_RERROR = 107,
	P9_TFLUSH = 108,
	P9_RFLUSH = 109,
	P9_TWALK = 110,
	P9_RWALK = 111,
	P9_TOPEN = 112,
	P9_ROPEN = 113,
	P9_TCREATE = 114,
	P9_RCREATE = 115,
	P9_TREAD = 116,
	P9_RREAD = 117,
	P9_TWRITE = 118,
	P9_RWRITE = 119,
	P9_TCLUNK = 120,
	P9_RCLUNK = 121,
	P9_TREMOVE = 122,
	P9_RREMOVE = 123,
	P9_TSTAT = 124,
	P9_RSTAT = 125,
	P9_TWSTAT = 126,
	P9_RWSTAT = 127,
};

enum p9_open_mode_t {
	P9_OREAD = 0,
	P9_OWRITE = 1,
	P9_ORDWR = 2,
	P9_OEXEC = 3,
	P9_OTRUNC = 16,
	P9_OREXEC = 32,
	P9_ORCLOSE = 64,
	P9_OAPPEND = 128,
	P9_OEXCL = 4096,
	P9L_MODE_MASK = 8191,
	P9L_DIRECT = 8192,
	P9L_NOWRITECACHE = 16384,
	P9L_LOOSE = 32768,
};

enum p9_perm_t {
	P9_DMDIR = 2147483648,
	P9_DMAPPEND = 1073741824,
	P9_DMEXCL = 536870912,
	P9_DMMOUNT = 268435456,
	P9_DMAUTH = 134217728,
	P9_DMTMP = 67108864,
	P9_DMSYMLINK = 33554432,
	P9_DMLINK = 16777216,
	P9_DMDEVICE = 8388608,
	P9_DMNAMEDPIPE = 2097152,
	P9_DMSOCKET = 1048576,
	P9_DMSETUID = 524288,
	P9_DMSETGID = 262144,
	P9_DMSETVTX = 65536,
};

enum p9_proto_versions {
	p9_proto_legacy = 0,
	p9_proto_2000u = 1,
	p9_proto_2000L = 2,
};

enum p9_req_status_t {
	REQ_STATUS_ALLOC = 0,
	REQ_STATUS_UNSENT = 1,
	REQ_STATUS_SENT = 2,
	REQ_STATUS_RCVD = 3,
	REQ_STATUS_FLSHD = 4,
	REQ_STATUS_ERROR = 5,
};

enum p9_session_flags {
	V9FS_PROTO_2000U = 1,
	V9FS_PROTO_2000L = 2,
	V9FS_ACCESS_SINGLE = 4,
	V9FS_ACCESS_USER = 8,
	V9FS_ACCESS_CLIENT = 16,
	V9FS_POSIX_ACL = 32,
	V9FS_NO_XATTR = 64,
	V9FS_IGNORE_QV = 128,
	V9FS_DIRECT_IO = 256,
	V9FS_SYNC = 512,
};

enum p9_trans_status {
	Connected = 0,
	BeginDisconnect = 1,
	Disconnected = 2,
	Hung = 3,
};

enum packet_sock_flags {
	PACKET_SOCK_ORIGDEV = 0,
	PACKET_SOCK_AUXDATA = 1,
	PACKET_SOCK_TX_HAS_OFF = 2,
	PACKET_SOCK_TP_LOSS = 3,
	PACKET_SOCK_RUNNING = 4,
	PACKET_SOCK_PRESSURE = 5,
	PACKET_SOCK_QDISC_BYPASS = 6,
};

enum page_cache_mode {
	_PAGE_CACHE_MODE_WB = 0,
	_PAGE_CACHE_MODE_WC = 1,
	_PAGE_CACHE_MODE_UC_MINUS = 2,
	_PAGE_CACHE_MODE_UC = 3,
	_PAGE_CACHE_MODE_WT = 4,
	_PAGE_CACHE_MODE_WP = 5,
	_PAGE_CACHE_MODE_NUM = 8,
};

enum page_memcg_data_flags {
	MEMCG_DATA_OBJEXTS = 1,
	MEMCG_DATA_KMEM = 2,
	__NR_MEMCG_DATA_FLAGS = 4,
};

enum page_size_enum {
	__PAGE_SIZE = 4096,
};

enum page_walk_action {
	ACTION_SUBTREE = 0,
	ACTION_CONTINUE = 1,
	ACTION_AGAIN = 2,
};

enum page_walk_lock {
	PGWALK_RDLOCK = 0,
	PGWALK_WRLOCK = 1,
	PGWALK_WRLOCK_VERIFY = 2,
};

enum pageblock_bits {
	PB_migrate = 0,
	PB_migrate_end = 2,
	PB_migrate_skip = 3,
	NR_PAGEBLOCK_BITS = 4,
};

enum pageflags {
	PG_locked = 0,
	PG_writeback = 1,
	PG_referenced = 2,
	PG_uptodate = 3,
	PG_dirty = 4,
	PG_lru = 5,
	PG_head = 6,
	PG_waiters = 7,
	PG_active = 8,
	PG_workingset = 9,
	PG_owner_priv_1 = 10,
	PG_owner_2 = 11,
	PG_arch_1 = 12,
	PG_reserved = 13,
	PG_private = 14,
	PG_private_2 = 15,
	PG_reclaim = 16,
	PG_swapbacked = 17,
	PG_unevictable = 18,
	PG_dropbehind = 19,
	PG_mlocked = 20,
	PG_arch_2 = 21,
	__NR_PAGEFLAGS = 22,
	PG_readahead = 16,
	PG_swapcache = 10,
	PG_checked = 10,
	PG_anon_exclusive = 11,
	PG_mappedtodisk = 11,
	PG_fscache = 15,
	PG_pinned = 10,
	PG_savepinned = 4,
	PG_foreign = 10,
	PG_xen_remapped = 10,
	PG_isolated = 16,
	PG_reported = 3,
	PG_vmemmap_self_hosted = 10,
	PG_has_hwpoisoned = 8,
	PG_large_rmappable = 9,
	PG_partially_mapped = 16,
};

enum pagetype {
	PGTY_buddy = 240,
	PGTY_offline = 241,
	PGTY_table = 242,
	PGTY_guard = 243,
	PGTY_hugetlb = 244,
	PGTY_slab = 245,
	PGTY_zsmalloc = 246,
	PGTY_unaccepted = 247,
	PGTY_mapcount_underflow = 255,
};

enum panel_type {
	PANEL_TYPE_OPREGION = 0,
	PANEL_TYPE_VBT = 1,
	PANEL_TYPE_PNPID = 2,
	PANEL_TYPE_FALLBACK = 3,
};

enum partition_cmd {
	partcmd_enable = 0,
	partcmd_enablei = 1,
	partcmd_disable = 2,
	partcmd_update = 3,
	partcmd_invalidate = 4,
};

enum passtype {
	PASS_SCAN = 0,
	PASS_REVOKE = 1,
	PASS_REPLAY = 2,
};

enum pci_bar_type {
	pci_bar_unknown = 0,
	pci_bar_io = 1,
	pci_bar_mem32 = 2,
	pci_bar_mem64 = 3,
};

enum pci_bf_sort_state {
	pci_bf_sort_default = 0,
	pci_force_nobf = 1,
	pci_force_bf = 2,
	pci_dmi_bf = 3,
};

enum pci_board_num_t {
	pbn_default = 0,
	pbn_b0_1_115200 = 1,
	pbn_b0_2_115200 = 2,
	pbn_b0_4_115200 = 3,
	pbn_b0_5_115200 = 4,
	pbn_b0_8_115200 = 5,
	pbn_b0_1_921600 = 6,
	pbn_b0_2_921600 = 7,
	pbn_b0_4_921600 = 8,
	pbn_b0_2_1130000 = 9,
	pbn_b0_4_1152000 = 10,
	pbn_b0_4_1250000 = 11,
	pbn_b0_2_1843200 = 12,
	pbn_b0_4_1843200 = 13,
	pbn_b0_1_15625000 = 14,
	pbn_b0_bt_1_115200 = 15,
	pbn_b0_bt_2_115200 = 16,
	pbn_b0_bt_4_115200 = 17,
	pbn_b0_bt_8_115200 = 18,
	pbn_b0_bt_1_460800 = 19,
	pbn_b0_bt_2_460800 = 20,
	pbn_b0_bt_4_460800 = 21,
	pbn_b0_bt_1_921600 = 22,
	pbn_b0_bt_2_921600 = 23,
	pbn_b0_bt_4_921600 = 24,
	pbn_b0_bt_8_921600 = 25,
	pbn_b1_1_115200 = 26,
	pbn_b1_2_115200 = 27,
	pbn_b1_4_115200 = 28,
	pbn_b1_8_115200 = 29,
	pbn_b1_16_115200 = 30,
	pbn_b1_1_921600 = 31,
	pbn_b1_2_921600 = 32,
	pbn_b1_4_921600 = 33,
	pbn_b1_8_921600 = 34,
	pbn_b1_2_1250000 = 35,
	pbn_b1_bt_1_115200 = 36,
	pbn_b1_bt_2_115200 = 37,
	pbn_b1_bt_4_115200 = 38,
	pbn_b1_bt_2_921600 = 39,
	pbn_b1_1_1382400 = 40,
	pbn_b1_2_1382400 = 41,
	pbn_b1_4_1382400 = 42,
	pbn_b1_8_1382400 = 43,
	pbn_b2_1_115200 = 44,
	pbn_b2_2_115200 = 45,
	pbn_b2_4_115200 = 46,
	pbn_b2_8_115200 = 47,
	pbn_b2_1_460800 = 48,
	pbn_b2_4_460800 = 49,
	pbn_b2_8_460800 = 50,
	pbn_b2_16_460800 = 51,
	pbn_b2_1_921600 = 52,
	pbn_b2_4_921600 = 53,
	pbn_b2_8_921600 = 54,
	pbn_b2_8_1152000 = 55,
	pbn_b2_bt_1_115200 = 56,
	pbn_b2_bt_2_115200 = 57,
	pbn_b2_bt_4_115200 = 58,
	pbn_b2_bt_2_921600 = 59,
	pbn_b2_bt_4_921600 = 60,
	pbn_b3_2_115200 = 61,
	pbn_b3_4_115200 = 62,
	pbn_b3_8_115200 = 63,
	pbn_b4_bt_2_921600 = 64,
	pbn_b4_bt_4_921600 = 65,
	pbn_b4_bt_8_921600 = 66,
	pbn_panacom = 67,
	pbn_panacom2 = 68,
	pbn_panacom4 = 69,
	pbn_plx_romulus = 70,
	pbn_oxsemi = 71,
	pbn_oxsemi_1_15625000 = 72,
	pbn_oxsemi_2_15625000 = 73,
	pbn_oxsemi_4_15625000 = 74,
	pbn_oxsemi_8_15625000 = 75,
	pbn_intel_i960 = 76,
	pbn_sgi_ioc3 = 77,
	pbn_computone_4 = 78,
	pbn_computone_6 = 79,
	pbn_computone_8 = 80,
	pbn_sbsxrsio = 81,
	pbn_pasemi_1682M = 82,
	pbn_ni8430_2 = 83,
	pbn_ni8430_4 = 84,
	pbn_ni8430_8 = 85,
	pbn_ni8430_16 = 86,
	pbn_ADDIDATA_PCIe_1_3906250 = 87,
	pbn_ADDIDATA_PCIe_2_3906250 = 88,
	pbn_ADDIDATA_PCIe_4_3906250 = 89,
	pbn_ADDIDATA_PCIe_8_3906250 = 90,
	pbn_ce4100_1_115200 = 91,
	pbn_omegapci = 92,
	pbn_NETMOS9900_2s_115200 = 93,
	pbn_brcm_trumanage = 94,
	pbn_fintek_4 = 95,
	pbn_fintek_8 = 96,
	pbn_fintek_12 = 97,
	pbn_fintek_F81504A = 98,
	pbn_fintek_F81508A = 99,
	pbn_fintek_F81512A = 100,
	pbn_wch382_2 = 101,
	pbn_wch384_4 = 102,
	pbn_wch384_8 = 103,
	pbn_sunix_pci_1s = 104,
	pbn_sunix_pci_2s = 105,
	pbn_sunix_pci_4s = 106,
	pbn_sunix_pci_8s = 107,
	pbn_sunix_pci_16s = 108,
	pbn_titan_1_4000000 = 109,
	pbn_titan_2_4000000 = 110,
	pbn_titan_4_4000000 = 111,
	pbn_titan_8_4000000 = 112,
	pbn_moxa_2 = 113,
	pbn_moxa_4 = 114,
	pbn_moxa_8 = 115,
};

enum pci_bus_flags {
	PCI_BUS_FLAGS_NO_MSI = 1,
	PCI_BUS_FLAGS_NO_MMRBC = 2,
	PCI_BUS_FLAGS_NO_AERSID = 4,
	PCI_BUS_FLAGS_NO_EXTCFG = 8,
};

enum pci_bus_speed {
	PCI_SPEED_33MHz = 0,
	PCI_SPEED_66MHz = 1,
	PCI_SPEED_66MHz_PCIX = 2,
	PCI_SPEED_100MHz_PCIX = 3,
	PCI_SPEED_133MHz_PCIX = 4,
	PCI_SPEED_66MHz_PCIX_ECC = 5,
	PCI_SPEED_100MHz_PCIX_ECC = 6,
	PCI_SPEED_133MHz_PCIX_ECC = 7,
	PCI_SPEED_66MHz_PCIX_266 = 9,
	PCI_SPEED_100MHz_PCIX_266 = 10,
	PCI_SPEED_133MHz_PCIX_266 = 11,
	AGP_UNKNOWN = 12,
	AGP_1X = 13,
	AGP_2X = 14,
	AGP_4X = 15,
	AGP_8X = 16,
	PCI_SPEED_66MHz_PCIX_533 = 17,
	PCI_SPEED_100MHz_PCIX_533 = 18,
	PCI_SPEED_133MHz_PCIX_533 = 19,
	PCIE_SPEED_2_5GT = 20,
	PCIE_SPEED_5_0GT = 21,
	PCIE_SPEED_8_0GT = 22,
	PCIE_SPEED_16_0GT = 23,
	PCIE_SPEED_32_0GT = 24,
	PCIE_SPEED_64_0GT = 25,
	PCI_SPEED_UNKNOWN = 255,
};

enum pci_dev_flags {
	PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
	PCI_DEV_FLAGS_NO_D3 = 2,
	PCI_DEV_FLAGS_ASSIGNED = 4,
	PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
	PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32,
	PCI_DEV_FLAGS_NO_BUS_RESET = 64,
	PCI_DEV_FLAGS_NO_PM_RESET = 128,
	PCI_DEV_FLAGS_VPD_REF_F0 = 256,
	PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = 512,
	PCI_DEV_FLAGS_NO_FLR_RESET = 1024,
	PCI_DEV_FLAGS_NO_RELAXED_ORDERING = 2048,
	PCI_DEV_FLAGS_HAS_MSI_MASKING = 4096,
};

enum pci_ers_result {
	PCI_ERS_RESULT_NONE = 1,
	PCI_ERS_RESULT_CAN_RECOVER = 2,
	PCI_ERS_RESULT_NEED_RESET = 3,
	PCI_ERS_RESULT_DISCONNECT = 4,
	PCI_ERS_RESULT_RECOVERED = 5,
	PCI_ERS_RESULT_NO_AER_DRIVER = 6,
};

enum pci_fixup_pass {
	pci_fixup_early = 0,
	pci_fixup_header = 1,
	pci_fixup_final = 2,
	pci_fixup_enable = 3,
	pci_fixup_resume = 4,
	pci_fixup_suspend = 5,
	pci_fixup_resume_early = 6,
	pci_fixup_suspend_late = 7,
};

enum pci_irq_reroute_variant {
	INTEL_IRQ_REROUTE_VARIANT = 1,
	MAX_IRQ_REROUTE_VARIANTS = 3,
};

enum pci_mmap_api {
	PCI_MMAP_SYSFS = 0,
	PCI_MMAP_PROCFS = 1,
};

enum pci_mmap_state {
	pci_mmap_io = 0,
	pci_mmap_mem = 1,
};

enum pci_p2pdma_map_type {
	PCI_P2PDMA_MAP_UNKNOWN = 0,
	PCI_P2PDMA_MAP_NOT_SUPPORTED = 1,
	PCI_P2PDMA_MAP_BUS_ADDR = 2,
	PCI_P2PDMA_MAP_THRU_HOST_BRIDGE = 3,
};

enum pcie_bus_config_types {
	PCIE_BUS_TUNE_OFF = 0,
	PCIE_BUS_DEFAULT = 1,
	PCIE_BUS_SAFE = 2,
	PCIE_BUS_PERFORMANCE = 3,
	PCIE_BUS_PEER2PEER = 4,
};

enum pcie_link_width {
	PCIE_LNK_WIDTH_RESRV = 0,
	PCIE_LNK_X1 = 1,
	PCIE_LNK_X2 = 2,
	PCIE_LNK_X4 = 4,
	PCIE_LNK_X8 = 8,
	PCIE_LNK_X12 = 12,
	PCIE_LNK_X16 = 16,
	PCIE_LNK_X32 = 32,
	PCIE_LNK_WIDTH_UNKNOWN = 255,
};

enum pcie_reset_state {
	pcie_deassert_reset = 1,
	pcie_warm_reset = 2,
	pcie_hot_reset = 3,
};

enum pcim_addr_devres_type {
	PCIM_ADDR_DEVRES_TYPE_INVALID = 0,
	PCIM_ADDR_DEVRES_TYPE_REGION = 1,
	PCIM_ADDR_DEVRES_TYPE_REGION_MAPPING = 2,
	PCIM_ADDR_DEVRES_TYPE_MAPPING = 3,
};

enum pcpu_fc {
	PCPU_FC_AUTO = 0,
	PCPU_FC_EMBED = 1,
	PCPU_FC_PAGE = 2,
	PCPU_FC_NR = 3,
};

enum pedit_cmd {
	TCA_PEDIT_KEY_EX_CMD_SET = 0,
	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
	__PEDIT_CMD_MAX = 2,
};

enum pedit_header_type {
	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
	__PEDIT_HDR_TYPE_MAX = 6,
};

enum peer_app_attr {
	DCB_ATTR_CEE_PEER_APP_UNSPEC = 0,
	DCB_ATTR_CEE_PEER_APP_INFO = 1,
	DCB_ATTR_CEE_PEER_APP = 2,
	__DCB_ATTR_CEE_PEER_APP_MAX = 3,
};

enum perf_addr_filter_action_t {
	PERF_ADDR_FILTER_ACTION_STOP = 0,
	PERF_ADDR_FILTER_ACTION_START = 1,
	PERF_ADDR_FILTER_ACTION_FILTER = 2,
};

enum perf_adl_uncore_imc_freerunning_types {
	ADL_MMIO_UNCORE_IMC_DATA_TOTAL = 0,
	ADL_MMIO_UNCORE_IMC_DATA_READ = 1,
	ADL_MMIO_UNCORE_IMC_DATA_WRITE = 2,
	ADL_MMIO_UNCORE_IMC_FREERUNNING_TYPE_MAX = 3,
};

enum perf_bpf_event_type {
	PERF_BPF_EVENT_UNKNOWN = 0,
	PERF_BPF_EVENT_PROG_LOAD = 1,
	PERF_BPF_EVENT_PROG_UNLOAD = 2,
	PERF_BPF_EVENT_MAX = 3,
};

enum perf_branch_sample_type {
	PERF_SAMPLE_BRANCH_USER = 1,
	PERF_SAMPLE_BRANCH_KERNEL = 2,
	PERF_SAMPLE_BRANCH_HV = 4,
	PERF_SAMPLE_BRANCH_ANY = 8,
	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
	PERF_SAMPLE_BRANCH_IND_CALL = 64,
	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
	PERF_SAMPLE_BRANCH_IN_TX = 256,
	PERF_SAMPLE_BRANCH_NO_TX = 512,
	PERF_SAMPLE_BRANCH_COND = 1024,
	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
	PERF_SAMPLE_BRANCH_CALL = 8192,
	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
	PERF_SAMPLE_BRANCH_HW_INDEX = 131072,
	PERF_SAMPLE_BRANCH_PRIV_SAVE = 262144,
	PERF_SAMPLE_BRANCH_COUNTERS = 524288,
	PERF_SAMPLE_BRANCH_MAX = 1048576,
};

enum perf_branch_sample_type_shift {
	PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
	PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
	PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
	PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
	PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
	PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
	PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
	PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,
	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,
	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,
	PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT = 17,
	PERF_SAMPLE_BRANCH_PRIV_SAVE_SHIFT = 18,
	PERF_SAMPLE_BRANCH_COUNTERS_SHIFT = 19,
	PERF_SAMPLE_BRANCH_MAX_SHIFT = 20,
};

enum perf_callchain_context {
	PERF_CONTEXT_HV = 18446744073709551584ULL,
	PERF_CONTEXT_KERNEL = 18446744073709551488ULL,
	PERF_CONTEXT_USER = 18446744073709551104ULL,
	PERF_CONTEXT_GUEST = 18446744073709549568ULL,
	PERF_CONTEXT_GUEST_KERNEL = 18446744073709549440ULL,
	PERF_CONTEXT_GUEST_USER = 18446744073709549056ULL,
	PERF_CONTEXT_MAX = 18446744073709547521ULL,
};

enum perf_cstate_core_events {
	PERF_CSTATE_CORE_C1_RES = 0,
	PERF_CSTATE_CORE_C3_RES = 1,
	PERF_CSTATE_CORE_C6_RES = 2,
	PERF_CSTATE_CORE_C7_RES = 3,
	PERF_CSTATE_CORE_EVENT_MAX = 4,
};

enum perf_cstate_module_events {
	PERF_CSTATE_MODULE_C6_RES = 0,
	PERF_CSTATE_MODULE_EVENT_MAX = 1,
};

enum perf_cstate_pkg_events {
	PERF_CSTATE_PKG_C2_RES = 0,
	PERF_CSTATE_PKG_C3_RES = 1,
	PERF_CSTATE_PKG_C6_RES = 2,
	PERF_CSTATE_PKG_C7_RES = 3,
	PERF_CSTATE_PKG_C8_RES = 4,
	PERF_CSTATE_PKG_C9_RES = 5,
	PERF_CSTATE_PKG_C10_RES = 6,
	PERF_CSTATE_PKG_EVENT_MAX = 7,
};

enum perf_event_ioc_flags {
	PERF_IOC_FLAG_GROUP = 1,
};

enum perf_event_read_format {
	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
	PERF_FORMAT_ID = 4,
	PERF_FORMAT_GROUP = 8,
	PERF_FORMAT_LOST = 16,
	PERF_FORMAT_MAX = 32,
};

enum perf_event_sample_format {
	PERF_SAMPLE_IP = 1,
	PERF_SAMPLE_TID = 2,
	PERF_SAMPLE_TIME = 4,
	PERF_SAMPLE_ADDR = 8,
	PERF_SAMPLE_READ = 16,
	PERF_SAMPLE_CALLCHAIN = 32,
	PERF_SAMPLE_ID = 64,
	PERF_SAMPLE_CPU = 128,
	PERF_SAMPLE_PERIOD = 256,
	PERF_SAMPLE_STREAM_ID = 512,
	PERF_SAMPLE_RAW = 1024,
	PERF_SAMPLE_BRANCH_STACK = 2048,
	PERF_SAMPLE_REGS_USER = 4096,
	PERF_SAMPLE_STACK_USER = 8192,
	PERF_SAMPLE_WEIGHT = 16384,
	PERF_SAMPLE_DATA_SRC = 32768,
	PERF_SAMPLE_IDENTIFIER = 65536,
	PERF_SAMPLE_TRANSACTION = 131072,
	PERF_SAMPLE_REGS_INTR = 262144,
	PERF_SAMPLE_PHYS_ADDR = 524288,
	PERF_SAMPLE_AUX = 1048576,
	PERF_SAMPLE_CGROUP = 2097152,
	PERF_SAMPLE_DATA_PAGE_SIZE = 4194304,
	PERF_SAMPLE_CODE_PAGE_SIZE = 8388608,
	PERF_SAMPLE_WEIGHT_STRUCT = 16777216,
	PERF_SAMPLE_MAX = 33554432,
};

enum perf_event_state {
	PERF_EVENT_STATE_DEAD = -4,
	PERF_EVENT_STATE_EXIT = -3,
	PERF_EVENT_STATE_ERROR = -2,
	PERF_EVENT_STATE_OFF = -1,
	PERF_EVENT_STATE_INACTIVE = 0,
	PERF_EVENT_STATE_ACTIVE = 1,
};

enum perf_event_task_context {
	perf_invalid_context = -1,
	perf_hw_context = 0,
	perf_sw_context = 1,
	perf_nr_task_contexts = 2,
};

enum perf_event_type {
	PERF_RECORD_MMAP = 1,
	PERF_RECORD_LOST = 2,
	PERF_RECORD_COMM = 3,
	PERF_RECORD_EXIT = 4,
	PERF_RECORD_THROTTLE = 5,
	PERF_RECORD_UNTHROTTLE = 6,
	PERF_RECORD_FORK = 7,
	PERF_RECORD_READ = 8,
	PERF_RECORD_SAMPLE = 9,
	PERF_RECORD_MMAP2 = 10,
	PERF_RECORD_AUX = 11,
	PERF_RECORD_ITRACE_START = 12,
	PERF_RECORD_LOST_SAMPLES = 13,
	PERF_RECORD_SWITCH = 14,
	PERF_RECORD_SWITCH_CPU_WIDE = 15,
	PERF_RECORD_NAMESPACES = 16,
	PERF_RECORD_KSYMBOL = 17,
	PERF_RECORD_BPF_EVENT = 18,
	PERF_RECORD_CGROUP = 19,
	PERF_RECORD_TEXT_POKE = 20,
	PERF_RECORD_AUX_OUTPUT_HW_ID = 21,
	PERF_RECORD_MAX = 22,
};

enum perf_event_x86_regs {
	PERF_REG_X86_AX = 0,
	PERF_REG_X86_BX = 1,
	PERF_REG_X86_CX = 2,
	PERF_REG_X86_DX = 3,
	PERF_REG_X86_SI = 4,
	PERF_REG_X86_DI = 5,
	PERF_REG_X86_BP = 6,
	PERF_REG_X86_SP = 7,
	PERF_REG_X86_IP = 8,
	PERF_REG_X86_FLAGS = 9,
	PERF_REG_X86_CS = 10,
	PERF_REG_X86_SS = 11,
	PERF_REG_X86_DS = 12,
	PERF_REG_X86_ES = 13,
	PERF_REG_X86_FS = 14,
	PERF_REG_X86_GS = 15,
	PERF_REG_X86_R8 = 16,
	PERF_REG_X86_R9 = 17,
	PERF_REG_X86_R10 = 18,
	PERF_REG_X86_R11 = 19,
	PERF_REG_X86_R12 = 20,
	PERF_REG_X86_R13 = 21,
	PERF_REG_X86_R14 = 22,
	PERF_REG_X86_R15 = 23,
	PERF_REG_X86_32_MAX = 16,
	PERF_REG_X86_64_MAX = 24,
	PERF_REG_X86_XMM0 = 32,
	PERF_REG_X86_XMM1 = 34,
	PERF_REG_X86_XMM2 = 36,
	PERF_REG_X86_XMM3 = 38,
	PERF_REG_X86_XMM4 = 40,
	PERF_REG_X86_XMM5 = 42,
	PERF_REG_X86_XMM6 = 44,
	PERF_REG_X86_XMM7 = 46,
	PERF_REG_X86_XMM8 = 48,
	PERF_REG_X86_XMM9 = 50,
	PERF_REG_X86_XMM10 = 52,
	PERF_REG_X86_XMM11 = 54,
	PERF_REG_X86_XMM12 = 56,
	PERF_REG_X86_XMM13 = 58,
	PERF_REG_X86_XMM14 = 60,
	PERF_REG_X86_XMM15 = 62,
	PERF_REG_X86_XMM_MAX = 64,
};

enum perf_hw_cache_id {
	PERF_COUNT_HW_CACHE_L1D = 0,
	PERF_COUNT_HW_CACHE_L1I = 1,
	PERF_COUNT_HW_CACHE_LL = 2,
	PERF_COUNT_HW_CACHE_DTLB = 3,
	PERF_COUNT_HW_CACHE_ITLB = 4,
	PERF_COUNT_HW_CACHE_BPU = 5,
	PERF_COUNT_HW_CACHE_NODE = 6,
	PERF_COUNT_HW_CACHE_MAX = 7,
};

enum perf_hw_cache_op_id {
	PERF_COUNT_HW_CACHE_OP_READ = 0,
	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
	PERF_COUNT_HW_CACHE_OP_MAX = 3,
};

enum perf_hw_cache_op_result_id {
	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
};

enum perf_hw_id {
	PERF_COUNT_HW_CPU_CYCLES = 0,
	PERF_COUNT_HW_INSTRUCTIONS = 1,
	PERF_COUNT_HW_CACHE_REFERENCES = 2,
	PERF_COUNT_HW_CACHE_MISSES = 3,
	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
	PERF_COUNT_HW_BRANCH_MISSES = 5,
	PERF_COUNT_HW_BUS_CYCLES = 6,
	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
	PERF_COUNT_HW_MAX = 10,
};

enum perf_msr_id {
	PERF_MSR_TSC = 0,
	PERF_MSR_APERF = 1,
	PERF_MSR_MPERF = 2,
	PERF_MSR_PPERF = 3,
	PERF_MSR_SMI = 4,
	PERF_MSR_PTSC = 5,
	PERF_MSR_IRPERF = 6,
	PERF_MSR_THERM = 7,
	PERF_MSR_EVENT_MAX = 8,
};

enum perf_pmu_scope {
	PERF_PMU_SCOPE_NONE = 0,
	PERF_PMU_SCOPE_CORE = 1,
	PERF_PMU_SCOPE_DIE = 2,
	PERF_PMU_SCOPE_CLUSTER = 3,
	PERF_PMU_SCOPE_PKG = 4,
	PERF_PMU_SCOPE_SYS_WIDE = 5,
	PERF_PMU_MAX_SCOPE = 6,
};

enum perf_probe_config {
	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
};

enum perf_rapl_pkg_events {
	PERF_RAPL_PP0 = 0,
	PERF_RAPL_PKG = 1,
	PERF_RAPL_RAM = 2,
	PERF_RAPL_PP1 = 3,
	PERF_RAPL_PSYS = 4,
	PERF_RAPL_PKG_EVENTS_MAX = 5,
	NR_RAPL_PKG_DOMAINS = 5,
};

enum perf_record_ksymbol_type {
	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
	PERF_RECORD_KSYMBOL_TYPE_OOL = 2,
	PERF_RECORD_KSYMBOL_TYPE_MAX = 3,
};

enum perf_sample_regs_abi {
	PERF_SAMPLE_REGS_ABI_NONE = 0,
	PERF_SAMPLE_REGS_ABI_32 = 1,
	PERF_SAMPLE_REGS_ABI_64 = 2,
};

enum perf_snb_uncore_imc_freerunning_types {
	SNB_PCI_UNCORE_IMC_DATA_READS = 0,
	SNB_PCI_UNCORE_IMC_DATA_WRITES = 1,
	SNB_PCI_UNCORE_IMC_GT_REQUESTS = 2,
	SNB_PCI_UNCORE_IMC_IA_REQUESTS = 3,
	SNB_PCI_UNCORE_IMC_IO_REQUESTS = 4,
	SNB_PCI_UNCORE_IMC_FREERUNNING_TYPE_MAX = 5,
};

enum perf_sw_ids {
	PERF_COUNT_SW_CPU_CLOCK = 0,
	PERF_COUNT_SW_TASK_CLOCK = 1,
	PERF_COUNT_SW_PAGE_FAULTS = 2,
	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
	PERF_COUNT_SW_EMULATION_FAULTS = 8,
	PERF_COUNT_SW_DUMMY = 9,
	PERF_COUNT_SW_BPF_OUTPUT = 10,
	PERF_COUNT_SW_CGROUP_SWITCHES = 11,
	PERF_COUNT_SW_MAX = 12,
};

enum perf_tgl_uncore_imc_freerunning_types {
	TGL_MMIO_UNCORE_IMC_DATA_TOTAL = 0,
	TGL_MMIO_UNCORE_IMC_DATA_READ = 1,
	TGL_MMIO_UNCORE_IMC_DATA_WRITE = 2,
	TGL_MMIO_UNCORE_IMC_FREERUNNING_TYPE_MAX = 3,
};

enum perf_type_id {
	PERF_TYPE_HARDWARE = 0,
	PERF_TYPE_SOFTWARE = 1,
	PERF_TYPE_TRACEPOINT = 2,
	PERF_TYPE_HW_CACHE = 3,
	PERF_TYPE_RAW = 4,
	PERF_TYPE_BREAKPOINT = 5,
	PERF_TYPE_MAX = 6,
};

enum perf_uncore_icx_iio_freerunning_type_id {
	ICX_IIO_MSR_IOCLK = 0,
	ICX_IIO_MSR_BW_IN = 1,
	ICX_IIO_FREERUNNING_TYPE_MAX = 2,
};

enum perf_uncore_icx_imc_freerunning_type_id {
	ICX_IMC_DCLK = 0,
	ICX_IMC_DDR = 1,
	ICX_IMC_DDRT = 2,
	ICX_IMC_FREERUNNING_TYPE_MAX = 3,
};

enum perf_uncore_iio_freerunning_type_id {
	SKX_IIO_MSR_IOCLK = 0,
	SKX_IIO_MSR_BW = 1,
	SKX_IIO_MSR_UTIL = 2,
	SKX_IIO_FREERUNNING_TYPE_MAX = 3,
};

enum perf_uncore_snr_iio_freerunning_type_id {
	SNR_IIO_MSR_IOCLK = 0,
	SNR_IIO_MSR_BW_IN = 1,
	SNR_IIO_FREERUNNING_TYPE_MAX = 2,
};

enum perf_uncore_snr_imc_freerunning_type_id {
	SNR_IMC_DCLK = 0,
	SNR_IMC_DDR = 1,
	SNR_IMC_FREERUNNING_TYPE_MAX = 2,
};

enum perf_uncore_spr_iio_freerunning_type_id {
	SPR_IIO_MSR_IOCLK = 0,
	SPR_IIO_MSR_BW_IN = 1,
	SPR_IIO_MSR_BW_OUT = 2,
	SPR_IIO_FREERUNNING_TYPE_MAX = 3,
};

enum perf_uncore_spr_imc_freerunning_type_id {
	SPR_IMC_DCLK = 0,
	SPR_IMC_PQ_CYCLES = 1,
	SPR_IMC_FREERUNNING_TYPE_MAX = 2,
};

enum pg_level {
	PG_LEVEL_NONE = 0,
	PG_LEVEL_4K = 1,
	PG_LEVEL_2M = 2,
	PG_LEVEL_1G = 3,
	PG_LEVEL_512G = 4,
	PG_LEVEL_256T = 5,
	PG_LEVEL_NUM = 6,
};

enum pgdat_flags {
	PGDAT_DIRTY = 0,
	PGDAT_WRITEBACK = 1,
	PGDAT_RECLAIM_LOCKED = 2,
};

enum pgt_entry {
	NORMAL_PMD = 0,
	HPAGE_PMD = 1,
	NORMAL_PUD = 2,
	HPAGE_PUD = 3,
};

enum phy {
	PHY_NONE = -1,
	PHY_A = 0,
	PHY_B = 1,
	PHY_C = 2,
	PHY_D = 3,
	PHY_E = 4,
	PHY_F = 5,
	PHY_G = 6,
	PHY_H = 7,
	PHY_I = 8,
	I915_MAX_PHYS = 9,
};

enum phy_fia {
	FIA1 = 0,
	FIA2 = 1,
	FIA3 = 2,
};

enum phy_state {
	PHY_DOWN = 0,
	PHY_READY = 1,
	PHY_HALTED = 2,
	PHY_ERROR = 3,
	PHY_UP = 4,
	PHY_RUNNING = 5,
	PHY_NOLINK = 6,
	PHY_CABLETEST = 7,
};

enum phy_state_work {
	PHY_STATE_WORK_NONE = 0,
	PHY_STATE_WORK_ANEG = 1,
	PHY_STATE_WORK_SUSPEND = 2,
};

enum phy_tunable_id {
	ETHTOOL_PHY_ID_UNSPEC = 0,
	ETHTOOL_PHY_DOWNSHIFT = 1,
	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
	ETHTOOL_PHY_EDPD = 3,
	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
};

enum phy_upstream {
	PHY_UPSTREAM_MAC = 0,
	PHY_UPSTREAM_PHY = 1,
};

enum pid_type {
	PIDTYPE_PID = 0,
	PIDTYPE_TGID = 1,
	PIDTYPE_PGID = 2,
	PIDTYPE_SID = 3,
	PIDTYPE_MAX = 4,
};

enum pidcg_event {
	PIDCG_MAX = 0,
	PIDCG_FORKFAIL = 1,
	NR_PIDCG_EVENTS = 2,
};

enum pinctrl_map_type {
	PIN_MAP_TYPE_INVALID = 0,
	PIN_MAP_TYPE_DUMMY_STATE = 1,
	PIN_MAP_TYPE_MUX_GROUP = 2,
	PIN_MAP_TYPE_CONFIGS_PIN = 3,
	PIN_MAP_TYPE_CONFIGS_GROUP = 4,
};

enum pipe {
	INVALID_PIPE = -1,
	PIPE_A = 0,
	PIPE_B = 1,
	PIPE_C = 2,
	PIPE_D = 3,
	_PIPE_EDP = 4,
	I915_MAX_PIPES = 4,
};

enum pkcs7_actions {
	ACT_pkcs7_check_content_type = 0,
	ACT_pkcs7_extract_cert = 1,
	ACT_pkcs7_note_OID = 2,
	ACT_pkcs7_note_certificate_list = 3,
	ACT_pkcs7_note_content = 4,
	ACT_pkcs7_note_data = 5,
	ACT_pkcs7_note_signed_info = 6,
	ACT_pkcs7_note_signeddata_version = 7,
	ACT_pkcs7_note_signerinfo_version = 8,
	ACT_pkcs7_sig_note_authenticated_attr = 9,
	ACT_pkcs7_sig_note_digest_algo = 10,
	ACT_pkcs7_sig_note_issuer = 11,
	ACT_pkcs7_sig_note_pkey_algo = 12,
	ACT_pkcs7_sig_note_serial = 13,
	ACT_pkcs7_sig_note_set_of_authattrs = 14,
	ACT_pkcs7_sig_note_signature = 15,
	ACT_pkcs7_sig_note_skid = 16,
	NR__pkcs7_actions = 17,
};

enum pkt_hash_types {
	PKT_HASH_TYPE_NONE = 0,
	PKT_HASH_TYPE_L2 = 1,
	PKT_HASH_TYPE_L3 = 2,
	PKT_HASH_TYPE_L4 = 3,
};

enum plane_id {
	PLANE_1 = 0,
	PLANE_2 = 1,
	PLANE_3 = 2,
	PLANE_4 = 3,
	PLANE_5 = 4,
	PLANE_6 = 5,
	PLANE_7 = 6,
	PLANE_CURSOR = 7,
	I915_MAX_PLANES = 8,
	PLANE_PRIMARY = 0,
	PLANE_SPRITE0 = 1,
	PLANE_SPRITE1 = 2,
};

enum pm_qos_flags_status {
	PM_QOS_FLAGS_UNDEFINED = -1,
	PM_QOS_FLAGS_NONE = 0,
	PM_QOS_FLAGS_SOME = 1,
	PM_QOS_FLAGS_ALL = 2,
};

enum pm_qos_req_action {
	PM_QOS_ADD_REQ = 0,
	PM_QOS_UPDATE_REQ = 1,
	PM_QOS_REMOVE_REQ = 2,
};

enum pm_qos_type {
	PM_QOS_UNITIALIZED = 0,
	PM_QOS_MAX = 1,
	PM_QOS_MIN = 2,
};

enum pmc_type {
	KVM_PMC_GP = 0,
	KVM_PMC_FIXED = 1,
};

enum pnfs_iomode {
	IOMODE_READ = 1,
	IOMODE_RW = 2,
	IOMODE_ANY = 3,
};

enum pnfs_try_status {
	PNFS_ATTEMPTED = 0,
	PNFS_NOT_ATTEMPTED = 1,
	PNFS_TRY_AGAIN = 2,
};

enum policy_opt {
	Opt_measure = 0,
	Opt_dont_measure = 1,
	Opt_appraise = 2,
	Opt_dont_appraise = 3,
	Opt_audit = 4,
	Opt_hash___2 = 5,
	Opt_dont_hash = 6,
	Opt_obj_user = 7,
	Opt_obj_role = 8,
	Opt_obj_type = 9,
	Opt_subj_user = 10,
	Opt_subj_role = 11,
	Opt_subj_type = 12,
	Opt_func = 13,
	Opt_mask = 14,
	Opt_fsmagic = 15,
	Opt_fsname = 16,
	Opt_fsuuid = 17,
	Opt_uid_eq = 18,
	Opt_euid_eq = 19,
	Opt_gid_eq = 20,
	Opt_egid_eq = 21,
	Opt_fowner_eq = 22,
	Opt_fgroup_eq = 23,
	Opt_uid_gt = 24,
	Opt_euid_gt = 25,
	Opt_gid_gt = 26,
	Opt_egid_gt = 27,
	Opt_fowner_gt = 28,
	Opt_fgroup_gt = 29,
	Opt_uid_lt = 30,
	Opt_euid_lt = 31,
	Opt_gid_lt = 32,
	Opt_egid_lt = 33,
	Opt_fowner_lt = 34,
	Opt_fgroup_lt = 35,
	Opt_digest_type = 36,
	Opt_appraise_type = 37,
	Opt_appraise_flag = 38,
	Opt_appraise_algos = 39,
	Opt_permit_directio = 40,
	Opt_pcr = 41,
	Opt_template = 42,
	Opt_keyrings = 43,
	Opt_label = 44,
	Opt_err___9 = 45,
};

enum policy_rule_list {
	IMA_DEFAULT_POLICY = 1,
	IMA_CUSTOM_POLICY = 2,
};

enum policy_types {
	ORIGINAL_TCB = 1,
	DEFAULT_TCB = 2,
};

enum poll_time_type {
	PT_TIMEVAL = 0,
	PT_OLD_TIMEVAL = 1,
	PT_TIMESPEC = 2,
	PT_OLD_TIMESPEC = 3,
};

enum pool_workqueue_stats {
	PWQ_STAT_STARTED = 0,
	PWQ_STAT_COMPLETED = 1,
	PWQ_STAT_CPU_TIME = 2,
	PWQ_STAT_CPU_INTENSIVE = 3,
	PWQ_STAT_CM_WAKEUP = 4,
	PWQ_STAT_REPATRIATED = 5,
	PWQ_STAT_MAYDAY = 6,
	PWQ_STAT_RESCUED = 7,
	PWQ_NR_STATS = 8,
};

enum port {
	PORT_NONE = -1,
	PORT_A = 0,
	PORT_B = 1,
	PORT_C = 2,
	PORT_D = 3,
	PORT_E = 4,
	PORT_F = 5,
	PORT_G = 6,
	PORT_H = 7,
	PORT_I = 8,
	PORT_TC1 = 3,
	PORT_TC2 = 4,
	PORT_TC3 = 5,
	PORT_TC4 = 6,
	PORT_TC5 = 7,
	PORT_TC6 = 8,
	PORT_D_XELPD = 7,
	PORT_E_XELPD = 8,
	I915_MAX_PORTS = 9,
};

enum port_pkey_state {
	IB_PORT_PKEY_NOT_VALID = 0,
	IB_PORT_PKEY_VALID = 1,
	IB_PORT_PKEY_LISTED = 2,
};

enum positive_aop_returns {
	AOP_WRITEPAGE_ACTIVATE = 524288,
	AOP_TRUNCATED_PAGE = 524289,
};

enum posix_timer_state {
	POSIX_TIMER_DISARMED = 0,
	POSIX_TIMER_ARMED = 1,
	POSIX_TIMER_REQUEUE_PENDING = 2,
};

enum power_supply_charge_behaviour {
	POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO = 0,
	POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE = 1,
	POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE = 2,
};

enum power_supply_charge_type {
	POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_CHARGE_TYPE_NONE = 1,
	POWER_SUPPLY_CHARGE_TYPE_TRICKLE = 2,
	POWER_SUPPLY_CHARGE_TYPE_FAST = 3,
	POWER_SUPPLY_CHARGE_TYPE_STANDARD = 4,
	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE = 5,
	POWER_SUPPLY_CHARGE_TYPE_CUSTOM = 6,
	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE = 7,
	POWER_SUPPLY_CHARGE_TYPE_BYPASS = 8,
};

enum power_supply_notifier_events {
	PSY_EVENT_PROP_CHANGED = 0,
};

enum power_supply_property {
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
	POWER_SUPPLY_PROP_CHARGE_TYPES = 2,
	POWER_SUPPLY_PROP_HEALTH = 3,
	POWER_SUPPLY_PROP_PRESENT = 4,
	POWER_SUPPLY_PROP_ONLINE = 5,
	POWER_SUPPLY_PROP_AUTHENTIC = 6,
	POWER_SUPPLY_PROP_TECHNOLOGY = 7,
	POWER_SUPPLY_PROP_CYCLE_COUNT = 8,
	POWER_SUPPLY_PROP_VOLTAGE_MAX = 9,
	POWER_SUPPLY_PROP_VOLTAGE_MIN = 10,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 11,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 12,
	POWER_SUPPLY_PROP_VOLTAGE_NOW = 13,
	POWER_SUPPLY_PROP_VOLTAGE_AVG = 14,
	POWER_SUPPLY_PROP_VOLTAGE_OCV = 15,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 16,
	POWER_SUPPLY_PROP_CURRENT_MAX = 17,
	POWER_SUPPLY_PROP_CURRENT_NOW = 18,
	POWER_SUPPLY_PROP_CURRENT_AVG = 19,
	POWER_SUPPLY_PROP_CURRENT_BOOT = 20,
	POWER_SUPPLY_PROP_POWER_NOW = 21,
	POWER_SUPPLY_PROP_POWER_AVG = 22,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 23,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 24,
	POWER_SUPPLY_PROP_CHARGE_FULL = 25,
	POWER_SUPPLY_PROP_CHARGE_EMPTY = 26,
	POWER_SUPPLY_PROP_CHARGE_NOW = 27,
	POWER_SUPPLY_PROP_CHARGE_AVG = 28,
	POWER_SUPPLY_PROP_CHARGE_COUNTER = 29,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 30,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 31,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 32,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 33,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 34,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 35,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 36,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 37,
	POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR = 38,
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 39,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 40,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 41,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 42,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 43,
	POWER_SUPPLY_PROP_ENERGY_FULL = 44,
	POWER_SUPPLY_PROP_ENERGY_EMPTY = 45,
	POWER_SUPPLY_PROP_ENERGY_NOW = 46,
	POWER_SUPPLY_PROP_ENERGY_AVG = 47,
	POWER_SUPPLY_PROP_CAPACITY = 48,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 49,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 50,
	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN = 51,
	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 52,
	POWER_SUPPLY_PROP_TEMP = 53,
	POWER_SUPPLY_PROP_TEMP_MAX = 54,
	POWER_SUPPLY_PROP_TEMP_MIN = 55,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 56,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 57,
	POWER_SUPPLY_PROP_TEMP_AMBIENT = 58,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 59,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 60,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 61,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 62,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 63,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 64,
	POWER_SUPPLY_PROP_TYPE = 65,
	POWER_SUPPLY_PROP_USB_TYPE = 66,
	POWER_SUPPLY_PROP_SCOPE = 67,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 68,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 69,
	POWER_SUPPLY_PROP_CALIBRATE = 70,
	POWER_SUPPLY_PROP_MANUFACTURE_YEAR = 71,
	POWER_SUPPLY_PROP_MANUFACTURE_MONTH = 72,
	POWER_SUPPLY_PROP_MANUFACTURE_DAY = 73,
	POWER_SUPPLY_PROP_MODEL_NAME = 74,
	POWER_SUPPLY_PROP_MANUFACTURER = 75,
	POWER_SUPPLY_PROP_SERIAL_NUMBER = 76,
};

enum power_supply_type {
	POWER_SUPPLY_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_TYPE_BATTERY = 1,
	POWER_SUPPLY_TYPE_UPS = 2,
	POWER_SUPPLY_TYPE_MAINS = 3,
	POWER_SUPPLY_TYPE_USB = 4,
	POWER_SUPPLY_TYPE_USB_DCP = 5,
	POWER_SUPPLY_TYPE_USB_CDP = 6,
	POWER_SUPPLY_TYPE_USB_ACA = 7,
	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
	POWER_SUPPLY_TYPE_USB_PD = 9,
	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
	POWER_SUPPLY_TYPE_WIRELESS = 12,
};

enum power_supply_usb_type {
	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_USB_TYPE_SDP = 1,
	POWER_SUPPLY_USB_TYPE_DCP = 2,
	POWER_SUPPLY_USB_TYPE_CDP = 3,
	POWER_SUPPLY_USB_TYPE_ACA = 4,
	POWER_SUPPLY_USB_TYPE_C = 5,
	POWER_SUPPLY_USB_TYPE_PD = 6,
	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
};

enum pptp_ctrlcall_state {
	PPTP_CALL_NONE = 0,
	PPTP_CALL_ERROR = 1,
	PPTP_CALL_OUT_REQ = 2,
	PPTP_CALL_OUT_CONF = 3,
	PPTP_CALL_IN_REQ = 4,
	PPTP_CALL_IN_REP = 5,
	PPTP_CALL_IN_CONF = 6,
	PPTP_CALL_CLEAR_REQ = 7,
};

enum pptp_ctrlsess_state {
	PPTP_SESSION_NONE = 0,
	PPTP_SESSION_ERROR = 1,
	PPTP_SESSION_STOPREQ = 2,
	PPTP_SESSION_REQUESTED = 3,
	PPTP_SESSION_CONFIRMED = 4,
};

enum pr_status {
	PR_STS_SUCCESS = 0,
	PR_STS_IOERR = 2,
	PR_STS_RESERVATION_CONFLICT = 24,
	PR_STS_RETRY_PATH_FAILURE = 917504,
	PR_STS_PATH_FAST_FAILED = 983040,
	PR_STS_PATH_FAILED = 65536,
};

enum pr_type {
	PR_WRITE_EXCLUSIVE = 1,
	PR_EXCLUSIVE_ACCESS = 2,
	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

enum prep_dispatch {
	PREP_DISPATCH_OK = 0,
	PREP_DISPATCH_NO_TAG = 1,
	PREP_DISPATCH_NO_BUDGET = 2,
};

enum print_line_t {
	TRACE_TYPE_PARTIAL_LINE = 0,
	TRACE_TYPE_HANDLED = 1,
	TRACE_TYPE_UNHANDLED = 2,
	TRACE_TYPE_NO_CONSUME = 3,
};

enum printk_info_flags {
	LOG_FORCE_CON = 1,
	LOG_NEWLINE = 2,
	LOG_CONT = 8,
};

enum prio_policy {
	POLICY_NO_CHANGE = 0,
	POLICY_PROMOTE_TO_RT = 1,
	POLICY_RESTRICT_TO_BE = 2,
	POLICY_ALL_TO_IDLE = 3,
	POLICY_NONE_TO_RT = 4,
};

enum priv_stack_mode {
	PRIV_STACK_UNKNOWN = 0,
	NO_PRIV_STACK = 1,
	PRIV_STACK_ADAPTIVE = 2,
};

enum probe_print_type {
	PROBE_PRINT_NORMAL = 0,
	PROBE_PRINT_RETURN = 1,
	PROBE_PRINT_EVENT = 2,
};

enum probe_type {
	PROBE_DEFAULT_STRATEGY = 0,
	PROBE_PREFER_ASYNCHRONOUS = 1,
	PROBE_FORCE_SYNCHRONOUS = 2,
};

enum proc_cn_event {
	PROC_EVENT_NONE = 0,
	PROC_EVENT_FORK = 1,
	PROC_EVENT_EXEC = 2,
	PROC_EVENT_UID = 4,
	PROC_EVENT_GID = 64,
	PROC_EVENT_SID = 128,
	PROC_EVENT_PTRACE = 256,
	PROC_EVENT_COMM = 512,
	PROC_EVENT_NONZERO_EXIT = 536870912,
	PROC_EVENT_COREDUMP = 1073741824,
	PROC_EVENT_EXIT = 2147483648,
};

enum proc_cn_mcast_op {
	PROC_CN_MCAST_LISTEN = 1,
	PROC_CN_MCAST_IGNORE = 2,
};

enum proc_hidepid {
	HIDEPID_OFF = 0,
	HIDEPID_NO_ACCESS = 1,
	HIDEPID_INVISIBLE = 2,
	HIDEPID_NOT_PTRACEABLE = 4,
};

enum proc_mem_force {
	PROC_MEM_FORCE_ALWAYS = 0,
	PROC_MEM_FORCE_PTRACE = 1,
	PROC_MEM_FORCE_NEVER = 2,
};

enum proc_param {
	Opt_gid___9 = 0,
	Opt_hidepid = 1,
	Opt_subset = 2,
};

enum proc_pidonly {
	PROC_PIDONLY_OFF = 0,
	PROC_PIDONLY_ON = 1,
};

enum procmap_query_flags {
	PROCMAP_QUERY_VMA_READABLE = 1,
	PROCMAP_QUERY_VMA_WRITABLE = 2,
	PROCMAP_QUERY_VMA_EXECUTABLE = 4,
	PROCMAP_QUERY_VMA_SHARED = 8,
	PROCMAP_QUERY_COVERING_OR_NEXT_VMA = 16,
	PROCMAP_QUERY_FILE_BACKED_VMA = 32,
};

enum protection_domain_mode {
	PD_MODE_V1 = 1,
	PD_MODE_V2 = 2,
};

enum prs_errcode {
	PERR_NONE = 0,
	PERR_INVCPUS = 1,
	PERR_INVPARENT = 2,
	PERR_NOTPART = 3,
	PERR_NOTEXCL = 4,
	PERR_NOCPUS = 5,
	PERR_HOTPLUG = 6,
	PERR_CPUSEMPTY = 7,
	PERR_HKEEPING = 8,
	PERR_ACCESS = 9,
};

enum ps2_disposition {
	PS2_PROCESS = 0,
	PS2_IGNORE = 1,
	PS2_ERROR = 2,
};

enum psample_command {
	PSAMPLE_CMD_SAMPLE = 0,
	PSAMPLE_CMD_GET_GROUP = 1,
	PSAMPLE_CMD_NEW_GROUP = 2,
	PSAMPLE_CMD_DEL_GROUP = 3,
};

enum psample_nl_multicast_groups {
	PSAMPLE_NL_MCGRP_CONFIG = 0,
	PSAMPLE_NL_MCGRP_SAMPLE = 1,
};

enum psample_tunnel_key_attr {
	PSAMPLE_TUNNEL_KEY_ATTR_ID = 0,
	PSAMPLE_TUNNEL_KEY_ATTR_IPV4_SRC = 1,
	PSAMPLE_TUNNEL_KEY_ATTR_IPV4_DST = 2,
	PSAMPLE_TUNNEL_KEY_ATTR_TOS = 3,
	PSAMPLE_TUNNEL_KEY_ATTR_TTL = 4,
	PSAMPLE_TUNNEL_KEY_ATTR_DONT_FRAGMENT = 5,
	PSAMPLE_TUNNEL_KEY_ATTR_CSUM = 6,
	PSAMPLE_TUNNEL_KEY_ATTR_OAM = 7,
	PSAMPLE_TUNNEL_KEY_ATTR_GENEVE_OPTS = 8,
	PSAMPLE_TUNNEL_KEY_ATTR_TP_SRC = 9,
	PSAMPLE_TUNNEL_KEY_ATTR_TP_DST = 10,
	PSAMPLE_TUNNEL_KEY_ATTR_VXLAN_OPTS = 11,
	PSAMPLE_TUNNEL_KEY_ATTR_IPV6_SRC = 12,
	PSAMPLE_TUNNEL_KEY_ATTR_IPV6_DST = 13,
	PSAMPLE_TUNNEL_KEY_ATTR_PAD = 14,
	PSAMPLE_TUNNEL_KEY_ATTR_ERSPAN_OPTS = 15,
	PSAMPLE_TUNNEL_KEY_ATTR_IPV4_INFO_BRIDGE = 16,
	__PSAMPLE_TUNNEL_KEY_ATTR_MAX = 17,
};

enum psi_aggregators {
	PSI_AVGS = 0,
	PSI_POLL = 1,
	NR_PSI_AGGREGATORS = 2,
};

enum psi_res {
	PSI_IO = 0,
	PSI_MEM = 1,
	PSI_CPU = 2,
	NR_PSI_RESOURCES = 3,
};

enum psi_states {
	PSI_IO_SOME = 0,
	PSI_IO_FULL = 1,
	PSI_MEM_SOME = 2,
	PSI_MEM_FULL = 3,
	PSI_CPU_SOME = 4,
	PSI_CPU_FULL = 5,
	PSI_NONIDLE = 6,
	NR_PSI_STATES = 7,
};

enum psi_task_count {
	NR_IOWAIT = 0,
	NR_MEMSTALL = 1,
	NR_RUNNING = 2,
	NR_MEMSTALL_RUNNING = 3,
	NR_PSI_TASK_COUNTS = 4,
};

enum psmouse_scale {
	PSMOUSE_SCALE11 = 0,
	PSMOUSE_SCALE21 = 1,
};

enum psmouse_state {
	PSMOUSE_IGNORE = 0,
	PSMOUSE_INITIALIZING = 1,
	PSMOUSE_RESYNCING = 2,
	PSMOUSE_CMD_MODE = 3,
	PSMOUSE_ACTIVATED = 4,
};

enum psmouse_type {
	PSMOUSE_NONE = 0,
	PSMOUSE_PS2 = 1,
	PSMOUSE_PS2PP = 2,
	PSMOUSE_THINKPS = 3,
	PSMOUSE_GENPS = 4,
	PSMOUSE_IMPS = 5,
	PSMOUSE_IMEX = 6,
	PSMOUSE_SYNAPTICS = 7,
	PSMOUSE_ALPS = 8,
	PSMOUSE_LIFEBOOK = 9,
	PSMOUSE_TRACKPOINT = 10,
	PSMOUSE_TOUCHKIT_PS2 = 11,
	PSMOUSE_CORTRON = 12,
	PSMOUSE_HGPK = 13,
	PSMOUSE_ELANTECH = 14,
	PSMOUSE_FSP = 15,
	PSMOUSE_SYNAPTICS_RELATIVE = 16,
	PSMOUSE_CYPRESS = 17,
	PSMOUSE_FOCALTECH = 18,
	PSMOUSE_VMMOUSE = 19,
	PSMOUSE_BYD = 20,
	PSMOUSE_SYNAPTICS_SMBUS = 21,
	PSMOUSE_ELANTECH_SMBUS = 22,
	PSMOUSE_AUTO = 23,
};

enum pt_capabilities {
	PT_CAP_max_subleaf = 0,
	PT_CAP_cr3_filtering = 1,
	PT_CAP_psb_cyc = 2,
	PT_CAP_ip_filtering = 3,
	PT_CAP_mtc = 4,
	PT_CAP_ptwrite = 5,
	PT_CAP_power_event_trace = 6,
	PT_CAP_event_trace = 7,
	PT_CAP_tnt_disable = 8,
	PT_CAP_topa_output = 9,
	PT_CAP_topa_multiple_entries = 10,
	PT_CAP_single_range_output = 11,
	PT_CAP_output_subsys = 12,
	PT_CAP_payloads_lip = 13,
	PT_CAP_num_address_ranges = 14,
	PT_CAP_mtc_periods = 15,
	PT_CAP_cycle_thresholds = 16,
	PT_CAP_psb_periods = 17,
};

enum pti_clone_level {
	PTI_CLONE_PMD = 0,
	PTI_CLONE_PTE = 1,
};

enum pti_mode {
	PTI_AUTO = 0,
	PTI_FORCE_OFF = 1,
	PTI_FORCE_ON = 2,
};

enum ptp_clock_events {
	PTP_CLOCK_ALARM = 0,
	PTP_CLOCK_EXTTS = 1,
	PTP_CLOCK_EXTOFF = 2,
	PTP_CLOCK_PPS = 3,
	PTP_CLOCK_PPSUSR = 4,
};

enum ptp_pin_function {
	PTP_PF_NONE = 0,
	PTP_PF_EXTTS = 1,
	PTP_PF_PEROUT = 2,
	PTP_PF_PHYSYNC = 3,
};

enum pubkey_algo {
	PUBKEY_ALGO_RSA = 0,
	PUBKEY_ALGO_MAX = 1,
};

enum pwm_polarity {
	PWM_POLARITY_NORMAL = 0,
	PWM_POLARITY_INVERSED = 1,
};

enum pxp_status {
	PXP_STATUS_SUCCESS = 0,
	PXP_STATUS_ERROR_API_VERSION = 4098,
	PXP_STATUS_NOT_READY = 4110,
	PXP_STATUS_PLATFCONFIG_KF1_NOVERIF = 4122,
	PXP_STATUS_PLATFCONFIG_KF1_BAD = 4127,
	PXP_STATUS_OP_NOT_PERMITTED = 16403,
};

enum qdisc_class_ops_flags {
	QDISC_CLASS_OPS_DOIT_UNLOCKED = 1,
};

enum qdisc_state2_t {
	__QDISC_STATE2_RUNNING = 0,
};

enum qdisc_state_t {
	__QDISC_STATE_SCHED = 0,
	__QDISC_STATE_DEACTIVATED = 1,
	__QDISC_STATE_MISSED = 2,
	__QDISC_STATE_DRAINING = 3,
};

enum qfq_state {
	ER = 0,
	IR = 1,
	EB = 2,
	IB = 3,
	QFQ_MAX_STATE = 4,
};

enum queue_direction {
	ENA_COM_IO_QUEUE_DIRECTION_TX = 0,
	ENA_COM_IO_QUEUE_DIRECTION_RX = 1,
};

enum quota_type {
	USRQUOTA = 0,
	GRPQUOTA = 1,
	PRJQUOTA = 2,
};

enum ramfs_param {
	Opt_mode___6 = 0,
};

enum rapl_unit_quirk {
	RAPL_UNIT_QUIRK_NONE = 0,
	RAPL_UNIT_QUIRK_INTEL_HSW = 1,
	RAPL_UNIT_QUIRK_INTEL_SPR = 2,
};

enum rc_driver_type {
	RC_DRIVER_SCANCODE = 0,
	RC_DRIVER_IR_RAW = 1,
	RC_DRIVER_IR_RAW_TX = 2,
};

enum rc_proto {
	RC_PROTO_UNKNOWN = 0,
	RC_PROTO_OTHER = 1,
	RC_PROTO_RC5 = 2,
	RC_PROTO_RC5X_20 = 3,
	RC_PROTO_RC5_SZ = 4,
	RC_PROTO_JVC = 5,
	RC_PROTO_SONY12 = 6,
	RC_PROTO_SONY15 = 7,
	RC_PROTO_SONY20 = 8,
	RC_PROTO_NEC = 9,
	RC_PROTO_NECX = 10,
	RC_PROTO_NEC32 = 11,
	RC_PROTO_SANYO = 12,
	RC_PROTO_MCIR2_KBD = 13,
	RC_PROTO_MCIR2_MSE = 14,
	RC_PROTO_RC6_0 = 15,
	RC_PROTO_RC6_6A_20 = 16,
	RC_PROTO_RC6_6A_24 = 17,
	RC_PROTO_RC6_6A_32 = 18,
	RC_PROTO_RC6_MCE = 19,
	RC_PROTO_SHARP = 20,
	RC_PROTO_XMP = 21,
	RC_PROTO_CEC = 22,
	RC_PROTO_IMON = 23,
	RC_PROTO_RCMM12 = 24,
	RC_PROTO_RCMM24 = 25,
	RC_PROTO_RCMM32 = 26,
	RC_PROTO_XBOX_DVD = 27,
	RC_PROTO_MAX = 27,
};

enum rdma_ah_attr_type {
	RDMA_AH_ATTR_TYPE_UNDEFINED = 0,
	RDMA_AH_ATTR_TYPE_IB = 1,
	RDMA_AH_ATTR_TYPE_ROCE = 2,
	RDMA_AH_ATTR_TYPE_OPA = 3,
};

enum rdma_cm_event_type {
	RDMA_CM_EVENT_ADDR_RESOLVED = 0,
	RDMA_CM_EVENT_ADDR_ERROR = 1,
	RDMA_CM_EVENT_ROUTE_RESOLVED = 2,
	RDMA_CM_EVENT_ROUTE_ERROR = 3,
	RDMA_CM_EVENT_CONNECT_REQUEST = 4,
	RDMA_CM_EVENT_CONNECT_RESPONSE = 5,
	RDMA_CM_EVENT_CONNECT_ERROR = 6,
	RDMA_CM_EVENT_UNREACHABLE = 7,
	RDMA_CM_EVENT_REJECTED = 8,
	RDMA_CM_EVENT_ESTABLISHED = 9,
	RDMA_CM_EVENT_DISCONNECTED = 10,
	RDMA_CM_EVENT_DEVICE_REMOVAL = 11,
	RDMA_CM_EVENT_MULTICAST_JOIN = 12,
	RDMA_CM_EVENT_MULTICAST_ERROR = 13,
	RDMA_CM_EVENT_ADDR_CHANGE = 14,
	RDMA_CM_EVENT_TIMEWAIT_EXIT = 15,
};

enum rdma_driver_id {
	RDMA_DRIVER_UNKNOWN = 0,
	RDMA_DRIVER_MLX5 = 1,
	RDMA_DRIVER_MLX4 = 2,
	RDMA_DRIVER_CXGB3 = 3,
	RDMA_DRIVER_CXGB4 = 4,
	RDMA_DRIVER_MTHCA = 5,
	RDMA_DRIVER_BNXT_RE = 6,
	RDMA_DRIVER_OCRDMA = 7,
	RDMA_DRIVER_NES = 8,
	RDMA_DRIVER_I40IW = 9,
	RDMA_DRIVER_IRDMA = 9,
	RDMA_DRIVER_VMW_PVRDMA = 10,
	RDMA_DRIVER_QEDR = 11,
	RDMA_DRIVER_HNS = 12,
	RDMA_DRIVER_USNIC = 13,
	RDMA_DRIVER_RXE = 14,
	RDMA_DRIVER_HFI1 = 15,
	RDMA_DRIVER_QIB = 16,
	RDMA_DRIVER_EFA = 17,
	RDMA_DRIVER_SIW = 18,
	RDMA_DRIVER_ERDMA = 19,
	RDMA_DRIVER_MANA = 20,
};

enum rdma_link_layer {
	IB_LINK_LAYER_UNSPECIFIED = 0,
	IB_LINK_LAYER_INFINIBAND = 1,
	IB_LINK_LAYER_ETHERNET = 2,
};

enum rdma_netdev_t {
	RDMA_NETDEV_OPA_VNIC = 0,
	RDMA_NETDEV_IPOIB = 1,
};

enum rdma_network_type {
	RDMA_NETWORK_IB = 0,
	RDMA_NETWORK_ROCE_V1 = 1,
	RDMA_NETWORK_IPV4 = 2,
	RDMA_NETWORK_IPV6 = 3,
};

enum rdma_nl_counter_mask {
	RDMA_COUNTER_MASK_QP_TYPE = 1,
	RDMA_COUNTER_MASK_PID = 2,
};

enum rdma_nl_counter_mode {
	RDMA_COUNTER_MODE_NONE = 0,
	RDMA_COUNTER_MODE_AUTO = 1,
	RDMA_COUNTER_MODE_MANUAL = 2,
	RDMA_COUNTER_MODE_MAX = 3,
};

enum rdma_nl_dev_type {
	RDMA_DEVICE_TYPE_SMI = 1,
};

enum rdma_nl_name_assign_type {
	RDMA_NAME_ASSIGN_TYPE_UNKNOWN = 0,
	RDMA_NAME_ASSIGN_TYPE_USER = 1,
};

enum rdma_restrack_type {
	RDMA_RESTRACK_PD = 0,
	RDMA_RESTRACK_CQ = 1,
	RDMA_RESTRACK_QP = 2,
	RDMA_RESTRACK_CM_ID = 3,
	RDMA_RESTRACK_MR = 4,
	RDMA_RESTRACK_CTX = 5,
	RDMA_RESTRACK_COUNTER = 6,
	RDMA_RESTRACK_SRQ = 7,
	RDMA_RESTRACK_MAX = 8,
};

enum rdma_transport_type {
	RDMA_TRANSPORT_IB = 0,
	RDMA_TRANSPORT_IWARP = 1,
	RDMA_TRANSPORT_USNIC = 2,
	RDMA_TRANSPORT_USNIC_UDP = 3,
	RDMA_TRANSPORT_UNSPECIFIED = 4,
};

enum rdma_ucm_port_space {
	RDMA_PS_IPOIB = 2,
	RDMA_PS_IB = 319,
	RDMA_PS_TCP = 262,
	RDMA_PS_UDP = 273,
};

enum rdmacg_file_type {
	RDMACG_RESOURCE_TYPE_MAX = 0,
	RDMACG_RESOURCE_TYPE_STAT = 1,
};

enum rdmacg_resource_type {
	RDMACG_RESOURCE_HCA_HANDLE = 0,
	RDMACG_RESOURCE_HCA_OBJECT = 1,
	RDMACG_RESOURCE_MAX = 2,
};

enum rds_message_rxpath_latency {
	RDS_MSG_RX_HDR_TO_DGRAM_START = 0,
	RDS_MSG_RX_DGRAM_REASSEMBLE = 1,
	RDS_MSG_RX_DGRAM_DELIVERED = 2,
	RDS_MSG_RX_DGRAM_TRACE_MAX = 3,
};

enum reboot_mode {
	REBOOT_UNDEFINED = -1,
	REBOOT_COLD = 0,
	REBOOT_WARM = 1,
	REBOOT_HARD = 2,
	REBOOT_SOFT = 3,
	REBOOT_GPIO = 4,
};

enum reboot_type {
	BOOT_TRIPLE = 116,
	BOOT_KBD = 107,
	BOOT_BIOS = 98,
	BOOT_ACPI = 97,
	BOOT_EFI = 101,
	BOOT_CF9_FORCE = 112,
	BOOT_CF9_SAFE = 113,
};

enum recovery_flags {
	MD_RECOVERY_NEEDED = 0,
	MD_RECOVERY_RUNNING = 1,
	MD_RECOVERY_INTR = 2,
	MD_RECOVERY_DONE = 3,
	MD_RECOVERY_FROZEN = 4,
	MD_RECOVERY_WAIT = 5,
	MD_RECOVERY_ERROR = 6,
	MD_RECOVERY_SYNC = 7,
	MD_RECOVERY_REQUESTED = 8,
	MD_RECOVERY_CHECK = 9,
	MD_RECOVERY_RECOVER = 10,
	MD_RECOVERY_RESHAPE = 11,
	MD_RESYNCING_REMOTE = 12,
};

enum ref_state_type {
	REF_TYPE_PTR = 1,
	REF_TYPE_IRQ = 2,
	REF_TYPE_LOCK = 3,
};

enum refcount_saturation_type {
	REFCOUNT_ADD_NOT_ZERO_OVF = 0,
	REFCOUNT_ADD_OVF = 1,
	REFCOUNT_ADD_UAF = 2,
	REFCOUNT_SUB_UAF = 3,
	REFCOUNT_DEC_LEAK = 4,
};

enum reg_arg_type {
	SRC_OP = 0,
	DST_OP = 1,
	DST_OP_NO_MARK = 2,
};

enum reg_type {
	REG_TYPE_RM = 0,
	REG_TYPE_REG = 1,
	REG_TYPE_INDEX = 2,
	REG_TYPE_BASE = 3,
};

enum regex_type {
	MATCH_FULL = 0,
	MATCH_FRONT_ONLY = 1,
	MATCH_MIDDLE_ONLY = 2,
	MATCH_END_ONLY = 3,
	MATCH_GLOB = 4,
	MATCH_INDEX = 5,
};

enum release_type {
	leaf_only = 0,
	whole_subtree = 1,
};

enum reloc_stage {
	MOVE_DATA_EXTENTS = 0,
	UPDATE_DATA_PTRS = 1,
};

enum report_header {
	HDR_32_BIT = 0,
	HDR_64_BIT = 1,
};

enum req_flag_bits {
	__REQ_FAILFAST_DEV = 8,
	__REQ_FAILFAST_TRANSPORT = 9,
	__REQ_FAILFAST_DRIVER = 10,
	__REQ_SYNC = 11,
	__REQ_META = 12,
	__REQ_PRIO = 13,
	__REQ_NOMERGE = 14,
	__REQ_IDLE = 15,
	__REQ_INTEGRITY = 16,
	__REQ_FUA = 17,
	__REQ_PREFLUSH = 18,
	__REQ_RAHEAD = 19,
	__REQ_BACKGROUND = 20,
	__REQ_NOWAIT = 21,
	__REQ_POLLED = 22,
	__REQ_ALLOC_CACHE = 23,
	__REQ_SWAP = 24,
	__REQ_DRV = 25,
	__REQ_FS_PRIVATE = 26,
	__REQ_ATOMIC = 27,
	__REQ_NOUNMAP = 28,
	__REQ_NR_BITS = 29,
};

enum req_op {
	REQ_OP_READ = 0,
	REQ_OP_WRITE = 1,
	REQ_OP_FLUSH = 2,
	REQ_OP_DISCARD = 3,
	REQ_OP_SECURE_ERASE = 5,
	REQ_OP_ZONE_APPEND = 7,
	REQ_OP_WRITE_ZEROES = 9,
	REQ_OP_ZONE_OPEN = 10,
	REQ_OP_ZONE_CLOSE = 11,
	REQ_OP_ZONE_FINISH = 12,
	REQ_OP_ZONE_RESET = 13,
	REQ_OP_ZONE_RESET_ALL = 15,
	REQ_OP_DRV_IN = 34,
	REQ_OP_DRV_OUT = 35,
	REQ_OP_LAST = 36,
};

enum resctrl_conf_type {
	CDP_NONE = 0,
	CDP_CODE = 1,
	CDP_DATA = 2,
};

enum reset_control_flags {
	RESET_CONTROL_EXCLUSIVE = 4,
	RESET_CONTROL_EXCLUSIVE_DEASSERTED = 12,
	RESET_CONTROL_EXCLUSIVE_RELEASED = 0,
	RESET_CONTROL_SHARED = 1,
	RESET_CONTROL_SHARED_DEASSERTED = 9,
	RESET_CONTROL_OPTIONAL_EXCLUSIVE = 6,
	RESET_CONTROL_OPTIONAL_EXCLUSIVE_DEASSERTED = 14,
	RESET_CONTROL_OPTIONAL_EXCLUSIVE_RELEASED = 2,
	RESET_CONTROL_OPTIONAL_SHARED = 3,
	RESET_CONTROL_OPTIONAL_SHARED_DEASSERTED = 11,
};

enum resolve_mode {
	RESOLVE_TBD = 0,
	RESOLVE_PTR = 1,
	RESOLVE_STRUCT_OR_ARRAY = 2,
};

enum retbleed_mitigation {
	RETBLEED_MITIGATION_NONE = 0,
	RETBLEED_MITIGATION_UNRET = 1,
	RETBLEED_MITIGATION_IBPB = 2,
	RETBLEED_MITIGATION_IBRS = 3,
	RETBLEED_MITIGATION_EIBRS = 4,
	RETBLEED_MITIGATION_STUFF = 5,
};

enum retbleed_mitigation_cmd {
	RETBLEED_CMD_OFF = 0,
	RETBLEED_CMD_AUTO = 1,
	RETBLEED_CMD_UNRET = 2,
	RETBLEED_CMD_IBPB = 3,
	RETBLEED_CMD_STUFF = 4,
};

enum retry_state {
	STATE_CONGESTED = 0,
	STATE_RESTART = 1,
	STATE_DONE = 2,
};

enum rfds_mitigations {
	RFDS_MITIGATION_OFF = 0,
	RFDS_MITIGATION_VERW = 1,
	RFDS_MITIGATION_UCODE_NEEDED = 2,
};

enum ring_buffer_flags {
	RB_FL_OVERWRITE = 1,
};

enum ring_buffer_type {
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING = 29,
	RINGBUF_TYPE_TIME_EXTEND = 30,
	RINGBUF_TYPE_TIME_STAMP = 31,
};

enum rlimit_type {
	UCOUNT_RLIMIT_NPROC = 0,
	UCOUNT_RLIMIT_MSGQUEUE = 1,
	UCOUNT_RLIMIT_SIGPENDING = 2,
	UCOUNT_RLIMIT_MEMLOCK = 3,
	UCOUNT_RLIMIT_COUNTS = 4,
};

enum rmap_level {
	RMAP_LEVEL_PTE = 0,
	RMAP_LEVEL_PMD = 1,
};

enum rmi_reg_state {
	RMI_REG_STATE_DEFAULT = 0,
	RMI_REG_STATE_OFF = 1,
	RMI_REG_STATE_ON = 2,
};

enum rmi_sensor_type {
	rmi_sensor_default = 0,
	rmi_sensor_touchscreen = 1,
	rmi_sensor_touchpad = 2,
};

enum rmp_flags {
	RMP_LOCKED = 1,
	RMP_USE_SHARED_ZEROPAGE = 2,
};

enum rp_check {
	RP_CHECK_CALL = 0,
	RP_CHECK_CHAIN_CALL = 1,
	RP_CHECK_RET = 2,
};

enum rpc_accept_stat {
	RPC_SUCCESS = 0,
	RPC_PROG_UNAVAIL = 1,
	RPC_PROG_MISMATCH = 2,
	RPC_PROC_UNAVAIL = 3,
	RPC_GARBAGE_ARGS = 4,
	RPC_SYSTEM_ERR = 5,
	RPC_DROP_REPLY = 60000,
};

enum rpc_auth_flavors {
	RPC_AUTH_NULL = 0,
	RPC_AUTH_UNIX = 1,
	RPC_AUTH_SHORT = 2,
	RPC_AUTH_DES = 3,
	RPC_AUTH_KRB = 4,
	RPC_AUTH_GSS = 6,
	RPC_AUTH_TLS = 7,
	RPC_AUTH_MAXFLAVOR = 8,
	RPC_AUTH_GSS_KRB5 = 390003,
	RPC_AUTH_GSS_KRB5I = 390004,
	RPC_AUTH_GSS_KRB5P = 390005,
	RPC_AUTH_GSS_LKEY = 390006,
	RPC_AUTH_GSS_LKEYI = 390007,
	RPC_AUTH_GSS_LKEYP = 390008,
	RPC_AUTH_GSS_SPKM = 390009,
	RPC_AUTH_GSS_SPKMI = 390010,
	RPC_AUTH_GSS_SPKMP = 390011,
};

enum rpc_auth_stat {
	RPC_AUTH_OK = 0,
	RPC_AUTH_BADCRED = 1,
	RPC_AUTH_REJECTEDCRED = 2,
	RPC_AUTH_BADVERF = 3,
	RPC_AUTH_REJECTEDVERF = 4,
	RPC_AUTH_TOOWEAK = 5,
	RPCSEC_GSS_CREDPROBLEM = 13,
	RPCSEC_GSS_CTXPROBLEM = 14,
};

enum rpc_display_format_t {
	RPC_DISPLAY_ADDR = 0,
	RPC_DISPLAY_PORT = 1,
	RPC_DISPLAY_PROTO = 2,
	RPC_DISPLAY_HEX_ADDR = 3,
	RPC_DISPLAY_HEX_PORT = 4,
	RPC_DISPLAY_NETID = 5,
	RPC_DISPLAY_MAX = 6,
};

enum rpc_gss_proc {
	RPC_GSS_PROC_DATA = 0,
	RPC_GSS_PROC_INIT = 1,
	RPC_GSS_PROC_CONTINUE_INIT = 2,
	RPC_GSS_PROC_DESTROY = 3,
};

enum rpc_gss_svc {
	RPC_GSS_SVC_NONE = 1,
	RPC_GSS_SVC_INTEGRITY = 2,
	RPC_GSS_SVC_PRIVACY = 3,
};

enum rpc_msg_type {
	RPC_CALL = 0,
	RPC_REPLY = 1,
};

enum rpc_reject_stat {
	RPC_MISMATCH = 0,
	RPC_AUTH_ERROR = 1,
};

enum rpc_reply_stat {
	RPC_MSG_ACCEPTED = 0,
	RPC_MSG_DENIED = 1,
};

enum rpm_request {
	RPM_REQ_NONE = 0,
	RPM_REQ_IDLE = 1,
	RPM_REQ_SUSPEND = 2,
	RPM_REQ_AUTOSUSPEND = 3,
	RPM_REQ_RESUME = 4,
};

enum rpm_status {
	RPM_INVALID = -1,
	RPM_ACTIVE = 0,
	RPM_RESUMING = 1,
	RPM_SUSPENDED = 2,
	RPM_SUSPENDING = 3,
};

enum rq_end_io_ret {
	RQ_END_IO_NONE = 0,
	RQ_END_IO_FREE = 1,
};

enum rq_qos_id {
	RQ_QOS_WBT = 0,
	RQ_QOS_LATENCY = 1,
	RQ_QOS_COST = 2,
};

enum rqf_flags {
	__RQF_STARTED = 0,
	__RQF_FLUSH_SEQ = 1,
	__RQF_MIXED_MERGE = 2,
	__RQF_DONTPREP = 3,
	__RQF_SCHED_TAGS = 4,
	__RQF_USE_SCHED = 5,
	__RQF_FAILED = 6,
	__RQF_QUIET = 7,
	__RQF_IO_STAT = 8,
	__RQF_PM = 9,
	__RQF_HASHED = 10,
	__RQF_STATS = 11,
	__RQF_SPECIAL_PAYLOAD = 12,
	__RQF_ZONE_WRITE_PLUGGING = 13,
	__RQF_TIMED_OUT = 14,
	__RQF_RESV = 15,
	__RQF_BITS = 16,
};

enum rsaprivkey_actions {
	ACT_rsa_get_d = 0,
	ACT_rsa_get_dp = 1,
	ACT_rsa_get_dq = 2,
	ACT_rsa_get_e = 3,
	ACT_rsa_get_n = 4,
	ACT_rsa_get_p = 5,
	ACT_rsa_get_q = 6,
	ACT_rsa_get_qinv = 7,
	NR__rsaprivkey_actions = 8,
};

enum rsapubkey_actions {
	ACT_rsa_get_e___2 = 0,
	ACT_rsa_get_n___2 = 1,
	NR__rsapubkey_actions = 2,
};

enum rseq_cpu_id_state {
	RSEQ_CPU_ID_UNINITIALIZED = -1,
	RSEQ_CPU_ID_REGISTRATION_FAILED = -2,
};

enum rseq_cs_flags {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL = 2,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE = 4,
};

enum rseq_cs_flags_bit {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

enum rseq_event_mask_bits {
	RSEQ_EVENT_PREEMPT_BIT = 0,
	RSEQ_EVENT_SIGNAL_BIT = 1,
	RSEQ_EVENT_MIGRATE_BIT = 2,
};

enum rseq_flags {
	RSEQ_FLAG_UNREGISTER = 1,
};

enum rt6_nud_state {
	RT6_NUD_FAIL_HARD = -3,
	RT6_NUD_FAIL_PROBE = -2,
	RT6_NUD_FAIL_DO_RR = -1,
	RT6_NUD_SUCCEED = 1,
};

enum rt_class_t {
	RT_TABLE_UNSPEC = 0,
	RT_TABLE_COMPAT = 252,
	RT_TABLE_DEFAULT = 253,
	RT_TABLE_MAIN = 254,
	RT_TABLE_LOCAL = 255,
	RT_TABLE_MAX = 4294967295,
};

enum rt_scope_t {
	RT_SCOPE_UNIVERSE = 0,
	RT_SCOPE_SITE = 200,
	RT_SCOPE_LINK = 253,
	RT_SCOPE_HOST = 254,
	RT_SCOPE_NOWHERE = 255,
};

enum rtattr_type_t {
	RTA_UNSPEC = 0,
	RTA_DST = 1,
	RTA_SRC = 2,
	RTA_IIF = 3,
	RTA_OIF = 4,
	RTA_GATEWAY = 5,
	RTA_PRIORITY = 6,
	RTA_PREFSRC = 7,
	RTA_METRICS = 8,
	RTA_MULTIPATH = 9,
	RTA_PROTOINFO = 10,
	RTA_FLOW = 11,
	RTA_CACHEINFO = 12,
	RTA_SESSION = 13,
	RTA_MP_ALGO = 14,
	RTA_TABLE = 15,
	RTA_MARK = 16,
	RTA_MFC_STATS = 17,
	RTA_VIA = 18,
	RTA_NEWDST = 19,
	RTA_PREF = 20,
	RTA_ENCAP_TYPE = 21,
	RTA_ENCAP = 22,
	RTA_EXPIRES = 23,
	RTA_PAD = 24,
	RTA_UID = 25,
	RTA_TTL_PROPAGATE = 26,
	RTA_IP_PROTO = 27,
	RTA_SPORT = 28,
	RTA_DPORT = 29,
	RTA_NH_ID = 30,
	RTA_FLOWLABEL = 31,
	__RTA_MAX = 32,
};

enum rtmutex_chainwalk {
	RT_MUTEX_MIN_CHAINWALK = 0,
	RT_MUTEX_FULL_CHAINWALK = 1,
};

enum rtnetlink_groups {
	RTNLGRP_NONE = 0,
	RTNLGRP_LINK = 1,
	RTNLGRP_NOTIFY = 2,
	RTNLGRP_NEIGH = 3,
	RTNLGRP_TC = 4,
	RTNLGRP_IPV4_IFADDR = 5,
	RTNLGRP_IPV4_MROUTE = 6,
	RTNLGRP_IPV4_ROUTE = 7,
	RTNLGRP_IPV4_RULE = 8,
	RTNLGRP_IPV6_IFADDR = 9,
	RTNLGRP_IPV6_MROUTE = 10,
	RTNLGRP_IPV6_ROUTE = 11,
	RTNLGRP_IPV6_IFINFO = 12,
	RTNLGRP_DECnet_IFADDR = 13,
	RTNLGRP_NOP2 = 14,
	RTNLGRP_DECnet_ROUTE = 15,
	RTNLGRP_DECnet_RULE = 16,
	RTNLGRP_NOP4 = 17,
	RTNLGRP_IPV6_PREFIX = 18,
	RTNLGRP_IPV6_RULE = 19,
	RTNLGRP_ND_USEROPT = 20,
	RTNLGRP_PHONET_IFADDR = 21,
	RTNLGRP_PHONET_ROUTE = 22,
	RTNLGRP_DCB = 23,
	RTNLGRP_IPV4_NETCONF = 24,
	RTNLGRP_IPV6_NETCONF = 25,
	RTNLGRP_MDB = 26,
	RTNLGRP_MPLS_ROUTE = 27,
	RTNLGRP_NSID = 28,
	RTNLGRP_MPLS_NETCONF = 29,
	RTNLGRP_IPV4_MROUTE_R = 30,
	RTNLGRP_IPV6_MROUTE_R = 31,
	RTNLGRP_NEXTHOP = 32,
	RTNLGRP_BRVLAN = 33,
	RTNLGRP_MCTP_IFADDR = 34,
	RTNLGRP_TUNNEL = 35,
	RTNLGRP_STATS = 36,
	RTNLGRP_IPV4_MCADDR = 37,
	RTNLGRP_IPV6_MCADDR = 38,
	RTNLGRP_IPV6_ACADDR = 39,
	__RTNLGRP_MAX = 40,
};

enum rtnl_kinds {
	RTNL_KIND_NEW = 0,
	RTNL_KIND_DEL = 1,
	RTNL_KIND_GET = 2,
	RTNL_KIND_SET = 3,
};

enum rtnl_link_flags {
	RTNL_FLAG_DOIT_UNLOCKED = 1,
	RTNL_FLAG_BULK_DEL_SUPPORTED = 2,
	RTNL_FLAG_DUMP_UNLOCKED = 4,
	RTNL_FLAG_DUMP_SPLIT_NLM_DONE = 8,
};

enum rw_hint {
	WRITE_LIFE_NOT_SET = 0,
	WRITE_LIFE_NONE = 1,
	WRITE_LIFE_SHORT = 2,
	WRITE_LIFE_MEDIUM = 3,
	WRITE_LIFE_LONG = 4,
	WRITE_LIFE_EXTREME = 5,
} __attribute__((mode(byte)));

enum rwsem_waiter_type {
	RWSEM_WAITING_FOR_WRITE = 0,
	RWSEM_WAITING_FOR_READ = 1,
};

enum rwsem_wake_type {
	RWSEM_WAKE_ANY = 0,
	RWSEM_WAKE_READERS = 1,
	RWSEM_WAKE_READ_OWNED = 2,
};

enum rx_handler_result {
	RX_HANDLER_CONSUMED = 0,
	RX_HANDLER_ANOTHER = 1,
	RX_HANDLER_EXACT = 2,
	RX_HANDLER_PASS = 3,
};

typedef enum rx_handler_result rx_handler_result_t;

enum s2idle_states {
	S2IDLE_STATE_NONE = 0,
	S2IDLE_STATE_ENTER = 1,
	S2IDLE_STATE_WAKE = 2,
};

enum s_alloc {
	sa_rootdomain = 0,
	sa_sd = 1,
	sa_sd_storage = 2,
	sa_none = 3,
};

enum sa_path_rec_type {
	SA_PATH_REC_TYPE_IB = 0,
	SA_PATH_REC_TYPE_ROCE_V1 = 1,
	SA_PATH_REC_TYPE_ROCE_V2 = 2,
	SA_PATH_REC_TYPE_OPA = 3,
};

enum sam_status {
	SAM_STAT_GOOD = 0,
	SAM_STAT_CHECK_CONDITION = 2,
	SAM_STAT_CONDITION_MET = 4,
	SAM_STAT_BUSY = 8,
	SAM_STAT_INTERMEDIATE = 16,
	SAM_STAT_INTERMEDIATE_CONDITION_MET = 20,
	SAM_STAT_RESERVATION_CONFLICT = 24,
	SAM_STAT_COMMAND_TERMINATED = 34,
	SAM_STAT_TASK_SET_FULL = 40,
	SAM_STAT_ACA_ACTIVE = 48,
	SAM_STAT_TASK_ABORTED = 64,
};

enum sane_state {
	SANE_STATE_NORMAL = 0,
	SANE_STATE_START_REQUESTED = 1,
};

enum scan_balance {
	SCAN_EQUAL = 0,
	SCAN_FRACT = 1,
	SCAN_ANON = 2,
	SCAN_FILE = 3,
};

enum sched_tunable_scaling {
	SCHED_TUNABLESCALING_NONE = 0,
	SCHED_TUNABLESCALING_LOG = 1,
	SCHED_TUNABLESCALING_LINEAR = 2,
	SCHED_TUNABLESCALING_END = 3,
};

enum scrub_stripe_flags {
	SCRUB_STRIPE_FLAG_INITIALIZED = 0,
	SCRUB_STRIPE_FLAG_REPAIR_DONE = 1,
	SCRUB_STRIPE_FLAG_NO_REPORT = 2,
};

enum scsi_cmnd_submitter {
	SUBMITTED_BY_BLOCK_LAYER = 0,
	SUBMITTED_BY_SCSI_ERROR_HANDLER = 1,
	SUBMITTED_BY_SCSI_RESET_IOCTL = 2,
} __attribute__((mode(byte)));

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE = 1,
	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
	SDEV_EVT_FIRST = 1,
	SDEV_EVT_LAST = 8,
	SDEV_EVT_MAXBITS = 9,
};

enum scsi_device_state {
	SDEV_CREATED = 1,
	SDEV_RUNNING = 2,
	SDEV_CANCEL = 3,
	SDEV_DEL = 4,
	SDEV_QUIESCE = 5,
	SDEV_OFFLINE = 6,
	SDEV_TRANSPORT_OFFLINE = 7,
	SDEV_BLOCK = 8,
	SDEV_CREATED_BLOCK = 9,
};

enum scsi_devinfo_key {
	SCSI_DEVINFO_GLOBAL = 0,
	SCSI_DEVINFO_SPI = 1,
};

enum scsi_disposition {
	NEEDS_RETRY = 8193,
	SUCCESS = 8194,
	FAILED = 8195,
	QUEUED = 8196,
	SOFT_ERROR = 8197,
	ADD_TO_MLQUEUE = 8198,
	TIMEOUT_ERROR = 8199,
	SCSI_RETURN_NOT_HANDLED = 8200,
	FAST_IO_FAIL = 8201,
};

enum scsi_host_prot_capabilities {
	SHOST_DIF_TYPE1_PROTECTION = 1,
	SHOST_DIF_TYPE2_PROTECTION = 2,
	SHOST_DIF_TYPE3_PROTECTION = 4,
	SHOST_DIX_TYPE0_PROTECTION = 8,
	SHOST_DIX_TYPE1_PROTECTION = 16,
	SHOST_DIX_TYPE2_PROTECTION = 32,
	SHOST_DIX_TYPE3_PROTECTION = 64,
};

enum scsi_host_state {
	SHOST_CREATED = 1,
	SHOST_RUNNING = 2,
	SHOST_CANCEL = 3,
	SHOST_DEL = 4,
	SHOST_RECOVERY = 5,
	SHOST_CANCEL_RECOVERY = 6,
	SHOST_DEL_RECOVERY = 7,
};

enum scsi_host_status {
	DID_OK = 0,
	DID_NO_CONNECT = 1,
	DID_BUS_BUSY = 2,
	DID_TIME_OUT = 3,
	DID_BAD_TARGET = 4,
	DID_ABORT = 5,
	DID_PARITY = 6,
	DID_ERROR = 7,
	DID_RESET = 8,
	DID_BAD_INTR = 9,
	DID_PASSTHROUGH = 10,
	DID_SOFT_ERROR = 11,
	DID_IMM_RETRY = 12,
	DID_REQUEUE = 13,
	DID_TRANSPORT_DISRUPTED = 14,
	DID_TRANSPORT_FAILFAST = 15,
	DID_TRANSPORT_MARGINAL = 20,
};

enum scsi_ml_status {
	SCSIML_STAT_OK = 0,
	SCSIML_STAT_RESV_CONFLICT = 1,
	SCSIML_STAT_NOSPC = 2,
	SCSIML_STAT_MED_ERROR = 3,
	SCSIML_STAT_TGT_FAILURE = 4,
	SCSIML_STAT_DL_TIMEOUT = 5,
};

enum scsi_msg_byte {
	COMMAND_COMPLETE = 0,
	EXTENDED_MESSAGE = 1,
	SAVE_POINTERS = 2,
	RESTORE_POINTERS = 3,
	DISCONNECT = 4,
	INITIATOR_ERROR = 5,
	ABORT_TASK_SET = 6,
	MESSAGE_REJECT = 7,
	NOP___2 = 8,
	MSG_PARITY_ERROR = 9,
	LINKED_CMD_COMPLETE = 10,
	LINKED_FLG_CMD_COMPLETE = 11,
	TARGET_RESET = 12,
	ABORT_TASK = 13,
	CLEAR_TASK_SET = 14,
	INITIATE_RECOVERY = 15,
	RELEASE_RECOVERY = 16,
	TERMINATE_IO_PROC = 17,
	CLEAR_ACA = 22,
	LOGICAL_UNIT_RESET = 23,
	SIMPLE_QUEUE_TAG = 32,
	HEAD_OF_QUEUE_TAG = 33,
	ORDERED_QUEUE_TAG = 34,
	IGNORE_WIDE_RESIDUE = 35,
	ACA = 36,
	QAS_REQUEST = 85,
	BUS_DEVICE_RESET = 12,
	ABORT = 6,
};

enum scsi_pr_type {
	SCSI_PR_WRITE_EXCLUSIVE = 1,
	SCSI_PR_EXCLUSIVE_ACCESS = 3,
	SCSI_PR_WRITE_EXCLUSIVE_REG_ONLY = 5,
	SCSI_PR_EXCLUSIVE_ACCESS_REG_ONLY = 6,
	SCSI_PR_WRITE_EXCLUSIVE_ALL_REGS = 7,
	SCSI_PR_EXCLUSIVE_ACCESS_ALL_REGS = 8,
};

enum scsi_prot_flags {
	SCSI_PROT_TRANSFER_PI = 1,
	SCSI_PROT_GUARD_CHECK = 2,
	SCSI_PROT_REF_CHECK = 4,
	SCSI_PROT_REF_INCREMENT = 8,
	SCSI_PROT_IP_CHECKSUM = 16,
};

enum scsi_prot_operations {
	SCSI_PROT_NORMAL = 0,
	SCSI_PROT_READ_INSERT = 1,
	SCSI_PROT_WRITE_STRIP = 2,
	SCSI_PROT_READ_STRIP = 3,
	SCSI_PROT_WRITE_INSERT = 4,
	SCSI_PROT_READ_PASS = 5,
	SCSI_PROT_WRITE_PASS = 6,
};

enum scsi_scan_mode {
	SCSI_SCAN_INITIAL = 0,
	SCSI_SCAN_RESCAN = 1,
	SCSI_SCAN_MANUAL = 2,
};

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING = 2,
	STARGET_REMOVE = 3,
	STARGET_CREATED_REMOVE = 4,
	STARGET_DEL = 5,
};

enum scsi_timeout_action {
	SCSI_EH_DONE = 0,
	SCSI_EH_RESET_TIMER = 1,
	SCSI_EH_NOT_HANDLED = 2,
};

enum scsi_timeouts {
	SCSI_DEFAULT_EH_TIMEOUT = 10000,
};

enum scsi_vpd_parameters {
	SCSI_VPD_HEADER_SIZE = 4,
	SCSI_VPD_LIST_SIZE = 36,
};

enum sctp_cid {
	SCTP_CID_DATA = 0,
	SCTP_CID_INIT = 1,
	SCTP_CID_INIT_ACK = 2,
	SCTP_CID_SACK = 3,
	SCTP_CID_HEARTBEAT = 4,
	SCTP_CID_HEARTBEAT_ACK = 5,
	SCTP_CID_ABORT = 6,
	SCTP_CID_SHUTDOWN = 7,
	SCTP_CID_SHUTDOWN_ACK = 8,
	SCTP_CID_ERROR = 9,
	SCTP_CID_COOKIE_ECHO = 10,
	SCTP_CID_COOKIE_ACK = 11,
	SCTP_CID_ECN_ECNE = 12,
	SCTP_CID_ECN_CWR = 13,
	SCTP_CID_SHUTDOWN_COMPLETE = 14,
	SCTP_CID_AUTH = 15,
	SCTP_CID_I_DATA = 64,
	SCTP_CID_FWD_TSN = 192,
	SCTP_CID_ASCONF = 193,
	SCTP_CID_I_FWD_TSN = 194,
	SCTP_CID_ASCONF_ACK = 128,
	SCTP_CID_RECONF = 130,
	SCTP_CID_PAD = 132,
};

enum sctp_cmsg_type {
	SCTP_INIT = 0,
	SCTP_SNDRCV = 1,
	SCTP_SNDINFO = 2,
	SCTP_RCVINFO = 3,
	SCTP_NXTINFO = 4,
	SCTP_PRINFO = 5,
	SCTP_AUTHINFO = 6,
	SCTP_DSTADDRV4 = 7,
	SCTP_DSTADDRV6 = 8,
};

enum sctp_conntrack {
	SCTP_CONNTRACK_NONE = 0,
	SCTP_CONNTRACK_CLOSED = 1,
	SCTP_CONNTRACK_COOKIE_WAIT = 2,
	SCTP_CONNTRACK_COOKIE_ECHOED = 3,
	SCTP_CONNTRACK_ESTABLISHED = 4,
	SCTP_CONNTRACK_SHUTDOWN_SENT = 5,
	SCTP_CONNTRACK_SHUTDOWN_RECD = 6,
	SCTP_CONNTRACK_SHUTDOWN_ACK_SENT = 7,
	SCTP_CONNTRACK_HEARTBEAT_SENT = 8,
	SCTP_CONNTRACK_HEARTBEAT_ACKED = 9,
	SCTP_CONNTRACK_MAX = 10,
};

enum sctp_disposition {
	SCTP_DISPOSITION_DISCARD = 0,
	SCTP_DISPOSITION_CONSUME = 1,
	SCTP_DISPOSITION_NOMEM = 2,
	SCTP_DISPOSITION_DELETE_TCB = 3,
	SCTP_DISPOSITION_ABORT = 4,
	SCTP_DISPOSITION_VIOLATION = 5,
	SCTP_DISPOSITION_NOT_IMPL = 6,
	SCTP_DISPOSITION_ERROR = 7,
	SCTP_DISPOSITION_BUG = 8,
};

enum sctp_endpoint_type {
	SCTP_EP_TYPE_SOCKET = 0,
	SCTP_EP_TYPE_ASSOCIATION = 1,
};

enum sctp_error {
	SCTP_ERROR_NO_ERROR = 0,
	SCTP_ERROR_INV_STRM = 256,
	SCTP_ERROR_MISS_PARAM = 512,
	SCTP_ERROR_STALE_COOKIE = 768,
	SCTP_ERROR_NO_RESOURCE = 1024,
	SCTP_ERROR_DNS_FAILED = 1280,
	SCTP_ERROR_UNKNOWN_CHUNK = 1536,
	SCTP_ERROR_INV_PARAM = 1792,
	SCTP_ERROR_UNKNOWN_PARAM = 2048,
	SCTP_ERROR_NO_DATA = 2304,
	SCTP_ERROR_COOKIE_IN_SHUTDOWN = 2560,
	SCTP_ERROR_RESTART = 2816,
	SCTP_ERROR_USER_ABORT = 3072,
	SCTP_ERROR_PROTO_VIOLATION = 3328,
	SCTP_ERROR_NEW_ENCAP_PORT = 3584,
	SCTP_ERROR_DEL_LAST_IP = 40960,
	SCTP_ERROR_RSRC_LOW = 41216,
	SCTP_ERROR_DEL_SRC_IP = 41472,
	SCTP_ERROR_ASCONF_ACK = 41728,
	SCTP_ERROR_REQ_REFUSED = 41984,
	SCTP_ERROR_UNSUP_HMAC = 1281,
};

enum sctp_event_other {
	SCTP_EVENT_NO_PENDING_TSN = 0,
	SCTP_EVENT_ICMP_PROTO_UNREACH = 1,
};

enum sctp_event_primitive {
	SCTP_PRIMITIVE_ASSOCIATE = 0,
	SCTP_PRIMITIVE_SHUTDOWN = 1,
	SCTP_PRIMITIVE_ABORT = 2,
	SCTP_PRIMITIVE_SEND = 3,
	SCTP_PRIMITIVE_REQUESTHEARTBEAT = 4,
	SCTP_PRIMITIVE_ASCONF = 5,
	SCTP_PRIMITIVE_RECONF = 6,
};

enum sctp_event_timeout {
	SCTP_EVENT_TIMEOUT_NONE = 0,
	SCTP_EVENT_TIMEOUT_T1_COOKIE = 1,
	SCTP_EVENT_TIMEOUT_T1_INIT = 2,
	SCTP_EVENT_TIMEOUT_T2_SHUTDOWN = 3,
	SCTP_EVENT_TIMEOUT_T3_RTX = 4,
	SCTP_EVENT_TIMEOUT_T4_RTO = 5,
	SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD = 6,
	SCTP_EVENT_TIMEOUT_HEARTBEAT = 7,
	SCTP_EVENT_TIMEOUT_RECONF = 8,
	SCTP_EVENT_TIMEOUT_PROBE = 9,
	SCTP_EVENT_TIMEOUT_SACK = 10,
	SCTP_EVENT_TIMEOUT_AUTOCLOSE = 11,
};

enum sctp_event_type {
	SCTP_EVENT_T_CHUNK = 1,
	SCTP_EVENT_T_TIMEOUT = 2,
	SCTP_EVENT_T_OTHER = 3,
	SCTP_EVENT_T_PRIMITIVE = 4,
};

enum sctp_ierror {
	SCTP_IERROR_NO_ERROR = 0,
	SCTP_IERROR_BASE = 1000,
	SCTP_IERROR_NO_COOKIE = 1001,
	SCTP_IERROR_BAD_SIG = 1002,
	SCTP_IERROR_STALE_COOKIE = 1003,
	SCTP_IERROR_NOMEM = 1004,
	SCTP_IERROR_MALFORMED = 1005,
	SCTP_IERROR_BAD_TAG = 1006,
	SCTP_IERROR_BIG_GAP = 1007,
	SCTP_IERROR_DUP_TSN = 1008,
	SCTP_IERROR_HIGH_TSN = 1009,
	SCTP_IERROR_IGNORE_TSN = 1010,
	SCTP_IERROR_NO_DATA = 1011,
	SCTP_IERROR_BAD_STREAM = 1012,
	SCTP_IERROR_BAD_PORTS = 1013,
	SCTP_IERROR_AUTH_BAD_HMAC = 1014,
	SCTP_IERROR_AUTH_BAD_KEYID = 1015,
	SCTP_IERROR_PROTO_VIOLATION = 1016,
	SCTP_IERROR_ERROR = 1017,
	SCTP_IERROR_ABORT = 1018,
};

enum sctp_lower_cwnd {
	SCTP_LOWER_CWND_T3_RTX = 0,
	SCTP_LOWER_CWND_FAST_RTX = 1,
	SCTP_LOWER_CWND_ECNE = 2,
	SCTP_LOWER_CWND_INACTIVE = 3,
};

enum sctp_msg_flags {
	MSG_NOTIFICATION = 32768,
};

enum sctp_param {
	SCTP_PARAM_HEARTBEAT_INFO = 256,
	SCTP_PARAM_IPV4_ADDRESS = 1280,
	SCTP_PARAM_IPV6_ADDRESS = 1536,
	SCTP_PARAM_STATE_COOKIE = 1792,
	SCTP_PARAM_UNRECOGNIZED_PARAMETERS = 2048,
	SCTP_PARAM_COOKIE_PRESERVATIVE = 2304,
	SCTP_PARAM_HOST_NAME_ADDRESS = 2816,
	SCTP_PARAM_SUPPORTED_ADDRESS_TYPES = 3072,
	SCTP_PARAM_ECN_CAPABLE = 128,
	SCTP_PARAM_RANDOM = 640,
	SCTP_PARAM_CHUNKS = 896,
	SCTP_PARAM_HMAC_ALGO = 1152,
	SCTP_PARAM_SUPPORTED_EXT = 2176,
	SCTP_PARAM_FWD_TSN_SUPPORT = 192,
	SCTP_PARAM_ADD_IP = 448,
	SCTP_PARAM_DEL_IP = 704,
	SCTP_PARAM_ERR_CAUSE = 960,
	SCTP_PARAM_SET_PRIMARY = 1216,
	SCTP_PARAM_SUCCESS_REPORT = 1472,
	SCTP_PARAM_ADAPTATION_LAYER_IND = 1728,
	SCTP_PARAM_RESET_OUT_REQUEST = 3328,
	SCTP_PARAM_RESET_IN_REQUEST = 3584,
	SCTP_PARAM_RESET_TSN_REQUEST = 3840,
	SCTP_PARAM_RESET_RESPONSE = 4096,
	SCTP_PARAM_RESET_ADD_OUT_STREAMS = 4352,
	SCTP_PARAM_RESET_ADD_IN_STREAMS = 4608,
};

enum sctp_plpmtud_state {
	SCTP_PL_DISABLED = 0,
	SCTP_PL_BASE = 1,
	SCTP_PL_SEARCH = 2,
	SCTP_PL_COMPLETE = 3,
	SCTP_PL_ERROR = 4,
};

enum sctp_retransmit_reason {
	SCTP_RTXR_T3_RTX = 0,
	SCTP_RTXR_FAST_RTX = 1,
	SCTP_RTXR_PMTUD = 2,
	SCTP_RTXR_T1_RTX = 3,
};

enum sctp_sac_state {
	SCTP_COMM_UP = 0,
	SCTP_COMM_LOST = 1,
	SCTP_RESTART = 2,
	SCTP_SHUTDOWN_COMP = 3,
	SCTP_CANT_STR_ASSOC = 4,
};

enum sctp_sched_type {
	SCTP_SS_FCFS = 0,
	SCTP_SS_DEFAULT = 0,
	SCTP_SS_PRIO = 1,
	SCTP_SS_RR = 2,
	SCTP_SS_FC = 3,
	SCTP_SS_WFQ = 4,
	SCTP_SS_MAX = 4,
};

enum sctp_scope {
	SCTP_SCOPE_GLOBAL = 0,
	SCTP_SCOPE_PRIVATE = 1,
	SCTP_SCOPE_LINK = 2,
	SCTP_SCOPE_LOOPBACK = 3,
	SCTP_SCOPE_UNUSABLE = 4,
};

enum sctp_sinfo_flags {
	SCTP_UNORDERED = 1,
	SCTP_ADDR_OVER = 2,
	SCTP_ABORT = 4,
	SCTP_SACK_IMMEDIATELY = 8,
	SCTP_SENDALL = 64,
	SCTP_PR_SCTP_ALL = 128,
	SCTP_NOTIFICATION = 32768,
	SCTP_EOF = 512,
};

enum sctp_sn_error {
	SCTP_FAILED_THRESHOLD = 0,
	SCTP_RECEIVED_SACK = 1,
	SCTP_HEARTBEAT_SUCCESS = 2,
	SCTP_RESPONSE_TO_USER_REQ = 3,
	SCTP_INTERNAL_ERROR = 4,
	SCTP_SHUTDOWN_GUARD_EXPIRES = 5,
	SCTP_PEER_FAULTY = 6,
};

typedef enum sctp_sn_error sctp_sn_error_t;

enum sctp_sn_type {
	SCTP_SN_TYPE_BASE = 32768,
	SCTP_DATA_IO_EVENT = 32768,
	SCTP_ASSOC_CHANGE = 32769,
	SCTP_PEER_ADDR_CHANGE = 32770,
	SCTP_SEND_FAILED = 32771,
	SCTP_REMOTE_ERROR = 32772,
	SCTP_SHUTDOWN_EVENT = 32773,
	SCTP_PARTIAL_DELIVERY_EVENT = 32774,
	SCTP_ADAPTATION_INDICATION = 32775,
	SCTP_AUTHENTICATION_EVENT = 32776,
	SCTP_SENDER_DRY_EVENT = 32777,
	SCTP_STREAM_RESET_EVENT = 32778,
	SCTP_ASSOC_RESET_EVENT = 32779,
	SCTP_STREAM_CHANGE_EVENT = 32780,
	SCTP_SEND_FAILED_EVENT = 32781,
	SCTP_SN_TYPE_MAX = 32781,
};

enum sctp_sock_state {
	SCTP_SS_CLOSED = 7,
	SCTP_SS_LISTENING = 10,
	SCTP_SS_ESTABLISHING = 2,
	SCTP_SS_ESTABLISHED = 1,
	SCTP_SS_CLOSING = 8,
};

enum sctp_socket_type {
	SCTP_SOCKET_UDP = 0,
	SCTP_SOCKET_UDP_HIGH_BANDWIDTH = 1,
	SCTP_SOCKET_TCP = 2,
};

enum sctp_spc_state {
	SCTP_ADDR_AVAILABLE = 0,
	SCTP_ADDR_UNREACHABLE = 1,
	SCTP_ADDR_REMOVED = 2,
	SCTP_ADDR_ADDED = 3,
	SCTP_ADDR_MADE_PRIM = 4,
	SCTP_ADDR_CONFIRMED = 5,
	SCTP_ADDR_POTENTIALLY_FAILED = 6,
};

enum sctp_spinfo_state {
	SCTP_INACTIVE = 0,
	SCTP_PF = 1,
	SCTP_ACTIVE = 2,
	SCTP_UNCONFIRMED = 3,
	SCTP_UNKNOWN = 65535,
};

enum sctp_spp_flags {
	SPP_HB_ENABLE = 1,
	SPP_HB_DISABLE = 2,
	SPP_HB = 3,
	SPP_HB_DEMAND = 4,
	SPP_PMTUD_ENABLE = 8,
	SPP_PMTUD_DISABLE = 16,
	SPP_PMTUD = 24,
	SPP_SACKDELAY_ENABLE = 32,
	SPP_SACKDELAY_DISABLE = 64,
	SPP_SACKDELAY = 96,
	SPP_HB_TIME_IS_ZERO = 128,
	SPP_IPV6_FLOWLABEL = 256,
	SPP_DSCP = 512,
};

enum sctp_ssf_flags {
	SCTP_DATA_UNSENT = 0,
	SCTP_DATA_SENT = 1,
};

enum sctp_sstat_state {
	SCTP_EMPTY = 0,
	SCTP_CLOSED = 1,
	SCTP_COOKIE_WAIT = 2,
	SCTP_COOKIE_ECHOED = 3,
	SCTP_ESTABLISHED = 4,
	SCTP_SHUTDOWN_PENDING = 5,
	SCTP_SHUTDOWN_SENT = 6,
	SCTP_SHUTDOWN_RECEIVED = 7,
	SCTP_SHUTDOWN_ACK_SENT = 8,
};

enum sctp_state {
	SCTP_STATE_CLOSED = 0,
	SCTP_STATE_COOKIE_WAIT = 1,
	SCTP_STATE_COOKIE_ECHOED = 2,
	SCTP_STATE_ESTABLISHED = 3,
	SCTP_STATE_SHUTDOWN_PENDING = 4,
	SCTP_STATE_SHUTDOWN_SENT = 5,
	SCTP_STATE_SHUTDOWN_RECEIVED = 6,
	SCTP_STATE_SHUTDOWN_ACK_SENT = 7,
};

enum sctp_transport_cmd {
	SCTP_TRANSPORT_UP = 0,
	SCTP_TRANSPORT_DOWN = 1,
	SCTP_TRANSPORT_PF = 2,
};

enum sctp_verb {
	SCTP_CMD_NOP = 0,
	SCTP_CMD_NEW_ASOC = 1,
	SCTP_CMD_DELETE_TCB = 2,
	SCTP_CMD_NEW_STATE = 3,
	SCTP_CMD_REPORT_TSN = 4,
	SCTP_CMD_GEN_SACK = 5,
	SCTP_CMD_PROCESS_SACK = 6,
	SCTP_CMD_GEN_INIT_ACK = 7,
	SCTP_CMD_PEER_INIT = 8,
	SCTP_CMD_GEN_COOKIE_ECHO = 9,
	SCTP_CMD_CHUNK_ULP = 10,
	SCTP_CMD_EVENT_ULP = 11,
	SCTP_CMD_REPLY = 12,
	SCTP_CMD_SEND_PKT = 13,
	SCTP_CMD_RETRAN = 14,
	SCTP_CMD_ECN_CE = 15,
	SCTP_CMD_ECN_ECNE = 16,
	SCTP_CMD_ECN_CWR = 17,
	SCTP_CMD_TIMER_START = 18,
	SCTP_CMD_TIMER_START_ONCE = 19,
	SCTP_CMD_TIMER_RESTART = 20,
	SCTP_CMD_TIMER_STOP = 21,
	SCTP_CMD_INIT_CHOOSE_TRANSPORT = 22,
	SCTP_CMD_INIT_COUNTER_RESET = 23,
	SCTP_CMD_INIT_COUNTER_INC = 24,
	SCTP_CMD_INIT_RESTART = 25,
	SCTP_CMD_COOKIEECHO_RESTART = 26,
	SCTP_CMD_INIT_FAILED = 27,
	SCTP_CMD_REPORT_DUP = 28,
	SCTP_CMD_STRIKE = 29,
	SCTP_CMD_HB_TIMERS_START = 30,
	SCTP_CMD_HB_TIMER_UPDATE = 31,
	SCTP_CMD_HB_TIMERS_STOP = 32,
	SCTP_CMD_PROBE_TIMER_UPDATE = 33,
	SCTP_CMD_TRANSPORT_HB_SENT = 34,
	SCTP_CMD_TRANSPORT_IDLE = 35,
	SCTP_CMD_TRANSPORT_ON = 36,
	SCTP_CMD_REPORT_ERROR = 37,
	SCTP_CMD_REPORT_BAD_TAG = 38,
	SCTP_CMD_PROCESS_CTSN = 39,
	SCTP_CMD_ASSOC_FAILED = 40,
	SCTP_CMD_DISCARD_PACKET = 41,
	SCTP_CMD_GEN_SHUTDOWN = 42,
	SCTP_CMD_PURGE_OUTQUEUE = 43,
	SCTP_CMD_SETUP_T2 = 44,
	SCTP_CMD_RTO_PENDING = 45,
	SCTP_CMD_PART_DELIVER = 46,
	SCTP_CMD_RENEGE = 47,
	SCTP_CMD_SETUP_T4 = 48,
	SCTP_CMD_PROCESS_OPERR = 49,
	SCTP_CMD_REPORT_FWDTSN = 50,
	SCTP_CMD_PROCESS_FWDTSN = 51,
	SCTP_CMD_CLEAR_INIT_TAG = 52,
	SCTP_CMD_DEL_NON_PRIMARY = 53,
	SCTP_CMD_T3_RTX_TIMERS_STOP = 54,
	SCTP_CMD_FORCE_PRIM_RETRAN = 55,
	SCTP_CMD_SET_SK_ERR = 56,
	SCTP_CMD_ASSOC_CHANGE = 57,
	SCTP_CMD_ADAPTATION_IND = 58,
	SCTP_CMD_PEER_NO_AUTH = 59,
	SCTP_CMD_ASSOC_SHKEY = 60,
	SCTP_CMD_T1_RETRAN = 61,
	SCTP_CMD_UPDATE_INITTAG = 62,
	SCTP_CMD_SEND_MSG = 63,
	SCTP_CMD_PURGE_ASCONF_QUEUE = 64,
	SCTP_CMD_SET_ASOC = 65,
	SCTP_CMD_LAST = 66,
};

enum sctp_xmit {
	SCTP_XMIT_OK = 0,
	SCTP_XMIT_PMTU_FULL = 1,
	SCTP_XMIT_RWND_FULL = 2,
	SCTP_XMIT_DELAY = 3,
};

enum sdp_header_types {
	SDP_HDR_UNSPEC = 0,
	SDP_HDR_VERSION = 1,
	SDP_HDR_OWNER = 2,
	SDP_HDR_CONNECTION = 3,
	SDP_HDR_MEDIA = 4,
};

enum seg6_end_dt_mode {
	DT_INVALID_MODE = -22,
	DT_LEGACY_MODE = 0,
	DT_VRF_MODE = 1,
};

enum seg6_local_flv_action {
	SEG6_LOCAL_FLV_ACT_UNSPEC = 0,
	SEG6_LOCAL_FLV_ACT_END = 1,
	SEG6_LOCAL_FLV_ACT_PSP = 2,
	SEG6_LOCAL_FLV_ACT_USP = 3,
	SEG6_LOCAL_FLV_ACT_USD = 4,
	__SEG6_LOCAL_FLV_ACT_MAX = 5,
};

enum seg6_local_pktinfo {
	SEG6_LOCAL_PKTINFO_NOHDR = 0,
	SEG6_LOCAL_PKTINFO_SL_ZERO = 1,
	SEG6_LOCAL_PKTINFO_SL_ONE = 2,
	SEG6_LOCAL_PKTINFO_SL_MORE = 3,
	__SEG6_LOCAL_PKTINFO_MAX = 4,
};

enum ser {
	SER_REQUIRED = 1,
	NO_SER = 2,
};

enum serio_event_type {
	SERIO_RESCAN_PORT = 0,
	SERIO_RECONNECT_PORT = 1,
	SERIO_RECONNECT_SUBTREE = 2,
	SERIO_REGISTER_PORT = 3,
	SERIO_ATTACH_DRIVER = 4,
};

enum set_event_iter_type {
	SET_EVENT_FILE = 0,
	SET_EVENT_MOD = 1,
};

enum severity_level {
	MCE_NO_SEVERITY = 0,
	MCE_DEFERRED_SEVERITY = 1,
	MCE_UCNA_SEVERITY = 1,
	MCE_KEEP_SEVERITY = 2,
	MCE_SOME_SEVERITY = 3,
	MCE_AO_SEVERITY = 4,
	MCE_UC_SEVERITY = 5,
	MCE_AR_SEVERITY = 6,
	MCE_PANIC_SEVERITY = 7,
};

enum sgp_type {
	SGP_READ = 0,
	SGP_NOALLOC = 1,
	SGP_CACHE = 2,
	SGP_WRITE = 3,
	SGP_FALLOC = 4,
};

enum shmem_param {
	Opt_gid___10 = 0,
	Opt_huge = 1,
	Opt_mode___7 = 2,
	Opt_mpol = 3,
	Opt_nr_blocks = 4,
	Opt_nr_inodes___2 = 5,
	Opt_size___2 = 6,
	Opt_uid___9 = 7,
	Opt_inode32___2 = 8,
	Opt_inode64___2 = 9,
	Opt_noswap = 10,
	Opt_quota___3 = 11,
	Opt_usrquota___3 = 12,
	Opt_grpquota___3 = 13,
	Opt_usrquota_block_hardlimit = 14,
	Opt_usrquota_inode_hardlimit = 15,
	Opt_grpquota_block_hardlimit = 16,
	Opt_grpquota_inode_hardlimit = 17,
	Opt_casefold_version = 18,
	Opt_casefold = 19,
	Opt_strict_encoding = 20,
};

enum show_regs_mode {
	SHOW_REGS_SHORT = 0,
	SHOW_REGS_USER = 1,
	SHOW_REGS_ALL = 2,
};

enum sig_handler {
	HANDLER_CURRENT = 0,
	HANDLER_SIG_DFL = 1,
	HANDLER_EXIT = 2,
};

enum siginfo_layout {
	SIL_KILL = 0,
	SIL_TIMER = 1,
	SIL_POLL = 2,
	SIL_FAULT = 3,
	SIL_FAULT_TRAPNO = 4,
	SIL_FAULT_MCEERR = 5,
	SIL_FAULT_BNDERR = 6,
	SIL_FAULT_PKUERR = 7,
	SIL_FAULT_PERF_EVENT = 8,
	SIL_CHLD = 9,
	SIL_RT = 10,
	SIL_SYS = 11,
};

enum sip_expectation_classes {
	SIP_EXPECT_SIGNALLING = 0,
	SIP_EXPECT_AUDIO = 1,
	SIP_EXPECT_VIDEO = 2,
	SIP_EXPECT_IMAGE = 3,
	__SIP_EXPECT_MAX = 4,
};

enum sip_header_types {
	SIP_HDR_CSEQ = 0,
	SIP_HDR_FROM = 1,
	SIP_HDR_TO = 2,
	SIP_HDR_CONTACT = 3,
	SIP_HDR_VIA_UDP = 4,
	SIP_HDR_VIA_TCP = 5,
	SIP_HDR_EXPIRES = 6,
	SIP_HDR_CONTENT_LENGTH = 7,
	SIP_HDR_CALL_ID = 8,
};

enum sk_action {
	SK_DROP = 0,
	SK_PASS = 1,
};

enum sk_pacing {
	SK_PACING_NONE = 0,
	SK_PACING_NEEDED = 1,
	SK_PACING_FQ = 2,
};

enum sk_psock_state_bits {
	SK_PSOCK_TX_ENABLED = 0,
	SK_PSOCK_RX_STRP_ENABLED = 1,
};

enum sk_rst_reason {
	SK_RST_REASON_NOT_SPECIFIED = 0,
	SK_RST_REASON_NO_SOCKET = 1,
	SK_RST_REASON_TCP_INVALID_ACK_SEQUENCE = 2,
	SK_RST_REASON_TCP_RFC7323_PAWS = 3,
	SK_RST_REASON_TCP_TOO_OLD_ACK = 4,
	SK_RST_REASON_TCP_ACK_UNSENT_DATA = 5,
	SK_RST_REASON_TCP_FLAGS = 6,
	SK_RST_REASON_TCP_OLD_ACK = 7,
	SK_RST_REASON_TCP_ABORT_ON_DATA = 8,
	SK_RST_REASON_TCP_TIMEWAIT_SOCKET = 9,
	SK_RST_REASON_INVALID_SYN = 10,
	SK_RST_REASON_TCP_ABORT_ON_CLOSE = 11,
	SK_RST_REASON_TCP_ABORT_ON_LINGER = 12,
	SK_RST_REASON_TCP_ABORT_ON_MEMORY = 13,
	SK_RST_REASON_TCP_STATE = 14,
	SK_RST_REASON_TCP_KEEPALIVE_TIMEOUT = 15,
	SK_RST_REASON_TCP_DISCONNECT_WITH_DATA = 16,
	SK_RST_REASON_MPTCP_RST_EUNSPEC = 17,
	SK_RST_REASON_MPTCP_RST_EMPTCP = 18,
	SK_RST_REASON_MPTCP_RST_ERESOURCE = 19,
	SK_RST_REASON_MPTCP_RST_EPROHIBIT = 20,
	SK_RST_REASON_MPTCP_RST_EWQ2BIG = 21,
	SK_RST_REASON_MPTCP_RST_EBADPERF = 22,
	SK_RST_REASON_MPTCP_RST_EMIDDLEBOX = 23,
	SK_RST_REASON_ERROR = 24,
	SK_RST_REASON_MAX = 25,
};

enum skb_drop_reason {
	SKB_NOT_DROPPED_YET = 0,
	SKB_CONSUMED = 1,
	SKB_DROP_REASON_NOT_SPECIFIED = 2,
	SKB_DROP_REASON_NO_SOCKET = 3,
	SKB_DROP_REASON_SOCKET_CLOSE = 4,
	SKB_DROP_REASON_SOCKET_FILTER = 5,
	SKB_DROP_REASON_SOCKET_RCVBUFF = 6,
	SKB_DROP_REASON_UNIX_DISCONNECT = 7,
	SKB_DROP_REASON_UNIX_SKIP_OOB = 8,
	SKB_DROP_REASON_PKT_TOO_SMALL = 9,
	SKB_DROP_REASON_TCP_CSUM = 10,
	SKB_DROP_REASON_UDP_CSUM = 11,
	SKB_DROP_REASON_NETFILTER_DROP = 12,
	SKB_DROP_REASON_OTHERHOST = 13,
	SKB_DROP_REASON_IP_CSUM = 14,
	SKB_DROP_REASON_IP_INHDR = 15,
	SKB_DROP_REASON_IP_RPFILTER = 16,
	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST = 17,
	SKB_DROP_REASON_XFRM_POLICY = 18,
	SKB_DROP_REASON_IP_NOPROTO = 19,
	SKB_DROP_REASON_PROTO_MEM = 20,
	SKB_DROP_REASON_TCP_AUTH_HDR = 21,
	SKB_DROP_REASON_TCP_MD5NOTFOUND = 22,
	SKB_DROP_REASON_TCP_MD5UNEXPECTED = 23,
	SKB_DROP_REASON_TCP_MD5FAILURE = 24,
	SKB_DROP_REASON_TCP_AONOTFOUND = 25,
	SKB_DROP_REASON_TCP_AOUNEXPECTED = 26,
	SKB_DROP_REASON_TCP_AOKEYNOTFOUND = 27,
	SKB_DROP_REASON_TCP_AOFAILURE = 28,
	SKB_DROP_REASON_SOCKET_BACKLOG = 29,
	SKB_DROP_REASON_TCP_FLAGS = 30,
	SKB_DROP_REASON_TCP_ABORT_ON_DATA = 31,
	SKB_DROP_REASON_TCP_ZEROWINDOW = 32,
	SKB_DROP_REASON_TCP_OLD_DATA = 33,
	SKB_DROP_REASON_TCP_OVERWINDOW = 34,
	SKB_DROP_REASON_TCP_OFOMERGE = 35,
	SKB_DROP_REASON_TCP_RFC7323_PAWS = 36,
	SKB_DROP_REASON_TCP_RFC7323_PAWS_ACK = 37,
	SKB_DROP_REASON_TCP_OLD_SEQUENCE = 38,
	SKB_DROP_REASON_TCP_INVALID_SEQUENCE = 39,
	SKB_DROP_REASON_TCP_INVALID_ACK_SEQUENCE = 40,
	SKB_DROP_REASON_TCP_RESET = 41,
	SKB_DROP_REASON_TCP_INVALID_SYN = 42,
	SKB_DROP_REASON_TCP_CLOSE = 43,
	SKB_DROP_REASON_TCP_FASTOPEN = 44,
	SKB_DROP_REASON_TCP_OLD_ACK = 45,
	SKB_DROP_REASON_TCP_TOO_OLD_ACK = 46,
	SKB_DROP_REASON_TCP_ACK_UNSENT_DATA = 47,
	SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE = 48,
	SKB_DROP_REASON_TCP_OFO_DROP = 49,
	SKB_DROP_REASON_IP_OUTNOROUTES = 50,
	SKB_DROP_REASON_BPF_CGROUP_EGRESS = 51,
	SKB_DROP_REASON_IPV6DISABLED = 52,
	SKB_DROP_REASON_NEIGH_CREATEFAIL = 53,
	SKB_DROP_REASON_NEIGH_FAILED = 54,
	SKB_DROP_REASON_NEIGH_QUEUEFULL = 55,
	SKB_DROP_REASON_NEIGH_DEAD = 56,
	SKB_DROP_REASON_TC_EGRESS = 57,
	SKB_DROP_REASON_SECURITY_HOOK = 58,
	SKB_DROP_REASON_QDISC_DROP = 59,
	SKB_DROP_REASON_QDISC_OVERLIMIT = 60,
	SKB_DROP_REASON_QDISC_CONGESTED = 61,
	SKB_DROP_REASON_CAKE_FLOOD = 62,
	SKB_DROP_REASON_FQ_BAND_LIMIT = 63,
	SKB_DROP_REASON_FQ_HORIZON_LIMIT = 64,
	SKB_DROP_REASON_FQ_FLOW_LIMIT = 65,
	SKB_DROP_REASON_CPU_BACKLOG = 66,
	SKB_DROP_REASON_XDP = 67,
	SKB_DROP_REASON_TC_INGRESS = 68,
	SKB_DROP_REASON_UNHANDLED_PROTO = 69,
	SKB_DROP_REASON_SKB_CSUM = 70,
	SKB_DROP_REASON_SKB_GSO_SEG = 71,
	SKB_DROP_REASON_SKB_UCOPY_FAULT = 72,
	SKB_DROP_REASON_DEV_HDR = 73,
	SKB_DROP_REASON_DEV_READY = 74,
	SKB_DROP_REASON_FULL_RING = 75,
	SKB_DROP_REASON_NOMEM = 76,
	SKB_DROP_REASON_HDR_TRUNC = 77,
	SKB_DROP_REASON_TAP_FILTER = 78,
	SKB_DROP_REASON_TAP_TXFILTER = 79,
	SKB_DROP_REASON_ICMP_CSUM = 80,
	SKB_DROP_REASON_INVALID_PROTO = 81,
	SKB_DROP_REASON_IP_INADDRERRORS = 82,
	SKB_DROP_REASON_IP_INNOROUTES = 83,
	SKB_DROP_REASON_IP_LOCAL_SOURCE = 84,
	SKB_DROP_REASON_IP_INVALID_SOURCE = 85,
	SKB_DROP_REASON_IP_LOCALNET = 86,
	SKB_DROP_REASON_IP_INVALID_DEST = 87,
	SKB_DROP_REASON_PKT_TOO_BIG = 88,
	SKB_DROP_REASON_DUP_FRAG = 89,
	SKB_DROP_REASON_FRAG_REASM_TIMEOUT = 90,
	SKB_DROP_REASON_FRAG_TOO_FAR = 91,
	SKB_DROP_REASON_TCP_MINTTL = 92,
	SKB_DROP_REASON_IPV6_BAD_EXTHDR = 93,
	SKB_DROP_REASON_IPV6_NDISC_FRAG = 94,
	SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT = 95,
	SKB_DROP_REASON_IPV6_NDISC_BAD_CODE = 96,
	SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS = 97,
	SKB_DROP_REASON_IPV6_NDISC_NS_OTHERHOST = 98,
	SKB_DROP_REASON_QUEUE_PURGE = 99,
	SKB_DROP_REASON_TC_COOKIE_ERROR = 100,
	SKB_DROP_REASON_PACKET_SOCK_ERROR = 101,
	SKB_DROP_REASON_TC_CHAIN_NOTFOUND = 102,
	SKB_DROP_REASON_TC_RECLASSIFY_LOOP = 103,
	SKB_DROP_REASON_VXLAN_INVALID_HDR = 104,
	SKB_DROP_REASON_VXLAN_VNI_NOT_FOUND = 105,
	SKB_DROP_REASON_MAC_INVALID_SOURCE = 106,
	SKB_DROP_REASON_VXLAN_ENTRY_EXISTS = 107,
	SKB_DROP_REASON_NO_TX_TARGET = 108,
	SKB_DROP_REASON_IP_TUNNEL_ECN = 109,
	SKB_DROP_REASON_TUNNEL_TXINFO = 110,
	SKB_DROP_REASON_LOCAL_MAC = 111,
	SKB_DROP_REASON_ARP_PVLAN_DISABLE = 112,
	SKB_DROP_REASON_MAC_IEEE_MAC_CONTROL = 113,
	SKB_DROP_REASON_BRIDGE_INGRESS_STP_STATE = 114,
	SKB_DROP_REASON_MAX = 115,
	SKB_DROP_REASON_SUBSYS_MASK = 4294901760,
};

enum skb_drop_reason_subsys {
	SKB_DROP_REASON_SUBSYS_CORE = 0,
	SKB_DROP_REASON_SUBSYS_MAC80211_UNUSABLE = 1,
	SKB_DROP_REASON_SUBSYS_MAC80211_MONITOR = 2,
	SKB_DROP_REASON_SUBSYS_OPENVSWITCH = 3,
	SKB_DROP_REASON_SUBSYS_NUM = 4,
};

enum skb_ext_id {
	SKB_EXT_BRIDGE_NF = 0,
	SKB_EXT_SEC_PATH = 1,
	TC_SKB_EXT = 2,
	SKB_EXT_MPTCP = 3,
	SKB_EXT_NUM = 4,
};

enum skb_tstamp_type {
	SKB_CLOCK_REALTIME = 0,
	SKB_CLOCK_MONOTONIC = 1,
	SKB_CLOCK_TAI = 2,
	__SKB_CLOCK_MAX = 2,
};

enum skl_power_gate {
	SKL_PG0 = 0,
	SKL_PG1 = 1,
	SKL_PG2 = 2,
	ICL_PG3 = 3,
	ICL_PG4 = 4,
};

enum sknetlink_groups {
	SKNLGRP_NONE = 0,
	SKNLGRP_INET_TCP_DESTROY = 1,
	SKNLGRP_INET_UDP_DESTROY = 2,
	SKNLGRP_INET6_TCP_DESTROY = 3,
	SKNLGRP_INET6_UDP_DESTROY = 4,
	__SKNLGRP_MAX = 5,
};

enum slab_stat_type {
	SL_ALL = 0,
	SL_PARTIAL = 1,
	SL_CPU = 2,
	SL_OBJECTS = 3,
	SL_TOTAL = 4,
};

enum slab_state {
	DOWN = 0,
	PARTIAL = 1,
	UP = 2,
	FULL = 3,
};

enum slpc_event_id {
	SLPC_EVENT_RESET = 0,
	SLPC_EVENT_SHUTDOWN = 1,
	SLPC_EVENT_PLATFORM_INFO_CHANGE = 2,
	SLPC_EVENT_DISPLAY_MODE_CHANGE = 3,
	SLPC_EVENT_FLIP_COMPLETE = 4,
	SLPC_EVENT_QUERY_TASK_STATE = 5,
	SLPC_EVENT_PARAMETER_SET = 6,
	SLPC_EVENT_PARAMETER_UNSET = 7,
};

enum slpc_global_state {
	SLPC_GLOBAL_STATE_NOT_RUNNING = 0,
	SLPC_GLOBAL_STATE_INITIALIZING = 1,
	SLPC_GLOBAL_STATE_RESETTING = 2,
	SLPC_GLOBAL_STATE_RUNNING = 3,
	SLPC_GLOBAL_STATE_SHUTTING_DOWN = 4,
	SLPC_GLOBAL_STATE_ERROR = 5,
};

enum slpc_media_ratio_mode {
	SLPC_MEDIA_RATIO_MODE_DYNAMIC_CONTROL = 0,
	SLPC_MEDIA_RATIO_MODE_FIXED_ONE_TO_ONE = 1,
	SLPC_MEDIA_RATIO_MODE_FIXED_ONE_TO_TWO = 2,
};

enum slpc_param_id {
	SLPC_PARAM_TASK_ENABLE_GTPERF = 0,
	SLPC_PARAM_TASK_DISABLE_GTPERF = 1,
	SLPC_PARAM_TASK_ENABLE_BALANCER = 2,
	SLPC_PARAM_TASK_DISABLE_BALANCER = 3,
	SLPC_PARAM_TASK_ENABLE_DCC = 4,
	SLPC_PARAM_TASK_DISABLE_DCC = 5,
	SLPC_PARAM_GLOBAL_MIN_GT_UNSLICE_FREQ_MHZ = 6,
	SLPC_PARAM_GLOBAL_MAX_GT_UNSLICE_FREQ_MHZ = 7,
	SLPC_PARAM_GLOBAL_MIN_GT_SLICE_FREQ_MHZ = 8,
	SLPC_PARAM_GLOBAL_MAX_GT_SLICE_FREQ_MHZ = 9,
	SLPC_PARAM_GTPERF_THRESHOLD_MAX_FPS = 10,
	SLPC_PARAM_GLOBAL_DISABLE_GT_FREQ_MANAGEMENT = 11,
	SLPC_PARAM_GTPERF_ENABLE_FRAMERATE_STALLING = 12,
	SLPC_PARAM_GLOBAL_DISABLE_RC6_MODE_CHANGE = 13,
	SLPC_PARAM_GLOBAL_OC_UNSLICE_FREQ_MHZ = 14,
	SLPC_PARAM_GLOBAL_OC_SLICE_FREQ_MHZ = 15,
	SLPC_PARAM_GLOBAL_ENABLE_IA_GT_BALANCING = 16,
	SLPC_PARAM_GLOBAL_ENABLE_ADAPTIVE_BURST_TURBO = 17,
	SLPC_PARAM_GLOBAL_ENABLE_EVAL_MODE = 18,
	SLPC_PARAM_GLOBAL_ENABLE_BALANCER_IN_NON_GAMING_MODE = 19,
	SLPC_PARAM_GLOBAL_RT_MODE_TURBO_FREQ_DELTA_MHZ = 20,
	SLPC_PARAM_PWRGATE_RC_MODE = 21,
	SLPC_PARAM_EDR_MODE_COMPUTE_TIMEOUT_MS = 22,
	SLPC_PARAM_EDR_QOS_FREQ_MHZ = 23,
	SLPC_PARAM_MEDIA_FF_RATIO_MODE = 24,
	SLPC_PARAM_ENABLE_IA_FREQ_LIMITING = 25,
	SLPC_PARAM_STRATEGIES = 26,
	SLPC_PARAM_POWER_PROFILE = 27,
	SLPC_PARAM_IGNORE_EFFICIENT_FREQUENCY = 28,
	SLPC_MAX_PARAM = 32,
};

enum smbios_attr_enum {
	SMBIOS_ATTR_NONE = 0,
	SMBIOS_ATTR_LABEL_SHOW = 1,
	SMBIOS_ATTR_INSTANCE_SHOW = 2,
};

enum smca_bank_types {
	SMCA_LS = 0,
	SMCA_LS_V2 = 1,
	SMCA_IF = 2,
	SMCA_L2_CACHE = 3,
	SMCA_DE = 4,
	SMCA_RESERVED = 5,
	SMCA_EX = 6,
	SMCA_FP = 7,
	SMCA_L3_CACHE = 8,
	SMCA_CS = 9,
	SMCA_CS_V2 = 10,
	SMCA_PIE = 11,
	SMCA_UMC = 12,
	SMCA_UMC_V2 = 13,
	SMCA_MA_LLC = 14,
	SMCA_PB = 15,
	SMCA_PSP = 16,
	SMCA_PSP_V2 = 17,
	SMCA_SMU = 18,
	SMCA_SMU_V2 = 19,
	SMCA_MP5 = 20,
	SMCA_MPDMA = 21,
	SMCA_NBIO = 22,
	SMCA_PCIE = 23,
	SMCA_PCIE_V2 = 24,
	SMCA_XGMI_PCS = 25,
	SMCA_NBIF = 26,
	SMCA_SHUB = 27,
	SMCA_SATA = 28,
	SMCA_USB = 29,
	SMCA_USR_DP = 30,
	SMCA_USR_CP = 31,
	SMCA_GMI_PCS = 32,
	SMCA_XGMI_PHY = 33,
	SMCA_WAFL_PHY = 34,
	SMCA_GMI_PHY = 35,
	N_SMCA_BANK_TYPES = 36,
};

enum sock_flags {
	SOCK_DEAD = 0,
	SOCK_DONE = 1,
	SOCK_URGINLINE = 2,
	SOCK_KEEPOPEN = 3,
	SOCK_LINGER = 4,
	SOCK_DESTROY = 5,
	SOCK_BROADCAST = 6,
	SOCK_TIMESTAMP = 7,
	SOCK_ZAPPED = 8,
	SOCK_USE_WRITE_QUEUE = 9,
	SOCK_DBG = 10,
	SOCK_RCVTSTAMP = 11,
	SOCK_RCVTSTAMPNS = 12,
	SOCK_LOCALROUTE = 13,
	SOCK_MEMALLOC = 14,
	SOCK_TIMESTAMPING_RX_SOFTWARE = 15,
	SOCK_FASYNC = 16,
	SOCK_RXQ_OVFL = 17,
	SOCK_ZEROCOPY = 18,
	SOCK_WIFI_STATUS = 19,
	SOCK_NOFCS = 20,
	SOCK_FILTER_LOCKED = 21,
	SOCK_SELECT_ERR_QUEUE = 22,
	SOCK_RCU_FREE = 23,
	SOCK_TXTIME = 24,
	SOCK_XDP = 25,
	SOCK_TSTAMP_NEW = 26,
	SOCK_RCVMARK = 27,
	SOCK_RCVPRIORITY = 28,
};

enum sock_shutdown_cmd {
	SHUT_RD = 0,
	SHUT_WR = 1,
	SHUT_RDWR = 2,
};

enum sock_type {
	SOCK_STREAM = 1,
	SOCK_DGRAM = 2,
	SOCK_RAW = 3,
	SOCK_RDM = 4,
	SOCK_SEQPACKET = 5,
	SOCK_DCCP = 6,
	SOCK_PACKET = 10,
};

enum special_kfunc_type {
	KF_bpf_obj_new_impl = 0,
	KF_bpf_obj_drop_impl = 1,
	KF_bpf_refcount_acquire_impl = 2,
	KF_bpf_list_push_front_impl = 3,
	KF_bpf_list_push_back_impl = 4,
	KF_bpf_list_pop_front = 5,
	KF_bpf_list_pop_back = 6,
	KF_bpf_cast_to_kern_ctx = 7,
	KF_bpf_rdonly_cast = 8,
	KF_bpf_rcu_read_lock = 9,
	KF_bpf_rcu_read_unlock = 10,
	KF_bpf_rbtree_remove = 11,
	KF_bpf_rbtree_add_impl = 12,
	KF_bpf_rbtree_first = 13,
	KF_bpf_dynptr_from_skb = 14,
	KF_bpf_dynptr_from_xdp = 15,
	KF_bpf_dynptr_slice = 16,
	KF_bpf_dynptr_slice_rdwr = 17,
	KF_bpf_dynptr_clone = 18,
	KF_bpf_percpu_obj_new_impl = 19,
	KF_bpf_percpu_obj_drop_impl = 20,
	KF_bpf_throw = 21,
	KF_bpf_wq_set_callback_impl = 22,
	KF_bpf_preempt_disable = 23,
	KF_bpf_preempt_enable = 24,
	KF_bpf_iter_css_task_new = 25,
	KF_bpf_session_cookie = 26,
	KF_bpf_get_kmem_cache = 27,
	KF_bpf_local_irq_save = 28,
	KF_bpf_local_irq_restore = 29,
	KF_bpf_iter_num_new = 30,
	KF_bpf_iter_num_next = 31,
	KF_bpf_iter_num_destroy = 32,
};

enum spectre_v1_mitigation {
	SPECTRE_V1_MITIGATION_NONE = 0,
	SPECTRE_V1_MITIGATION_AUTO = 1,
};

enum spectre_v2_mitigation {
	SPECTRE_V2_NONE = 0,
	SPECTRE_V2_RETPOLINE = 1,
	SPECTRE_V2_LFENCE = 2,
	SPECTRE_V2_EIBRS = 3,
	SPECTRE_V2_EIBRS_RETPOLINE = 4,
	SPECTRE_V2_EIBRS_LFENCE = 5,
	SPECTRE_V2_IBRS = 6,
};

enum spectre_v2_mitigation_cmd {
	SPECTRE_V2_CMD_NONE = 0,
	SPECTRE_V2_CMD_AUTO = 1,
	SPECTRE_V2_CMD_FORCE = 2,
	SPECTRE_V2_CMD_RETPOLINE = 3,
	SPECTRE_V2_CMD_RETPOLINE_GENERIC = 4,
	SPECTRE_V2_CMD_RETPOLINE_LFENCE = 5,
	SPECTRE_V2_CMD_EIBRS = 6,
	SPECTRE_V2_CMD_EIBRS_RETPOLINE = 7,
	SPECTRE_V2_CMD_EIBRS_LFENCE = 8,
	SPECTRE_V2_CMD_IBRS = 9,
};

enum spectre_v2_user_cmd {
	SPECTRE_V2_USER_CMD_NONE = 0,
	SPECTRE_V2_USER_CMD_AUTO = 1,
	SPECTRE_V2_USER_CMD_FORCE = 2,
	SPECTRE_V2_USER_CMD_PRCTL = 3,
	SPECTRE_V2_USER_CMD_PRCTL_IBPB = 4,
	SPECTRE_V2_USER_CMD_SECCOMP = 5,
	SPECTRE_V2_USER_CMD_SECCOMP_IBPB = 6,
};

enum spectre_v2_user_mitigation {
	SPECTRE_V2_USER_NONE = 0,
	SPECTRE_V2_USER_STRICT = 1,
	SPECTRE_V2_USER_STRICT_PREFERRED = 2,
	SPECTRE_V2_USER_PRCTL = 3,
	SPECTRE_V2_USER_SECCOMP = 4,
};

enum spi_compare_returns {
	SPI_COMPARE_SUCCESS = 0,
	SPI_COMPARE_FAILURE = 1,
	SPI_COMPARE_SKIP_TEST = 2,
};

enum spi_signal_type {
	SPI_SIGNAL_UNKNOWN = 1,
	SPI_SIGNAL_SE = 2,
	SPI_SIGNAL_LVD = 3,
	SPI_SIGNAL_HVD = 4,
};

enum split_lock_detect_state {
	sld_off = 0,
	sld_warn = 1,
	sld_fatal = 2,
	sld_ratelimit = 3,
};

enum srbds_mitigations {
	SRBDS_MITIGATION_OFF = 0,
	SRBDS_MITIGATION_UCODE_NEEDED = 1,
	SRBDS_MITIGATION_FULL = 2,
	SRBDS_MITIGATION_TSX_OFF = 3,
	SRBDS_MITIGATION_HYPERVISOR = 4,
};

enum srso_mitigation {
	SRSO_MITIGATION_NONE = 0,
	SRSO_MITIGATION_UCODE_NEEDED = 1,
	SRSO_MITIGATION_SAFE_RET_UCODE_NEEDED = 2,
	SRSO_MITIGATION_MICROCODE = 3,
	SRSO_MITIGATION_SAFE_RET = 4,
	SRSO_MITIGATION_IBPB = 5,
	SRSO_MITIGATION_IBPB_ON_VMEXIT = 6,
};

enum srso_mitigation_cmd {
	SRSO_CMD_OFF = 0,
	SRSO_CMD_MICROCODE = 1,
	SRSO_CMD_SAFE_RET = 2,
	SRSO_CMD_IBPB = 3,
	SRSO_CMD_IBPB_ON_VMEXIT = 4,
};

enum ssb_mitigation {
	SPEC_STORE_BYPASS_NONE = 0,
	SPEC_STORE_BYPASS_DISABLE = 1,
	SPEC_STORE_BYPASS_PRCTL = 2,
	SPEC_STORE_BYPASS_SECCOMP = 3,
};

enum ssb_mitigation_cmd {
	SPEC_STORE_BYPASS_CMD_NONE = 0,
	SPEC_STORE_BYPASS_CMD_AUTO = 1,
	SPEC_STORE_BYPASS_CMD_ON = 2,
	SPEC_STORE_BYPASS_CMD_PRCTL = 3,
	SPEC_STORE_BYPASS_CMD_SECCOMP = 4,
};

enum stack_type {
	STACK_TYPE_UNKNOWN = 0,
	STACK_TYPE_TASK = 1,
	STACK_TYPE_IRQ = 2,
	STACK_TYPE_SOFTIRQ = 3,
	STACK_TYPE_ENTRY = 4,
	STACK_TYPE_EXCEPTION = 5,
	STACK_TYPE_EXCEPTION_LAST = 10,
};

enum stat_group {
	STAT_READ = 0,
	STAT_WRITE = 1,
	STAT_DISCARD = 2,
	STAT_FLUSH = 3,
	NR_STAT_GROUPS = 4,
};

enum stat_item {
	ALLOC_FASTPATH = 0,
	ALLOC_SLOWPATH = 1,
	FREE_FASTPATH = 2,
	FREE_SLOWPATH = 3,
	FREE_FROZEN = 4,
	FREE_ADD_PARTIAL = 5,
	FREE_REMOVE_PARTIAL = 6,
	ALLOC_FROM_PARTIAL = 7,
	ALLOC_SLAB = 8,
	ALLOC_REFILL = 9,
	ALLOC_NODE_MISMATCH = 10,
	FREE_SLAB = 11,
	CPUSLAB_FLUSH = 12,
	DEACTIVATE_FULL = 13,
	DEACTIVATE_EMPTY = 14,
	DEACTIVATE_TO_HEAD = 15,
	DEACTIVATE_TO_TAIL = 16,
	DEACTIVATE_REMOTE_FREES = 17,
	DEACTIVATE_BYPASS = 18,
	ORDER_FALLBACK = 19,
	CMPXCHG_DOUBLE_CPU_FAIL = 20,
	CMPXCHG_DOUBLE_FAIL = 21,
	CPU_PARTIAL_ALLOC = 22,
	CPU_PARTIAL_FREE = 23,
	CPU_PARTIAL_NODE = 24,
	CPU_PARTIAL_DRAIN = 25,
	NR_SLUB_STAT_ITEMS = 26,
};

enum state {
	Start = 0,
	Collect = 1,
	GotHeader = 2,
	SkipIt = 3,
	GotName = 4,
	CopyFile = 5,
	GotSymlink = 6,
	Reset = 7,
};

enum store_type {
	wr_invalid = 0,
	wr_new_root = 1,
	wr_store_root = 2,
	wr_exact_fit = 3,
	wr_spanning_store = 4,
	wr_split_store = 5,
	wr_rebalance = 6,
	wr_append = 7,
	wr_node_store = 8,
	wr_slot_store = 9,
};

enum string_size_units {
	STRING_UNITS_10 = 0,
	STRING_UNITS_2 = 1,
	STRING_UNITS_MASK = 1,
	STRING_UNITS_NO_SPACE = 1073741824,
	STRING_UNITS_NO_BYTES = 2147483648,
};

enum subpixel_order {
	SubPixelUnknown = 0,
	SubPixelHorizontalRGB = 1,
	SubPixelHorizontalBGR = 2,
	SubPixelVerticalRGB = 3,
	SubPixelVerticalBGR = 4,
	SubPixelNone = 5,
};

enum sum_check_bits {
	SUM_CHECK_P = 0,
	SUM_CHECK_Q = 1,
};

enum sum_check_flags {
	SUM_CHECK_P_RESULT = 1,
	SUM_CHECK_Q_RESULT = 2,
};

enum support_mode {
	ALLOW_LEGACY = 0,
	DENY_LEGACY = 1,
};

enum suspend_mode {
	PRESUSPEND = 0,
	PRESUSPEND_UNDO = 1,
	POSTSUSPEND = 2,
};

enum suspend_stat_step {
	SUSPEND_WORKING = 0,
	SUSPEND_FREEZE = 1,
	SUSPEND_PREPARE = 2,
	SUSPEND_SUSPEND = 3,
	SUSPEND_SUSPEND_LATE = 4,
	SUSPEND_SUSPEND_NOIRQ = 5,
	SUSPEND_RESUME_NOIRQ = 6,
	SUSPEND_RESUME_EARLY = 7,
	SUSPEND_RESUME = 8,
};

enum svc_auth_status {
	SVC_GARBAGE = 1,
	SVC_SYSERR = 2,
	SVC_VALID = 3,
	SVC_NEGATIVE = 4,
	SVC_OK = 5,
	SVC_DROP = 6,
	SVC_CLOSE = 7,
	SVC_DENIED = 8,
	SVC_PENDING = 9,
	SVC_COMPLETE = 10,
};

enum sw_flow_mac_proto {
	MAC_PROTO_NONE = 0,
	MAC_PROTO_ETHERNET = 1,
};

enum swap_cluster_flags {
	CLUSTER_FLAG_NONE = 0,
	CLUSTER_FLAG_FREE = 1,
	CLUSTER_FLAG_NONFULL = 2,
	CLUSTER_FLAG_FRAG = 3,
	CLUSTER_FLAG_USABLE = 3,
	CLUSTER_FLAG_FULL = 4,
	CLUSTER_FLAG_DISCARD = 5,
	CLUSTER_FLAG_MAX = 6,
};

enum switch_power_state {
	DRM_SWITCH_POWER_ON = 0,
	DRM_SWITCH_POWER_OFF = 1,
	DRM_SWITCH_POWER_CHANGING = 2,
	DRM_SWITCH_POWER_DYNAMIC_OFF = 3,
};

enum switchdev_attr_id {
	SWITCHDEV_ATTR_ID_UNDEFINED = 0,
	SWITCHDEV_ATTR_ID_PORT_STP_STATE = 1,
	SWITCHDEV_ATTR_ID_PORT_MST_STATE = 2,
	SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS = 3,
	SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS = 4,
	SWITCHDEV_ATTR_ID_PORT_MROUTER = 5,
	SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME = 6,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING = 7,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL = 8,
	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED = 9,
	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER = 10,
	SWITCHDEV_ATTR_ID_BRIDGE_MST = 11,
	SWITCHDEV_ATTR_ID_MRP_PORT_ROLE = 12,
	SWITCHDEV_ATTR_ID_VLAN_MSTI = 13,
};

enum switchdev_notifier_type {
	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
	SWITCHDEV_FDB_DEL_TO_BRIDGE = 2,
	SWITCHDEV_FDB_ADD_TO_DEVICE = 3,
	SWITCHDEV_FDB_DEL_TO_DEVICE = 4,
	SWITCHDEV_FDB_OFFLOADED = 5,
	SWITCHDEV_FDB_FLUSH_TO_BRIDGE = 6,
	SWITCHDEV_PORT_OBJ_ADD = 7,
	SWITCHDEV_PORT_OBJ_DEL = 8,
	SWITCHDEV_PORT_ATTR_SET = 9,
	SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE = 10,
	SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE = 11,
	SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE = 12,
	SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE = 13,
	SWITCHDEV_VXLAN_FDB_OFFLOADED = 14,
	SWITCHDEV_BRPORT_OFFLOADED = 15,
	SWITCHDEV_BRPORT_UNOFFLOADED = 16,
	SWITCHDEV_BRPORT_REPLAY = 17,
};

enum switchdev_obj_id {
	SWITCHDEV_OBJ_ID_UNDEFINED = 0,
	SWITCHDEV_OBJ_ID_PORT_VLAN = 1,
	SWITCHDEV_OBJ_ID_PORT_MDB = 2,
	SWITCHDEV_OBJ_ID_HOST_MDB = 3,
	SWITCHDEV_OBJ_ID_MRP = 4,
	SWITCHDEV_OBJ_ID_RING_TEST_MRP = 5,
	SWITCHDEV_OBJ_ID_RING_ROLE_MRP = 6,
	SWITCHDEV_OBJ_ID_RING_STATE_MRP = 7,
	SWITCHDEV_OBJ_ID_IN_TEST_MRP = 8,
	SWITCHDEV_OBJ_ID_IN_ROLE_MRP = 9,
	SWITCHDEV_OBJ_ID_IN_STATE_MRP = 10,
};

enum synaptics_pkt_type {
	SYN_NEWABS = 0,
	SYN_NEWABS_STRICT = 1,
	SYN_NEWABS_RELAXED = 2,
	SYN_OLDABS = 3,
};

enum sync {
	DEFAULTSYNC = 0,
	NOSYNC = 1,
	FORCESYNC = 2,
};

enum sync_action {
	ACTION_RESYNC = 0,
	ACTION_RECOVER = 1,
	ACTION_CHECK = 2,
	ACTION_REPAIR = 3,
	ACTION_RESHAPE = 4,
	ACTION_FROZEN = 5,
	ACTION_IDLE = 6,
	NR_SYNC_ACTIONS = 7,
};

enum sys_off_mode {
	SYS_OFF_MODE_POWER_OFF_PREPARE = 0,
	SYS_OFF_MODE_POWER_OFF = 1,
	SYS_OFF_MODE_RESTART_PREPARE = 2,
	SYS_OFF_MODE_RESTART = 3,
};

enum syscall_work_bit {
	SYSCALL_WORK_BIT_SECCOMP = 0,
	SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT = 1,
	SYSCALL_WORK_BIT_SYSCALL_TRACE = 2,
	SYSCALL_WORK_BIT_SYSCALL_EMU = 3,
	SYSCALL_WORK_BIT_SYSCALL_AUDIT = 4,
	SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH = 5,
	SYSCALL_WORK_BIT_SYSCALL_EXIT_TRAP = 6,
};

enum sysctl_writes_mode {
	SYSCTL_WRITES_LEGACY = -1,
	SYSCTL_WRITES_WARN = 0,
	SYSCTL_WRITES_STRICT = 1,
};

enum system_states {
	SYSTEM_BOOTING = 0,
	SYSTEM_SCHEDULING = 1,
	SYSTEM_FREEING_INITMEM = 2,
	SYSTEM_RUNNING = 3,
	SYSTEM_HALT = 4,
	SYSTEM_POWER_OFF = 5,
	SYSTEM_RESTART = 6,
	SYSTEM_SUSPEND = 7,
};

enum t10_dif_type {
	T10_PI_TYPE0_PROTECTION = 0,
	T10_PI_TYPE1_PROTECTION = 1,
	T10_PI_TYPE2_PROTECTION = 2,
	T10_PI_TYPE3_PROTECTION = 3,
};

enum taa_mitigations {
	TAA_MITIGATION_OFF = 0,
	TAA_MITIGATION_UCODE_NEEDED = 1,
	TAA_MITIGATION_VERW = 2,
	TAA_MITIGATION_TSX_DISABLED = 3,
};

enum task_work_notify_mode {
	TWA_NONE = 0,
	TWA_RESUME = 1,
	TWA_SIGNAL = 2,
	TWA_SIGNAL_NO_IPI = 3,
	TWA_NMI_CURRENT = 4,
};

enum tc_clsbpf_command {
	TC_CLSBPF_OFFLOAD = 0,
	TC_CLSBPF_STATS = 1,
};

enum tc_clsu32_command {
	TC_CLSU32_NEW_KNODE = 0,
	TC_CLSU32_REPLACE_KNODE = 1,
	TC_CLSU32_DELETE_KNODE = 2,
	TC_CLSU32_NEW_HNODE = 3,
	TC_CLSU32_REPLACE_HNODE = 4,
	TC_CLSU32_DELETE_HNODE = 5,
};

enum tc_ets_command {
	TC_ETS_REPLACE = 0,
	TC_ETS_DESTROY = 1,
	TC_ETS_STATS = 2,
	TC_ETS_GRAFT = 3,
};

enum tc_fifo_command {
	TC_FIFO_REPLACE = 0,
	TC_FIFO_DESTROY = 1,
	TC_FIFO_STATS = 2,
};

enum tc_gred_command {
	TC_GRED_REPLACE = 0,
	TC_GRED_DESTROY = 1,
	TC_GRED_STATS = 2,
};

enum tc_htb_command {
	TC_HTB_CREATE = 0,
	TC_HTB_DESTROY = 1,
	TC_HTB_LEAF_ALLOC_QUEUE = 2,
	TC_HTB_LEAF_TO_INNER = 3,
	TC_HTB_LEAF_DEL = 4,
	TC_HTB_LEAF_DEL_LAST = 5,
	TC_HTB_LEAF_DEL_LAST_FORCE = 6,
	TC_HTB_NODE_MODIFY = 7,
	TC_HTB_LEAF_QUERY_QUEUE = 8,
};

enum tc_link_layer {
	TC_LINKLAYER_UNAWARE = 0,
	TC_LINKLAYER_ETHERNET = 1,
	TC_LINKLAYER_ATM = 2,
};

enum tc_matchall_command {
	TC_CLSMATCHALL_REPLACE = 0,
	TC_CLSMATCHALL_DESTROY = 1,
	TC_CLSMATCHALL_STATS = 2,
};

enum tc_mq_command {
	TC_MQ_CREATE = 0,
	TC_MQ_DESTROY = 1,
	TC_MQ_STATS = 2,
	TC_MQ_GRAFT = 3,
};

enum tc_port {
	TC_PORT_NONE = -1,
	TC_PORT_1 = 0,
	TC_PORT_2 = 1,
	TC_PORT_3 = 2,
	TC_PORT_4 = 3,
	TC_PORT_5 = 4,
	TC_PORT_6 = 5,
	I915_MAX_TC_PORTS = 6,
};

enum tc_port_mode {
	TC_PORT_DISCONNECTED = 0,
	TC_PORT_TBT_ALT = 1,
	TC_PORT_DP_ALT = 2,
	TC_PORT_LEGACY = 3,
};

enum tc_prio_command {
	TC_PRIO_REPLACE = 0,
	TC_PRIO_DESTROY = 1,
	TC_PRIO_STATS = 2,
	TC_PRIO_GRAFT = 3,
};

enum tc_red_command {
	TC_RED_REPLACE = 0,
	TC_RED_DESTROY = 1,
	TC_RED_STATS = 2,
	TC_RED_XSTATS = 3,
	TC_RED_GRAFT = 4,
};

enum tc_root_command {
	TC_ROOT_GRAFT = 0,
};

enum tc_setup_type {
	TC_QUERY_CAPS = 0,
	TC_SETUP_QDISC_MQPRIO = 1,
	TC_SETUP_CLSU32 = 2,
	TC_SETUP_CLSFLOWER = 3,
	TC_SETUP_CLSMATCHALL = 4,
	TC_SETUP_CLSBPF = 5,
	TC_SETUP_BLOCK = 6,
	TC_SETUP_QDISC_CBS = 7,
	TC_SETUP_QDISC_RED = 8,
	TC_SETUP_QDISC_PRIO = 9,
	TC_SETUP_QDISC_MQ = 10,
	TC_SETUP_QDISC_ETF = 11,
	TC_SETUP_ROOT_QDISC = 12,
	TC_SETUP_QDISC_GRED = 13,
	TC_SETUP_QDISC_TAPRIO = 14,
	TC_SETUP_FT = 15,
	TC_SETUP_QDISC_ETS = 16,
	TC_SETUP_QDISC_TBF = 17,
	TC_SETUP_QDISC_FIFO = 18,
	TC_SETUP_QDISC_HTB = 19,
	TC_SETUP_ACT = 20,
};

enum tc_taprio_qopt_cmd {
	TAPRIO_CMD_REPLACE = 0,
	TAPRIO_CMD_DESTROY = 1,
	TAPRIO_CMD_STATS = 2,
	TAPRIO_CMD_QUEUE_STATS = 3,
};

enum tc_tbf_command {
	TC_TBF_REPLACE = 0,
	TC_TBF_DESTROY = 1,
	TC_TBF_STATS = 2,
	TC_TBF_GRAFT = 3,
};

enum tca_id {
	TCA_ID_UNSPEC = 0,
	TCA_ID_POLICE = 1,
	TCA_ID_GACT = 5,
	TCA_ID_IPT = 6,
	TCA_ID_PEDIT = 7,
	TCA_ID_MIRRED = 8,
	TCA_ID_NAT = 9,
	TCA_ID_XT = 10,
	TCA_ID_SKBEDIT = 11,
	TCA_ID_VLAN = 12,
	TCA_ID_BPF = 13,
	TCA_ID_CONNMARK = 14,
	TCA_ID_SKBMOD = 15,
	TCA_ID_CSUM = 16,
	TCA_ID_TUNNEL_KEY = 17,
	TCA_ID_SIMP = 22,
	TCA_ID_IFE = 25,
	TCA_ID_SAMPLE = 26,
	TCA_ID_CTINFO = 27,
	TCA_ID_MPLS = 28,
	TCA_ID_CT = 29,
	TCA_ID_GATE = 30,
	__TCA_ID_MAX = 255,
};

enum tcf_proto_ops_flags {
	TCF_PROTO_OPS_DOIT_UNLOCKED = 1,
};

enum tcp_bit_set {
	TCP_SYN_SET = 0,
	TCP_SYNACK_SET = 1,
	TCP_FIN_SET = 2,
	TCP_ACK_SET = 3,
	TCP_RST_SET = 4,
	TCP_NONE_SET = 5,
};

enum tcp_ca_ack_event_flags {
	CA_ACK_SLOWPATH = 1,
	CA_ACK_WIN_UPDATE = 2,
	CA_ACK_ECE = 4,
};

enum tcp_ca_event {
	CA_EVENT_TX_START = 0,
	CA_EVENT_CWND_RESTART = 1,
	CA_EVENT_COMPLETE_CWR = 2,
	CA_EVENT_LOSS = 3,
	CA_EVENT_ECN_NO_CE = 4,
	CA_EVENT_ECN_IS_CE = 5,
};

enum tcp_ca_state {
	TCP_CA_Open = 0,
	TCP_CA_Disorder = 1,
	TCP_CA_CWR = 2,
	TCP_CA_Recovery = 3,
	TCP_CA_Loss = 4,
};

enum tcp_chrono {
	TCP_CHRONO_UNSPEC = 0,
	TCP_CHRONO_BUSY = 1,
	TCP_CHRONO_RWND_LIMITED = 2,
	TCP_CHRONO_SNDBUF_LIMITED = 3,
	__TCP_CHRONO_MAX = 4,
};

enum tcp_conntrack {
	TCP_CONNTRACK_NONE = 0,
	TCP_CONNTRACK_SYN_SENT = 1,
	TCP_CONNTRACK_SYN_RECV = 2,
	TCP_CONNTRACK_ESTABLISHED = 3,
	TCP_CONNTRACK_FIN_WAIT = 4,
	TCP_CONNTRACK_CLOSE_WAIT = 5,
	TCP_CONNTRACK_LAST_ACK = 6,
	TCP_CONNTRACK_TIME_WAIT = 7,
	TCP_CONNTRACK_CLOSE = 8,
	TCP_CONNTRACK_LISTEN = 9,
	TCP_CONNTRACK_MAX = 10,
	TCP_CONNTRACK_IGNORE = 11,
	TCP_CONNTRACK_RETRANS = 12,
	TCP_CONNTRACK_UNACK = 13,
	TCP_CONNTRACK_TIMEOUT_MAX = 14,
};

enum tcp_fastopen_client_fail {
	TFO_STATUS_UNSPEC = 0,
	TFO_COOKIE_UNAVAILABLE = 1,
	TFO_DATA_NOT_ACKED = 2,
	TFO_SYN_RETRANSMITTED = 3,
};

enum tcp_lp_state {
	LP_VALID_RHZ = 1,
	LP_VALID_OWD = 2,
	LP_WITHIN_THR = 8,
	LP_WITHIN_INF = 16,
};

enum tcp_metric_index {
	TCP_METRIC_RTT = 0,
	TCP_METRIC_RTTVAR = 1,
	TCP_METRIC_SSTHRESH = 2,
	TCP_METRIC_CWND = 3,
	TCP_METRIC_REORDERING = 4,
	TCP_METRIC_RTT_US = 5,
	TCP_METRIC_RTTVAR_US = 6,
	__TCP_METRIC_MAX = 7,
};

enum tcp_queue {
	TCP_FRAG_IN_WRITE_QUEUE = 0,
	TCP_FRAG_IN_RTX_QUEUE = 1,
};

enum tcp_seq_states {
	TCP_SEQ_STATE_LISTENING = 0,
	TCP_SEQ_STATE_ESTABLISHED = 1,
};

enum tcp_skb_cb_sacked_flags {
	TCPCB_SACKED_ACKED = 1,
	TCPCB_SACKED_RETRANS = 2,
	TCPCB_LOST = 4,
	TCPCB_TAGBITS = 7,
	TCPCB_REPAIRED = 16,
	TCPCB_EVER_RETRANS = 128,
	TCPCB_RETRANS = 146,
};

enum tcp_synack_type {
	TCP_SYNACK_NORMAL = 0,
	TCP_SYNACK_FASTOPEN = 1,
	TCP_SYNACK_COOKIE = 2,
};

enum tcp_tw_status {
	TCP_TW_SUCCESS = 0,
	TCP_TW_RST = 1,
	TCP_TW_ACK = 2,
	TCP_TW_SYN = 3,
};

enum tcpa_event_types {
	PREBOOT = 0,
	POST_CODE = 1,
	UNUSED = 2,
	NO_ACTION = 3,
	SEPARATOR = 4,
	ACTION = 5,
	EVENT_TAG = 6,
	SCRTM_CONTENTS = 7,
	SCRTM_VERSION = 8,
	CPU_MICROCODE = 9,
	PLATFORM_CONFIG_FLAGS = 10,
	TABLE_OF_DEVICES = 11,
	COMPACT_HASH = 12,
	IPL = 13,
	IPL_PARTITION_DATA = 14,
	NONHOST_CODE = 15,
	NONHOST_CONFIG = 16,
	NONHOST_INFO = 17,
};

enum tcpa_pc_event_ids {
	SMBIOS = 1,
	BIS_CERT = 2,
	POST_BIOS_ROM = 3,
	ESCD = 4,
	CMOS = 5,
	NVRAM = 6,
	OPTION_ROM_EXEC = 7,
	OPTION_ROM_CONFIG = 8,
	OPTION_ROM_MICROCODE = 10,
	S_CRTM_VERSION = 11,
	S_CRTM_CONTENTS = 12,
	POST_CONTENTS = 13,
	HOST_TABLE_OF_DEVICES = 14,
};

enum tcx_action_base {
	TCX_NEXT = -1,
	TCX_PASS = 0,
	TCX_DROP = 2,
	TCX_REDIRECT = 7,
};

enum tg_state_flags {
	THROTL_TG_PENDING = 1,
	THROTL_TG_WAS_EMPTY = 2,
	THROTL_TG_CANCELING = 4,
};

enum thermal_device_mode {
	THERMAL_DEVICE_DISABLED = 0,
	THERMAL_DEVICE_ENABLED = 1,
};

enum thermal_genl_attr {
	THERMAL_GENL_ATTR_UNSPEC = 0,
	THERMAL_GENL_ATTR_TZ = 1,
	THERMAL_GENL_ATTR_TZ_ID = 2,
	THERMAL_GENL_ATTR_TZ_TEMP = 3,
	THERMAL_GENL_ATTR_TZ_TRIP = 4,
	THERMAL_GENL_ATTR_TZ_TRIP_ID = 5,
	THERMAL_GENL_ATTR_TZ_TRIP_TYPE = 6,
	THERMAL_GENL_ATTR_TZ_TRIP_TEMP = 7,
	THERMAL_GENL_ATTR_TZ_TRIP_HYST = 8,
	THERMAL_GENL_ATTR_TZ_MODE = 9,
	THERMAL_GENL_ATTR_TZ_NAME = 10,
	THERMAL_GENL_ATTR_TZ_CDEV_WEIGHT = 11,
	THERMAL_GENL_ATTR_TZ_GOV = 12,
	THERMAL_GENL_ATTR_TZ_GOV_NAME = 13,
	THERMAL_GENL_ATTR_CDEV = 14,
	THERMAL_GENL_ATTR_CDEV_ID = 15,
	THERMAL_GENL_ATTR_CDEV_CUR_STATE = 16,
	THERMAL_GENL_ATTR_CDEV_MAX_STATE = 17,
	THERMAL_GENL_ATTR_CDEV_NAME = 18,
	THERMAL_GENL_ATTR_GOV_NAME = 19,
	THERMAL_GENL_ATTR_CPU_CAPABILITY = 20,
	THERMAL_GENL_ATTR_CPU_CAPABILITY_ID = 21,
	THERMAL_GENL_ATTR_CPU_CAPABILITY_PERFORMANCE = 22,
	THERMAL_GENL_ATTR_CPU_CAPABILITY_EFFICIENCY = 23,
	THERMAL_GENL_ATTR_THRESHOLD = 24,
	THERMAL_GENL_ATTR_THRESHOLD_TEMP = 25,
	THERMAL_GENL_ATTR_THRESHOLD_DIRECTION = 26,
	THERMAL_GENL_ATTR_TZ_PREV_TEMP = 27,
	__THERMAL_GENL_ATTR_MAX = 28,
};

enum thermal_genl_cmd {
	THERMAL_GENL_CMD_UNSPEC = 0,
	THERMAL_GENL_CMD_TZ_GET_ID = 1,
	THERMAL_GENL_CMD_TZ_GET_TRIP = 2,
	THERMAL_GENL_CMD_TZ_GET_TEMP = 3,
	THERMAL_GENL_CMD_TZ_GET_GOV = 4,
	THERMAL_GENL_CMD_TZ_GET_MODE = 5,
	THERMAL_GENL_CMD_CDEV_GET = 6,
	THERMAL_GENL_CMD_THRESHOLD_GET = 7,
	THERMAL_GENL_CMD_THRESHOLD_ADD = 8,
	THERMAL_GENL_CMD_THRESHOLD_DELETE = 9,
	THERMAL_GENL_CMD_THRESHOLD_FLUSH = 10,
	__THERMAL_GENL_CMD_MAX = 11,
};

enum thermal_genl_event {
	THERMAL_GENL_EVENT_UNSPEC = 0,
	THERMAL_GENL_EVENT_TZ_CREATE = 1,
	THERMAL_GENL_EVENT_TZ_DELETE = 2,
	THERMAL_GENL_EVENT_TZ_DISABLE = 3,
	THERMAL_GENL_EVENT_TZ_ENABLE = 4,
	THERMAL_GENL_EVENT_TZ_TRIP_UP = 5,
	THERMAL_GENL_EVENT_TZ_TRIP_DOWN = 6,
	THERMAL_GENL_EVENT_TZ_TRIP_CHANGE = 7,
	THERMAL_GENL_EVENT_TZ_TRIP_ADD = 8,
	THERMAL_GENL_EVENT_TZ_TRIP_DELETE = 9,
	THERMAL_GENL_EVENT_CDEV_ADD = 10,
	THERMAL_GENL_EVENT_CDEV_DELETE = 11,
	THERMAL_GENL_EVENT_CDEV_STATE_UPDATE = 12,
	THERMAL_GENL_EVENT_TZ_GOV_CHANGE = 13,
	THERMAL_GENL_EVENT_CPU_CAPABILITY_CHANGE = 14,
	THERMAL_GENL_EVENT_THRESHOLD_ADD = 15,
	THERMAL_GENL_EVENT_THRESHOLD_DELETE = 16,
	THERMAL_GENL_EVENT_THRESHOLD_FLUSH = 17,
	THERMAL_GENL_EVENT_THRESHOLD_UP = 18,
	THERMAL_GENL_EVENT_THRESHOLD_DOWN = 19,
	__THERMAL_GENL_EVENT_MAX = 20,
};

enum thermal_genl_multicast_groups {
	THERMAL_GENL_SAMPLING_GROUP = 0,
	THERMAL_GENL_EVENT_GROUP = 1,
	THERMAL_GENL_MAX_GROUP = 1,
};

enum thermal_genl_sampling {
	THERMAL_GENL_SAMPLING_TEMP = 0,
	__THERMAL_GENL_SAMPLING_MAX = 1,
};

enum thermal_notify_event {
	THERMAL_EVENT_UNSPECIFIED = 0,
	THERMAL_EVENT_TEMP_SAMPLE = 1,
	THERMAL_TRIP_VIOLATED = 2,
	THERMAL_TRIP_CHANGED = 3,
	THERMAL_DEVICE_DOWN = 4,
	THERMAL_DEVICE_UP = 5,
	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
	THERMAL_TABLE_CHANGED = 7,
	THERMAL_EVENT_KEEP_ALIVE = 8,
	THERMAL_TZ_BIND_CDEV = 9,
	THERMAL_TZ_UNBIND_CDEV = 10,
	THERMAL_INSTANCE_WEIGHT_CHANGED = 11,
	THERMAL_TZ_RESUME = 12,
	THERMAL_TZ_ADD_THRESHOLD = 13,
	THERMAL_TZ_DEL_THRESHOLD = 14,
	THERMAL_TZ_FLUSH_THRESHOLDS = 15,
};

enum thermal_trend {
	THERMAL_TREND_STABLE = 0,
	THERMAL_TREND_RAISING = 1,
	THERMAL_TREND_DROPPING = 2,
};

enum thermal_trip_type {
	THERMAL_TRIP_ACTIVE = 0,
	THERMAL_TRIP_PASSIVE = 1,
	THERMAL_TRIP_HOT = 2,
	THERMAL_TRIP_CRITICAL = 3,
};

enum tick_broadcast_mode {
	TICK_BROADCAST_OFF = 0,
	TICK_BROADCAST_ON = 1,
	TICK_BROADCAST_FORCE = 2,
};

enum tick_broadcast_state {
	TICK_BROADCAST_EXIT = 0,
	TICK_BROADCAST_ENTER = 1,
};

enum tick_dep_bits {
	TICK_DEP_BIT_POSIX_TIMER = 0,
	TICK_DEP_BIT_PERF_EVENTS = 1,
	TICK_DEP_BIT_SCHED = 2,
	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
	TICK_DEP_BIT_RCU = 4,
	TICK_DEP_BIT_RCU_EXP = 5,
};

enum tick_device_mode {
	TICKDEV_MODE_PERIODIC = 0,
	TICKDEV_MODE_ONESHOT = 1,
};

enum timekeeping_adv_mode {
	TK_ADV_TICK = 0,
	TK_ADV_FREQ = 1,
};

enum timespec_type {
	TT_NONE = 0,
	TT_NATIVE = 1,
	TT_COMPAT = 2,
};

enum tipc_scope {
	TIPC_CLUSTER_SCOPE = 2,
	TIPC_NODE_SCOPE = 3,
};

enum tis_access {
	TPM_ACCESS_VALID = 128,
	TPM_ACCESS_ACTIVE_LOCALITY = 32,
	TPM_ACCESS_REQUEST_PENDING = 4,
	TPM_ACCESS_REQUEST_USE = 2,
};

enum tis_defaults {
	TIS_MEM_LEN = 20480,
	TIS_SHORT_TIMEOUT = 750,
	TIS_LONG_TIMEOUT = 2000,
	TIS_TIMEOUT_MIN_ATML = 14700,
	TIS_TIMEOUT_MAX_ATML = 15000,
};

enum tis_int_flags {
	TPM_GLOBAL_INT_ENABLE = 2147483648,
	TPM_INTF_BURST_COUNT_STATIC = 256,
	TPM_INTF_CMD_READY_INT = 128,
	TPM_INTF_INT_EDGE_FALLING = 64,
	TPM_INTF_INT_EDGE_RISING = 32,
	TPM_INTF_INT_LEVEL_LOW = 16,
	TPM_INTF_INT_LEVEL_HIGH = 8,
	TPM_INTF_LOCALITY_CHANGE_INT = 4,
	TPM_INTF_STS_VALID_INT = 2,
	TPM_INTF_DATA_AVAIL_INT = 1,
};

enum tis_status {
	TPM_STS_VALID = 128,
	TPM_STS_COMMAND_READY = 64,
	TPM_STS_GO = 32,
	TPM_STS_DATA_AVAIL = 16,
	TPM_STS_DATA_EXPECT = 8,
	TPM_STS_RESPONSE_RETRY = 2,
	TPM_STS_READ_ZERO = 35,
};

enum tk_offsets {
	TK_OFFS_REAL = 0,
	TK_OFFS_BOOT = 1,
	TK_OFFS_TAI = 2,
	TK_OFFS_MAX = 3,
};

enum tlb_flush_reason {
	TLB_FLUSH_ON_TASK_SWITCH = 0,
	TLB_REMOTE_SHOOTDOWN = 1,
	TLB_LOCAL_SHOOTDOWN = 2,
	TLB_LOCAL_MM_SHOOTDOWN = 3,
	TLB_REMOTE_SEND_IPI = 4,
	TLB_REMOTE_WRONG_CPU = 5,
	NR_TLB_FLUSH_REASONS = 6,
};

enum tlb_infos {
	ENTRIES = 0,
	NR_INFO = 1,
};

enum topo_types {
	INVALID_TYPE = 0,
	SMT_TYPE = 1,
	CORE_TYPE = 2,
	MAX_TYPE_0B = 3,
	MODULE_TYPE = 3,
	AMD_CCD_TYPE = 3,
	TILE_TYPE = 4,
	AMD_SOCKET_TYPE = 4,
	MAX_TYPE_80000026 = 5,
	DIE_TYPE = 5,
	DIEGRP_TYPE = 6,
	MAX_TYPE_1F = 7,
};

enum tp_func_state {
	TP_FUNC_0 = 0,
	TP_FUNC_1 = 1,
	TP_FUNC_2 = 2,
	TP_FUNC_N = 3,
};

enum tp_transition_sync {
	TP_TRANSITION_SYNC_1_0_1 = 0,
	TP_TRANSITION_SYNC_N_2_1 = 1,
	_NR_TP_TRANSITION_SYNC = 2,
};

enum tpacket_versions {
	TPACKET_V1 = 0,
	TPACKET_V2 = 1,
	TPACKET_V3 = 2,
};

enum tpm2_capabilities {
	TPM2_CAP_HANDLES = 1,
	TPM2_CAP_COMMANDS = 2,
	TPM2_CAP_PCRS = 5,
	TPM2_CAP_TPM_PROPERTIES = 6,
};

enum tpm2_cc_attrs {
	TPM2_CC_ATTR_CHANDLES = 25,
	TPM2_CC_ATTR_RHANDLE = 28,
	TPM2_CC_ATTR_VENDOR = 29,
};

enum tpm2_command_codes {
	TPM2_CC_FIRST = 287,
	TPM2_CC_HIERARCHY_CONTROL = 289,
	TPM2_CC_HIERARCHY_CHANGE_AUTH = 297,
	TPM2_CC_CREATE_PRIMARY = 305,
	TPM2_CC_SEQUENCE_COMPLETE = 318,
	TPM2_CC_SELF_TEST = 323,
	TPM2_CC_STARTUP = 324,
	TPM2_CC_SHUTDOWN = 325,
	TPM2_CC_NV_READ = 334,
	TPM2_CC_CREATE = 339,
	TPM2_CC_LOAD = 343,
	TPM2_CC_SEQUENCE_UPDATE = 348,
	TPM2_CC_UNSEAL = 350,
	TPM2_CC_CONTEXT_LOAD = 353,
	TPM2_CC_CONTEXT_SAVE = 354,
	TPM2_CC_FLUSH_CONTEXT = 357,
	TPM2_CC_READ_PUBLIC = 371,
	TPM2_CC_START_AUTH_SESS = 374,
	TPM2_CC_VERIFY_SIGNATURE = 375,
	TPM2_CC_GET_CAPABILITY = 378,
	TPM2_CC_GET_RANDOM = 379,
	TPM2_CC_PCR_READ = 382,
	TPM2_CC_PCR_EXTEND = 386,
	TPM2_CC_EVENT_SEQUENCE_COMPLETE = 389,
	TPM2_CC_HASH_SEQUENCE_START = 390,
	TPM2_CC_CREATE_LOADED = 401,
	TPM2_CC_LAST = 403,
};

enum tpm2_const {
	TPM2_PLATFORM_PCR = 24,
	TPM2_PCR_SELECT_MIN = 3,
};

enum tpm2_curves {
	TPM2_ECC_NONE = 0,
	TPM2_ECC_NIST_P256 = 3,
};

enum tpm2_handle_types {
	TPM2_HT_HMAC_SESSION = 33554432,
	TPM2_HT_POLICY_SESSION = 50331648,
	TPM2_HT_TRANSIENT = 2147483648,
};

enum tpm2_mso_type {
	TPM2_MSO_NVRAM = 1,
	TPM2_MSO_SESSION = 2,
	TPM2_MSO_POLICY = 3,
	TPM2_MSO_PERMANENT = 64,
	TPM2_MSO_VOLATILE = 128,
	TPM2_MSO_PERSISTENT = 129,
};

enum tpm2_object_attributes {
	TPM2_OA_FIXED_TPM = 2,
	TPM2_OA_ST_CLEAR = 4,
	TPM2_OA_FIXED_PARENT = 16,
	TPM2_OA_SENSITIVE_DATA_ORIGIN = 32,
	TPM2_OA_USER_WITH_AUTH = 64,
	TPM2_OA_ADMIN_WITH_POLICY = 128,
	TPM2_OA_NO_DA = 1024,
	TPM2_OA_ENCRYPTED_DUPLICATION = 2048,
	TPM2_OA_RESTRICTED = 65536,
	TPM2_OA_DECRYPT = 131072,
	TPM2_OA_SIGN = 262144,
};

enum tpm2_permanent_handles {
	TPM2_RH_NULL = 1073741831,
	TPM2_RS_PW = 1073741833,
};

enum tpm2_properties {
	TPM_PT_TOTAL_COMMANDS = 297,
};

enum tpm2_return_codes {
	TPM2_RC_SUCCESS = 0,
	TPM2_RC_HASH = 131,
	TPM2_RC_HANDLE = 139,
	TPM2_RC_INTEGRITY = 159,
	TPM2_RC_INITIALIZE = 256,
	TPM2_RC_FAILURE = 257,
	TPM2_RC_DISABLED = 288,
	TPM2_RC_UPGRADE = 301,
	TPM2_RC_COMMAND_CODE = 323,
	TPM2_RC_TESTING = 2314,
	TPM2_RC_REFERENCE_H0 = 2320,
	TPM2_RC_RETRY = 2338,
};

enum tpm2_session_attributes {
	TPM2_SA_CONTINUE_SESSION = 1,
	TPM2_SA_AUDIT_EXCLUSIVE = 2,
	TPM2_SA_AUDIT_RESET = 8,
	TPM2_SA_DECRYPT = 32,
	TPM2_SA_ENCRYPT = 64,
	TPM2_SA_AUDIT = 128,
};

enum tpm2_session_types {
	TPM2_SE_HMAC = 0,
	TPM2_SE_POLICY = 1,
	TPM2_SE_TRIAL = 2,
};

enum tpm2_startup_types {
	TPM2_SU_CLEAR = 0,
	TPM2_SU_STATE = 1,
};

enum tpm2_structures {
	TPM2_ST_NO_SESSIONS = 32769,
	TPM2_ST_SESSIONS = 32770,
	TPM2_ST_CREATION = 32801,
};

enum tpm2_timeouts {
	TPM2_TIMEOUT_A = 750,
	TPM2_TIMEOUT_B = 2000,
	TPM2_TIMEOUT_C = 200,
	TPM2_TIMEOUT_D = 30,
	TPM2_DURATION_SHORT = 20,
	TPM2_DURATION_MEDIUM = 750,
	TPM2_DURATION_LONG = 2000,
	TPM2_DURATION_LONG_LONG = 300000,
	TPM2_DURATION_DEFAULT = 120000,
};

enum tpm_algorithms {
	TPM_ALG_ERROR = 0,
	TPM_ALG_SHA1 = 4,
	TPM_ALG_AES = 6,
	TPM_ALG_KEYEDHASH = 8,
	TPM_ALG_SHA256 = 11,
	TPM_ALG_SHA384 = 12,
	TPM_ALG_SHA512 = 13,
	TPM_ALG_NULL = 16,
	TPM_ALG_SM3_256 = 18,
	TPM_ALG_ECC = 35,
	TPM_ALG_CFB = 67,
};

enum tpm_buf_flags {
	TPM_BUF_OVERFLOW = 1,
	TPM_BUF_TPM2B = 2,
	TPM_BUF_BOUNDARY_ERROR = 4,
};

enum tpm_capabilities {
	TPM_CAP_FLAG = 4,
	TPM_CAP_PROP = 5,
	TPM_CAP_VERSION_1_1 = 6,
	TPM_CAP_VERSION_1_2 = 26,
};

enum tpm_chip_flags {
	TPM_CHIP_FLAG_BOOTSTRAPPED = 1,
	TPM_CHIP_FLAG_TPM2 = 2,
	TPM_CHIP_FLAG_IRQ = 4,
	TPM_CHIP_FLAG_VIRTUAL = 8,
	TPM_CHIP_FLAG_HAVE_TIMEOUTS = 16,
	TPM_CHIP_FLAG_ALWAYS_POWERED = 32,
	TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED = 64,
	TPM_CHIP_FLAG_FIRMWARE_UPGRADE = 128,
	TPM_CHIP_FLAG_SUSPENDED = 256,
	TPM_CHIP_FLAG_HWRNG_DISABLED = 512,
	TPM_CHIP_FLAG_DISABLE = 1024,
};

enum tpm_duration {
	TPM_SHORT = 0,
	TPM_MEDIUM = 1,
	TPM_LONG = 2,
	TPM_LONG_LONG = 3,
	TPM_UNDEFINED = 4,
	TPM_NUM_DURATIONS = 4,
};

enum tpm_pcrs {
	TPM_PCR0 = 0,
	TPM_PCR8 = 8,
	TPM_PCR10 = 10,
};

enum tpm_sub_capabilities {
	TPM_CAP_PROP_PCR = 257,
	TPM_CAP_PROP_MANUFACTURER = 259,
	TPM_CAP_FLAG_PERM = 264,
	TPM_CAP_FLAG_VOL = 265,
	TPM_CAP_PROP_OWNER = 273,
	TPM_CAP_PROP_TIS_TIMEOUT = 277,
	TPM_CAP_PROP_TIS_DURATION = 288,
};

enum tpm_timeout {
	TPM_TIMEOUT = 5,
	TPM_TIMEOUT_RETRY = 100,
	TPM_TIMEOUT_RANGE_US = 300,
	TPM_TIMEOUT_POLL = 1,
	TPM_TIMEOUT_USECS_MIN = 100,
	TPM_TIMEOUT_USECS_MAX = 500,
};

enum tpm_tis_flags {
	TPM_TIS_ITPM_WORKAROUND = 0,
	TPM_TIS_INVALID_STATUS = 1,
	TPM_TIS_DEFAULT_CANCELLATION = 2,
	TPM_TIS_IRQ_TESTED = 3,
	TPM_TIS_STATUS_VALID_RETRY = 4,
};

enum tpm_tis_io_mode {
	TPM_TIS_PHYS_8 = 0,
	TPM_TIS_PHYS_16 = 1,
	TPM_TIS_PHYS_32 = 2,
};

enum trace_flag_type {
	TRACE_FLAG_IRQS_OFF = 1,
	TRACE_FLAG_NEED_RESCHED_LAZY = 2,
	TRACE_FLAG_NEED_RESCHED = 4,
	TRACE_FLAG_HARDIRQ = 8,
	TRACE_FLAG_SOFTIRQ = 16,
	TRACE_FLAG_PREEMPT_RESCHED = 32,
	TRACE_FLAG_NMI = 64,
	TRACE_FLAG_BH_OFF = 128,
};

enum trace_iter_flags {
	TRACE_FILE_LAT_FMT = 1,
	TRACE_FILE_ANNOTATE = 2,
	TRACE_FILE_TIME_IN_NS = 4,
};

enum trace_iterator_bits {
	TRACE_ITER_PRINT_PARENT_BIT = 0,
	TRACE_ITER_SYM_OFFSET_BIT = 1,
	TRACE_ITER_SYM_ADDR_BIT = 2,
	TRACE_ITER_VERBOSE_BIT = 3,
	TRACE_ITER_RAW_BIT = 4,
	TRACE_ITER_HEX_BIT = 5,
	TRACE_ITER_BIN_BIT = 6,
	TRACE_ITER_BLOCK_BIT = 7,
	TRACE_ITER_FIELDS_BIT = 8,
	TRACE_ITER_PRINTK_BIT = 9,
	TRACE_ITER_ANNOTATE_BIT = 10,
	TRACE_ITER_USERSTACKTRACE_BIT = 11,
	TRACE_ITER_SYM_USEROBJ_BIT = 12,
	TRACE_ITER_PRINTK_MSGONLY_BIT = 13,
	TRACE_ITER_CONTEXT_INFO_BIT = 14,
	TRACE_ITER_LATENCY_FMT_BIT = 15,
	TRACE_ITER_RECORD_CMD_BIT = 16,
	TRACE_ITER_RECORD_TGID_BIT = 17,
	TRACE_ITER_OVERWRITE_BIT = 18,
	TRACE_ITER_STOP_ON_FREE_BIT = 19,
	TRACE_ITER_IRQ_INFO_BIT = 20,
	TRACE_ITER_MARKERS_BIT = 21,
	TRACE_ITER_EVENT_FORK_BIT = 22,
	TRACE_ITER_TRACE_PRINTK_BIT = 23,
	TRACE_ITER_PAUSE_ON_TRACE_BIT = 24,
	TRACE_ITER_HASH_PTR_BIT = 25,
	TRACE_ITER_STACKTRACE_BIT = 26,
	TRACE_ITER_LAST_BIT = 27,
};

enum trace_iterator_flags {
	TRACE_ITER_PRINT_PARENT = 1,
	TRACE_ITER_SYM_OFFSET = 2,
	TRACE_ITER_SYM_ADDR = 4,
	TRACE_ITER_VERBOSE = 8,
	TRACE_ITER_RAW = 16,
	TRACE_ITER_HEX = 32,
	TRACE_ITER_BIN = 64,
	TRACE_ITER_BLOCK = 128,
	TRACE_ITER_FIELDS = 256,
	TRACE_ITER_PRINTK = 512,
	TRACE_ITER_ANNOTATE = 1024,
	TRACE_ITER_USERSTACKTRACE = 2048,
	TRACE_ITER_SYM_USEROBJ = 4096,
	TRACE_ITER_PRINTK_MSGONLY = 8192,
	TRACE_ITER_CONTEXT_INFO = 16384,
	TRACE_ITER_LATENCY_FMT = 32768,
	TRACE_ITER_RECORD_CMD = 65536,
	TRACE_ITER_RECORD_TGID = 131072,
	TRACE_ITER_OVERWRITE = 262144,
	TRACE_ITER_STOP_ON_FREE = 524288,
	TRACE_ITER_IRQ_INFO = 1048576,
	TRACE_ITER_MARKERS = 2097152,
	TRACE_ITER_EVENT_FORK = 4194304,
	TRACE_ITER_TRACE_PRINTK = 8388608,
	TRACE_ITER_PAUSE_ON_TRACE = 16777216,
	TRACE_ITER_HASH_PTR = 33554432,
	TRACE_ITER_STACKTRACE = 67108864,
};

enum trace_reg {
	TRACE_REG_REGISTER = 0,
	TRACE_REG_UNREGISTER = 1,
	TRACE_REG_PERF_REGISTER = 2,
	TRACE_REG_PERF_UNREGISTER = 3,
	TRACE_REG_PERF_OPEN = 4,
	TRACE_REG_PERF_CLOSE = 5,
	TRACE_REG_PERF_ADD = 6,
	TRACE_REG_PERF_DEL = 7,
};

enum trace_type {
	__TRACE_FIRST_TYPE = 0,
	TRACE_FN = 1,
	TRACE_CTX = 2,
	TRACE_WAKE = 3,
	TRACE_STACK = 4,
	TRACE_PRINT = 5,
	TRACE_BPRINT = 6,
	TRACE_MMIO_RW = 7,
	TRACE_MMIO_MAP = 8,
	TRACE_BRANCH = 9,
	TRACE_GRAPH_RET = 10,
	TRACE_GRAPH_ENT = 11,
	TRACE_GRAPH_RETADDR_ENT = 12,
	TRACE_USER_STACK = 13,
	TRACE_BLK = 14,
	TRACE_BPUTS = 15,
	TRACE_HWLAT = 16,
	TRACE_OSNOISE = 17,
	TRACE_TIMERLAT = 18,
	TRACE_RAW_DATA = 19,
	TRACE_FUNC_REPEATS = 20,
	__TRACE_LAST_TYPE = 21,
};

enum track_item {
	TRACK_ALLOC = 0,
	TRACK_FREE = 1,
};

enum transcoder {
	INVALID_TRANSCODER = -1,
	TRANSCODER_A = 0,
	TRANSCODER_B = 1,
	TRANSCODER_C = 2,
	TRANSCODER_D = 3,
	TRANSCODER_EDP = 4,
	TRANSCODER_DSI_0 = 5,
	TRANSCODER_DSI_1 = 6,
	TRANSCODER_DSI_A = 5,
	TRANSCODER_DSI_C = 6,
	I915_MAX_TRANSCODERS = 7,
};

enum translation_map {
	LAT1_MAP = 0,
	GRAF_MAP = 1,
	IBMPC_MAP = 2,
	USER_MAP = 3,
	FIRST_MAP = 0,
	LAST_MAP = 3,
};

enum tsq_enum {
	TSQ_THROTTLED = 0,
	TSQ_QUEUED = 1,
	TCP_TSQ_DEFERRED = 2,
	TCP_WRITE_TIMER_DEFERRED = 3,
	TCP_DELACK_TIMER_DEFERRED = 4,
	TCP_MTU_REDUCED_DEFERRED = 5,
	TCP_ACK_DEFERRED = 6,
};

enum tsq_flags {
	TSQF_THROTTLED = 1,
	TSQF_QUEUED = 2,
	TCPF_TSQ_DEFERRED = 4,
	TCPF_WRITE_TIMER_DEFERRED = 8,
	TCPF_DELACK_TIMER_DEFERRED = 16,
	TCPF_MTU_REDUCED_DEFERRED = 32,
	TCPF_ACK_DEFERRED = 64,
};

enum tsx_ctrl_states {
	TSX_CTRL_ENABLE = 0,
	TSX_CTRL_DISABLE = 1,
	TSX_CTRL_RTM_ALWAYS_ABORT = 2,
	TSX_CTRL_NOT_SUPPORTED = 3,
};

enum ttm_bo_type {
	ttm_bo_type_device = 0,
	ttm_bo_type_kernel = 1,
	ttm_bo_type_sg = 2,
};

enum ttm_caching {
	ttm_uncached = 0,
	ttm_write_combined = 1,
	ttm_cached = 2,
};

enum ttm_lru_item_type {
	TTM_LRU_RESOURCE = 0,
	TTM_LRU_HITCH = 1,
};

enum ttu_flags {
	TTU_SPLIT_HUGE_PMD = 4,
	TTU_IGNORE_MLOCK = 8,
	TTU_SYNC = 16,
	TTU_HWPOISON = 32,
	TTU_BATCH_FLUSH = 64,
	TTU_RMAP_LOCKED = 128,
};

enum tty_flow_change {
	TTY_FLOW_NO_CHANGE = 0,
	TTY_THROTTLE_SAFE = 1,
	TTY_UNTHROTTLE_SAFE = 2,
};

enum tunable_id {
	ETHTOOL_ID_UNSPEC = 0,
	ETHTOOL_RX_COPYBREAK = 1,
	ETHTOOL_TX_COPYBREAK = 2,
	ETHTOOL_PFC_PREVENTION_TOUT = 3,
	ETHTOOL_TX_COPYBREAK_BUF_SIZE = 4,
	__ETHTOOL_TUNABLE_COUNT = 5,
};

enum tunable_type_id {
	ETHTOOL_TUNABLE_UNSPEC = 0,
	ETHTOOL_TUNABLE_U8 = 1,
	ETHTOOL_TUNABLE_U16 = 2,
	ETHTOOL_TUNABLE_U32 = 3,
	ETHTOOL_TUNABLE_U64 = 4,
	ETHTOOL_TUNABLE_STRING = 5,
	ETHTOOL_TUNABLE_S8 = 6,
	ETHTOOL_TUNABLE_S16 = 7,
	ETHTOOL_TUNABLE_S32 = 8,
	ETHTOOL_TUNABLE_S64 = 9,
};

enum tunnel_encap_types {
	TUNNEL_ENCAP_NONE = 0,
	TUNNEL_ENCAP_FOU = 1,
	TUNNEL_ENCAP_GUE = 2,
	TUNNEL_ENCAP_MPLS = 3,
};

enum txtime_flags {
	SOF_TXTIME_DEADLINE_MODE = 1,
	SOF_TXTIME_REPORT_ERRORS = 2,
	SOF_TXTIME_FLAGS_LAST = 2,
	SOF_TXTIME_FLAGS_MASK = 3,
};

enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3,
	UART_PM_STATE_UNDEFINED = 4,
};

enum ubsan_checks {
	ubsan_add_overflow = 0,
	ubsan_builtin_unreachable = 1,
	ubsan_cfi_check_fail = 2,
	ubsan_divrem_overflow = 3,
	ubsan_dynamic_type_cache_miss = 4,
	ubsan_float_cast_overflow = 5,
	ubsan_function_type_mismatch = 6,
	ubsan_implicit_conversion = 7,
	ubsan_invalid_builtin = 8,
	ubsan_invalid_objc_cast = 9,
	ubsan_load_invalid_value = 10,
	ubsan_missing_return = 11,
	ubsan_mul_overflow = 12,
	ubsan_negate_overflow = 13,
	ubsan_nullability_arg = 14,
	ubsan_nullability_return = 15,
	ubsan_nonnull_arg = 16,
	ubsan_nonnull_return = 17,
	ubsan_out_of_bounds = 18,
	ubsan_pointer_overflow = 19,
	ubsan_shift_out_of_bounds = 20,
	ubsan_sub_overflow = 21,
	ubsan_type_mismatch = 22,
	ubsan_alignment_assumption = 23,
	ubsan_vla_bound_not_positive = 24,
};

enum uclamp_id {
	UCLAMP_MIN = 0,
	UCLAMP_MAX = 1,
	UCLAMP_CNT = 2,
};

enum ucode_state {
	UCODE_OK = 0,
	UCODE_NEW = 1,
	UCODE_NEW_SAFE = 2,
	UCODE_UPDATED = 3,
	UCODE_NFOUND = 4,
	UCODE_ERROR = 5,
	UCODE_TIMEOUT = 6,
	UCODE_OFFLINE = 7,
};

enum ucount_type {
	UCOUNT_USER_NAMESPACES = 0,
	UCOUNT_PID_NAMESPACES = 1,
	UCOUNT_UTS_NAMESPACES = 2,
	UCOUNT_IPC_NAMESPACES = 3,
	UCOUNT_NET_NAMESPACES = 4,
	UCOUNT_MNT_NAMESPACES = 5,
	UCOUNT_CGROUP_NAMESPACES = 6,
	UCOUNT_TIME_NAMESPACES = 7,
	UCOUNT_INOTIFY_INSTANCES = 8,
	UCOUNT_INOTIFY_WATCHES = 9,
	UCOUNT_COUNTS = 10,
};

enum udp_conntrack {
	UDP_CT_UNREPLIED = 0,
	UDP_CT_REPLIED = 1,
	UDP_CT_MAX = 2,
};

enum udp_parsable_tunnel_type {
	UDP_TUNNEL_TYPE_VXLAN = 1,
	UDP_TUNNEL_TYPE_GENEVE = 2,
	UDP_TUNNEL_TYPE_VXLAN_GPE = 4,
};

enum udp_tunnel_nic_info_flags {
	UDP_TUNNEL_NIC_INFO_MAY_SLEEP = 1,
	UDP_TUNNEL_NIC_INFO_OPEN_ONLY = 2,
	UDP_TUNNEL_NIC_INFO_IPV4_ONLY = 4,
	UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN = 8,
};

enum udp_tunnel_nic_table_entry_flags {
	UDP_TUNNEL_NIC_ENTRY_ADD = 1,
	UDP_TUNNEL_NIC_ENTRY_DEL = 2,
	UDP_TUNNEL_NIC_ENTRY_OP_FAIL = 4,
	UDP_TUNNEL_NIC_ENTRY_FROZEN = 8,
};

enum umh_disable_depth {
	UMH_ENABLED = 0,
	UMH_FREEZING = 1,
	UMH_DISABLED = 2,
};

enum umount_tree_flags {
	UMOUNT_SYNC = 1,
	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
};

enum uncore_access_type {
	UNCORE_ACCESS_MSR = 0,
	UNCORE_ACCESS_MMIO = 1,
	UNCORE_ACCESS_PCI = 2,
	UNCORE_ACCESS_MAX = 3,
};

enum unix_vertex_index {
	UNIX_VERTEX_INDEX_MARK1 = 0,
	UNIX_VERTEX_INDEX_MARK2 = 1,
	UNIX_VERTEX_INDEX_START = 2,
};

enum update_reason {
	enqueue = 0,
	requeue = 1,
};

enum uprobe_task_state {
	UTASK_RUNNING = 0,
	UTASK_SSTEP = 1,
	UTASK_SSTEP_ACK = 2,
	UTASK_SSTEP_TRAPPED = 3,
};

enum utf16_endian {
	UTF16_HOST_ENDIAN = 0,
	UTF16_LITTLE_ENDIAN = 1,
	UTF16_BIG_ENDIAN = 2,
};

enum utf8_normalization {
	UTF8_NFDI = 0,
	UTF8_NFDICF = 1,
	UTF8_NMAX = 2,
};

enum uts_proc {
	UTS_PROC_ARCH = 0,
	UTS_PROC_OSTYPE = 1,
	UTS_PROC_OSRELEASE = 2,
	UTS_PROC_VERSION = 3,
	UTS_PROC_HOSTNAME = 4,
	UTS_PROC_DOMAINNAME = 5,
};

enum uv_system_type {
	UV_NONE = 0,
	UV_LEGACY_APIC = 1,
	UV_X2APIC = 2,
};

enum v4l2_av1_segment_feature {
	V4L2_AV1_SEG_LVL_ALT_Q = 0,
	V4L2_AV1_SEG_LVL_ALT_LF_Y_V = 1,
	V4L2_AV1_SEG_LVL_REF_FRAME = 5,
	V4L2_AV1_SEG_LVL_REF_SKIP = 6,
	V4L2_AV1_SEG_LVL_REF_GLOBALMV = 7,
	V4L2_AV1_SEG_LVL_MAX = 8,
};

enum v4l2_fwnode_bus_type {
	V4L2_FWNODE_BUS_TYPE_GUESS = 0,
	V4L2_FWNODE_BUS_TYPE_CSI2_CPHY = 1,
	V4L2_FWNODE_BUS_TYPE_CSI1 = 2,
	V4L2_FWNODE_BUS_TYPE_CCP2 = 3,
	V4L2_FWNODE_BUS_TYPE_CSI2_DPHY = 4,
	V4L2_FWNODE_BUS_TYPE_PARALLEL = 5,
	V4L2_FWNODE_BUS_TYPE_BT656 = 6,
	V4L2_FWNODE_BUS_TYPE_DPI = 7,
	NR_OF_V4L2_FWNODE_BUS_TYPE = 8,
};

enum v4l2_preemphasis {
	V4L2_PREEMPHASIS_DISABLED = 0,
	V4L2_PREEMPHASIS_50_uS = 1,
	V4L2_PREEMPHASIS_75_uS = 2,
};

enum vbt_gmbus_ddi {
	DDC_BUS_DDI_B = 1,
	DDC_BUS_DDI_C = 2,
	DDC_BUS_DDI_D = 3,
	DDC_BUS_DDI_F = 4,
	ICL_DDC_BUS_DDI_A = 1,
	ICL_DDC_BUS_DDI_B = 2,
	TGL_DDC_BUS_DDI_C = 3,
	RKL_DDC_BUS_DDI_D = 3,
	RKL_DDC_BUS_DDI_E = 4,
	ICL_DDC_BUS_PORT_1 = 4,
	ICL_DDC_BUS_PORT_2 = 5,
	ICL_DDC_BUS_PORT_3 = 6,
	ICL_DDC_BUS_PORT_4 = 7,
	TGL_DDC_BUS_PORT_5 = 8,
	TGL_DDC_BUS_PORT_6 = 9,
	ADLS_DDC_BUS_PORT_TC1 = 2,
	ADLS_DDC_BUS_PORT_TC2 = 3,
	ADLS_DDC_BUS_PORT_TC3 = 4,
	ADLS_DDC_BUS_PORT_TC4 = 5,
	ADLP_DDC_BUS_PORT_TC1 = 3,
	ADLP_DDC_BUS_PORT_TC2 = 4,
	ADLP_DDC_BUS_PORT_TC3 = 5,
	ADLP_DDC_BUS_PORT_TC4 = 6,
};

enum vc_ctl_state {
	ESnormal = 0,
	ESesc = 1,
	ESsquare = 2,
	ESgetpars = 3,
	ESfunckey = 4,
	EShash = 5,
	ESsetG0 = 6,
	ESsetG1 = 7,
	ESpercent = 8,
	EScsiignore = 9,
	ESnonstd = 10,
	ESpalette = 11,
	ESosc = 12,
	ESANSI_first = 12,
	ESapc = 13,
	ESpm = 14,
	ESdcs = 15,
	ESANSI_last = 15,
};

enum vc_intensity {
	VCI_HALF_BRIGHT = 0,
	VCI_NORMAL = 1,
	VCI_BOLD = 2,
	VCI_MASK = 3,
};

enum vdso_clock_mode {
	VDSO_CLOCKMODE_NONE = 0,
	VDSO_CLOCKMODE_TSC = 1,
	VDSO_CLOCKMODE_PVCLOCK = 2,
	VDSO_CLOCKMODE_HVCLOCK = 3,
	VDSO_CLOCKMODE_MAX = 4,
	VDSO_CLOCKMODE_TIMENS = 2147483647,
};

enum verifier_phase {
	CHECK_META = 0,
	CHECK_TYPE = 1,
};

enum verity_block_type {
	DM_VERITY_BLOCK_TYPE_DATA = 0,
	DM_VERITY_BLOCK_TYPE_METADATA = 1,
};

enum verity_mode {
	DM_VERITY_MODE_EIO = 0,
	DM_VERITY_MODE_LOGGING = 1,
	DM_VERITY_MODE_RESTART = 2,
	DM_VERITY_MODE_PANIC = 3,
};

enum vesa_blank_mode {
	VESA_NO_BLANKING = 0,
	VESA_VSYNC_SUSPEND = 1,
	VESA_HSYNC_SUSPEND = 2,
	VESA_POWERDOWN = 3,
	VESA_BLANK_MAX = 3,
};

enum vga_switcheroo_client_id {
	VGA_SWITCHEROO_UNKNOWN_ID = 4096,
	VGA_SWITCHEROO_IGD = 0,
	VGA_SWITCHEROO_DIS = 1,
	VGA_SWITCHEROO_MAX_CLIENTS = 2,
};

enum vga_switcheroo_handler_flags_t {
	VGA_SWITCHEROO_CAN_SWITCH_DDC = 1,
	VGA_SWITCHEROO_NEEDS_EDP_CONFIG = 2,
};

enum vga_switcheroo_state {
	VGA_SWITCHEROO_OFF = 0,
	VGA_SWITCHEROO_ON = 1,
	VGA_SWITCHEROO_NOT_FOUND = 2,
};

enum vgt_g2v_type {
	VGT_G2V_PPGTT_L3_PAGE_TABLE_CREATE = 2,
	VGT_G2V_PPGTT_L3_PAGE_TABLE_DESTROY = 3,
	VGT_G2V_PPGTT_L4_PAGE_TABLE_CREATE = 4,
	VGT_G2V_PPGTT_L4_PAGE_TABLE_DESTROY = 5,
	VGT_G2V_EXECLIST_CONTEXT_CREATE = 6,
	VGT_G2V_EXECLIST_CONTEXT_DESTROY = 7,
	VGT_G2V_MAX = 8,
};

enum vhost_task_flags {
	VHOST_TASK_FLAGS_STOP = 0,
	VHOST_TASK_FLAGS_KILLED = 1,
};

enum virtio_gpu_ctrl_type {
	VIRTIO_GPU_UNDEFINED = 0,
	VIRTIO_GPU_CMD_GET_DISPLAY_INFO = 256,
	VIRTIO_GPU_CMD_RESOURCE_CREATE_2D = 257,
	VIRTIO_GPU_CMD_RESOURCE_UNREF = 258,
	VIRTIO_GPU_CMD_SET_SCANOUT = 259,
	VIRTIO_GPU_CMD_RESOURCE_FLUSH = 260,
	VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D = 261,
	VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING = 262,
	VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING = 263,
	VIRTIO_GPU_CMD_GET_CAPSET_INFO = 264,
	VIRTIO_GPU_CMD_GET_CAPSET = 265,
	VIRTIO_GPU_CMD_GET_EDID = 266,
	VIRTIO_GPU_CMD_RESOURCE_ASSIGN_UUID = 267,
	VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB = 268,
	VIRTIO_GPU_CMD_SET_SCANOUT_BLOB = 269,
	VIRTIO_GPU_CMD_CTX_CREATE = 512,
	VIRTIO_GPU_CMD_CTX_DESTROY = 513,
	VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE = 514,
	VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE = 515,
	VIRTIO_GPU_CMD_RESOURCE_CREATE_3D = 516,
	VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D = 517,
	VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D = 518,
	VIRTIO_GPU_CMD_SUBMIT_3D = 519,
	VIRTIO_GPU_CMD_RESOURCE_MAP_BLOB = 520,
	VIRTIO_GPU_CMD_RESOURCE_UNMAP_BLOB = 521,
	VIRTIO_GPU_CMD_UPDATE_CURSOR = 768,
	VIRTIO_GPU_CMD_MOVE_CURSOR = 769,
	VIRTIO_GPU_RESP_OK_NODATA = 4352,
	VIRTIO_GPU_RESP_OK_DISPLAY_INFO = 4353,
	VIRTIO_GPU_RESP_OK_CAPSET_INFO = 4354,
	VIRTIO_GPU_RESP_OK_CAPSET = 4355,
	VIRTIO_GPU_RESP_OK_EDID = 4356,
	VIRTIO_GPU_RESP_OK_RESOURCE_UUID = 4357,
	VIRTIO_GPU_RESP_OK_MAP_INFO = 4358,
	VIRTIO_GPU_RESP_ERR_UNSPEC = 4608,
	VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY = 4609,
	VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID = 4610,
	VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID = 4611,
	VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID = 4612,
	VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER = 4613,
};

enum virtio_gpu_formats {
	VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM = 1,
	VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM = 2,
	VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM = 3,
	VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM = 4,
	VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM = 67,
	VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM = 68,
	VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM = 121,
	VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM = 134,
};

enum virtio_gpu_shm_id {
	VIRTIO_GPU_SHM_ID_UNDEFINED = 0,
	VIRTIO_GPU_SHM_ID_HOST_VISIBLE = 1,
};

enum virtio_input_config_select {
	VIRTIO_INPUT_CFG_UNSET = 0,
	VIRTIO_INPUT_CFG_ID_NAME = 1,
	VIRTIO_INPUT_CFG_ID_SERIAL = 2,
	VIRTIO_INPUT_CFG_ID_DEVIDS = 3,
	VIRTIO_INPUT_CFG_PROP_BITS = 16,
	VIRTIO_INPUT_CFG_EV_BITS = 17,
	VIRTIO_INPUT_CFG_ABS_INFO = 18,
};

enum virtio_vsock_event_id {
	VIRTIO_VSOCK_EVENT_TRANSPORT_RESET = 0,
};

enum virtio_vsock_op {
	VIRTIO_VSOCK_OP_INVALID = 0,
	VIRTIO_VSOCK_OP_REQUEST = 1,
	VIRTIO_VSOCK_OP_RESPONSE = 2,
	VIRTIO_VSOCK_OP_RST = 3,
	VIRTIO_VSOCK_OP_SHUTDOWN = 4,
	VIRTIO_VSOCK_OP_RW = 5,
	VIRTIO_VSOCK_OP_CREDIT_UPDATE = 6,
	VIRTIO_VSOCK_OP_CREDIT_REQUEST = 7,
};

enum virtio_vsock_rw {
	VIRTIO_VSOCK_SEQ_EOM = 1,
	VIRTIO_VSOCK_SEQ_EOR = 2,
};

enum virtio_vsock_shutdown {
	VIRTIO_VSOCK_SHUTDOWN_RCV = 1,
	VIRTIO_VSOCK_SHUTDOWN_SEND = 2,
};

enum virtio_vsock_type {
	VIRTIO_VSOCK_TYPE_STREAM = 1,
	VIRTIO_VSOCK_TYPE_SEQPACKET = 2,
};

enum virtnet_xmit_type {
	VIRTNET_XMIT_TYPE_SKB = 0,
	VIRTNET_XMIT_TYPE_SKB_ORPHAN = 1,
	VIRTNET_XMIT_TYPE_XDP = 2,
	VIRTNET_XMIT_TYPE_XSK = 3,
};

enum visit_state {
	NOT_VISITED = 0,
	VISITED = 1,
	RESOLVED = 2,
};

enum vlan_flags {
	VLAN_FLAG_REORDER_HDR = 1,
	VLAN_FLAG_GVRP = 2,
	VLAN_FLAG_LOOSE_BINDING = 4,
	VLAN_FLAG_MVRP = 8,
	VLAN_FLAG_BRIDGE_BINDING = 16,
};

enum vlan_protos {
	VLAN_PROTO_8021Q = 0,
	VLAN_PROTO_8021AD = 1,
	VLAN_PROTO_NUM = 2,
};

enum vlv_wm_level {
	VLV_WM_LEVEL_PM2 = 0,
	VLV_WM_LEVEL_PM5 = 1,
	VLV_WM_LEVEL_DDR_DVFS = 2,
	NUM_VLV_WM_LEVELS = 3,
};

enum vm_event_item {
	PGPGIN = 0,
	PGPGOUT = 1,
	PSWPIN = 2,
	PSWPOUT = 3,
	PGALLOC_DMA = 4,
	PGALLOC_DMA32 = 5,
	PGALLOC_NORMAL = 6,
	PGALLOC_MOVABLE = 7,
	ALLOCSTALL_DMA = 8,
	ALLOCSTALL_DMA32 = 9,
	ALLOCSTALL_NORMAL = 10,
	ALLOCSTALL_MOVABLE = 11,
	PGSCAN_SKIP_DMA = 12,
	PGSCAN_SKIP_DMA32 = 13,
	PGSCAN_SKIP_NORMAL = 14,
	PGSCAN_SKIP_MOVABLE = 15,
	PGFREE = 16,
	PGACTIVATE = 17,
	PGDEACTIVATE = 18,
	PGLAZYFREE = 19,
	PGFAULT = 20,
	PGMAJFAULT = 21,
	PGLAZYFREED = 22,
	PGREFILL = 23,
	PGREUSE = 24,
	PGSTEAL_KSWAPD = 25,
	PGSTEAL_DIRECT = 26,
	PGSTEAL_KHUGEPAGED = 27,
	PGSCAN_KSWAPD = 28,
	PGSCAN_DIRECT = 29,
	PGSCAN_KHUGEPAGED = 30,
	PGSCAN_DIRECT_THROTTLE = 31,
	PGSCAN_ANON = 32,
	PGSCAN_FILE = 33,
	PGSTEAL_ANON = 34,
	PGSTEAL_FILE = 35,
	PGSCAN_ZONE_RECLAIM_SUCCESS = 36,
	PGSCAN_ZONE_RECLAIM_FAILED = 37,
	PGINODESTEAL = 38,
	SLABS_SCANNED = 39,
	KSWAPD_INODESTEAL = 40,
	KSWAPD_LOW_WMARK_HIT_QUICKLY = 41,
	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 42,
	PAGEOUTRUN = 43,
	PGROTATED = 44,
	DROP_PAGECACHE = 45,
	DROP_SLAB = 46,
	OOM_KILL = 47,
	PGMIGRATE_SUCCESS = 48,
	PGMIGRATE_FAIL = 49,
	THP_MIGRATION_SUCCESS = 50,
	THP_MIGRATION_FAIL = 51,
	THP_MIGRATION_SPLIT = 52,
	COMPACTMIGRATE_SCANNED = 53,
	COMPACTFREE_SCANNED = 54,
	COMPACTISOLATED = 55,
	COMPACTSTALL = 56,
	COMPACTFAIL = 57,
	COMPACTSUCCESS = 58,
	KCOMPACTD_WAKE = 59,
	KCOMPACTD_MIGRATE_SCANNED = 60,
	KCOMPACTD_FREE_SCANNED = 61,
	HTLB_BUDDY_PGALLOC = 62,
	HTLB_BUDDY_PGALLOC_FAIL = 63,
	UNEVICTABLE_PGCULLED = 64,
	UNEVICTABLE_PGSCANNED = 65,
	UNEVICTABLE_PGRESCUED = 66,
	UNEVICTABLE_PGMLOCKED = 67,
	UNEVICTABLE_PGMUNLOCKED = 68,
	UNEVICTABLE_PGCLEARED = 69,
	UNEVICTABLE_PGSTRANDED = 70,
	SWAP_RA = 71,
	SWAP_RA_HIT = 72,
	SWPIN_ZERO = 73,
	SWPOUT_ZERO = 74,
	DIRECT_MAP_LEVEL2_SPLIT = 75,
	DIRECT_MAP_LEVEL3_SPLIT = 76,
	KSTACK_1K = 77,
	KSTACK_2K = 78,
	KSTACK_4K = 79,
	KSTACK_8K = 80,
	KSTACK_16K = 81,
	NR_VM_EVENT_ITEMS = 82,
};

enum vm_fault_reason {
	VM_FAULT_OOM = 1,
	VM_FAULT_SIGBUS = 2,
	VM_FAULT_MAJOR = 4,
	VM_FAULT_HWPOISON = 16,
	VM_FAULT_HWPOISON_LARGE = 32,
	VM_FAULT_SIGSEGV = 64,
	VM_FAULT_NOPAGE = 256,
	VM_FAULT_LOCKED = 512,
	VM_FAULT_RETRY = 1024,
	VM_FAULT_FALLBACK = 2048,
	VM_FAULT_DONE_COW = 4096,
	VM_FAULT_NEEDDSYNC = 8192,
	VM_FAULT_COMPLETED = 16384,
	VM_FAULT_HINDEX_MASK = 983040,
};

enum vm_stat_item {
	NR_DIRTY_THRESHOLD = 0,
	NR_DIRTY_BG_THRESHOLD = 1,
	NR_MEMMAP_PAGES = 2,
	NR_MEMMAP_BOOT_PAGES = 3,
	NR_VM_STAT_ITEMS = 4,
};

enum vma_merge_flags {
	VMG_FLAG_DEFAULT = 0,
	VMG_FLAG_JUST_EXPAND = 1,
};

enum vma_merge_state {
	VMA_MERGE_START = 0,
	VMA_MERGE_ERROR_NOMEM = 1,
	VMA_MERGE_NOMERGE = 2,
	VMA_MERGE_SUCCESS = 3,
};

enum vma_resv_mode {
	VMA_NEEDS_RESV = 0,
	VMA_COMMIT_RESV = 1,
	VMA_END_RESV = 2,
	VMA_ADD_RESV = 3,
	VMA_DEL_RESV = 4,
};

enum vmpressure_levels {
	VMPRESSURE_LOW = 0,
	VMPRESSURE_MEDIUM = 1,
	VMPRESSURE_CRITICAL = 2,
	VMPRESSURE_NUM_LEVELS = 3,
};

enum vmpressure_modes {
	VMPRESSURE_NO_PASSTHROUGH = 0,
	VMPRESSURE_HIERARCHY = 1,
	VMPRESSURE_LOCAL = 2,
	VMPRESSURE_NUM_MODES = 3,
};

enum vmscan_throttle_state {
	VMSCAN_THROTTLE_WRITEBACK = 0,
	VMSCAN_THROTTLE_ISOLATED = 1,
	VMSCAN_THROTTLE_NOPROGRESS = 2,
	VMSCAN_THROTTLE_CONGESTED = 3,
	NR_VMSCAN_THROTTLE = 4,
};

enum vmx_feature_leafs {
	MISC_FEATURES = 0,
	PRIMARY_CTLS = 1,
	SECONDARY_CTLS = 2,
	TERTIARY_CTLS_LOW = 3,
	TERTIARY_CTLS_HIGH = 4,
	NR_VMX_FEATURE_WORDS = 5,
};

enum vmx_l1d_flush_state {
	VMENTER_L1D_FLUSH_AUTO = 0,
	VMENTER_L1D_FLUSH_NEVER = 1,
	VMENTER_L1D_FLUSH_COND = 2,
	VMENTER_L1D_FLUSH_ALWAYS = 3,
	VMENTER_L1D_FLUSH_EPT_DISABLED = 4,
	VMENTER_L1D_FLUSH_NOT_REQUIRED = 5,
};

enum vp_vq_vector_policy {
	VP_VQ_VECTOR_POLICY_EACH = 0,
	VP_VQ_VECTOR_POLICY_SHARED_SLOW = 1,
	VP_VQ_VECTOR_POLICY_SHARED = 2,
};

enum wb_reason {
	WB_REASON_BACKGROUND = 0,
	WB_REASON_VMSCAN = 1,
	WB_REASON_SYNC = 2,
	WB_REASON_PERIODIC = 3,
	WB_REASON_LAPTOP_TIMER = 4,
	WB_REASON_FS_FREE_SPACE = 5,
	WB_REASON_FORKER_THREAD = 6,
	WB_REASON_FOREIGN_FLUSH = 7,
	WB_REASON_MAX = 8,
};

enum wb_stat_item {
	WB_RECLAIMABLE = 0,
	WB_WRITEBACK = 1,
	WB_DIRTIED = 2,
	WB_WRITTEN = 3,
	NR_WB_STAT_ITEMS = 4,
};

enum wb_state {
	WB_registered = 0,
	WB_writeback_running = 1,
	WB_has_dirty_io = 2,
	WB_start_all = 3,
};

enum wd_read_status {
	WD_READ_SUCCESS = 0,
	WD_READ_UNSTABLE = 1,
	WD_READ_SKIP = 2,
};

enum wdrr_bucket_idx {
	WDRR_BUCKET_FOR_HH = 0,
	WDRR_BUCKET_FOR_NON_HH = 1,
};

enum which_selector {
	FS = 0,
	GS = 1,
};

enum why_no_delegation4 {
	WND4_NOT_WANTED = 0,
	WND4_CONTENTION = 1,
	WND4_RESOURCE = 2,
	WND4_NOT_SUPP_FTYPE = 3,
	WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,
	WND4_NOT_SUPP_UPGRADE = 5,
	WND4_NOT_SUPP_DOWNGRADE = 6,
	WND4_CANCELLED = 7,
	WND4_IS_DIR = 8,
};

enum wmi_brightness_method {
	WMI_BRIGHTNESS_METHOD_LEVEL = 1,
	WMI_BRIGHTNESS_METHOD_SOURCE = 2,
	WMI_BRIGHTNESS_METHOD_MAX = 3,
};

enum wmi_brightness_mode {
	WMI_BRIGHTNESS_MODE_GET = 0,
	WMI_BRIGHTNESS_MODE_SET = 1,
	WMI_BRIGHTNESS_MODE_GET_MAX_LEVEL = 2,
	WMI_BRIGHTNESS_MODE_MAX = 3,
};

enum wmi_brightness_source {
	WMI_BRIGHTNESS_SOURCE_GPU = 1,
	WMI_BRIGHTNESS_SOURCE_EC = 2,
	WMI_BRIGHTNESS_SOURCE_AUX = 3,
	WMI_BRIGHTNESS_SOURCE_MAX = 4,
};

enum work_bits {
	WORK_STRUCT_PENDING_BIT = 0,
	WORK_STRUCT_INACTIVE_BIT = 1,
	WORK_STRUCT_PWQ_BIT = 2,
	WORK_STRUCT_LINKED_BIT = 3,
	WORK_STRUCT_FLAG_BITS = 4,
	WORK_STRUCT_COLOR_SHIFT = 4,
	WORK_STRUCT_COLOR_BITS = 4,
	WORK_STRUCT_PWQ_SHIFT = 8,
	WORK_OFFQ_FLAG_SHIFT = 4,
	WORK_OFFQ_BH_BIT = 4,
	WORK_OFFQ_FLAG_END = 5,
	WORK_OFFQ_FLAG_BITS = 1,
	WORK_OFFQ_DISABLE_SHIFT = 5,
	WORK_OFFQ_DISABLE_BITS = 16,
	WORK_OFFQ_POOL_SHIFT = 21,
	WORK_OFFQ_LEFT = 43,
	WORK_OFFQ_POOL_BITS = 31,
};

enum work_cancel_flags {
	WORK_CANCEL_DELAYED = 1,
	WORK_CANCEL_DISABLE = 2,
};

enum work_flags {
	WORK_STRUCT_PENDING = 1,
	WORK_STRUCT_INACTIVE = 2,
	WORK_STRUCT_PWQ = 4,
	WORK_STRUCT_LINKED = 8,
	WORK_STRUCT_STATIC = 0,
};

enum worker_flags {
	WORKER_DIE = 2,
	WORKER_IDLE = 4,
	WORKER_PREP = 8,
	WORKER_CPU_INTENSIVE = 64,
	WORKER_UNBOUND = 128,
	WORKER_REBOUND = 256,
	WORKER_NOT_RUNNING = 456,
};

enum worker_pool_flags {
	POOL_BH = 1,
	POOL_MANAGER_ACTIVE = 2,
	POOL_DISASSOCIATED = 4,
	POOL_BH_DRAINING = 8,
};

enum wq_affn_scope {
	WQ_AFFN_DFL = 0,
	WQ_AFFN_CPU = 1,
	WQ_AFFN_SMT = 2,
	WQ_AFFN_CACHE = 3,
	WQ_AFFN_NUMA = 4,
	WQ_AFFN_SYSTEM = 5,
	WQ_AFFN_NR_TYPES = 6,
};

enum wq_consts {
	WQ_MAX_ACTIVE = 2048,
	WQ_UNBOUND_MAX_ACTIVE = 2048,
	WQ_DFL_ACTIVE = 1024,
	WQ_DFL_MIN_ACTIVE = 8,
};

enum wq_flags {
	WQ_BH = 1,
	WQ_UNBOUND = 2,
	WQ_FREEZABLE = 4,
	WQ_MEM_RECLAIM = 8,
	WQ_HIGHPRI = 16,
	WQ_CPU_INTENSIVE = 32,
	WQ_SYSFS = 64,
	WQ_POWER_EFFICIENT = 128,
	__WQ_DESTROYING = 32768,
	__WQ_DRAINING = 65536,
	__WQ_ORDERED = 131072,
	__WQ_LEGACY = 262144,
	__WQ_BH_ALLOWS = 17,
};

enum wq_internal_consts {
	NR_STD_WORKER_POOLS = 2,
	UNBOUND_POOL_HASH_ORDER = 6,
	BUSY_WORKER_HASH_ORDER = 6,
	MAX_IDLE_WORKERS_RATIO = 4,
	IDLE_WORKER_TIMEOUT = 300000,
	MAYDAY_INITIAL_TIMEOUT = 10,
	MAYDAY_INTERVAL = 100,
	CREATE_COOLDOWN = 1000,
	RESCUER_NICE_LEVEL = -20,
	HIGHPRI_NICE_LEVEL = -20,
	WQ_NAME_LEN = 32,
	WORKER_ID_LEN = 42,
};

enum wq_misc_consts {
	WORK_NR_COLORS = 16,
	WORK_CPU_UNBOUND = 64,
	WORK_BUSY_PENDING = 1,
	WORK_BUSY_RUNNING = 2,
	WORKER_DESC_LEN = 32,
};

enum writeback_sync_modes {
	WB_SYNC_NONE = 0,
	WB_SYNC_ALL = 1,
};

enum x509_actions {
	ACT_x509_extract_key_data = 0,
	ACT_x509_extract_name_segment = 1,
	ACT_x509_note_OID = 2,
	ACT_x509_note_issuer = 3,
	ACT_x509_note_not_after = 4,
	ACT_x509_note_not_before = 5,
	ACT_x509_note_params = 6,
	ACT_x509_note_serial = 7,
	ACT_x509_note_sig_algo = 8,
	ACT_x509_note_signature = 9,
	ACT_x509_note_subject = 10,
	ACT_x509_note_tbs_certificate = 11,
	ACT_x509_process_extension = 12,
	NR__x509_actions = 13,
};

enum x509_akid_actions {
	ACT_x509_akid_note_kid = 0,
	ACT_x509_akid_note_name = 1,
	ACT_x509_akid_note_serial = 2,
	ACT_x509_extract_name_segment___2 = 3,
	ACT_x509_note_OID___2 = 4,
	NR__x509_akid_actions = 5,
};

enum x86_hardware_subarch {
	X86_SUBARCH_PC = 0,
	X86_SUBARCH_LGUEST = 1,
	X86_SUBARCH_XEN = 2,
	X86_SUBARCH_INTEL_MID = 3,
	X86_SUBARCH_CE4100 = 4,
	X86_NR_SUBARCHS = 5,
};

enum x86_hypervisor_type {
	X86_HYPER_NATIVE = 0,
	X86_HYPER_VMWARE = 1,
	X86_HYPER_MS_HYPERV = 2,
	X86_HYPER_XEN_PV = 3,
	X86_HYPER_XEN_HVM = 4,
	X86_HYPER_KVM = 5,
	X86_HYPER_JAILHOUSE = 6,
	X86_HYPER_ACRN = 7,
};

enum x86_intercept_stage;

enum x86_legacy_i8042_state {
	X86_LEGACY_I8042_PLATFORM_ABSENT = 0,
	X86_LEGACY_I8042_FIRMWARE_ABSENT = 1,
	X86_LEGACY_I8042_EXPECTED_PRESENT = 2,
};

enum x86_pf_error_code {
	X86_PF_PROT = 1,
	X86_PF_WRITE = 2,
	X86_PF_USER = 4,
	X86_PF_RSVD = 8,
	X86_PF_INSTR = 16,
	X86_PF_PK = 32,
	X86_PF_SHSTK = 64,
	X86_PF_SGX = 32768,
	X86_PF_RMP = 2147483648,
};

enum x86_regset_32 {
	REGSET32_GENERAL = 0,
	REGSET32_FP = 1,
	REGSET32_XFP = 2,
	REGSET32_XSTATE = 3,
	REGSET32_TLS = 4,
	REGSET32_IOPERM = 5,
};

enum x86_regset_64 {
	REGSET64_GENERAL = 0,
	REGSET64_FP = 1,
	REGSET64_IOPERM = 2,
	REGSET64_XSTATE = 3,
	REGSET64_SSP = 4,
};

enum x86_topology_cpu_type {
	TOPO_CPU_TYPE_PERFORMANCE = 0,
	TOPO_CPU_TYPE_EFFICIENCY = 1,
	TOPO_CPU_TYPE_UNKNOWN = 2,
};

enum x86_topology_domains {
	TOPO_SMT_DOMAIN = 0,
	TOPO_CORE_DOMAIN = 1,
	TOPO_MODULE_DOMAIN = 2,
	TOPO_TILE_DOMAIN = 3,
	TOPO_DIE_DOMAIN = 4,
	TOPO_DIEGRP_DOMAIN = 5,
	TOPO_PKG_DOMAIN = 6,
	TOPO_MAX_DOMAIN = 7,
};

enum xa_lock_type {
	XA_LOCK_IRQ = 1,
	XA_LOCK_BH = 2,
};

enum xbtree_key_contig {
	XBTREE_KEY_GAP = 0,
	XBTREE_KEY_CONTIGUOUS = 1,
	XBTREE_KEY_OVERLAP = 2,
};

enum xbtree_recpacking {
	XBTREE_RECPACKING_EMPTY = 0,
	XBTREE_RECPACKING_SPARSE = 1,
	XBTREE_RECPACKING_FULL = 2,
};

enum xchk_dirpath_outcome {
	XCHK_DIRPATH_SCANNING = 0,
	XCHK_DIRPATH_DELETE = 1,
	XCHK_DIRPATH_CORRUPT = 2,
	XCHK_DIRPATH_LOOP = 3,
	XCHK_DIRPATH_STALE = 4,
	XCHK_DIRPATH_OK = 5,
	XREP_DIRPATH_DELETING = 6,
	XREP_DIRPATH_DELETED = 7,
	XREP_DIRPATH_ADOPTING = 8,
	XREP_DIRPATH_ADOPTED = 9,
};

enum xchk_health_group {
	XHG_NONE = 1,
	XHG_FS = 2,
	XHG_AG = 3,
	XHG_INO = 4,
	XHG_RTGROUP = 5,
};

enum xchk_type {
	ST_NONE = 1,
	ST_PERAG = 2,
	ST_FS = 3,
	ST_INODE = 4,
	ST_GENERIC = 5,
	ST_RTGROUP = 6,
};

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

enum xdp_buff_flags {
	XDP_FLAGS_HAS_FRAGS = 1,
	XDP_FLAGS_FRAGS_PF_MEMALLOC = 2,
};

enum xdp_mem_type {
	MEM_TYPE_PAGE_SHARED = 0,
	MEM_TYPE_PAGE_ORDER0 = 1,
	MEM_TYPE_PAGE_POOL = 2,
	MEM_TYPE_XSK_BUFF_POOL = 3,
	MEM_TYPE_MAX = 4,
};

enum xdp_rss_hash_type {
	XDP_RSS_L3_IPV4 = 1,
	XDP_RSS_L3_IPV6 = 2,
	XDP_RSS_L3_DYNHDR = 4,
	XDP_RSS_L4 = 8,
	XDP_RSS_L4_TCP = 16,
	XDP_RSS_L4_UDP = 32,
	XDP_RSS_L4_SCTP = 64,
	XDP_RSS_L4_IPSEC = 128,
	XDP_RSS_L4_ICMP = 256,
	XDP_RSS_TYPE_NONE = 0,
	XDP_RSS_TYPE_L2 = 0,
	XDP_RSS_TYPE_L3_IPV4 = 1,
	XDP_RSS_TYPE_L3_IPV6 = 2,
	XDP_RSS_TYPE_L3_IPV4_OPT = 5,
	XDP_RSS_TYPE_L3_IPV6_EX = 6,
	XDP_RSS_TYPE_L4_ANY = 8,
	XDP_RSS_TYPE_L4_IPV4_TCP = 25,
	XDP_RSS_TYPE_L4_IPV4_UDP = 41,
	XDP_RSS_TYPE_L4_IPV4_SCTP = 73,
	XDP_RSS_TYPE_L4_IPV4_IPSEC = 137,
	XDP_RSS_TYPE_L4_IPV4_ICMP = 265,
	XDP_RSS_TYPE_L4_IPV6_TCP = 26,
	XDP_RSS_TYPE_L4_IPV6_UDP = 42,
	XDP_RSS_TYPE_L4_IPV6_SCTP = 74,
	XDP_RSS_TYPE_L4_IPV6_IPSEC = 138,
	XDP_RSS_TYPE_L4_IPV6_ICMP = 266,
	XDP_RSS_TYPE_L4_IPV6_TCP_EX = 30,
	XDP_RSS_TYPE_L4_IPV6_UDP_EX = 46,
	XDP_RSS_TYPE_L4_IPV6_SCTP_EX = 78,
};

enum xdp_rx_metadata {
	XDP_METADATA_KFUNC_RX_TIMESTAMP = 0,
	XDP_METADATA_KFUNC_RX_HASH = 1,
	XDP_METADATA_KFUNC_RX_VLAN_TAG = 2,
	MAX_XDP_METADATA_KFUNC = 3,
};

enum xen_domain_type {
	XEN_NATIVE = 0,
	XEN_PV_DOMAIN = 1,
	XEN_HVM_DOMAIN = 2,
};

enum xfeature {
	XFEATURE_FP = 0,
	XFEATURE_SSE = 1,
	XFEATURE_YMM = 2,
	XFEATURE_BNDREGS = 3,
	XFEATURE_BNDCSR = 4,
	XFEATURE_OPMASK = 5,
	XFEATURE_ZMM_Hi256 = 6,
	XFEATURE_Hi16_ZMM = 7,
	XFEATURE_PT_UNIMPLEMENTED_SO_FAR = 8,
	XFEATURE_PKRU = 9,
	XFEATURE_PASID = 10,
	XFEATURE_CET_USER = 11,
	XFEATURE_CET_KERNEL_UNUSED = 12,
	XFEATURE_RSRVD_COMP_13 = 13,
	XFEATURE_RSRVD_COMP_14 = 14,
	XFEATURE_LBR = 15,
	XFEATURE_RSRVD_COMP_16 = 16,
	XFEATURE_XTILE_CFG = 17,
	XFEATURE_XTILE_DATA = 18,
	XFEATURE_MAX = 19,
};

enum xfrm_ae_ftype_t {
	XFRM_AE_UNSPEC = 0,
	XFRM_AE_RTHR = 1,
	XFRM_AE_RVAL = 2,
	XFRM_AE_LVAL = 4,
	XFRM_AE_ETHR = 8,
	XFRM_AE_CR = 16,
	XFRM_AE_CE = 32,
	XFRM_AE_CU = 64,
	__XFRM_AE_MAX = 65,
};

enum xfrm_attr_type_t {
	XFRMA_UNSPEC = 0,
	XFRMA_ALG_AUTH = 1,
	XFRMA_ALG_CRYPT = 2,
	XFRMA_ALG_COMP = 3,
	XFRMA_ENCAP = 4,
	XFRMA_TMPL = 5,
	XFRMA_SA = 6,
	XFRMA_POLICY = 7,
	XFRMA_SEC_CTX = 8,
	XFRMA_LTIME_VAL = 9,
	XFRMA_REPLAY_VAL = 10,
	XFRMA_REPLAY_THRESH = 11,
	XFRMA_ETIMER_THRESH = 12,
	XFRMA_SRCADDR = 13,
	XFRMA_COADDR = 14,
	XFRMA_LASTUSED = 15,
	XFRMA_POLICY_TYPE = 16,
	XFRMA_MIGRATE = 17,
	XFRMA_ALG_AEAD = 18,
	XFRMA_KMADDRESS = 19,
	XFRMA_ALG_AUTH_TRUNC = 20,
	XFRMA_MARK = 21,
	XFRMA_TFCPAD = 22,
	XFRMA_REPLAY_ESN_VAL = 23,
	XFRMA_SA_EXTRA_FLAGS = 24,
	XFRMA_PROTO = 25,
	XFRMA_ADDRESS_FILTER = 26,
	XFRMA_PAD = 27,
	XFRMA_OFFLOAD_DEV = 28,
	XFRMA_SET_MARK = 29,
	XFRMA_SET_MARK_MASK = 30,
	XFRMA_IF_ID = 31,
	XFRMA_MTIMER_THRESH = 32,
	XFRMA_SA_DIR = 33,
	XFRMA_NAT_KEEPALIVE_INTERVAL = 34,
	XFRMA_SA_PCPU = 35,
	XFRMA_IPTFS_DROP_TIME = 36,
	XFRMA_IPTFS_REORDER_WINDOW = 37,
	XFRMA_IPTFS_DONT_FRAG = 38,
	XFRMA_IPTFS_INIT_DELAY = 39,
	XFRMA_IPTFS_MAX_QSIZE = 40,
	XFRMA_IPTFS_PKT_SIZE = 41,
	__XFRMA_MAX = 42,
};

enum xfrm_nlgroups {
	XFRMNLGRP_NONE = 0,
	XFRMNLGRP_ACQUIRE = 1,
	XFRMNLGRP_EXPIRE = 2,
	XFRMNLGRP_SA = 3,
	XFRMNLGRP_POLICY = 4,
	XFRMNLGRP_AEVENTS = 5,
	XFRMNLGRP_REPORT = 6,
	XFRMNLGRP_MIGRATE = 7,
	XFRMNLGRP_MAPPING = 8,
	__XFRMNLGRP_MAX = 9,
};

enum xfrm_pol_inexact_candidate_type {
	XFRM_POL_CAND_BOTH = 0,
	XFRM_POL_CAND_SADDR = 1,
	XFRM_POL_CAND_DADDR = 2,
	XFRM_POL_CAND_ANY = 3,
	XFRM_POL_CAND_MAX = 4,
};

enum xfrm_replay_mode {
	XFRM_REPLAY_MODE_LEGACY = 0,
	XFRM_REPLAY_MODE_BMP = 1,
	XFRM_REPLAY_MODE_ESN = 2,
};

enum xfrm_sa_dir {
	XFRM_SA_DIR_IN = 1,
	XFRM_SA_DIR_OUT = 2,
};

enum xfrm_sadattr_type_t {
	XFRMA_SAD_UNSPEC = 0,
	XFRMA_SAD_CNT = 1,
	XFRMA_SAD_HINFO = 2,
	__XFRMA_SAD_MAX = 3,
};

enum xfrm_spdattr_type_t {
	XFRMA_SPD_UNSPEC = 0,
	XFRMA_SPD_INFO = 1,
	XFRMA_SPD_HINFO = 2,
	XFRMA_SPD_IPV4_HTHRESH = 3,
	XFRMA_SPD_IPV6_HTHRESH = 4,
	__XFRMA_SPD_MAX = 5,
};

enum xfs_ag_resv_type {
	XFS_AG_RESV_NONE = 0,
	XFS_AG_RESV_AGFL = 1,
	XFS_AG_RESV_METADATA = 2,
	XFS_AG_RESV_RMAPBT = 3,
	XFS_AG_RESV_IGNORE = 4,
	XFS_AG_RESV_METAFILE = 5,
};

enum xfs_apply_dqtrx_type {
	XFS_APPLY_DQTRX_COMMIT = 0,
	XFS_APPLY_DQTRX_UNRESERVE = 1,
};

enum xfs_attr_defer_op {
	XFS_ATTR_DEFER_SET = 0,
	XFS_ATTR_DEFER_REMOVE = 1,
	XFS_ATTR_DEFER_REPLACE = 2,
};

enum xfs_attr_update {
	XFS_ATTRUPDATE_REMOVE = 0,
	XFS_ATTRUPDATE_UPSERT = 1,
	XFS_ATTRUPDATE_CREATE = 2,
	XFS_ATTRUPDATE_REPLACE = 3,
};

enum xfs_blft {
	XFS_BLFT_UNKNOWN_BUF = 0,
	XFS_BLFT_UDQUOT_BUF = 1,
	XFS_BLFT_PDQUOT_BUF = 2,
	XFS_BLFT_GDQUOT_BUF = 3,
	XFS_BLFT_BTREE_BUF = 4,
	XFS_BLFT_AGF_BUF = 5,
	XFS_BLFT_AGFL_BUF = 6,
	XFS_BLFT_AGI_BUF = 7,
	XFS_BLFT_DINO_BUF = 8,
	XFS_BLFT_SYMLINK_BUF = 9,
	XFS_BLFT_DIR_BLOCK_BUF = 10,
	XFS_BLFT_DIR_DATA_BUF = 11,
	XFS_BLFT_DIR_FREE_BUF = 12,
	XFS_BLFT_DIR_LEAF1_BUF = 13,
	XFS_BLFT_DIR_LEAFN_BUF = 14,
	XFS_BLFT_DA_NODE_BUF = 15,
	XFS_BLFT_ATTR_LEAF_BUF = 16,
	XFS_BLFT_ATTR_RMT_BUF = 17,
	XFS_BLFT_SB_BUF = 18,
	XFS_BLFT_RTBITMAP_BUF = 19,
	XFS_BLFT_RTSUMMARY_BUF = 20,
	XFS_BLFT_MAX_BUF = 32,
};

enum xfs_bmap_intent_type {
	XFS_BMAP_MAP = 1,
	XFS_BMAP_UNMAP = 2,
};

enum xfs_btree_type {
	XFS_BTREE_TYPE_AG = 0,
	XFS_BTREE_TYPE_INODE = 1,
	XFS_BTREE_TYPE_MEM = 2,
};

enum xfs_dacmp {
	XFS_CMP_DIFFERENT = 0,
	XFS_CMP_EXACT = 1,
	XFS_CMP_CASE = 2,
};

enum xfs_dax_mode {
	XFS_DAX_INODE = 0,
	XFS_DAX_ALWAYS = 1,
	XFS_DAX_NEVER = 2,
};

enum xfs_delattr_state {
	XFS_DAS_UNINIT = 0,
	XFS_DAS_SF_ADD = 1,
	XFS_DAS_SF_REMOVE = 2,
	XFS_DAS_LEAF_ADD = 3,
	XFS_DAS_LEAF_REMOVE = 4,
	XFS_DAS_NODE_ADD = 5,
	XFS_DAS_NODE_REMOVE = 6,
	XFS_DAS_LEAF_SET_RMT = 7,
	XFS_DAS_LEAF_ALLOC_RMT = 8,
	XFS_DAS_LEAF_REPLACE = 9,
	XFS_DAS_LEAF_REMOVE_OLD = 10,
	XFS_DAS_LEAF_REMOVE_RMT = 11,
	XFS_DAS_LEAF_REMOVE_ATTR = 12,
	XFS_DAS_NODE_SET_RMT = 13,
	XFS_DAS_NODE_ALLOC_RMT = 14,
	XFS_DAS_NODE_REPLACE = 15,
	XFS_DAS_NODE_REMOVE_OLD = 16,
	XFS_DAS_NODE_REMOVE_RMT = 17,
	XFS_DAS_NODE_REMOVE_ATTR = 18,
	XFS_DAS_DONE = 19,
};

enum xfs_dinode_fmt {
	XFS_DINODE_FMT_DEV = 0,
	XFS_DINODE_FMT_LOCAL = 1,
	XFS_DINODE_FMT_EXTENTS = 2,
	XFS_DINODE_FMT_BTREE = 3,
	XFS_DINODE_FMT_UUID = 4,
	XFS_DINODE_FMT_META_BTREE = 5,
};

enum xfs_dir2_fmt {
	XFS_DIR2_FMT_SF = 0,
	XFS_DIR2_FMT_BLOCK = 1,
	XFS_DIR2_FMT_LEAF = 2,
	XFS_DIR2_FMT_NODE = 3,
	XFS_DIR2_FMT_ERROR = 4,
};

enum xfs_experimental_feat {
	XFS_EXPERIMENTAL_PNFS = 0,
	XFS_EXPERIMENTAL_SCRUB = 1,
	XFS_EXPERIMENTAL_SHRINK = 2,
	XFS_EXPERIMENTAL_LARP = 3,
	XFS_EXPERIMENTAL_LBS = 4,
	XFS_EXPERIMENTAL_EXCHRANGE = 5,
	XFS_EXPERIMENTAL_PPTR = 6,
	XFS_EXPERIMENTAL_METADIR = 7,
	XFS_EXPERIMENTAL_MAX = 8,
};

enum xfs_fstrm_alloc {
	XFS_PICK_USERDATA = 1,
	XFS_PICK_LOWSPACE = 2,
};

enum xfs_group_type {
	XG_TYPE_AG = 0,
	XG_TYPE_RTG = 1,
	XG_TYPE_MAX = 2,
} __attribute__((mode(byte)));

enum xfs_icwalk_goal {
	XFS_ICWALK_BLOCKGC = 1,
	XFS_ICWALK_RECLAIM = 0,
};

enum xfs_metafile_type {
	XFS_METAFILE_UNKNOWN = 0,
	XFS_METAFILE_DIR = 1,
	XFS_METAFILE_USRQUOTA = 2,
	XFS_METAFILE_GRPQUOTA = 3,
	XFS_METAFILE_PRJQUOTA = 4,
	XFS_METAFILE_RTBITMAP = 5,
	XFS_METAFILE_RTSUMMARY = 6,
	XFS_METAFILE_RTRMAP = 7,
	XFS_METAFILE_RTREFCOUNT = 8,
	XFS_METAFILE_MAX = 9,
} __attribute__((mode(byte)));

enum xfs_refc_adjust_op {
	XFS_REFCOUNT_ADJUST_INCREASE = 1,
	XFS_REFCOUNT_ADJUST_DECREASE = -1,
	XFS_REFCOUNT_ADJUST_COW_ALLOC = 0,
	XFS_REFCOUNT_ADJUST_COW_FREE = -1,
};

enum xfs_refc_domain {
	XFS_REFC_DOMAIN_SHARED = 0,
	XFS_REFC_DOMAIN_COW = 1,
};

enum xfs_refcount_intent_type {
	XFS_REFCOUNT_INCREASE = 1,
	XFS_REFCOUNT_DECREASE = 2,
	XFS_REFCOUNT_ALLOC_COW = 3,
	XFS_REFCOUNT_FREE_COW = 4,
};

enum xfs_rmap_intent_type {
	XFS_RMAP_MAP = 0,
	XFS_RMAP_MAP_SHARED = 1,
	XFS_RMAP_UNMAP = 2,
	XFS_RMAP_UNMAP_SHARED = 3,
	XFS_RMAP_CONVERT = 4,
	XFS_RMAP_CONVERT_SHARED = 5,
	XFS_RMAP_ALLOC = 6,
	XFS_RMAP_FREE = 7,
};

enum xfs_rtg_inodes {
	XFS_RTGI_BITMAP = 0,
	XFS_RTGI_SUMMARY = 1,
	XFS_RTGI_RMAP = 2,
	XFS_RTGI_REFCOUNT = 3,
	XFS_RTGI_MAX = 4,
};

enum xlog_iclog_state {
	XLOG_STATE_ACTIVE = 0,
	XLOG_STATE_WANT_SYNC = 1,
	XLOG_STATE_SYNCING = 2,
	XLOG_STATE_DONE_SYNC = 3,
	XLOG_STATE_CALLBACK = 4,
	XLOG_STATE_DIRTY = 5,
};

enum xlog_recover_reorder {
	XLOG_REORDER_BUFFER_LIST = 0,
	XLOG_REORDER_ITEM_LIST = 1,
	XLOG_REORDER_INODE_BUFFER_LIST = 2,
	XLOG_REORDER_CANCEL_LIST = 3,
};

enum xprt_transports {
	XPRT_TRANSPORT_UDP = 17,
	XPRT_TRANSPORT_TCP = 6,
	XPRT_TRANSPORT_BC_TCP = -2147483642,
	XPRT_TRANSPORT_RDMA = 256,
	XPRT_TRANSPORT_BC_RDMA = -2147483392,
	XPRT_TRANSPORT_LOCAL = 257,
	XPRT_TRANSPORT_TCP_TLS = 258,
};

enum xprt_xid_rb_cmp {
	XID_RB_EQUAL = 0,
	XID_RB_LEFT = 1,
	XID_RB_RIGHT = 2,
};

enum xprtsec_policies {
	RPC_XPRTSEC_NONE = 0,
	RPC_XPRTSEC_TLS_ANON = 1,
	RPC_XPRTSEC_TLS_X509 = 2,
};

enum xps_map_type {
	XPS_CPUS = 0,
	XPS_RXQS = 1,
	XPS_MAPS_MAX = 2,
};

enum xstate_copy_mode {
	XSTATE_COPY_FP = 0,
	XSTATE_COPY_FX = 1,
	XSTATE_COPY_XSAVE = 2,
};

enum xt_bpf_modes {
	XT_BPF_MODE_BYTECODE = 0,
	XT_BPF_MODE_FD_PINNED = 1,
	XT_BPF_MODE_FD_ELF = 2,
};

enum xt_cluster_flags {
	XT_CLUSTER_F_INV = 1,
};

enum xt_connbytes_direction {
	XT_CONNBYTES_DIR_ORIGINAL = 0,
	XT_CONNBYTES_DIR_REPLY = 1,
	XT_CONNBYTES_DIR_BOTH = 2,
};

enum xt_connbytes_what {
	XT_CONNBYTES_PKTS = 0,
	XT_CONNBYTES_BYTES = 1,
	XT_CONNBYTES_AVGPKT = 2,
};

enum xt_connlabel_mtopts {
	XT_CONNLABEL_OP_INVERT = 1,
	XT_CONNLABEL_OP_SET = 2,
};

enum xt_devgroup_flags {
	XT_DEVGROUP_MATCH_SRC = 1,
	XT_DEVGROUP_INVERT_SRC = 2,
	XT_DEVGROUP_MATCH_DST = 4,
	XT_DEVGROUP_INVERT_DST = 8,
};

enum xt_l2tp_type {
	XT_L2TP_TYPE_CONTROL = 0,
	XT_L2TP_TYPE_DATA = 1,
};

enum xt_multiport_flags {
	XT_MULTIPORT_SOURCE = 0,
	XT_MULTIPORT_DESTINATION = 1,
	XT_MULTIPORT_EITHER = 2,
};

enum xt_policy_flags {
	XT_POLICY_MATCH_IN = 1,
	XT_POLICY_MATCH_OUT = 2,
	XT_POLICY_MATCH_NONE = 4,
	XT_POLICY_MATCH_STRICT = 8,
};

enum xt_quota_flags {
	XT_QUOTA_INVERT = 1,
};

enum xt_rateest_match_flags {
	XT_RATEEST_MATCH_INVERT = 1,
	XT_RATEEST_MATCH_ABS = 2,
	XT_RATEEST_MATCH_REL = 4,
	XT_RATEEST_MATCH_DELTA = 8,
	XT_RATEEST_MATCH_BPS = 16,
	XT_RATEEST_MATCH_PPS = 32,
};

enum xt_rateest_match_mode {
	XT_RATEEST_MATCH_NONE = 0,
	XT_RATEEST_MATCH_EQ = 1,
	XT_RATEEST_MATCH_LT = 2,
	XT_RATEEST_MATCH_GT = 3,
};

enum xt_statistic_flags {
	XT_STATISTIC_INVERT = 1,
};

enum xt_statistic_mode {
	XT_STATISTIC_MODE_RANDOM = 0,
	XT_STATISTIC_MODE_NTH = 1,
	__XT_STATISTIC_MODE_MAX = 2,
};

enum xt_u32_ops {
	XT_U32_AND = 0,
	XT_U32_LEFTSH = 1,
	XT_U32_RIGHTSH = 2,
	XT_U32_AT = 3,
};

enum xz_check {
	XZ_CHECK_NONE = 0,
	XZ_CHECK_CRC32 = 1,
	XZ_CHECK_CRC64 = 4,
	XZ_CHECK_SHA256 = 10,
};

enum xz_mode {
	XZ_SINGLE = 0,
	XZ_PREALLOC = 1,
	XZ_DYNALLOC = 2,
};

enum xz_ret {
	XZ_OK = 0,
	XZ_STREAM_END = 1,
	XZ_UNSUPPORTED_CHECK = 2,
	XZ_MEM_ERROR = 3,
	XZ_MEMLIMIT_ERROR = 4,
	XZ_FORMAT_ERROR = 5,
	XZ_OPTIONS_ERROR = 6,
	XZ_DATA_ERROR = 7,
	XZ_BUF_ERROR = 8,
};

enum zone_flags {
	ZONE_BOOSTED_WATERMARK = 0,
	ZONE_RECLAIM_ACTIVE = 1,
	ZONE_BELOW_HIGH = 2,
};

enum zone_stat_item {
	NR_FREE_PAGES = 0,
	NR_ZONE_LRU_BASE = 1,
	NR_ZONE_INACTIVE_ANON = 1,
	NR_ZONE_ACTIVE_ANON = 2,
	NR_ZONE_INACTIVE_FILE = 3,
	NR_ZONE_ACTIVE_FILE = 4,
	NR_ZONE_UNEVICTABLE = 5,
	NR_ZONE_WRITE_PENDING = 6,
	NR_MLOCK = 7,
	NR_BOUNCE = 8,
	NR_FREE_CMA_PAGES = 9,
	NR_VM_ZONE_STAT_ITEMS = 10,
};

enum zone_type {
	ZONE_DMA = 0,
	ZONE_DMA32 = 1,
	ZONE_NORMAL = 2,
	ZONE_MOVABLE = 3,
	__MAX_NR_ZONES = 4,
};

enum zone_watermarks {
	WMARK_MIN = 0,
	WMARK_LOW = 1,
	WMARK_HIGH = 2,
	WMARK_PROMO = 3,
	NR_WMARK = 4,
};

typedef _Bool bool;

typedef __int128 unsigned __u128;

typedef __u128 u128;

typedef u128 freelist_full_t;

typedef char acpi_bus_id[8];

typedef char acpi_device_class[20];

typedef char acpi_device_name[40];

typedef char *acpi_string;

typedef const char (* const ethnl_string_array_t)[32];

typedef int __kernel_clockid_t;

typedef int __kernel_daddr_t;

typedef int __kernel_ipc_pid_t;

typedef int __kernel_key_t;

typedef int __kernel_mqd_t;

typedef int __kernel_pid_t;

typedef int __kernel_rwf_t;

typedef int __kernel_timer_t;

typedef int __s32;

typedef int class_get_unused_fd_t;

typedef __kernel_clockid_t clockid_t;

typedef __s32 s32;

typedef s32 codel_tdiff_t;

typedef s32 compat_int_t;

typedef s32 compat_ssize_t;

typedef int cydp_t;

typedef s32 dma_cookie_t;

typedef int ext4_grpblk_t;

typedef int folio_walk_flags_t;

typedef int fpb_t;

typedef int fpi_t;

typedef int initcall_entry_t;

typedef int insn_value_t;

typedef s32 int32_t;

typedef int32_t key_serial_t;

typedef __kernel_key_t key_t;

typedef int mhp_t;

typedef int mpi_size_t;

typedef __kernel_mqd_t mqd_t;

typedef s32 old_time32_t;

typedef int pci_power_t;

typedef __kernel_pid_t pid_t;

typedef int rmap_t;

typedef __kernel_rwf_t rwf_t;

typedef __s32 sctp_assoc_t;

typedef int suspend_state_t;

typedef __kernel_timer_t timer_t;

typedef const int tracepoint_ptr_t;

typedef long int __kernel_long_t;

typedef __kernel_long_t __kernel_clock_t;

typedef __kernel_long_t __kernel_off_t;

typedef __kernel_long_t __kernel_old_time_t;

typedef __kernel_long_t __kernel_ptrdiff_t;

typedef __kernel_long_t __kernel_ssize_t;

typedef __kernel_long_t __kernel_suseconds_t;

typedef __kernel_clock_t clock_t;

typedef long int intptr_t;

typedef long int mpi_limb_signed_t;

typedef __kernel_off_t off_t;

typedef __kernel_ptrdiff_t ptrdiff_t;

typedef __kernel_ssize_t ssize_t;

typedef __kernel_suseconds_t suseconds_t;

typedef long long int __s64;

typedef __s64 Elf64_Sxword;

typedef long long int __kernel_loff_t;

typedef long long int __kernel_time64_t;

typedef __s64 s64;

typedef s64 compat_loff_t;

typedef s64 int64_t;

typedef s64 ktime_t;

typedef __kernel_loff_t loff_t;

typedef long long int qsize_t;

typedef __s64 time64_t;

typedef loff_t xfblob_cookie;

typedef int64_t xfs_csn_t;

typedef __s64 xfs_daddr_t;

typedef __s64 xfs_off_t;

typedef xfs_off_t xfs_dir2_off_t;

typedef int64_t xfs_fsize_t;

typedef int64_t xfs_lsn_t;

typedef long long unsigned int __u64;

typedef __u64 Elf64_Addr;

typedef __u64 Elf64_Off;

typedef __u64 Elf64_Xword;

typedef __u64 u64;

typedef u64 uint64_t;

typedef uint64_t U64;

typedef U64 ZSTD_VecMask;

typedef __u64 __addrpair;

typedef __u64 __be64;

typedef __u64 __le64;

typedef __u64 __virtio64;

typedef u64 acpi_bus_address;

typedef u64 acpi_integer;

typedef u64 acpi_io_address;

typedef u64 acpi_physical_address;

typedef u64 acpi_size;

typedef u64 async_cookie_t;

typedef __u64 blist_flags_t;

typedef u64 blkcnt_t;

typedef u64 clientid4;

typedef u64 compat_u64;

typedef long long unsigned int cycles_t;

typedef u64 dma_addr_t;

typedef long long unsigned int ext4_fsblk_t;

typedef u64 gen8_pte_t;

typedef u64 gfn_t;

typedef u64 gpa_t;

typedef u64 hfn_t;

typedef u64 hpa_t;

typedef u64 io_req_flags_t;

typedef hfn_t kvm_pfn_t;

typedef long long unsigned int llu;

typedef u64 netdev_features_t;

typedef u64 pci_bus_addr_t;

typedef u64 phys_addr_t;

typedef u64 psched_time_t;

typedef __u64 rds_rdma_cookie_t;

typedef u64 sector_t;

typedef sector_t region_t;

typedef phys_addr_t resource_size_t;

typedef u64 sci_t;

typedef __u64 timeu64_t;

typedef u64 u_int64_t;

typedef u64 unative_t;

typedef u64 upf_t;

typedef uint64_t vli_type;

typedef uint64_t xfarray_idx_t;

typedef uint64_t xfbno_t;

typedef __be64 xfs_bmbt_ptr_t;

typedef uint64_t xfs_bmbt_rec_base_t;

typedef uint64_t xfs_extnum_t;

typedef uint64_t xfs_filblks_t;

typedef uint64_t xfs_fileoff_t;

typedef uint64_t xfs_fsblock_t;

typedef long long unsigned int xfs_ino_t;

typedef uint64_t xfs_inofree_t;

typedef uint64_t xfs_log_timestamp_t;

typedef uint64_t xfs_qcnt_t;

typedef uint64_t xfs_rfsblock_t;

typedef uint64_t xfs_rtblock_t;

typedef uint64_t xfs_rtbxlen_t;

typedef __be64 xfs_rtrefcount_ptr_t;

typedef __be64 xfs_rtrmap_ptr_t;

typedef uint64_t xfs_rtxnum_t;

typedef __be64 xfs_timestamp_t;

typedef uint64_t xfs_ufsize_t;

typedef long unsigned int __kernel_ulong_t;

typedef __kernel_ulong_t __kernel_size_t;

typedef __kernel_size_t size_t;

typedef size_t HUF_CElt;

typedef long unsigned int mpi_limb_t;

typedef mpi_limb_t UWtype;

typedef long unsigned int __kernel_old_dev_t;

typedef __kernel_ulong_t aio_context_t;

typedef long unsigned int efi_status_t;

typedef long unsigned int elf_greg_t;

typedef elf_greg_t elf_gregset_t[27];

typedef long unsigned int gva_t;

typedef __kernel_ulong_t ino_t;

typedef long unsigned int irq_hw_number_t;

typedef long unsigned int kernel_ulong_t;

typedef long unsigned int kimage_entry_t;

typedef long unsigned int mce_banks_t[1];

typedef mpi_limb_t *mpi_ptr_t;

typedef long unsigned int netmem_ref;

typedef long unsigned int old_sigset_t;

typedef long unsigned int p4dval_t;

typedef long unsigned int perf_trace_t[1024];

typedef long unsigned int pgdval_t;

typedef long unsigned int pgprotval_t;

typedef long unsigned int pmdval_t;

typedef long unsigned int pte_marker;

typedef long unsigned int pteval_t;

typedef long unsigned int pudval_t;

typedef long unsigned int uLong;

typedef long unsigned int u_long;

typedef long unsigned int uintptr_t;

typedef long unsigned int ulg;

typedef long unsigned int ulong;

typedef uintptr_t uptrval;

typedef long unsigned int vm_flags_t;

typedef short int __s16;

typedef __s16 s16;

typedef s16 int16_t;

typedef int16_t S16;

typedef short unsigned int __u16;

typedef __u16 Elf32_Half;

typedef __u16 Elf64_Half;

typedef short unsigned int ush;

typedef ush Pos;

typedef __u16 u16;

typedef u16 uint16_t;

typedef uint16_t U16;

typedef __u16 __be16;

typedef short unsigned int __kernel_gid16_t;

typedef short unsigned int __kernel_sa_family_t;

typedef short unsigned int __kernel_uid16_t;

typedef __u16 __le16;

typedef __u16 __sum16;

typedef __u16 __virtio16;

typedef u16 acpi_owner_id;

typedef u16 acpi_rs_length;

typedef short unsigned int atm_backend_t;

typedef u16 batadv_dat_addr_t;

typedef __u16 bitmap_counter_t;

typedef u16 blk_short_t;

typedef __u16 comp_t;

typedef u16 efi_char16_t;

typedef __kernel_gid16_t gid16_t;

typedef __u16 ip_set_id_t;

typedef short unsigned int mifi_t;

typedef short unsigned int pci_bus_flags_t;

typedef short unsigned int pci_dev_flags_t;

typedef __u16 port_id;

typedef __kernel_sa_family_t sa_family_t;

typedef u16 sfq_index;

typedef u16 u_int16_t;

typedef short unsigned int u_short;

typedef u16 ucs2_char_t;

typedef __kernel_uid16_t uid16_t;

typedef __u16 uio_meta_flags_t;

typedef short unsigned int umode_t;

typedef short unsigned int ushort;

typedef short unsigned int vifi_t;

typedef u16 wchar_t;

typedef uint16_t xfs_dir2_data_off_t;

typedef signed char __s8;

typedef __s8 s8;

typedef s8 int8_t;

typedef unsigned char __u8;

typedef __u8 u8;

typedef u8 uint8_t;

typedef uint8_t BYTE;

typedef unsigned char Byte;

typedef uint8_t U8;

typedef u8 acpi_adr_space_type;

typedef u8 blk_status_t;

typedef unsigned char cc_t;

typedef unsigned char cisdata_t;

typedef u8 dscp_t;

typedef u8 efi_bool_t;

typedef unsigned char insn_byte_t;

typedef u8 kprobe_opcode_t;

typedef __u8 mtrr_type;

typedef __u8 rds_tos_t;

typedef u8 retpoline_thunk_t[32];

typedef unsigned char u8___2;

typedef unsigned char u_char;

typedef u8 u_int8_t;

typedef unsigned char uch;

typedef unsigned char unchar;

typedef u8 uprobe_opcode_t;

typedef __u8 virtio_net_ctrl_ack;

typedef uint8_t xfs_dqtype_t;

typedef unsigned int __u32;

typedef __u32 Elf32_Addr;

typedef __u32 Elf32_Off;

typedef __u32 Elf32_Word;

typedef __u32 Elf64_Word;

typedef unsigned int FSE_CTable;

typedef unsigned int FSE_DTable;

typedef __u32 u32;

typedef u32 uint32_t;

typedef uint32_t U32;

typedef U32 HUF_DTable;

typedef unsigned int IPos;

typedef unsigned int OM_uint32;

typedef unsigned int UHWtype;

typedef __u32 __be32;

typedef u32 __kernel_dev_t;

typedef unsigned int __kernel_gid32_t;

typedef unsigned int __kernel_gid_t;

typedef unsigned int __kernel_mode_t;

typedef unsigned int __kernel_uid32_t;

typedef unsigned int __kernel_uid_t;

typedef __u32 __le32;

typedef unsigned int __poll_t;

typedef __u32 __portpair;

typedef __u32 __virtio32;

typedef __u32 __wsum;

typedef u32 acpi_event_status;

typedef u32 acpi_mutex_handle;

typedef u32 acpi_name;

typedef u32 acpi_object_type;

typedef u32 acpi_rsdesc_size;

typedef u32 acpi_status;

typedef unsigned int autofs_wqt_t;

typedef unsigned int blk_features_t;

typedef unsigned int blk_flags_t;

typedef unsigned int blk_insert_t;

typedef unsigned int blk_mode_t;

typedef __u32 blk_mq_req_flags_t;

typedef __u32 blk_opf_t;

typedef unsigned int blk_qc_t;

typedef u32 codel_time_t;

typedef __u32 comp2_t;

typedef u32 compat_caddr_t;

typedef u32 compat_size_t;

typedef u32 compat_uint_t;

typedef u32 compat_ulong_t;

typedef u32 compat_uptr_t;

typedef u32 depot_flags_t;

typedef u32 depot_stack_handle_t;

typedef __kernel_dev_t dev_t;

typedef uint32_t drbg_flag_t;

typedef unsigned int drm_magic_t;

typedef u32 errseq_t;

typedef unsigned int ext4_group_t;

typedef __u32 ext4_lblk_t;

typedef unsigned int fgf_t;

typedef unsigned int fmode_t;

typedef unsigned int fop_flags_t;

typedef u32 gen6_pte_t;

typedef unsigned int gfp_t;

typedef __kernel_gid32_t gid_t;

typedef __u32 if_mask;

typedef unsigned int insn_attr_t;

typedef u32 intel_engine_mask_t;

typedef unsigned int ioasid_t;

typedef unsigned int iov_iter_extraction_t;

typedef unsigned int isolate_mode_t;

typedef unsigned int kasan_vmalloc_flags_t;

typedef uint32_t key_perm_t;

typedef __kernel_mode_t mode_t;

typedef u32 nlink_t;

typedef u32 note_buf_t[92];

typedef __u32 nvme_submit_flags_t;

typedef unsigned int pci_channel_state_t;

typedef unsigned int pci_ers_result_t;

typedef unsigned int pgtbl_mod_mask;

typedef u32 phandle;

typedef u32 phys_cpuid_t;

typedef unsigned int pipe_index_t;

typedef uint32_t prid_t;

typedef __kernel_uid32_t projid_t;

typedef __kernel_uid32_t qid_t;

typedef U32 rankValCol_t[13];

typedef __u32 req_flags_t;

typedef u32 rpc_authflavor_t;

typedef __be32 rpc_fraghdr;

typedef unsigned int sk_buff_data_t;

typedef unsigned int slab_flags_t;

typedef unsigned int speed_t;

typedef unsigned int t_key;

typedef unsigned int tcflag_t;

typedef unsigned int tid_t;

typedef unsigned int uInt;

typedef unsigned int u_int;

typedef u32 u_int32_t;

typedef __kernel_uid32_t uid_t;

typedef unsigned int uint;

typedef u32 unicode_t;

typedef unsigned int upstat_t;

typedef unsigned int vm_fault_t;

typedef unsigned int xa_mark_t;

typedef u32 xdp_features_t;

typedef uint32_t xfs_aextnum_t;

typedef uint32_t xfs_agblock_t;

typedef uint32_t xfs_agino_t;

typedef uint32_t xfs_agnumber_t;

typedef unsigned int xfs_buf_flags_t;

typedef uint32_t xfs_dablk_t;

typedef uint32_t xfs_dahash_t;

typedef __u32 xfs_dev_t;

typedef uint xfs_dir2_data_aoff_t;

typedef uint32_t xfs_dir2_dataptr_t;

typedef uint32_t xfs_dir2_db_t;

typedef uint32_t xfs_dqid_t;

typedef uint32_t xfs_extlen_t;

typedef __u32 xfs_nlink_t;

typedef uint32_t xfs_rgblock_t;

typedef uint32_t xfs_rgnumber_t;

typedef uint32_t xfs_rtxlen_t;

typedef uint32_t xlog_tid_t;

typedef unsigned int zap_flags_t;

typedef struct {
	size_t bitContainer;
	unsigned int bitPos;
	char *startPtr;
	char *ptr;
	char *endPtr;
} BIT_CStream_t;

typedef struct {
	size_t bitContainer;
	unsigned int bitsConsumed;
	const char *ptr;
	const char *start;
	const char *limitPtr;
} BIT_DStream_t;

typedef struct {
	BYTE maxTableLog;
	BYTE tableType;
	BYTE tableLog;
	BYTE reserved;
} DTableDesc;

typedef struct {
	ptrdiff_t value;
	const void *stateTable;
	const void *symbolTT;
	unsigned int stateLog;
} FSE_CState_t;

typedef struct {
	size_t state;
	const void *table;
} FSE_DState_t;

typedef struct {
	U16 tableLog;
	U16 fastMode;
} FSE_DTableHeader;

typedef struct {
	short int ncount[256];
	FSE_DTable dtable[0];
} FSE_DecompressWksp;

typedef struct {
	short unsigned int newState;
	unsigned char symbol;
	unsigned char nbBits;
} FSE_decode_t;

typedef struct {
	int deltaFindState;
	U32 deltaNbBits;
} FSE_symbolCompressionTransform;

typedef struct {
	size_t bitContainer[2];
	size_t bitPos[2];
	BYTE *startPtr;
	BYTE *ptr;
	BYTE *endPtr;
} HUF_CStream_t;

typedef struct {
	FSE_CTable CTable[59];
	U32 scratchBuffer[41];
	unsigned int count[13];
	S16 norm[13];
} HUF_CompressWeightsWksp;

typedef struct {
	BYTE nbBits;
	BYTE byte;
} HUF_DEltX1;

typedef struct {
	U16 sequence;
	BYTE nbBits;
	BYTE length;
} HUF_DEltX2;

typedef struct {
	U32 rankVal[13];
	U32 rankStart[13];
	U32 statsWksp[218];
	BYTE symbols[256];
	BYTE huffWeight[256];
} HUF_ReadDTableX1_Workspace;

typedef struct {
	BYTE symbol;
} sortedSymbol_t;

typedef struct {
	U32 rankVal[156];
	U32 rankStats[13];
	U32 rankStart0[15];
	sortedSymbol_t sortedSymbol[256];
	BYTE weightList[256];
	U32 calleeWksp[218];
} HUF_ReadDTableX2_Workspace;

typedef struct {
	HUF_CompressWeightsWksp wksp;
	BYTE bitsToWeight[13];
	BYTE huffWeight[255];
} HUF_WriteCTableWksp;

struct nodeElt_s {
	U32 count;
	U16 parent;
	BYTE byte;
	BYTE nbBits;
};

typedef struct nodeElt_s nodeElt;

typedef nodeElt huffNodeTable[512];

typedef struct {
	U16 base;
	U16 curr;
} rankPos;

typedef struct {
	huffNodeTable huffNodeTbl;
	rankPos rankPosition[192];
} HUF_buildCTable_wksp_tables;

typedef struct {
	unsigned int count[256];
	HUF_CElt CTable[257];
	union {
		HUF_buildCTable_wksp_tables buildCTable_wksp;
		HUF_WriteCTableWksp writeCTable_wksp;
		U32 hist_wksp[1024];
	} wksps;
} HUF_compress_tables_t;

struct buffer_head;

typedef struct {
	__le32 *p;
	__le32 key;
	struct buffer_head *bh;
} Indirect;

typedef struct {
	const uint8_t *externalDict;
	size_t extDictSize;
	const uint8_t *prefixEnd;
	size_t prefixSize;
} LZ4_streamDecode_t_internal;

typedef union {
	long long unsigned int table[4];
	LZ4_streamDecode_t_internal internal_donotuse;
} LZ4_streamDecode_t;

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

typedef struct {
	int counter;
} atomic_t;

struct refcount_struct {
	atomic_t refs;
};

typedef struct refcount_struct refcount_t;

struct dentry;

struct file;

typedef struct {
	struct list_head list;
	long unsigned int flags;
	int offset;
	int size;
	char *magic;
	char *mask;
	const char *interpreter;
	char *name;
	struct dentry *dentry;
	struct file *interp_file;
	refcount_t users;
} Node;

struct TransportAddress_ipAddress {
	int options;
	unsigned int ip;
};

typedef struct TransportAddress_ipAddress TransportAddress_ipAddress;

struct TransportAddress_ip6Address {
	int options;
	unsigned int ip;
};

typedef struct TransportAddress_ip6Address TransportAddress_ip6Address;

struct TransportAddress {
	enum {
		eTransportAddress_ipAddress = 0,
		eTransportAddress_ipSourceRoute = 1,
		eTransportAddress_ipxAddress = 2,
		eTransportAddress_ip6Address = 3,
		eTransportAddress_netBios = 4,
		eTransportAddress_nsap = 5,
		eTransportAddress_nonStandardAddress = 6,
	} choice;
	union {
		TransportAddress_ipAddress ipAddress;
		TransportAddress_ip6Address ip6Address;
	};
};

typedef struct TransportAddress TransportAddress;

struct DataProtocolCapability {
	enum {
		eDataProtocolCapability_nonStandard = 0,
		eDataProtocolCapability_v14buffered = 1,
		eDataProtocolCapability_v42lapm = 2,
		eDataProtocolCapability_hdlcFrameTunnelling = 3,
		eDataProtocolCapability_h310SeparateVCStack = 4,
		eDataProtocolCapability_h310SingleVCStack = 5,
		eDataProtocolCapability_transparent = 6,
		eDataProtocolCapability_segmentationAndReassembly = 7,
		eDataProtocolCapability_hdlcFrameTunnelingwSAR = 8,
		eDataProtocolCapability_v120 = 9,
		eDataProtocolCapability_separateLANStack = 10,
		eDataProtocolCapability_v76wCompression = 11,
		eDataProtocolCapability_tcp = 12,
		eDataProtocolCapability_udp = 13,
	} choice;
};

typedef struct DataProtocolCapability DataProtocolCapability;

struct DataApplicationCapability_application {
	enum {
		eDataApplicationCapability_application_nonStandard = 0,
		eDataApplicationCapability_application_t120 = 1,
		eDataApplicationCapability_application_dsm_cc = 2,
		eDataApplicationCapability_application_userData = 3,
		eDataApplicationCapability_application_t84 = 4,
		eDataApplicationCapability_application_t434 = 5,
		eDataApplicationCapability_application_h224 = 6,
		eDataApplicationCapability_application_nlpid = 7,
		eDataApplicationCapability_application_dsvdControl = 8,
		eDataApplicationCapability_application_h222DataPartitioning = 9,
		eDataApplicationCapability_application_t30fax = 10,
		eDataApplicationCapability_application_t140 = 11,
		eDataApplicationCapability_application_t38fax = 12,
		eDataApplicationCapability_application_genericDataCapability = 13,
	} choice;
	union {
		DataProtocolCapability t120;
	};
};

typedef struct DataApplicationCapability_application DataApplicationCapability_application;

struct DataApplicationCapability {
	int options;
	DataApplicationCapability_application application;
};

typedef struct DataApplicationCapability DataApplicationCapability;

struct DataType {
	enum {
		eDataType_nonStandard = 0,
		eDataType_nullData = 1,
		eDataType_videoData = 2,
		eDataType_audioData = 3,
		eDataType_data = 4,
		eDataType_encryptionData = 5,
		eDataType_h235Control = 6,
		eDataType_h235Media = 7,
		eDataType_multiplexedStream = 8,
	} choice;
	union {
		DataApplicationCapability data;
	};
};

typedef struct DataType DataType;

struct UnicastAddress_iPAddress {
	int options;
	unsigned int network;
};

typedef struct UnicastAddress_iPAddress UnicastAddress_iPAddress;

struct UnicastAddress_iP6Address {
	int options;
	unsigned int network;
};

typedef struct UnicastAddress_iP6Address UnicastAddress_iP6Address;

struct UnicastAddress {
	enum {
		eUnicastAddress_iPAddress = 0,
		eUnicastAddress_iPXAddress = 1,
		eUnicastAddress_iP6Address = 2,
		eUnicastAddress_netBios = 3,
		eUnicastAddress_iPSourceRouteAddress = 4,
		eUnicastAddress_nsap = 5,
		eUnicastAddress_nonStandardAddress = 6,
	} choice;
	union {
		UnicastAddress_iPAddress iPAddress;
		UnicastAddress_iP6Address iP6Address;
	};
};

typedef struct UnicastAddress UnicastAddress;

struct H245_TransportAddress {
	enum {
		eH245_TransportAddress_unicastAddress = 0,
		eH245_TransportAddress_multicastAddress = 1,
	} choice;
	union {
		UnicastAddress unicastAddress;
	};
};

typedef struct H245_TransportAddress H245_TransportAddress;

struct H2250LogicalChannelParameters {
	enum {
		eH2250LogicalChannelParameters_nonStandard = -2147483648,
		eH2250LogicalChannelParameters_associatedSessionID = 1073741824,
		eH2250LogicalChannelParameters_mediaChannel = 536870912,
		eH2250LogicalChannelParameters_mediaGuaranteedDelivery = 268435456,
		eH2250LogicalChannelParameters_mediaControlChannel = 134217728,
		eH2250LogicalChannelParameters_mediaControlGuaranteedDelivery = 67108864,
		eH2250LogicalChannelParameters_silenceSuppression = 33554432,
		eH2250LogicalChannelParameters_destination = 16777216,
		eH2250LogicalChannelParameters_dynamicRTPPayloadType = 8388608,
		eH2250LogicalChannelParameters_mediaPacketization = 4194304,
		eH2250LogicalChannelParameters_transportCapability = 2097152,
		eH2250LogicalChannelParameters_redundancyEncoding = 1048576,
		eH2250LogicalChannelParameters_source = 524288,
	} options;
	H245_TransportAddress mediaChannel;
	H245_TransportAddress mediaControlChannel;
};

typedef struct H2250LogicalChannelParameters H2250LogicalChannelParameters;

struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
	enum {
		eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters = 0,
		eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters = 1,
		eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters = 2,
		eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters = 3,
		eOpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_none = 4,
	} choice;
	union {
		H2250LogicalChannelParameters h2250LogicalChannelParameters;
	};
};

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

struct OpenLogicalChannel_forwardLogicalChannelParameters {
	enum {
		eOpenLogicalChannel_forwardLogicalChannelParameters_portNumber = -2147483648,
		eOpenLogicalChannel_forwardLogicalChannelParameters_forwardLogicalChannelDependency = 1073741824,
		eOpenLogicalChannel_forwardLogicalChannelParameters_replacementFor = 536870912,
	} options;
	DataType dataType;
	OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
};

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters OpenLogicalChannel_forwardLogicalChannelParameters;

struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
	enum {
		eOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters = 0,
		eOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters = 1,
		eOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters = 2,
	} choice;
	union {
		H2250LogicalChannelParameters h2250LogicalChannelParameters;
	};
};

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

struct OpenLogicalChannel_reverseLogicalChannelParameters {
	enum {
		eOpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters = -2147483648,
		eOpenLogicalChannel_reverseLogicalChannelParameters_reverseLogicalChannelDependency = 1073741824,
		eOpenLogicalChannel_reverseLogicalChannelParameters_replacementFor = 536870912,
	} options;
	OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
};

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters OpenLogicalChannel_reverseLogicalChannelParameters;

struct NetworkAccessParameters_networkAddress {
	enum {
		eNetworkAccessParameters_networkAddress_q2931Address = 0,
		eNetworkAccessParameters_networkAddress_e164Address = 1,
		eNetworkAccessParameters_networkAddress_localAreaAddress = 2,
	} choice;
	union {
		H245_TransportAddress localAreaAddress;
	};
};

typedef struct NetworkAccessParameters_networkAddress NetworkAccessParameters_networkAddress;

struct NetworkAccessParameters {
	enum {
		eNetworkAccessParameters_distribution = -2147483648,
		eNetworkAccessParameters_externalReference = 1073741824,
		eNetworkAccessParameters_t120SetupProcedure = 536870912,
	} options;
	NetworkAccessParameters_networkAddress networkAddress;
};

typedef struct NetworkAccessParameters NetworkAccessParameters;

struct OpenLogicalChannel {
	enum {
		eOpenLogicalChannel_reverseLogicalChannelParameters = -2147483648,
		eOpenLogicalChannel_separateStack = 1073741824,
		eOpenLogicalChannel_encryptionSync = 536870912,
	} options;
	OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
	OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
	NetworkAccessParameters separateStack;
};

typedef struct OpenLogicalChannel OpenLogicalChannel;

struct Setup_UUIE_fastStart {
	int count;
	OpenLogicalChannel item[30];
};

typedef struct Setup_UUIE_fastStart Setup_UUIE_fastStart;

struct Setup_UUIE {
	enum {
		eSetup_UUIE_h245Address = -2147483648,
		eSetup_UUIE_sourceAddress = 1073741824,
		eSetup_UUIE_destinationAddress = 536870912,
		eSetup_UUIE_destCallSignalAddress = 268435456,
		eSetup_UUIE_destExtraCallInfo = 134217728,
		eSetup_UUIE_destExtraCRV = 67108864,
		eSetup_UUIE_callServices = 33554432,
		eSetup_UUIE_sourceCallSignalAddress = 16777216,
		eSetup_UUIE_remoteExtensionAddress = 8388608,
		eSetup_UUIE_callIdentifier = 4194304,
		eSetup_UUIE_h245SecurityCapability = 2097152,
		eSetup_UUIE_tokens = 1048576,
		eSetup_UUIE_cryptoTokens = 524288,
		eSetup_UUIE_fastStart = 262144,
		eSetup_UUIE_mediaWaitForConnect = 131072,
		eSetup_UUIE_canOverlapSend = 65536,
		eSetup_UUIE_endpointIdentifier = 32768,
		eSetup_UUIE_multipleCalls = 16384,
		eSetup_UUIE_maintainConnection = 8192,
		eSetup_UUIE_connectionParameters = 4096,
		eSetup_UUIE_language = 2048,
		eSetup_UUIE_presentationIndicator = 1024,
		eSetup_UUIE_screeningIndicator = 512,
		eSetup_UUIE_serviceControl = 256,
		eSetup_UUIE_symmetricOperationRequired = 128,
		eSetup_UUIE_capacity = 64,
		eSetup_UUIE_circuitInfo = 32,
		eSetup_UUIE_desiredProtocols = 16,
		eSetup_UUIE_neededFeatures = 8,
		eSetup_UUIE_desiredFeatures = 4,
		eSetup_UUIE_supportedFeatures = 2,
		eSetup_UUIE_parallelH245Control = 1,
	} options;
	TransportAddress h245Address;
	TransportAddress destCallSignalAddress;
	TransportAddress sourceCallSignalAddress;
	Setup_UUIE_fastStart fastStart;
};

typedef struct Setup_UUIE Setup_UUIE;

struct CallProceeding_UUIE_fastStart {
	int count;
	OpenLogicalChannel item[30];
};

typedef struct CallProceeding_UUIE_fastStart CallProceeding_UUIE_fastStart;

struct CallProceeding_UUIE {
	enum {
		eCallProceeding_UUIE_h245Address = -2147483648,
		eCallProceeding_UUIE_callIdentifier = 1073741824,
		eCallProceeding_UUIE_h245SecurityMode = 536870912,
		eCallProceeding_UUIE_tokens = 268435456,
		eCallProceeding_UUIE_cryptoTokens = 134217728,
		eCallProceeding_UUIE_fastStart = 67108864,
		eCallProceeding_UUIE_multipleCalls = 33554432,
		eCallProceeding_UUIE_maintainConnection = 16777216,
		eCallProceeding_UUIE_fastConnectRefused = 8388608,
		eCallProceeding_UUIE_featureSet = 4194304,
	} options;
	TransportAddress h245Address;
	CallProceeding_UUIE_fastStart fastStart;
};

typedef struct CallProceeding_UUIE CallProceeding_UUIE;

struct Connect_UUIE_fastStart {
	int count;
	OpenLogicalChannel item[30];
};

typedef struct Connect_UUIE_fastStart Connect_UUIE_fastStart;

struct Connect_UUIE {
	enum {
		eConnect_UUIE_h245Address = -2147483648,
		eConnect_UUIE_callIdentifier = 1073741824,
		eConnect_UUIE_h245SecurityMode = 536870912,
		eConnect_UUIE_tokens = 268435456,
		eConnect_UUIE_cryptoTokens = 134217728,
		eConnect_UUIE_fastStart = 67108864,
		eConnect_UUIE_multipleCalls = 33554432,
		eConnect_UUIE_maintainConnection = 16777216,
		eConnect_UUIE_language = 8388608,
		eConnect_UUIE_connectedAddress = 4194304,
		eConnect_UUIE_presentationIndicator = 2097152,
		eConnect_UUIE_screeningIndicator = 1048576,
		eConnect_UUIE_fastConnectRefused = 524288,
		eConnect_UUIE_serviceControl = 262144,
		eConnect_UUIE_capacity = 131072,
		eConnect_UUIE_featureSet = 65536,
	} options;
	TransportAddress h245Address;
	Connect_UUIE_fastStart fastStart;
};

typedef struct Connect_UUIE Connect_UUIE;

struct Alerting_UUIE_fastStart {
	int count;
	OpenLogicalChannel item[30];
};

typedef struct Alerting_UUIE_fastStart Alerting_UUIE_fastStart;

struct Alerting_UUIE {
	enum {
		eAlerting_UUIE_h245Address = -2147483648,
		eAlerting_UUIE_callIdentifier = 1073741824,
		eAlerting_UUIE_h245SecurityMode = 536870912,
		eAlerting_UUIE_tokens = 268435456,
		eAlerting_UUIE_cryptoTokens = 134217728,
		eAlerting_UUIE_fastStart = 67108864,
		eAlerting_UUIE_multipleCalls = 33554432,
		eAlerting_UUIE_maintainConnection = 16777216,
		eAlerting_UUIE_alertingAddress = 8388608,
		eAlerting_UUIE_presentationIndicator = 4194304,
		eAlerting_UUIE_screeningIndicator = 2097152,
		eAlerting_UUIE_fastConnectRefused = 1048576,
		eAlerting_UUIE_serviceControl = 524288,
		eAlerting_UUIE_capacity = 262144,
		eAlerting_UUIE_featureSet = 131072,
	} options;
	TransportAddress h245Address;
	Alerting_UUIE_fastStart fastStart;
};

typedef struct Alerting_UUIE Alerting_UUIE;

struct FacilityReason {
	enum {
		eFacilityReason_routeCallToGatekeeper = 0,
		eFacilityReason_callForwarded = 1,
		eFacilityReason_routeCallToMC = 2,
		eFacilityReason_undefinedReason = 3,
		eFacilityReason_conferenceListChoice = 4,
		eFacilityReason_startH245 = 5,
		eFacilityReason_noH245 = 6,
		eFacilityReason_newTokens = 7,
		eFacilityReason_featureSetUpdate = 8,
		eFacilityReason_forwardedElements = 9,
		eFacilityReason_transportedInformation = 10,
	} choice;
};

typedef struct FacilityReason FacilityReason;

struct Facility_UUIE_fastStart {
	int count;
	OpenLogicalChannel item[30];
};

typedef struct Facility_UUIE_fastStart Facility_UUIE_fastStart;

struct Facility_UUIE {
	enum {
		eFacility_UUIE_alternativeAddress = -2147483648,
		eFacility_UUIE_alternativeAliasAddress = 1073741824,
		eFacility_UUIE_conferenceID = 536870912,
		eFacility_UUIE_callIdentifier = 268435456,
		eFacility_UUIE_destExtraCallInfo = 134217728,
		eFacility_UUIE_remoteExtensionAddress = 67108864,
		eFacility_UUIE_tokens = 33554432,
		eFacility_UUIE_cryptoTokens = 16777216,
		eFacility_UUIE_conferences = 8388608,
		eFacility_UUIE_h245Address = 4194304,
		eFacility_UUIE_fastStart = 2097152,
		eFacility_UUIE_multipleCalls = 1048576,
		eFacility_UUIE_maintainConnection = 524288,
		eFacility_UUIE_fastConnectRefused = 262144,
		eFacility_UUIE_serviceControl = 131072,
		eFacility_UUIE_circuitInfo = 65536,
		eFacility_UUIE_featureSet = 32768,
		eFacility_UUIE_destinationInfo = 16384,
		eFacility_UUIE_h245SecurityMode = 8192,
	} options;
	TransportAddress alternativeAddress;
	FacilityReason reason;
	TransportAddress h245Address;
	Facility_UUIE_fastStart fastStart;
};

typedef struct Facility_UUIE Facility_UUIE;

struct Progress_UUIE_fastStart {
	int count;
	OpenLogicalChannel item[30];
};

typedef struct Progress_UUIE_fastStart Progress_UUIE_fastStart;

struct Progress_UUIE {
	enum {
		eProgress_UUIE_h245Address = -2147483648,
		eProgress_UUIE_h245SecurityMode = 1073741824,
		eProgress_UUIE_tokens = 536870912,
		eProgress_UUIE_cryptoTokens = 268435456,
		eProgress_UUIE_fastStart = 134217728,
		eProgress_UUIE_multipleCalls = 67108864,
		eProgress_UUIE_maintainConnection = 33554432,
		eProgress_UUIE_fastConnectRefused = 16777216,
	} options;
	TransportAddress h245Address;
	Progress_UUIE_fastStart fastStart;
};

typedef struct Progress_UUIE Progress_UUIE;

struct H323_UU_PDU_h323_message_body {
	enum {
		eH323_UU_PDU_h323_message_body_setup = 0,
		eH323_UU_PDU_h323_message_body_callProceeding = 1,
		eH323_UU_PDU_h323_message_body_connect = 2,
		eH323_UU_PDU_h323_message_body_alerting = 3,
		eH323_UU_PDU_h323_message_body_information = 4,
		eH323_UU_PDU_h323_message_body_releaseComplete = 5,
		eH323_UU_PDU_h323_message_body_facility = 6,
		eH323_UU_PDU_h323_message_body_progress = 7,
		eH323_UU_PDU_h323_message_body_empty = 8,
		eH323_UU_PDU_h323_message_body_status = 9,
		eH323_UU_PDU_h323_message_body_statusInquiry = 10,
		eH323_UU_PDU_h323_message_body_setupAcknowledge = 11,
		eH323_UU_PDU_h323_message_body_notify = 12,
	} choice;
	union {
		Setup_UUIE setup;
		CallProceeding_UUIE callProceeding;
		Connect_UUIE connect;
		Alerting_UUIE alerting;
		Facility_UUIE facility;
		Progress_UUIE progress;
	};
};

typedef struct H323_UU_PDU_h323_message_body H323_UU_PDU_h323_message_body;

struct RequestMessage {
	enum {
		eRequestMessage_nonStandard = 0,
		eRequestMessage_masterSlaveDetermination = 1,
		eRequestMessage_terminalCapabilitySet = 2,
		eRequestMessage_openLogicalChannel = 3,
		eRequestMessage_closeLogicalChannel = 4,
		eRequestMessage_requestChannelClose = 5,
		eRequestMessage_multiplexEntrySend = 6,
		eRequestMessage_requestMultiplexEntry = 7,
		eRequestMessage_requestMode = 8,
		eRequestMessage_roundTripDelayRequest = 9,
		eRequestMessage_maintenanceLoopRequest = 10,
		eRequestMessage_communicationModeRequest = 11,
		eRequestMessage_conferenceRequest = 12,
		eRequestMessage_multilinkRequest = 13,
		eRequestMessage_logicalChannelRateRequest = 14,
	} choice;
	union {
		OpenLogicalChannel openLogicalChannel;
	};
};

typedef struct RequestMessage RequestMessage;

struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
	enum {
		eOpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters = 0,
		eOpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters = 1,
	} choice;
	union {
		H2250LogicalChannelParameters h2250LogicalChannelParameters;
	};
};

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
	enum {
		eOpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber = -2147483648,
		eOpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters = 1073741824,
		eOpenLogicalChannelAck_reverseLogicalChannelParameters_replacementFor = 536870912,
	} options;
	OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
};

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters OpenLogicalChannelAck_reverseLogicalChannelParameters;

struct H2250LogicalChannelAckParameters {
	enum {
		eH2250LogicalChannelAckParameters_nonStandard = -2147483648,
		eH2250LogicalChannelAckParameters_sessionID = 1073741824,
		eH2250LogicalChannelAckParameters_mediaChannel = 536870912,
		eH2250LogicalChannelAckParameters_mediaControlChannel = 268435456,
		eH2250LogicalChannelAckParameters_dynamicRTPPayloadType = 134217728,
		eH2250LogicalChannelAckParameters_flowControlToZero = 67108864,
		eH2250LogicalChannelAckParameters_portNumber = 33554432,
	} options;
	H245_TransportAddress mediaChannel;
	H245_TransportAddress mediaControlChannel;
};

typedef struct H2250LogicalChannelAckParameters H2250LogicalChannelAckParameters;

struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
	enum {
		eOpenLogicalChannelAck_forwardMultiplexAckParameters_h2250LogicalChannelAckParameters = 0,
	} choice;
	union {
		H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
	};
};

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters OpenLogicalChannelAck_forwardMultiplexAckParameters;

struct OpenLogicalChannelAck {
	enum {
		eOpenLogicalChannelAck_reverseLogicalChannelParameters = -2147483648,
		eOpenLogicalChannelAck_separateStack = 1073741824,
		eOpenLogicalChannelAck_forwardMultiplexAckParameters = 536870912,
		eOpenLogicalChannelAck_encryptionSync = 268435456,
	} options;
	OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
	NetworkAccessParameters separateStack;
	OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
};

typedef struct OpenLogicalChannelAck OpenLogicalChannelAck;

struct ResponseMessage {
	enum {
		eResponseMessage_nonStandard = 0,
		eResponseMessage_masterSlaveDeterminationAck = 1,
		eResponseMessage_masterSlaveDeterminationReject = 2,
		eResponseMessage_terminalCapabilitySetAck = 3,
		eResponseMessage_terminalCapabilitySetReject = 4,
		eResponseMessage_openLogicalChannelAck = 5,
		eResponseMessage_openLogicalChannelReject = 6,
		eResponseMessage_closeLogicalChannelAck = 7,
		eResponseMessage_requestChannelCloseAck = 8,
		eResponseMessage_requestChannelCloseReject = 9,
		eResponseMessage_multiplexEntrySendAck = 10,
		eResponseMessage_multiplexEntrySendReject = 11,
		eResponseMessage_requestMultiplexEntryAck = 12,
		eResponseMessage_requestMultiplexEntryReject = 13,
		eResponseMessage_requestModeAck = 14,
		eResponseMessage_requestModeReject = 15,
		eResponseMessage_roundTripDelayResponse = 16,
		eResponseMessage_maintenanceLoopAck = 17,
		eResponseMessage_maintenanceLoopReject = 18,
		eResponseMessage_communicationModeResponse = 19,
		eResponseMessage_conferenceResponse = 20,
		eResponseMessage_multilinkResponse = 21,
		eResponseMessage_logicalChannelRateAcknowledge = 22,
		eResponseMessage_logicalChannelRateReject = 23,
	} choice;
	union {
		OpenLogicalChannelAck openLogicalChannelAck;
	};
};

typedef struct ResponseMessage ResponseMessage;

struct MultimediaSystemControlMessage {
	enum {
		eMultimediaSystemControlMessage_request = 0,
		eMultimediaSystemControlMessage_response = 1,
		eMultimediaSystemControlMessage_command = 2,
		eMultimediaSystemControlMessage_indication = 3,
	} choice;
	union {
		RequestMessage request;
		ResponseMessage response;
	};
};

typedef struct MultimediaSystemControlMessage MultimediaSystemControlMessage;

struct H323_UU_PDU_h245Control {
	int count;
	MultimediaSystemControlMessage item[4];
};

typedef struct H323_UU_PDU_h245Control H323_UU_PDU_h245Control;

struct H323_UU_PDU {
	enum {
		eH323_UU_PDU_nonStandardData = -2147483648,
		eH323_UU_PDU_h4501SupplementaryService = 1073741824,
		eH323_UU_PDU_h245Tunneling = 536870912,
		eH323_UU_PDU_h245Control = 268435456,
		eH323_UU_PDU_nonStandardControl = 134217728,
		eH323_UU_PDU_callLinkage = 67108864,
		eH323_UU_PDU_tunnelledSignallingMessage = 33554432,
		eH323_UU_PDU_provisionalRespToH245Tunneling = 16777216,
		eH323_UU_PDU_stimulusControl = 8388608,
		eH323_UU_PDU_genericData = 4194304,
	} options;
	H323_UU_PDU_h323_message_body h323_message_body;
	H323_UU_PDU_h245Control h245Control;
};

typedef struct H323_UU_PDU H323_UU_PDU;

struct H323_UserInformation {
	enum {
		eH323_UserInformation_user_data = -2147483648,
	} options;
	H323_UU_PDU h323_uu_pdu;
};

typedef struct H323_UserInformation H323_UserInformation;

typedef struct {
	enum {
		Q931_NationalEscape = 0,
		Q931_Alerting = 1,
		Q931_CallProceeding = 2,
		Q931_Connect = 7,
		Q931_ConnectAck = 15,
		Q931_Progress = 3,
		Q931_Setup = 5,
		Q931_SetupAck = 13,
		Q931_Resume = 38,
		Q931_ResumeAck = 46,
		Q931_ResumeReject = 34,
		Q931_Suspend = 37,
		Q931_SuspendAck = 45,
		Q931_SuspendReject = 33,
		Q931_UserInformation = 32,
		Q931_Disconnect = 69,
		Q931_Release = 77,
		Q931_ReleaseComplete = 90,
		Q931_Restart = 70,
		Q931_RestartAck = 78,
		Q931_Segment = 96,
		Q931_CongestionCtrl = 121,
		Q931_Information = 123,
		Q931_Notify = 110,
		Q931_Status = 125,
		Q931_StatusEnquiry = 117,
		Q931_Facility = 98,
	} MessageType;
	H323_UserInformation UUIE;
} Q931;

struct folio;

typedef struct {
	struct folio *v;
} Sector;

typedef struct {
	unsigned int offset;
	unsigned int litLength;
	unsigned int matchLength;
	unsigned int rep;
} ZSTD_Sequence;

typedef struct {
	int collectSequences;
	ZSTD_Sequence *seqStart;
	size_t seqIndex;
	size_t maxSequences;
} SeqCollector;

typedef struct {
	S16 norm[53];
	U32 wksp[285];
} ZSTD_BuildCTableWksp;

struct ZSTD_DDict_s;

typedef struct ZSTD_DDict_s ZSTD_DDict;

typedef struct {
	const ZSTD_DDict **ddictPtrTable;
	size_t ddictPtrTableSize;
	size_t ddictPtrCount;
} ZSTD_DDictHashSet;

struct seqDef_s;

typedef struct seqDef_s seqDef;

typedef struct {
	seqDef *sequencesStart;
	seqDef *sequences;
	BYTE *litStart;
	BYTE *lit;
	BYTE *llCode;
	BYTE *mlCode;
	BYTE *ofCode;
	size_t maxNbSeq;
	size_t maxNbLit;
	ZSTD_longLengthType_e longLengthType;
	U32 longLengthPos;
} seqStore_t;

typedef struct {
	symbolEncodingType_e hType;
	BYTE hufDesBuffer[128];
	size_t hufDesSize;
} ZSTD_hufCTablesMetadata_t;

typedef struct {
	symbolEncodingType_e llType;
	symbolEncodingType_e ofType;
	symbolEncodingType_e mlType;
	BYTE fseTablesBuffer[133];
	size_t fseTablesSize;
	size_t lastCountSize;
} ZSTD_fseCTablesMetadata_t;

typedef struct {
	ZSTD_hufCTablesMetadata_t hufMetadata;
	ZSTD_fseCTablesMetadata_t fseMetadata;
} ZSTD_entropyCTablesMetadata_t;

typedef struct {
	seqStore_t fullSeqStoreChunk;
	seqStore_t firstHalfSeqStore;
	seqStore_t secondHalfSeqStore;
	seqStore_t currSeqStore;
	seqStore_t nextSeqStore;
	U32 partitions[196];
	ZSTD_entropyCTablesMetadata_t entropyMetadata;
} ZSTD_blockSplitCtx;

typedef struct {
	HUF_CElt CTable[257];
	HUF_repeat repeatMode;
} ZSTD_hufCTables_t;

typedef struct {
	FSE_CTable offcodeCTable[193];
	FSE_CTable matchlengthCTable[363];
	FSE_CTable litlengthCTable[329];
	FSE_repeat offcode_repeatMode;
	FSE_repeat matchlength_repeatMode;
	FSE_repeat litlength_repeatMode;
} ZSTD_fseCTables_t;

typedef struct {
	ZSTD_hufCTables_t huf;
	ZSTD_fseCTables_t fse;
} ZSTD_entropyCTables_t;

typedef struct {
	ZSTD_entropyCTables_t entropy;
	U32 rep[3];
} ZSTD_compressedBlockState_t;

typedef struct {
	const BYTE *nextSrc;
	const BYTE *base;
	const BYTE *dictBase;
	U32 dictLimit;
	U32 lowLimit;
	U32 nbOverflowCorrections;
} ZSTD_window_t;

typedef struct {
	U32 off;
	U32 len;
} ZSTD_match_t;

typedef struct {
	int price;
	U32 off;
	U32 mlen;
	U32 litlen;
	U32 rep[3];
} ZSTD_optimal_t;

typedef struct {
	unsigned int *litFreq;
	unsigned int *litLengthFreq;
	unsigned int *matchLengthFreq;
	unsigned int *offCodeFreq;
	ZSTD_match_t *matchTable;
	ZSTD_optimal_t *priceTable;
	U32 litSum;
	U32 litLengthSum;
	U32 matchLengthSum;
	U32 offCodeSum;
	U32 litSumBasePrice;
	U32 litLengthSumBasePrice;
	U32 matchLengthSumBasePrice;
	U32 offCodeSumBasePrice;
	ZSTD_OptPrice_e priceType;
	const ZSTD_entropyCTables_t *symbolCosts;
	ZSTD_paramSwitch_e literalCompressionMode;
} optState_t;

typedef struct {
	unsigned int windowLog;
	unsigned int chainLog;
	unsigned int hashLog;
	unsigned int searchLog;
	unsigned int minMatch;
	unsigned int targetLength;
	ZSTD_strategy strategy;
} ZSTD_compressionParameters;

typedef struct {
	U32 offset;
	U32 litLength;
	U32 matchLength;
} rawSeq;

typedef struct {
	rawSeq *seq;
	size_t pos;
	size_t posInSequence;
	size_t size;
	size_t capacity;
} rawSeqStore_t;

struct ZSTD_matchState_t;

typedef struct ZSTD_matchState_t ZSTD_matchState_t;

struct ZSTD_matchState_t {
	ZSTD_window_t window;
	U32 loadedDictEnd;
	U32 nextToUpdate;
	U32 hashLog3;
	U32 rowHashLog;
	U16 *tagTable;
	U32 hashCache[8];
	U32 *hashTable;
	U32 *hashTable3;
	U32 *chainTable;
	U32 forceNonContiguous;
	int dedicatedDictSearch;
	optState_t opt;
	const ZSTD_matchState_t *dictMatchState;
	ZSTD_compressionParameters cParams;
	const rawSeqStore_t *ldmSeqStore;
};

typedef struct {
	ZSTD_compressedBlockState_t *prevCBlock;
	ZSTD_compressedBlockState_t *nextCBlock;
	ZSTD_matchState_t matchState;
} ZSTD_blockState_t;

typedef struct {
	size_t error;
	int lowerBound;
	int upperBound;
} ZSTD_bounds;

typedef struct {
	U32 f1c;
	U32 f1d;
	U32 f7b;
	U32 f7c;
} ZSTD_cpuid_t;

typedef void * (*ZSTD_allocFunction)(void *, size_t);

typedef void (*ZSTD_freeFunction)(void *, void *);

typedef struct {
	ZSTD_allocFunction customAlloc;
	ZSTD_freeFunction customFree;
	void *opaque;
} ZSTD_customMem;

typedef struct {
	void *workspace;
	void *workspaceEnd;
	void *objectEnd;
	void *tableEnd;
	void *tableValidEnd;
	void *allocStart;
	BYTE allocFailed;
	int workspaceOversizedDuration;
	ZSTD_cwksp_alloc_phase_e phase;
	ZSTD_cwksp_static_alloc_e isStatic;
} ZSTD_cwksp;

typedef struct {
	U16 nextState;
	BYTE nbAdditionalBits;
	BYTE nbBits;
	U32 baseValue;
} ZSTD_seqSymbol;

typedef struct {
	ZSTD_seqSymbol LLTable[513];
	ZSTD_seqSymbol OFTable[257];
	ZSTD_seqSymbol MLTable[513];
	HUF_DTable hufTable[4097];
	U32 rep[3];
	U32 workspace[157];
} ZSTD_entropyDTables_t;

typedef struct {
	long long unsigned int frameContentSize;
	long long unsigned int windowSize;
	unsigned int blockSizeMax;
	ZSTD_frameType_e frameType;
	unsigned int headerSize;
	unsigned int dictID;
	unsigned int checksumFlag;
} ZSTD_frameHeader;

typedef struct {
	int contentSizeFlag;
	int checksumFlag;
	int noDictIDFlag;
} ZSTD_frameParameters;

typedef struct {
	long long unsigned int ingested;
	long long unsigned int consumed;
	long long unsigned int produced;
	long long unsigned int flushed;
	unsigned int currentJobID;
	unsigned int nbActiveWorkers;
} ZSTD_frameProgression;

typedef struct {
	size_t compressedSize;
	long long unsigned int decompressedBound;
} ZSTD_frameSizeInfo;

typedef struct {
	size_t state;
	const ZSTD_seqSymbol *table;
} ZSTD_fseState;

struct ZSTD_CDict_s;

typedef struct ZSTD_CDict_s ZSTD_CDict;

typedef struct {
	void *dictBuffer;
	const void *dict;
	size_t dictSize;
	ZSTD_dictContentType_e dictContentType;
	ZSTD_CDict *cdict;
} ZSTD_localDict;

typedef struct {
	rawSeqStore_t seqStore;
	U32 startPosInBlock;
	U32 endPosInBlock;
	U32 offset;
} ZSTD_optLdm_t;

typedef struct {
	ZSTD_compressionParameters cParams;
	ZSTD_frameParameters fParams;
} ZSTD_parameters;

typedef struct {
	U32 fastMode;
	U32 tableLog;
} ZSTD_seqSymbol_header;

typedef struct {
	U32 litLength;
	U32 matchLength;
} ZSTD_sequenceLength;

typedef struct {
	U32 idx;
	U32 posInSequence;
	size_t posInSrc;
} ZSTD_sequencePosition;

typedef struct {
	U32 LLtype;
	U32 Offtype;
	U32 MLtype;
	size_t size;
	size_t lastCountSize;
} ZSTD_symbolEncodingTypeStats_t;

typedef struct {
	long unsigned int fds_bits[16];
} __kernel_fd_set;

typedef struct {
	int val[2];
} __kernel_fsid_t;

typedef struct {
	U32 tableTime;
	U32 decode256Time;
} algo_time_t;

typedef struct {
	unsigned char _[8];
} atm_kptr_t;

typedef struct {
	s64 counter;
} atomic64_t;

typedef atomic64_t atomic_long_t;

typedef struct {
	__be64 a;
	__be64 b;
} be128;

typedef struct {
	blockType_e blockType;
	U32 lastBlock;
	U32 origSize;
} blockProperties_t;

typedef struct {
	union {
		void *kernel;
		void *user;
	};
	bool is_kernel: 1;
} sockptr_t;

typedef sockptr_t bpfptr_t;

struct permanent_flags_t {
	__be16 tag;
	u8 disable;
	u8 ownership;
	u8 deactivated;
	u8 readPubek;
	u8 disableOwnerClear;
	u8 allowMaintenance;
	u8 physicalPresenceLifetimeLock;
	u8 physicalPresenceHWEnable;
	u8 physicalPresenceCMDEnable;
	u8 CEKPUsed;
	u8 TPMpost;
	u8 TPMpostLock;
	u8 FIPS;
	u8 operator;
	u8 enableRevokeEK;
	u8 nvLocked;
	u8 readSRKPub;
	u8 tpmEstablished;
	u8 maintenanceDone;
	u8 disableFullDALogicInfo;
};

struct stclear_flags_t {
	__be16 tag;
	u8 deactivated;
	u8 disableForceClear;
	u8 physicalPresence;
	u8 physicalPresenceLock;
	u8 bGlobalLock;
} __attribute__((packed));

struct tpm1_version {
	u8 major;
	u8 minor;
	u8 rev_major;
	u8 rev_minor;
};

struct tpm1_version2 {
	__be16 tag;
	struct tpm1_version version;
};

struct timeout_t {
	__be32 a;
	__be32 b;
	__be32 c;
	__be32 d;
};

struct duration_t {
	__be32 tpm_short;
	__be32 tpm_medium;
	__be32 tpm_long;
};

typedef union {
	struct permanent_flags_t perm_flags;
	struct stclear_flags_t stclear_flags;
	__u8 owned;
	__be32 num_pcrs;
	struct tpm1_version version1;
	struct tpm1_version2 version2;
	__be32 manufacturer_id;
	struct timeout_t timeout;
	struct duration_t duration;
} cap_t;

typedef struct {
	unsigned int interval;
	unsigned int timeout;
} cisco_proto;

typedef struct {
	void *lock;
} class_cpus_read_lock_t;

struct rq;

typedef struct {
	struct rq *lock;
	struct rq *lock2;
} class_double_rq_lock_t;

typedef struct {
	void *lock;
	long unsigned int flags;
} class_irqsave_t;

typedef struct {
	void *lock;
} class_jump_label_lock_t;

typedef struct {
	void *lock;
} class_preempt_notrace_t;

typedef struct {
	void *lock;
} class_preempt_t;

struct raw_spinlock;

typedef struct raw_spinlock raw_spinlock_t;

typedef struct {
	raw_spinlock_t *lock;
} class_raw_spinlock_irq_t;

typedef struct {
	raw_spinlock_t *lock;
	long unsigned int flags;
} class_raw_spinlock_irqsave_t;

typedef struct {
	raw_spinlock_t *lock;
} class_raw_spinlock_t;

typedef struct {
	void *lock;
} class_rcu_t;

typedef struct {
	void *lock;
} class_rcu_tasks_trace_t;

struct pin_cookie {};

struct rq_flags {
	long unsigned int flags;
	struct pin_cookie cookie;
	unsigned int clock_update_flags;
};

typedef struct {
	struct rq *lock;
	struct rq_flags rf;
} class_rq_lock_irq_t;

typedef struct {
	struct rq *lock;
	struct rq_flags rf;
} class_rq_lock_irqsave_t;

typedef struct {
	struct rq *lock;
	struct rq_flags rf;
} class_rq_lock_t;

struct spinlock;

typedef struct spinlock spinlock_t;

typedef struct {
	spinlock_t *lock;
} class_spinlock_irq_t;

typedef struct {
	spinlock_t *lock;
	long unsigned int flags;
} class_spinlock_irqsave_t;

typedef struct {
	spinlock_t *lock;
} class_spinlock_t;

struct srcu_struct;

typedef struct {
	struct srcu_struct *lock;
	int idx;
} class_srcu_t;

struct task_struct;

typedef struct {
	struct task_struct *lock;
	struct rq *rq;
	struct rq_flags rf;
} class_task_rq_lock_t;

struct qspinlock {
	union {
		atomic_t val;
		struct {
			u8 locked;
			u8 pending;
		};
		struct {
			u16 locked_pending;
			u16 tail;
		};
	};
};

typedef struct qspinlock arch_spinlock_t;

struct qrwlock {
	union {
		atomic_t cnts;
		struct {
			u8 wlocked;
			u8 __lstate[3];
		};
	};
	arch_spinlock_t wait_lock;
};

typedef struct qrwlock arch_rwlock_t;

typedef struct {
	arch_rwlock_t raw_lock;
} rwlock_t;

typedef struct {
	rwlock_t *lock;
} class_write_lock_irq_t;

typedef struct {
	unsigned char op;
	unsigned char bits;
	short unsigned int val;
} code;

typedef union {
	u64 nn;
	struct {
		u8 *vec;
		u8 len;
	} sp;
} dccp_feat_val;

typedef struct {
	long unsigned int bits[1];
} dma_cap_mask_t;

typedef struct {
	__u8 b[16];
} guid_t;

typedef guid_t efi_guid_t;

typedef struct {
	efi_guid_t guid;
	u32 headersize;
	u32 flags;
	u32 imagesize;
} efi_capsule_header_t;

typedef struct {
	efi_guid_t guid;
	u32 table;
} efi_config_table_32_t;

typedef struct {
	efi_guid_t guid;
	u64 table;
} efi_config_table_64_t;

typedef union {
	struct {
		efi_guid_t guid;
		void *table;
	};
	efi_config_table_32_t mixed_mode;
} efi_config_table_t;

typedef struct {
	efi_guid_t guid;
	long unsigned int *ptr;
	const char name[16];
} efi_config_table_type_t;

typedef struct {
	u32 type;
	u32 pad;
	u64 phys_addr;
	u64 virt_addr;
	u64 num_pages;
	u64 attribute;
} efi_memory_desc_t;

typedef struct {
	u32 version;
	u32 num_entries;
	u32 desc_size;
	u32 flags;
	efi_memory_desc_t entry[0];
} efi_memory_attributes_table_t;

typedef struct {
	u16 version;
	u16 length;
	u32 runtime_services_supported;
} efi_rt_properties_table_t;

typedef struct {
	u64 signature;
	u32 revision;
	u32 headersize;
	u32 crc32;
	u32 reserved;
} efi_table_hdr_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 get_time;
	u32 set_time;
	u32 get_wakeup_time;
	u32 set_wakeup_time;
	u32 set_virtual_address_map;
	u32 convert_pointer;
	u32 get_variable;
	u32 get_next_variable;
	u32 set_variable;
	u32 get_next_high_mono_count;
	u32 reset_system;
	u32 update_capsule;
	u32 query_capsule_caps;
	u32 query_variable_info;
} efi_runtime_services_32_t;

typedef struct {
	u16 year;
	u8 month;
	u8 day;
	u8 hour;
	u8 minute;
	u8 second;
	u8 pad1;
	u32 nanosecond;
	s16 timezone;
	u8 daylight;
	u8 pad2;
} efi_time_t;

typedef struct {
	u32 resolution;
	u32 accuracy;
	u8 sets_to_zero;
} efi_time_cap_t;

typedef union {
	struct {
		efi_table_hdr_t hdr;
		efi_status_t (*get_time)(efi_time_t *, efi_time_cap_t *);
		efi_status_t (*set_time)(efi_time_t *);
		efi_status_t (*get_wakeup_time)(efi_bool_t *, efi_bool_t *, efi_time_t *);
		efi_status_t (*set_wakeup_time)(efi_bool_t, efi_time_t *);
		efi_status_t (*set_virtual_address_map)(long unsigned int, long unsigned int, u32, efi_memory_desc_t *);
		void *convert_pointer;
		efi_status_t (*get_variable)(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);
		efi_status_t (*get_next_variable)(long unsigned int *, efi_char16_t *, efi_guid_t *);
		efi_status_t (*set_variable)(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);
		efi_status_t (*get_next_high_mono_count)(u32 *);
		void (*reset_system)(int, efi_status_t, long unsigned int, efi_char16_t *);
		efi_status_t (*update_capsule)(efi_capsule_header_t **, long unsigned int, long unsigned int);
		efi_status_t (*query_capsule_caps)(efi_capsule_header_t **, long unsigned int, u64 *, int *);
		efi_status_t (*query_variable_info)(u32, u64 *, u64 *, u64 *);
	};
	efi_runtime_services_32_t mixed_mode;
} efi_runtime_services_t;

typedef struct {
	efi_guid_t signature_owner;
	u8 signature_data[0];
} efi_signature_data_t;

typedef struct {
	efi_guid_t signature_type;
	u32 signature_list_size;
	u32 signature_header_size;
	u32 signature_size;
	u8 signature_header[0];
} efi_signature_list_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 fw_vendor;
	u32 fw_revision;
	u32 con_in_handle;
	u32 con_in;
	u32 con_out_handle;
	u32 con_out;
	u32 stderr_handle;
	u32 stderr;
	u32 runtime;
	u32 boottime;
	u32 nr_tables;
	u32 tables;
} efi_system_table_32_t;

typedef struct {
	efi_table_hdr_t hdr;
	u64 fw_vendor;
	u32 fw_revision;
	u32 __pad1;
	u64 con_in_handle;
	u64 con_in;
	u64 con_out_handle;
	u64 con_out;
	u64 stderr_handle;
	u64 stderr;
	u64 runtime;
	u64 boottime;
	u32 nr_tables;
	u32 __pad2;
	u64 tables;
} efi_system_table_64_t;

union efi_simple_text_input_protocol;

typedef union efi_simple_text_input_protocol efi_simple_text_input_protocol_t;

union efi_simple_text_output_protocol;

typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;

union efi_boot_services;

typedef union efi_boot_services efi_boot_services_t;

typedef union {
	struct {
		efi_table_hdr_t hdr;
		long unsigned int fw_vendor;
		u32 fw_revision;
		long unsigned int con_in_handle;
		efi_simple_text_input_protocol_t *con_in;
		long unsigned int con_out_handle;
		efi_simple_text_output_protocol_t *con_out;
		long unsigned int stderr_handle;
		long unsigned int stderr;
		efi_runtime_services_t *runtime;
		efi_boot_services_t *boottime;
		long unsigned int nr_tables;
		long unsigned int tables;
	};
	efi_system_table_32_t mixed_mode;
} efi_system_table_t;

typedef struct {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
} ext4_acl_entry;

typedef struct {
	__le32 a_version;
} ext4_acl_header;

typedef __kernel_fd_set fd_set;

typedef struct {
	long unsigned int *in;
	long unsigned int *out;
	long unsigned int *ex;
	long unsigned int *res_in;
	long unsigned int *res_out;
	long unsigned int *res_ex;
} fd_set_bits;

typedef struct {
	atomic64_t refcnt;
} file_ref_t;

typedef struct {
	unsigned int t391;
	unsigned int t392;
	unsigned int n391;
	unsigned int n392;
	unsigned int n393;
	short unsigned int lmi;
	short unsigned int dce;
} fr_proto;

typedef struct {
	unsigned int dlci;
} fr_proto_pvc;

typedef struct {
	unsigned int dlci;
	char master[16];
} fr_proto_pvc_info;

typedef union {
	struct {
		void *freelist;
		long unsigned int counter;
	};
	freelist_full_t full;
} freelist_aba_t;

typedef struct {
	long unsigned int v;
} freeptr_t;

typedef struct {
	long unsigned int key[2];
} hsiphash_key_t;

typedef struct {
	u32 reg;
} i915_mcr_reg_t;

typedef struct {
	u32 reg;
} i915_reg_t;

typedef union {
	u8 hsw[3];
	long unsigned int xehp[1];
} intel_sseu_ss_mask_t;

typedef struct {
	u8 kvm_cpu_l1tf_flush_l1d;
	unsigned int __nmi_count;
	unsigned int apic_timer_irqs;
	unsigned int irq_spurious_count;
	unsigned int icr_read_retry_count;
	unsigned int kvm_posted_intr_ipis;
	unsigned int kvm_posted_intr_wakeup_ipis;
	unsigned int kvm_posted_intr_nested_ipis;
	unsigned int x86_platform_ipis;
	unsigned int apic_perf_irqs;
	unsigned int apic_irq_work_irqs;
	unsigned int irq_resched_count;
	unsigned int irq_call_count;
	unsigned int irq_tlb_count;
	unsigned int irq_thermal_count;
	unsigned int irq_threshold_count;
	unsigned int irq_deferred_error_count;
	unsigned int irq_hv_callback_count;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
} irq_cpustat_t;

typedef struct {
	u64 val;
} kernel_cap_t;

typedef struct {
	gid_t val;
} kgid_t;

typedef struct {
	projid_t val;
} kprojid_t;

typedef struct {
	uid_t val;
} kuid_t;

typedef struct {
	U32 offset;
	U32 checksum;
} ldmEntry_t;

typedef struct {
	const BYTE *split;
	U32 hash;
	U32 checksum;
	ldmEntry_t *bucket;
} ldmMatchCandidate_t;

typedef struct {
	ZSTD_paramSwitch_e enableLdm;
	U32 hashLog;
	U32 bucketSizeLog;
	U32 minMatchLength;
	U32 hashRateLog;
	U32 windowLog;
} ldmParams_t;

typedef struct {
	U64 rolling;
	U64 stopMask;
} ldmRollingHashState_t;

typedef struct {
	ZSTD_window_t window;
	ldmEntry_t *hashTable;
	U32 loadedDictEnd;
	BYTE *bucketOffsets;
	size_t splitIndices[64];
	ldmMatchCandidate_t matchCandidates[64];
} ldmState_t;

typedef struct {
	__le64 b;
	__le64 a;
} le128;

typedef struct {
	atomic_long_t a;
} local_t;

typedef struct {
	local_t a;
} local64_t;

typedef struct {} local_lock_t;

typedef struct {} lockdep_map_p;

struct optimistic_spin_queue {
	atomic_t tail;
};

struct raw_spinlock {
	arch_spinlock_t raw_lock;
};

struct rw_semaphore {
	atomic_long_t count;
	atomic_long_t owner;
	struct optimistic_spin_queue osq;
	raw_spinlock_t wait_lock;
	struct list_head wait_list;
};

struct mutex {
	atomic_long_t owner;
	raw_spinlock_t wait_lock;
	struct optimistic_spin_queue osq;
	struct list_head wait_list;
};

struct ldt_struct;

struct vdso_image;

typedef struct {
	u64 ctx_id;
	atomic64_t tlb_gen;
	long unsigned int next_trim_cpumask;
	struct rw_semaphore ldt_usr_sem;
	struct ldt_struct *ldt;
	long unsigned int flags;
	struct mutex lock;
	void *vdso;
	const struct vdso_image *vdso_image;
	atomic_t perf_rdpmc_allowed;
	u16 pkey_allocation_map;
	s16 execute_only_pkey;
} mm_context_t;

typedef struct {} netdevice_tracker;

typedef struct {} netns_tracker;

typedef struct {
	char data[8];
} nfs4_verifier;

typedef struct {
	long unsigned int bits[1];
} nodemask_t;

typedef struct {
	p4dval_t p4d;
} p4d_t;

typedef struct {
	u64 pme;
} pagemap_entry_t;

typedef struct {
	u64 val;
} pfn_t;

typedef struct {
	pgdval_t pgd;
} pgd_t;

typedef struct {
	pmdval_t pmd;
} pmd_t;

typedef struct {
	long unsigned int bits[4];
} pnp_irq_mask_t;

struct net;

typedef struct {
	struct net *net;
} possible_net_t;

typedef struct {
	pteval_t pte;
} pte_t;

typedef struct {
	pudval_t pud;
} pud_t;

typedef struct {
	short unsigned int encoding;
	short unsigned int parity;
} raw_hdlc_proto;

typedef struct {
	atomic_t refcnt;
} rcuref_t;

typedef struct {
	size_t written;
	size_t count;
	union {
		char *buf;
		void *data;
	} arg;
	int error;
} read_descriptor_t;

typedef union {
} release_pages_arg;

typedef struct {
	sctp_assoc_t associd;
	int sd;
} sctp_peeloff_arg_t;

typedef struct {
	sctp_peeloff_arg_t p_arg;
	unsigned int flags;
} sctp_peeloff_flags_arg_t;

typedef struct {
	BIT_DStream_t DStream;
	ZSTD_fseState stateLL;
	ZSTD_fseState stateOffb;
	ZSTD_fseState stateML;
	size_t prevOffset[3];
} seqState_t;

typedef struct {
	U32 *splitLocations;
	size_t idx;
} seqStoreSplits;

typedef struct {
	size_t litLength;
	size_t matchLength;
	size_t offset;
} seq_t;

struct seqcount {
	unsigned int sequence;
};

typedef struct seqcount seqcount_t;

typedef struct {
	seqcount_t seqcount;
} seqcount_latch_t;

struct seqcount_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_spinlock seqcount_spinlock_t;

struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
};

typedef struct {
	seqcount_spinlock_t seqcount;
	spinlock_t lock;
} seqlock_t;

typedef struct {
	long unsigned int sig[1];
} sigset_t;

typedef struct {
	u64 key[2];
} siphash_key_t;

struct wait_queue_head {
	spinlock_t lock;
	struct list_head head;
};

typedef struct wait_queue_head wait_queue_head_t;

typedef struct {
	spinlock_t slock;
	int owned;
	wait_queue_head_t wq;
} socket_lock_t;

typedef struct {
	char *from;
	char *to;
} substring_t;

typedef struct {
	long unsigned int val;
} swp_entry_t;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
} sync_serial_settings;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
	unsigned int slot_map;
} te1_settings;

struct mm_struct;

typedef struct {
	struct mm_struct *mm;
} temp_mm_state_t;

typedef struct {
	local64_t v;
} u64_stats_t;

typedef struct {
	u64 m_low;
	u64 m_high;
} uint128_t;

typedef struct {
	u32 val;
} uint_fixed_16_16_t;

typedef struct {
	__u8 b[16];
} uuid_le;

typedef struct {
	__u8 b[16];
} uuid_t;

typedef struct {
	gid_t val;
} vfsgid_t;

typedef struct {
	uid_t val;
} vfsuid_t;

typedef struct {
	short unsigned int dce;
	unsigned int modulo;
	unsigned int window;
	unsigned int t1;
	unsigned int t2;
	unsigned int n2;
} x25_hdlc_proto;

struct in6_addr {
	union {
		__u8 u6_addr8[16];
		__be16 u6_addr16[8];
		__be32 u6_addr32[4];
	} in6_u;
};

typedef union {
	__be32 a4;
	__be32 a6[4];
	struct in6_addr in6;
} xfrm_address_t;

typedef ZSTD_compressionParameters zstd_compression_parameters;

typedef ZSTD_customMem zstd_custom_mem;

typedef ZSTD_frameHeader zstd_frame_header;

typedef ZSTD_parameters zstd_parameters;

struct AdmissionConfirm {
	enum {
		eAdmissionConfirm_irrFrequency = -2147483648,
		eAdmissionConfirm_nonStandardData = 1073741824,
		eAdmissionConfirm_destinationInfo = 536870912,
		eAdmissionConfirm_destExtraCallInfo = 268435456,
		eAdmissionConfirm_destinationType = 134217728,
		eAdmissionConfirm_remoteExtensionAddress = 67108864,
		eAdmissionConfirm_alternateEndpoints = 33554432,
		eAdmissionConfirm_tokens = 16777216,
		eAdmissionConfirm_cryptoTokens = 8388608,
		eAdmissionConfirm_integrityCheckValue = 4194304,
		eAdmissionConfirm_transportQOS = 2097152,
		eAdmissionConfirm_willRespondToIRR = 1048576,
		eAdmissionConfirm_uuiesRequested = 524288,
		eAdmissionConfirm_language = 262144,
		eAdmissionConfirm_alternateTransportAddresses = 131072,
		eAdmissionConfirm_useSpecifiedTransport = 65536,
		eAdmissionConfirm_circuitInfo = 32768,
		eAdmissionConfirm_usageSpec = 16384,
		eAdmissionConfirm_supportedProtocols = 8192,
		eAdmissionConfirm_serviceControl = 4096,
		eAdmissionConfirm_multipleCalls = 2048,
		eAdmissionConfirm_featureSet = 1024,
		eAdmissionConfirm_genericData = 512,
	} options;
	TransportAddress destCallSignalAddress;
};

typedef struct AdmissionConfirm AdmissionConfirm;

struct AdmissionRequest {
	enum {
		eAdmissionRequest_callModel = -2147483648,
		eAdmissionRequest_destinationInfo = 1073741824,
		eAdmissionRequest_destCallSignalAddress = 536870912,
		eAdmissionRequest_destExtraCallInfo = 268435456,
		eAdmissionRequest_srcCallSignalAddress = 134217728,
		eAdmissionRequest_nonStandardData = 67108864,
		eAdmissionRequest_callServices = 33554432,
		eAdmissionRequest_canMapAlias = 16777216,
		eAdmissionRequest_callIdentifier = 8388608,
		eAdmissionRequest_srcAlternatives = 4194304,
		eAdmissionRequest_destAlternatives = 2097152,
		eAdmissionRequest_gatekeeperIdentifier = 1048576,
		eAdmissionRequest_tokens = 524288,
		eAdmissionRequest_cryptoTokens = 262144,
		eAdmissionRequest_integrityCheckValue = 131072,
		eAdmissionRequest_transportQOS = 65536,
		eAdmissionRequest_willSupplyUUIEs = 32768,
		eAdmissionRequest_callLinkage = 16384,
		eAdmissionRequest_gatewayDataRate = 8192,
		eAdmissionRequest_capacity = 4096,
		eAdmissionRequest_circuitInfo = 2048,
		eAdmissionRequest_desiredProtocols = 1024,
		eAdmissionRequest_desiredTunnelledProtocol = 512,
		eAdmissionRequest_featureSet = 256,
		eAdmissionRequest_genericData = 128,
	} options;
	TransportAddress destCallSignalAddress;
	TransportAddress srcCallSignalAddress;
};

typedef struct AdmissionRequest AdmissionRequest;

struct GatekeeperConfirm {
	enum {
		eGatekeeperConfirm_nonStandardData = -2147483648,
		eGatekeeperConfirm_gatekeeperIdentifier = 1073741824,
		eGatekeeperConfirm_alternateGatekeeper = 536870912,
		eGatekeeperConfirm_authenticationMode = 268435456,
		eGatekeeperConfirm_tokens = 134217728,
		eGatekeeperConfirm_cryptoTokens = 67108864,
		eGatekeeperConfirm_algorithmOID = 33554432,
		eGatekeeperConfirm_integrity = 16777216,
		eGatekeeperConfirm_integrityCheckValue = 8388608,
		eGatekeeperConfirm_featureSet = 4194304,
		eGatekeeperConfirm_genericData = 2097152,
	} options;
	TransportAddress rasAddress;
};

typedef struct GatekeeperConfirm GatekeeperConfirm;

struct GatekeeperRequest {
	enum {
		eGatekeeperRequest_nonStandardData = -2147483648,
		eGatekeeperRequest_gatekeeperIdentifier = 1073741824,
		eGatekeeperRequest_callServices = 536870912,
		eGatekeeperRequest_endpointAlias = 268435456,
		eGatekeeperRequest_alternateEndpoints = 134217728,
		eGatekeeperRequest_tokens = 67108864,
		eGatekeeperRequest_cryptoTokens = 33554432,
		eGatekeeperRequest_authenticationCapability = 16777216,
		eGatekeeperRequest_algorithmOIDs = 8388608,
		eGatekeeperRequest_integrity = 4194304,
		eGatekeeperRequest_integrityCheckValue = 2097152,
		eGatekeeperRequest_supportsAltGK = 1048576,
		eGatekeeperRequest_featureSet = 524288,
		eGatekeeperRequest_genericData = 262144,
	} options;
	TransportAddress rasAddress;
};

typedef struct GatekeeperRequest GatekeeperRequest;

union IO_APIC_reg_00 {
	u32 raw;
	struct {
		u32 __reserved_2: 14;
		u32 LTS: 1;
		u32 delivery_type: 1;
		u32 __reserved_1: 8;
		u32 ID: 8;
	} bits;
};

union IO_APIC_reg_01 {
	u32 raw;
	struct {
		u32 version: 8;
		u32 __reserved_2: 7;
		u32 PRQ: 1;
		u32 entries: 8;
		u32 __reserved_1: 8;
	} bits;
};

union IO_APIC_reg_02 {
	u32 raw;
	struct {
		u32 __reserved_2: 24;
		u32 arbitration: 4;
		u32 __reserved_1: 4;
	} bits;
};

union IO_APIC_reg_03 {
	u32 raw;
	struct {
		u32 boot_DT: 1;
		u32 __reserved_1: 31;
	} bits;
};

struct IO_APIC_route_entry {
	union {
		struct {
			u64 vector: 8;
			u64 delivery_mode: 3;
			u64 dest_mode_logical: 1;
			u64 delivery_status: 1;
			u64 active_low: 1;
			u64 irr: 1;
			u64 is_level: 1;
			u64 masked: 1;
			u64 reserved_0: 15;
			u64 reserved_1: 17;
			u64 virt_destid_8_14: 7;
			u64 destid_0_7: 8;
		};
		struct {
			u64 ir_shared_0: 8;
			u64 ir_zero: 3;
			u64 ir_index_15: 1;
			u64 ir_shared_1: 5;
			u64 ir_reserved_0: 31;
			u64 ir_format: 1;
			u64 ir_index_0_14: 15;
		};
		struct {
			u64 w1: 32;
			u64 w2: 32;
		};
	};
};

struct InfoRequestResponse_callSignalAddress {
	int count;
	TransportAddress item[10];
};

typedef struct InfoRequestResponse_callSignalAddress InfoRequestResponse_callSignalAddress;

struct InfoRequestResponse {
	enum {
		eInfoRequestResponse_nonStandardData = -2147483648,
		eInfoRequestResponse_endpointAlias = 1073741824,
		eInfoRequestResponse_perCallInfo = 536870912,
		eInfoRequestResponse_tokens = 268435456,
		eInfoRequestResponse_cryptoTokens = 134217728,
		eInfoRequestResponse_integrityCheckValue = 67108864,
		eInfoRequestResponse_needResponse = 33554432,
		eInfoRequestResponse_capacity = 16777216,
		eInfoRequestResponse_irrStatus = 8388608,
		eInfoRequestResponse_unsolicited = 4194304,
		eInfoRequestResponse_genericData = 2097152,
	} options;
	TransportAddress rasAddress;
	InfoRequestResponse_callSignalAddress callSignalAddress;
};

typedef struct InfoRequestResponse InfoRequestResponse;

struct LocationConfirm {
	enum {
		eLocationConfirm_nonStandardData = -2147483648,
		eLocationConfirm_destinationInfo = 1073741824,
		eLocationConfirm_destExtraCallInfo = 536870912,
		eLocationConfirm_destinationType = 268435456,
		eLocationConfirm_remoteExtensionAddress = 134217728,
		eLocationConfirm_alternateEndpoints = 67108864,
		eLocationConfirm_tokens = 33554432,
		eLocationConfirm_cryptoTokens = 16777216,
		eLocationConfirm_integrityCheckValue = 8388608,
		eLocationConfirm_alternateTransportAddresses = 4194304,
		eLocationConfirm_supportedProtocols = 2097152,
		eLocationConfirm_multipleCalls = 1048576,
		eLocationConfirm_featureSet = 524288,
		eLocationConfirm_genericData = 262144,
		eLocationConfirm_circuitInfo = 131072,
		eLocationConfirm_serviceControl = 65536,
	} options;
	TransportAddress callSignalAddress;
	TransportAddress rasAddress;
};

typedef struct LocationConfirm LocationConfirm;

struct LocationRequest {
	enum {
		eLocationRequest_endpointIdentifier = -2147483648,
		eLocationRequest_nonStandardData = 1073741824,
		eLocationRequest_sourceInfo = 536870912,
		eLocationRequest_canMapAlias = 268435456,
		eLocationRequest_gatekeeperIdentifier = 134217728,
		eLocationRequest_tokens = 67108864,
		eLocationRequest_cryptoTokens = 33554432,
		eLocationRequest_integrityCheckValue = 16777216,
		eLocationRequest_desiredProtocols = 8388608,
		eLocationRequest_desiredTunnelledProtocol = 4194304,
		eLocationRequest_featureSet = 2097152,
		eLocationRequest_genericData = 1048576,
		eLocationRequest_hopCount = 524288,
		eLocationRequest_circuitInfo = 262144,
	} options;
	TransportAddress replyAddress;
};

typedef struct LocationRequest LocationRequest;

struct PptpCallDisconnectNotify {
	__be16 callID;
	__u8 resultCode;
	__u8 generalErrorCode;
	__be16 causeCode;
	__u16 reserved;
	__u8 callStatistics[128];
};

struct PptpClearCallRequest {
	__be16 callID;
	__u16 reserved;
};

struct PptpControlHeader {
	__be16 messageType;
	__u16 reserved;
};

struct PptpInCallConnected {
	__be16 peersCallID;
	__u16 reserved;
	__be32 connectSpeed;
	__be16 packetWindow;
	__be16 packetProcDelay;
	__be32 callFramingType;
};

struct PptpInCallReply {
	__be16 callID;
	__be16 peersCallID;
	__u8 resultCode;
	__u8 generalErrorCode;
	__be16 packetWindow;
	__be16 packetProcDelay;
	__u16 reserved;
};

struct PptpInCallRequest {
	__be16 callID;
	__be16 callSerialNumber;
	__be32 callBearerType;
	__be32 physChannelID;
	__be16 dialedNumberLength;
	__be16 dialingNumberLength;
	__u8 dialedNumber[64];
	__u8 dialingNumber[64];
	__u8 subAddress[64];
};

struct PptpOutCallReply {
	__be16 callID;
	__be16 peersCallID;
	__u8 resultCode;
	__u8 generalErrorCode;
	__be16 causeCode;
	__be32 connectSpeed;
	__be16 packetWindow;
	__be16 packetProcDelay;
	__be32 physChannelID;
};

struct PptpOutCallRequest {
	__be16 callID;
	__be16 callSerialNumber;
	__be32 minBPS;
	__be32 maxBPS;
	__be32 bearerType;
	__be32 framingType;
	__be16 packetWindow;
	__be16 packetProcDelay;
	__be16 phoneNumberLength;
	__u16 reserved1;
	__u8 phoneNumber[64];
	__u8 subAddress[64];
};

struct PptpSetLinkInfo {
	__be16 peersCallID;
	__u16 reserved;
	__be32 sendAccm;
	__be32 recvAccm;
};

struct PptpStartSessionReply {
	__be16 protocolVersion;
	__u8 resultCode;
	__u8 generalErrorCode;
	__be32 framingCapability;
	__be32 bearerCapability;
	__be16 maxChannels;
	__be16 firmwareRevision;
	__u8 hostName[64];
	__u8 vendorString[64];
};

struct PptpStartSessionRequest {
	__be16 protocolVersion;
	__u16 reserved1;
	__be32 framingCapability;
	__be32 bearerCapability;
	__be16 maxChannels;
	__be16 firmwareRevision;
	__u8 hostName[64];
	__u8 vendorString[64];
};

struct PptpStopSessionReply {
	__u8 resultCode;
	__u8 generalErrorCode;
	__u16 reserved1;
};

struct PptpStopSessionRequest {
	__u8 reason;
	__u8 reserved1;
	__u16 reserved2;
};

struct PptpWanErrorNotify {
	__be16 peersCallID;
	__u16 reserved;
	__be32 crcErrors;
	__be32 framingErrors;
	__be32 hardwareOverRuns;
	__be32 bufferOverRuns;
	__be32 timeoutErrors;
	__be32 alignmentErrors;
};

struct hlist_node {
	struct hlist_node *next;
	struct hlist_node **pprev;
};

struct sk_buff;

struct sk_buff_list {
	struct sk_buff *next;
	struct sk_buff *prev;
};

struct sk_buff_head {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
		};
		struct sk_buff_list list;
	};
	__u32 qlen;
	spinlock_t lock;
};

struct qdisc_skb_head {
	struct sk_buff *head;
	struct sk_buff *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct u64_stats_sync {};

struct gnet_stats_basic_sync {
	u64_stats_t bytes;
	u64_stats_t packets;
	struct u64_stats_sync syncp;
};

struct gnet_stats_queue {
	__u32 qlen;
	__u32 backlog;
	__u32 drops;
	__u32 requeues;
	__u32 overlimits;
};

struct callback_head {
	struct callback_head *next;
	void (*func)(struct callback_head *);
};

struct lock_class_key {};

struct Qdisc_ops;

struct qdisc_size_table;

struct netdev_queue;

struct net_rate_estimator;

struct Qdisc {
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops *ops;
	struct qdisc_size_table *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue *dev_queue;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_sync *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	int pad;
	refcount_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head gso_skb;
	struct qdisc_skb_head q;
	struct gnet_stats_basic_sync bstats;
	struct gnet_stats_queue qstats;
	int owner;
	long unsigned int state;
	long unsigned int state2;
	struct Qdisc *next_sched;
	struct sk_buff_head skb_bad_txq;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t busylock;
	spinlock_t seqlock;
	struct callback_head rcu;
	netdevice_tracker dev_tracker;
	struct lock_class_key root_lock_key;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long int privdata[0];
};

struct Qdisc_class_common {
	u32 classid;
	unsigned int filter_cnt;
	struct hlist_node hnode;
};

struct hlist_head;

struct Qdisc_class_hash {
	struct hlist_head *hash;
	unsigned int hashsize;
	unsigned int hashmask;
	unsigned int hashelems;
};

struct tcmsg;

struct netlink_ext_ack;

struct nlattr;

struct qdisc_walker;

struct tcf_block;

struct gnet_dump;

struct Qdisc_class_ops {
	unsigned int flags;
	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
	int (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
	struct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);
	void (*qlen_notify)(struct Qdisc *, long unsigned int);
	long unsigned int (*find)(struct Qdisc *, u32);
	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	void (*walk)(struct Qdisc *, struct qdisc_walker *);
	struct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	long unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);
	void (*unbind_tcf)(struct Qdisc *, long unsigned int);
	int (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);
};

struct module;

struct Qdisc_ops {
	struct Qdisc_ops *next;
	const struct Qdisc_class_ops *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct sk_buff * (*peek)(struct Qdisc *);
	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc *);
	void (*destroy)(struct Qdisc *);
	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc *);
	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
	void (*change_real_num_tx)(struct Qdisc *, unsigned int);
	int (*dump)(struct Qdisc *, struct sk_buff *);
	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
	void (*ingress_block_set)(struct Qdisc *, u32);
	void (*egress_block_set)(struct Qdisc *, u32);
	u32 (*ingress_block_get)(struct Qdisc *);
	u32 (*egress_block_get)(struct Qdisc *);
	struct module *owner;
};

struct RR_CL_s {
	__u8 location[8];
};

struct RR_NM_s {
	__u8 flags;
	char name[0];
};

struct RR_PL_s {
	__u8 location[8];
};

struct RR_PN_s {
	__u8 dev_high[8];
	__u8 dev_low[8];
};

struct RR_PX_s {
	__u8 mode[8];
	__u8 n_links[8];
	__u8 uid[8];
	__u8 gid[8];
};

struct RR_RR_s {
	__u8 flags[1];
};

struct SL_component {
	__u8 flags;
	__u8 len;
	__u8 text[0];
};

struct RR_SL_s {
	__u8 flags;
	struct SL_component link;
};

struct stamp {
	__u8 time[7];
};

struct RR_TF_s {
	__u8 flags;
	struct stamp times[0];
};

struct RR_ZF_s {
	__u8 algorithm[2];
	__u8 parms[2];
	__u8 real_size[8];
};

struct RegistrationRequest_callSignalAddress {
	int count;
	TransportAddress item[10];
};

typedef struct RegistrationRequest_callSignalAddress RegistrationRequest_callSignalAddress;

struct RegistrationRequest_rasAddress {
	int count;
	TransportAddress item[10];
};

typedef struct RegistrationRequest_rasAddress RegistrationRequest_rasAddress;

struct RegistrationRequest {
	enum {
		eRegistrationRequest_nonStandardData = -2147483648,
		eRegistrationRequest_terminalAlias = 1073741824,
		eRegistrationRequest_gatekeeperIdentifier = 536870912,
		eRegistrationRequest_alternateEndpoints = 268435456,
		eRegistrationRequest_timeToLive = 134217728,
		eRegistrationRequest_tokens = 67108864,
		eRegistrationRequest_cryptoTokens = 33554432,
		eRegistrationRequest_integrityCheckValue = 16777216,
		eRegistrationRequest_keepAlive = 8388608,
		eRegistrationRequest_endpointIdentifier = 4194304,
		eRegistrationRequest_willSupplyUUIEs = 2097152,
		eRegistrationRequest_maintainConnection = 1048576,
		eRegistrationRequest_alternateTransportAddresses = 524288,
		eRegistrationRequest_additiveRegistration = 262144,
		eRegistrationRequest_terminalAliasPattern = 131072,
		eRegistrationRequest_supportsAltGK = 65536,
		eRegistrationRequest_usageReportingCapability = 32768,
		eRegistrationRequest_multipleCalls = 16384,
		eRegistrationRequest_supportedH248Packages = 8192,
		eRegistrationRequest_callCreditCapability = 4096,
		eRegistrationRequest_capacityReportingCapability = 2048,
		eRegistrationRequest_capacity = 1024,
		eRegistrationRequest_featureSet = 512,
		eRegistrationRequest_genericData = 256,
	} options;
	RegistrationRequest_callSignalAddress callSignalAddress;
	RegistrationRequest_rasAddress rasAddress;
	unsigned int timeToLive;
};

typedef struct RegistrationRequest RegistrationRequest;

struct RegistrationConfirm_callSignalAddress {
	int count;
	TransportAddress item[10];
};

typedef struct RegistrationConfirm_callSignalAddress RegistrationConfirm_callSignalAddress;

struct RegistrationConfirm {
	enum {
		eRegistrationConfirm_nonStandardData = -2147483648,
		eRegistrationConfirm_terminalAlias = 1073741824,
		eRegistrationConfirm_gatekeeperIdentifier = 536870912,
		eRegistrationConfirm_alternateGatekeeper = 268435456,
		eRegistrationConfirm_timeToLive = 134217728,
		eRegistrationConfirm_tokens = 67108864,
		eRegistrationConfirm_cryptoTokens = 33554432,
		eRegistrationConfirm_integrityCheckValue = 16777216,
		eRegistrationConfirm_willRespondToIRR = 8388608,
		eRegistrationConfirm_preGrantedARQ = 4194304,
		eRegistrationConfirm_maintainConnection = 2097152,
		eRegistrationConfirm_serviceControl = 1048576,
		eRegistrationConfirm_supportsAdditiveRegistration = 524288,
		eRegistrationConfirm_terminalAliasPattern = 262144,
		eRegistrationConfirm_supportedPrefixes = 131072,
		eRegistrationConfirm_usageSpec = 65536,
		eRegistrationConfirm_featureServerAlias = 32768,
		eRegistrationConfirm_capacityReportingSpec = 16384,
		eRegistrationConfirm_featureSet = 8192,
		eRegistrationConfirm_genericData = 4096,
	} options;
	RegistrationConfirm_callSignalAddress callSignalAddress;
	unsigned int timeToLive;
};

typedef struct RegistrationConfirm RegistrationConfirm;

struct UnregistrationRequest_callSignalAddress {
	int count;
	TransportAddress item[10];
};

typedef struct UnregistrationRequest_callSignalAddress UnregistrationRequest_callSignalAddress;

struct UnregistrationRequest {
	enum {
		eUnregistrationRequest_endpointAlias = -2147483648,
		eUnregistrationRequest_nonStandardData = 1073741824,
		eUnregistrationRequest_endpointIdentifier = 536870912,
		eUnregistrationRequest_alternateEndpoints = 268435456,
		eUnregistrationRequest_gatekeeperIdentifier = 134217728,
		eUnregistrationRequest_tokens = 67108864,
		eUnregistrationRequest_cryptoTokens = 33554432,
		eUnregistrationRequest_integrityCheckValue = 16777216,
		eUnregistrationRequest_reason = 8388608,
		eUnregistrationRequest_endpointAliasPattern = 4194304,
		eUnregistrationRequest_supportedPrefixes = 2097152,
		eUnregistrationRequest_alternateGatekeeper = 1048576,
		eUnregistrationRequest_genericData = 524288,
	} options;
	UnregistrationRequest_callSignalAddress callSignalAddress;
};

typedef struct UnregistrationRequest UnregistrationRequest;

struct RasMessage {
	enum {
		eRasMessage_gatekeeperRequest = 0,
		eRasMessage_gatekeeperConfirm = 1,
		eRasMessage_gatekeeperReject = 2,
		eRasMessage_registrationRequest = 3,
		eRasMessage_registrationConfirm = 4,
		eRasMessage_registrationReject = 5,
		eRasMessage_unregistrationRequest = 6,
		eRasMessage_unregistrationConfirm = 7,
		eRasMessage_unregistrationReject = 8,
		eRasMessage_admissionRequest = 9,
		eRasMessage_admissionConfirm = 10,
		eRasMessage_admissionReject = 11,
		eRasMessage_bandwidthRequest = 12,
		eRasMessage_bandwidthConfirm = 13,
		eRasMessage_bandwidthReject = 14,
		eRasMessage_disengageRequest = 15,
		eRasMessage_disengageConfirm = 16,
		eRasMessage_disengageReject = 17,
		eRasMessage_locationRequest = 18,
		eRasMessage_locationConfirm = 19,
		eRasMessage_locationReject = 20,
		eRasMessage_infoRequest = 21,
		eRasMessage_infoRequestResponse = 22,
		eRasMessage_nonStandardMessage = 23,
		eRasMessage_unknownMessageResponse = 24,
		eRasMessage_requestInProgress = 25,
		eRasMessage_resourcesAvailableIndicate = 26,
		eRasMessage_resourcesAvailableConfirm = 27,
		eRasMessage_infoRequestAck = 28,
		eRasMessage_infoRequestNak = 29,
		eRasMessage_serviceControlIndication = 30,
		eRasMessage_serviceControlResponse = 31,
	} choice;
	union {
		GatekeeperRequest gatekeeperRequest;
		GatekeeperConfirm gatekeeperConfirm;
		RegistrationRequest registrationRequest;
		RegistrationConfirm registrationConfirm;
		UnregistrationRequest unregistrationRequest;
		AdmissionRequest admissionRequest;
		AdmissionConfirm admissionConfirm;
		LocationRequest locationRequest;
		LocationConfirm locationConfirm;
		InfoRequestResponse infoRequestResponse;
	};
};

typedef struct RasMessage RasMessage;

struct SU_CE_s {
	__u8 extent[8];
	__u8 offset[8];
	__u8 size[8];
};

struct SU_ER_s {
	__u8 len_id;
	__u8 len_des;
	__u8 len_src;
	__u8 ext_ver;
	__u8 data[0];
};

struct SU_SP_s {
	__u8 magic[2];
	__u8 skip;
};

struct kref {
	refcount_t refcount;
};

struct swait_queue_head {
	raw_spinlock_t lock;
	struct list_head task_list;
};

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};

struct blk_mq_queue_map {
	unsigned int *mq_map;
	unsigned int nr_queues;
	unsigned int queue_offset;
};

struct blk_mq_ops;

struct blk_mq_tags;

struct blk_mq_tag_set {
	const struct blk_mq_ops *ops;
	struct blk_mq_queue_map map[3];
	unsigned int nr_maps;
	unsigned int nr_hw_queues;
	unsigned int queue_depth;
	unsigned int reserved_tags;
	unsigned int cmd_size;
	int numa_node;
	unsigned int timeout;
	unsigned int flags;
	void *driver_data;
	struct blk_mq_tags **tags;
	struct blk_mq_tags *shared_tags;
	struct mutex tag_list_lock;
	struct list_head tag_list;
	struct srcu_struct *srcu;
};

struct kset;

struct kobj_type;

struct kernfs_node;

struct kobject {
	const char *name;
	struct list_head entry;
	struct kobject *parent;
	struct kset *kset;
	const struct kobj_type *ktype;
	struct kernfs_node *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
};

struct dev_links_info {
	struct list_head suppliers;
	struct list_head consumers;
	struct list_head defer_sync;
	enum dl_dev_state status;
};

struct pm_message {
	int event;
};

typedef struct pm_message pm_message_t;

struct rb_node {
	long unsigned int __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
};

struct timerqueue_node {
	struct rb_node node;
	ktime_t expires;
};

struct hrtimer_clock_base;

struct hrtimer {
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *);
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
};

struct work_struct;

typedef void (*work_func_t)(struct work_struct *);

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
};

struct wakeup_source;

struct wake_irq;

struct pm_subsys_data;

struct device;

struct dev_pm_qos;

struct dev_pm_info {
	pm_message_t power_state;
	bool can_wakeup: 1;
	bool async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	struct list_head entry;
	struct completion completion;
	struct wakeup_source *wakeup;
	bool wakeup_path: 1;
	bool syscore: 1;
	bool no_pm_callbacks: 1;
	bool async_in_progress: 1;
	bool must_resume: 1;
	bool set_active: 1;
	bool may_skip_resume: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	bool idle_notification: 1;
	bool request_pending: 1;
	bool deferred_resume: 1;
	bool needs_force_resume: 1;
	bool runtime_auto: 1;
	bool ignore_children: 1;
	bool no_callbacks: 1;
	bool irq_safe: 1;
	bool use_autosuspend: 1;
	bool timer_autosuspends: 1;
	bool memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	enum rpm_status last_status;
	int runtime_error;
	int autosuspend_delay;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device *, s32);
	struct dev_pm_qos *qos;
};

struct irq_domain;

struct msi_device_data;

struct dev_msi_info {
	struct irq_domain *domain;
	struct msi_device_data *data;
};

struct dev_archdata {};

struct device_private;

struct device_type;

struct bus_type;

struct device_driver;

struct dev_pm_domain;

struct bus_dma_region;

struct device_dma_parameters;

struct io_tlb_mem;

struct device_node;

struct fwnode_handle;

struct class;

struct attribute_group;

struct iommu_group;

struct dev_iommu;

struct device_physical_location;

struct device {
	struct kobject kobj;
	struct device *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type *type;
	const struct bus_type *bus;
	struct device_driver *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	struct dev_pm_info power;
	struct dev_pm_domain *pm_domain;
	struct dev_msi_info msi;
	u64 *dma_mask;
	u64 coherent_dma_mask;
	u64 bus_dma_limit;
	const struct bus_dma_region *dma_range_map;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct io_tlb_mem *dma_io_tlb_mem;
	struct dev_archdata archdata;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	int numa_node;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	const struct class *class;
	const struct attribute_group **groups;
	void (*release)(struct device *);
	struct iommu_group *iommu_group;
	struct dev_iommu *iommu;
	struct device_physical_location *physical_location;
	enum device_removable removable;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
	bool state_synced: 1;
	bool can_match: 1;
	bool dma_skip_sync: 1;
	bool dma_iommu: 1;
};

struct scsi_host_template;

struct scsi_transport_template;

struct workqueue_struct;

struct Scsi_Host {
	struct list_head __devices;
	struct list_head __targets;
	struct list_head starved_list;
	spinlock_t default_lock;
	spinlock_t *host_lock;
	struct mutex scan_mutex;
	struct list_head eh_abort_list;
	struct list_head eh_cmd_q;
	struct task_struct *ehandler;
	struct completion *eh_action;
	wait_queue_head_t host_wait;
	const struct scsi_host_template *hostt;
	struct scsi_transport_template *transportt;
	struct kref tagset_refcnt;
	struct completion tagset_freed;
	struct blk_mq_tag_set tag_set;
	atomic_t host_blocked;
	unsigned int host_failed;
	unsigned int host_eh_scheduled;
	unsigned int host_no;
	int eh_deadline;
	long unsigned int last_reset;
	unsigned int max_channel;
	unsigned int max_id;
	u64 max_lun;
	unsigned int unique_id;
	short unsigned int max_cmd_len;
	int this_id;
	int can_queue;
	short int cmd_per_lun;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int opt_sectors;
	unsigned int max_segment_size;
	unsigned int dma_alignment;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	unsigned int nr_hw_queues;
	unsigned int nr_maps;
	unsigned int active_mode: 2;
	unsigned int host_self_blocked: 1;
	unsigned int reverse_ordering: 1;
	unsigned int tmf_in_progress: 1;
	unsigned int async_scan: 1;
	unsigned int eh_noresume: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int queuecommand_may_block: 1;
	unsigned int short_inquiry: 1;
	unsigned int no_scsi2_lun_in_cdb: 1;
	unsigned int no_highmem: 1;
	struct workqueue_struct *work_q;
	struct workqueue_struct *tmf_work_q;
	unsigned int max_host_blocked;
	unsigned int prot_capabilities;
	unsigned char prot_guard_type;
	long unsigned int base;
	long unsigned int io_port;
	unsigned char n_io_port;
	unsigned char dma_channel;
	unsigned int irq;
	enum scsi_host_state shost_state;
	struct device shost_gendev;
	struct device shost_dev;
	void *shost_data;
	struct device *dma_dev;
	int rpm_autosuspend_delay;
	long unsigned int hostdata[0];
};

struct ZSTD_CCtx_params_s {
	ZSTD_format_e format;
	ZSTD_compressionParameters cParams;
	ZSTD_frameParameters fParams;
	int compressionLevel;
	int forceWindow;
	size_t targetCBlockSize;
	int srcSizeHint;
	ZSTD_dictAttachPref_e attachDictPref;
	ZSTD_paramSwitch_e literalCompressionMode;
	int nbWorkers;
	size_t jobSize;
	int overlapLog;
	int rsyncable;
	ldmParams_t ldmParams;
	int enableDedicatedDictSearch;
	ZSTD_bufferMode_e inBufferMode;
	ZSTD_bufferMode_e outBufferMode;
	ZSTD_sequenceFormat_e blockDelimiters;
	int validateSequences;
	ZSTD_paramSwitch_e useBlockSplitter;
	ZSTD_paramSwitch_e useRowMatchFinder;
	int deterministicRefPrefix;
	ZSTD_customMem customMem;
};

typedef struct ZSTD_CCtx_params_s ZSTD_CCtx_params;

struct xxh64_state {
	uint64_t total_len;
	uint64_t v1;
	uint64_t v2;
	uint64_t v3;
	uint64_t v4;
	uint64_t mem64[4];
	uint32_t memsize;
};

struct POOL_ctx_s;

typedef struct POOL_ctx_s ZSTD_threadPool;

struct ZSTD_inBuffer_s {
	const void *src;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_inBuffer_s ZSTD_inBuffer;

struct ZSTD_prefixDict_s {
	const void *dict;
	size_t dictSize;
	ZSTD_dictContentType_e dictContentType;
};

typedef struct ZSTD_prefixDict_s ZSTD_prefixDict;

struct ZSTD_CCtx_s {
	ZSTD_compressionStage_e stage;
	int cParamsChanged;
	int bmi2;
	ZSTD_CCtx_params requestedParams;
	ZSTD_CCtx_params appliedParams;
	ZSTD_CCtx_params simpleApiParams;
	U32 dictID;
	size_t dictContentSize;
	ZSTD_cwksp workspace;
	size_t blockSize;
	long long unsigned int pledgedSrcSizePlusOne;
	long long unsigned int consumedSrcSize;
	long long unsigned int producedCSize;
	struct xxh64_state xxhState;
	ZSTD_customMem customMem;
	ZSTD_threadPool *pool;
	size_t staticSize;
	SeqCollector seqCollector;
	int isFirstBlock;
	int initialized;
	seqStore_t seqStore;
	ldmState_t ldmState;
	rawSeq *ldmSequences;
	size_t maxNbLdmSequences;
	rawSeqStore_t externSeqStore;
	ZSTD_blockState_t blockState;
	U32 *entropyWorkspace;
	ZSTD_buffered_policy_e bufferedPolicy;
	char *inBuff;
	size_t inBuffSize;
	size_t inToCompress;
	size_t inBuffPos;
	size_t inBuffTarget;
	char *outBuff;
	size_t outBuffSize;
	size_t outBuffContentSize;
	size_t outBuffFlushedSize;
	ZSTD_cStreamStage streamStage;
	U32 frameEnded;
	ZSTD_inBuffer expectedInBuffer;
	size_t expectedOutBufferSize;
	ZSTD_localDict localDict;
	const ZSTD_CDict *cdict;
	ZSTD_prefixDict prefixDict;
	ZSTD_blockSplitCtx blockSplitCtx;
};

typedef struct ZSTD_CCtx_s ZSTD_CCtx;

typedef ZSTD_CCtx ZSTD_CStream;

typedef ZSTD_CCtx zstd_cctx;

typedef ZSTD_CStream zstd_cstream;

struct ZSTD_CDict_s {
	const void *dictContent;
	size_t dictContentSize;
	ZSTD_dictContentType_e dictContentType;
	U32 *entropyWorkspace;
	ZSTD_cwksp workspace;
	ZSTD_matchState_t matchState;
	ZSTD_compressedBlockState_t cBlockState;
	ZSTD_customMem customMem;
	U32 dictID;
	int compressionLevel;
	ZSTD_paramSwitch_e useRowMatchFinder;
};

typedef ZSTD_CDict zstd_cdict;

struct ZSTD_outBuffer_s {
	void *dst;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_outBuffer_s ZSTD_outBuffer;

struct ZSTD_DCtx_s {
	const ZSTD_seqSymbol *LLTptr;
	const ZSTD_seqSymbol *MLTptr;
	const ZSTD_seqSymbol *OFTptr;
	const HUF_DTable *HUFptr;
	ZSTD_entropyDTables_t entropy;
	U32 workspace[640];
	const void *previousDstEnd;
	const void *prefixStart;
	const void *virtualStart;
	const void *dictEnd;
	size_t expected;
	ZSTD_frameHeader fParams;
	U64 processedCSize;
	U64 decodedSize;
	blockType_e bType;
	ZSTD_dStage stage;
	U32 litEntropy;
	U32 fseEntropy;
	struct xxh64_state xxhState;
	size_t headerSize;
	ZSTD_format_e format;
	ZSTD_forceIgnoreChecksum_e forceIgnoreChecksum;
	U32 validateChecksum;
	const BYTE *litPtr;
	ZSTD_customMem customMem;
	size_t litSize;
	size_t rleSize;
	size_t staticSize;
	int bmi2;
	ZSTD_DDict *ddictLocal;
	const ZSTD_DDict *ddict;
	U32 dictID;
	int ddictIsCold;
	ZSTD_dictUses_e dictUses;
	ZSTD_DDictHashSet *ddictSet;
	ZSTD_refMultipleDDicts_e refMultipleDDicts;
	ZSTD_dStreamStage streamStage;
	char *inBuff;
	size_t inBuffSize;
	size_t inPos;
	size_t maxWindowSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outStart;
	size_t outEnd;
	size_t lhSize;
	U32 hostageByte;
	int noForwardProgress;
	ZSTD_bufferMode_e outBufferMode;
	ZSTD_outBuffer expectedOutBuffer;
	BYTE *litBuffer;
	const BYTE *litBufferEnd;
	ZSTD_litLocation_e litBufferLocation;
	BYTE litExtraBuffer[65568];
	BYTE headerBuffer[18];
	size_t oversizedDuration;
};

typedef struct ZSTD_DCtx_s ZSTD_DCtx;

typedef ZSTD_DCtx ZSTD_DStream;

typedef ZSTD_DCtx zstd_dctx;

typedef ZSTD_DStream zstd_dstream;

struct ZSTD_DDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictSize;
	ZSTD_entropyDTables_t entropy;
	U32 dictID;
	U32 entropyPresent;
	ZSTD_customMem cMem;
};

typedef ZSTD_DDict zstd_ddict;

typedef ZSTD_inBuffer zstd_in_buffer;

typedef ZSTD_outBuffer zstd_out_buffer;

struct __aio_sigset {
	const sigset_t *sigmask;
	size_t sigsetsize;
};

struct __arch_relative_insn {
	u8 op;
	s32 raddr;
} __attribute__((packed));

struct __bridge_info {
	__u64 designated_root;
	__u64 bridge_id;
	__u32 root_path_cost;
	__u32 max_age;
	__u32 hello_time;
	__u32 forward_delay;
	__u32 bridge_max_age;
	__u32 bridge_hello_time;
	__u32 bridge_forward_delay;
	__u8 topology_change;
	__u8 topology_change_detected;
	__u8 root_port;
	__u8 stp_enabled;
	__u32 ageing_time;
	__u32 gc_interval;
	__u32 hello_timer_value;
	__u32 tcn_timer_value;
	__u32 topology_change_timer_value;
	__u32 gc_timer_value;
};

struct llist_node {
	struct llist_node *next;
};

struct __call_single_node {
	struct llist_node llist;
	union {
		unsigned int u_flags;
		atomic_t a_flags;
	};
	u16 src;
	u16 dst;
};

typedef void (*smp_call_func_t)(void *);

struct __call_single_data {
	struct __call_single_node node;
	smp_call_func_t func;
	void *info;
};

typedef struct __call_single_data call_single_data_t;

struct cpumask;

struct __cmp_key {
	const struct cpumask *cpus;
	struct cpumask ***masks;
	int node;
	int cpu;
	int w;
};

struct drm_connector;

struct drm_connector_state;

struct __drm_connnectors_state {
	struct drm_connector *ptr;
	struct drm_connector_state *state;
	struct drm_connector_state *old_state;
	struct drm_connector_state *new_state;
	s32 *out_fence_ptr;
};

struct drm_crtc;

struct drm_crtc_state;

struct drm_crtc_commit;

struct __drm_crtcs_state {
	struct drm_crtc *ptr;
	struct drm_crtc_state *state;
	struct drm_crtc_state *old_state;
	struct drm_crtc_state *new_state;
	struct drm_crtc_commit *commit;
	s32 *out_fence_ptr;
	u64 last_vblank_count;
};

struct drm_plane;

struct drm_plane_state;

struct __drm_planes_state {
	struct drm_plane *ptr;
	struct drm_plane_state *state;
	struct drm_plane_state *old_state;
	struct drm_plane_state *new_state;
};

struct drm_private_obj;

struct drm_private_state;

struct __drm_private_objs_state {
	struct drm_private_obj *ptr;
	struct drm_private_state *state;
	struct drm_private_state *old_state;
	struct drm_private_state *new_state;
};

struct __ext_steer_reg {
	const char *name;
	i915_mcr_reg_t reg;
};

struct __fat_dirent {
	long int d_ino;
	__kernel_off_t d_off;
	short unsigned int d_reclen;
	char d_name[256];
};

struct __fdb_entry {
	__u8 mac_addr[6];
	__u8 port_no;
	__u8 is_local;
	__u32 ageing_timer_value;
	__u8 port_hi;
	__u8 pad0;
	__u16 unused;
};

struct genradix_root;

struct __genradix {
	struct genradix_root *root;
};

struct pmu;

struct cgroup;

struct __group_key {
	int cpu;
	struct pmu *pmu;
	struct cgroup *cgroup;
};

struct guc_mmio_reg_set {
	u32 address;
	u16 count;
	u16 reserved;
};

struct guc_ads {
	struct guc_mmio_reg_set reg_state_list[512];
	u32 reserved0;
	u32 scheduler_policies;
	u32 gt_system_info;
	u32 reserved1;
	u32 control_data;
	u32 golden_context_lrca[16];
	u32 eng_state_size[16];
	u32 private_data;
	u32 reserved2;
	u32 capture_instance[32];
	u32 capture_class[32];
	u32 capture_global[2];
	u32 wa_klv_addr_lo;
	u32 wa_klv_addr_hi;
	u32 wa_klv_size;
	u32 reserved[11];
};

struct guc_policies {
	u32 submission_queue_depth[16];
	u32 dpc_promote_time;
	u32 is_valid;
	u32 max_num_work_items;
	u32 global_flags;
	u32 reserved[4];
};

struct guc_gt_system_info {
	u8 mapping_table[512];
	u32 engine_enabled_masks[16];
	u32 generic_gt_sysinfo[16];
};

struct guc_engine_usage_record {
	u32 current_context_index;
	u32 last_switch_in_stamp;
	u32 reserved0;
	u32 total_runtime;
	u32 reserved1[4];
};

struct guc_engine_usage {
	struct guc_engine_usage_record engines[512];
};

struct guc_mmio_reg {
	u32 offset;
	u32 value;
	u32 flags;
	u32 mask;
};

struct __guc_ads_blob {
	struct guc_ads ads;
	struct guc_policies policies;
	struct guc_gt_system_info system_info;
	struct guc_engine_usage engine_usage;
	struct guc_mmio_reg regset[0];
};

struct __guc_capture_ads_cache {
	bool is_valid;
	void *ptr;
	size_t size;
	int status;
};

struct __guc_capture_bufstate {
	u32 size;
	void *data;
	u32 rd;
	u32 wr;
};

struct gcap_reg_list_info {
	u32 vfid;
	u32 num_regs;
	struct guc_mmio_reg *regs;
};

struct __guc_capture_parsed_output {
	struct list_head link;
	bool is_partial;
	u32 eng_class;
	u32 eng_inst;
	u32 guc_id;
	u32 lrca;
	struct gcap_reg_list_info reginfo[3];
};

struct __guc_mmio_reg_descr {
	i915_reg_t reg;
	u32 flags;
	u32 mask;
	const char *regname;
};

struct __guc_mmio_reg_descr_group {
	const struct __guc_mmio_reg_descr *list;
	u32 num_regs;
	u32 owner;
	u32 type;
	u32 engine;
	struct __guc_mmio_reg_descr *extlist;
};

struct intel_global_obj;

struct intel_global_state;

struct __intel_global_objs_state {
	struct intel_global_obj *ptr;
	struct intel_global_state *state;
	struct intel_global_state *old_state;
	struct intel_global_state *new_state;
};

struct __ip6_tnl_parm {
	char name[16];
	int link;
	__u8 proto;
	__u8 encap_limit;
	__u8 hop_limit;
	bool collect_md;
	__be32 flowinfo;
	__u32 flags;
	struct in6_addr laddr;
	struct in6_addr raddr;
	long unsigned int i_flags[1];
	long unsigned int o_flags[1];
	__be32 i_key;
	__be32 o_key;
	__u32 fwmark;
	__u32 index;
	__u8 erspan_ver;
	__u8 dir;
	__u16 hwid;
};

struct __kernel_timespec {
	__kernel_time64_t tv_sec;
	long long int tv_nsec;
};

struct __kernel_itimerspec {
	struct __kernel_timespec it_interval;
	struct __kernel_timespec it_value;
};

struct __kernel_old_timeval {
	__kernel_long_t tv_sec;
	__kernel_long_t tv_usec;
};

struct __kernel_old_itimerval {
	struct __kernel_old_timeval it_interval;
	struct __kernel_old_timeval it_value;
};

struct __kernel_old_timespec {
	__kernel_old_time_t tv_sec;
	long int tv_nsec;
};

struct __kernel_sock_timeval {
	__s64 tv_sec;
	__s64 tv_usec;
};

struct __kernel_sockaddr_storage {
	union {
		struct {
			__kernel_sa_family_t ss_family;
			char __data[126];
		};
		void *__align;
	};
};

struct __kernel_timex_timeval {
	__kernel_time64_t tv_sec;
	long long int tv_usec;
};

struct __kernel_timex {
	unsigned int modes;
	long long int offset;
	long long int freq;
	long long int maxerror;
	long long int esterror;
	int status;
	long long int constant;
	long long int precision;
	long long int tolerance;
	struct __kernel_timex_timeval time;
	long long int tick;
	long long int ppsfreq;
	long long int jitter;
	int shift;
	long long int stabil;
	long long int jitcnt;
	long long int calcnt;
	long long int errcnt;
	long long int stbcnt;
	int tai;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct __kfifo {
	unsigned int in;
	unsigned int out;
	unsigned int mask;
	unsigned int esize;
	void *data;
};

struct __large_struct {
	long unsigned int buf[100];
};

struct nft_payload {
	enum nft_payload_bases base: 8;
	u8 offset;
	u8 len;
	u8 dreg;
};

struct nft_meta {
	enum nft_meta_keys key: 8;
	u8 len;
	union {
		u8 dreg;
		u8 sreg;
	};
};

struct nft_expr_ops;

struct __nft_expr {
	const struct nft_expr_ops *ops;
	union {
		struct nft_payload payload;
		struct nft_meta meta;
	};
};

struct __old_kernel_stat {
	short unsigned int st_dev;
	short unsigned int st_ino;
	short unsigned int st_mode;
	short unsigned int st_nlink;
	short unsigned int st_uid;
	short unsigned int st_gid;
	short unsigned int st_rdev;
	unsigned int st_size;
	unsigned int st_atime;
	unsigned int st_mtime;
	unsigned int st_ctime;
};

struct __port_info {
	__u64 designated_root;
	__u64 designated_bridge;
	__u16 port_id;
	__u16 designated_port;
	__u32 path_cost;
	__u32 designated_cost;
	__u8 state;
	__u8 top_change_ack;
	__u8 config_pending;
	__u8 unused0;
	__u32 message_age_timer_value;
	__u32 forward_delay_timer_value;
	__u32 hold_timer_value;
};

struct net_device;

struct __rt6_probe_work {
	struct work_struct work;
	struct in6_addr target;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
};

struct __sctp_missing {
	__be32 num_missing;
	__be16 type;
} __attribute__((packed));

union sigval {
	int sival_int;
	void *sival_ptr;
};

typedef union sigval sigval_t;

union __sifields {
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
	} _kill;
	struct {
		__kernel_timer_t _tid;
		int _overrun;
		sigval_t _sigval;
		int _sys_private;
	} _timer;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		sigval_t _sigval;
	} _rt;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		int _status;
		__kernel_clock_t _utime;
		__kernel_clock_t _stime;
	} _sigchld;
	struct {
		void *_addr;
		union {
			int _trapno;
			short int _addr_lsb;
			struct {
				char _dummy_bnd[8];
				void *_lower;
				void *_upper;
			} _addr_bnd;
			struct {
				char _dummy_pkey[8];
				__u32 _pkey;
			} _addr_pkey;
			struct {
				long unsigned int _data;
				__u32 _type;
				__u32 _flags;
			} _perf;
		};
	} _sigfault;
	struct {
		long int _band;
		int _fd;
	} _sigpoll;
	struct {
		void *_call_addr;
		int _syscall;
		unsigned int _arch;
	} _sigsys;
};

struct bpf_flow_keys;

struct bpf_sock;

struct __sk_buff {
	__u32 len;
	__u32 pkt_type;
	__u32 mark;
	__u32 queue_mapping;
	__u32 protocol;
	__u32 vlan_present;
	__u32 vlan_tci;
	__u32 vlan_proto;
	__u32 priority;
	__u32 ingress_ifindex;
	__u32 ifindex;
	__u32 tc_index;
	__u32 cb[5];
	__u32 hash;
	__u32 tc_classid;
	__u32 data;
	__u32 data_end;
	__u32 napi_id;
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 data_meta;
	union {
		struct bpf_flow_keys *flow_keys;
	};
	__u64 tstamp;
	__u32 wire_len;
	__u32 gso_segs;
	union {
		struct bpf_sock *sk;
	};
	__u32 gso_size;
	__u8 tstamp_type;
	__u64 hwtstamp;
};

struct tc_taprio_qopt_stats {
	u64 window_drops;
	u64 tx_overruns;
};

struct tc_taprio_qopt_queue_stats {
	int queue;
	struct tc_taprio_qopt_stats stats;
};

struct tc_mqprio_qopt {
	__u8 num_tc;
	__u8 prio_tc_map[16];
	__u8 hw;
	__u16 count[16];
	__u16 offset[16];
};

struct tc_mqprio_qopt_offload {
	struct tc_mqprio_qopt qopt;
	struct netlink_ext_ack *extack;
	u16 mode;
	u16 shaper;
	u32 flags;
	u64 min_rate[16];
	u64 max_rate[16];
	long unsigned int preemptible_tcs;
};

struct tc_taprio_sched_entry {
	u8 command;
	u32 gate_mask;
	u32 interval;
};

struct tc_taprio_qopt_offload {
	enum tc_taprio_qopt_cmd cmd;
	union {
		struct tc_taprio_qopt_stats stats;
		struct tc_taprio_qopt_queue_stats queue_stats;
		struct {
			struct tc_mqprio_qopt_offload mqprio;
			struct netlink_ext_ack *extack;
			ktime_t base_time;
			u64 cycle_time;
			u64 cycle_time_extension;
			u32 max_sdu[16];
			size_t num_entries;
			struct tc_taprio_sched_entry entries[0];
		};
	};
};

struct __tc_taprio_qopt_offload {
	refcount_t users;
	struct tc_taprio_qopt_offload offload;
};

struct __track_dentry_update_args {
	struct dentry *dentry;
	int op;
};

struct __track_range_args {
	ext4_lblk_t start;
	ext4_lblk_t end;
};

union __u128_halves {
	u128 full;
	struct {
		u64 low;
		u64 high;
	};
};

struct __una_u32 {
	u32 x;
};

struct inode;

struct __uprobe_key {
	struct inode *inode;
	loff_t offset;
};

struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
};

typedef struct __user_cap_data_struct *cap_user_data_t;

struct __user_cap_header_struct {
	__u32 version;
	int pid;
};

typedef struct __user_cap_header_struct *cap_user_header_t;

struct __va_list_tag {
	unsigned int gp_offset;
	unsigned int fp_offset;
	void *overflow_arg_area;
	void *reg_save_area;
};

typedef __builtin_va_list va_list;

struct __xfsstats {
	uint32_t xs_allocx;
	uint32_t xs_allocb;
	uint32_t xs_freex;
	uint32_t xs_freeb;
	uint32_t xs_abt_lookup;
	uint32_t xs_abt_compare;
	uint32_t xs_abt_insrec;
	uint32_t xs_abt_delrec;
	uint32_t xs_blk_mapr;
	uint32_t xs_blk_mapw;
	uint32_t xs_blk_unmap;
	uint32_t xs_add_exlist;
	uint32_t xs_del_exlist;
	uint32_t xs_look_exlist;
	uint32_t xs_cmp_exlist;
	uint32_t xs_bmbt_lookup;
	uint32_t xs_bmbt_compare;
	uint32_t xs_bmbt_insrec;
	uint32_t xs_bmbt_delrec;
	uint32_t xs_dir_lookup;
	uint32_t xs_dir_create;
	uint32_t xs_dir_remove;
	uint32_t xs_dir_getdents;
	uint32_t xs_trans_sync;
	uint32_t xs_trans_async;
	uint32_t xs_trans_empty;
	uint32_t xs_ig_attempts;
	uint32_t xs_ig_found;
	uint32_t xs_ig_frecycle;
	uint32_t xs_ig_missed;
	uint32_t xs_ig_dup;
	uint32_t xs_ig_reclaims;
	uint32_t xs_ig_attrchg;
	uint32_t xs_log_writes;
	uint32_t xs_log_blocks;
	uint32_t xs_log_noiclogs;
	uint32_t xs_log_force;
	uint32_t xs_log_force_sleep;
	uint32_t xs_try_logspace;
	uint32_t xs_sleep_logspace;
	uint32_t xs_push_ail;
	uint32_t xs_push_ail_success;
	uint32_t xs_push_ail_pushbuf;
	uint32_t xs_push_ail_pinned;
	uint32_t xs_push_ail_locked;
	uint32_t xs_push_ail_flushing;
	uint32_t xs_push_ail_restarts;
	uint32_t xs_push_ail_flush;
	uint32_t xs_xstrat_quick;
	uint32_t xs_xstrat_split;
	uint32_t xs_write_calls;
	uint32_t xs_read_calls;
	uint32_t xs_attr_get;
	uint32_t xs_attr_set;
	uint32_t xs_attr_remove;
	uint32_t xs_attr_list;
	uint32_t xs_iflush_count;
	uint32_t xs_icluster_flushcnt;
	uint32_t xs_icluster_flushinode;
	uint32_t vn_active;
	uint32_t vn_alloc;
	uint32_t vn_get;
	uint32_t vn_hold;
	uint32_t vn_rele;
	uint32_t vn_reclaim;
	uint32_t vn_remove;
	uint32_t vn_free;
	uint32_t xb_get;
	uint32_t xb_create;
	uint32_t xb_get_locked;
	uint32_t xb_get_locked_waited;
	uint32_t xb_busy_locked;
	uint32_t xb_miss_locked;
	uint32_t xb_page_retries;
	uint32_t xb_page_found;
	uint32_t xb_get_read;
	uint32_t xs_abtb_2[15];
	uint32_t xs_abtc_2[15];
	uint32_t xs_bmbt_2[15];
	uint32_t xs_ibt_2[15];
	uint32_t xs_fibt_2[15];
	uint32_t xs_rmap_2[15];
	uint32_t xs_refcbt_2[15];
	uint32_t xs_rmap_mem_2[15];
	uint32_t xs_rcbag_2[15];
	uint32_t xs_rtrmap_2[15];
	uint32_t xs_rtrmap_mem_2[15];
	uint32_t xs_rtrefcbt_2[15];
	uint32_t xs_qm_dqreclaims;
	uint32_t xs_qm_dqreclaim_misses;
	uint32_t xs_qm_dquot_dups;
	uint32_t xs_qm_dqcachemisses;
	uint32_t xs_qm_dqcachehits;
	uint32_t xs_qm_dqwants;
	uint32_t xs_qm_dquot;
	uint32_t xs_qm_dquot_unused;
	uint64_t xs_xstrat_bytes;
	uint64_t xs_write_bytes;
	uint64_t xs_read_bytes;
	uint64_t defer_relog;
};

struct drm_mm;

struct drm_mm_node {
	long unsigned int color;
	u64 start;
	u64 size;
	struct drm_mm *mm;
	struct list_head node_list;
	struct list_head hole_stack;
	struct rb_node rb;
	struct rb_node rb_hole_size;
	struct rb_node rb_hole_addr;
	u64 __subtree_last;
	u64 hole_size;
	u64 subtree_max_hole;
	long unsigned int flags;
};

struct _balloon_info_ {
	struct drm_mm_node space[4];
};

struct _bpf_dtab_netdev {
	struct net_device *dev;
};

struct _cache_table {
	unsigned char descriptor;
	char cache_type;
	short int size;
};

union _cpuid4_leaf_eax {
	struct {
		enum _cache_type type: 5;
		unsigned int level: 3;
		unsigned int is_self_initializing: 1;
		unsigned int is_fully_associative: 1;
		unsigned int reserved: 4;
		unsigned int num_threads_sharing: 12;
		unsigned int num_cores_on_die: 6;
	} split;
	u32 full;
};

union _cpuid4_leaf_ebx {
	struct {
		unsigned int coherency_line_size: 12;
		unsigned int physical_line_partition: 10;
		unsigned int ways_of_associativity: 10;
	} split;
	u32 full;
};

union _cpuid4_leaf_ecx {
	struct {
		unsigned int number_of_sets: 32;
	} split;
	u32 full;
};

struct amd_northbridge;

struct _cpuid4_info_regs {
	union _cpuid4_leaf_eax eax;
	union _cpuid4_leaf_ebx ebx;
	union _cpuid4_leaf_ecx ecx;
	unsigned int id;
	long unsigned int size;
	struct amd_northbridge *nb;
};

struct jump_entry;

struct static_key_mod;

struct static_key {
	atomic_t enabled;
	union {
		long unsigned int type;
		struct jump_entry *entries;
		struct static_key_mod *next;
	};
};

struct static_key_true {
	struct static_key key;
};

struct static_key_false {
	struct static_key key;
};

struct _ddebug {
	const char *modname;
	const char *function;
	const char *filename;
	const char *format;
	unsigned int lineno: 18;
	unsigned int class_id: 6;
	unsigned int flags: 8;
	union {
		struct static_key_true dd_key_true;
		struct static_key_false dd_key_false;
	} key;
};

struct _flow_keys_digest_data {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
	__be32 ports;
	__be32 src;
	__be32 dst;
};

struct _fpreg {
	__u16 significand[4];
	__u16 exponent;
};

struct _fpxreg {
	__u16 significand[4];
	__u16 exponent;
	__u16 padding[3];
};

struct _xmmreg {
	__u32 element[4];
};

struct _fpx_sw_bytes {
	__u32 magic1;
	__u32 extended_size;
	__u64 xfeatures;
	__u32 xstate_size;
	__u32 padding[7];
};

struct _fpstate_32 {
	__u32 cw;
	__u32 sw;
	__u32 tag;
	__u32 ipoff;
	__u32 cssel;
	__u32 dataoff;
	__u32 datasel;
	struct _fpreg _st[8];
	__u16 status;
	__u16 magic;
	__u32 _fxsr_env[6];
	__u32 mxcsr;
	__u32 reserved;
	struct _fpxreg _fxsr_st[8];
	struct _xmmreg _xmm[8];
	union {
		__u32 padding1[44];
		__u32 padding[44];
	};
	union {
		__u32 padding2[12];
		struct _fpx_sw_bytes sw_reserved;
	};
};

struct _gpt_entry_attributes {
	u64 required_to_function: 1;
	u64 reserved: 47;
	u64 type_guid_specific: 16;
};

typedef struct _gpt_entry_attributes gpt_entry_attributes;

struct _gpt_entry {
	efi_guid_t partition_type_guid;
	efi_guid_t unique_partition_guid;
	__le64 starting_lba;
	__le64 ending_lba;
	gpt_entry_attributes attributes;
	__le16 partition_name[36];
};

typedef struct _gpt_entry gpt_entry;

struct _gpt_header {
	__le64 signature;
	__le32 revision;
	__le32 header_size;
	__le32 header_crc32;
	__le32 reserved1;
	__le64 my_lba;
	__le64 alternate_lba;
	__le64 first_usable_lba;
	__le64 last_usable_lba;
	efi_guid_t disk_guid;
	__le64 partition_entry_lba;
	__le32 num_partition_entries;
	__le32 sizeof_partition_entry;
	__le32 partition_entry_array_crc32;
} __attribute__((packed));

typedef struct _gpt_header gpt_header;

struct _gpt_mbr_record {
	u8 boot_indicator;
	u8 start_head;
	u8 start_sector;
	u8 start_track;
	u8 os_type;
	u8 end_head;
	u8 end_sector;
	u8 end_track;
	__le32 starting_lba;
	__le32 size_in_lba;
};

typedef struct _gpt_mbr_record gpt_mbr_record;

struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	long unsigned int flags;
	long unsigned int desc;
	struct resource *parent;
	struct resource *sibling;
	struct resource *child;
};

struct intel_gtt_driver;

struct pci_dev;

struct page;

struct _intel_private {
	const struct intel_gtt_driver *driver;
	struct pci_dev *pcidev;
	struct pci_dev *bridge_dev;
	u8 *registers;
	phys_addr_t gtt_phys_addr;
	u32 PGETBL_save;
	u32 *gtt;
	bool clear_fake_agp;
	int num_dcache_entries;
	void *i9xx_flush_page;
	char *i81x_gtt_table;
	struct resource ifp_resource;
	int resource_valid;
	struct page *scratch_page;
	phys_addr_t scratch_page_dma;
	int refcount;
	unsigned int needs_dmar: 1;
	phys_addr_t gma_bus_addr;
	resource_size_t stolen_size;
	unsigned int gtt_total_entries;
	unsigned int gtt_mappable_entries;
};

struct kvm_stats_desc {
	__u32 flags;
	__s16 exponent;
	__u16 size;
	__u32 offset;
	__u32 bucket_size;
	char name[0];
};

struct _kvm_stats_desc {
	struct kvm_stats_desc desc;
	char name[48];
};

struct _legacy_mbr {
	u8 boot_code[440];
	__le32 unique_mbr_signature;
	__le16 unknown;
	gpt_mbr_record partition_record[4];
	__le16 signature;
} __attribute__((packed));

typedef struct _legacy_mbr legacy_mbr;

struct strp_msg {
	int full_len;
	int offset;
};

struct _strp_msg {
	struct strp_msg strp;
	int accum_len;
};

struct timer_list {
	struct hlist_node entry;
	long unsigned int expires;
	void (*function)(struct timer_list *);
	u32 flags;
};

struct delayed_work {
	struct work_struct work;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int cpu;
};

struct _thermal_state {
	u64 next_check;
	u64 last_interrupt_time;
	struct delayed_work therm_work;
	long unsigned int count;
	long unsigned int last_count;
	long unsigned int max_time_ms;
	long unsigned int total_time_ms;
	bool rate_control_active;
	bool new_event;
	u8 level;
	u8 sample_index;
	u8 sample_count;
	u8 average;
	u8 baseline_temp;
	u8 temp_samples[3];
};

struct _tlb_table {
	unsigned char descriptor;
	char tlb_type;
	unsigned int entries;
	char info[128];
};

struct atalk_addr {
	__be16 s_net;
	__u8 s_node;
};

struct aarp_entry {
	long unsigned int last_sent;
	struct sk_buff_head packet_queue;
	int status;
	long unsigned int expires_at;
	struct atalk_addr target_addr;
	struct net_device *dev;
	char hwaddr[6];
	short unsigned int xmit_count;
	struct aarp_entry *next;
};

struct aarp_iter_state {
	int bucket;
	struct aarp_entry **table;
};

struct seq_net_private {
	struct net *net;
	netns_tracker ns_tracker;
};

struct ac6_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
};

struct access_coordinate {
	unsigned int read_bandwidth;
	unsigned int write_bandwidth;
	unsigned int read_latency;
	unsigned int write_latency;
};

struct acct {
	char ac_flag;
	char ac_version;
	__u16 ac_uid16;
	__u16 ac_gid16;
	__u16 ac_tty;
	__u32 ac_btime;
	comp_t ac_utime;
	comp_t ac_stime;
	comp_t ac_etime;
	comp_t ac_mem;
	comp_t ac_io;
	comp_t ac_rw;
	comp_t ac_minflt;
	comp_t ac_majflt;
	comp_t ac_swaps;
	__u16 ac_ahz;
	__u32 ac_exitcode;
	char ac_comm[17];
	__u8 ac_etime_hi;
	__u16 ac_etime_lo;
	__u32 ac_uid;
	__u32 ac_gid;
};

typedef struct acct acct_t;

struct drm_dp_nak_reply {
	guid_t guid;
	u8 reason;
	u8 nak_data;
};

struct drm_dp_link_addr_reply_port {
	bool input_port;
	u8 peer_device_type;
	u8 port_number;
	bool mcs;
	bool ddps;
	bool legacy_device_plug_status;
	u8 dpcd_revision;
	guid_t peer_guid;
	u8 num_sdp_streams;
	u8 num_sdp_stream_sinks;
};

struct drm_dp_link_address_ack_reply {
	guid_t guid;
	u8 nports;
	struct drm_dp_link_addr_reply_port ports[16];
};

struct drm_dp_port_number_rep {
	u8 port_number;
};

struct drm_dp_enum_path_resources_ack_reply {
	u8 port_number;
	bool fec_capable;
	u16 full_payload_bw_number;
	u16 avail_payload_bw_number;
};

struct drm_dp_allocate_payload_ack_reply {
	u8 port_number;
	u8 vcpi;
	u16 allocated_pbn;
};

struct drm_dp_query_payload_ack_reply {
	u8 port_number;
	u16 allocated_pbn;
};

struct drm_dp_remote_dpcd_read_ack_reply {
	u8 port_number;
	u8 num_bytes;
	u8 bytes[255];
};

struct drm_dp_remote_dpcd_write_ack_reply {
	u8 port_number;
};

struct drm_dp_remote_dpcd_write_nak_reply {
	u8 port_number;
	u8 reason;
	u8 bytes_written_before_failure;
};

struct drm_dp_remote_i2c_read_ack_reply {
	u8 port_number;
	u8 num_bytes;
	u8 bytes[255];
};

struct drm_dp_remote_i2c_read_nak_reply {
	u8 port_number;
	u8 nak_reason;
	u8 i2c_nak_transaction;
};

struct drm_dp_remote_i2c_write_ack_reply {
	u8 port_number;
};

struct drm_dp_query_stream_enc_status_ack_reply {
	u8 stream_id;
	bool reply_signed;
	bool unauthorizable_device_present;
	bool legacy_device_present;
	bool query_capable_device_present;
	bool hdcp_1x_device_present;
	bool hdcp_2x_device_present;
	bool auth_completed;
	bool encryption_enabled;
	bool repeater_present;
	u8 state;
};

union ack_replies {
	struct drm_dp_nak_reply nak;
	struct drm_dp_link_address_ack_reply link_addr;
	struct drm_dp_port_number_rep port_number;
	struct drm_dp_enum_path_resources_ack_reply path_resources;
	struct drm_dp_allocate_payload_ack_reply allocate_payload;
	struct drm_dp_query_payload_ack_reply query_payload;
	struct drm_dp_remote_dpcd_read_ack_reply remote_dpcd_read_ack;
	struct drm_dp_remote_dpcd_write_ack_reply remote_dpcd_write_ack;
	struct drm_dp_remote_dpcd_write_nak_reply remote_dpcd_write_nack;
	struct drm_dp_remote_i2c_read_ack_reply remote_i2c_read_ack;
	struct drm_dp_remote_i2c_read_nak_reply remote_i2c_read_nack;
	struct drm_dp_remote_i2c_write_ack_reply remote_i2c_write_ack;
	struct drm_dp_query_stream_enc_status_ack_reply enc_status;
};

struct drm_dp_connection_status_notify {
	guid_t guid;
	u8 port_number;
	bool legacy_device_plug_status;
	bool displayport_device_plug_status;
	bool message_capability_status;
	bool input_port;
	u8 peer_device_type;
};

struct drm_dp_port_number_req {
	u8 port_number;
};

struct drm_dp_resource_status_notify {
	u8 port_number;
	guid_t guid;
	u16 available_pbn;
};

struct drm_dp_query_payload {
	u8 port_number;
	u8 vcpi;
};

struct drm_dp_allocate_payload {
	u8 port_number;
	u8 number_sdp_streams;
	u8 vcpi;
	u16 pbn;
	u8 sdp_stream_sink[16];
};

struct drm_dp_remote_dpcd_read {
	u8 port_number;
	u32 dpcd_address;
	u8 num_bytes;
};

struct drm_dp_remote_dpcd_write {
	u8 port_number;
	u32 dpcd_address;
	u8 num_bytes;
	u8 *bytes;
};

struct drm_dp_remote_i2c_read_tx {
	u8 i2c_dev_id;
	u8 num_bytes;
	u8 *bytes;
	u8 no_stop_bit;
	u8 i2c_transaction_delay;
};

struct drm_dp_remote_i2c_read {
	u8 num_transactions;
	u8 port_number;
	struct drm_dp_remote_i2c_read_tx transactions[4];
	u8 read_i2c_device_id;
	u8 num_bytes_read;
};

struct drm_dp_remote_i2c_write {
	u8 port_number;
	u8 write_i2c_device_id;
	u8 num_bytes;
	u8 *bytes;
};

struct drm_dp_query_stream_enc_status {
	u8 stream_id;
	u8 client_id[7];
	u8 stream_event;
	bool valid_stream_event;
	u8 stream_behavior;
	u8 valid_stream_behavior;
};

union ack_req {
	struct drm_dp_connection_status_notify conn_stat;
	struct drm_dp_port_number_req port_num;
	struct drm_dp_resource_status_notify resource_stat;
	struct drm_dp_query_payload query_payload;
	struct drm_dp_allocate_payload allocate_payload;
	struct drm_dp_remote_dpcd_read dpcd_read;
	struct drm_dp_remote_dpcd_write dpcd_write;
	struct drm_dp_remote_i2c_read i2c_read;
	struct drm_dp_remote_i2c_write i2c_write;
	struct drm_dp_query_stream_enc_status enc_status;
};

struct ack_sample {
	u32 pkts_acked;
	s32 rtt_us;
	u32 in_flight;
};

struct crypto_tfm;

struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_alg {
	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_type;

struct crypto_alg {
	struct list_head cra_list;
	struct list_head cra_users;
	u32 cra_flags;
	unsigned int cra_blocksize;
	unsigned int cra_ctxsize;
	unsigned int cra_alignmask;
	int cra_priority;
	refcount_t cra_refcnt;
	char cra_name[128];
	char cra_driver_name[128];
	const struct crypto_type *cra_type;
	union {
		struct cipher_alg cipher;
		struct compress_alg compress;
	} cra_u;
	int (*cra_init)(struct crypto_tfm *);
	void (*cra_exit)(struct crypto_tfm *);
	void (*cra_destroy)(struct crypto_alg *);
	struct module *cra_module;
};

struct comp_alg_common {
	struct crypto_alg base;
};

struct acomp_req;

struct scatterlist;

struct crypto_acomp;

struct acomp_alg {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	int (*init)(struct crypto_acomp *);
	void (*exit)(struct crypto_acomp *);
	unsigned int reqsize;
	union {
		struct {
			struct crypto_alg base;
		};
		struct comp_alg_common calg;
	};
};

typedef void (*crypto_completion_t)(void *, int);

struct crypto_async_request {
	struct list_head list;
	crypto_completion_t complete;
	void *data;
	struct crypto_tfm *tfm;
	u32 flags;
};

struct acomp_req {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int slen;
	unsigned int dlen;
	u32 flags;
	void *__ctx[0];
};

struct power_supply;

union power_supply_propval;

struct power_supply_desc {
	const char *name;
	enum power_supply_type type;
	u8 charge_behaviours;
	u32 charge_types;
	u32 usb_types;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
	void (*external_power_changed)(struct power_supply *);
	void (*set_charged)(struct power_supply *);
	bool no_thermal;
	int use_for_apm;
};

struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);

struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block *next;
	int priority;
};

struct acpi_device;

struct acpi_ac {
	struct power_supply *charger;
	struct power_supply_desc charger_desc;
	struct acpi_device *device;
	long long unsigned int state;
	struct notifier_block battery_nb;
};

struct acpi_address16_attribute {
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
};

struct acpi_address32_attribute {
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
};

struct acpi_address64_attribute {
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
};

struct acpi_namespace_node;

struct acpi_address_range {
	struct acpi_address_range *next;
	struct acpi_namespace_node *region_node;
	acpi_physical_address start_address;
	acpi_physical_address end_address;
};

struct acpi_battery {
	struct mutex lock;
	struct mutex sysfs_lock;
	struct power_supply *bat;
	struct power_supply_desc bat_desc;
	struct acpi_device *device;
	struct notifier_block pm_nb;
	struct list_head list;
	long unsigned int update_time;
	int revision;
	int rate_now;
	int capacity_now;
	int voltage_now;
	int design_capacity;
	int full_charge_capacity;
	int technology;
	int design_voltage;
	int design_capacity_warning;
	int design_capacity_low;
	int cycle_count;
	int measurement_accuracy;
	int max_sampling_time;
	int min_sampling_time;
	int max_averaging_interval;
	int min_averaging_interval;
	int capacity_granularity_1;
	int capacity_granularity_2;
	int alarm;
	char model_number[64];
	char serial_number[64];
	char type[64];
	char oem_info[64];
	int state;
	int power_unit;
	long unsigned int flags;
};

struct acpi_battery_hook {
	const char *name;
	int (*add_battery)(struct power_supply *, struct acpi_battery_hook *);
	int (*remove_battery)(struct power_supply *, struct acpi_battery_hook *);
	struct list_head list;
};

struct acpi_bit_register_info {
	u8 parent_register;
	u8 bit_position;
	u16 access_bit_mask;
};

struct acpi_buffer {
	acpi_size length;
	void *pointer;
};

struct acpi_bus_event {
	struct list_head node;
	acpi_device_class device_class;
	acpi_bus_id bus_id;
	u32 type;
	u32 data;
};

struct acpi_bus_type {
	struct list_head list;
	const char *name;
	bool (*match)(struct device *);
	struct acpi_device * (*find_companion)(struct device *);
	void (*setup)(struct device *);
};

struct input_dev;

struct acpi_button {
	unsigned int type;
	struct input_dev *input;
	char phys[32];
	long unsigned int pushed;
	int last_state;
	ktime_t last_time;
	bool suspended;
	bool lid_state_initialized;
};

struct acpi_cdat_header {
	u8 type;
	u8 reserved;
	u16 length;
};

struct acpi_cedt_header {
	u8 type;
	u8 reserved;
	u16 length;
};

struct acpi_cedt_cfmws {
	struct acpi_cedt_header header;
	u32 reserved1;
	u64 base_hpa;
	u64 window_size;
	u8 interleave_ways;
	u8 interleave_arithmetic;
	u16 reserved2;
	u32 granularity;
	u16 restrictions;
	u16 qtg_id;
	u32 interleave_targets[0];
} __attribute__((packed));

struct acpi_comment_node {
	char *comment;
	struct acpi_comment_node *next;
};

struct acpi_common_descriptor {
	void *common_pointer;
	u8 descriptor_type;
};

struct acpi_common_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
};

struct acpi_connection_info {
	u8 *connection;
	u16 length;
	u8 access_length;
};

union acpi_parse_object;

struct acpi_control_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u16 opcode;
	union acpi_parse_object *predicate_op;
	u8 *aml_predicate_start;
	u8 *package_end;
	u64 loop_timeout;
};

struct cpumask {
	long unsigned int bits[1];
};

typedef struct cpumask cpumask_var_t[1];

struct acpi_pct_register;

struct acpi_cpufreq_data {
	unsigned int resume;
	unsigned int cpu_feature;
	unsigned int acpi_perf_cpu;
	cpumask_var_t freqdomain_cpus;
	void (*cpu_freq_write)(struct acpi_pct_register *, u32);
	u32 (*cpu_freq_read)(struct acpi_pct_register *);
};

struct acpi_create_field_info {
	struct acpi_namespace_node *region_node;
	struct acpi_namespace_node *field_node;
	struct acpi_namespace_node *register_node;
	struct acpi_namespace_node *data_register_node;
	struct acpi_namespace_node *connection_node;
	u8 *resource_buffer;
	u32 bank_value;
	u32 field_bit_position;
	u32 field_bit_length;
	u16 resource_length;
	u16 pin_number_index;
	u8 field_flags;
	u8 attribute;
	u8 field_type;
	u8 access_length;
};

struct acpi_csrt_group {
	u32 length;
	u32 vendor_id;
	u32 subvendor_id;
	u16 device_id;
	u16 subdevice_id;
	u16 revision;
	u16 reserved;
	u32 shared_info_length;
};

struct acpi_csrt_shared_info {
	u16 major_version;
	u16 minor_version;
	u32 mmio_base_low;
	u32 mmio_base_high;
	u32 gsi_interrupt;
	u8 interrupt_polarity;
	u8 interrupt_mode;
	u8 num_channels;
	u8 dma_address_width;
	u16 base_request_line;
	u16 num_handshake_signals;
	u32 max_block_size;
};

struct attribute {
	const char *name;
	umode_t mode;
};

struct address_space;

struct vm_area_struct;

struct bin_attribute {
	struct attribute attr;
	size_t size;
	void *private;
	struct address_space * (*f_mapping)(void);
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*read_new)(struct file *, struct kobject *, const struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write_new)(struct file *, struct kobject *, const struct bin_attribute *, char *, loff_t, size_t);
	loff_t (*llseek)(struct file *, struct kobject *, const struct bin_attribute *, loff_t, int);
	int (*mmap)(struct file *, struct kobject *, const struct bin_attribute *, struct vm_area_struct *);
};

struct acpi_data_attr {
	struct bin_attribute attr;
	u64 addr;
};

typedef void *acpi_handle;

struct fwnode_operations;

struct fwnode_handle {
	struct fwnode_handle *secondary;
	const struct fwnode_operations *ops;
	struct device *dev;
	struct list_head suppliers;
	struct list_head consumers;
	u8 flags;
};

union acpi_object;

struct acpi_device_data {
	const union acpi_object *pointer;
	struct list_head properties;
	const union acpi_object *of_compatible;
	struct list_head subnodes;
};

struct acpi_data_node {
	struct list_head sibling;
	const char *name;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct fwnode_handle *parent;
	struct acpi_device_data data;
	struct kobject kobj;
	struct completion kobj_done;
};

struct acpi_data_node_attr {
	struct attribute attr;
	ssize_t (*show)(struct acpi_data_node *, char *);
	ssize_t (*store)(struct acpi_data_node *, const char *, size_t);
};

struct acpi_data_obj {
	char *name;
	int (*fn)(void *, struct acpi_data_attr *);
};

struct acpi_data_table_mapping {
	void *pointer;
};

struct acpi_dep_data {
	struct list_head node;
	acpi_handle supplier;
	acpi_handle consumer;
	bool honor_dep;
	bool met;
	bool free_when_met;
};

union acpi_operand_object;

struct acpi_object_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
};

struct acpi_object_integer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 fill[3];
	u64 value;
};

struct acpi_object_string {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	char *pointer;
	u32 length;
};

struct acpi_object_buffer {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 *pointer;
	u32 length;
	u32 aml_length;
	u8 *aml_start;
	struct acpi_namespace_node *node;
};

struct acpi_object_package {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	union acpi_operand_object **elements;
	u8 *aml_start;
	u32 aml_length;
	u32 count;
};

struct acpi_object_event {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	void *os_semaphore;
};

struct acpi_walk_state;

typedef acpi_status (*acpi_internal_method)(struct acpi_walk_state *);

struct acpi_object_method {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 info_flags;
	u8 param_count;
	u8 sync_level;
	union acpi_operand_object *mutex;
	union acpi_operand_object *node;
	u8 *aml_start;
	union {
		acpi_internal_method implementation;
		union acpi_operand_object *handler;
	} dispatch;
	u32 aml_length;
	acpi_owner_id owner_id;
	u8 thread_count;
};

struct acpi_thread_state;

struct acpi_object_mutex {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 sync_level;
	u16 acquisition_depth;
	void *os_mutex;
	u64 thread_id;
	struct acpi_thread_state *owner_thread;
	union acpi_operand_object *prev;
	union acpi_operand_object *next;
	struct acpi_namespace_node *node;
	u8 original_sync_level;
};

struct acpi_object_region {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler;
	union acpi_operand_object *next;
	acpi_physical_address address;
	u32 length;
	void *pointer;
};

struct acpi_object_notify_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_gpe_block_info;

struct acpi_object_device {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	struct acpi_gpe_block_info *gpe_block;
};

struct acpi_object_power_resource {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	u32 system_level;
	u32 resource_order;
};

struct acpi_object_processor {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 proc_id;
	u8 length;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
	acpi_io_address address;
};

struct acpi_object_thermal_zone {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *notify_list[2];
	union acpi_operand_object *handler;
};

struct acpi_object_field_common {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
};

struct acpi_object_region_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u16 resource_length;
	union acpi_operand_object *region_obj;
	u8 *resource_buffer;
	u16 pin_number_index;
	u8 *internal_pcc_buffer;
};

struct acpi_object_buffer_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	u8 is_create_field;
	union acpi_operand_object *buffer_obj;
};

struct acpi_object_bank_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *region_obj;
	union acpi_operand_object *bank_obj;
};

struct acpi_object_index_field {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 field_flags;
	u8 attribute;
	u8 access_byte_width;
	struct acpi_namespace_node *node;
	u32 bit_length;
	u32 base_byte_offset;
	u32 value;
	u8 start_field_bit_offset;
	u8 access_length;
	union acpi_operand_object *index_obj;
	union acpi_operand_object *data_obj;
};

typedef void (*acpi_notify_handler)(acpi_handle, u32, void *);

struct acpi_object_notify_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *node;
	u32 handler_type;
	acpi_notify_handler handler;
	void *context;
	union acpi_operand_object *next[2];
};

typedef acpi_status (*acpi_adr_space_handler)(u32, acpi_physical_address, u32, u64 *, void *, void *);

typedef acpi_status (*acpi_adr_space_setup)(acpi_handle, u32, void *, void **);

struct acpi_object_addr_handler {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 space_id;
	u8 handler_flags;
	acpi_adr_space_handler handler;
	struct acpi_namespace_node *node;
	void *context;
	void *context_mutex;
	acpi_adr_space_setup setup;
	union acpi_operand_object *region_list;
	union acpi_operand_object *next;
};

struct acpi_object_reference {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	u8 class;
	u8 target_type;
	u8 resolved;
	void *object;
	struct acpi_namespace_node *node;
	union acpi_operand_object **where;
	u8 *index_pointer;
	u8 *aml;
	u32 value;
};

struct acpi_object_extra {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	struct acpi_namespace_node *method_REG;
	struct acpi_namespace_node *scope_node;
	void *region_context;
	u8 *aml_start;
	u32 aml_length;
};

typedef void (*acpi_object_handler)(acpi_handle, void *);

struct acpi_object_data {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	acpi_object_handler handler;
	void *pointer;
};

struct acpi_object_cache_list {
	union acpi_operand_object *next_object;
	u8 descriptor_type;
	u8 type;
	u16 reference_count;
	u8 flags;
	union acpi_operand_object *next;
};

union acpi_name_union {
	u32 integer;
	char ascii[4];
};

struct acpi_namespace_node {
	union acpi_operand_object *object;
	u8 descriptor_type;
	u8 type;
	u16 flags;
	union acpi_name_union name;
	struct acpi_namespace_node *parent;
	struct acpi_namespace_node *child;
	struct acpi_namespace_node *peer;
	acpi_owner_id owner_id;
};

union acpi_operand_object {
	struct acpi_object_common common;
	struct acpi_object_integer integer;
	struct acpi_object_string string;
	struct acpi_object_buffer buffer;
	struct acpi_object_package package;
	struct acpi_object_event event;
	struct acpi_object_method method;
	struct acpi_object_mutex mutex;
	struct acpi_object_region region;
	struct acpi_object_notify_common common_notify;
	struct acpi_object_device device;
	struct acpi_object_power_resource power_resource;
	struct acpi_object_processor processor;
	struct acpi_object_thermal_zone thermal_zone;
	struct acpi_object_field_common common_field;
	struct acpi_object_region_field field;
	struct acpi_object_buffer_field buffer_field;
	struct acpi_object_bank_field bank_field;
	struct acpi_object_index_field index_field;
	struct acpi_object_notify_handler notify;
	struct acpi_object_addr_handler address_space;
	struct acpi_object_reference reference;
	struct acpi_object_extra extra;
	struct acpi_object_data data;
	struct acpi_object_cache_list cache;
	struct acpi_namespace_node node;
};

union acpi_parse_value {
	u64 integer;
	u32 size;
	char *string;
	u8 *buffer;
	char *name;
	union acpi_parse_object *arg;
};

struct acpi_parse_obj_common {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
};

struct acpi_parse_obj_named {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	char *path;
	u8 *data;
	u32 length;
	u32 name;
};

struct acpi_parse_obj_asl {
	union acpi_parse_object *parent;
	u8 descriptor_type;
	u8 flags;
	u16 aml_opcode;
	u8 *aml;
	union acpi_parse_object *next;
	struct acpi_namespace_node *node;
	union acpi_parse_value value;
	u8 arg_list_length;
	union acpi_parse_object *child;
	union acpi_parse_object *parent_method;
	char *filename;
	u8 file_changed;
	char *parent_filename;
	char *external_name;
	char *namepath;
	char name_seg[4];
	u32 extra_value;
	u32 column;
	u32 line_number;
	u32 logical_line_number;
	u32 logical_byte_offset;
	u32 end_line;
	u32 end_logical_line;
	u32 acpi_btype;
	u32 aml_length;
	u32 aml_subtree_length;
	u32 final_aml_length;
	u32 final_aml_offset;
	u32 compile_flags;
	u16 parse_opcode;
	u8 aml_opcode_length;
	u8 aml_pkg_len_bytes;
	u8 extra;
	char parse_op_name[20];
};

union acpi_parse_object {
	struct acpi_parse_obj_common common;
	struct acpi_parse_obj_named named;
	struct acpi_parse_obj_asl asl;
};

union acpi_descriptor {
	struct acpi_common_descriptor common;
	union acpi_operand_object object;
	struct acpi_namespace_node node;
	union acpi_parse_object op;
};

struct acpi_device_id {
	__u8 id[16];
	kernel_ulong_t driver_data;
	__u32 cls;
	__u32 cls_msk;
};

struct acpi_dev_match_info {
	struct acpi_device_id hid[2];
	const char *uid;
	s64 hrv;
};

struct acpi_dev_walk_context {
	int (*fn)(struct acpi_device *, void *);
	void *data;
};

struct acpi_device_status {
	u32 present: 1;
	u32 enabled: 1;
	u32 show_in_ui: 1;
	u32 functional: 1;
	u32 battery_present: 1;
	u32 reserved: 27;
};

struct acpi_device_flags {
	u32 dynamic_status: 1;
	u32 removable: 1;
	u32 ejectable: 1;
	u32 power_manageable: 1;
	u32 match_driver: 1;
	u32 initialized: 1;
	u32 visited: 1;
	u32 hotplug_notify: 1;
	u32 is_dock_station: 1;
	u32 of_compatible_ok: 1;
	u32 coherent_dma: 1;
	u32 cca_seen: 1;
	u32 enumeration_by_parent: 1;
	u32 honor_deps: 1;
	u32 reserved: 18;
};

struct acpi_pnp_type {
	u32 hardware_id: 1;
	u32 bus_address: 1;
	u32 platform_id: 1;
	u32 backlight: 1;
	u32 reserved: 28;
};

struct acpi_device_pnp {
	acpi_bus_id bus_id;
	int instance_no;
	struct acpi_pnp_type type;
	acpi_bus_address bus_address;
	char *unique_id;
	struct list_head ids;
	acpi_device_name device_name;
	acpi_device_class device_class;
};

struct acpi_device_power_flags {
	u32 explicit_get: 1;
	u32 power_resources: 1;
	u32 inrush_current: 1;
	u32 power_removed: 1;
	u32 ignore_parent: 1;
	u32 dsw_present: 1;
	u32 reserved: 26;
};

struct acpi_device_power_state {
	struct list_head resources;
	struct {
		u8 valid: 1;
		u8 explicit_set: 1;
		u8 reserved: 6;
	} flags;
	int power;
	int latency;
};

struct acpi_device_power {
	int state;
	struct acpi_device_power_flags flags;
	struct acpi_device_power_state states[5];
	u8 state_for_enumeration;
};

struct acpi_device_wakeup_flags {
	u8 valid: 1;
	u8 notifier_present: 1;
};

struct acpi_device_wakeup_context {
	void (*func)(struct acpi_device_wakeup_context *);
	struct device *dev;
};

struct acpi_device_wakeup {
	acpi_handle gpe_device;
	u64 gpe_number;
	u64 sleep_state;
	struct list_head resources;
	struct acpi_device_wakeup_flags flags;
	struct acpi_device_wakeup_context context;
	struct wakeup_source *ws;
	int prepare_count;
	int enable_count;
};

struct acpi_device_perf_flags {
	u8 reserved: 8;
};

struct acpi_device_perf_state;

struct acpi_device_perf {
	int state;
	struct acpi_device_perf_flags flags;
	int state_count;
	struct acpi_device_perf_state *states;
};

struct proc_dir_entry;

struct acpi_device_dir {
	struct proc_dir_entry *entry;
};

struct acpi_scan_handler;

struct acpi_hotplug_context;

struct acpi_device_software_nodes;

struct acpi_gpio_mapping;

struct acpi_device {
	u32 pld_crc;
	int device_type;
	acpi_handle handle;
	struct fwnode_handle fwnode;
	struct list_head wakeup_list;
	struct list_head del_list;
	struct acpi_device_status status;
	struct acpi_device_flags flags;
	struct acpi_device_pnp pnp;
	struct acpi_device_power power;
	struct acpi_device_wakeup wakeup;
	struct acpi_device_perf performance;
	struct acpi_device_dir dir;
	struct acpi_device_data data;
	struct acpi_scan_handler *handler;
	struct acpi_hotplug_context *hp;
	struct acpi_device_software_nodes *swnodes;
	const struct acpi_gpio_mapping *driver_gpios;
	void *driver_data;
	struct device dev;
	unsigned int physical_node_count;
	unsigned int dep_unmet;
	struct list_head physical_node_list;
	struct mutex physical_node_lock;
	void (*remove)(struct acpi_device *);
};

struct xarray {
	spinlock_t xa_lock;
	gfp_t xa_flags;
	void *xa_head;
};

struct ida {
	struct xarray xa;
};

struct acpi_device_bus_id {
	const char *bus_id;
	struct ida instance_ida;
	struct list_head node;
};

struct acpi_pnp_device_id {
	u32 length;
	char *string;
};

struct acpi_pnp_device_id_list {
	u32 count;
	u32 list_size;
	struct acpi_pnp_device_id ids[0];
};

struct acpi_device_info {
	u32 info_size;
	u32 name;
	acpi_object_type type;
	u8 param_count;
	u16 valid;
	u8 flags;
	u8 highest_dstates[4];
	u8 lowest_dstates[5];
	u64 address;
	struct acpi_pnp_device_id hardware_id;
	struct acpi_pnp_device_id unique_id;
	struct acpi_pnp_device_id class_code;
	struct acpi_pnp_device_id_list compatible_id_list;
};

typedef int (*acpi_op_add)(struct acpi_device *);

typedef void (*acpi_op_remove)(struct acpi_device *);

typedef void (*acpi_op_notify)(struct acpi_device *, u32);

struct acpi_device_ops {
	acpi_op_add add;
	acpi_op_remove remove;
	acpi_op_notify notify;
};

struct acpi_device_perf_state {
	struct {
		u8 valid: 1;
		u8 reserved: 7;
	} flags;
	u8 power;
	u8 performance;
	int latency;
};

struct acpi_device_physical_node {
	struct list_head node;
	struct device *dev;
	unsigned int node_id;
	bool put_online: 1;
};

struct acpi_device_properties {
	struct list_head list;
	const guid_t *guid;
	union acpi_object *properties;
	void **bufs;
};

struct property_entry {
	const char *name;
	size_t length;
	bool is_inline;
	enum dev_prop_type type;
	union {
		const void *pointer;
		union {
			u8 u8_data[8];
			u16 u16_data[4];
			u32 u32_data[2];
			u64 u64_data[1];
			const char *str[1];
		} value;
	};
};

struct software_node;

struct software_node_ref_args {
	const struct software_node *node;
	unsigned int nargs;
	u64 args[16];
};

struct acpi_device_software_node_port {
	char port_name[9];
	u32 data_lanes[8];
	u32 lane_polarities[9];
	u64 link_frequencies[8];
	unsigned int port_nr;
	bool crs_csi2_local;
	struct property_entry port_props[2];
	struct property_entry ep_props[8];
	struct software_node_ref_args remote_ep[1];
};

struct acpi_device_software_nodes {
	struct property_entry dev_props[6];
	struct software_node *nodes;
	const struct software_node **nodeptrs;
	struct acpi_device_software_node_port *ports;
	unsigned int num_ports;
};

struct acpi_table_desc;

struct acpi_evaluate_info;

struct acpi_device_walk_info {
	struct acpi_table_desc *table_desc;
	struct acpi_evaluate_info *evaluate_info;
	u32 device_count;
	u32 num_STA;
	u32 num_INI;
};

struct dma_chan;

struct acpi_dma_spec;

struct acpi_dma {
	struct list_head dma_controllers;
	struct device *dev;
	struct dma_chan * (*acpi_dma_xlate)(struct acpi_dma_spec *, struct acpi_dma *);
	void *data;
	short unsigned int base_request_line;
	short unsigned int end_request_line;
};

typedef bool (*dma_filter_fn)(struct dma_chan *, void *);

struct acpi_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

struct acpi_dma_spec {
	int chan_id;
	int slave_id;
	struct device *dev;
};

struct acpi_dma_parser_data {
	struct acpi_dma_spec dma_spec;
	size_t index;
	size_t n;
};

struct acpi_dmar_header {
	u16 type;
	u16 length;
};

struct acpi_dmar_andd {
	struct acpi_dmar_header header;
	u8 reserved[3];
	u8 device_number;
	union {
		char __pad;
		struct {
			struct {} __Empty_device_name;
			char device_name[0];
		};
	};
} __attribute__((packed));

struct acpi_dmar_atsr {
	struct acpi_dmar_header header;
	u8 flags;
	u8 reserved;
	u16 segment;
};

struct acpi_dmar_device_scope {
	u8 entry_type;
	u8 length;
	u16 reserved;
	u8 enumeration_id;
	u8 bus;
};

struct acpi_dmar_hardware_unit {
	struct acpi_dmar_header header;
	u8 flags;
	u8 size;
	u16 segment;
	u64 address;
};

struct acpi_dmar_pci_path {
	u8 device;
	u8 function;
};

struct acpi_dmar_reserved_memory {
	struct acpi_dmar_header header;
	u16 reserved;
	u16 segment;
	u64 base_address;
	u64 end_address;
};

struct acpi_dmar_rhsa {
	struct acpi_dmar_header header;
	u32 reserved;
	u64 base_address;
	u32 proximity_domain;
} __attribute__((packed));

struct acpi_dmar_satc {
	struct acpi_dmar_header header;
	u8 flags;
	u8 reserved;
	u16 segment;
};

struct of_device_id;

struct dev_pm_ops;

struct driver_private;

struct device_driver {
	const char *name;
	const struct bus_type *bus;
	struct module *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	const struct dev_pm_ops *pm;
	void (*coredump)(struct device *);
	struct driver_private *p;
};

struct acpi_driver {
	char name[80];
	char class[80];
	const struct acpi_device_id *ids;
	unsigned int flags;
	struct acpi_device_ops ops;
	struct device_driver drv;
};

struct transaction;

struct acpi_ec {
	acpi_handle handle;
	int gpe;
	int irq;
	long unsigned int command_addr;
	long unsigned int data_addr;
	bool global_lock;
	long unsigned int flags;
	long unsigned int reference_count;
	struct mutex mutex;
	wait_queue_head_t wait;
	struct list_head list;
	struct transaction *curr;
	spinlock_t lock;
	struct work_struct work;
	long unsigned int timestamp;
	enum acpi_ec_event_state event_state;
	unsigned int events_to_process;
	unsigned int events_in_progress;
	unsigned int queries_in_progress;
	bool busy_polling;
	unsigned int polling_guard;
};

struct transaction {
	const u8 *wdata;
	u8 *rdata;
	short unsigned int irq_count;
	u8 command;
	u8 wi;
	u8 ri;
	u8 wlen;
	u8 rlen;
	u8 flags;
};

struct acpi_ec_query_handler;

struct acpi_ec_query {
	struct transaction transaction;
	struct work_struct work;
	struct acpi_ec_query_handler *handler;
	struct acpi_ec *ec;
};

typedef int (*acpi_ec_query_func)(void *);

struct acpi_ec_query_handler {
	struct list_head node;
	acpi_ec_query_func func;
	acpi_handle handle;
	void *data;
	u8 query_bit;
	struct kref kref;
};

union acpi_predefined_info;

struct acpi_evaluate_info {
	struct acpi_namespace_node *prefix_node;
	const char *relative_pathname;
	union acpi_operand_object **parameters;
	struct acpi_namespace_node *node;
	union acpi_operand_object *obj_desc;
	char *full_pathname;
	const union acpi_predefined_info *predefined;
	union acpi_operand_object *return_object;
	union acpi_operand_object *parent_package;
	u32 return_flags;
	u32 return_btype;
	u16 param_count;
	u16 node_flags;
	u8 pass_number;
	u8 return_object_type;
	u8 flags;
};

struct acpi_exception_info {
	char *name;
};

struct acpi_fadt_info {
	const char *name;
	u16 address64;
	u16 address32;
	u16 length;
	u8 default_length;
	u8 flags;
};

struct acpi_generic_address;

struct acpi_fadt_pm_info {
	struct acpi_generic_address *target;
	u16 source;
	u8 register_num;
};

struct acpi_fan_fif {
	u8 revision;
	u8 fine_grain_ctrl;
	u8 step_size;
	u8 low_speed_notification;
};

struct device_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device *, struct device_attribute *, char *);
	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
};

struct acpi_fan_fps;

struct thermal_cooling_device;

struct acpi_fan {
	bool acpi4;
	struct acpi_fan_fif fif;
	struct acpi_fan_fps *fps;
	int fps_count;
	struct thermal_cooling_device *cdev;
	struct device_attribute fst_speed;
	struct device_attribute fine_grain_control;
};

struct acpi_fan_fps {
	u64 control;
	u64 trip_point;
	u64 speed;
	u64 noise_level;
	u64 power;
	char name[20];
	struct device_attribute dev_attr;
};

struct acpi_fan_fst {
	u64 revision;
	u64 control;
	u64 speed;
};

struct acpi_ffh_info {
	u64 offset;
	u64 length;
};

typedef u32 (*acpi_event_handler)(void *);

struct acpi_fixed_event_handler {
	acpi_event_handler handler;
	void *context;
};

struct acpi_fixed_event_info {
	u8 status_register_id;
	u8 enable_register_id;
	u16 status_bit_mask;
	u16 enable_bit_mask;
};

struct acpi_ged_device {
	struct device *dev;
	struct list_head event_list;
};

struct acpi_ged_event {
	struct list_head node;
	struct device *dev;
	unsigned int gsi;
	unsigned int irq;
	acpi_handle handle;
};

struct acpi_ged_handler_info {
	struct acpi_ged_handler_info *next;
	u32 int_id;
	struct acpi_namespace_node *evt_method;
};

struct acpi_generic_address {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct acpi_update_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *object;
};

struct acpi_scope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	struct acpi_namespace_node *node;
};

struct acpi_pscope_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 arg_count;
	union acpi_parse_object *op;
	u8 *arg_end;
	u8 *pkg_end;
	u32 arg_list;
};

struct acpi_pkg_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u32 index;
	union acpi_operand_object *source_object;
	union acpi_operand_object *dest_object;
	struct acpi_walk_state *walk_state;
	void *this_target_obj;
	u32 num_packages;
};

struct acpi_thread_state {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 current_sync_level;
	struct acpi_walk_state *walk_state_list;
	union acpi_operand_object *acquired_mutex_list;
	u64 thread_id;
};

struct acpi_result_values {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	union acpi_operand_object *obj_desc[8];
};

struct acpi_global_notify_handler;

struct acpi_notify_info {
	void *next;
	u8 descriptor_type;
	u8 flags;
	u16 value;
	u16 state;
	u8 handler_list_id;
	struct acpi_namespace_node *node;
	union acpi_operand_object *handler_list_head;
	struct acpi_global_notify_handler *global;
};

union acpi_generic_state {
	struct acpi_common_state common;
	struct acpi_control_state control;
	struct acpi_update_state update;
	struct acpi_scope_state scope;
	struct acpi_pscope_state parse_scope;
	struct acpi_pkg_state pkg;
	struct acpi_thread_state thread;
	struct acpi_result_values results;
	struct acpi_notify_info notify;
};

struct acpi_genl_event {
	acpi_device_class device_class;
	char bus_id[15];
	u32 type;
	u32 data;
};

typedef acpi_status (*acpi_walk_callback)(acpi_handle, u32, void *, void **);

struct acpi_get_devices_info {
	acpi_walk_callback user_function;
	void *context;
	const char *hid;
};

struct acpi_global_notify_handler {
	acpi_notify_handler handler;
	void *context;
};

struct acpi_gpe_address {
	u8 space_id;
	u64 address;
};

struct acpi_gpe_xrupt_info;

struct acpi_gpe_register_info;

struct acpi_gpe_event_info;

struct acpi_gpe_block_info {
	struct acpi_namespace_node *node;
	struct acpi_gpe_block_info *previous;
	struct acpi_gpe_block_info *next;
	struct acpi_gpe_xrupt_info *xrupt_block;
	struct acpi_gpe_register_info *register_info;
	struct acpi_gpe_event_info *event_info;
	u64 address;
	u32 register_count;
	u16 gpe_count;
	u16 block_base_number;
	u8 space_id;
	u8 initialized;
};

struct acpi_gpe_block_status_context {
	struct acpi_gpe_register_info *gpe_skip_register_info;
	u8 gpe_skip_mask;
	u8 retval;
};

struct acpi_gpe_device_info {
	u32 index;
	u32 next_block_base_index;
	acpi_status status;
	struct acpi_namespace_node *gpe_device;
};

struct acpi_gpe_handler_info;

struct acpi_gpe_notify_info;

union acpi_gpe_dispatch_info {
	struct acpi_namespace_node *method_node;
	struct acpi_gpe_handler_info *handler;
	struct acpi_gpe_notify_info *notify_list;
};

struct acpi_gpe_event_info {
	union acpi_gpe_dispatch_info dispatch;
	struct acpi_gpe_register_info *register_info;
	u8 flags;
	u8 gpe_number;
	u8 runtime_count;
	u8 disable_for_dispatch;
};

typedef u32 (*acpi_gpe_handler)(acpi_handle, u32, void *);

struct acpi_gpe_handler_info {
	acpi_gpe_handler address;
	void *context;
	struct acpi_namespace_node *method_node;
	u8 original_flags;
	u8 originally_enabled;
};

struct acpi_gpe_notify_info {
	struct acpi_namespace_node *device_node;
	struct acpi_gpe_notify_info *next;
};

struct acpi_gpe_register_info {
	struct acpi_gpe_address status_address;
	struct acpi_gpe_address enable_address;
	u16 base_gpe_number;
	u8 enable_for_wake;
	u8 enable_for_run;
	u8 mask_for_run;
	u8 enable_mask;
};

struct acpi_gpe_walk_info {
	struct acpi_namespace_node *gpe_device;
	struct acpi_gpe_block_info *gpe_block;
	u16 count;
	acpi_owner_id owner_id;
	u8 execute_by_owner_id;
};

struct acpi_gpe_xrupt_info {
	struct acpi_gpe_xrupt_info *previous;
	struct acpi_gpe_xrupt_info *next;
	struct acpi_gpe_block_info *gpe_block_list_head;
	u32 interrupt_number;
};

struct acpi_gpio_params;

struct acpi_gpio_mapping {
	const char *name;
	const struct acpi_gpio_params *data;
	unsigned int size;
	unsigned int quirks;
};

struct acpi_gpio_params {
	unsigned int crs_entry_index;
	unsigned int line_index;
	bool active_low;
};

struct acpi_handle_list {
	u32 count;
	acpi_handle *handles;
};

struct acpi_hardware_id {
	struct list_head list;
	const char *id;
};

struct acpi_hmat_structure {
	u16 type;
	u16 reserved;
	u32 length;
};

typedef int (*acpi_hp_notify)(struct acpi_device *, u32);

typedef void (*acpi_hp_uevent)(struct acpi_device *, u32);

typedef void (*acpi_hp_fixup)(struct acpi_device *);

struct acpi_hotplug_context {
	struct acpi_device *self;
	acpi_hp_notify notify;
	acpi_hp_uevent uevent;
	acpi_hp_fixup fixup;
};

struct acpi_hotplug_profile {
	struct kobject kobj;
	int (*scan_dependent)(struct acpi_device *);
	void (*notify_online)(struct acpi_device *);
	bool enabled: 1;
	bool demand_offline: 1;
};

struct acpi_hp_work {
	struct work_struct work;
	struct acpi_device *adev;
	u32 src;
};

struct acpi_init_walk_info {
	u32 table_index;
	u32 object_count;
	u32 method_count;
	u32 serial_method_count;
	u32 non_serial_method_count;
	u32 serialized_method_count;
	u32 device_count;
	u32 op_region_count;
	u32 field_count;
	u32 buffer_count;
	u32 package_count;
	u32 op_region_init;
	u32 field_init;
	u32 buffer_init;
	u32 package_init;
	acpi_owner_id owner_id;
};

struct acpi_interface_info {
	char *name;
	struct acpi_interface_info *next;
	u8 flags;
	u8 value;
};

struct acpi_io_attribute {
	u8 range_type;
	u8 translation;
	u8 translation_type;
	u8 reserved1;
};

struct rcu_work {
	struct work_struct work;
	struct callback_head rcu;
	struct workqueue_struct *wq;
};

struct acpi_ioremap {
	struct list_head list;
	void *virt;
	acpi_physical_address phys;
	acpi_size size;
	union {
		long unsigned int refcount;
		struct rcu_work rwork;
	} track;
};

struct acpi_lpat {
	int temp;
	int raw;
};

struct acpi_lpat_conversion_table {
	struct acpi_lpat *lpat;
	int lpat_count;
};

struct acpi_lpi_state {
	u32 min_residency;
	u32 wake_latency;
	u32 flags;
	u32 arch_flags;
	u32 res_cnt_freq;
	u32 enable_parent_state;
	u64 address;
	u8 index;
	u8 entry_method;
	char desc[32];
};

struct acpi_lpi_states_array {
	unsigned int size;
	unsigned int composite_states_size;
	struct acpi_lpi_state *entries;
	struct acpi_lpi_state *composite_states[8];
};

struct acpi_lpit_header {
	u32 type;
	u32 length;
	u16 unique_id;
	u16 reserved;
	u32 flags;
};

struct acpi_lpit_native {
	struct acpi_lpit_header header;
	struct acpi_generic_address entry_trigger;
	u32 residency;
	u32 latency;
	struct acpi_generic_address residency_counter;
	u64 counter_frequency;
};

struct acpi_subtable_header {
	u8 type;
	u8 length;
};

struct acpi_madt_core_pic {
	struct acpi_subtable_header header;
	u8 version;
	u32 processor_id;
	u32 core_id;
	u32 flags;
} __attribute__((packed));

struct acpi_madt_generic_distributor {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 gic_id;
	u64 base_address;
	u32 global_irq_base;
	u8 version;
	u8 reserved2[3];
};

struct acpi_madt_generic_interrupt {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 cpu_interface_number;
	u32 uid;
	u32 flags;
	u32 parking_version;
	u32 performance_interrupt;
	u64 parked_address;
	u64 base_address;
	u64 gicv_base_address;
	u64 gich_base_address;
	u32 vgic_interrupt;
	u64 gicr_base_address;
	u64 arm_mpidr;
	u8 efficiency_class;
	u8 reserved2[1];
	u16 spe_interrupt;
	u16 trbe_interrupt;
} __attribute__((packed));

struct acpi_madt_interrupt_override {
	struct acpi_subtable_header header;
	u8 bus;
	u8 source_irq;
	u32 global_irq;
	u16 inti_flags;
} __attribute__((packed));

struct acpi_madt_interrupt_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u8 type;
	u8 id;
	u8 eid;
	u8 io_sapic_vector;
	u32 global_irq;
	u32 flags;
};

struct acpi_madt_io_apic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 address;
	u32 global_irq_base;
};

struct acpi_madt_io_sapic {
	struct acpi_subtable_header header;
	u8 id;
	u8 reserved;
	u32 global_irq_base;
	u64 address;
};

struct acpi_madt_local_apic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u32 lapic_flags;
};

struct acpi_madt_local_apic_nmi {
	struct acpi_subtable_header header;
	u8 processor_id;
	u16 inti_flags;
	u8 lint;
} __attribute__((packed));

struct acpi_madt_local_apic_override {
	struct acpi_subtable_header header;
	u16 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_madt_local_sapic {
	struct acpi_subtable_header header;
	u8 processor_id;
	u8 id;
	u8 eid;
	u8 reserved[3];
	u32 lapic_flags;
	u32 uid;
	char uid_string[0];
};

struct acpi_madt_local_x2apic {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 local_apic_id;
	u32 lapic_flags;
	u32 uid;
};

struct acpi_madt_local_x2apic_nmi {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 uid;
	u8 lint;
	u8 reserved[3];
};

struct acpi_madt_multiproc_wakeup {
	struct acpi_subtable_header header;
	u16 version;
	u32 reserved;
	u64 mailbox_address;
	u64 reset_vector;
};

struct acpi_madt_multiproc_wakeup_mailbox {
	u16 command;
	u16 reserved;
	u32 apic_id;
	u64 wakeup_vector;
	u8 reserved_os[2032];
	u8 reserved_firmware[2048];
};

struct acpi_madt_nmi_source {
	struct acpi_subtable_header header;
	u16 inti_flags;
	u32 global_irq;
};

struct acpi_madt_rintc {
	struct acpi_subtable_header header;
	u8 version;
	u8 reserved;
	u32 flags;
	u64 hart_id;
	u32 uid;
	u32 ext_intc_id;
	u64 imsic_addr;
	u32 imsic_size;
} __attribute__((packed));

struct acpi_mcfg_allocation {
	u64 address;
	u16 pci_segment;
	u8 start_bus_number;
	u8 end_bus_number;
	u32 reserved;
};

struct acpi_mem_mapping {
	acpi_physical_address physical_address;
	u8 *logical_address;
	acpi_size length;
	struct acpi_mem_mapping *next_mm;
};

struct acpi_mem_space_context {
	u32 length;
	acpi_physical_address address;
	struct acpi_mem_mapping *cur_mm;
	struct acpi_mem_mapping *first_mm;
};

struct acpi_memory_attribute {
	u8 write_protect;
	u8 caching;
	u8 range_type;
	u8 translation;
};

struct acpi_mutex_info {
	void *mutex;
	u32 use_count;
	u64 thread_id;
};

struct acpi_name_info {
	char name[4];
	u16 argument_list;
	u8 expected_btypes;
} __attribute__((packed));

struct acpi_namestring_info {
	const char *external_name;
	const char *next_external_char;
	char *internal_name;
	u32 length;
	u32 num_segments;
	u32 num_carats;
	u8 fully_qualified;
};

union acpi_object {
	acpi_object_type type;
	struct {
		acpi_object_type type;
		u64 value;
	} integer;
	struct {
		acpi_object_type type;
		u32 length;
		char *pointer;
	} string;
	struct {
		acpi_object_type type;
		u32 length;
		u8 *pointer;
	} buffer;
	struct {
		acpi_object_type type;
		u32 count;
		union acpi_object *elements;
	} package;
	struct {
		acpi_object_type type;
		acpi_object_type actual_type;
		acpi_handle handle;
	} reference;
	struct {
		acpi_object_type type;
		u32 proc_id;
		acpi_io_address pblk_address;
		u32 pblk_length;
	} processor;
	struct {
		acpi_object_type type;
		u32 system_level;
		u32 resource_order;
	} power_resource;
};

struct acpi_object_list {
	u32 count;
	union acpi_object *pointer;
};

struct acpi_offsets {
	size_t offset;
	u8 mode;
};

struct acpi_opcode_info {
	u32 parse_args;
	u32 runtime_args;
	u16 flags;
	u8 object_type;
	u8 class;
	u8 type;
};

typedef void (*acpi_osd_exec_callback)(void *);

struct acpi_os_dpc {
	acpi_osd_exec_callback function;
	void *context;
	struct work_struct work;
};

struct acpi_osc_context {
	char *uuid_str;
	int rev;
	struct acpi_buffer cap;
	struct acpi_buffer ret;
};

struct acpi_osi_config {
	u8 default_disabling;
	unsigned int linux_enable: 1;
	unsigned int linux_dmi: 1;
	unsigned int linux_cmdline: 1;
	unsigned int darwin_enable: 1;
	unsigned int darwin_dmi: 1;
	unsigned int darwin_cmdline: 1;
};

struct acpi_osi_entry {
	char string[64];
	bool enable;
};

struct acpi_package_info {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 object_type2;
	u8 count2;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info2 {
	u8 type;
	u8 count;
	u8 object_type[4];
	u8 reserved;
};

struct acpi_package_info3 {
	u8 type;
	u8 count;
	u8 object_type[2];
	u8 tail_object_type;
	u16 reserved;
} __attribute__((packed));

struct acpi_package_info4 {
	u8 type;
	u8 object_type1;
	u8 count1;
	u8 sub_object_types;
	u8 pkg_count;
	u16 reserved;
} __attribute__((packed));

struct acpi_parse_state {
	u8 *aml_start;
	u8 *aml;
	u8 *aml_end;
	u8 *pkg_start;
	u8 *pkg_end;
	union acpi_parse_object *start_op;
	struct acpi_namespace_node *start_node;
	union acpi_generic_state *scope;
	union acpi_parse_object *start_scope;
	u32 aml_size;
};

struct acpi_pcc_info {
	u8 subspace_id;
	u16 length;
	u8 *internal_buffer;
};

struct acpi_pcct_ext_pcc_master {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved1;
	u64 base_address;
	u32 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u32 min_turnaround_time;
	struct acpi_generic_address platform_ack_register;
	u64 ack_preserve_mask;
	u64 ack_set_mask;
	u64 reserved2;
	struct acpi_generic_address cmd_complete_register;
	u64 cmd_complete_mask;
	struct acpi_generic_address cmd_update_register;
	u64 cmd_update_preserve_mask;
	u64 cmd_update_set_mask;
	struct acpi_generic_address error_status_register;
	u64 error_status_mask;
} __attribute__((packed));

struct acpi_pcct_ext_pcc_shared_memory {
	u32 signature;
	u32 flags;
	u32 length;
	u32 command;
};

struct acpi_pcct_hw_reduced {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pcct_hw_reduced_type2 {
	struct acpi_subtable_header header;
	u32 platform_interrupt;
	u8 flags;
	u8 reserved;
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
	struct acpi_generic_address platform_ack_register;
	u64 ack_preserve_mask;
	u64 ack_write_mask;
} __attribute__((packed));

struct acpi_pcct_shared_memory {
	u32 signature;
	u16 command;
	u16 status;
};

struct acpi_pcct_subspace {
	struct acpi_subtable_header header;
	u8 reserved[6];
	u64 base_address;
	u64 length;
	struct acpi_generic_address doorbell_register;
	u64 preserve_mask;
	u64 write_mask;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
} __attribute__((packed));

struct acpi_pci_device {
	acpi_handle device;
	struct acpi_pci_device *next;
};

struct acpi_pci_id {
	u16 segment;
	u16 bus;
	u16 device;
	u16 function;
};

struct acpi_pci_ioapic {
	acpi_handle root_handle;
	acpi_handle handle;
	u32 gsi_base;
	struct resource res;
	struct pci_dev *pdev;
	struct list_head list;
};

struct acpi_pci_link_irq {
	u32 active;
	u8 triggering;
	u8 polarity;
	u8 resource_type;
	u8 possible_count;
	u32 possible[16];
	u8 initialized: 1;
	u8 reserved: 7;
};

struct acpi_pci_link {
	struct list_head list;
	struct acpi_device *device;
	struct acpi_pci_link_irq irq;
	int refcnt;
};

struct pci_bus;

struct acpi_pci_root {
	struct acpi_device *device;
	struct pci_bus *bus;
	u16 segment;
	int bridge_type;
	struct resource secondary;
	u32 osc_support_set;
	u32 osc_control_set;
	u32 osc_ext_support_set;
	u32 osc_ext_control_set;
	phys_addr_t mcfg_addr;
};

struct acpi_pci_root_ops;

struct acpi_pci_root_info {
	struct acpi_pci_root *root;
	struct acpi_device *bridge;
	struct acpi_pci_root_ops *ops;
	struct list_head resources;
	char name[16];
};

struct pci_ops;

struct acpi_pci_root_ops {
	struct pci_ops *pci_ops;
	int (*init_info)(struct acpi_pci_root_info *);
	void (*release_info)(struct acpi_pci_root_info *);
	int (*prepare_resources)(struct acpi_pci_root_info *);
};

struct acpi_pci_routing_table {
	u32 length;
	u32 pin;
	u64 address;
	u32 source_index;
	union {
		char pad[4];
		struct {
			struct {} __Empty_source;
			char source[0];
		};
	};
};

struct acpi_pct_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 reserved;
	u64 address;
} __attribute__((packed));

struct acpi_pkg_info {
	u8 *free_space;
	acpi_size length;
	u32 object_space;
	u32 num_packages;
};

struct acpi_platform_list {
	char oem_id[7];
	char oem_table_id[9];
	u32 oem_revision;
	char *table;
	enum acpi_predicate pred;
	char *reason;
	u32 data;
};

struct acpi_pld_info {
	u8 revision;
	u8 ignore_color;
	u8 red;
	u8 green;
	u8 blue;
	u16 width;
	u16 height;
	u8 user_visible;
	u8 dock;
	u8 lid;
	u8 panel;
	u8 vertical_position;
	u8 horizontal_position;
	u8 shape;
	u8 group_orientation;
	u8 group_token;
	u8 group_position;
	u8 bay;
	u8 ejectable;
	u8 ospm_eject_required;
	u8 cabinet_number;
	u8 card_cage_number;
	u8 reference;
	u8 rotation;
	u8 order;
	u8 reserved;
	u16 vertical_offset;
	u16 horizontal_offset;
};

struct acpi_port_info {
	char *name;
	u16 start;
	u16 end;
	u8 osi_dependency;
};

struct acpi_power_dependent_device {
	struct device *dev;
	struct list_head node;
};

struct acpi_power_register {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_power_resource {
	struct acpi_device device;
	struct list_head list_node;
	u32 system_level;
	u32 order;
	unsigned int ref_count;
	u8 state;
	struct mutex resource_lock;
	struct list_head dependents;
};

struct acpi_power_resource_entry {
	struct list_head node;
	struct acpi_power_resource *resource;
};

union acpi_predefined_info {
	struct acpi_name_info info;
	struct acpi_package_info ret_info;
	struct acpi_package_info2 ret_info2;
	struct acpi_package_info3 ret_info3;
	struct acpi_package_info4 ret_info4;
};

struct acpi_predefined_names {
	const char *name;
	u8 type;
	char *val;
};

struct acpi_prmt_handler_info {
	u16 revision;
	u16 length;
	u8 handler_guid[16];
	u64 handler_address;
	u64 static_data_buffer_address;
	u64 acpi_param_buffer_address;
} __attribute__((packed));

struct acpi_prmt_module_header {
	u16 revision;
	u16 length;
};

struct acpi_prmt_module_info {
	u16 revision;
	u16 length;
	u8 module_guid[16];
	u16 major_rev;
	u16 minor_rev;
	u16 handler_info_count;
	u32 handler_info_offset;
	u64 mmio_list_pointer;
} __attribute__((packed));

struct acpi_probe_entry;

typedef bool (*acpi_probe_entry_validate_subtbl)(struct acpi_subtable_header *, struct acpi_probe_entry *);

struct acpi_table_header;

typedef int (*acpi_tbl_table_handler)(struct acpi_table_header *);

union acpi_subtable_headers;

typedef int (*acpi_tbl_entry_handler)(union acpi_subtable_headers *, const long unsigned int);

struct acpi_probe_entry {
	__u8 id[5];
	__u8 type;
	acpi_probe_entry_validate_subtbl subtable_valid;
	union {
		acpi_tbl_table_handler probe_table;
		acpi_tbl_entry_handler probe_subtbl;
	};
	kernel_ulong_t driver_data;
};

struct acpi_processor_flags {
	u8 power: 1;
	u8 performance: 1;
	u8 throttling: 1;
	u8 limit: 1;
	u8 bm_control: 1;
	u8 bm_check: 1;
	u8 has_cst: 1;
	u8 has_lpi: 1;
	u8 power_setup_done: 1;
	u8 bm_rld_set: 1;
	u8 previously_online: 1;
};

struct acpi_processor_cx {
	u8 valid;
	u8 type;
	u32 address;
	u8 entry_method;
	u8 index;
	u32 latency;
	u8 bm_sts_skip;
	char desc[32];
};

struct acpi_processor_power {
	int count;
	union {
		struct acpi_processor_cx states[8];
		struct acpi_lpi_state lpi_states[8];
	};
	int timer_broadcast_on_state;
};

struct acpi_tsd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_processor_tx {
	u16 power;
	u16 performance;
};

struct acpi_processor_tx_tss;

struct acpi_processor;

struct acpi_processor_throttling {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	unsigned int state_count;
	struct acpi_processor_tx_tss *states_tss;
	struct acpi_tsd_package domain_info;
	cpumask_var_t shared_cpu_map;
	int (*acpi_processor_get_throttling)(struct acpi_processor *);
	int (*acpi_processor_set_throttling)(struct acpi_processor *, int, bool);
	u32 address;
	u8 duty_offset;
	u8 duty_width;
	u8 tsd_valid_flag;
	unsigned int shared_type;
	struct acpi_processor_tx states[16];
};

struct acpi_processor_lx {
	int px;
	int tx;
};

struct acpi_processor_limit {
	struct acpi_processor_lx state;
	struct acpi_processor_lx thermal;
	struct acpi_processor_lx user;
};

struct plist_node {
	int prio;
	struct list_head prio_list;
	struct list_head node_list;
};

struct freq_constraints;

struct freq_qos_request {
	enum freq_qos_req_type type;
	struct plist_node pnode;
	struct freq_constraints *qos;
};

struct acpi_processor_performance;

struct acpi_processor {
	acpi_handle handle;
	u32 acpi_id;
	phys_cpuid_t phys_id;
	u32 id;
	u32 pblk;
	int performance_platform_limit;
	int throttling_platform_limit;
	struct acpi_processor_flags flags;
	struct acpi_processor_power power;
	struct acpi_processor_performance *performance;
	struct acpi_processor_throttling throttling;
	struct acpi_processor_limit limit;
	struct thermal_cooling_device *cdev;
	struct device *dev;
	struct freq_qos_request perflib_req;
	struct freq_qos_request thermal_req;
};

struct acpi_processor_errata {
	u8 smp;
	struct {
		u8 throttle: 1;
		u8 fdma: 1;
		u8 reserved: 6;
		u32 bmisx;
	} piix4;
};

struct acpi_psd_package {
	u64 num_entries;
	u64 revision;
	u64 domain;
	u64 coord_type;
	u64 num_processors;
};

struct acpi_processor_px;

struct acpi_processor_performance {
	unsigned int state;
	unsigned int platform_limit;
	struct acpi_pct_register control_register;
	struct acpi_pct_register status_register;
	unsigned int state_count;
	struct acpi_processor_px *states;
	struct acpi_psd_package domain_info;
	cpumask_var_t shared_cpu_map;
	unsigned int shared_type;
};

struct acpi_processor_px {
	u64 core_frequency;
	u64 power;
	u64 transition_latency;
	u64 bus_master_latency;
	u64 control;
	u64 status;
};

struct acpi_processor_throttling_arg {
	struct acpi_processor *pr;
	int target_state;
	bool force;
};

struct acpi_processor_tx_tss {
	u64 freqpercentage;
	u64 power;
	u64 transition_latency;
	u64 control;
	u64 status;
};

struct acpi_prt_entry {
	struct acpi_pci_id id;
	u8 pin;
	acpi_handle link;
	u32 index;
};

struct acpi_reg_walk_info {
	u32 function;
	u32 reg_run_count;
	acpi_adr_space_type space_id;
};

typedef acpi_status (*acpi_repair_function)(struct acpi_evaluate_info *, union acpi_operand_object **);

struct acpi_repair_info {
	char name[4];
	acpi_repair_function repair_function;
};

struct acpi_resource_irq {
	u8 descriptor_length;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	union {
		u8 interrupt;
		struct {
			struct {} __Empty_interrupts;
			u8 interrupts[0];
		};
	};
};

struct acpi_resource_dma {
	u8 type;
	u8 bus_master;
	u8 transfer;
	u8 channel_count;
	union {
		u8 channel;
		struct {
			struct {} __Empty_channels;
			u8 channels[0];
		};
	};
};

struct acpi_resource_start_dependent {
	u8 descriptor_length;
	u8 compatibility_priority;
	u8 performance_robustness;
};

struct acpi_resource_io {
	u8 io_decode;
	u8 alignment;
	u8 address_length;
	u16 minimum;
	u16 maximum;
} __attribute__((packed));

struct acpi_resource_fixed_io {
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_dma {
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct acpi_resource_vendor {
	u16 byte_length;
	u8 byte_data[0];
};

struct acpi_resource_vendor_typed {
	u16 byte_length;
	u8 uuid_subtype;
	u8 uuid[16];
	u8 byte_data[0];
} __attribute__((packed));

struct acpi_resource_end_tag {
	u8 checksum;
};

struct acpi_resource_memory24 {
	u8 write_protect;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct acpi_resource_memory32 {
	u8 write_protect;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct acpi_resource_fixed_memory32 {
	u8 write_protect;
	u32 address;
	u32 address_length;
} __attribute__((packed));

union acpi_resource_attribute {
	struct acpi_memory_attribute mem;
	struct acpi_io_attribute io;
	u8 type_specific;
};

struct acpi_resource_source {
	u8 index;
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_resource_address16 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address16_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address32 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address32_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	struct acpi_address64_attribute address;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_extended_address64 {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
	u8 revision_ID;
	struct acpi_address64_attribute address;
	u64 type_specific;
} __attribute__((packed));

struct acpi_resource_extended_irq {
	u8 producer_consumer;
	u8 triggering;
	u8 polarity;
	u8 shareable;
	u8 wake_capable;
	u8 interrupt_count;
	struct acpi_resource_source resource_source;
	union {
		u32 interrupt;
		struct {
			struct {} __Empty_interrupts;
			u32 interrupts[0];
		};
	};
} __attribute__((packed));

struct acpi_resource_generic_register {
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct acpi_resource_gpio {
	u8 revision_id;
	u8 connection_type;
	u8 producer_consumer;
	u8 pin_config;
	u8 shareable;
	u8 wake_capable;
	u8 io_restriction;
	u8 triggering;
	u8 polarity;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_i2c_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 access_mode;
	u16 slave_address;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_spi_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 wire_mode;
	u8 device_polarity;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
	u32 connection_speed;
} __attribute__((packed));

struct acpi_resource_uart_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 endian;
	u8 data_bits;
	u8 stop_bits;
	u8 flow_control;
	u8 parity;
	u8 lines_enabled;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u32 default_baud_rate;
} __attribute__((packed));

struct acpi_resource_csi2_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
	u8 local_port_instance;
	u8 phy_type;
} __attribute__((packed));

struct acpi_resource_common_serialbus {
	u8 revision_id;
	u8 type;
	u8 producer_consumer;
	u8 slave_mode;
	u8 connection_sharing;
	u8 type_revision_id;
	u16 type_data_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_function {
	u8 revision_id;
	u8 pin_config;
	u8 shareable;
	u16 function_number;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_length;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	u16 *pin_table;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_label {
	u16 string_length;
	char *string_ptr;
} __attribute__((packed));

struct acpi_resource_pin_group {
	u8 revision_id;
	u8 producer_consumer;
	u16 pin_table_length;
	u16 vendor_length;
	u16 *pin_table;
	struct acpi_resource_label resource_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_function {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u16 function_number;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_pin_group_config {
	u8 revision_id;
	u8 producer_consumer;
	u8 shareable;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 vendor_length;
	struct acpi_resource_source resource_source;
	struct acpi_resource_label resource_source_label;
	u8 *vendor_data;
} __attribute__((packed));

struct acpi_resource_clock_input {
	u8 revision_id;
	u8 mode;
	u8 scale;
	u16 frequency_divisor;
	u32 frequency_numerator;
	struct acpi_resource_source resource_source;
} __attribute__((packed));

struct acpi_resource_address {
	u8 resource_type;
	u8 producer_consumer;
	u8 decode;
	u8 min_address_fixed;
	u8 max_address_fixed;
	union acpi_resource_attribute info;
};

union acpi_resource_data {
	struct acpi_resource_irq irq;
	struct acpi_resource_dma dma;
	struct acpi_resource_start_dependent start_dpf;
	struct acpi_resource_io io;
	struct acpi_resource_fixed_io fixed_io;
	struct acpi_resource_fixed_dma fixed_dma;
	struct acpi_resource_vendor vendor;
	struct acpi_resource_vendor_typed vendor_typed;
	struct acpi_resource_end_tag end_tag;
	struct acpi_resource_memory24 memory24;
	struct acpi_resource_memory32 memory32;
	struct acpi_resource_fixed_memory32 fixed_memory32;
	struct acpi_resource_address16 address16;
	struct acpi_resource_address32 address32;
	struct acpi_resource_address64 address64;
	struct acpi_resource_extended_address64 ext_address64;
	struct acpi_resource_extended_irq extended_irq;
	struct acpi_resource_generic_register generic_reg;
	struct acpi_resource_gpio gpio;
	struct acpi_resource_i2c_serialbus i2c_serial_bus;
	struct acpi_resource_spi_serialbus spi_serial_bus;
	struct acpi_resource_uart_serialbus uart_serial_bus;
	struct acpi_resource_csi2_serialbus csi2_serial_bus;
	struct acpi_resource_common_serialbus common_serial_bus;
	struct acpi_resource_pin_function pin_function;
	struct acpi_resource_pin_config pin_config;
	struct acpi_resource_pin_group pin_group;
	struct acpi_resource_pin_group_function pin_group_function;
	struct acpi_resource_pin_group_config pin_group_config;
	struct acpi_resource_clock_input clock_input;
	struct acpi_resource_address address;
};

struct acpi_resource {
	u32 type;
	u32 length;
	union acpi_resource_data data;
};

struct acpi_rsconvert_info {
	u8 opcode;
	u8 resource_offset;
	u8 aml_offset;
	u8 value;
};

struct acpi_rw_lock {
	void *writer_mutex;
	void *reader_mutex;
	u32 num_readers;
};

struct acpi_s2idle_dev_ops {
	struct list_head list_node;
	void (*prepare)(void);
	void (*check)(void);
	void (*restore)(void);
};

struct acpi_scan_clear_dep_work {
	struct work_struct work;
	struct acpi_device *adev;
};

struct acpi_scan_handler {
	struct list_head list_node;
	const struct acpi_device_id *ids;
	bool (*match)(const char *, const struct acpi_device_id **);
	int (*attach)(struct acpi_device *, const struct acpi_device_id *);
	void (*detach)(struct acpi_device *);
	void (*post_eject)(struct acpi_device *);
	void (*bind)(struct device *);
	void (*unbind)(struct device *);
	struct acpi_hotplug_profile hotplug;
};

typedef u32 (*acpi_sci_handler)(void *);

struct acpi_sci_handler_info {
	struct acpi_sci_handler_info *next;
	acpi_sci_handler address;
	void *context;
};

struct acpi_signal_fatal_info {
	u32 type;
	u32 code;
	u32 argument;
};

typedef acpi_status (*acpi_object_converter)(struct acpi_namespace_node *, union acpi_operand_object *, union acpi_operand_object **);

struct acpi_simple_repair_info {
	char name[4];
	u32 unexpected_btypes;
	u32 package_index;
	acpi_object_converter object_converter;
};

struct acpi_srat_cpu_affinity {
	struct acpi_subtable_header header;
	u8 proximity_domain_lo;
	u8 apic_id;
	u32 flags;
	u8 local_sapic_eid;
	u8 proximity_domain_hi[3];
	u32 clock_domain;
};

struct acpi_srat_generic_affinity {
	struct acpi_subtable_header header;
	u8 reserved;
	u8 device_handle_type;
	u32 proximity_domain;
	u8 device_handle[16];
	u32 flags;
	u32 reserved1;
};

struct acpi_srat_gicc_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u32 acpi_processor_uid;
	u32 flags;
	u32 clock_domain;
} __attribute__((packed));

struct acpi_srat_mem_affinity {
	struct acpi_subtable_header header;
	u32 proximity_domain;
	u16 reserved;
	u64 base_address;
	u64 length;
	u32 reserved1;
	u32 flags;
	u64 reserved2;
} __attribute__((packed));

struct acpi_srat_rintc_affinity {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 proximity_domain;
	u32 acpi_processor_uid;
	u32 flags;
	u32 clock_domain;
};

struct acpi_srat_x2apic_cpu_affinity {
	struct acpi_subtable_header header;
	u16 reserved;
	u32 proximity_domain;
	u32 apic_id;
	u32 flags;
	u32 clock_domain;
	u32 reserved2;
};

struct acpi_subtable_entry {
	union acpi_subtable_headers *hdr;
	enum acpi_subtable_type type;
};

union acpi_subtable_headers {
	struct acpi_subtable_header common;
	struct acpi_hmat_structure hmat;
	struct acpi_prmt_module_header prmt;
	struct acpi_cedt_header cedt;
	struct acpi_cdat_header cdat;
};

typedef int (*acpi_tbl_entry_handler_arg)(union acpi_subtable_headers *, void *, const long unsigned int);

struct acpi_subtable_proc {
	int id;
	acpi_tbl_entry_handler handler;
	acpi_tbl_entry_handler_arg handler_arg;
	void *arg;
	int count;
};

struct acpi_table_attr {
	struct bin_attribute attr;
	char name[4];
	int instance;
	char filename[8];
	struct list_head node;
};

struct acpi_table_header {
	char signature[4];
	u32 length;
	u8 revision;
	u8 checksum;
	char oem_id[6];
	char oem_table_id[8];
	u32 oem_revision;
	char asl_compiler_id[4];
	u32 asl_compiler_revision;
};

struct acpi_table_bert {
	struct acpi_table_header header;
	u32 region_length;
	u64 address;
};

struct acpi_table_bgrt {
	struct acpi_table_header header;
	u16 version;
	u8 status;
	u8 image_type;
	u64 image_address;
	u32 image_offset_x;
	u32 image_offset_y;
};

struct acpi_table_boot {
	struct acpi_table_header header;
	u8 cmos_index;
	u8 reserved[3];
};

struct acpi_table_ccel {
	struct acpi_table_header header;
	u8 CCtype;
	u8 Ccsub_type;
	u16 reserved;
	u64 log_area_minimum_length;
	u64 log_area_start_address;
};

struct acpi_table_cdat {
	u32 length;
	u8 revision;
	u8 checksum;
	u8 reserved[6];
	u32 sequence;
};

struct acpi_table_csrt {
	struct acpi_table_header header;
};

struct acpi_table_desc {
	acpi_physical_address address;
	struct acpi_table_header *pointer;
	u32 length;
	union acpi_name_union signature;
	acpi_owner_id owner_id;
	u8 flags;
	u16 validation_count;
};

struct acpi_table_dmar {
	struct acpi_table_header header;
	u8 width;
	u8 flags;
	u8 reserved[10];
};

struct acpi_table_ecdt {
	struct acpi_table_header header;
	struct acpi_generic_address control;
	struct acpi_generic_address data;
	u32 uid;
	u8 gpe;
	u8 id[0];
} __attribute__((packed));

struct acpi_table_facs {
	char signature[4];
	u32 length;
	u32 hardware_signature;
	u32 firmware_waking_vector;
	u32 global_lock;
	u32 flags;
	u64 xfirmware_waking_vector;
	u8 version;
	u8 reserved[3];
	u32 ospm_flags;
	u8 reserved1[24];
};

struct acpi_table_fadt {
	struct acpi_table_header header;
	u32 facs;
	u32 dsdt;
	u8 model;
	u8 preferred_profile;
	u16 sci_interrupt;
	u32 smi_command;
	u8 acpi_enable;
	u8 acpi_disable;
	u8 s4_bios_request;
	u8 pstate_control;
	u32 pm1a_event_block;
	u32 pm1b_event_block;
	u32 pm1a_control_block;
	u32 pm1b_control_block;
	u32 pm2_control_block;
	u32 pm_timer_block;
	u32 gpe0_block;
	u32 gpe1_block;
	u8 pm1_event_length;
	u8 pm1_control_length;
	u8 pm2_control_length;
	u8 pm_timer_length;
	u8 gpe0_block_length;
	u8 gpe1_block_length;
	u8 gpe1_base;
	u8 cst_control;
	u16 c2_latency;
	u16 c3_latency;
	u16 flush_size;
	u16 flush_stride;
	u8 duty_offset;
	u8 duty_width;
	u8 day_alarm;
	u8 month_alarm;
	u8 century;
	u16 boot_flags;
	u8 reserved;
	u32 flags;
	struct acpi_generic_address reset_register;
	u8 reset_value;
	u16 arm_boot_flags;
	u8 minor_revision;
	u64 Xfacs;
	u64 Xdsdt;
	struct acpi_generic_address xpm1a_event_block;
	struct acpi_generic_address xpm1b_event_block;
	struct acpi_generic_address xpm1a_control_block;
	struct acpi_generic_address xpm1b_control_block;
	struct acpi_generic_address xpm2_control_block;
	struct acpi_generic_address xpm_timer_block;
	struct acpi_generic_address xgpe0_block;
	struct acpi_generic_address xgpe1_block;
	struct acpi_generic_address sleep_control;
	struct acpi_generic_address sleep_status;
	u64 hypervisor_id;
} __attribute__((packed));

struct acpi_table_hpet {
	struct acpi_table_header header;
	u32 id;
	struct acpi_generic_address address;
	u8 sequence;
	u16 minimum_tick;
	u8 flags;
} __attribute__((packed));

struct acpi_table_list {
	struct acpi_table_desc *tables;
	u32 current_table_count;
	u32 max_table_count;
	u8 flags;
};

struct acpi_table_lpit {
	struct acpi_table_header header;
};

struct acpi_table_madt {
	struct acpi_table_header header;
	u32 address;
	u32 flags;
};

struct acpi_table_mcfg {
	struct acpi_table_header header;
	u8 reserved[8];
};

struct acpi_table_pcct {
	struct acpi_table_header header;
	u32 flags;
	u64 reserved;
};

struct acpi_table_rsdp {
	char signature[8];
	u8 checksum;
	char oem_id[6];
	u8 revision;
	u32 rsdt_physical_address;
	u32 length;
	u64 xsdt_physical_address;
	u8 extended_checksum;
	u8 reserved[3];
} __attribute__((packed));

struct acpi_table_slit {
	struct acpi_table_header header;
	u64 locality_count;
	u8 entry[0];
} __attribute__((packed));

struct acpi_table_spcr {
	struct acpi_table_header header;
	u8 interface_type;
	u8 reserved[3];
	struct acpi_generic_address serial_port;
	u8 interrupt_type;
	u8 pc_interrupt;
	u32 interrupt;
	u8 baud_rate;
	u8 parity;
	u8 stop_bits;
	u8 flow_control;
	u8 terminal_type;
	u8 language;
	u16 pci_device_id;
	u16 pci_vendor_id;
	u8 pci_bus;
	u8 pci_device;
	u8 pci_function;
	u32 pci_flags;
	u8 pci_segment;
	u32 uart_clk_freq;
	u32 precise_baudrate;
	u16 name_space_string_length;
	u16 name_space_string_offset;
	char name_space_string[0];
} __attribute__((packed));

struct acpi_table_srat {
	struct acpi_table_header header;
	u32 table_revision;
	u64 reserved;
};

struct acpi_table_stao {
	struct acpi_table_header header;
	u8 ignore_uart;
} __attribute__((packed));

struct acpi_table_tpm2 {
	struct acpi_table_header header;
	u16 platform_class;
	u16 reserved;
	u64 control_address;
	u32 start_method;
} __attribute__((packed));

struct acpi_table_viot {
	struct acpi_table_header header;
	u16 node_count;
	u16 node_offset;
	u8 reserved[8];
};

struct client_hdr {
	u32 log_max_len;
	u64 log_start_addr;
} __attribute__((packed));

struct server_hdr {
	u16 reserved;
	u64 log_max_len;
	u64 log_start_addr;
} __attribute__((packed));

struct acpi_tcpa {
	struct acpi_table_header hdr;
	u16 platform_class;
	union {
		struct client_hdr client;
		struct server_hdr server;
	};
};

struct acpi_thermal_trip {
	long unsigned int temp_dk;
	struct acpi_handle_list devices;
};

struct acpi_thermal_passive {
	struct acpi_thermal_trip trip;
	long unsigned int tc1;
	long unsigned int tc2;
	long unsigned int delay;
};

struct acpi_thermal_active {
	struct acpi_thermal_trip trip;
};

struct acpi_thermal_trips {
	struct acpi_thermal_passive passive;
	struct acpi_thermal_active active[10];
};

struct thermal_zone_device;

struct acpi_thermal {
	struct acpi_device *device;
	acpi_bus_id name;
	long unsigned int temp_dk;
	long unsigned int last_temp_dk;
	long unsigned int polling_frequency;
	volatile u8 zombie;
	struct acpi_thermal_trips trips;
	struct thermal_zone_device *thermal_zone;
	int kelvin_offset;
	struct work_struct thermal_check_work;
	struct mutex thermal_check_lock;
	refcount_t thermal_check_count;
};

struct acpi_tpm2_phy {
	u8 start_method_specific[12];
	u32 log_area_minimum_length;
	u64 log_area_start_address;
};

struct acpi_vendor_uuid {
	u8 subtype;
	u8 data[16];
};

struct acpi_vendor_walk_info {
	struct acpi_vendor_uuid *uuid;
	struct acpi_buffer *buffer;
	acpi_status status;
};

struct acpi_video_brightness_flags {
	u8 _BCL_no_ac_battery_levels: 1;
	u8 _BCL_reversed: 1;
	u8 _BQC_use_index: 1;
};

struct acpi_video_bus_cap {
	u8 _DOS: 1;
	u8 _DOD: 1;
	u8 _ROM: 1;
	u8 _GPD: 1;
	u8 _SPD: 1;
	u8 _VPO: 1;
	u8 reserved: 2;
};

struct acpi_video_bus_flags {
	u8 multihead: 1;
	u8 rom: 1;
	u8 post: 1;
	u8 reserved: 5;
};

struct acpi_video_enumerated_device;

struct acpi_video_bus {
	struct acpi_device *device;
	bool backlight_registered;
	u8 dos_setting;
	struct acpi_video_enumerated_device *attached_array;
	u8 attached_count;
	u8 child_count;
	struct acpi_video_bus_cap cap;
	struct acpi_video_bus_flags flags;
	struct list_head video_device_list;
	struct mutex device_list_lock;
	struct list_head entry;
	struct input_dev *input;
	char phys[32];
	struct notifier_block pm_nb;
};

struct acpi_video_device_flags {
	u8 crt: 1;
	u8 lcd: 1;
	u8 tvout: 1;
	u8 dvi: 1;
	u8 bios: 1;
	u8 unknown: 1;
	u8 notify: 1;
	u8 reserved: 1;
};

struct acpi_video_device_cap {
	u8 _ADR: 1;
	u8 _BCL: 1;
	u8 _BCM: 1;
	u8 _BQC: 1;
	u8 _BCQ: 1;
	u8 _DDC: 1;
};

struct acpi_video_device_brightness;

struct backlight_device;

struct acpi_video_device {
	long unsigned int device_id;
	struct acpi_video_device_flags flags;
	struct acpi_video_device_cap cap;
	struct list_head entry;
	struct delayed_work switch_brightness_work;
	int switch_brightness_event;
	struct acpi_video_bus *video;
	struct acpi_device *dev;
	struct acpi_video_device_brightness *brightness;
	struct backlight_device *backlight;
	struct thermal_cooling_device *cooling_dev;
};

struct acpi_video_device_attrib {
	u32 display_index: 4;
	u32 display_port_attachment: 4;
	u32 display_type: 4;
	u32 vendor_specific: 4;
	u32 bios_can_detect: 1;
	u32 depend_on_vga: 1;
	u32 pipe_id: 3;
	u32 reserved: 10;
	u32 device_id_scheme: 1;
};

struct acpi_video_device_brightness {
	int curr;
	int count;
	int *levels;
	struct acpi_video_brightness_flags flags;
};

struct acpi_video_enumerated_device {
	union {
		u32 int_val;
		struct acpi_video_device_attrib attrib;
	} value;
	struct acpi_video_device *bind_info;
};

struct acpi_viot_header {
	u8 type;
	u8 reserved;
	u16 length;
};

struct acpi_viot_mmio {
	struct acpi_viot_header header;
	u32 endpoint;
	u64 base_address;
	u16 output_node;
	u8 reserved[6];
};

struct acpi_viot_pci_range {
	struct acpi_viot_header header;
	u32 endpoint_start;
	u16 segment_start;
	u16 segment_end;
	u16 bdf_start;
	u16 bdf_end;
	u16 output_node;
	u8 reserved[6];
};

struct acpi_viot_virtio_iommu_mmio {
	struct acpi_viot_header header;
	u8 reserved[4];
	u64 base_address;
};

struct acpi_viot_virtio_iommu_pci {
	struct acpi_viot_header header;
	u16 segment;
	u16 bdf;
	u8 reserved[8];
};

struct acpi_wakeup_handler {
	struct list_head list_node;
	bool (*wakeup)(void *);
	void *context;
};

typedef acpi_status (*acpi_parse_downwards)(struct acpi_walk_state *, union acpi_parse_object **);

typedef acpi_status (*acpi_parse_upwards)(struct acpi_walk_state *);

struct acpi_walk_state {
	struct acpi_walk_state *next;
	u8 descriptor_type;
	u8 walk_type;
	u16 opcode;
	u8 next_op_info;
	u8 num_operands;
	u8 operand_index;
	acpi_owner_id owner_id;
	u8 last_predicate;
	u8 current_result;
	u8 return_used;
	u8 scope_depth;
	u8 pass_number;
	u8 namespace_override;
	u8 result_size;
	u8 result_count;
	u8 *aml;
	u32 arg_types;
	u32 method_breakpoint;
	u32 user_breakpoint;
	u32 parse_flags;
	struct acpi_parse_state parser_state;
	u32 prev_arg_types;
	u32 arg_count;
	u16 method_nesting_depth;
	u8 method_is_nested;
	struct acpi_namespace_node arguments[7];
	struct acpi_namespace_node local_variables[8];
	union acpi_operand_object *operands[9];
	union acpi_operand_object **params;
	u8 *aml_last_while;
	union acpi_operand_object **caller_return_desc;
	union acpi_generic_state *control_state;
	struct acpi_namespace_node *deferred_node;
	union acpi_operand_object *implicit_return_obj;
	struct acpi_namespace_node *method_call_node;
	union acpi_parse_object *method_call_op;
	union acpi_operand_object *method_desc;
	struct acpi_namespace_node *method_node;
	char *method_pathname;
	union acpi_parse_object *op;
	const struct acpi_opcode_info *op_info;
	union acpi_parse_object *origin;
	union acpi_operand_object *result_obj;
	union acpi_generic_state *results;
	union acpi_operand_object *return_desc;
	union acpi_generic_state *scope_info;
	union acpi_parse_object *prev_op;
	union acpi_parse_object *next_op;
	struct acpi_thread_state *thread;
	acpi_parse_downwards descending_callback;
	acpi_parse_upwards ascending_callback;
};

struct acpihid_map_entry {
	struct list_head list;
	u8 uid[256];
	u8 hid[9];
	u32 devid;
	u32 root_devid;
	bool cmd_line;
	struct iommu_group *group;
};

struct pnp_dev;

struct acpipnp_parse_option_s {
	struct pnp_dev *dev;
	unsigned int option_flags;
};

struct action_cache {
	long unsigned int allow_native[8];
};

struct action_devres {
	void *data;
	void (*action)(void *);
};

struct ip_tunnel_key {
	__be64 tun_id;
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ipv4;
		struct {
			struct in6_addr src;
			struct in6_addr dst;
		} ipv6;
	} u;
	long unsigned int tun_flags[1];
	__be32 label;
	u32 nhid;
	u8 tos;
	u8 ttl;
	__be16 tp_src;
	__be16 tp_dst;
	__u8 flow_flags;
};

struct vlan_head {
	__be16 tpid;
	__be16 tci;
};

struct ovs_nsh_key_base {
	__u8 flags;
	__u8 ttl;
	__u8 mdtype;
	__u8 np;
	__be32 path_hdr;
};

struct ovs_key_nsh {
	struct ovs_nsh_key_base base;
	__be32 context[4];
};

struct ovs_key_ct_labels {
	union {
		__u8 ct_labels[16];
		__u32 ct_labels_32[4];
	};
};

struct sw_flow_key {
	u8 tun_opts[255];
	u8 tun_opts_len;
	struct ip_tunnel_key tun_key;
	struct {
		u32 priority;
		u32 skb_mark;
		u16 in_port;
	} __attribute__((packed)) phy;
	u8 mac_proto;
	u8 tun_proto;
	u32 ovs_flow_hash;
	u32 recirc_id;
	struct {
		u8 src[6];
		u8 dst[6];
		struct vlan_head vlan;
		struct vlan_head cvlan;
		__be16 type;
	} eth;
	u8 ct_state;
	u8 ct_orig_proto;
	union {
		struct {
			u8 proto;
			u8 tos;
			u8 ttl;
			u8 frag;
		} ip;
	};
	u16 ct_zone;
	struct {
		__be16 src;
		__be16 dst;
		__be16 flags;
	} tp;
	union {
		struct {
			struct {
				__be32 src;
				__be32 dst;
			} addr;
			union {
				struct {
					__be32 src;
					__be32 dst;
				} ct_orig;
				struct {
					u8 sha[6];
					u8 tha[6];
				} arp;
			};
		} ipv4;
		struct {
			struct {
				struct in6_addr src;
				struct in6_addr dst;
			} addr;
			__be32 label;
			u16 exthdrs;
			union {
				struct {
					struct in6_addr src;
					struct in6_addr dst;
				} ct_orig;
				struct {
					struct in6_addr target;
					u8 sll[6];
					u8 tll[6];
				} nd;
			};
		} ipv6;
		struct {
			u32 num_labels_mask;
			__be32 lse[3];
		} mpls;
		struct ovs_key_nsh nsh;
	};
	struct {
		struct {
			__be16 src;
			__be16 dst;
		} orig_tp;
		u32 mark;
		struct ovs_key_ct_labels labels;
	} ct;
};

struct deferred_action {
	struct sk_buff *skb;
	const struct nlattr *actions;
	int actions_len;
	struct sw_flow_key pkt_key;
};

struct action_fifo {
	int head;
	int tail;
	struct deferred_action fifo[10];
};

struct action_flow_keys {
	struct sw_flow_key key[3];
};

struct action_gate_entry {
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
};

struct dma_fence;

struct dma_fence_cb;

typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);

struct dma_fence_cb {
	struct list_head node;
	dma_fence_func_t func;
};

struct i915_active_fence {
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct i915_active;

struct active_node {
	struct rb_node node;
	struct i915_active_fence base;
	struct i915_active *ref;
	u64 timeline;
};

struct addr_marker {
	long unsigned int start_address;
	const char *name;
	long unsigned int max_lines;
};

struct rb_root {
	struct rb_node *rb_node;
};

struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};

struct address_space_operations;

struct address_space {
	struct inode *host;
	struct xarray i_pages;
	struct rw_semaphore invalidate_lock;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	long unsigned int nrpages;
	long unsigned int writeback_index;
	const struct address_space_operations *a_ops;
	long unsigned int flags;
	errseq_t wb_err;
	spinlock_t i_private_lock;
	struct list_head i_private_list;
	struct rw_semaphore i_mmap_rwsem;
	void *i_private_data;
};

struct writeback_control;

struct readahead_control;

struct kiocb;

struct iov_iter;

struct swap_info_struct;

struct address_space_operations {
	int (*writepage)(struct page *, struct writeback_control *);
	int (*read_folio)(struct file *, struct folio *);
	int (*writepages)(struct address_space *, struct writeback_control *);
	bool (*dirty_folio)(struct address_space *, struct folio *);
	void (*readahead)(struct readahead_control *);
	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, struct folio **, void **);
	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct folio *, void *);
	sector_t (*bmap)(struct address_space *, sector_t);
	void (*invalidate_folio)(struct folio *, size_t, size_t);
	bool (*release_folio)(struct folio *, gfp_t);
	void (*free_folio)(struct folio *);
	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
	int (*migrate_folio)(struct address_space *, struct folio *, struct folio *, enum migrate_mode);
	int (*launder_folio)(struct folio *);
	bool (*is_partially_uptodate)(struct folio *, size_t, size_t);
	void (*is_dirty_writeback)(struct folio *, bool *, bool *);
	int (*error_remove_folio)(struct address_space *, struct folio *);
	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
	void (*swap_deactivate)(struct file *);
	int (*swap_rw)(struct kiocb *, struct iov_iter *);
};

struct adjust_trip_data {
	struct acpi_thermal *tz;
	u32 event;
};

struct crypto_aead;

struct aead_request;

struct aead_alg {
	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
	int (*setauthsize)(struct crypto_aead *, unsigned int);
	int (*encrypt)(struct aead_request *);
	int (*decrypt)(struct aead_request *);
	int (*init)(struct crypto_aead *);
	void (*exit)(struct crypto_aead *);
	unsigned int ivsize;
	unsigned int maxauthsize;
	unsigned int chunksize;
	struct crypto_alg base;
};

struct crypto_sync_skcipher;

struct aead_geniv_ctx {
	spinlock_t lock;
	struct crypto_aead *child;
	struct crypto_sync_skcipher *sknull;
	u8 salt[0];
};

struct crypto_template;

struct crypto_spawn;

struct crypto_instance {
	struct crypto_alg alg;
	struct crypto_template *tmpl;
	union {
		struct hlist_node list;
		struct crypto_spawn *spawns;
	};
	struct work_struct free_work;
	void *__ctx[0];
};

struct aead_instance {
	void (*free)(struct aead_instance *);
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct aead_alg alg;
	};
};

struct aead_request {
	struct crypto_async_request base;
	unsigned int assoclen;
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	void *__ctx[0];
};

struct sg_table {
	struct scatterlist *sgl;
	unsigned int nents;
	unsigned int orig_nents;
};

struct scatterlist {
	long unsigned int page_link;
	unsigned int offset;
	unsigned int length;
	dma_addr_t dma_address;
	unsigned int dma_length;
	unsigned int dma_flags;
};

struct af_alg_sgl {
	struct sg_table sgt;
	struct scatterlist sgl[17];
	bool need_unpin;
};

struct af_alg_rsgl {
	struct af_alg_sgl sgl;
	struct list_head list;
	size_t sg_num_bytes;
};

struct skcipher_request {
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	struct crypto_async_request base;
	void *__ctx[0];
};

struct sock;

struct af_alg_async_req {
	struct kiocb *iocb;
	struct sock *sk;
	struct af_alg_rsgl first_rsgl;
	struct af_alg_rsgl *last_rsgl;
	struct list_head rsgl_list;
	struct scatterlist *tsgl;
	unsigned int tsgl_entries;
	unsigned int outlen;
	unsigned int areqlen;
	union {
		struct aead_request aead_req;
		struct skcipher_request skcipher_req;
	} cra_u;
};

struct af_alg_iv;

struct af_alg_control {
	struct af_alg_iv *iv;
	int op;
	unsigned int aead_assoclen;
};

struct crypto_wait {
	struct completion completion;
	int err;
};

struct af_alg_ctx {
	struct list_head tsgl_list;
	void *iv;
	void *state;
	size_t aead_assoclen;
	struct crypto_wait wait;
	size_t used;
	atomic_t rcvused;
	bool more;
	bool merge;
	bool enc;
	bool init;
	unsigned int len;
	unsigned int inflight;
};

struct af_alg_iv {
	__u32 ivlen;
	__u8 iv[0];
};

struct af_alg_tsgl {
	struct list_head list;
	unsigned int cur;
	struct scatterlist sg[0];
};

struct proto_ops;

struct af_alg_type {
	void * (*bind)(const char *, u32, u32);
	void (*release)(void *);
	int (*setkey)(void *, const u8 *, unsigned int);
	int (*setentropy)(void *, sockptr_t, unsigned int);
	int (*accept)(void *, struct sock *);
	int (*accept_nokey)(void *, struct sock *);
	int (*setauthsize)(void *, unsigned int);
	struct proto_ops *ops;
	struct proto_ops *ops_nokey;
	struct module *owner;
	char name[14];
};

struct af_vsockmon_hdr {
	__le64 src_cid;
	__le64 dst_cid;
	__le32 src_port;
	__le32 dst_port;
	__le16 op;
	__le16 transport;
	__le16 len;
	__u8 reserved[2];
};

struct affinity_context {
	const struct cpumask *new_mask;
	struct cpumask *user_mask;
	unsigned int flags;
};

struct aggregate_control {
	long int *aggregate;
	long int *local;
	long int *pending;
	long int *ppending;
	long int *cstat;
	long int *cstat_prev;
	int size;
};

struct component_master_ops;

struct component_match;

struct aggregate_device {
	struct list_head node;
	bool bound;
	const struct component_master_ops *ops;
	struct device *parent;
	struct component_match *match;
};

struct aggressiveness_profile2_entry {
	u8 opst_aggressiveness: 4;
	u8 elp_aggressiveness: 4;
};

struct aggressiveness_profile3_entry {
	u8 apd_aggressiveness: 4;
	u8 pixoptix_aggressiveness: 4;
};

struct aggressiveness_profile4_entry {
	u8 xpst_aggressiveness: 4;
	u8 tcon_aggressiveness: 4;
};

struct aggressiveness_profile_entry {
	u8 dpst_aggressiveness: 4;
	u8 lace_aggressiveness: 4;
};

struct xfs_btree_ops;

struct aghdr_init_data {
	xfs_agblock_t agno;
	xfs_extlen_t agsize;
	struct list_head buffer_list;
	xfs_rfsblock_t nfree;
	xfs_daddr_t daddr;
	size_t numblks;
	const struct xfs_btree_ops *bc_ops;
};

struct agp_3_5_dev {
	struct list_head list;
	u8 capndx;
	u32 maxbw;
	struct pci_dev *dev;
};

struct agp_version;

struct agp_bridge_driver;

struct vm_operations_struct;

struct agp_bridge_data {
	const struct agp_version *version;
	const struct agp_bridge_driver *driver;
	const struct vm_operations_struct *vm_ops;
	void *previous_size;
	void *current_size;
	void *dev_private_data;
	struct pci_dev *dev;
	u32 *gatt_table;
	u32 *gatt_table_real;
	long unsigned int scratch_page;
	struct page *scratch_page_page;
	dma_addr_t scratch_page_dma;
	long unsigned int gart_bus_addr;
	long unsigned int gatt_bus_addr;
	u32 mode;
	long unsigned int *key_list;
	atomic_t current_memory_agp;
	atomic_t agp_in_use;
	int max_memory_agp;
	int aperture_size_idx;
	int capndx;
	int flags;
	char major_version;
	char minor_version;
	struct list_head list;
	u32 apbase_config;
	struct list_head mapped_list;
	spinlock_t mapped_lock;
};

struct gatt_mask;

struct agp_memory;

struct agp_bridge_driver {
	struct module *owner;
	const void *aperture_sizes;
	int num_aperture_sizes;
	enum aper_size_type size_type;
	bool cant_use_aperture;
	bool needs_scratch_page;
	const struct gatt_mask *masks;
	int (*fetch_size)(void);
	int (*configure)(void);
	void (*agp_enable)(struct agp_bridge_data *, u32);
	void (*cleanup)(void);
	void (*tlb_flush)(struct agp_memory *);
	long unsigned int (*mask_memory)(struct agp_bridge_data *, dma_addr_t, int);
	void (*cache_flush)(void);
	int (*create_gatt_table)(struct agp_bridge_data *);
	int (*free_gatt_table)(struct agp_bridge_data *);
	int (*insert_memory)(struct agp_memory *, off_t, int);
	int (*remove_memory)(struct agp_memory *, off_t, int);
	struct agp_memory * (*alloc_by_type)(size_t, int);
	void (*free_by_type)(struct agp_memory *);
	struct page * (*agp_alloc_page)(struct agp_bridge_data *);
	int (*agp_alloc_pages)(struct agp_bridge_data *, struct agp_memory *, size_t);
	void (*agp_destroy_page)(struct page *, int);
	void (*agp_destroy_pages)(struct agp_memory *);
	int (*agp_type_to_mask_type)(struct agp_bridge_data *, int);
};

struct agp_version {
	u16 major;
	u16 minor;
};

struct agp_kern_info {
	struct agp_version version;
	struct pci_dev *device;
	enum chipset_type chipset;
	long unsigned int mode;
	long unsigned int aper_base;
	size_t aper_size;
	int max_memory;
	int current_memory;
	bool cant_use_aperture;
	long unsigned int page_mask;
	const struct vm_operations_struct *vm_ops;
};

struct agp_memory {
	struct agp_memory *next;
	struct agp_memory *prev;
	struct agp_bridge_data *bridge;
	struct page **pages;
	size_t page_count;
	int key;
	int num_scratch_pages;
	off_t pg_start;
	u32 type;
	u32 physical;
	bool is_bound;
	bool is_flushed;
	struct list_head mapped_list;
	struct scatterlist *sg_list;
	int num_sg;
};

struct crypto_ahash;

struct ah_data {
	int icv_full_len;
	int icv_trunc_len;
	struct crypto_ahash *ahash;
};

struct ip_options {
	__be32 faddr;
	__be32 nexthop;
	unsigned char optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_strictroute: 1;
	unsigned char srr_is_hit: 1;
	unsigned char is_changed: 1;
	unsigned char rr_needaddr: 1;
	unsigned char ts_needtime: 1;
	unsigned char ts_needaddr: 1;
	unsigned char router_alert;
	unsigned char cipso;
	unsigned char __pad2;
	unsigned char __data[0];
};

struct inet_skb_parm {
	int iif;
	struct ip_options opt;
	u16 flags;
	u16 frag_max_size;
};

struct inet6_skb_parm {
	int iif;
	__be16 ra;
	__u16 dst0;
	__u16 srcrt;
	__u16 dst1;
	__u16 lastopt;
	__u16 nhoff;
	__u16 flags;
	__u16 dsthao;
	__u16 frag_max_size;
	__u16 srhoff;
};

struct ip_tunnel;

struct ip6_tnl;

struct xfrm_tunnel_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	union {
		struct ip_tunnel *ip4;
		struct ip6_tnl *ip6;
	} tunnel;
};

struct xfrm_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	union {
		struct {
			__u32 low;
			__u32 hi;
		} output;
		struct {
			__be32 low;
			__be32 hi;
		} input;
	} seq;
};

struct ah_skb_cb {
	struct xfrm_skb_cb xfrm;
	void *tmp;
};

struct hash_alg_common {
	unsigned int digestsize;
	unsigned int statesize;
	struct crypto_alg base;
};

struct ahash_request;

struct ahash_alg {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_ahash *);
	void (*exit_tfm)(struct crypto_ahash *);
	int (*clone_tfm)(struct crypto_ahash *, struct crypto_ahash *);
	struct hash_alg_common halg;
};

struct ahash_instance {
	void (*free)(struct ahash_instance *);
	union {
		struct {
			char head[96];
			struct crypto_instance base;
		} s;
		struct ahash_alg alg;
	};
};

struct ahash_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	struct scatterlist *src;
	u8 *result;
	void *priv;
	void *__ctx[0];
};

struct wait_page_queue;

struct kiocb {
	struct file *ki_filp;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb *, long int);
	void *private;
	int ki_flags;
	u16 ki_ioprio;
	union {
		struct wait_page_queue *ki_waitq;
		ssize_t (*dio_complete)(void *);
	};
};

struct cred;

struct fsync_iocb {
	struct file *file;
	struct work_struct work;
	bool datasync;
	struct cred *creds;
};

struct wait_queue_entry;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);

struct wait_queue_entry {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head entry;
};

struct poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool cancelled;
	bool work_scheduled;
	bool work_need_resched;
	struct wait_queue_entry wait;
	struct work_struct work;
};

typedef int kiocb_cancel_fn(struct kiocb *);

struct io_event {
	__u64 data;
	__u64 obj;
	__s64 res;
	__s64 res2;
};

struct kioctx;

struct eventfd_ctx;

struct aio_kiocb {
	union {
		struct file *ki_filp;
		struct kiocb rw;
		struct fsync_iocb fsync;
		struct poll_iocb poll;
	};
	struct kioctx *ki_ctx;
	kiocb_cancel_fn *ki_cancel;
	struct io_event ki_res;
	struct list_head ki_list;
	refcount_t ki_refcnt;
	struct eventfd_ctx *ki_eventfd;
};

struct poll_table_struct;

typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
};

struct aio_poll_table {
	struct poll_table_struct pt;
	struct aio_kiocb *iocb;
	bool queued;
	int error;
};

struct aio_ring {
	unsigned int id;
	unsigned int nr;
	unsigned int head;
	unsigned int tail;
	unsigned int magic;
	unsigned int compat_features;
	unsigned int incompat_features;
	unsigned int header_length;
	struct io_event io_events[0];
};

struct aio_waiter {
	struct wait_queue_entry w;
	size_t min_nr;
};

struct akcipher_request;

struct crypto_akcipher;

struct akcipher_alg {
	int (*encrypt)(struct akcipher_request *);
	int (*decrypt)(struct akcipher_request *);
	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
	unsigned int (*max_size)(struct crypto_akcipher *);
	int (*init)(struct crypto_akcipher *);
	void (*exit)(struct crypto_akcipher *);
	struct crypto_alg base;
};

struct akcipher_instance {
	void (*free)(struct akcipher_instance *);
	union {
		struct {
			char head[56];
			struct crypto_instance base;
		} s;
		struct akcipher_alg alg;
	};
};

struct akcipher_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	void *__ctx[0];
};

struct alarm {
	struct timerqueue_node node;
	struct hrtimer timer;
	void (*function)(struct alarm *, ktime_t);
	enum alarmtimer_type type;
	int state;
	void *data;
};

struct timerqueue_head {
	struct rb_root_cached rb_root;
};

struct timespec64;

struct alarm_base {
	spinlock_t lock;
	struct timerqueue_head timerqueue;
	ktime_t (*get_ktime)(void);
	void (*get_timespec)(struct timespec64 *);
	clockid_t base_clockid;
};

struct alert_data {
	short unsigned int addr;
	enum i2c_alert_protocol type;
	unsigned int data;
};

struct hlist_nulls_node {
	struct hlist_nulls_node *next;
	struct hlist_nulls_node **pprev;
};

struct proto;

struct inet_timewait_death_row;

struct sock_common {
	union {
		__addrpair skc_addrpair;
		struct {
			__be32 skc_daddr;
			__be32 skc_rcv_saddr;
		};
	};
	union {
		unsigned int skc_hash;
		__u16 skc_u16hashes[2];
	};
	union {
		__portpair skc_portpair;
		struct {
			__be16 skc_dport;
			__u16 skc_num;
		};
	};
	short unsigned int skc_family;
	volatile unsigned char skc_state;
	unsigned char skc_reuse: 4;
	unsigned char skc_reuseport: 1;
	unsigned char skc_ipv6only: 1;
	unsigned char skc_net_refcnt: 1;
	int skc_bound_dev_if;
	union {
		struct hlist_node skc_bind_node;
		struct hlist_node skc_portaddr_node;
	};
	struct proto *skc_prot;
	possible_net_t skc_net;
	struct in6_addr skc_v6_daddr;
	struct in6_addr skc_v6_rcv_saddr;
	atomic64_t skc_cookie;
	union {
		long unsigned int skc_flags;
		struct sock *skc_listener;
		struct inet_timewait_death_row *skc_tw_dr;
	};
	int skc_dontcopy_begin[0];
	union {
		struct hlist_node skc_node;
		struct hlist_nulls_node skc_nulls_node;
	};
	short unsigned int skc_tx_queue_mapping;
	short unsigned int skc_rx_queue_mapping;
	union {
		int skc_incoming_cpu;
		u32 skc_rcv_wnd;
		u32 skc_tw_rcv_nxt;
	};
	refcount_t skc_refcnt;
	int skc_dontcopy_end[0];
	union {
		u32 skc_rxhash;
		u32 skc_window_clamp;
		u32 skc_tw_snd_nxt;
	};
};

struct page_frag {
	struct page *page;
	__u32 offset;
	__u32 size;
};

struct sock_cgroup_data {
	struct cgroup *cgroup;
	u32 classid;
	u16 prioidx;
};

struct dst_entry;

struct sk_filter;

struct socket_wq;

struct socket;

struct mem_cgroup;

struct xfrm_policy;

struct pid;

struct sock_reuseport;

struct bpf_local_storage;

struct sock {
	struct sock_common __sk_common;
	__u8 __cacheline_group_begin__sock_write_rx[0];
	atomic_t sk_drops;
	__s32 sk_peek_off;
	struct sk_buff_head sk_error_queue;
	struct sk_buff_head sk_receive_queue;
	struct {
		atomic_t rmem_alloc;
		int len;
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	__u8 __cacheline_group_end__sock_write_rx[0];
	__u8 __cacheline_group_begin__sock_read_rx[0];
	struct dst_entry *sk_rx_dst;
	int sk_rx_dst_ifindex;
	u32 sk_rx_dst_cookie;
	unsigned int sk_ll_usec;
	unsigned int sk_napi_id;
	u16 sk_busy_poll_budget;
	u8 sk_prefer_busy_poll;
	u8 sk_userlocks;
	int sk_rcvbuf;
	struct sk_filter *sk_filter;
	union {
		struct socket_wq *sk_wq;
		struct socket_wq *sk_wq_raw;
	};
	void (*sk_data_ready)(struct sock *);
	long int sk_rcvtimeo;
	int sk_rcvlowat;
	__u8 __cacheline_group_end__sock_read_rx[0];
	__u8 __cacheline_group_begin__sock_read_rxtx[0];
	int sk_err;
	struct socket *sk_socket;
	struct mem_cgroup *sk_memcg;
	struct xfrm_policy *sk_policy[2];
	__u8 __cacheline_group_end__sock_read_rxtx[0];
	__u8 __cacheline_group_begin__sock_write_rxtx[0];
	socket_lock_t sk_lock;
	u32 sk_reserved_mem;
	int sk_forward_alloc;
	u32 sk_tsflags;
	__u8 __cacheline_group_end__sock_write_rxtx[0];
	__u8 __cacheline_group_begin__sock_write_tx[0];
	int sk_write_pending;
	atomic_t sk_omem_alloc;
	int sk_sndbuf;
	int sk_wmem_queued;
	refcount_t sk_wmem_alloc;
	long unsigned int sk_tsq_flags;
	union {
		struct sk_buff *sk_send_head;
		struct rb_root tcp_rtx_queue;
	};
	struct sk_buff_head sk_write_queue;
	u32 sk_dst_pending_confirm;
	u32 sk_pacing_status;
	struct page_frag sk_frag;
	struct timer_list sk_timer;
	long unsigned int sk_pacing_rate;
	atomic_t sk_zckey;
	atomic_t sk_tskey;
	__u8 __cacheline_group_end__sock_write_tx[0];
	__u8 __cacheline_group_begin__sock_read_tx[0];
	long unsigned int sk_max_pacing_rate;
	long int sk_sndtimeo;
	u32 sk_priority;
	u32 sk_mark;
	struct dst_entry *sk_dst_cache;
	netdev_features_t sk_route_caps;
	u16 sk_gso_type;
	u16 sk_gso_max_segs;
	unsigned int sk_gso_max_size;
	gfp_t sk_allocation;
	u32 sk_txhash;
	u8 sk_pacing_shift;
	bool sk_use_task_frag;
	__u8 __cacheline_group_end__sock_read_tx[0];
	u8 sk_gso_disabled: 1;
	u8 sk_kern_sock: 1;
	u8 sk_no_check_tx: 1;
	u8 sk_no_check_rx: 1;
	u8 sk_shutdown;
	u16 sk_type;
	u16 sk_protocol;
	long unsigned int sk_lingertime;
	struct proto *sk_prot_creator;
	rwlock_t sk_callback_lock;
	int sk_err_soft;
	u32 sk_ack_backlog;
	u32 sk_max_ack_backlog;
	kuid_t sk_uid;
	spinlock_t sk_peer_lock;
	int sk_bind_phc;
	struct pid *sk_peer_pid;
	const struct cred *sk_peer_cred;
	ktime_t sk_stamp;
	int sk_disconnects;
	u8 sk_txrehash;
	u8 sk_clockid;
	u8 sk_txtime_deadline_mode: 1;
	u8 sk_txtime_report_errors: 1;
	u8 sk_txtime_unused: 6;
	void *sk_user_data;
	void *sk_security;
	struct sock_cgroup_data sk_cgrp_data;
	void (*sk_state_change)(struct sock *);
	void (*sk_write_space)(struct sock *);
	void (*sk_error_report)(struct sock *);
	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
	void (*sk_destruct)(struct sock *);
	struct sock_reuseport *sk_reuseport_cb;
	struct bpf_local_storage *sk_bpf_storage;
	struct callback_head sk_rcu;
	netns_tracker ns_tracker;
	struct xarray sk_user_frags;
};

struct alg_sock {
	struct sock sk;
	struct sock *parent;
	atomic_t refcnt;
	atomic_t nokey_refcnt;
	const struct af_alg_type *type;
	void *private;
};

struct alg_type_list {
	const struct af_alg_type *type;
	struct list_head list;
};

struct alloc_chunk_ctl {
	u64 start;
	u64 type;
	int num_stripes;
	int sub_stripes;
	int dev_stripes;
	int devs_max;
	int devs_min;
	int devs_increment;
	int ncopies;
	int nparity;
	u64 max_stripe_size;
	u64 max_chunk_size;
	u64 dev_extent_min;
	u64 stripe_size;
	u64 chunk_size;
	int ndevs;
};

struct zonelist;

struct zoneref;

struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;
	enum zone_type highest_zoneidx;
	bool spread_dirty_pages;
};

struct codetag {
	unsigned int flags;
	unsigned int lineno;
	const char *modname;
	const char *function;
	const char *filename;
};

struct alloc_tag_counters;

struct alloc_tag {
	struct codetag ct;
	struct alloc_tag_counters *counters;
};

struct alloc_tag_counters {
	u64 bytes;
	u64 calls;
};

struct alps_bitmap_point {
	int start_bit;
	int num_bits;
};

struct input_mt_pos {
	s16 x;
	s16 y;
};

struct alps_fields {
	unsigned int x_map;
	unsigned int y_map;
	unsigned int fingers;
	int pressure;
	struct input_mt_pos st;
	struct input_mt_pos mt[4];
	unsigned int first_mp: 1;
	unsigned int is_mp: 1;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int ts_left: 1;
	unsigned int ts_right: 1;
	unsigned int ts_middle: 1;
};

struct psmouse;

struct alps_nibble_commands;

struct alps_data {
	struct psmouse *psmouse;
	struct input_dev *dev2;
	struct input_dev *dev3;
	char phys2[32];
	char phys3[32];
	struct delayed_work dev3_register_work;
	const struct alps_nibble_commands *nibble_commands;
	int addr_command;
	u16 proto_version;
	u8 byte0;
	u8 mask0;
	u8 dev_id[3];
	u8 fw_ver[3];
	int flags;
	int x_max;
	int y_max;
	int x_bits;
	int y_bits;
	unsigned int x_res;
	unsigned int y_res;
	int (*hw_init)(struct psmouse *);
	void (*process_packet)(struct psmouse *);
	int (*decode_fields)(struct alps_fields *, unsigned char *, struct psmouse *);
	void (*set_abs_params)(struct alps_data *, struct input_dev *);
	int prev_fin;
	int multi_packet;
	int second_touch;
	unsigned char multi_data[6];
	struct alps_fields f;
	u8 quirks;
	struct timer_list timer;
};

struct alps_protocol_info {
	u16 version;
	u8 byte0;
	u8 mask0;
	unsigned int flags;
};

struct alps_model_info {
	u8 signature[3];
	struct alps_protocol_info protocol_info;
};

struct alps_nibble_commands {
	int command;
	unsigned char data;
};

struct als_data_entry {
	u16 backlight_adjust;
	u16 lux;
};

struct alt_instr {
	s32 instr_offset;
	s32 repl_offset;
	union {
		struct {
			u32 cpuid: 16;
			u32 flags: 16;
		};
		u32 ft_flags;
	};
	u8 instrlen;
	u8 replacementlen;
} __attribute__((packed));

struct amd768_priv {
	void *iobase;
	struct pci_dev *pcidev;
	u32 pmbase;
};

struct amd_aperf_mperf {
	u64 aperf;
	u64 mperf;
	u64 tsc;
};

struct amd_cpudata {
	int cpu;
	struct freq_qos_request req[2];
	u64 cppc_req_cached;
	u8 highest_perf;
	u8 nominal_perf;
	u8 lowest_nonlinear_perf;
	u8 lowest_perf;
	u8 prefcore_ranking;
	u8 min_limit_perf;
	u8 max_limit_perf;
	u32 min_limit_freq;
	u32 max_limit_freq;
	u32 max_freq;
	u32 min_freq;
	u32 nominal_freq;
	u32 lowest_nonlinear_freq;
	struct amd_aperf_mperf cur;
	struct amd_aperf_mperf prev;
	u64 freq;
	bool boost_supported;
	bool hw_prefcore;
	u8 epp_cached;
	u32 policy;
	u64 cppc_cap1_cached;
	bool suspended;
	u8 epp_default;
};

struct amd_hostbridge {
	u32 bus;
	u32 slot;
	u32 device;
};

struct iommu_flush_ops;

struct io_pgtable_cfg {
	long unsigned int quirks;
	long unsigned int pgsize_bitmap;
	unsigned int ias;
	unsigned int oas;
	bool coherent_walk;
	const struct iommu_flush_ops *tlb;
	struct device *iommu_dev;
	void * (*alloc)(void *, size_t, gfp_t);
	void (*free)(void *, void *, size_t);
	union {
		struct {
			u64 ttbr;
			struct {
				u32 ips: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 tsz: 6;
			} tcr;
			u64 mair;
		} arm_lpae_s1_cfg;
		struct {
			u64 vttbr;
			struct {
				u32 ps: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 sl: 2;
				u32 tsz: 6;
			} vtcr;
		} arm_lpae_s2_cfg;
		struct {
			u32 ttbr;
			u32 tcr;
			u32 nmrr;
			u32 prrr;
		} arm_v7s_cfg;
		struct {
			u64 transtab;
			u64 memattr;
		} arm_mali_lpae_cfg;
		struct {
			u64 ttbr[4];
			u32 n_ttbrs;
		} apple_dart_cfg;
		struct {
			int nid;
		} amd;
	};
};

struct iommu_iotlb_gather;

struct iommu_dirty_bitmap;

struct io_pgtable_ops {
	int (*map_pages)(struct io_pgtable_ops *, long unsigned int, phys_addr_t, size_t, size_t, int, gfp_t, size_t *);
	size_t (*unmap_pages)(struct io_pgtable_ops *, long unsigned int, size_t, size_t, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct io_pgtable_ops *, long unsigned int);
	int (*pgtable_walk)(struct io_pgtable_ops *, long unsigned int, void *);
	int (*read_and_clear_dirty)(struct io_pgtable_ops *, long unsigned int, size_t, long unsigned int, struct iommu_dirty_bitmap *);
};

struct io_pgtable {
	enum io_pgtable_fmt fmt;
	void *cookie;
	struct io_pgtable_cfg cfg;
	struct io_pgtable_ops ops;
};

struct amd_io_pgtable {
	struct io_pgtable pgtbl;
	int mode;
	u64 *root;
	u64 *pgd;
};

struct iommu_ops;

struct iommu_device {
	struct list_head list;
	const struct iommu_ops *ops;
	struct fwnode_handle *fwnode;
	struct device *dev;
	struct iommu_group *singleton_group;
	u32 max_pasids;
};

struct amd_iommu_pci_seg;

struct iopf_queue;

struct amd_iommu {
	struct list_head list;
	int index;
	raw_spinlock_t lock;
	struct pci_dev *dev;
	struct pci_dev *root_pdev;
	u64 mmio_phys;
	u64 mmio_phys_end;
	u8 *mmio_base;
	u32 cap;
	u8 acpi_flags;
	u64 features;
	u64 features2;
	u16 devid;
	u16 cap_ptr;
	struct amd_iommu_pci_seg *pci_seg;
	u64 exclusion_start;
	u64 exclusion_length;
	u8 *cmd_buf;
	u32 cmd_buf_head;
	u32 cmd_buf_tail;
	u8 *evt_buf;
	unsigned char evt_irq_name[16];
	u8 *ppr_log;
	unsigned char ppr_irq_name[16];
	u8 *ga_log;
	unsigned char ga_irq_name[16];
	u8 *ga_log_tail;
	bool int_enabled;
	bool need_sync;
	bool irtcachedis_enabled;
	struct iommu_device iommu;
	u32 stored_addr_lo;
	u32 stored_addr_hi;
	u32 stored_l1[108];
	u32 stored_l2[131];
	u8 max_banks;
	u8 max_counters;
	u32 flags;
	volatile u64 *cmd_sem;
	atomic64_t cmd_sem_val;
	struct iopf_queue *iopf_queue;
	unsigned char iopfq_name[32];
};

struct amd_iommu_event_desc {
	struct device_attribute attr;
	const char *event;
};

struct llist_head {
	struct llist_node *first;
};

struct dev_table_entry;

struct irq_remap_table;

struct amd_iommu_pci_seg {
	struct list_head list;
	struct llist_head dev_data_list;
	u16 id;
	u16 last_bdf;
	u32 dev_table_size;
	u32 alias_table_size;
	u32 rlookup_table_size;
	struct dev_table_entry *dev_table;
	struct amd_iommu **rlookup_table;
	struct irq_remap_table **irq_lookup_table;
	struct dev_table_entry *old_dev_tbl_cpy;
	u16 *alias_table;
	struct list_head unity_map;
};

struct amd_l3_cache {
	unsigned int indices;
	u8 subcaches[4];
};

struct amd_lps0_hid_device_data {
	const bool check_off_by_one;
};

struct event_constraint {
	union {
		long unsigned int idxmsk[1];
		u64 idxmsk64;
	};
	u64 code;
	u64 cmask;
	int weight;
	int overlap;
	int flags;
	unsigned int size;
};

struct perf_event;

struct amd_nb {
	int nb_id;
	int refcnt;
	struct perf_event *owners[64];
	struct event_constraint event_constraints[64];
};

struct amd_nb_bus_dev_range {
	u8 bus;
	u8 dev_base;
	u8 dev_limit;
};

struct amd_northbridge {
	struct pci_dev *root;
	struct pci_dev *misc;
	struct pci_dev *link;
	struct amd_l3_cache l3_cache;
};

struct amd_northbridge_info {
	u16 num;
	u64 flags;
	struct amd_northbridge *nb;
};

union amd_uncore_info;

struct amd_uncore_pmu;

struct amd_uncore {
	union amd_uncore_info *info;
	struct amd_uncore_pmu *pmus;
	unsigned int num_pmus;
	bool init_done;
	void (*scan)(struct amd_uncore *, unsigned int);
	int (*init)(struct amd_uncore *, unsigned int);
	void (*move)(struct amd_uncore *, unsigned int);
	void (*free)(struct amd_uncore *, unsigned int);
};

struct amd_uncore_ctx {
	int refcnt;
	int cpu;
	struct perf_event **events;
	struct hlist_node node;
};

union amd_uncore_info {
	struct {
		u64 aux_data: 32;
		u64 num_pmcs: 8;
		u64 gid: 8;
		u64 cid: 8;
	} split;
	u64 full;
};

typedef struct cpumask cpumask_t;

struct perf_cpu_pmu_context;

struct perf_event_pmu_context;

struct kmem_cache;

struct perf_output_handle;

struct pmu {
	struct list_head entry;
	struct module *module;
	struct device *dev;
	struct device *parent;
	const struct attribute_group **attr_groups;
	const struct attribute_group **attr_update;
	const char *name;
	int type;
	int capabilities;
	unsigned int scope;
	int *pmu_disable_count;
	struct perf_cpu_pmu_context *cpu_pmu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu *);
	void (*pmu_disable)(struct pmu *);
	int (*event_init)(struct perf_event *);
	void (*event_mapped)(struct perf_event *, struct mm_struct *);
	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
	int (*add)(struct perf_event *, int);
	void (*del)(struct perf_event *, int);
	void (*start)(struct perf_event *, int);
	void (*stop)(struct perf_event *, int);
	void (*read)(struct perf_event *);
	void (*start_txn)(struct pmu *, unsigned int);
	int (*commit_txn)(struct pmu *);
	void (*cancel_txn)(struct pmu *);
	int (*event_idx)(struct perf_event *);
	void (*sched_task)(struct perf_event_pmu_context *, struct task_struct *, bool);
	struct kmem_cache *task_ctx_cache;
	void (*swap_task_ctx)(struct perf_event_pmu_context *, struct perf_event_pmu_context *);
	void * (*setup_aux)(struct perf_event *, void **, int, bool);
	void (*free_aux)(void *);
	long int (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, long unsigned int);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event *);
	int (*aux_output_match)(struct perf_event *);
	bool (*filter)(struct pmu *, int);
	int (*check_period)(struct perf_event *, u64);
};

struct amd_uncore_pmu {
	char name[16];
	int num_counters;
	int rdpmc_base;
	u32 msr_base;
	int group;
	cpumask_t active_mask;
	struct pmu pmu;
	struct amd_uncore_ctx **ctx;
};

struct aml_resource_small_header {
	u8 descriptor_type;
};

struct aml_resource_large_header {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_irq {
	u8 descriptor_type;
	u16 irq_mask;
	u8 flags;
} __attribute__((packed));

struct aml_resource_dma {
	u8 descriptor_type;
	u8 dma_channel_mask;
	u8 flags;
};

struct aml_resource_start_dependent {
	u8 descriptor_type;
	u8 flags;
};

struct aml_resource_end_dependent {
	u8 descriptor_type;
};

struct aml_resource_io {
	u8 descriptor_type;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u8 alignment;
	u8 address_length;
};

struct aml_resource_fixed_io {
	u8 descriptor_type;
	u16 address;
	u8 address_length;
} __attribute__((packed));

struct aml_resource_fixed_dma {
	u8 descriptor_type;
	u16 request_lines;
	u16 channels;
	u8 width;
} __attribute__((packed));

struct aml_resource_vendor_small {
	u8 descriptor_type;
};

struct aml_resource_end_tag {
	u8 descriptor_type;
	u8 checksum;
};

struct aml_resource_memory24 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u16 minimum;
	u16 maximum;
	u16 alignment;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_generic_register {
	u8 descriptor_type;
	u16 resource_length;
	u8 address_space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_size;
	u64 address;
} __attribute__((packed));

struct aml_resource_vendor_large {
	u8 descriptor_type;
	u16 resource_length;
} __attribute__((packed));

struct aml_resource_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 minimum;
	u32 maximum;
	u32 alignment;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_fixed_memory32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u32 address;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address16 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u16 granularity;
	u16 minimum;
	u16 maximum;
	u16 translation_offset;
	u16 address_length;
} __attribute__((packed));

struct aml_resource_address32 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u32 granularity;
	u32 minimum;
	u32 maximum;
	u32 translation_offset;
	u32 address_length;
} __attribute__((packed));

struct aml_resource_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
} __attribute__((packed));

struct aml_resource_extended_address64 {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
	u8 revision_ID;
	u8 reserved;
	u64 granularity;
	u64 minimum;
	u64 maximum;
	u64 translation_offset;
	u64 address_length;
	u64 type_specific;
} __attribute__((packed));

struct aml_resource_extended_irq {
	u8 descriptor_type;
	u16 resource_length;
	u8 flags;
	u8 interrupt_count;
	union {
		u32 interrupt;
		struct {
			struct {} __Empty_interrupts;
			u32 interrupts[0];
		};
	};
} __attribute__((packed));

struct aml_resource_gpio {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 connection_type;
	u16 flags;
	u16 int_flags;
	u8 pin_config;
	u16 drive_strength;
	u16 debounce_timeout;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_i2c_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u16 slave_address;
} __attribute__((packed));

struct aml_resource_spi_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 connection_speed;
	u8 data_bit_length;
	u8 clock_phase;
	u8 clock_polarity;
	u16 device_selection;
} __attribute__((packed));

struct aml_resource_uart_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
	u32 default_baud_rate;
	u16 rx_fifo_size;
	u16 tx_fifo_size;
	u8 parity;
	u8 lines_enabled;
} __attribute__((packed));

struct aml_resource_csi2_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
} __attribute__((packed));

struct aml_resource_common_serialbus {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u8 res_source_index;
	u8 type;
	u8 flags;
	u16 type_specific_flags;
	u8 type_revision_id;
	u16 type_data_length;
} __attribute__((packed));

struct aml_resource_pin_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config;
	u16 function_number;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u16 pin_table_offset;
	u8 res_source_index;
	u16 res_source_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 pin_table_offset;
	u16 label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_function {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 function_number;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_pin_group_config {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u8 pin_config_type;
	u32 pin_config_value;
	u8 res_source_index;
	u16 res_source_offset;
	u16 res_source_label_offset;
	u16 vendor_offset;
	u16 vendor_length;
} __attribute__((packed));

struct aml_resource_clock_input {
	u8 descriptor_type;
	u16 resource_length;
	u8 revision_id;
	u16 flags;
	u16 frequency_divisor;
	u32 frequency_numerator;
} __attribute__((packed));

struct aml_resource_address {
	u8 descriptor_type;
	u16 resource_length;
	u8 resource_type;
	u8 flags;
	u8 specific_flags;
} __attribute__((packed));

union aml_resource {
	u8 descriptor_type;
	struct aml_resource_small_header small_header;
	struct aml_resource_large_header large_header;
	struct aml_resource_irq irq;
	struct aml_resource_dma dma;
	struct aml_resource_start_dependent start_dpf;
	struct aml_resource_end_dependent end_dpf;
	struct aml_resource_io io;
	struct aml_resource_fixed_io fixed_io;
	struct aml_resource_fixed_dma fixed_dma;
	struct aml_resource_vendor_small vendor_small;
	struct aml_resource_end_tag end_tag;
	struct aml_resource_memory24 memory24;
	struct aml_resource_generic_register generic_reg;
	struct aml_resource_vendor_large vendor_large;
	struct aml_resource_memory32 memory32;
	struct aml_resource_fixed_memory32 fixed_memory32;
	struct aml_resource_address16 address16;
	struct aml_resource_address32 address32;
	struct aml_resource_address64 address64;
	struct aml_resource_extended_address64 ext_address64;
	struct aml_resource_extended_irq extended_irq;
	struct aml_resource_gpio gpio;
	struct aml_resource_i2c_serialbus i2c_serial_bus;
	struct aml_resource_spi_serialbus spi_serial_bus;
	struct aml_resource_uart_serialbus uart_serial_bus;
	struct aml_resource_csi2_serialbus csi2_serial_bus;
	struct aml_resource_common_serialbus common_serial_bus;
	struct aml_resource_pin_function pin_function;
	struct aml_resource_pin_config pin_config;
	struct aml_resource_pin_group pin_group;
	struct aml_resource_pin_group_function pin_group_function;
	struct aml_resource_pin_group_config pin_group_config;
	struct aml_resource_clock_input clock_input;
	struct aml_resource_address address;
	u32 dword_item;
	u16 word_item;
	u8 byte_item;
};

struct analog_param_field {
	unsigned int even;
	unsigned int odd;
};

struct analog_param_range {
	unsigned int min;
	unsigned int typ;
	unsigned int max;
};

struct analog_parameters {
	unsigned int num_lines;
	unsigned int line_duration_ns;
	struct analog_param_range hact_ns;
	struct analog_param_range hfp_ns;
	struct analog_param_range hslen_ns;
	struct analog_param_range hbp_ns;
	struct analog_param_range hblk_ns;
	unsigned int bt601_hfp;
	struct analog_param_field vfp_lines;
	struct analog_param_field vslen_lines;
	struct analog_param_field vbp_lines;
};

struct kobj_uevent_env;

struct kobj_ns_type_operations;

struct class {
	const char *name;
	const struct attribute_group **class_groups;
	const struct attribute_group **dev_groups;
	int (*dev_uevent)(const struct device *, struct kobj_uevent_env *);
	char * (*devnode)(const struct device *, umode_t *);
	void (*class_release)(const struct class *);
	void (*dev_release)(struct device *);
	int (*shutdown_pre)(struct device *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(const struct device *);
	void (*get_ownership)(const struct device *, kuid_t *, kgid_t *);
	const struct dev_pm_ops *pm;
};

struct transport_container;

struct transport_class {
	struct class class;
	int (*setup)(struct transport_container *, struct device *, struct device *);
	int (*configure)(struct transport_container *, struct device *, struct device *);
	int (*remove)(struct transport_container *, struct device *, struct device *);
};

struct klist_node;

struct klist {
	spinlock_t k_lock;
	struct list_head k_list;
	void (*get)(struct klist_node *);
	void (*put)(struct klist_node *);
};

struct attribute_container {
	struct list_head node;
	struct klist containers;
	struct class *class;
	const struct attribute_group *grp;
	struct device_attribute **attrs;
	int (*match)(struct attribute_container *, struct device *);
	long unsigned int flags;
};

struct anon_transport_class {
	struct transport_class tclass;
	struct attribute_container container;
};

struct anon_vma {
	struct anon_vma *root;
	struct rw_semaphore rwsem;
	atomic_t refcount;
	long unsigned int num_children;
	long unsigned int num_active_vmas;
	struct anon_vma *parent;
	struct rb_root_cached rb_root;
};

struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct rb_node rb;
	long unsigned int rb_subtree_last;
};

struct anon_vma_name {
	struct kref kref;
	char name[0];
};

struct apd_private_data;

struct apd_device_desc {
	unsigned int fixed_clk_rate;
	struct property_entry *properties;
	int (*setup)(struct apd_private_data *);
};

struct clk;

struct apd_private_data {
	struct clk *clk;
	struct acpi_device *adev;
	const struct apd_device_desc *dev_desc;
};

struct aper_size_info_16 {
	int size;
	int num_entries;
	int page_order;
	u16 size_value;
};

struct aper_size_info_32 {
	int size;
	int num_entries;
	int page_order;
	u32 size_value;
};

struct aper_size_info_8 {
	int size;
	int num_entries;
	int page_order;
	u8 size_value;
};

struct aper_size_info_fixed {
	int size;
	int num_entries;
	int page_order;
};

struct aper_size_info_lvl2 {
	int size;
	int num_entries;
	u32 size_value;
};

struct aperfmperf {
	seqcount_t seq;
	long unsigned int last_update;
	u64 acnt;
	u64 mcnt;
	u64 aperf;
	u64 mperf;
};

struct aperture_range {
	struct device *dev;
	resource_size_t base;
	resource_size_t size;
	struct list_head lh;
	void (*detach)(struct device *);
};

struct apic {
	void (*eoi)(void);
	void (*native_eoi)(void);
	void (*write)(u32, u32);
	u32 (*read)(u32);
	void (*wait_icr_idle)(void);
	u32 (*safe_wait_icr_idle)(void);
	void (*send_IPI)(int, int);
	void (*send_IPI_mask)(const struct cpumask *, int);
	void (*send_IPI_mask_allbutself)(const struct cpumask *, int);
	void (*send_IPI_allbutself)(int);
	void (*send_IPI_all)(int);
	void (*send_IPI_self)(int);
	u32 disable_esr: 1;
	u32 dest_mode_logical: 1;
	u32 x2apic_set_max_apicid: 1;
	u32 nmi_to_offline_cpu: 1;
	u32 (*calc_dest_apicid)(unsigned int);
	u64 (*icr_read)(void);
	void (*icr_write)(u32, u32);
	u32 max_apic_id;
	int (*probe)(void);
	int (*acpi_madt_oem_check)(char *, char *);
	void (*init_apic_ldr)(void);
	u32 (*cpu_present_to_apicid)(int);
	u32 (*get_apic_id)(u32);
	int (*wakeup_secondary_cpu)(u32, long unsigned int);
	int (*wakeup_secondary_cpu_64)(u32, long unsigned int);
	char *name;
};

struct irq_cfg {
	unsigned int dest_apicid;
	unsigned int vector;
};

struct apic_chip_data {
	struct irq_cfg hw_irq_cfg;
	unsigned int vector;
	unsigned int prev_vector;
	unsigned int cpu;
	unsigned int prev_cpu;
	unsigned int irq;
	struct hlist_node clist;
	unsigned int move_in_progress: 1;
	unsigned int is_managed: 1;
	unsigned int can_reserve: 1;
	unsigned int has_reserved: 1;
};

union apic_ir {
	long unsigned int map[4];
	u32 regs[8];
};

struct apic_override {
	void (*eoi)(void);
	void (*native_eoi)(void);
	void (*write)(u32, u32);
	u32 (*read)(u32);
	void (*send_IPI)(int, int);
	void (*send_IPI_mask)(const struct cpumask *, int);
	void (*send_IPI_mask_allbutself)(const struct cpumask *, int);
	void (*send_IPI_allbutself)(int);
	void (*send_IPI_all)(int);
	void (*send_IPI_self)(int);
	u64 (*icr_read)(void);
	void (*icr_write)(u32, u32);
	int (*wakeup_secondary_cpu)(u32, long unsigned int);
	int (*wakeup_secondary_cpu_64)(u32, long unsigned int);
};

struct apm_bios_info {
	__u16 version;
	__u16 cseg;
	__u32 offset;
	__u16 cseg_16;
	__u16 dseg;
	__u16 flags;
	__u16 cseg_len;
	__u16 cseg_16_len;
	__u16 dseg_len;
};

struct workqueue_attrs;

struct pool_workqueue;

struct apply_wqattrs_ctx {
	struct workqueue_struct *wq;
	struct workqueue_attrs *attrs;
	struct list_head list;
	struct pool_workqueue *dfl_pwq;
	struct pool_workqueue *pwq_tbl[0];
};

struct arch_elf_state {};

struct arch_hw_breakpoint {
	long unsigned int address;
	long unsigned int mask;
	u8 len;
	u8 type;
};

struct arch_hybrid_cpu_scale {
	long unsigned int capacity;
	long unsigned int freq_ratio;
};

struct arch_io_reserve_memtype_wc_devres {
	resource_size_t start;
	resource_size_t size;
};

struct lbr_entry {
	u64 from;
	u64 to;
	u64 info;
};

struct arch_lbr_state {
	u64 lbr_ctl;
	u64 lbr_depth;
	u64 ler_from;
	u64 ler_to;
	u64 ler_info;
	struct lbr_entry entries[0];
};

struct arch_optimized_insn {
	kprobe_opcode_t copied_insn[4];
	kprobe_opcode_t *insn;
	size_t size;
};

struct kprobe;

struct pt_regs;

struct arch_specific_insn {
	kprobe_opcode_t *insn;
	unsigned int boostable: 1;
	unsigned char size;
	union {
		unsigned char opcode;
		struct {
			unsigned char type;
		} jcc;
		struct {
			unsigned char type;
			unsigned char asize;
		} loop;
		struct {
			unsigned char reg;
		} indirect;
	};
	s32 rel32;
	void (*emulate_op)(struct kprobe *, struct pt_regs *);
	int tp_len;
};

struct arch_tlbflush_unmap_batch {
	struct cpumask cpumask;
};

struct uprobe_xol_ops;

struct arch_uprobe {
	union {
		u8 insn[16];
		u8 ixol[16];
	};
	const struct uprobe_xol_ops *ops;
	union {
		struct {
			s32 offs;
			u8 ilen;
			u8 opc1;
		} branch;
		struct {
			u8 fixups;
			u8 ilen;
		} defparam;
		struct {
			u8 reg_offset;
			u8 ilen;
		} push;
	};
};

struct arch_uprobe_task {
	long unsigned int saved_scratch_register;
	unsigned int saved_trap_nr;
	unsigned int saved_tf;
};

struct arch_vdso_time_data {};

struct arg_dev_net_ip {
	struct net *net;
	struct in6_addr *addr;
};

struct arg_netdev_event {
	const struct net_device *dev;
	union {
		unsigned char nh_flags;
		long unsigned int event;
	};
};

struct args_askumount {
	__u32 may_umount;
};

struct args_expire {
	__u32 how;
};

struct args_fail {
	__u32 token;
	__s32 status;
};

struct args_in {
	__u32 type;
};

struct args_out {
	__u32 devid;
	__u32 magic;
};

struct args_ismountpoint {
	union {
		struct args_in in;
		struct args_out out;
	};
};

struct args_openmount {
	__u32 devid;
};

struct args_protosubver {
	__u32 sub_version;
};

struct args_protover {
	__u32 version;
};

struct args_ready {
	__u32 token;
};

struct args_requester {
	__u32 uid;
	__u32 gid;
};

struct args_setpipefd {
	__s32 pipefd;
};

struct args_timeout {
	__u64 timeout;
};

struct arp_eth_header {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
	unsigned char ar_sha[6];
	unsigned char ar_sip[4];
	unsigned char ar_tha[6];
	unsigned char ar_tip[4];
};

struct arphdr {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
};

struct arppayload {
	unsigned char mac_src[6];
	unsigned char ip_src[4];
	unsigned char mac_dst[6];
	unsigned char ip_dst[4];
};

struct sockaddr {
	sa_family_t sa_family;
	union {
		char sa_data_min[14];
		struct {
			struct {} __empty_sa_data;
			char sa_data[0];
		};
	};
};

struct arpreq {
	struct sockaddr arp_pa;
	struct sockaddr arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
};

struct in_addr {
	__be32 s_addr;
};

struct arpt_devaddr_info {
	char addr[16];
	char mask[16];
};

struct arpt_arp {
	struct in_addr src;
	struct in_addr tgt;
	struct in_addr smsk;
	struct in_addr tmsk;
	__u8 arhln;
	__u8 arhln_mask;
	struct arpt_devaddr_info src_devaddr;
	struct arpt_devaddr_info tgt_devaddr;
	__be16 arpop;
	__be16 arpop_mask;
	__be16 arhrd;
	__be16 arhrd_mask;
	__be16 arpro;
	__be16 arpro_mask;
	char iniface[16];
	char outiface[16];
	unsigned char iniface_mask[16];
	unsigned char outiface_mask[16];
	__u8 flags;
	__u16 invflags;
};

struct xt_counters {
	__u64 pcnt;
	__u64 bcnt;
};

struct arpt_entry {
	struct arpt_arp arp;
	__u16 target_offset;
	__u16 next_offset;
	unsigned int comefrom;
	struct xt_counters counters;
	unsigned char elems[0];
};

struct xt_target;

struct xt_entry_target {
	union {
		struct {
			__u16 target_size;
			char name[29];
			__u8 revision;
		} user;
		struct {
			__u16 target_size;
			struct xt_target *target;
		} kernel;
		__u16 target_size;
	} u;
	unsigned char data[0];
};

struct xt_error_target {
	struct xt_entry_target target;
	char errorname[30];
};

struct arpt_error {
	struct arpt_entry entry;
	struct xt_error_target target;
};

struct arpt_get_entries {
	char name[32];
	unsigned int size;
	struct arpt_entry entrytable[0];
};

struct arpt_getinfo {
	char name[32];
	unsigned int valid_hooks;
	unsigned int hook_entry[3];
	unsigned int underflow[3];
	unsigned int num_entries;
	unsigned int size;
};

struct arpt_mangle {
	char src_devaddr[16];
	char tgt_devaddr[16];
	union {
		struct in_addr src_ip;
	} u_s;
	union {
		struct in_addr tgt_ip;
	} u_t;
	__u8 flags;
	int target;
};

struct arpt_replace {
	char name[32];
	unsigned int valid_hooks;
	unsigned int num_entries;
	unsigned int size;
	unsigned int hook_entry[3];
	unsigned int underflow[3];
	unsigned int num_counters;
	struct xt_counters *counters;
	struct arpt_entry entries[0];
};

struct xt_standard_target {
	struct xt_entry_target target;
	int verdict;
};

struct arpt_standard {
	struct arpt_entry entry;
	struct xt_standard_target target;
};

struct trace_array;

struct trace_buffer;

struct trace_array_cpu;

struct array_buffer {
	struct trace_array *tr;
	struct trace_buffer *buffer;
	struct trace_array_cpu *data;
	u64 time_start;
	int cpu;
};

typedef int (*asn1_action_t)(void *, size_t, unsigned char, const void *, size_t);

struct asn1_decoder {
	const unsigned char *machine;
	size_t machlen;
	const asn1_action_t *actions;
};

struct assoc_array_ptr;

struct assoc_array {
	struct assoc_array_ptr *root;
	long unsigned int nr_leaves_on_tree;
};

struct assoc_array_node;

struct assoc_array_delete_collapse_context {
	struct assoc_array_node *node;
	const void *skip_leaf;
	int slot;
};

struct assoc_array_ops;

struct assoc_array_edit {
	struct callback_head rcu;
	struct assoc_array *array;
	const struct assoc_array_ops *ops;
	const struct assoc_array_ops *ops_for_excised_subtree;
	struct assoc_array_ptr *leaf;
	struct assoc_array_ptr **leaf_p;
	struct assoc_array_ptr *dead_leaf;
	struct assoc_array_ptr *new_meta[3];
	struct assoc_array_ptr *excised_meta[1];
	struct assoc_array_ptr *excised_subtree;
	struct assoc_array_ptr **set_backpointers[16];
	struct assoc_array_ptr *set_backpointers_to;
	struct assoc_array_node *adjust_count_on;
	long int adjust_count_by;
	struct {
		struct assoc_array_ptr **ptr;
		struct assoc_array_ptr *to;
	} set[2];
	struct {
		u8 *p;
		u8 to;
	} set_parent_slot[1];
	u8 segment_cache[17];
};

struct assoc_array_node {
	struct assoc_array_ptr *back_pointer;
	u8 parent_slot;
	struct assoc_array_ptr *slots[16];
	long unsigned int nr_leaves_on_branch;
};

struct assoc_array_ops {
	long unsigned int (*get_key_chunk)(const void *, int);
	long unsigned int (*get_object_key_chunk)(const void *, int);
	bool (*compare_object)(const void *, const void *);
	int (*diff_objects)(const void *, const void *);
	void (*free_object)(void *);
};

struct assoc_array_shortcut {
	struct assoc_array_ptr *back_pointer;
	int parent_slot;
	int skip_to_level;
	struct assoc_array_ptr *next_node;
	long unsigned int index_key[0];
};

struct assoc_array_walk_result {
	struct {
		struct assoc_array_node *node;
		int level;
		int slot;
	} terminal_node;
	struct {
		struct assoc_array_shortcut *shortcut;
		int level;
		int sc_level;
		long unsigned int sc_segments;
		long unsigned int dissimilarity;
	} wrong_shortcut;
};

struct asym_cap_data {
	struct list_head link;
	struct callback_head rcu;
	long unsigned int capacity;
	long unsigned int cpus[0];
};

struct asymmetric_key_id {
	short unsigned int len;
	unsigned char data[0];
};

struct asymmetric_key_ids {
	void *id[3];
};

struct key_preparsed_payload;

struct asymmetric_key_parser {
	struct list_head link;
	struct module *owner;
	const char *name;
	int (*parse)(struct key_preparsed_payload *);
};

struct key;

struct seq_file;

struct kernel_pkey_params;

struct kernel_pkey_query;

struct public_key_signature;

struct asymmetric_key_subtype {
	struct module *owner;
	const char *name;
	short unsigned int name_len;
	void (*describe)(const struct key *, struct seq_file *);
	void (*destroy)(void *, void *);
	int (*query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*verify_signature)(const struct key *, const struct public_key_signature *);
};

struct btrfs_work;

typedef void (*btrfs_func_t)(struct btrfs_work *);

typedef void (*btrfs_ordered_func_t)(struct btrfs_work *, bool);

struct btrfs_workqueue;

struct btrfs_work {
	btrfs_func_t func;
	btrfs_ordered_func_t ordered_func;
	struct work_struct normal_work;
	struct list_head ordered_list;
	struct btrfs_workqueue *wq;
	long unsigned int flags;
};

struct btrfs_inode;

struct cgroup_subsys_state;

struct async_cow;

struct async_chunk {
	struct btrfs_inode *inode;
	struct folio *locked_folio;
	u64 start;
	u64 end;
	blk_opf_t write_flags;
	struct list_head extents;
	struct cgroup_subsys_state *blkcg_css;
	struct btrfs_work work;
	struct async_cow *async_cow;
};

struct async_cow {
	atomic_t num_chunks;
	struct async_chunk chunks[0];
};

struct async_domain {
	struct list_head pending;
	unsigned int registered: 1;
};

typedef void (*async_func_t)(void *, async_cookie_t);

struct async_entry {
	struct list_head domain_list;
	struct list_head global_list;
	struct work_struct work;
	async_cookie_t cookie;
	async_func_t func;
	void *data;
	struct async_domain *domain;
};

struct async_extent {
	u64 start;
	u64 ram_size;
	u64 compressed_size;
	struct folio **folios;
	long unsigned int nr_folios;
	int compress_type;
	struct list_head list;
};

struct io_poll {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	int retries;
	struct wait_queue_entry wait;
};

struct async_poll {
	struct io_poll poll;
	struct io_poll *double_poll;
};

struct async_scan_data {
	struct list_head list;
	struct Scsi_Host *shost;
	struct completion prev_finished;
};

struct nvme_ctrl;

struct async_scan_info {
	struct nvme_ctrl *ctrl;
	atomic_t next_nsid;
	__le32 *ns_list;
};

struct btrfs_device;

struct btrfs_io_context;

struct btrfs_io_stripe {
	struct btrfs_device *dev;
	u64 physical;
	u64 length;
	bool rst_search_commit_root;
	struct btrfs_io_context *bioc;
};

struct btrfs_bio;

struct async_submit_bio {
	struct btrfs_bio *bbio;
	struct btrfs_io_context *bioc;
	struct btrfs_io_stripe smap;
	int mirror_num;
	struct btrfs_work work;
};

struct atalk_netrange {
	__u8 nr_phase;
	__be16 nr_firstnet;
	__be16 nr_lastnet;
};

struct atalk_iface {
	struct net_device *dev;
	struct atalk_addr address;
	int status;
	struct atalk_netrange nets;
	struct atalk_iface *next;
};

struct atalk_route {
	struct net_device *dev;
	struct atalk_addr target;
	struct atalk_addr gateway;
	int flags;
	struct atalk_route *next;
};

struct atalk_sock {
	struct sock sk;
	__be16 dest_net;
	__be16 src_net;
	unsigned char dest_node;
	unsigned char src_node;
	unsigned char dest_port;
	unsigned char src_port;
};

struct ps2dev;

typedef enum ps2_disposition (*ps2_pre_receive_handler_t)(struct ps2dev *, u8, unsigned int);

typedef void (*ps2_receive_handler_t)(struct ps2dev *, u8);

struct serio;

struct ps2dev {
	struct serio *serio;
	struct mutex cmd_mutex;
	wait_queue_head_t wait;
	long unsigned int flags;
	u8 cmdbuf[8];
	u8 cmdcnt;
	u8 nak;
	ps2_pre_receive_handler_t pre_receive_handler;
	ps2_receive_handler_t receive_handler;
};

struct vivaldi_data {
	u32 function_row_physmap[24];
	unsigned int num_function_row_keys;
};

struct atkbd {
	struct ps2dev ps2dev;
	struct input_dev *dev;
	char name[64];
	char phys[32];
	short unsigned int id;
	short unsigned int keycode[512];
	long unsigned int force_release_mask[8];
	unsigned char set;
	bool translated;
	bool extra;
	bool write;
	bool softrepeat;
	bool softraw;
	bool scroll;
	bool enabled;
	unsigned char emul;
	bool resend;
	bool release;
	long unsigned int xl_bit;
	unsigned int last;
	long unsigned int time;
	long unsigned int err_count;
	struct delayed_work event_work;
	long unsigned int event_jiffies;
	long unsigned int event_mask;
	struct mutex mutex;
	struct vivaldi_data vdata;
};

struct atm_aal_stats {
	int tx;
	int tx_err;
	int rx;
	int rx_err;
	int rx_drop;
};

struct br2684_if_spec {
	int method;
	union {
		char ifname[16];
		int devnum;
	} spec;
};

struct atm_backend_br2684 {
	atm_backend_t backend_num;
	struct br2684_if_spec ifspec;
	int fcs_in;
	int fcs_out;
	int fcs_auto;
	int encaps;
	int has_vpiid;
	__u8 vpn_id[7];
	int send_padding;
	int min_size;
};

struct atm_bhli {
	unsigned char hl_type;
	unsigned char hl_length;
	unsigned char hl_info[8];
};

struct atm_blli {
	unsigned char l2_proto;
	union {
		struct {
			unsigned char mode;
			unsigned char window;
		} itu;
		unsigned char user;
	} l2;
	unsigned char l3_proto;
	union {
		struct {
			unsigned char mode;
			unsigned char def_size;
			unsigned char window;
		} itu;
		unsigned char user;
		struct {
			unsigned char term_type;
			unsigned char fw_mpx_cap;
			unsigned char bw_mpx_cap;
		} h310;
		struct {
			unsigned char ipi;
			unsigned char snap[5];
		} tr9577;
	} l3;
};

struct atm_cirange {
	signed char vpi_bits;
	signed char vci_bits;
};

struct k_atm_aal_stats {
	atomic_t tx;
	atomic_t tx_err;
	atomic_t rx;
	atomic_t rx_err;
	atomic_t rx_drop;
};

struct k_atm_dev_stats {
	struct k_atm_aal_stats aal0;
	struct k_atm_aal_stats aal34;
	struct k_atm_aal_stats aal5;
};

struct atmdev_ops;

struct atmphy_ops;

struct atm_dev {
	const struct atmdev_ops *ops;
	const struct atmphy_ops *phy;
	const char *type;
	int number;
	void *dev_data;
	void *phy_data;
	long unsigned int flags;
	struct list_head local;
	struct list_head lecs;
	unsigned char esi[6];
	struct atm_cirange ci_range;
	struct k_atm_dev_stats stats;
	char signal;
	int link_rate;
	refcount_t refcnt;
	spinlock_t lock;
	struct proc_dir_entry *proc_entry;
	char *proc_name;
	struct device class_dev;
	struct list_head dev_list;
};

struct sockaddr_atmsvc {
	short unsigned int sas_family;
	struct {
		unsigned char prv[20];
		char pub[13];
		char lij_type;
		__u32 lij_id;
	} sas_addr;
};

struct atm_dev_addr {
	struct sockaddr_atmsvc addr;
	struct list_head entry;
};

struct atm_dev_stats {
	struct atm_aal_stats aal0;
	struct atm_aal_stats aal34;
	struct atm_aal_stats aal5;
};

struct atm_iobuf {
	int length;
	void *buffer;
};

struct atm_ioctl {
	struct module *owner;
	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
	struct list_head list;
};

struct atm_trafprm {
	unsigned char traffic_class;
	int max_pcr;
	int pcr;
	int min_pcr;
	int max_cdv;
	int max_sdu;
	unsigned int icr;
	unsigned int tbe;
	unsigned int frtt: 24;
	unsigned int rif: 4;
	unsigned int rdf: 4;
	unsigned int nrm_pres: 1;
	unsigned int trm_pres: 1;
	unsigned int adtf_pres: 1;
	unsigned int cdf_pres: 1;
	unsigned int nrm: 3;
	unsigned int trm: 3;
	unsigned int adtf: 10;
	unsigned int cdf: 3;
	unsigned int spare: 9;
};

struct atm_qos {
	struct atm_trafprm txtp;
	struct atm_trafprm rxtp;
	unsigned char aal;
};

struct atm_mpoa_qos {
	struct atm_mpoa_qos *next;
	__be32 ipaddr;
	struct atm_qos qos;
};

struct atm_newif_br2684 {
	atm_backend_t backend_num;
	int media;
	char ifname[16];
	int mtu;
};

struct atm_sap {
	struct atm_bhli bhli;
	struct atm_blli blli[3];
};

struct atm_vcc;

struct atm_skb_data {
	struct atm_vcc *vcc;
	long unsigned int atm_options;
	unsigned int acct_truesize;
} __attribute__((packed));

struct atm_vcc {
	struct sock sk;
	long unsigned int flags;
	short int vpi;
	int vci;
	long unsigned int aal_options;
	long unsigned int atm_options;
	struct atm_dev *dev;
	struct atm_qos qos;
	struct atm_sap sap;
	void (*release_cb)(struct atm_vcc *);
	void (*push)(struct atm_vcc *, struct sk_buff *);
	void (*pop)(struct atm_vcc *, struct sk_buff *);
	int (*push_oam)(struct atm_vcc *, void *);
	int (*send)(struct atm_vcc *, struct sk_buff *);
	void *dev_data;
	void *proto_data;
	struct k_atm_aal_stats *stats;
	struct module *owner;
	short int itf;
	struct sockaddr_atmsvc local;
	struct sockaddr_atmsvc remote;
	struct atm_vcc *session;
	void *user_back;
};

struct atmarp_ctrl {
	enum atmarp_ctrl_type type;
	int itf_num;
	__be32 ip;
};

struct clip_vcc;

struct neighbour;

struct atmarp_entry {
	struct clip_vcc *vccs;
	long unsigned int expires;
	struct neighbour *neigh;
};

struct atmdev_ops {
	void (*dev_close)(struct atm_dev *);
	int (*open)(struct atm_vcc *);
	void (*close)(struct atm_vcc *);
	int (*ioctl)(struct atm_dev *, unsigned int, void *);
	int (*send)(struct atm_vcc *, struct sk_buff *);
	int (*send_bh)(struct atm_vcc *, struct sk_buff *);
	int (*send_oam)(struct atm_vcc *, void *, int);
	void (*phy_put)(struct atm_dev *, unsigned char, long unsigned int);
	unsigned char (*phy_get)(struct atm_dev *, long unsigned int);
	int (*change_qos)(struct atm_vcc *, struct atm_qos *, int);
	int (*proc_read)(struct atm_dev *, loff_t *, char *);
	struct module *owner;
};

struct atmif_sioc {
	int number;
	int length;
	void *arg;
};

struct atmlec_config_msg {
	unsigned int maximum_unknown_frame_count;
	unsigned int max_unknown_frame_time;
	short unsigned int max_retry_count;
	unsigned int aging_time;
	unsigned int forward_delay_time;
	unsigned int arp_response_time;
	unsigned int flush_timeout;
	unsigned int path_switching_delay;
	unsigned int lane_version;
	int mtu;
	int is_proxy;
};

struct atmlec_ioc {
	int dev_num;
	unsigned char atm_addr[20];
	unsigned char receive;
};

struct atmlec_msg {
	atmlec_msg_type type;
	int sizeoftlvs;
	union {
		struct {
			unsigned char mac_addr[6];
			unsigned char atm_addr[20];
			unsigned int flag;
			unsigned int targetless_le_arp;
			unsigned int no_source_le_narp;
		} normal;
		struct atmlec_config_msg config;
		struct {
			__u16 lec_id;
			__u32 tran_id;
			unsigned char mac_addr[6];
			unsigned char atm_addr[20];
		} proxy;
	} content;
};

struct atmmpc_ioc {
	int dev_num;
	__be32 ipaddr;
	int type;
};

struct atmphy_ops {
	int (*start)(struct atm_dev *);
	int (*ioctl)(struct atm_dev *, unsigned int, void *);
	void (*interrupt)(struct atm_dev *);
	int (*stop)(struct atm_dev *);
};

struct sockaddr_atmpvc {
	short unsigned int sap_family;
	struct {
		short int itf;
		short int vpi;
		int vci;
	} sap_addr;
};

struct atmsvc_msg {
	enum atmsvc_msg_type type;
	atm_kptr_t vcc;
	atm_kptr_t listen_vcc;
	int reply;
	struct sockaddr_atmpvc pvc;
	struct sockaddr_atmsvc local;
	struct atm_qos qos;
	struct atm_sap sap;
	unsigned int session;
	struct sockaddr_atmsvc svc;
};

struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block *head;
};

struct attribute_group {
	const char *name;
	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject *, const struct bin_attribute *, int);
	size_t (*bin_size)(struct kobject *, const struct bin_attribute *, int);
	struct attribute **attrs;
	union {
		struct bin_attribute **bin_attrs;
		const struct bin_attribute * const *bin_attrs_new;
	};
};

struct aud_ts_cdclk_m_n {
	u8 m;
	u16 n;
};

struct audit_aux_data {
	struct audit_aux_data *next;
	int type;
};

struct audit_cap_data {
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	union {
		unsigned int fE;
		kernel_cap_t effective;
	};
	kernel_cap_t ambient;
	kuid_t rootid;
};

struct audit_aux_data_bprm_fcaps {
	struct audit_aux_data d;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	struct audit_cap_data old_pcap;
	struct audit_cap_data new_pcap;
};

struct lsm_prop_selinux {};

struct lsm_prop_smack {};

struct lsm_prop_apparmor {};

struct lsm_prop_bpf {
	u32 secid;
};

struct lsm_prop {
	struct lsm_prop_selinux selinux;
	struct lsm_prop_smack smack;
	struct lsm_prop_apparmor apparmor;
	struct lsm_prop_bpf bpf;
};

struct audit_aux_data_pids {
	struct audit_aux_data d;
	pid_t target_pid[16];
	kuid_t target_auid[16];
	kuid_t target_uid[16];
	unsigned int target_sessionid[16];
	struct lsm_prop target_ref[16];
	char target_comm[256];
	int pid_count;
};

struct audit_context;

struct audit_buffer {
	struct sk_buff *skb;
	struct audit_context *ctx;
	gfp_t gfp_mask;
};

struct audit_tree;

struct audit_node {
	struct list_head list;
	struct audit_tree *owner;
	unsigned int index;
};

struct fsnotify_mark;

struct audit_chunk {
	struct list_head hash;
	long unsigned int key;
	struct fsnotify_mark *mark;
	struct list_head trees;
	int count;
	atomic_long_t refs;
	struct callback_head head;
	struct audit_node owners[0];
};

struct timespec64 {
	time64_t tv_sec;
	long int tv_nsec;
};

struct filename;

struct audit_names {
	struct list_head list;
	struct filename *name;
	int name_len;
	bool hidden;
	long unsigned int ino;
	dev_t dev;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	struct lsm_prop oprop;
	struct audit_cap_data fcap;
	unsigned int fcap_ver;
	unsigned char type;
	bool should_free;
};

struct vfsmount;

struct path {
	struct vfsmount *mnt;
	struct dentry *dentry;
};

struct mq_attr {
	__kernel_long_t mq_flags;
	__kernel_long_t mq_maxmsg;
	__kernel_long_t mq_msgsize;
	__kernel_long_t mq_curmsgs;
	__kernel_long_t __reserved[4];
};

struct open_how {
	__u64 flags;
	__u64 mode;
	__u64 resolve;
};

struct audit_ntp_val {
	long long int oldval;
	long long int newval;
};

struct audit_ntp_data {
	struct audit_ntp_val vals[6];
};

struct audit_proctitle {
	int len;
	char *value;
};

struct audit_tree_refs;

struct audit_context {
	int dummy;
	enum {
		AUDIT_CTX_UNUSED = 0,
		AUDIT_CTX_SYSCALL = 1,
		AUDIT_CTX_URING = 2,
	} context;
	enum audit_state state;
	enum audit_state current_state;
	unsigned int serial;
	int major;
	int uring_op;
	struct timespec64 ctime;
	long unsigned int argv[4];
	long int return_code;
	u64 prio;
	int return_valid;
	struct audit_names preallocated_names[5];
	int name_count;
	struct list_head names_list;
	char *filterkey;
	struct path pwd;
	struct audit_aux_data *aux;
	struct audit_aux_data *aux_pids;
	struct __kernel_sockaddr_storage *sockaddr;
	size_t sockaddr_len;
	pid_t ppid;
	kuid_t uid;
	kuid_t euid;
	kuid_t suid;
	kuid_t fsuid;
	kgid_t gid;
	kgid_t egid;
	kgid_t sgid;
	kgid_t fsgid;
	long unsigned int personality;
	int arch;
	pid_t target_pid;
	kuid_t target_auid;
	kuid_t target_uid;
	unsigned int target_sessionid;
	struct lsm_prop target_ref;
	char target_comm[16];
	struct audit_tree_refs *trees;
	struct audit_tree_refs *first_trees;
	struct list_head killed_trees;
	int tree_count;
	int type;
	union {
		struct {
			int nargs;
			long int args[6];
		} socketcall;
		struct {
			kuid_t uid;
			kgid_t gid;
			umode_t mode;
			struct lsm_prop oprop;
			int has_perm;
			uid_t perm_uid;
			gid_t perm_gid;
			umode_t perm_mode;
			long unsigned int qbytes;
		} ipc;
		struct {
			mqd_t mqdes;
			struct mq_attr mqstat;
		} mq_getsetattr;
		struct {
			mqd_t mqdes;
			int sigev_signo;
		} mq_notify;
		struct {
			mqd_t mqdes;
			size_t msg_len;
			unsigned int msg_prio;
			struct timespec64 abs_timeout;
		} mq_sendrecv;
		struct {
			int oflag;
			umode_t mode;
			struct mq_attr attr;
		} mq_open;
		struct {
			pid_t pid;
			struct audit_cap_data cap;
		} capset;
		struct {
			int fd;
			int flags;
		} mmap;
		struct open_how openat2;
		struct {
			int argc;
		} execve;
		struct {
			char *name;
		} module;
		struct {
			struct audit_ntp_data ntp_data;
			struct timespec64 tk_injoffset;
		} time;
	};
	int fds[2];
	struct audit_proctitle proctitle;
};

struct audit_ctl_mutex {
	struct mutex lock;
	void *owner;
};

struct audit_field;

struct audit_watch;

struct audit_fsnotify_mark;

struct audit_krule {
	u32 pflags;
	u32 flags;
	u32 listnr;
	u32 action;
	u32 mask[64];
	u32 buflen;
	u32 field_count;
	char *filterkey;
	struct audit_field *fields;
	struct audit_field *arch_f;
	struct audit_field *inode_f;
	struct audit_watch *watch;
	struct audit_tree *tree;
	struct audit_fsnotify_mark *exe;
	struct list_head rlist;
	struct list_head list;
	u64 prio;
};

struct audit_entry {
	struct list_head list;
	struct callback_head rcu;
	struct audit_krule rule;
};

struct audit_features {
	__u32 vers;
	__u32 mask;
	__u32 features;
	__u32 lock;
};

struct audit_field {
	u32 type;
	union {
		u32 val;
		kuid_t uid;
		kgid_t gid;
		struct {
			char *lsm_str;
			void *lsm_rule;
		};
	};
	u32 op;
};

struct fsnotify_group;

struct fsnotify_mark_connector;

struct fsnotify_mark {
	__u32 mask;
	refcount_t refcnt;
	struct fsnotify_group *group;
	struct list_head g_list;
	spinlock_t lock;
	struct hlist_node obj_list;
	struct fsnotify_mark_connector *connector;
	__u32 ignore_mask;
	unsigned int flags;
};

struct audit_fsnotify_mark {
	dev_t dev;
	long unsigned int ino;
	char *path;
	struct fsnotify_mark mark;
	struct audit_krule *rule;
};

struct audit_net {
	struct sock *sk;
};

struct audit_netlink_list {
	__u32 portid;
	struct net *net;
	struct sk_buff_head q;
};

struct audit_nfcfgop_tab {
	enum audit_nfcfgop op;
	const char *s;
};

struct audit_parent {
	struct list_head watches;
	struct fsnotify_mark mark;
};

struct audit_reply {
	__u32 portid;
	struct net *net;
	struct sk_buff *skb;
};

struct audit_rule_data {
	__u32 flags;
	__u32 action;
	__u32 field_count;
	__u32 mask[64];
	__u32 fields[64];
	__u32 values[64];
	__u32 fieldflags[64];
	__u32 buflen;
	char buf[0];
};

struct audit_sig_info {
	uid_t uid;
	pid_t pid;
	char ctx[0];
};

struct audit_status {
	__u32 mask;
	__u32 enabled;
	__u32 failure;
	__u32 pid;
	__u32 rate_limit;
	__u32 backlog_limit;
	__u32 lost;
	__u32 backlog;
	union {
		__u32 version;
		__u32 feature_bitmap;
	};
	__u32 backlog_wait_time;
	__u32 backlog_wait_time_actual;
};

struct audit_tree {
	refcount_t count;
	int goner;
	struct audit_chunk *root;
	struct list_head chunks;
	struct list_head rules;
	struct list_head list;
	struct list_head same_root;
	struct callback_head head;
	char pathname[0];
};

struct audit_tree_mark {
	struct fsnotify_mark mark;
	struct audit_chunk *chunk;
};

struct audit_tree_refs {
	struct audit_tree_refs *next;
	struct audit_chunk *c[31];
};

struct audit_tty_status {
	__u32 enabled;
	__u32 log_passwd;
};

struct audit_watch {
	refcount_t count;
	dev_t dev;
	char *path;
	long unsigned int ino;
	struct audit_parent *parent;
	struct list_head wlist;
	struct list_head rules;
};

struct auditd_connection {
	struct pid *pid;
	u32 portid;
	struct net *net;
	struct callback_head rcu;
};

struct auth_cred {
	const struct cred *cred;
	const char *principal;
};

struct auth_ops;

struct auth_domain {
	struct kref ref;
	struct hlist_node hash;
	char *name;
	struct auth_ops *flavour;
	struct callback_head callback_head;
};

struct svc_rqst;

struct auth_ops {
	char *name;
	struct module *owner;
	int flavour;
	enum svc_auth_status (*accept)(struct svc_rqst *);
	int (*release)(struct svc_rqst *);
	void (*domain_release)(struct auth_domain *);
	enum svc_auth_status (*set_client)(struct svc_rqst *);
	rpc_authflavor_t (*pseudoflavor)(struct svc_rqst *);
};

struct crypto_spawn {
	struct list_head list;
	struct crypto_alg *alg;
	union {
		struct crypto_instance *inst;
		struct crypto_spawn *next;
	};
	const struct crypto_type *frontend;
	u32 mask;
	bool dead;
	bool registered;
};

struct crypto_ahash_spawn {
	struct crypto_spawn base;
};

struct crypto_skcipher_spawn {
	struct crypto_spawn base;
};

struct authenc_esn_instance_ctx {
	struct crypto_ahash_spawn auth;
	struct crypto_skcipher_spawn enc;
};

struct authenc_esn_request_ctx {
	struct scatterlist src[2];
	struct scatterlist dst[2];
	char tail[0];
};

struct authenc_instance_ctx {
	struct crypto_ahash_spawn auth;
	struct crypto_skcipher_spawn enc;
	unsigned int reqoff;
};

struct authenc_request_ctx {
	struct scatterlist src[2];
	struct scatterlist dst[2];
	char tail[0];
};

struct i915_active {
	atomic_t count;
	struct mutex mutex;
	spinlock_t tree_lock;
	struct active_node *cache;
	struct rb_root tree;
	struct i915_active_fence excl;
	long unsigned int flags;
	int (*active)(struct i915_active *);
	void (*retire)(struct i915_active *);
	struct work_struct work;
	struct llist_head preallocated_barriers;
};

struct auto_active {
	struct i915_active base;
	struct kref ref;
};

struct auto_mode_param {
	int qp_type;
};

struct auto_movable_group_stats {
	long unsigned int movable_pages;
	long unsigned int req_kernel_early_pages;
};

struct auto_movable_stats {
	long unsigned int kernel_early_pages;
	long unsigned int movable_pages;
};

struct autofs_dev_ioctl {
	__u32 ver_major;
	__u32 ver_minor;
	__u32 size;
	__s32 ioctlfd;
	union {
		struct args_protover protover;
		struct args_protosubver protosubver;
		struct args_openmount openmount;
		struct args_ready ready;
		struct args_fail fail;
		struct args_setpipefd setpipefd;
		struct args_timeout timeout;
		struct args_requester requester;
		struct args_expire expire;
		struct args_askumount askumount;
		struct args_ismountpoint ismountpoint;
	};
	char path[0];
};

struct autofs_fs_context {
	kuid_t uid;
	kgid_t gid;
	int pgrp;
	bool pgrp_set;
};

struct autofs_sb_info;

struct autofs_info {
	struct dentry *dentry;
	int flags;
	struct completion expire_complete;
	struct list_head active;
	struct list_head expiring;
	struct autofs_sb_info *sbi;
	long unsigned int exp_timeout;
	long unsigned int last_used;
	int count;
	kuid_t uid;
	kgid_t gid;
	struct callback_head rcu;
};

struct autofs_packet_hdr {
	int proto_version;
	int type;
};

struct autofs_packet_expire {
	struct autofs_packet_hdr hdr;
	int len;
	char name[256];
};

struct autofs_packet_expire_multi {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

struct autofs_packet_missing {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

union autofs_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_packet_missing missing;
	struct autofs_packet_expire expire;
	struct autofs_packet_expire_multi expire_multi;
};

struct super_block;

struct autofs_wait_queue;

struct autofs_sb_info {
	u32 magic;
	int pipefd;
	struct file *pipe;
	struct pid *oz_pgrp;
	int version;
	int sub_version;
	int min_proto;
	int max_proto;
	unsigned int flags;
	long unsigned int exp_timeout;
	unsigned int type;
	struct super_block *sb;
	struct mutex wq_mutex;
	struct mutex pipe_mutex;
	spinlock_t fs_lock;
	struct autofs_wait_queue *queues;
	spinlock_t lookup_lock;
	struct list_head active_list;
	struct list_head expiring_list;
	struct callback_head rcu;
};

struct autofs_v5_packet {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	__u32 dev;
	__u64 ino;
	__u32 uid;
	__u32 gid;
	__u32 pid;
	__u32 tgid;
	__u32 len;
	char name[256];
};

typedef struct autofs_v5_packet autofs_packet_expire_direct_t;

typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;

typedef struct autofs_v5_packet autofs_packet_missing_direct_t;

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;

union autofs_v5_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_v5_packet v5_packet;
	autofs_packet_missing_indirect_t missing_indirect;
	autofs_packet_expire_indirect_t expire_indirect;
	autofs_packet_missing_direct_t missing_direct;
	autofs_packet_expire_direct_t expire_direct;
};

struct qstr {
	union {
		struct {
			u32 hash;
			u32 len;
		};
		u64 hash_len;
	};
	const unsigned char *name;
};

struct autofs_wait_queue {
	wait_queue_head_t queue;
	struct autofs_wait_queue *next;
	autofs_wqt_t wait_queue_token;
	struct qstr name;
	u32 offset;
	u32 dev;
	u64 ino;
	kuid_t uid;
	kgid_t gid;
	pid_t pid;
	pid_t tgid;
	int status;
	unsigned int wait_ctr;
};

struct auxiliary_device {
	struct device dev;
	const char *name;
	u32 id;
	struct {
		struct xarray irqs;
		struct mutex lock;
		bool irq_dir_exists;
	} sysfs;
};

struct auxiliary_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct auxiliary_driver {
	int (*probe)(struct auxiliary_device *, const struct auxiliary_device_id *);
	void (*remove)(struct auxiliary_device *);
	void (*shutdown)(struct auxiliary_device *);
	int (*suspend)(struct auxiliary_device *, pm_message_t);
	int (*resume)(struct auxiliary_device *);
	const char *name;
	struct device_driver driver;
	const struct auxiliary_device_id *id_table;
};

struct auxiliary_irq_info {
	struct device_attribute sysfs_attr;
	char name[11];
};

struct backing_aio {
	struct kiocb iocb;
	refcount_t ref;
	struct kiocb *orig_iocb;
	void (*end_write)(struct kiocb *, ssize_t);
	struct work_struct work;
	long int res;
};

struct percpu_counter {
	raw_spinlock_t lock;
	s64 count;
	struct list_head list;
	s32 *counters;
};

struct fprop_local_percpu {
	struct percpu_counter events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct percpu_ref_data;

struct percpu_ref {
	long unsigned int percpu_count_ptr;
	struct percpu_ref_data *data;
};

struct backing_dev_info;

struct bdi_writeback {
	struct backing_dev_info *bdi;
	long unsigned int state;
	long unsigned int last_old_flush;
	struct list_head b_dirty;
	struct list_head b_io;
	struct list_head b_more_io;
	struct list_head b_dirty_time;
	spinlock_t list_lock;
	atomic_t writeback_inodes;
	struct percpu_counter stat[4];
	long unsigned int bw_time_stamp;
	long unsigned int dirtied_stamp;
	long unsigned int written_stamp;
	long unsigned int write_bandwidth;
	long unsigned int avg_write_bandwidth;
	long unsigned int dirty_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	struct fprop_local_percpu completions;
	int dirty_exceeded;
	enum wb_reason start_all_reason;
	spinlock_t work_lock;
	struct list_head work_list;
	struct delayed_work dwork;
	struct delayed_work bw_dwork;
	struct list_head bdi_node;
	struct percpu_ref refcnt;
	struct fprop_local_percpu memcg_completions;
	struct cgroup_subsys_state *memcg_css;
	struct cgroup_subsys_state *blkcg_css;
	struct list_head memcg_node;
	struct list_head blkcg_node;
	struct list_head b_attached;
	struct list_head offline_node;
	union {
		struct work_struct release_work;
		struct callback_head rcu;
	};
};

struct backing_dev_info {
	u64 id;
	struct rb_node rb_node;
	struct list_head bdi_list;
	long unsigned int ra_pages;
	long unsigned int io_pages;
	struct kref refcnt;
	unsigned int capabilities;
	unsigned int min_ratio;
	unsigned int max_ratio;
	unsigned int max_prop_frac;
	atomic_long_t tot_write_bandwidth;
	long unsigned int last_bdp_sleep;
	struct bdi_writeback wb;
	struct list_head wb_list;
	struct xarray cgwb_tree;
	struct mutex cgwb_release_mutex;
	struct rw_semaphore wb_switch_rwsem;
	wait_queue_head_t wb_waitq;
	struct device *dev;
	char dev_name[64];
	struct device *owner;
	struct timer_list laptop_mode_wb_timer;
	struct dentry *debug_dir;
};

struct file_ra_state {
	long unsigned int start;
	unsigned int size;
	unsigned int async_size;
	unsigned int ra_pages;
	unsigned int mmap_miss;
	loff_t prev_pos;
};

struct file_operations;

struct fown_struct;

struct file {
	file_ref_t f_ref;
	spinlock_t f_lock;
	fmode_t f_mode;
	const struct file_operations *f_op;
	struct address_space *f_mapping;
	void *private_data;
	struct inode *f_inode;
	unsigned int f_flags;
	unsigned int f_iocb_flags;
	const struct cred *f_cred;
	struct path f_path;
	union {
		struct mutex f_pos_lock;
		u64 f_pipe;
	};
	loff_t f_pos;
	void *f_security;
	struct fown_struct *f_owner;
	errseq_t f_wb_err;
	errseq_t f_sb_err;
	struct hlist_head *f_ep;
	union {
		struct callback_head f_task_work;
		struct llist_node f_llist;
		struct file_ra_state f_ra;
		freeptr_t f_freeptr;
	};
};

struct backing_file {
	struct file file;
	union {
		struct path user_path;
		freeptr_t bf_freeptr;
	};
};

struct backing_file_ctx {
	const struct cred *cred;
	void (*accessed)(struct file *);
	void (*end_write)(struct kiocb *, ssize_t);
};

struct backlight_properties {
	int brightness;
	int max_brightness;
	int power;
	enum backlight_type type;
	unsigned int state;
	enum backlight_scale scale;
};

struct backlight_ops;

struct backlight_device {
	struct backlight_properties props;
	struct mutex update_lock;
	struct mutex ops_lock;
	const struct backlight_ops *ops;
	struct notifier_block fb_notif;
	struct list_head entry;
	struct device dev;
	bool fb_bl_on[32];
	int use_count;
};

struct backlight_ops {
	unsigned int options;
	int (*update_status)(struct backlight_device *);
	int (*get_brightness)(struct backlight_device *);
	bool (*controls_device)(struct backlight_device *, struct device *);
};

struct btrfs_lru_cache_entry {
	struct list_head lru_list;
	u64 key;
	u64 gen;
	struct list_head list;
};

struct backref_cache_entry {
	struct btrfs_lru_cache_entry entry;
	u64 root_ids[17];
	int num_roots;
};

struct send_ctx;

struct backref_ctx {
	struct send_ctx *sctx;
	u64 found;
	u64 cur_objectid;
	u64 cur_offset;
	u64 extent_len;
	u64 bytenr;
	u64 backref_owner;
	u64 backref_offset;
};

struct bpf_verifier_env;

struct backtrack_state {
	struct bpf_verifier_env *env;
	u32 frame;
	u32 reg_masks[8];
	u64 stack_masks[8];
};

struct badblocks {
	struct device *dev;
	int count;
	int unacked_exist;
	int shift;
	u64 *page;
	int changed;
	seqlock_t lock;
	sector_t sector;
	sector_t size;
};

struct badblocks_context {
	sector_t start;
	sector_t len;
	int ack;
};

struct balance_callback {
	struct balance_callback *next;
	void (*func)(struct rq *);
};

struct tc_action;

struct tcf_exts_miss_cookie_node;

struct tcf_exts {
	__u32 type;
	int nr_actions;
	struct tc_action **actions;
	struct net *net;
	netns_tracker ns_tracker;
	struct tcf_exts_miss_cookie_node *miss_cookie_node;
	int action;
	int police;
};

struct tcf_ematch_tree_hdr {
	__u16 nmatches;
	__u16 progid;
};

struct tcf_ematch;

struct tcf_ematch_tree {
	struct tcf_ematch_tree_hdr hdr;
	struct tcf_ematch *matches;
};

struct tcf_proto;

struct tcf_result {
	union {
		struct {
			long unsigned int class;
			u32 classid;
		};
		const struct tcf_proto *goto_tp;
	};
};

struct tc_basic_pcnt;

struct basic_filter {
	u32 handle;
	struct tcf_exts exts;
	struct tcf_ematch_tree ematches;
	struct tcf_result res;
	struct tcf_proto *tp;
	struct list_head link;
	struct tc_basic_pcnt *pf;
	struct rcu_work rwork;
};

struct idr {
	struct xarray idr_rt;
	unsigned int idr_base;
	unsigned int idr_next;
};

struct basic_head {
	struct list_head flist;
	struct idr handle_idr;
	struct callback_head rcu;
};

struct batadv_priv;

struct batadv_gw_node;

struct batadv_orig_node;

struct netlink_callback;

struct batadv_algo_gw_ops {
	void (*init_sel_class)(struct batadv_priv *);
	u32 sel_class_max;
	struct batadv_gw_node * (*get_best_gw_node)(struct batadv_priv *);
	bool (*is_eligible)(struct batadv_priv *, struct batadv_orig_node *, struct batadv_orig_node *);
	void (*dump)(struct sk_buff *, struct netlink_callback *, struct batadv_priv *);
};

struct batadv_hard_iface;

struct batadv_algo_iface_ops {
	void (*activate)(struct batadv_hard_iface *);
	int (*enable)(struct batadv_hard_iface *);
	void (*enabled)(struct batadv_hard_iface *);
	void (*disable)(struct batadv_hard_iface *);
	void (*update_mac)(struct batadv_hard_iface *);
	void (*primary_set)(struct batadv_hard_iface *);
};

struct batadv_hardif_neigh_node;

struct batadv_neigh_node;

struct batadv_algo_neigh_ops {
	void (*hardif_init)(struct batadv_hardif_neigh_node *);
	int (*cmp)(struct batadv_neigh_node *, struct batadv_hard_iface *, struct batadv_neigh_node *, struct batadv_hard_iface *);
	bool (*is_similar_or_better)(struct batadv_neigh_node *, struct batadv_hard_iface *, struct batadv_neigh_node *, struct batadv_hard_iface *);
	void (*dump)(struct sk_buff *, struct netlink_callback *, struct batadv_priv *, struct batadv_hard_iface *);
};

struct batadv_algo_orig_ops {
	void (*dump)(struct sk_buff *, struct netlink_callback *, struct batadv_priv *, struct batadv_hard_iface *);
};

struct batadv_algo_ops {
	struct hlist_node list;
	char *name;
	struct batadv_algo_iface_ops iface;
	struct batadv_algo_neigh_ops neigh;
	struct batadv_algo_orig_ops orig;
	struct batadv_algo_gw_ops gw;
};

struct batadv_bcast_duplist_entry {
	u8 orig[6];
	__be32 crc;
	long unsigned int entrytime;
};

struct batadv_bcast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 reserved;
	__be32 seqno;
	__u8 orig[6];
} __attribute__((packed));

struct batadv_bla_backbone_gw {
	u8 orig[6];
	short unsigned int vid;
	struct hlist_node hash_entry;
	struct batadv_priv *bat_priv;
	long unsigned int lasttime;
	atomic_t wait_periods;
	atomic_t request_sent;
	u16 crc;
	spinlock_t crc_lock;
	struct work_struct report_work;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_bla_claim {
	u8 addr[6];
	short unsigned int vid;
	struct batadv_bla_backbone_gw *backbone_gw;
	spinlock_t backbone_lock;
	long unsigned int lasttime;
	struct hlist_node hash_entry;
	struct callback_head rcu;
	struct kref refcount;
};

struct batadv_bla_claim_dst {
	__u8 magic[3];
	__u8 type;
	__be16 group;
};

struct batadv_coded_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 first_ttvn;
	__u8 first_source[6];
	__u8 first_orig_dest[6];
	__be32 first_crc;
	__u8 second_ttl;
	__u8 second_ttvn;
	__u8 second_dest[6];
	__u8 second_source[6];
	__u8 second_orig_dest[6];
	__be32 second_crc;
	__be16 coded_len;
} __attribute__((packed));

struct batadv_dat_candidate {
	int type;
	struct batadv_orig_node *orig_node;
};

struct batadv_dat_entry {
	__be32 ip;
	u8 mac_addr[6];
	short unsigned int vid;
	long unsigned int last_update;
	struct hlist_node hash_entry;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_dhcp_packet {
	__u8 op;
	__u8 htype;
	__u8 hlen;
	__u8 hops;
	__be32 xid;
	__be16 secs;
	__be16 flags;
	__be32 ciaddr;
	__be32 yiaddr;
	__be32 siaddr;
	__be32 giaddr;
	__u8 chaddr[16];
	__u8 sname[64];
	__u8 file[128];
	__be32 magic;
};

struct batadv_elp_packet {
	__u8 packet_type;
	__u8 version;
	__u8 orig[6];
	__be32 seqno;
	__be32 elp_interval;
};

struct batadv_forw_packet {
	struct hlist_node list;
	struct hlist_node cleanup_list;
	long unsigned int send_time;
	u8 own;
	struct sk_buff *skb;
	u16 packet_len;
	u32 direct_link_flags;
	u8 num_packets;
	struct delayed_work delayed_work;
	struct batadv_hard_iface *if_incoming;
	struct batadv_hard_iface *if_outgoing;
	atomic_t *queue_left;
};

struct batadv_frag_list_entry {
	struct hlist_node list;
	struct sk_buff *skb;
	u8 no;
};

struct batadv_frag_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 reserved: 1;
	__u8 priority: 3;
	__u8 no: 4;
	__u8 dest[6];
	__u8 orig[6];
	__be16 seqno;
	__be16 total_size;
};

struct hlist_head {
	struct hlist_node *first;
};

struct batadv_frag_table_entry {
	struct hlist_head fragment_list;
	spinlock_t lock;
	long unsigned int timestamp;
	u16 seqno;
	u16 size;
	u16 total_size;
};

struct batadv_gw_node {
	struct hlist_node list;
	struct batadv_orig_node *orig_node;
	u32 bandwidth_down;
	u32 bandwidth_up;
	struct kref refcount;
	struct callback_head rcu;
};

struct packet_type {
	__be16 type;
	bool ignore_outgoing;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
	bool (*id_match)(struct packet_type *, struct sock *);
	struct net *af_packet_net;
	void *af_packet_priv;
	struct list_head list;
};

struct batadv_hard_iface_bat_iv {
	unsigned char *ogm_buff;
	int ogm_buff_len;
	atomic_t ogm_seqno;
	struct mutex ogm_buff_mutex;
};

struct batadv_hard_iface_bat_v {
	atomic_t elp_interval;
	atomic_t elp_seqno;
	struct sk_buff *elp_skb;
	struct delayed_work elp_wq;
	struct delayed_work aggr_wq;
	struct sk_buff_head aggr_list;
	unsigned int aggr_len;
	atomic_t throughput_override;
	u8 flags;
};

struct batadv_hard_iface {
	struct list_head list;
	char if_status;
	u8 num_bcasts;
	u32 wifi_flags;
	struct net_device *net_dev;
	struct kref refcount;
	struct packet_type batman_adv_ptype;
	struct net_device *soft_iface;
	struct callback_head rcu;
	atomic_t hop_penalty;
	struct batadv_hard_iface_bat_iv bat_iv;
	struct batadv_hard_iface_bat_v bat_v;
	struct hlist_head neigh_list;
	spinlock_t neigh_list_lock;
};

struct ewma_throughput {
	long unsigned int internal;
};

struct batadv_hardif_neigh_node_bat_v {
	struct ewma_throughput throughput;
	u32 elp_interval;
	u32 elp_latest_seqno;
	long unsigned int last_unicast_tx;
};

struct batadv_hardif_neigh_node {
	struct hlist_node list;
	u8 addr[6];
	u8 orig[6];
	struct batadv_hard_iface *if_incoming;
	long unsigned int last_seen;
	struct batadv_hardif_neigh_node_bat_v bat_v;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_hashtable {
	struct hlist_head *table;
	spinlock_t *list_locks;
	u32 size;
	atomic_t generation;
};

struct batadv_hw_addr {
	struct hlist_node list;
	unsigned char addr[6];
};

struct batadv_icmp_header {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 msg_type;
	__u8 dst[6];
	__u8 orig[6];
	__u8 uid;
	__u8 align[3];
};

struct batadv_icmp_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 msg_type;
	__u8 dst[6];
	__u8 orig[6];
	__u8 uid;
	__u8 reserved;
	__be16 seqno;
};

struct batadv_icmp_packet_rr {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 msg_type;
	__u8 dst[6];
	__u8 orig[6];
	__u8 uid;
	__u8 rr_cur;
	__be16 seqno;
	__u8 rr[96];
};

struct batadv_icmp_tp_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 msg_type;
	__u8 dst[6];
	__u8 orig[6];
	__u8 uid;
	__u8 subtype;
	__u8 session[2];
	__be32 seqno;
	__be32 timestamp;
};

struct batadv_mcast_querier_state {
	unsigned char exists: 1;
	unsigned char shadowing: 1;
};

struct batadv_mcast_mla_flags {
	struct batadv_mcast_querier_state querier_ipv4;
	struct batadv_mcast_querier_state querier_ipv6;
	unsigned char enabled: 1;
	unsigned char bridged: 1;
	u8 tvlv_flags;
};

struct batadv_mcast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 reserved;
	__be16 tvlv_len;
};

struct batadv_nc_node {
	struct list_head list;
	u8 addr[6];
	struct kref refcount;
	struct callback_head rcu;
	struct batadv_orig_node *orig_node;
	long unsigned int last_seen;
};

struct batadv_nc_path;

struct batadv_nc_packet {
	struct list_head list;
	__be32 packet_id;
	long unsigned int timestamp;
	struct batadv_neigh_node *neigh_node;
	struct sk_buff *skb;
	struct batadv_nc_path *nc_path;
};

struct batadv_nc_path {
	struct hlist_node hash_entry;
	struct callback_head rcu;
	struct kref refcount;
	struct list_head packet_list;
	spinlock_t packet_list_lock;
	u8 next_hop[6];
	u8 prev_hop[6];
	long unsigned int last_valid;
};

struct batadv_neigh_ifinfo_bat_iv {
	u8 tq_recv[5];
	u8 tq_index;
	u8 tq_avg;
	long unsigned int real_bits[1];
	u8 real_packet_count;
};

struct batadv_neigh_ifinfo_bat_v {
	u32 throughput;
	u32 last_seqno;
};

struct batadv_neigh_ifinfo {
	struct hlist_node list;
	struct batadv_hard_iface *if_outgoing;
	struct batadv_neigh_ifinfo_bat_iv bat_iv;
	struct batadv_neigh_ifinfo_bat_v bat_v;
	u8 last_ttl;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_neigh_node {
	struct hlist_node list;
	struct batadv_orig_node *orig_node;
	u8 addr[6];
	struct hlist_head ifinfo_list;
	spinlock_t ifinfo_lock;
	struct batadv_hard_iface *if_incoming;
	long unsigned int last_seen;
	struct batadv_hardif_neigh_node *hardif_neigh;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_ogm2_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 flags;
	__be32 seqno;
	__u8 orig[6];
	__be16 tvlv_len;
	__be32 throughput;
};

struct batadv_ogm_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 flags;
	__be32 seqno;
	__u8 orig[6];
	__u8 prev_sender[6];
	__u8 reserved;
	__u8 tq;
	__be16 tvlv_len;
};

struct batadv_orig_bat_iv {
	spinlock_t ogm_cnt_lock;
};

struct batadv_orig_ifinfo_bat_iv {
	long unsigned int bcast_own[1];
	u8 bcast_own_sum;
};

struct batadv_orig_ifinfo {
	struct hlist_node list;
	struct batadv_hard_iface *if_outgoing;
	struct batadv_neigh_node *router;
	u32 last_real_seqno;
	u8 last_ttl;
	u32 last_seqno_forwarded;
	long unsigned int batman_seqno_reset;
	struct batadv_orig_ifinfo_bat_iv bat_iv;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_orig_node {
	u8 orig[6];
	struct hlist_head ifinfo_list;
	struct batadv_orig_ifinfo *last_bonding_candidate;
	batadv_dat_addr_t dat_addr;
	long unsigned int last_seen;
	long unsigned int bcast_seqno_reset;
	spinlock_t mcast_handler_lock;
	u8 mcast_flags;
	struct hlist_node mcast_want_all_unsnoopables_node;
	struct hlist_node mcast_want_all_ipv4_node;
	struct hlist_node mcast_want_all_ipv6_node;
	struct hlist_node mcast_want_all_rtr4_node;
	struct hlist_node mcast_want_all_rtr6_node;
	long unsigned int capabilities;
	long unsigned int capa_initialized;
	atomic_t last_ttvn;
	unsigned char *tt_buff;
	s16 tt_buff_len;
	spinlock_t tt_buff_lock;
	spinlock_t tt_lock;
	long unsigned int bcast_bits[1];
	u32 last_bcast_seqno;
	struct hlist_head neigh_list;
	spinlock_t neigh_list_lock;
	struct hlist_node hash_entry;
	struct batadv_priv *bat_priv;
	spinlock_t bcast_seqno_lock;
	struct kref refcount;
	struct callback_head rcu;
	struct list_head in_coding_list;
	struct list_head out_coding_list;
	spinlock_t in_coding_list_lock;
	spinlock_t out_coding_list_lock;
	struct batadv_frag_table_entry fragments[8];
	struct hlist_head vlan_list;
	spinlock_t vlan_list_lock;
	struct batadv_orig_bat_iv bat_iv;
};

struct batadv_vlan_tt {
	u32 crc;
	atomic_t num_entries;
};

struct batadv_orig_node_vlan {
	short unsigned int vid;
	struct batadv_vlan_tt tt;
	struct hlist_node list;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_priv_bla {
	atomic_t num_requests;
	struct batadv_hashtable *claim_hash;
	struct batadv_hashtable *backbone_hash;
	u8 loopdetect_addr[6];
	long unsigned int loopdetect_lasttime;
	atomic_t loopdetect_next;
	struct batadv_bcast_duplist_entry bcast_duplist[16];
	int bcast_duplist_curr;
	spinlock_t bcast_duplist_lock;
	struct batadv_bla_claim_dst claim_dest;
	struct delayed_work work;
};

struct batadv_priv_gw {
	struct hlist_head gateway_list;
	spinlock_t list_lock;
	struct batadv_gw_node *curr_gw;
	unsigned int generation;
	atomic_t mode;
	atomic_t sel_class;
	atomic_t bandwidth_down;
	atomic_t bandwidth_up;
	atomic_t reselect;
};

struct batadv_priv_tt {
	atomic_t vn;
	atomic_t ogm_append_cnt;
	size_t local_changes;
	struct list_head changes_list;
	struct batadv_hashtable *local_hash;
	struct batadv_hashtable *global_hash;
	struct hlist_head req_list;
	struct list_head roam_list;
	spinlock_t changes_list_lock;
	spinlock_t req_list_lock;
	spinlock_t roam_list_lock;
	unsigned char *last_changeset;
	s16 last_changeset_len;
	spinlock_t last_changeset_lock;
	spinlock_t commit_lock;
	struct delayed_work work;
};

struct batadv_priv_tvlv {
	struct hlist_head container_list;
	struct hlist_head handler_list;
	spinlock_t container_list_lock;
	spinlock_t handler_list_lock;
};

struct batadv_priv_dat {
	batadv_dat_addr_t addr;
	struct batadv_hashtable *hash;
	struct delayed_work work;
};

struct batadv_priv_mcast {
	struct hlist_head mla_list;
	struct hlist_head want_all_unsnoopables_list;
	struct hlist_head want_all_ipv4_list;
	struct hlist_head want_all_ipv6_list;
	struct hlist_head want_all_rtr4_list;
	struct hlist_head want_all_rtr6_list;
	struct batadv_mcast_mla_flags mla_flags;
	spinlock_t mla_lock;
	atomic_t num_want_all_unsnoopables;
	atomic_t num_want_all_ipv4;
	atomic_t num_want_all_ipv6;
	atomic_t num_want_all_rtr4;
	atomic_t num_want_all_rtr6;
	atomic_t num_no_mc_ptype_capa;
	spinlock_t want_lists_lock;
	struct delayed_work work;
};

struct batadv_priv_nc {
	struct delayed_work work;
	u8 min_tq;
	u32 max_fwd_delay;
	u32 max_buffer_time;
	long unsigned int timestamp_fwd_flush;
	long unsigned int timestamp_sniffed_purge;
	struct batadv_hashtable *coding_hash;
	struct batadv_hashtable *decoding_hash;
};

struct batadv_priv_bat_v {
	unsigned char *ogm_buff;
	int ogm_buff_len;
	atomic_t ogm_seqno;
	struct mutex ogm_buff_mutex;
	struct delayed_work ogm_wq;
};

struct batadv_priv {
	atomic_t mesh_state;
	struct net_device *soft_iface;
	int mtu_set_by_user;
	u64 *bat_counters;
	atomic_t aggregated_ogms;
	atomic_t bonding;
	atomic_t fragmentation;
	atomic_t packet_size_max;
	atomic_t frag_seqno;
	atomic_t bridge_loop_avoidance;
	atomic_t distributed_arp_table;
	atomic_t multicast_mode;
	atomic_t multicast_fanout;
	atomic_t orig_interval;
	atomic_t hop_penalty;
	u32 isolation_mark;
	u32 isolation_mark_mask;
	atomic_t bcast_seqno;
	atomic_t bcast_queue_left;
	atomic_t batman_queue_left;
	struct hlist_head forw_bat_list;
	struct hlist_head forw_bcast_list;
	struct hlist_head tp_list;
	struct batadv_hashtable *orig_hash;
	spinlock_t forw_bat_list_lock;
	spinlock_t forw_bcast_list_lock;
	spinlock_t tp_list_lock;
	atomic_t tp_num;
	struct delayed_work orig_work;
	struct batadv_hard_iface *primary_if;
	struct batadv_algo_ops *algo_ops;
	struct hlist_head softif_vlan_list;
	spinlock_t softif_vlan_list_lock;
	struct batadv_priv_bla bla;
	struct batadv_priv_gw gw;
	struct batadv_priv_tt tt;
	struct batadv_priv_tvlv tvlv;
	struct batadv_priv_dat dat;
	struct batadv_priv_mcast mcast;
	atomic_t network_coding;
	struct batadv_priv_nc nc;
	struct batadv_priv_bat_v bat_v;
};

struct batadv_skb_cb {
	unsigned char decoded: 1;
	unsigned char num_bcasts;
};

struct batadv_softif_vlan {
	struct batadv_priv *bat_priv;
	short unsigned int vid;
	atomic_t ap_isolation;
	struct batadv_vlan_tt tt;
	struct hlist_node list;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_tp_unacked {
	u32 seqno;
	u16 len;
	struct list_head list;
};

struct batadv_tp_vars {
	struct hlist_node list;
	struct timer_list timer;
	struct batadv_priv *bat_priv;
	long unsigned int start_time;
	u8 other_end[6];
	enum batadv_tp_meter_role role;
	atomic_t sending;
	enum batadv_tp_meter_reason reason;
	struct delayed_work finish_work;
	u32 test_length;
	u8 session[2];
	u8 icmp_uid;
	u16 dec_cwnd;
	u32 cwnd;
	spinlock_t cwnd_lock;
	u32 ss_threshold;
	atomic_t last_acked;
	u32 last_sent;
	atomic64_t tot_sent;
	atomic_t dup_acks;
	unsigned char fast_recovery: 1;
	u32 recover;
	u32 rto;
	u32 srtt;
	u32 rttvar;
	wait_queue_head_t more_bytes;
	u32 prerandom_offset;
	spinlock_t prerandom_lock;
	u32 last_recv;
	struct list_head unacked_list;
	spinlock_t unacked_lock;
	long unsigned int last_recv_time;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_tvlv_tt_change {
	__u8 flags;
	__u8 reserved[3];
	__u8 addr[6];
	__be16 vid;
};

struct batadv_tt_change_node {
	struct list_head list;
	struct batadv_tvlv_tt_change change;
};

struct batadv_tt_common_entry {
	u8 addr[6];
	short unsigned int vid;
	struct hlist_node hash_entry;
	u16 flags;
	long unsigned int added_at;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_tt_global_entry {
	struct batadv_tt_common_entry common;
	struct hlist_head orig_list;
	atomic_t orig_list_count;
	spinlock_t list_lock;
	long unsigned int roam_at;
};

struct batadv_tt_local_entry {
	struct batadv_tt_common_entry common;
	long unsigned int last_seen;
	struct batadv_softif_vlan *vlan;
};

struct batadv_tt_orig_list_entry {
	struct batadv_orig_node *orig_node;
	u8 ttvn;
	u8 flags;
	struct hlist_node list;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_tt_req_node {
	u8 addr[6];
	long unsigned int issued_at;
	struct kref refcount;
	struct hlist_node list;
};

struct batadv_tt_roam_node {
	u8 addr[6];
	atomic_t counter;
	long unsigned int first_time;
	struct list_head list;
};

struct batadv_tvlv_hdr {
	__u8 type;
	__u8 version;
	__be16 len;
};

struct batadv_tvlv_container {
	struct hlist_node list;
	struct batadv_tvlv_hdr tvlv_hdr;
	struct kref refcount;
};

struct batadv_tvlv_gateway_data {
	__be32 bandwidth_down;
	__be32 bandwidth_up;
};

struct batadv_tvlv_handler {
	struct hlist_node list;
	void (*ogm_handler)(struct batadv_priv *, struct batadv_orig_node *, u8, void *, u16);
	int (*unicast_handler)(struct batadv_priv *, u8 *, u8 *, void *, u16);
	int (*mcast_handler)(struct batadv_priv *, struct sk_buff *);
	u8 type;
	u8 version;
	u8 flags;
	struct kref refcount;
	struct callback_head rcu;
};

struct batadv_tvlv_mcast_data {
	__u8 flags;
	__u8 reserved[3];
};

struct batadv_tvlv_mcast_tracker {
	__be16 num_dests;
};

struct batadv_tvlv_roam_adv {
	__u8 client[6];
	__be16 vid;
};

struct batadv_tvlv_tt_vlan_data {
	__be32 crc;
	__be16 vid;
	__u16 reserved;
};

struct batadv_tvlv_tt_data {
	__u8 flags;
	__u8 ttvn;
	__be16 num_vlan;
	struct batadv_tvlv_tt_vlan_data vlan_data[0];
};

struct batadv_unicast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 ttvn;
	__u8 dest[6];
};

struct batadv_unicast_4addr_packet {
	struct batadv_unicast_packet u;
	__u8 src[6];
	__u8 subtype;
	__u8 reserved;
};

struct batadv_unicast_tvlv_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 reserved;
	__u8 dst[6];
	__u8 src[6];
	__be16 tvlv_len;
	__u16 align;
};

struct batadv_v_metric_queue_entry {
	struct batadv_hardif_neigh_node *hardif_neigh;
	struct list_head list;
};

struct i915_vma;

struct batch_chunk {
	struct i915_vma *vma;
	u32 offset;
	u32 *start;
	u32 *end;
	u32 max_items;
};

struct batch_u16 {
	u16 entropy[48];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_u32 {
	u32 entropy[24];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_u64 {
	u64 entropy[12];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_u8 {
	u8 entropy[96];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_vals {
	u32 max_threads;
	u32 state_start;
	u32 surface_start;
	u32 surface_height;
	u32 surface_width;
	u32 size;
};

struct minmax_sample {
	u32 t;
	u32 v;
};

struct minmax {
	struct minmax_sample s[3];
};

struct bbr {
	u32 min_rtt_us;
	u32 min_rtt_stamp;
	u32 probe_rtt_done_stamp;
	struct minmax bw;
	u32 rtt_cnt;
	u32 next_rtt_delivered;
	u64 cycle_mstamp;
	u32 mode: 3;
	u32 prev_ca_state: 3;
	u32 packet_conservation: 1;
	u32 round_start: 1;
	u32 idle_restart: 1;
	u32 probe_rtt_round_done: 1;
	u32 unused: 13;
	u32 lt_is_sampling: 1;
	u32 lt_rtt_cnt: 7;
	u32 lt_use_bw: 1;
	u32 lt_bw;
	u32 lt_last_delivered;
	u32 lt_last_stamp;
	u32 lt_last_lost;
	u32 pacing_gain: 10;
	u32 cwnd_gain: 10;
	u32 full_bw_reached: 1;
	u32 full_bw_cnt: 2;
	u32 cycle_idx: 3;
	u32 has_seen_rtt: 1;
	u32 unused_b: 5;
	u32 prior_cwnd;
	u32 full_bw;
	u64 ack_epoch_mstamp;
	u16 extra_acked[2];
	u32 ack_epoch_acked: 20;
	u32 extra_acked_win_rtts: 5;
	u32 extra_acked_win_idx: 1;
	u32 unused_c: 6;
};

struct bd_holder_disk {
	struct list_head list;
	struct kobject *holder_dir;
	int refcnt;
};

struct bdb_block_entry {
	struct list_head node;
	enum bdb_block_id section_id;
	u8 data[0];
};

struct dsc_compression_parameters_entry {
	u8 version_major: 4;
	u8 version_minor: 4;
	u8 rc_buffer_block_size: 2;
	u8 reserved1: 6;
	u8 rc_buffer_size;
	u32 slices_per_line;
	u8 line_buffer_depth: 4;
	u8 reserved2: 4;
	u8 block_prediction_enable: 1;
	u8 reserved3: 7;
	u8 max_bpp;
	u8 reserved4: 1;
	u8 support_8bpc: 1;
	u8 support_10bpc: 1;
	u8 support_12bpc: 1;
	u8 reserved5: 4;
	u16 slice_height;
} __attribute__((packed));

struct bdb_compression_parameters {
	u16 entry_size;
	struct dsc_compression_parameters_entry data[16];
};

struct bdb_driver_features {
	u8 boot_dev_algorithm: 1;
	u8 allow_display_switch_dvd: 1;
	u8 allow_display_switch_dos: 1;
	u8 hotplug_dvo: 1;
	u8 dual_view_zoom: 1;
	u8 int15h_hook: 1;
	u8 sprite_in_clone: 1;
	u8 primary_lfp_id: 1;
	u16 boot_mode_x;
	u16 boot_mode_y;
	u8 boot_mode_bpp;
	u8 boot_mode_refresh;
	u16 enable_lfp_primary: 1;
	u16 selective_mode_pruning: 1;
	u16 dual_frequency: 1;
	u16 render_clock_freq: 1;
	u16 nt_clone_support: 1;
	u16 power_scheme_ui: 1;
	u16 sprite_display_assign: 1;
	u16 cui_aspect_scaling: 1;
	u16 preserve_aspect_ratio: 1;
	u16 sdvo_device_power_down: 1;
	u16 crt_hotplug: 1;
	u16 lvds_config: 2;
	u16 tv_hotplug: 1;
	u16 hdmi_config: 2;
	u8 static_display: 1;
	u8 embedded_platform: 1;
	u8 display_subsystem_enable: 1;
	u8 reserved0: 5;
	u16 legacy_crt_max_x;
	u16 legacy_crt_max_y;
	u8 legacy_crt_max_refresh;
	u8 hdmi_termination: 1;
	u8 cea861d_hdmi_support: 1;
	u8 self_refresh_enable: 1;
	u8 reserved1: 5;
	u8 custom_vbt_version;
	u16 rmpm_enabled: 1;
	u16 s2ddt_enabled: 1;
	u16 dpst_enabled: 1;
	u16 bltclt_enabled: 1;
	u16 adb_enabled: 1;
	u16 drrs_enabled: 1;
	u16 grs_enabled: 1;
	u16 gpmt_enabled: 1;
	u16 tbt_enabled: 1;
	u16 psr_enabled: 1;
	u16 ips_enabled: 1;
	u16 dfps_enabled: 1;
	u16 dmrrs_enabled: 1;
	u16 adt_enabled: 1;
	u16 hpd_wake: 1;
	u16 pc_feature_valid: 1;
} __attribute__((packed));

struct bdb_edid_dtd {
	u16 clock;
	u8 hactive_lo;
	u8 hblank_lo;
	u8 hblank_hi: 4;
	u8 hactive_hi: 4;
	u8 vactive_lo;
	u8 vblank_lo;
	u8 vblank_hi: 4;
	u8 vactive_hi: 4;
	u8 hsync_off_lo;
	u8 hsync_pulse_width_lo;
	u8 vsync_pulse_width_lo: 4;
	u8 vsync_off_lo: 4;
	u8 vsync_pulse_width_hi: 2;
	u8 vsync_off_hi: 2;
	u8 hsync_pulse_width_hi: 2;
	u8 hsync_off_hi: 2;
	u8 himage_lo;
	u8 vimage_lo;
	u8 vimage_hi: 4;
	u8 himage_hi: 4;
	u8 h_border;
	u8 v_border;
	u8 rsvd1: 3;
	u8 digital: 2;
	u8 vsync_positive: 1;
	u8 hsync_positive: 1;
	u8 non_interlaced: 1;
};

struct bdb_edid_pnp_id {
	u16 mfg_name;
	u16 product_code;
	u32 serial;
	u8 mfg_week;
	u8 mfg_year;
} __attribute__((packed));

struct bdb_edid_product_name {
	char name[13];
};

struct edp_power_seq {
	u16 t1_t3;
	u16 t8;
	u16 t9;
	u16 t10;
	u16 t11_t12;
};

struct edp_fast_link_params {
	u8 rate: 4;
	u8 lanes: 4;
	u8 preemphasis: 4;
	u8 vswing: 4;
};

struct edp_pwm_delays {
	u16 pwm_on_to_backlight_enable;
	u16 backlight_disable_to_pwm_off;
};

struct edp_full_link_params {
	u8 preemphasis: 4;
	u8 vswing: 4;
};

struct edp_apical_params {
	u32 panel_oui;
	u32 dpcd_base_address;
	u32 dpcd_idridix_control_0;
	u32 dpcd_option_select;
	u32 dpcd_backlight;
	u32 ambient_light;
	u32 backlight_scale;
};

struct bdb_edp {
	struct edp_power_seq power_seqs[16];
	u32 color_depth;
	struct edp_fast_link_params fast_link_params[16];
	u32 sdrrs_msa_timing_delay;
	u16 edp_s3d_feature;
	u16 edp_t3_optimization;
	u64 edp_vswing_preemph;
	u16 fast_link_training;
	u16 dpcd_600h_write_required;
	struct edp_pwm_delays pwm_delays[16];
	u16 full_link_params_provided;
	struct edp_full_link_params full_link_params[16];
	u16 apical_enable;
	struct edp_apical_params apical_params[16];
	u16 edp_fast_link_training_rate[16];
	u16 edp_max_port_link_rate[16];
	u16 edp_dsc_disable;
	u16 t6_delay_support;
	u16 link_idle_time[16];
} __attribute__((packed));

struct bdb_general_definitions {
	u8 crt_ddc_gmbus_pin;
	u8 dpms_non_acpi: 1;
	u8 skip_boot_crt_detect: 1;
	u8 dpms_aim: 1;
	u8 rsvd1: 5;
	u8 boot_display[2];
	u8 child_dev_size;
	u8 devices[0];
};

struct bdb_general_features {
	u8 panel_fitting: 2;
	u8 flexaim: 1;
	u8 msg_enable: 1;
	u8 clear_screen: 3;
	u8 color_flip: 1;
	u8 download_ext_vbt: 1;
	u8 enable_ssc: 1;
	u8 ssc_freq: 1;
	u8 enable_lfp_on_override: 1;
	u8 disable_ssc_ddt: 1;
	u8 underscan_vga_timings: 1;
	u8 display_clock_mode: 1;
	u8 vbios_hotplug_support: 1;
	u8 disable_smooth_vision: 1;
	u8 single_dvi: 1;
	u8 rotate_180: 1;
	u8 fdi_rx_polarity_inverted: 1;
	u8 vbios_extended_mode: 1;
	u8 copy_ilfp_dtd_to_sdvo_lvds_dtd: 1;
	u8 panel_best_fit_timing: 1;
	u8 ignore_strap_state: 1;
	u8 legacy_monitor_detect;
	u8 int_crt_support: 1;
	u8 int_tv_support: 1;
	u8 int_efp_support: 1;
	u8 dp_ssc_enable: 1;
	u8 dp_ssc_freq: 1;
	u8 dp_ssc_dongle_supported: 1;
	u8 rsvd11: 2;
	u8 tc_hpd_retry_timeout: 7;
	u8 rsvd12: 1;
	u8 afc_startup_config: 2;
	u8 rsvd13: 6;
};

struct generic_dtd_entry {
	u32 pixel_clock;
	u16 hactive;
	u16 hblank;
	u16 hfront_porch;
	u16 hsync;
	u16 vactive;
	u16 vblank;
	u16 vfront_porch;
	u16 vsync;
	u16 width_mm;
	u16 height_mm;
	u8 rsvd_flags: 6;
	u8 vsync_positive_polarity: 1;
	u8 hsync_positive_polarity: 1;
	u8 rsvd[3];
};

struct bdb_generic_dtd {
	u16 gdtd_size;
	struct generic_dtd_entry dtd[0];
} __attribute__((packed));

struct bdb_header {
	u8 signature[16];
	u16 version;
	u16 header_size;
	u16 bdb_size;
};

struct lfp_backlight_data_entry {
	u8 type: 2;
	u8 active_low_pwm: 1;
	u8 i2c_pin: 3;
	u8 i2c_speed: 2;
	u16 pwm_freq_hz;
	u8 min_brightness;
	u8 i2c_address;
	u8 i2c_command;
} __attribute__((packed));

struct lfp_backlight_control_method {
	u8 type: 4;
	u8 controller: 4;
};

struct lfp_brightness_level {
	u16 level;
	u16 reserved;
};

struct bdb_lfp_backlight {
	u8 entry_size;
	struct lfp_backlight_data_entry data[16];
	u8 level[16];
	struct lfp_backlight_control_method backlight_control[16];
	struct lfp_brightness_level brightness_level[16];
	struct lfp_brightness_level brightness_min_level[16];
	u8 brightness_precision_bits[16];
	u16 hdr_dpcd_refresh_timeout[16];
} __attribute__((packed));

struct fp_timing {
	u16 x_res;
	u16 y_res;
	u32 lvds_reg;
	u32 lvds_reg_val;
	u32 pp_on_reg;
	u32 pp_on_reg_val;
	u32 pp_off_reg;
	u32 pp_off_reg_val;
	u32 pp_cycle_reg;
	u32 pp_cycle_reg_val;
	u32 pfit_reg;
	u32 pfit_reg_val;
	u16 terminator;
} __attribute__((packed));

struct lfp_data_entry {
	struct fp_timing fp_timing;
	struct bdb_edid_dtd dvo_timing;
	struct bdb_edid_pnp_id pnp_id;
};

struct bdb_lfp_data {
	struct lfp_data_entry data[16];
};

struct lfp_data_ptr_table {
	u16 offset;
	u8 table_size;
} __attribute__((packed));

struct lfp_data_ptr {
	struct lfp_data_ptr_table fp_timing;
	struct lfp_data_ptr_table dvo_timing;
	struct lfp_data_ptr_table panel_pnp_id;
};

struct bdb_lfp_data_ptrs {
	u8 num_entries;
	struct lfp_data_ptr ptr[16];
	struct lfp_data_ptr_table panel_name;
};

struct lfp_black_border {
	u8 top;
	u8 bottom;
	u8 left;
	u8 right;
};

struct bdb_lfp_data_tail {
	struct bdb_edid_product_name panel_name[16];
	u16 scaling_enable;
	u8 seamless_drrs_min_refresh_rate[16];
	u8 pixel_overlap_count[16];
	struct lfp_black_border black_border[16];
	u16 dual_lfp_port_sync_enable;
	u16 gpu_dithering_for_banding_artifacts;
};

struct bdb_lfp_options {
	u8 panel_type;
	u8 panel_type2;
	u8 pfit_mode: 2;
	u8 pfit_text_mode_enhanced: 1;
	u8 pfit_gfx_mode_enhanced: 1;
	u8 pfit_ratio_auto: 1;
	u8 pixel_dither: 1;
	u8 lvds_edid: 1;
	u8 rsvd2: 1;
	u8 rsvd4;
	u32 lvds_panel_channel_bits;
	u16 ssc_bits;
	u16 ssc_freq;
	u16 ssc_ddt;
	u16 panel_color_depth;
	u32 dps_panel_type_bits;
	u32 blt_control_type_bits;
	u16 lcdvcc_s0_enable;
	u32 rotation;
	u32 position;
} __attribute__((packed));

struct lfp_power_features {
	u8 dpst_support: 1;
	u8 power_conservation_pref: 3;
	u8 reserved2: 1;
	u8 lace_enabled_status: 1;
	u8 lace_support: 1;
	u8 als_enable: 1;
};

struct panel_identification {
	u8 panel_technology: 4;
	u8 reserved: 4;
};

struct bdb_lfp_power {
	struct lfp_power_features features;
	struct als_data_entry als[5];
	u8 lace_aggressiveness_profile: 3;
	u8 reserved1: 5;
	u16 dpst;
	u16 psr;
	u16 drrs;
	u16 lace_support;
	u16 adt;
	u16 dmrrs;
	u16 adb;
	u16 lace_enabled_status;
	struct aggressiveness_profile_entry aggressiveness[16];
	u16 hobl;
	u16 vrr_feature_enabled;
	u16 elp;
	u16 opst;
	struct aggressiveness_profile2_entry aggressiveness2[16];
	u16 apd;
	u16 pixoptix;
	struct aggressiveness_profile3_entry aggressiveness3[16];
	struct panel_identification panel_identification[16];
	u16 xpst_support;
	u16 tcon_based_backlight_optimization;
	struct aggressiveness_profile4_entry aggressiveness4[16];
	u16 tcon_backlight_xpst_coexistence;
} __attribute__((packed));

struct mipi_config {
	u16 panel_id;
	u32 enable_dithering: 1;
	u32 rsvd1: 1;
	u32 is_bridge: 1;
	u32 panel_arch_type: 2;
	u32 is_cmd_mode: 1;
	u32 video_transfer_mode: 2;
	u32 cabc_supported: 1;
	u32 pwm_blc: 1;
	u32 videomode_color_format: 4;
	u32 rotation: 2;
	u32 bta_enabled: 1;
	u32 rsvd2: 15;
	u16 dual_link: 2;
	u16 lane_cnt: 2;
	u16 pixel_overlap: 3;
	u16 rgb_flip: 1;
	u16 dl_dcs_cabc_ports: 2;
	u16 dl_dcs_backlight_ports: 2;
	u16 rsvd3: 4;
	u16 rsvd4;
	u8 rsvd5;
	u32 target_burst_mode_freq;
	u32 dsi_ddr_clk;
	u32 bridge_ref_clk;
	u8 byte_clk_sel: 2;
	u8 rsvd6: 6;
	u16 dphy_param_valid: 1;
	u16 eot_pkt_disabled: 1;
	u16 enable_clk_stop: 1;
	u16 rsvd7: 13;
	u32 hs_tx_timeout;
	u32 lp_rx_timeout;
	u32 turn_around_timeout;
	u32 device_reset_timer;
	u32 master_init_timer;
	u32 dbi_bw_timer;
	u32 lp_byte_clk_val;
	u32 prepare_cnt: 6;
	u32 rsvd8: 2;
	u32 clk_zero_cnt: 8;
	u32 trail_cnt: 5;
	u32 rsvd9: 3;
	u32 exit_zero_cnt: 6;
	u32 rsvd10: 2;
	u32 clk_lane_switch_cnt;
	u32 hl_switch_cnt;
	u32 rsvd11[6];
	u8 tclk_miss;
	u8 tclk_post;
	u8 rsvd12;
	u8 tclk_pre;
	u8 tclk_prepare;
	u8 tclk_settle;
	u8 tclk_term_enable;
	u8 tclk_trail;
	u16 tclk_prepare_clkzero;
	u8 rsvd13;
	u8 td_term_enable;
	u8 teot;
	u8 ths_exit;
	u8 ths_prepare;
	u16 ths_prepare_hszero;
	u8 rsvd14;
	u8 ths_settle;
	u8 ths_skip;
	u8 ths_trail;
	u8 tinit;
	u8 tlpx;
	u8 rsvd15[3];
	u8 panel_enable;
	u8 bl_enable;
	u8 pwm_enable;
	u8 reset_r_n;
	u8 pwr_down_r;
	u8 stdby_r_n;
} __attribute__((packed));

struct mipi_pps_data {
	u16 panel_on_delay;
	u16 bl_enable_delay;
	u16 bl_disable_delay;
	u16 panel_off_delay;
	u16 panel_power_cycle_delay;
};

struct bdb_mipi_config {
	struct mipi_config config[6];
	struct mipi_pps_data pps[6];
	struct edp_pwm_delays pwm_delays[6];
	u8 pmic_i2c_bus_number[6];
};

struct bdb_mipi_sequence {
	u8 version;
	u8 data[0];
};

struct psr_table {
	u8 full_link: 1;
	u8 require_aux_to_wakeup: 1;
	u8 feature_bits_rsvd: 6;
	u8 idle_frames: 4;
	u8 lines_to_wait: 3;
	u8 wait_times_rsvd: 1;
	u16 tp1_wakeup_time;
	u16 tp2_tp3_wakeup_time;
};

struct bdb_psr {
	struct psr_table psr_table[16];
	u32 psr2_tp2_tp3_wakeup_time;
};

struct bdb_sdvo_lvds_dtd {
	struct bdb_edid_dtd dtd[4];
};

struct bdb_sdvo_lvds_options {
	u8 panel_backlight;
	u8 h40_set_panel_type;
	u8 panel_type;
	u8 ssc_clk_freq;
	u16 als_low_trip;
	u16 als_high_trip;
	u8 sclalarcoeff_tab_row_num;
	u8 sclalarcoeff_tab_row_size;
	u8 coefficient[8];
	u8 panel_misc_bits_1;
	u8 panel_misc_bits_2;
	u8 panel_misc_bits_3;
	u8 panel_misc_bits_4;
};

struct gendisk;

struct request_queue;

struct disk_stats;

struct blk_holder_ops;

struct partition_meta_info;

struct block_device {
	sector_t bd_start_sect;
	sector_t bd_nr_sectors;
	struct gendisk *bd_disk;
	struct request_queue *bd_queue;
	struct disk_stats *bd_stats;
	long unsigned int bd_stamp;
	atomic_t __bd_flags;
	dev_t bd_dev;
	struct address_space *bd_mapping;
	atomic_t bd_openers;
	spinlock_t bd_size_lock;
	void *bd_claiming;
	void *bd_holder;
	const struct blk_holder_ops *bd_holder_ops;
	struct mutex bd_holder_lock;
	int bd_holders;
	struct kobject *bd_holder_dir;
	atomic_t bd_fsfreeze_count;
	struct mutex bd_fsfreeze_mutex;
	struct partition_meta_info *bd_meta_info;
	int bd_writers;
	void *bd_security;
	struct device bd_device;
};

struct posix_acl;

struct inode_operations;

struct file_lock_context;

struct pipe_inode_info;

struct cdev;

struct inode {
	umode_t i_mode;
	short unsigned int i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations *i_op;
	struct super_block *i_sb;
	struct address_space *i_mapping;
	void *i_security;
	long unsigned int i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	time64_t i_atime_sec;
	time64_t i_mtime_sec;
	time64_t i_ctime_sec;
	u32 i_atime_nsec;
	u32 i_mtime_nsec;
	u32 i_ctime_nsec;
	u32 i_generation;
	spinlock_t i_lock;
	short unsigned int i_bytes;
	u8 i_blkbits;
	enum rw_hint i_write_hint;
	blkcnt_t i_blocks;
	u32 i_state;
	struct rw_semaphore i_rwsem;
	long unsigned int dirtied_when;
	long unsigned int dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct bdi_writeback *i_wb;
	int i_wb_frn_winner;
	u16 i_wb_frn_avg_time;
	u16 i_wb_frn_history;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations *i_fop;
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context *i_flctx;
	struct address_space i_data;
	union {
		struct list_head i_devices;
		int i_linklen;
	};
	union {
		struct pipe_inode_info *i_pipe;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector *i_fsnotify_marks;
	void *i_private;
};

struct bdev_inode {
	struct block_device bdev;
	struct inode vfs_inode;
};

struct bgl_lock {
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bh_accounting {
	int nr;
	int ratelimit;
};

struct bh_lru {
	struct buffer_head *bhs[16];
};

struct bictcp {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 bic_origin_point;
	u32 bic_K;
	u32 delay_min;
	u32 epoch_start;
	u32 ack_cnt;
	u32 tcp_cwnd;
	u16 unused;
	u8 sample_cnt;
	u8 found;
	u32 round_start;
	u32 end_seq;
	u32 last_ack;
	u32 curr_rtt;
};

struct bictcp___2 {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 epoch_start;
	u32 delayed_ack;
};

struct binfmt_misc {
	struct list_head entries;
	rwlock_t entries_lock;
	bool enabled;
};

struct bvec_iter {
	sector_t bi_sector;
	unsigned int bi_size;
	unsigned int bi_idx;
	unsigned int bi_bvec_done;
} __attribute__((packed));

struct bio;

typedef void bio_end_io_t(struct bio *);

struct bio_issue {
	u64 value;
};

struct bio_vec {
	struct page *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct blkcg_gq;

struct bio_set;

struct bio {
	struct bio *bi_next;
	struct block_device *bi_bdev;
	blk_opf_t bi_opf;
	short unsigned int bi_flags;
	short unsigned int bi_ioprio;
	enum rw_hint bi_write_hint;
	blk_status_t bi_status;
	atomic_t __bi_remaining;
	struct bvec_iter bi_iter;
	union {
		blk_qc_t bi_cookie;
		unsigned int __bi_nr_segments;
	};
	bio_end_io_t *bi_end_io;
	void *bi_private;
	struct blkcg_gq *bi_blkg;
	struct bio_issue bi_issue;
	u64 bi_iocost_cost;
	short unsigned int bi_vcnt;
	short unsigned int bi_max_vecs;
	atomic_t __bi_cnt;
	struct bio_vec *bi_io_vec;
	struct bio_set *bi_pool;
	struct bio_vec bi_inline_vecs[0];
};

struct bio_alloc_cache {
	struct bio *free_list;
	struct bio *free_list_irq;
	unsigned int nr;
	unsigned int nr_irq;
};

struct bio_integrity_payload {
	struct bio *bip_bio;
	struct bvec_iter bip_iter;
	short unsigned int bip_vcnt;
	short unsigned int bip_max_vcnt;
	short unsigned int bip_flags;
	u16 app_tag;
	struct bvec_iter bio_iter;
	struct work_struct bip_work;
	struct bio_vec *bip_vec;
	struct bio_vec bip_inline_vecs[0];
};

struct bio_list {
	struct bio *head;
	struct bio *tail;
};

struct iovec {
	void *iov_base;
	__kernel_size_t iov_len;
};

struct kvec;

struct folio_queue;

struct iov_iter {
	u8 iter_type;
	bool nofault;
	bool data_source;
	size_t iov_offset;
	union {
		struct iovec __ubuf_iovec;
		struct {
			union {
				const struct iovec *__iov;
				const struct kvec *kvec;
				const struct bio_vec *bvec;
				const struct folio_queue *folioq;
				struct xarray *xarray;
				void *ubuf;
			};
			size_t count;
		};
	};
	union {
		long unsigned int nr_segs;
		u8 folioq_slot;
		loff_t xarray_start;
	};
};

struct bio_map_data {
	bool is_our_pages: 1;
	bool is_null_mapped: 1;
	struct iov_iter iter;
	struct iovec iov[0];
};

struct bio_post_read_ctx {
	struct bio *bio;
	struct work_struct work;
	unsigned int cur_step;
	unsigned int enabled_steps;
};

typedef void *mempool_alloc_t(gfp_t, void *);

typedef void mempool_free_t(void *, void *);

struct mempool_s {
	spinlock_t lock;
	int min_nr;
	int curr_nr;
	void **elements;
	void *pool_data;
	mempool_alloc_t *alloc;
	mempool_free_t *free;
	wait_queue_head_t wait;
};

typedef struct mempool_s mempool_t;

struct bio_set {
	struct kmem_cache *bio_slab;
	unsigned int front_pad;
	struct bio_alloc_cache *cache;
	mempool_t bio_pool;
	mempool_t bvec_pool;
	unsigned int back_pad;
	spinlock_t rescue_lock;
	struct bio_list rescue_list;
	struct work_struct rescue_work;
	struct workqueue_struct *rescue_workqueue;
	struct hlist_node cpuhp_dead;
};

struct bio_slab {
	struct kmem_cache *slab;
	unsigned int slab_ref;
	unsigned int slab_size;
	char name[12];
};

struct biovec_slab {
	int nr_vecs;
	char *name;
	struct kmem_cache *slab;
};

struct bitmap_page;

struct bitmap_counts {
	spinlock_t lock;
	struct bitmap_page *bp;
	long unsigned int pages;
	long unsigned int missing_pages;
	long unsigned int chunkshift;
	long unsigned int chunks;
};

struct bitmap_storage {
	struct file *file;
	struct page *sb_page;
	long unsigned int sb_index;
	struct page **filemap;
	long unsigned int *filemap_attr;
	long unsigned int file_pages;
	long unsigned int bytes;
};

struct mddev;

struct bitmap {
	struct bitmap_counts counts;
	struct mddev *mddev;
	__u64 events_cleared;
	int need_sync;
	struct bitmap_storage storage;
	long unsigned int flags;
	int allclean;
	atomic_t behind_writes;
	long unsigned int behind_writes_used;
	long unsigned int daemon_lastrun;
	long unsigned int last_end_sync;
	atomic_t pending_writes;
	wait_queue_head_t write_wait;
	wait_queue_head_t overflow_wait;
	wait_queue_head_t behind_wait;
	struct kernfs_node *sysfs_can_clear;
	int cluster_slot;
};

struct ip_set;

struct bitmap_ip {
	long unsigned int *members;
	u32 first_ip;
	u32 last_ip;
	u32 elements;
	u32 hosts;
	size_t memsize;
	u8 netmask;
	struct timer_list gc;
	struct ip_set *set;
	unsigned char extensions[0];
};

struct bitmap_ip_adt_elem {
	u16 id;
};

struct bitmap_ip_elem {};

struct bitmap_ipmac {
	long unsigned int *members;
	u32 first_ip;
	u32 last_ip;
	u32 elements;
	size_t memsize;
	struct timer_list gc;
	struct ip_set *set;
	unsigned char extensions[0];
};

struct bitmap_ipmac_adt_elem {
	unsigned char ether[6];
	u16 id;
	u16 add_mac;
};

struct bitmap_ipmac_elem {
	unsigned char ether[6];
	unsigned char filled;
	long: 0;
};

struct md_bitmap_stats;

struct bitmap_operations {
	bool (*enabled)(struct mddev *);
	int (*create)(struct mddev *, int);
	int (*resize)(struct mddev *, sector_t, int, bool);
	int (*load)(struct mddev *);
	void (*destroy)(struct mddev *);
	void (*flush)(struct mddev *);
	void (*write_all)(struct mddev *);
	void (*dirty_bits)(struct mddev *, long unsigned int, long unsigned int);
	void (*unplug)(struct mddev *, bool);
	void (*daemon_work)(struct mddev *);
	void (*start_behind_write)(struct mddev *);
	void (*end_behind_write)(struct mddev *);
	void (*wait_behind_writes)(struct mddev *);
	int (*startwrite)(struct mddev *, sector_t, long unsigned int);
	void (*endwrite)(struct mddev *, sector_t, long unsigned int);
	bool (*start_sync)(struct mddev *, sector_t, sector_t *, bool);
	void (*end_sync)(struct mddev *, sector_t, sector_t *);
	void (*cond_end_sync)(struct mddev *, sector_t, bool);
	void (*close_sync)(struct mddev *);
	void (*update_sb)(void *);
	int (*get_stats)(void *, struct md_bitmap_stats *);
	void (*sync_with_cluster)(struct mddev *, sector_t, sector_t, sector_t, sector_t);
	void * (*get_from_slot)(struct mddev *, int);
	int (*copy_from_slot)(struct mddev *, int, sector_t *, sector_t *, bool);
	void (*set_pages)(void *, long unsigned int);
	void (*free)(void *);
};

struct bitmap_page {
	char *map;
	unsigned int hijacked: 1;
	unsigned int pending: 1;
	unsigned int count: 30;
};

struct bitmap_port {
	long unsigned int *members;
	u16 first_port;
	u16 last_port;
	u32 elements;
	size_t memsize;
	struct timer_list gc;
	struct ip_set *set;
	unsigned char extensions[0];
};

struct bitmap_port_adt_elem {
	u16 id;
};

struct bitmap_port_elem {};

struct bitmap_super_s {
	__le32 magic;
	__le32 version;
	__u8 uuid[16];
	__le64 events;
	__le64 events_cleared;
	__le64 sync_size;
	__le32 state;
	__le32 chunksize;
	__le32 daemon_sleep;
	__le32 write_behind;
	__le32 sectors_reserved;
	__le32 nodes;
	__u8 cluster_name[64];
	__u8 pad[120];
};

typedef struct bitmap_super_s bitmap_super_t;

struct bitmap_unplug_work {
	struct work_struct work;
	struct bitmap *bitmap;
	struct completion *done;
};

struct bitstr {
	unsigned char *buf;
	unsigned char *beg;
	unsigned char *end;
	unsigned char *cur;
	unsigned int bit;
};

struct bl_dev_msg {
	int32_t status;
	uint32_t major;
	uint32_t minor;
};

struct blacklist_entry {
	struct list_head next;
	char *buf;
};

struct blake2b_state {
	u64 h[8];
	u64 t[2];
	u64 f[2];
	u8 buf[128];
	unsigned int buflen;
	unsigned int outlen;
};

struct blake2b_tfm_ctx {
	u8 key[64];
	unsigned int keylen;
};

struct blake2s_state {
	u32 h[8];
	u32 t[2];
	u32 f[2];
	u8 buf[64];
	unsigned int buflen;
	unsigned int outlen;
};

struct blk_crypto_config {
	enum blk_crypto_mode_num crypto_mode;
	unsigned int data_unit_size;
	unsigned int dun_bytes;
};

struct blk_crypto_key {
	struct blk_crypto_config crypto_cfg;
	unsigned int data_unit_size_bits;
	unsigned int size;
	u8 raw[64];
};

struct blk_crypto_profile;

struct blk_crypto_ll_ops {
	int (*keyslot_program)(struct blk_crypto_profile *, const struct blk_crypto_key *, unsigned int);
	int (*keyslot_evict)(struct blk_crypto_profile *, const struct blk_crypto_key *, unsigned int);
};

struct blk_crypto_keyslot;

struct blk_crypto_profile {
	struct blk_crypto_ll_ops ll_ops;
	unsigned int max_dun_bytes_supported;
	unsigned int modes_supported[5];
	struct device *dev;
	unsigned int num_slots;
	struct rw_semaphore lock;
	struct lock_class_key lockdep_key;
	wait_queue_head_t idle_slots_wait_queue;
	struct list_head idle_slots;
	spinlock_t idle_slots_lock;
	struct hlist_head *slot_hashtable;
	unsigned int log_slot_ht_size;
	struct blk_crypto_keyslot *slots;
};

struct blk_expired_data {
	bool has_timedout_rq;
	long unsigned int next;
	long unsigned int timeout_start;
};

struct request;

struct blk_flush_queue {
	spinlock_t mq_flush_lock;
	unsigned int flush_pending_idx: 1;
	unsigned int flush_running_idx: 1;
	blk_status_t rq_status;
	long unsigned int flush_pending_since;
	struct list_head flush_queue[2];
	long unsigned int flush_data_in_flight;
	struct request *flush_rq;
};

struct blk_holder_ops {
	void (*mark_dead)(struct block_device *, bool);
	void (*sync)(struct block_device *);
	int (*freeze)(struct block_device *);
	int (*thaw)(struct block_device *);
};

struct blk_independent_access_range;

struct blk_ia_range_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_independent_access_range *, char *);
};

struct blk_independent_access_range {
	struct kobject kobj;
	sector_t sector;
	sector_t nr_sectors;
};

struct blk_independent_access_ranges {
	struct kobject kobj;
	bool sysfs_registered;
	unsigned int nr_ia_ranges;
	struct blk_independent_access_range ia_range[0];
};

struct blk_integrity {
	unsigned char flags;
	enum blk_integrity_checksum csum_type;
	unsigned char tuple_size;
	unsigned char pi_offset;
	unsigned char interval_exp;
	unsigned char tag_size;
};

struct blk_io_trace {
	__u32 magic;
	__u32 sequence;
	__u64 time;
	__u64 sector;
	__u32 bytes;
	__u32 action;
	__u32 pid;
	__u32 device;
	__u32 cpu;
	__u16 error;
	__u16 pdu_len;
};

struct blk_io_trace_remap {
	__be32 device_from;
	__be32 device_to;
	__be64 sector_from;
};

struct rq_qos_ops;

struct rq_qos {
	const struct rq_qos_ops *ops;
	struct gendisk *disk;
	enum rq_qos_id id;
	struct rq_qos *next;
	struct dentry *debugfs_dir;
};

struct blk_iolatency {
	struct rq_qos rqos;
	struct timer_list timer;
	bool enabled;
	atomic_t enable_cnt;
	struct work_struct enable_work;
};

struct blk_iou_cmd {
	int res;
	bool nowait;
};

struct blk_major_name {
	struct blk_major_name *next;
	int major;
	char name[16];
	void (*probe)(dev_t);
};

struct rq_list;

struct blk_mq_ctx;

struct blk_mq_hw_ctx;

struct blk_mq_alloc_data {
	struct request_queue *q;
	blk_mq_req_flags_t flags;
	unsigned int shallow_depth;
	blk_opf_t cmd_flags;
	req_flags_t rq_flags;
	unsigned int nr_tags;
	struct rq_list *cached_rqs;
	struct blk_mq_ctx *ctx;
	struct blk_mq_hw_ctx *hctx;
};

struct blk_mq_ctxs;

struct blk_mq_ctx {
	struct {
		spinlock_t lock;
		struct list_head rq_lists[3];
		long: 64;
	};
	unsigned int cpu;
	short unsigned int index_hw[3];
	struct blk_mq_hw_ctx *hctxs[3];
	struct request_queue *queue;
	struct blk_mq_ctxs *ctxs;
	struct kobject kobj;
	long: 64;
};

struct blk_mq_ctxs {
	struct kobject kobj;
	struct blk_mq_ctx *queue_ctx;
};

struct seq_operations;

struct blk_mq_debugfs_attr {
	const char *name;
	umode_t mode;
	int (*show)(void *, struct seq_file *);
	ssize_t (*write)(void *, const char *, size_t, loff_t *);
	const struct seq_operations *seq_ops;
};

struct sbitmap_word;

struct sbitmap {
	unsigned int depth;
	unsigned int shift;
	unsigned int map_nr;
	bool round_robin;
	struct sbitmap_word *map;
	unsigned int *alloc_hint;
};

typedef struct wait_queue_entry wait_queue_entry_t;

struct blk_mq_hw_ctx {
	struct {
		spinlock_t lock;
		struct list_head dispatch;
		long unsigned int state;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct delayed_work run_work;
	cpumask_var_t cpumask;
	int next_cpu;
	int next_cpu_batch;
	long unsigned int flags;
	void *sched_data;
	struct request_queue *queue;
	struct blk_flush_queue *fq;
	void *driver_data;
	struct sbitmap ctx_map;
	struct blk_mq_ctx *dispatch_from;
	unsigned int dispatch_busy;
	short unsigned int type;
	short unsigned int nr_ctx;
	struct blk_mq_ctx **ctxs;
	spinlock_t dispatch_wait_lock;
	wait_queue_entry_t dispatch_wait;
	atomic_t wait_index;
	struct blk_mq_tags *tags;
	struct blk_mq_tags *sched_tags;
	unsigned int numa_node;
	unsigned int queue_num;
	atomic_t nr_active;
	struct hlist_node cpuhp_online;
	struct hlist_node cpuhp_dead;
	struct kobject kobj;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct list_head hctx_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blk_mq_hw_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
};

struct blk_mq_queue_data;

struct io_comp_batch;

struct blk_mq_ops {
	blk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);
	void (*commit_rqs)(struct blk_mq_hw_ctx *);
	void (*queue_rqs)(struct rq_list *);
	int (*get_budget)(struct request_queue *);
	void (*put_budget)(struct request_queue *, int);
	void (*set_rq_budget_token)(struct request *, int);
	int (*get_rq_budget_token)(struct request *);
	enum blk_eh_timer_return (*timeout)(struct request *);
	int (*poll)(struct blk_mq_hw_ctx *, struct io_comp_batch *);
	void (*complete)(struct request *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	int (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);
	void (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);
	void (*cleanup_rq)(struct request *);
	bool (*busy)(struct request_queue *);
	void (*map_queues)(struct blk_mq_tag_set *);
	void (*show_rq)(struct seq_file *, struct request *);
};

struct elevator_type;

struct blk_mq_qe_pair {
	struct list_head node;
	struct request_queue *q;
	struct elevator_type *type;
};

struct blk_mq_queue_data {
	struct request *rq;
	bool last;
};

struct sbq_wait_state;

struct sbitmap_queue {
	struct sbitmap sb;
	unsigned int wake_batch;
	atomic_t wake_index;
	struct sbq_wait_state *ws;
	atomic_t ws_active;
	unsigned int min_shallow_depth;
	atomic_t completion_cnt;
	atomic_t wakeup_cnt;
};

struct blk_mq_tags {
	unsigned int nr_tags;
	unsigned int nr_reserved_tags;
	unsigned int active_queues;
	struct sbitmap_queue bitmap_tags;
	struct sbitmap_queue breserved_tags;
	struct request **rqs;
	struct request **static_rqs;
	struct list_head page_list;
	spinlock_t lock;
};

struct rq_list {
	struct request *head;
	struct request *tail;
};

struct blk_plug {
	struct rq_list mq_list;
	struct rq_list cached_rqs;
	u64 cur_ktime;
	short unsigned int nr_ios;
	short unsigned int rq_count;
	bool multiple_queues;
	bool has_elevator;
	struct list_head cb_list;
};

struct blk_plug_cb;

typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);

struct blk_plug_cb {
	struct list_head list;
	blk_plug_cb_fn callback;
	void *data;
};

struct blk_queue_stats {
	struct list_head callbacks;
	spinlock_t lock;
	int accounting;
};

struct blk_rq_stat {
	u64 mean;
	u64 min;
	u64 max;
	u32 nr_samples;
	u64 batch;
};

struct blk_rq_wait {
	struct completion done;
	blk_status_t ret;
};

struct blk_stat_callback {
	struct list_head list;
	struct timer_list timer;
	struct blk_rq_stat *cpu_stat;
	int (*bucket_fn)(const struct request *);
	unsigned int buckets;
	struct blk_rq_stat *stat;
	void (*timer_fn)(struct blk_stat_callback *);
	void *data;
	struct callback_head rcu;
};

struct rchan;

struct blk_trace {
	int trace_state;
	struct rchan *rchan;
	long unsigned int *sequence;
	unsigned char *msg_data;
	u16 act_mask;
	u64 start_lba;
	u64 end_lba;
	u32 pid;
	u32 dev;
	struct dentry *dir;
	struct list_head running_list;
	atomic_t dropped;
};

struct blk_user_trace_setup {
	char name[32];
	__u16 act_mask;
	__u32 buf_size;
	__u32 buf_nr;
	__u64 start_lba;
	__u64 end_lba;
	__u32 pid;
};

struct blk_zone {
	__u64 start;
	__u64 len;
	__u64 wp;
	__u8 type;
	__u8 cond;
	__u8 non_seq;
	__u8 reset;
	__u8 resv[4];
	__u64 capacity;
	__u8 reserved[24];
};

struct cgroup_subsys;

struct cgroup_subsys_state {
	struct cgroup *cgroup;
	struct cgroup_subsys *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state *parent;
	int nr_descendants;
};

struct blkcg_policy_data;

struct blkcg {
	struct cgroup_subsys_state css;
	spinlock_t lock;
	refcount_t online_pin;
	atomic_t congestion_count;
	struct xarray blkg_tree;
	struct blkcg_gq *blkg_hint;
	struct hlist_head blkg_list;
	struct blkcg_policy_data *cpd[6];
	struct list_head all_blkcgs_node;
	struct llist_head *lhead;
	struct list_head cgwb_list;
};

struct blkg_iostat {
	u64 bytes[3];
	u64 ios[3];
};

struct blkg_iostat_set {
	struct u64_stats_sync sync;
	struct blkcg_gq *blkg;
	struct llist_node lnode;
	int lqueued;
	struct blkg_iostat cur;
	struct blkg_iostat last;
};

struct blkg_policy_data;

struct blkcg_gq {
	struct request_queue *q;
	struct list_head q_node;
	struct hlist_node blkcg_node;
	struct blkcg *blkcg;
	struct blkcg_gq *parent;
	struct percpu_ref refcnt;
	bool online;
	struct blkg_iostat_set *iostat_cpu;
	struct blkg_iostat_set iostat;
	struct blkg_policy_data *pd[6];
	spinlock_t async_bio_lock;
	struct bio_list async_bios;
	union {
		struct work_struct async_bio_work;
		struct work_struct free_work;
	};
	atomic_t use_delay;
	atomic64_t delay_nsec;
	atomic64_t delay_start;
	u64 last_delay;
	int last_use;
	struct callback_head callback_head;
};

typedef struct blkcg_policy_data *blkcg_pol_alloc_cpd_fn(gfp_t);

typedef void blkcg_pol_free_cpd_fn(struct blkcg_policy_data *);

typedef struct blkg_policy_data *blkcg_pol_alloc_pd_fn(struct gendisk *, struct blkcg *, gfp_t);

typedef void blkcg_pol_init_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_online_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_offline_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_free_pd_fn(struct blkg_policy_data *);

typedef void blkcg_pol_reset_pd_stats_fn(struct blkg_policy_data *);

typedef void blkcg_pol_stat_pd_fn(struct blkg_policy_data *, struct seq_file *);

struct cftype;

struct blkcg_policy {
	int plid;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	blkcg_pol_alloc_cpd_fn *cpd_alloc_fn;
	blkcg_pol_free_cpd_fn *cpd_free_fn;
	blkcg_pol_alloc_pd_fn *pd_alloc_fn;
	blkcg_pol_init_pd_fn *pd_init_fn;
	blkcg_pol_online_pd_fn *pd_online_fn;
	blkcg_pol_offline_pd_fn *pd_offline_fn;
	blkcg_pol_free_pd_fn *pd_free_fn;
	blkcg_pol_reset_pd_stats_fn *pd_reset_stats_fn;
	blkcg_pol_stat_pd_fn *pd_stat_fn;
};

struct blkcg_policy_data {
	struct blkcg *blkcg;
	int plid;
};

struct blkdev_dio {
	union {
		struct kiocb *iocb;
		struct task_struct *waiter;
	};
	size_t size;
	atomic_t ref;
	unsigned int flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct bio bio;
	long: 64;
};

struct blkg_conf_ctx {
	char *input;
	char *body;
	struct block_device *bdev;
	struct blkcg_gq *blkg;
};

struct blkg_policy_data {
	struct blkcg_gq *blkg;
	int plid;
	bool online;
};

struct blkg_rwstat {
	struct percpu_counter cpu_cnt[5];
	atomic64_t aux_cnt[5];
};

struct blkg_rwstat_sample {
	u64 cnt[5];
};

struct blkpg_ioctl_arg {
	int op;
	int flags;
	int datalen;
	void *data;
};

struct blkpg_partition {
	long long int start;
	long long int length;
	int pno;
	char devname[64];
	char volname[64];
};

typedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);

struct hd_geometry;

struct pr_ops;

struct block_device_operations {
	void (*submit_bio)(struct bio *);
	int (*poll_bio)(struct bio *, struct io_comp_batch *, unsigned int);
	int (*open)(struct gendisk *, blk_mode_t);
	void (*release)(struct gendisk *);
	int (*ioctl)(struct block_device *, blk_mode_t, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct block_device *, blk_mode_t, unsigned int, long unsigned int);
	unsigned int (*check_events)(struct gendisk *, unsigned int);
	void (*unlock_native_capacity)(struct gendisk *);
	int (*getgeo)(struct block_device *, struct hd_geometry *);
	int (*set_read_only)(struct block_device *, bool);
	void (*free_disk)(struct gendisk *);
	void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
	int (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);
	char * (*devnode)(struct gendisk *, umode_t *);
	int (*get_unique_id)(struct gendisk *, u8 *, enum blk_unique_id);
	struct module *owner;
	const struct pr_ops *pr_ops;
	int (*alternative_gpt_sector)(struct gendisk *, sector_t *);
};

struct blockgroup_lock {
	struct bgl_lock locks[128];
};

struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block *head;
};

struct mem_zone_bm_rtree;

struct rtree_node;

struct bm_position {
	struct mem_zone_bm_rtree *zone;
	struct rtree_node *node;
	long unsigned int node_pfn;
	long unsigned int cur_pfn;
	int node_bit;
};

struct bmp_header {
	u16 id;
	u32 size;
} __attribute__((packed));

struct boot_e820_entry {
	__u64 addr;
	__u64 size;
	__u32 type;
} __attribute__((packed));

struct screen_info {
	__u8 orig_x;
	__u8 orig_y;
	__u16 ext_mem_k;
	__u16 orig_video_page;
	__u8 orig_video_mode;
	__u8 orig_video_cols;
	__u8 flags;
	__u8 unused2;
	__u16 orig_video_ega_bx;
	__u16 unused3;
	__u8 orig_video_lines;
	__u8 orig_video_isVGA;
	__u16 orig_video_points;
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u32 lfb_base;
	__u32 lfb_size;
	__u16 cl_magic;
	__u16 cl_offset;
	__u16 lfb_linelength;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
	__u16 vesapm_seg;
	__u16 vesapm_off;
	__u16 pages;
	__u16 vesa_attributes;
	__u32 capabilities;
	__u32 ext_lfb_base;
	__u8 _reserved[2];
} __attribute__((packed));

struct ist_info {
	__u32 signature;
	__u32 command;
	__u32 event;
	__u32 perf_level;
};

struct sys_desc_table {
	__u16 length;
	__u8 table[14];
};

struct olpc_ofw_header {
	__u32 ofw_magic;
	__u32 ofw_version;
	__u32 cif_handler;
	__u32 irq_desc_table;
};

struct edid_info {
	unsigned char dummy[128];
};

struct efi_info {
	__u32 efi_loader_signature;
	__u32 efi_systab;
	__u32 efi_memdesc_size;
	__u32 efi_memdesc_version;
	__u32 efi_memmap;
	__u32 efi_memmap_size;
	__u32 efi_systab_hi;
	__u32 efi_memmap_hi;
};

struct setup_header {
	__u8 setup_sects;
	__u16 root_flags;
	__u32 syssize;
	__u16 ram_size;
	__u16 vid_mode;
	__u16 root_dev;
	__u16 boot_flag;
	__u16 jump;
	__u32 header;
	__u16 version;
	__u32 realmode_swtch;
	__u16 start_sys_seg;
	__u16 kernel_version;
	__u8 type_of_loader;
	__u8 loadflags;
	__u16 setup_move_size;
	__u32 code32_start;
	__u32 ramdisk_image;
	__u32 ramdisk_size;
	__u32 bootsect_kludge;
	__u16 heap_end_ptr;
	__u8 ext_loader_ver;
	__u8 ext_loader_type;
	__u32 cmd_line_ptr;
	__u32 initrd_addr_max;
	__u32 kernel_alignment;
	__u8 relocatable_kernel;
	__u8 min_alignment;
	__u16 xloadflags;
	__u32 cmdline_size;
	__u32 hardware_subarch;
	__u64 hardware_subarch_data;
	__u32 payload_offset;
	__u32 payload_length;
	__u64 setup_data;
	__u64 pref_address;
	__u32 init_size;
	__u32 handover_offset;
	__u32 kernel_info_offset;
} __attribute__((packed));

struct edd_device_params {
	__u16 length;
	__u16 info_flags;
	__u32 num_default_cylinders;
	__u32 num_default_heads;
	__u32 sectors_per_track;
	__u64 number_of_sectors;
	__u16 bytes_per_sector;
	__u32 dpte_ptr;
	__u16 key;
	__u8 device_path_info_length;
	__u8 reserved2;
	__u16 reserved3;
	__u8 host_bus_type[4];
	__u8 interface_type[8];
	union {
		struct {
			__u16 base_address;
			__u16 reserved1;
			__u32 reserved2;
		} isa;
		struct {
			__u8 bus;
			__u8 slot;
			__u8 function;
			__u8 channel;
			__u32 reserved;
		} pci;
		struct {
			__u64 reserved;
		} ibnd;
		struct {
			__u64 reserved;
		} xprs;
		struct {
			__u64 reserved;
		} htpt;
		struct {
			__u64 reserved;
		} unknown;
	} interface_path;
	union {
		struct {
			__u8 device;
			__u8 reserved1;
			__u16 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} ata;
		struct {
			__u8 device;
			__u8 lun;
			__u8 reserved1;
			__u8 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} atapi;
		struct {
			__u16 id;
			__u64 lun;
			__u16 reserved1;
			__u32 reserved2;
		} __attribute__((packed)) scsi;
		struct {
			__u64 serial_number;
			__u64 reserved;
		} usb;
		struct {
			__u64 eui;
			__u64 reserved;
		} i1394;
		struct {
			__u64 wwid;
			__u64 lun;
		} fibre;
		struct {
			__u64 identity_tag;
			__u64 reserved;
		} i2o;
		struct {
			__u32 array_number;
			__u32 reserved1;
			__u64 reserved2;
		} raid;
		struct {
			__u8 device;
			__u8 reserved1;
			__u16 reserved2;
			__u32 reserved3;
			__u64 reserved4;
		} sata;
		struct {
			__u64 reserved1;
			__u64 reserved2;
		} unknown;
	} device_path;
	__u8 reserved4;
	__u8 checksum;
} __attribute__((packed));

struct edd_info {
	__u8 device;
	__u8 version;
	__u16 interface_support;
	__u16 legacy_max_cylinder;
	__u8 legacy_max_head;
	__u8 legacy_sectors_per_track;
	struct edd_device_params params;
};

struct boot_params {
	struct screen_info screen_info;
	struct apm_bios_info apm_bios_info;
	__u8 _pad2[4];
	__u64 tboot_addr;
	struct ist_info ist_info;
	__u64 acpi_rsdp_addr;
	__u8 _pad3[8];
	__u8 hd0_info[16];
	__u8 hd1_info[16];
	struct sys_desc_table sys_desc_table;
	struct olpc_ofw_header olpc_ofw_header;
	__u32 ext_ramdisk_image;
	__u32 ext_ramdisk_size;
	__u32 ext_cmd_line_ptr;
	__u8 _pad4[112];
	__u32 cc_blob_address;
	struct edid_info edid_info;
	struct efi_info efi_info;
	__u32 alt_mem_k;
	__u32 scratch;
	__u8 e820_entries;
	__u8 eddbuf_entries;
	__u8 edd_mbr_sig_buf_entries;
	__u8 kbd_status;
	__u8 secure_boot;
	__u8 _pad5[2];
	__u8 sentinel;
	__u8 _pad6[1];
	struct setup_header hdr;
	__u8 _pad7[36];
	__u32 edd_mbr_sig_buffer[16];
	struct boot_e820_entry e820_table[128];
	__u8 _pad8[48];
	struct edd_info eddbuf[6];
	__u8 _pad9[276];
};

struct boot_params_to_save {
	unsigned int start;
	unsigned int len;
};

struct boot_triggers {
	const char *event;
	char *trigger;
};

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
		};
		struct {
			__be32 saddr;
			__be32 daddr;
		} addrs;
	};
};

struct udphdr {
	__be16 source;
	__be16 dest;
	__be16 len;
	__sum16 check;
};

struct bootp_pkt {
	struct iphdr iph;
	struct udphdr udph;
	u8 op;
	u8 htype;
	u8 hlen;
	u8 hops;
	__be32 xid;
	__be16 secs;
	__be16 flags;
	__be32 client_ip;
	__be32 your_ip;
	__be32 server_ip;
	__be32 relay_ip;
	u8 hw_addr[16];
	u8 serv_name[64];
	u8 boot_file[128];
	u8 exten[312];
};

struct bp_slots_histogram {
	atomic_t count[4];
};

struct bp_cpuinfo {
	unsigned int cpu_pinned;
	struct bp_slots_histogram tsk_pinned;
};

struct text_poke_loc;

struct bp_patching_desc {
	struct text_poke_loc *vec;
	int nr_entries;
	atomic_t refs;
};

struct bpf_map_ops;

struct btf_record;

struct btf;

struct obj_cgroup;

struct btf_type;

struct bpf_map {
	const struct bpf_map_ops *ops;
	struct bpf_map *inner_map_meta;
	void *security;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u64 map_extra;
	u32 map_flags;
	u32 id;
	struct btf_record *record;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	u32 btf_vmlinux_value_type_id;
	struct btf *btf;
	struct obj_cgroup *objcg;
	char name[16];
	struct mutex freeze_mutex;
	atomic64_t refcnt;
	atomic64_t usercnt;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
	atomic64_t writecnt;
	struct {
		const struct btf_type *attach_func_proto;
		spinlock_t lock;
		enum bpf_prog_type type;
		bool jited;
		bool xdp_has_frags;
	} owner;
	bool bypass_spec_v1;
	bool frozen;
	bool free_after_mult_rcu_gp;
	bool free_after_rcu_gp;
	atomic64_t sleepable_refcnt;
	s64 *elem_count;
};

struct range_tree {
	struct rb_root_cached it_root;
	struct rb_root_cached range_size_root;
};

struct vm_struct;

struct bpf_arena {
	struct bpf_map map;
	u64 user_vm_start;
	u64 user_vm_end;
	struct vm_struct *kern_vm;
	struct range_tree rt;
	struct list_head vma_list;
	struct mutex lock;
};

struct bpf_array_aux;

struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	union {
		struct {
			struct {} __empty_value;
			char value[0];
		};
		struct {
			struct {} __empty_ptrs;
			void *ptrs[0];
		};
		struct {
			struct {} __empty_pptrs;
			void *pptrs[0];
		};
	};
};

struct bpf_array_aux {
	struct list_head poke_progs;
	struct bpf_map *map;
	struct mutex poke_mutex;
	struct work_struct work;
};

struct bpf_prog;

struct bpf_async_cb {
	struct bpf_map *map;
	struct bpf_prog *prog;
	void *callback_fn;
	void *value;
	union {
		struct callback_head rcu;
		struct work_struct delete_work;
	};
	u64 flags;
};

struct bpf_spin_lock {
	__u32 val;
};

struct bpf_hrtimer;

struct bpf_work;

struct bpf_async_kern {
	union {
		struct bpf_async_cb *cb;
		struct bpf_hrtimer *timer;
		struct bpf_work *work;
	};
	struct bpf_spin_lock lock;
};

struct btf_func_model {
	u8 ret_size;
	u8 ret_flags;
	u8 nr_args;
	u8 arg_size[12];
	u8 arg_flags[12];
};

struct bpf_attach_target_info {
	struct btf_func_model fmodel;
	long int tgt_addr;
	struct module *tgt_mod;
	const char *tgt_name;
	const struct btf_type *tgt_type;
};

union bpf_attr {
	struct {
		__u32 map_type;
		__u32 key_size;
		__u32 value_size;
		__u32 max_entries;
		__u32 map_flags;
		__u32 inner_map_fd;
		__u32 numa_node;
		char map_name[16];
		__u32 map_ifindex;
		__u32 btf_fd;
		__u32 btf_key_type_id;
		__u32 btf_value_type_id;
		__u32 btf_vmlinux_value_type_id;
		__u64 map_extra;
		__s32 value_type_btf_obj_fd;
		__s32 map_token_fd;
	};
	struct {
		__u32 map_fd;
		__u64 key;
		union {
			__u64 value;
			__u64 next_key;
		};
		__u64 flags;
	};
	struct {
		__u64 in_batch;
		__u64 out_batch;
		__u64 keys;
		__u64 values;
		__u32 count;
		__u32 map_fd;
		__u64 elem_flags;
		__u64 flags;
	} batch;
	struct {
		__u32 prog_type;
		__u32 insn_cnt;
		__u64 insns;
		__u64 license;
		__u32 log_level;
		__u32 log_size;
		__u64 log_buf;
		__u32 kern_version;
		__u32 prog_flags;
		char prog_name[16];
		__u32 prog_ifindex;
		__u32 expected_attach_type;
		__u32 prog_btf_fd;
		__u32 func_info_rec_size;
		__u64 func_info;
		__u32 func_info_cnt;
		__u32 line_info_rec_size;
		__u64 line_info;
		__u32 line_info_cnt;
		__u32 attach_btf_id;
		union {
			__u32 attach_prog_fd;
			__u32 attach_btf_obj_fd;
		};
		__u32 core_relo_cnt;
		__u64 fd_array;
		__u64 core_relos;
		__u32 core_relo_rec_size;
		__u32 log_true_size;
		__s32 prog_token_fd;
		__u32 fd_array_cnt;
	};
	struct {
		__u64 pathname;
		__u32 bpf_fd;
		__u32 file_flags;
		__s32 path_fd;
	};
	struct {
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_bpf_fd;
		__u32 attach_type;
		__u32 attach_flags;
		__u32 replace_bpf_fd;
		union {
			__u32 relative_fd;
			__u32 relative_id;
		};
		__u64 expected_revision;
	};
	struct {
		__u32 prog_fd;
		__u32 retval;
		__u32 data_size_in;
		__u32 data_size_out;
		__u64 data_in;
		__u64 data_out;
		__u32 repeat;
		__u32 duration;
		__u32 ctx_size_in;
		__u32 ctx_size_out;
		__u64 ctx_in;
		__u64 ctx_out;
		__u32 flags;
		__u32 cpu;
		__u32 batch_size;
	} test;
	struct {
		union {
			__u32 start_id;
			__u32 prog_id;
			__u32 map_id;
			__u32 btf_id;
			__u32 link_id;
		};
		__u32 next_id;
		__u32 open_flags;
	};
	struct {
		__u32 bpf_fd;
		__u32 info_len;
		__u64 info;
	} info;
	struct {
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 query_flags;
		__u32 attach_flags;
		__u64 prog_ids;
		union {
			__u32 prog_cnt;
			__u32 count;
		};
		__u64 prog_attach_flags;
		__u64 link_ids;
		__u64 link_attach_flags;
		__u64 revision;
	} query;
	struct {
		__u64 name;
		__u32 prog_fd;
		__u64 cookie;
	} raw_tracepoint;
	struct {
		__u64 btf;
		__u64 btf_log_buf;
		__u32 btf_size;
		__u32 btf_log_size;
		__u32 btf_log_level;
		__u32 btf_log_true_size;
		__u32 btf_flags;
		__s32 btf_token_fd;
	};
	struct {
		__u32 pid;
		__u32 fd;
		__u32 flags;
		__u32 buf_len;
		__u64 buf;
		__u32 prog_id;
		__u32 fd_type;
		__u64 probe_offset;
		__u64 probe_addr;
	} task_fd_query;
	struct {
		union {
			__u32 prog_fd;
			__u32 map_fd;
		};
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 flags;
		union {
			__u32 target_btf_id;
			struct {
				__u64 iter_info;
				__u32 iter_info_len;
			};
			struct {
				__u64 bpf_cookie;
			} perf_event;
			struct {
				__u32 flags;
				__u32 cnt;
				__u64 syms;
				__u64 addrs;
				__u64 cookies;
			} kprobe_multi;
			struct {
				__u32 target_btf_id;
				__u64 cookie;
			} tracing;
			struct {
				__u32 pf;
				__u32 hooknum;
				__s32 priority;
				__u32 flags;
			} netfilter;
			struct {
				union {
					__u32 relative_fd;
					__u32 relative_id;
				};
				__u64 expected_revision;
			} tcx;
			struct {
				__u64 path;
				__u64 offsets;
				__u64 ref_ctr_offsets;
				__u64 cookies;
				__u32 cnt;
				__u32 flags;
				__u32 pid;
			} uprobe_multi;
			struct {
				union {
					__u32 relative_fd;
					__u32 relative_id;
				};
				__u64 expected_revision;
			} netkit;
		};
	} link_create;
	struct {
		__u32 link_fd;
		union {
			__u32 new_prog_fd;
			__u32 new_map_fd;
		};
		__u32 flags;
		union {
			__u32 old_prog_fd;
			__u32 old_map_fd;
		};
	} link_update;
	struct {
		__u32 link_fd;
	} link_detach;
	struct {
		__u32 type;
	} enable_stats;
	struct {
		__u32 link_fd;
		__u32 flags;
	} iter_create;
	struct {
		__u32 prog_fd;
		__u32 map_fd;
		__u32 flags;
	} prog_bind_map;
	struct {
		__u32 flags;
		__u32 bpffs_fd;
	} token_create;
};

struct bpf_binary_header {
	u32 size;
	long: 0;
	u8 image[0];
};

struct bpf_bloom_filter {
	struct bpf_map map;
	u32 bitset_mask;
	u32 hash_seed;
	u32 nr_hash_funcs;
	long unsigned int bitset[0];
};

struct bpf_bprintf_buffers {
	char bin_args[512];
	char buf[1024];
};

struct bpf_bprintf_data {
	u32 *bin_args;
	char *buf;
	bool get_bin_args;
	bool get_buf;
};

struct bpf_btf_info {
	__u64 btf;
	__u32 btf_size;
	__u32 id;
	__u64 name;
	__u32 name_len;
	__u32 kernel_btf;
};

struct btf_field;

struct bpf_call_arg_meta {
	struct bpf_map *map_ptr;
	bool raw_mode;
	bool pkt_access;
	u8 release_regno;
	int regno;
	int access_size;
	int mem_size;
	u64 msize_max_value;
	int ref_obj_id;
	int dynptr_id;
	int map_uid;
	int func_id;
	struct btf *btf;
	u32 btf_id;
	struct btf *ret_btf;
	u32 ret_btf_id;
	u32 subprogno;
	struct btf_field *kptr_field;
	s64 const_map_key;
};

struct bpf_cand_cache {
	const char *name;
	u32 name_len;
	u16 kind;
	u16 cnt;
	struct {
		const struct btf *btf;
		u32 id;
	} cands[0];
};

struct bpf_run_ctx {};

struct bpf_prog_array_item;

struct bpf_cg_run_ctx {
	struct bpf_run_ctx run_ctx;
	const struct bpf_prog_array_item *prog_item;
	int retval;
};

struct bpf_cgroup_dev_ctx {
	__u32 access_type;
	__u32 major;
	__u32 minor;
};

struct bpf_link_ops;

struct bpf_link {
	atomic64_t refcnt;
	u32 id;
	enum bpf_link_type type;
	const struct bpf_link_ops *ops;
	struct bpf_prog *prog;
	bool sleepable;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct bpf_cgroup_link {
	struct bpf_link link;
	struct cgroup *cgroup;
	enum bpf_attach_type type;
};

struct bpf_cgroup_storage_key {
	__u64 cgroup_inode_id;
	__u32 attach_type;
};

struct bpf_storage_buffer;

struct bpf_cgroup_storage_map;

struct bpf_cgroup_storage {
	union {
		struct bpf_storage_buffer *buf;
		void *percpu_buf;
	};
	struct bpf_cgroup_storage_map *map;
	struct bpf_cgroup_storage_key key;
	struct list_head list_map;
	struct list_head list_cg;
	struct rb_node node;
	struct callback_head rcu;
};

struct bpf_cgroup_storage_map {
	struct bpf_map map;
	spinlock_t lock;
	struct rb_root root;
	struct list_head list;
};

struct bpf_lru_list {
	struct list_head lists[3];
	unsigned int counts[2];
	struct list_head *next_inactive_rotation;
	raw_spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_lru_locallist;

struct bpf_common_lru {
	struct bpf_lru_list lru_list;
	struct bpf_lru_locallist *local_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_core_accessor {
	__u32 type_id;
	__u32 idx;
	const char *name;
};

struct bpf_core_cand {
	const struct btf *btf;
	__u32 id;
};

struct bpf_core_cand_list {
	struct bpf_core_cand *cands;
	int len;
};

struct bpf_verifier_log;

struct bpf_core_ctx {
	struct bpf_verifier_log *log;
	const struct btf *btf;
};

struct bpf_core_relo {
	__u32 insn_off;
	__u32 type_id;
	__u32 access_str_off;
	enum bpf_core_relo_kind kind;
};

struct bpf_core_relo_res {
	__u64 orig_val;
	__u64 new_val;
	bool poison;
	bool validate;
	bool fail_memsz_adjust;
	__u32 orig_sz;
	__u32 orig_type_id;
	__u32 new_sz;
	__u32 new_type_id;
};

struct bpf_core_spec {
	const struct btf *btf;
	struct bpf_core_accessor spec[64];
	__u32 root_type_id;
	enum bpf_core_relo_kind relo_kind;
	int len;
	int raw_spec[64];
	int raw_len;
	__u32 bit_offset;
};

struct bpf_cpu_map_entry;

struct bpf_cpu_map {
	struct bpf_map map;
	struct bpf_cpu_map_entry **cpu_map;
};

struct bpf_cpumap_val {
	__u32 qsize;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

struct xdp_bulk_queue;

struct ptr_ring;

struct bpf_cpu_map_entry {
	u32 cpu;
	int map_id;
	struct xdp_bulk_queue *bulkq;
	struct ptr_ring *queue;
	struct task_struct *kthread;
	struct bpf_cpumap_val value;
	struct bpf_prog *prog;
	struct completion kthread_running;
	struct rcu_work free_work;
};

struct bpf_cpumask {
	cpumask_t cpumask;
	refcount_t usage;
};

struct bpf_crypto_type;

struct bpf_crypto_ctx {
	const struct bpf_crypto_type *type;
	void *tfm;
	u32 siv_len;
	struct callback_head rcu;
	refcount_t usage;
};

struct bpf_crypto_params {
	char type[14];
	u8 reserved[2];
	char algo[128];
	u8 key[256];
	u32 key_len;
	u32 authsize;
};

struct bpf_crypto_type {
	void * (*alloc_tfm)(const char *);
	void (*free_tfm)(void *);
	int (*has_algo)(const char *);
	int (*setkey)(void *, const u8 *, unsigned int);
	int (*setauthsize)(void *, unsigned int);
	int (*encrypt)(void *, const u8 *, u8 *, unsigned int, u8 *);
	int (*decrypt)(void *, const u8 *, u8 *, unsigned int, u8 *);
	unsigned int (*ivsize)(void *);
	unsigned int (*statesize)(void *);
	u32 (*get_flags)(void *);
	struct module *owner;
	char name[14];
};

struct bpf_crypto_type_list {
	const struct bpf_crypto_type *type;
	struct list_head list;
};

struct bpf_ct_opts {
	s32 netns_id;
	s32 error;
	u8 l4proto;
	u8 dir;
	u16 ct_zone_id;
	u8 ct_zone_dir;
	u8 reserved[3];
};

struct bpf_ctx_arg_aux {
	u32 offset;
	enum bpf_reg_type reg_type;
	struct btf *btf;
	u32 btf_id;
};

struct skb_ext;

struct sk_buff {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
			union {
				struct net_device *dev;
				long unsigned int dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
		struct llist_node ll_node;
	};
	struct sock *sk;
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			long unsigned int _skb_refdst;
			void (*destructor)(struct sk_buff *);
		};
		struct list_head tcp_tsorted_anchor;
		long unsigned int _sk_redir;
	};
	long unsigned int _nfct;
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u8 pp_recycle: 1;
	__u8 active_extensions;
	union {
		struct {
			__u8 __pkt_type_offset[0];
			__u8 pkt_type: 3;
			__u8 ignore_df: 1;
			__u8 dst_pending_confirm: 1;
			__u8 ip_summed: 2;
			__u8 ooo_okay: 1;
			__u8 __mono_tc_offset[0];
			__u8 tstamp_type: 2;
			__u8 tc_at_ingress: 1;
			__u8 tc_skip_classify: 1;
			__u8 remcsum_offload: 1;
			__u8 csum_complete_sw: 1;
			__u8 csum_level: 2;
			__u8 inner_protocol_type: 1;
			__u8 l4_hash: 1;
			__u8 sw_hash: 1;
			__u8 wifi_acked_valid: 1;
			__u8 wifi_acked: 1;
			__u8 no_fcs: 1;
			__u8 encapsulation: 1;
			__u8 encap_hdr_csum: 1;
			__u8 csum_valid: 1;
			__u8 ndisc_nodetype: 2;
			__u8 ipvs_property: 1;
			__u8 nf_trace: 1;
			__u8 redirected: 1;
			__u8 nf_skip_egress: 1;
			__u8 slow_gro: 1;
			__u8 csum_not_inet: 1;
			__u8 unreadable: 1;
			__u16 tc_index;
			u16 alloc_cpu;
			union {
				__wsum csum;
				struct {
					__u16 csum_start;
					__u16 csum_offset;
				};
			};
			__u32 priority;
			int skb_iif;
			__u32 hash;
			union {
				u32 vlan_all;
				struct {
					__be16 vlan_proto;
					__u16 vlan_tci;
				};
			};
			union {
				unsigned int napi_id;
				unsigned int sender_cpu;
			};
			__u32 secmark;
			union {
				__u32 mark;
				__u32 reserved_tailroom;
			};
			union {
				__be16 inner_protocol;
				__u8 inner_ipproto;
			};
			__u16 inner_transport_header;
			__u16 inner_network_header;
			__u16 inner_mac_header;
			__be16 protocol;
			__u16 transport_header;
			__u16 network_header;
			__u16 mac_header;
		};
		struct {
			__u8 __pkt_type_offset[0];
			__u8 pkt_type: 3;
			__u8 ignore_df: 1;
			__u8 dst_pending_confirm: 1;
			__u8 ip_summed: 2;
			__u8 ooo_okay: 1;
			__u8 __mono_tc_offset[0];
			__u8 tstamp_type: 2;
			__u8 tc_at_ingress: 1;
			__u8 tc_skip_classify: 1;
			__u8 remcsum_offload: 1;
			__u8 csum_complete_sw: 1;
			__u8 csum_level: 2;
			__u8 inner_protocol_type: 1;
			__u8 l4_hash: 1;
			__u8 sw_hash: 1;
			__u8 wifi_acked_valid: 1;
			__u8 wifi_acked: 1;
			__u8 no_fcs: 1;
			__u8 encapsulation: 1;
			__u8 encap_hdr_csum: 1;
			__u8 csum_valid: 1;
			__u8 ndisc_nodetype: 2;
			__u8 ipvs_property: 1;
			__u8 nf_trace: 1;
			__u8 redirected: 1;
			__u8 nf_skip_egress: 1;
			__u8 slow_gro: 1;
			__u8 csum_not_inet: 1;
			__u8 unreadable: 1;
			__u16 tc_index;
			u16 alloc_cpu;
			union {
				__wsum csum;
				struct {
					__u16 csum_start;
					__u16 csum_offset;
				};
			};
			__u32 priority;
			int skb_iif;
			__u32 hash;
			union {
				u32 vlan_all;
				struct {
					__be16 vlan_proto;
					__u16 vlan_tci;
				};
			};
			union {
				unsigned int napi_id;
				unsigned int sender_cpu;
			};
			__u32 secmark;
			union {
				__u32 mark;
				__u32 reserved_tailroom;
			};
			union {
				__be16 inner_protocol;
				__u8 inner_ipproto;
			};
			__u16 inner_transport_header;
			__u16 inner_network_header;
			__u16 inner_mac_header;
			__be16 protocol;
			__u16 transport_header;
			__u16 network_header;
			__u16 mac_header;
		} headers;
	};
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
	struct skb_ext *extensions;
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
	__u32 egress_ifindex;
};

struct xdp_rxq_info;

struct xdp_txq_info;

struct xdp_buff {
	void *data;
	void *data_end;
	void *data_meta;
	void *data_hard_start;
	struct xdp_rxq_info *rxq;
	struct xdp_txq_info *txq;
	u32 frame_sz;
	u32 flags;
};

struct bpf_sock {
	__u32 bound_dev_if;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 mark;
	__u32 priority;
	__u32 src_ip4;
	__u32 src_ip6[4];
	__u32 src_port;
	__be16 dst_port;
	__u32 dst_ip4;
	__u32 dst_ip6[4];
	__u32 state;
	__s32 rx_queue_mapping;
};

struct bpf_sock_addr {
	__u32 user_family;
	__u32 user_ip4;
	__u32 user_ip6[4];
	__u32 user_port;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 msg_src_ip4;
	__u32 msg_src_ip6[4];
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_sock_addr_kern {
	struct sock *sk;
	struct sockaddr *uaddr;
	u64 tmp_reg;
	void *t_ctx;
	u32 uaddrlen;
};

struct bpf_sock_ops {
	__u32 op;
	union {
		__u32 args[4];
		__u32 reply;
		__u32 replylong[4];
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 is_fullsock;
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 bpf_sock_ops_cb_flags;
	__u32 state;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u32 sk_txhash;
	__u64 bytes_received;
	__u64 bytes_acked;
	union {
		struct bpf_sock *sk;
	};
	union {
		void *skb_data;
	};
	union {
		void *skb_data_end;
	};
	__u32 skb_len;
	__u32 skb_tcp_flags;
	__u64 skb_hwtstamp;
};

struct bpf_sock_ops_kern {
	struct sock *sk;
	union {
		u32 args[4];
		u32 reply;
		u32 replylong[4];
	};
	struct sk_buff *syn_skb;
	struct sk_buff *skb;
	void *skb_data_end;
	u8 op;
	u8 is_fullsock;
	u8 remaining_opt_len;
	u64 temp;
};

struct sk_msg_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 size;
	union {
		struct bpf_sock *sk;
	};
};

struct sk_msg_sg {
	u32 start;
	u32 curr;
	u32 end;
	u32 size;
	u32 copybreak;
	long unsigned int copy[1];
	struct scatterlist data[19];
};

struct sk_msg {
	struct sk_msg_sg sg;
	void *data;
	void *data_end;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 flags;
	struct sk_buff *skb;
	struct sock *sk_redir;
	struct sock *sk;
	struct list_head list;
};

struct bpf_flow_dissector {
	struct bpf_flow_keys *flow_keys;
	const struct sk_buff *skb;
	const void *data;
	const void *data_end;
};

struct fred_cs {
	u64 cs: 16;
	u64 sl: 2;
	u64 wfe: 1;
};

struct fred_ss {
	u64 ss: 16;
	u64 sti: 1;
	u64 swevent: 1;
	u64 nmi: 1;
	int: 13;
	u64 vector: 8;
	short: 8;
	u64 type: 4;
	char: 4;
	u64 enclave: 1;
	u64 lm: 1;
	u64 nested: 1;
	char: 1;
	u64 insnlen: 4;
};

struct pt_regs {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bp;
	long unsigned int bx;
	long unsigned int r11;
	long unsigned int r10;
	long unsigned int r9;
	long unsigned int r8;
	long unsigned int ax;
	long unsigned int cx;
	long unsigned int dx;
	long unsigned int si;
	long unsigned int di;
	long unsigned int orig_ax;
	long unsigned int ip;
	union {
		u16 cs;
		u64 csx;
		struct fred_cs fred_cs;
	};
	long unsigned int flags;
	long unsigned int sp;
	union {
		u16 ss;
		u64 ssx;
		struct fred_ss fred_ss;
	};
};

typedef struct pt_regs bpf_user_pt_regs_t;

struct bpf_perf_event_data {
	bpf_user_pt_regs_t regs;
	__u64 sample_period;
	__u64 addr;
};

struct perf_sample_data;

struct bpf_perf_event_data_kern {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event *event;
};

struct bpf_raw_tracepoint_args {
	__u64 args[0];
};

struct bpf_sysctl {
	__u32 write;
	__u32 file_pos;
};

struct ctl_table_header;

struct ctl_table;

struct bpf_sysctl_kern {
	struct ctl_table_header *head;
	const struct ctl_table *table;
	void *cur_val;
	size_t cur_len;
	void *new_val;
	size_t new_len;
	int new_updated;
	int write;
	loff_t *ppos;
	u64 tmp_reg;
};

struct bpf_sockopt {
	union {
		struct bpf_sock *sk;
	};
	union {
		void *optval;
	};
	union {
		void *optval_end;
	};
	__s32 level;
	__s32 optname;
	__s32 optlen;
	__s32 retval;
};

struct bpf_sockopt_kern {
	struct sock *sk;
	u8 *optval;
	u8 *optval_end;
	s32 level;
	s32 optname;
	s32 optlen;
	struct task_struct *current_task;
	u64 tmp_reg;
};

struct sk_reuseport_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 len;
	__u32 eth_protocol;
	__u32 ip_protocol;
	__u32 bind_inany;
	__u32 hash;
	union {
		struct bpf_sock *sk;
	};
	union {
		struct bpf_sock *migrating_sk;
	};
};

struct sk_reuseport_kern {
	struct sk_buff *skb;
	struct sock *sk;
	struct sock *selected_sk;
	struct sock *migrating_sk;
	void *data_end;
	u32 hash;
	u32 reuseport_id;
	bool bind_inany;
};

struct bpf_sk_lookup {
	union {
		union {
			struct bpf_sock *sk;
		};
		__u64 cookie;
	};
	__u32 family;
	__u32 protocol;
	__u32 remote_ip4;
	__u32 remote_ip6[4];
	__be16 remote_port;
	__u32 local_ip4;
	__u32 local_ip6[4];
	__u32 local_port;
	__u32 ingress_ifindex;
};

struct bpf_sk_lookup_kern {
	u16 family;
	u16 protocol;
	__be16 sport;
	u16 dport;
	struct {
		__be32 saddr;
		__be32 daddr;
	} v4;
	struct {
		const struct in6_addr *saddr;
		const struct in6_addr *daddr;
	} v6;
	struct sock *selected_sk;
	u32 ingress_ifindex;
	bool no_reuseport;
};

struct nf_hook_state;

struct bpf_nf_ctx {
	const struct nf_hook_state *state;
	struct sk_buff *skb;
};

struct bpf_ctx_convert {
	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
	struct xdp_md BPF_PROG_TYPE_XDP_prog;
	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
	struct __sk_buff BPF_PROG_TYPE_CGROUP_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_CGROUP_SKB_kern;
	struct bpf_sock BPF_PROG_TYPE_CGROUP_SOCK_prog;
	struct sock BPF_PROG_TYPE_CGROUP_SOCK_kern;
	struct bpf_sock_addr BPF_PROG_TYPE_CGROUP_SOCK_ADDR_prog;
	struct bpf_sock_addr_kern BPF_PROG_TYPE_CGROUP_SOCK_ADDR_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
	void *BPF_PROG_TYPE_TRACING_prog;
	void *BPF_PROG_TYPE_TRACING_kern;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_prog;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_kern;
	struct bpf_sysctl BPF_PROG_TYPE_CGROUP_SYSCTL_prog;
	struct bpf_sysctl_kern BPF_PROG_TYPE_CGROUP_SYSCTL_kern;
	struct bpf_sockopt BPF_PROG_TYPE_CGROUP_SOCKOPT_prog;
	struct bpf_sockopt_kern BPF_PROG_TYPE_CGROUP_SOCKOPT_kern;
	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
	void *BPF_PROG_TYPE_STRUCT_OPS_prog;
	void *BPF_PROG_TYPE_STRUCT_OPS_kern;
	void *BPF_PROG_TYPE_EXT_prog;
	void *BPF_PROG_TYPE_EXT_kern;
	void *BPF_PROG_TYPE_LSM_prog;
	void *BPF_PROG_TYPE_LSM_kern;
	void *BPF_PROG_TYPE_SYSCALL_prog;
	void *BPF_PROG_TYPE_SYSCALL_kern;
	struct bpf_nf_ctx BPF_PROG_TYPE_NETFILTER_prog;
	struct bpf_nf_ctx BPF_PROG_TYPE_NETFILTER_kern;
};

struct bpf_devmap_val {
	__u32 ifindex;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

struct bpf_dispatcher_prog {
	struct bpf_prog *prog;
	refcount_t users;
};

struct latch_tree_node {
	struct rb_node node[2];
};

struct bpf_ksym {
	long unsigned int start;
	long unsigned int end;
	char name[512];
	struct list_head lnode;
	struct latch_tree_node tnode;
	bool prog;
};

struct static_call_key;

struct bpf_dispatcher {
	struct mutex mutex;
	void *func;
	struct bpf_dispatcher_prog progs[48];
	int num_progs;
	void *image;
	void *rw_image;
	u32 image_off;
	struct bpf_ksym ksym;
	struct static_call_key *sc_key;
	void *sc_tramp;
};

struct bpf_dtab_netdev;

struct bpf_dtab {
	struct bpf_map map;
	struct bpf_dtab_netdev **netdev_map;
	struct list_head list;
	struct hlist_head *dev_index_head;
	spinlock_t index_lock;
	unsigned int items;
	u32 n_buckets;
};

struct bpf_dtab_netdev {
	struct net_device *dev;
	struct hlist_node index_hlist;
	struct bpf_prog *xdp_prog;
	struct callback_head rcu;
	unsigned int idx;
	struct bpf_devmap_val val;
};

struct bpf_dummy_ops_state;

struct bpf_dummy_ops {
	int (*test_1)(struct bpf_dummy_ops_state *);
	int (*test_2)(struct bpf_dummy_ops_state *, int, short unsigned int, char, long unsigned int);
	int (*test_sleepable)(struct bpf_dummy_ops_state *);
};

struct bpf_dummy_ops_state {
	int val;
};

struct bpf_dummy_ops_test_args {
	u64 args[12];
	struct bpf_dummy_ops_state state;
};

struct bpf_dynptr {
	__u64 __opaque[2];
};

struct bpf_dynptr_kern {
	void *data;
	u32 size;
	u32 offset;
};

struct bpf_prog_array_item {
	struct bpf_prog *prog;
	union {
		struct bpf_cgroup_storage *cgroup_storage[2];
		u64 bpf_cookie;
	};
};

struct bpf_prog_array {
	struct callback_head rcu;
	struct bpf_prog_array_item items[0];
};

struct bpf_empty_prog_array {
	struct bpf_prog_array hdr;
	struct bpf_prog *null_prog;
};

struct bpf_event_entry {
	struct perf_event *event;
	struct file *perf_file;
	struct file *map_file;
	struct callback_head rcu;
};

struct bpf_fentry_test_t {
	struct bpf_fentry_test_t *a;
};

struct bpf_fib_lookup {
	__u8 family;
	__u8 l4_protocol;
	__be16 sport;
	__be16 dport;
	union {
		__u16 tot_len;
		__u16 mtu_result;
	};
	__u32 ifindex;
	union {
		__u8 tos;
		__be32 flowinfo;
		__u32 rt_metric;
	};
	union {
		__be32 ipv4_src;
		__u32 ipv6_src[4];
	};
	union {
		__be32 ipv4_dst;
		__u32 ipv6_dst[4];
	};
	union {
		struct {
			__be16 h_vlan_proto;
			__be16 h_vlan_TCI;
		};
		__u32 tbid;
	};
	union {
		struct {
			__u32 mark;
		};
		struct {
			__u8 smac[6];
			__u8 dmac[6];
		};
	};
};

struct bpf_flow_keys {
	__u16 nhoff;
	__u16 thoff;
	__u16 addr_proto;
	__u8 is_frag;
	__u8 is_first_frag;
	__u8 is_encap;
	__u8 ip_proto;
	__be16 n_proto;
	__be16 sport;
	__be16 dport;
	union {
		struct {
			__be32 ipv4_src;
			__be32 ipv4_dst;
		};
		struct {
			__u32 ipv6_src[4];
			__u32 ipv6_dst[4];
		};
	};
	__u32 flags;
	__be32 flow_label;
};

struct bpf_flowtable_opts {
	s32 error;
};

struct bpf_func_info {
	__u32 insn_off;
	__u32 type_id;
};

struct bpf_func_info_aux {
	u16 linkage;
	bool unreliable;
	bool called: 1;
	bool verified: 1;
};

struct bpf_func_proto {
	u64 (*func)(u64, u64, u64, u64, u64);
	bool gpl_only;
	bool pkt_access;
	bool might_sleep;
	bool allow_fastcall;
	enum bpf_return_type ret_type;
	union {
		struct {
			enum bpf_arg_type arg1_type;
			enum bpf_arg_type arg2_type;
			enum bpf_arg_type arg3_type;
			enum bpf_arg_type arg4_type;
			enum bpf_arg_type arg5_type;
		};
		enum bpf_arg_type arg_type[5];
	};
	union {
		struct {
			u32 *arg1_btf_id;
			u32 *arg2_btf_id;
			u32 *arg3_btf_id;
			u32 *arg4_btf_id;
			u32 *arg5_btf_id;
		};
		u32 *arg_btf_id[5];
		struct {
			size_t arg1_size;
			size_t arg2_size;
			size_t arg3_size;
			size_t arg4_size;
			size_t arg5_size;
		};
		size_t arg_size[5];
	};
	int *ret_btf_id;
	bool (*allowed)(const struct bpf_prog *);
};

struct tnum {
	u64 value;
	u64 mask;
};

struct bpf_reg_state {
	enum bpf_reg_type type;
	s32 off;
	union {
		int range;
		struct {
			struct bpf_map *map_ptr;
			u32 map_uid;
		};
		struct {
			struct btf *btf;
			u32 btf_id;
		};
		struct {
			u32 mem_size;
			u32 dynptr_id;
		};
		struct {
			enum bpf_dynptr_type type;
			bool first_slot;
		} dynptr;
		struct {
			struct btf *btf;
			u32 btf_id;
			enum bpf_iter_state state: 2;
			int depth: 30;
		} iter;
		struct {
			long unsigned int raw1;
			long unsigned int raw2;
		} raw;
		u32 subprogno;
	};
	struct tnum var_off;
	s64 smin_value;
	s64 smax_value;
	u64 umin_value;
	u64 umax_value;
	s32 s32_min_value;
	s32 s32_max_value;
	u32 u32_min_value;
	u32 u32_max_value;
	u32 id;
	u32 ref_obj_id;
	struct bpf_reg_state *parent;
	u32 frameno;
	s32 subreg_def;
	enum bpf_reg_liveness live;
	bool precise;
};

struct bpf_retval_range {
	s32 minval;
	s32 maxval;
};

struct bpf_stack_state;

struct bpf_func_state {
	struct bpf_reg_state regs[11];
	int callsite;
	u32 frameno;
	u32 subprogno;
	u32 async_entry_cnt;
	struct bpf_retval_range callback_ret_range;
	bool in_callback_fn;
	bool in_async_callback_fn;
	bool in_exception_callback_fn;
	u32 callback_depth;
	struct bpf_stack_state *stack;
	int allocated_stack;
};

struct bpf_hrtimer {
	struct bpf_async_cb cb;
	struct hrtimer timer;
	atomic_t cancelling;
};

struct bpf_mem_caches;

struct bpf_mem_cache;

struct bpf_mem_alloc {
	struct bpf_mem_caches *caches;
	struct bpf_mem_cache *cache;
	struct obj_cgroup *objcg;
	bool percpu;
	struct work_struct work;
};

struct pcpu_freelist_node;

struct pcpu_freelist_head {
	struct pcpu_freelist_node *first;
	raw_spinlock_t lock;
};

struct pcpu_freelist {
	struct pcpu_freelist_head *freelist;
	struct pcpu_freelist_head extralist;
};

struct bpf_lru_node;

typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);

struct bpf_lru {
	union {
		struct bpf_common_lru common_lru;
		struct bpf_lru_list *percpu_lru;
	};
	del_from_htab_func del_from_htab;
	void *del_arg;
	unsigned int hash_offset;
	unsigned int nr_scans;
	bool percpu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bucket;

struct htab_elem;

struct bpf_htab {
	struct bpf_map map;
	struct bpf_mem_alloc ma;
	struct bpf_mem_alloc pcpu_ma;
	struct bucket *buckets;
	void *elems;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct pcpu_freelist freelist;
		struct bpf_lru lru;
	};
	struct htab_elem **extra_elems;
	struct percpu_counter pcount;
	atomic_t count;
	bool use_percpu_counter;
	u32 n_buckets;
	u32 elem_size;
	u32 hashrnd;
	struct lock_class_key lockdep_key;
	int *map_locked[8];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_id_pair {
	u32 old;
	u32 cur;
};

struct bpf_idmap {
	u32 tmp_id_gen;
	struct bpf_id_pair map[600];
};

struct bpf_idset {
	u32 count;
	u32 ids[600];
};

struct bpf_insn {
	__u8 code;
	__u8 dst_reg: 4;
	__u8 src_reg: 4;
	__s16 off;
	__s32 imm;
};

struct bpf_insn_access_aux {
	enum bpf_reg_type reg_type;
	bool is_ldsx;
	union {
		int ctx_field_size;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
	};
	struct bpf_verifier_log *log;
	bool is_retval;
};

struct bpf_map_ptr_state {
	struct bpf_map *map_ptr;
	bool poison;
	bool unpriv;
};

struct bpf_loop_inline_state {
	unsigned int initialized: 1;
	unsigned int fit_for_inline: 1;
	u32 callback_subprogno;
};

struct btf_struct_meta;

struct bpf_insn_aux_data {
	union {
		enum bpf_reg_type ptr_type;
		struct bpf_map_ptr_state map_ptr_state;
		s32 call_imm;
		u32 alu_limit;
		struct {
			u32 map_index;
			u32 map_off;
		};
		struct {
			enum bpf_reg_type reg_type;
			union {
				struct {
					struct btf *btf;
					u32 btf_id;
				};
				u32 mem_size;
			};
		} btf_var;
		struct bpf_loop_inline_state loop_inline_state;
	};
	union {
		u64 obj_new_size;
		u64 insert_off;
	};
	struct btf_struct_meta *kptr_struct_meta;
	u64 map_key_state;
	int ctx_field_size;
	u32 seen;
	bool sanitize_stack_spill;
	bool zext_dst;
	bool needs_zext;
	bool storage_get_func_atomic;
	bool is_iter_next;
	bool call_with_percpu_alloc_ptr;
	u8 alu_state;
	u8 fastcall_pattern: 1;
	u8 fastcall_spills_num: 3;
	unsigned int orig_idx;
	bool jmp_point;
	bool prune_point;
	bool force_checkpoint;
	bool calls_callback;
};

typedef void (*bpf_insn_print_t)(void *, const char *, ...);

typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);

typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);

struct bpf_insn_cbs {
	bpf_insn_print_t cb_print;
	bpf_insn_revmap_call_t cb_call;
	bpf_insn_print_imm_t cb_imm;
	void *private_data;
};

struct bpf_insn_hist_entry {
	u32 idx;
	u32 prev_idx: 22;
	u32 flags: 10;
	u64 linked_regs;
};

struct bpf_iter_meta;

struct bpf_iter__bpf_link {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_link *link;
	};
};

struct bpf_iter__bpf_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
};

struct bpf_iter__bpf_map_elem {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		void *value;
	};
};

struct bpf_iter__bpf_prog {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_prog *prog;
	};
};

struct bpf_iter__bpf_sk_storage_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		struct sock *sk;
	};
	union {
		void *value;
	};
};

struct bpf_iter__cgroup {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct cgroup *cgroup;
	};
};

struct fib6_info;

struct bpf_iter__ipv6_route {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct fib6_info *rt;
	};
};

struct bpf_iter__kmem_cache {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct kmem_cache *s;
	};
};

struct kallsym_iter;

struct bpf_iter__ksym {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct kallsym_iter *ksym;
	};
};

struct netlink_sock;

struct bpf_iter__netlink {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct netlink_sock *sk;
	};
};

struct bpf_iter__sockmap {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		struct sock *sk;
	};
};

struct bpf_iter__task {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
};

struct bpf_iter__task__safe_trusted {
	struct bpf_iter_meta *meta;
	struct task_struct *task;
};

struct bpf_iter__task_file {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	u32 fd;
	union {
		struct file *file;
	};
};

struct bpf_iter__task_vma {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	union {
		struct vm_area_struct *vma;
	};
};

struct bpf_iter__tcp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct sock_common *sk_common;
	};
	uid_t uid;
};

struct udp_sock;

struct bpf_iter__udp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct udp_sock *udp_sk;
	};
	uid_t uid;
	long: 0;
	int bucket;
};

struct unix_sock;

struct bpf_iter__unix {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct unix_sock *unix_sk;
	};
	uid_t uid;
};

struct bpf_iter_aux_info {
	struct bpf_map *map;
	struct {
		struct cgroup *start;
		enum bpf_cgroup_iter_order order;
	} cgroup;
	struct {
		enum bpf_iter_task_type type;
		u32 pid;
	} task;
};

struct bpf_iter_bits {
	__u64 __opaque[2];
};

struct bpf_iter_bits_kern {
	union {
		__u64 *bits;
		__u64 bits_copy;
	};
	int nr_bits;
	int bit;
};

struct bpf_iter_css {
	__u64 __opaque[3];
};

struct bpf_iter_css_kern {
	struct cgroup_subsys_state *start;
	struct cgroup_subsys_state *pos;
	unsigned int flags;
};

struct bpf_iter_css_task {
	__u64 __opaque[1];
};

struct css_task_iter;

struct bpf_iter_css_task_kern {
	struct css_task_iter *css_it;
};

struct bpf_iter_kmem_cache {
	__u64 __opaque[1];
};

struct bpf_iter_kmem_cache_kern {
	struct kmem_cache *pos;
};

struct bpf_iter_target_info;

struct bpf_iter_link {
	struct bpf_link link;
	struct bpf_iter_aux_info aux;
	struct bpf_iter_target_info *tinfo;
};

union bpf_iter_link_info {
	struct {
		__u32 map_fd;
	} map;
	struct {
		enum bpf_cgroup_iter_order order;
		__u32 cgroup_fd;
		__u64 cgroup_id;
	} cgroup;
	struct {
		__u32 tid;
		__u32 pid;
		__u32 pid_fd;
	} task;
};

struct bpf_iter_meta {
	union {
		struct seq_file *seq;
	};
	u64 session_id;
	u64 seq_num;
};

struct bpf_iter_meta__safe_trusted {
	struct seq_file *seq;
};

struct bpf_iter_num {
	__u64 __opaque[1];
};

struct bpf_iter_num_kern {
	int cur;
	int end;
};

struct bpf_iter_seq_info;

struct bpf_iter_priv_data {
	struct bpf_iter_target_info *tinfo;
	const struct bpf_iter_seq_info *seq_info;
	struct bpf_prog *prog;
	u64 session_id;
	u64 seq_num;
	bool done_stop;
	long: 0;
	u8 target_private[0];
};

typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);

typedef void (*bpf_iter_show_fdinfo_t)(const struct bpf_iter_aux_info *, struct seq_file *);

struct bpf_link_info;

typedef int (*bpf_iter_fill_link_info_t)(const struct bpf_iter_aux_info *, struct bpf_link_info *);

typedef const struct bpf_func_proto * (*bpf_iter_get_func_proto_t)(enum bpf_func_id, const struct bpf_prog *);

struct bpf_iter_reg {
	const char *target;
	bpf_iter_attach_target_t attach_target;
	bpf_iter_detach_target_t detach_target;
	bpf_iter_show_fdinfo_t show_fdinfo;
	bpf_iter_fill_link_info_t fill_link_info;
	bpf_iter_get_func_proto_t get_func_proto;
	u32 ctx_arg_info_size;
	u32 feature;
	struct bpf_ctx_arg_aux ctx_arg_info[2];
	const struct bpf_iter_seq_info *seq_info;
};

struct bpf_iter_seq_array_map_info {
	struct bpf_map *map;
	void *percpu_value_buf;
	u32 index;
};

struct bpf_iter_seq_hash_map_info {
	struct bpf_map *map;
	struct bpf_htab *htab;
	void *percpu_value_buf;
	u32 bucket_id;
	u32 skip_elems;
};

typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_fini_seq_priv_t)(void *);

struct bpf_iter_seq_info {
	const struct seq_operations *seq_ops;
	bpf_iter_init_seq_priv_t init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct bpf_iter_seq_link_info {
	u32 link_id;
};

struct bpf_iter_seq_map_info {
	u32 map_id;
};

struct bpf_iter_seq_prog_info {
	u32 prog_id;
};

struct bpf_iter_seq_sk_storage_map_info {
	struct bpf_map *map;
	unsigned int bucket_id;
	unsigned int skip_elems;
};

struct pid_namespace;

struct bpf_iter_seq_task_common {
	struct pid_namespace *ns;
	enum bpf_iter_task_type type;
	u32 pid;
	u32 pid_visiting;
};

struct bpf_iter_seq_task_file_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	u32 tid;
	u32 fd;
};

struct bpf_iter_seq_task_info {
	struct bpf_iter_seq_task_common common;
	u32 tid;
};

struct bpf_iter_seq_task_vma_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *vma;
	u32 tid;
	long unsigned int prev_vm_start;
	long unsigned int prev_vm_end;
};

struct bpf_iter_target_info {
	struct list_head list;
	const struct bpf_iter_reg *reg_info;
	u32 btf_id;
};

struct bpf_iter_task {
	__u64 __opaque[3];
};

struct bpf_iter_task_kern {
	struct task_struct *task;
	struct task_struct *pos;
	unsigned int flags;
};

struct bpf_iter_task_vma {
	__u64 __opaque[1];
};

struct bpf_iter_task_vma_kern_data;

struct bpf_iter_task_vma_kern {
	struct bpf_iter_task_vma_kern_data *data;
};

struct maple_enode;

struct maple_tree;

struct maple_alloc;

struct ma_state {
	struct maple_tree *tree;
	long unsigned int index;
	long unsigned int last;
	struct maple_enode *node;
	long unsigned int min;
	long unsigned int max;
	struct maple_alloc *alloc;
	enum maple_status status;
	unsigned char depth;
	unsigned char offset;
	unsigned char mas_flags;
	unsigned char end;
	enum store_type store_type;
};

struct vma_iterator {
	struct ma_state mas;
};

struct mmap_unlock_irq_work;

struct bpf_iter_task_vma_kern_data {
	struct task_struct *task;
	struct mm_struct *mm;
	struct mmap_unlock_irq_work *work;
	struct vma_iterator vmi;
};

struct bpf_jit_poke_descriptor {
	void *tailcall_target;
	void *tailcall_bypass;
	void *bypass_addr;
	void *aux;
	union {
		struct {
			struct bpf_map *map;
			u32 key;
		} tail_call;
	};
	bool tailcall_target_stable;
	u8 adj_off;
	u16 reason;
	u32 insn_idx;
};

struct bpf_key {
	struct key *key;
	bool has_ref;
};

struct bpf_kfunc_btf {
	struct btf *btf;
	struct module *module;
	u16 offset;
};

struct bpf_kfunc_btf_tab {
	struct bpf_kfunc_btf descs[256];
	u32 nr_descs;
};

struct bpf_kfunc_call_arg_meta {
	struct btf *btf;
	u32 func_id;
	u32 kfunc_flags;
	const struct btf_type *func_proto;
	const char *func_name;
	u32 ref_obj_id;
	u8 release_regno;
	bool r0_rdonly;
	u32 ret_btf_id;
	u64 r0_size;
	u32 subprogno;
	struct {
		u64 value;
		bool found;
	} arg_constant;
	struct btf *arg_btf;
	u32 arg_btf_id;
	bool arg_owning_ref;
	struct {
		struct btf_field *field;
	} arg_list_head;
	struct {
		struct btf_field *field;
	} arg_rbtree_root;
	struct {
		enum bpf_dynptr_type type;
		u32 id;
		u32 ref_obj_id;
	} initialized_dynptr;
	struct {
		u8 spi;
		u8 frameno;
	} iter;
	struct {
		struct bpf_map *ptr;
		int uid;
	} map;
	u64 mem_size;
};

struct bpf_kfunc_desc {
	struct btf_func_model func_model;
	u32 func_id;
	s32 imm;
	u16 offset;
	long unsigned int addr;
};

struct bpf_kfunc_desc_tab {
	struct bpf_kfunc_desc descs[256];
	u32 nr_descs;
};

struct bpf_line_info {
	__u32 insn_off;
	__u32 file_name_off;
	__u32 line_off;
	__u32 line_col;
};

struct bpf_link_info {
	__u32 type;
	__u32 id;
	__u32 prog_id;
	union {
		struct {
			__u64 tp_name;
			__u32 tp_name_len;
		} raw_tracepoint;
		struct {
			__u32 attach_type;
			__u32 target_obj_id;
			__u32 target_btf_id;
		} tracing;
		struct {
			__u64 cgroup_id;
			__u32 attach_type;
		} cgroup;
		struct {
			__u64 target_name;
			__u32 target_name_len;
			union {
				struct {
					__u32 map_id;
				} map;
			};
			union {
				struct {
					__u64 cgroup_id;
					__u32 order;
				} cgroup;
				struct {
					__u32 tid;
					__u32 pid;
				} task;
			};
		} iter;
		struct {
			__u32 netns_ino;
			__u32 attach_type;
		} netns;
		struct {
			__u32 ifindex;
		} xdp;
		struct {
			__u32 map_id;
		} struct_ops;
		struct {
			__u32 pf;
			__u32 hooknum;
			__s32 priority;
			__u32 flags;
		} netfilter;
		struct {
			__u64 addrs;
			__u32 count;
			__u32 flags;
			__u64 missed;
			__u64 cookies;
		} kprobe_multi;
		struct {
			__u64 path;
			__u64 offsets;
			__u64 ref_ctr_offsets;
			__u64 cookies;
			__u32 path_size;
			__u32 count;
			__u32 flags;
			__u32 pid;
		} uprobe_multi;
		struct {
			__u32 type;
			union {
				struct {
					__u64 file_name;
					__u32 name_len;
					__u32 offset;
					__u64 cookie;
				} uprobe;
				struct {
					__u64 func_name;
					__u32 name_len;
					__u32 offset;
					__u64 addr;
					__u64 missed;
					__u64 cookie;
				} kprobe;
				struct {
					__u64 tp_name;
					__u32 name_len;
					__u64 cookie;
				} tracepoint;
				struct {
					__u64 config;
					__u32 type;
					__u64 cookie;
				} event;
			};
		} perf_event;
		struct {
			__u32 ifindex;
			__u32 attach_type;
		} tcx;
		struct {
			__u32 ifindex;
			__u32 attach_type;
		} netkit;
		struct {
			__u32 map_id;
			__u32 attach_type;
		} sockmap;
	};
};

struct bpf_link_ops {
	void (*release)(struct bpf_link *);
	void (*dealloc)(struct bpf_link *);
	void (*dealloc_deferred)(struct bpf_link *);
	int (*detach)(struct bpf_link *);
	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
	int (*update_map)(struct bpf_link *, struct bpf_map *, struct bpf_map *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
};

struct bpf_link_primer {
	struct bpf_link *link;
	struct file *file;
	int fd;
	u32 id;
};

struct bpf_list_head {
	__u64 __opaque[2];
};

struct bpf_list_node {
	__u64 __opaque[3];
};

struct bpf_list_node_kern {
	struct list_head list_head;
	void *owner;
};

struct bpf_local_storage_data;

struct bpf_local_storage_map;

struct bpf_local_storage {
	struct bpf_local_storage_data *cache[16];
	struct bpf_local_storage_map *smap;
	struct hlist_head list;
	void *owner;
	struct callback_head rcu;
	raw_spinlock_t lock;
};

struct bpf_local_storage_cache {
	spinlock_t idx_lock;
	u64 idx_usage_counts[16];
};

struct bpf_local_storage_data {
	struct bpf_local_storage_map *smap;
	u8 data[0];
};

struct bpf_local_storage_elem {
	struct hlist_node map_node;
	struct hlist_node snode;
	struct bpf_local_storage *local_storage;
	union {
		struct callback_head rcu;
		struct hlist_node free_node;
	};
	long: 64;
	struct bpf_local_storage_data sdata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_map_bucket;

struct bpf_local_storage_map {
	struct bpf_map map;
	struct bpf_local_storage_map_bucket *buckets;
	u32 bucket_log;
	u16 elem_size;
	u16 cache_idx;
	struct bpf_mem_alloc selem_ma;
	struct bpf_mem_alloc storage_ma;
	bool bpf_ma;
};

struct bpf_local_storage_map_bucket {
	struct hlist_head list;
	raw_spinlock_t lock;
};

struct bpf_lpm_trie_key_hdr {
	__u32 prefixlen;
};

struct bpf_lpm_trie_key_u8 {
	union {
		struct bpf_lpm_trie_key_hdr hdr;
		__u32 prefixlen;
	};
	__u8 data[0];
};

struct bpf_lru_locallist {
	struct list_head lists[2];
	u16 next_steal;
	raw_spinlock_t lock;
};

struct bpf_lru_node {
	struct list_head list;
	u16 cpu;
	u8 type;
	u8 ref;
};

struct bpf_lwt_prog {
	struct bpf_prog *prog;
	char *name;
};

struct bpf_lwt {
	struct bpf_lwt_prog in;
	struct bpf_lwt_prog out;
	struct bpf_lwt_prog xmit;
	int family;
};

struct bpf_offloaded_map;

struct bpf_map_dev_ops {
	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
};

struct bpf_map_info {
	__u32 type;
	__u32 id;
	__u32 key_size;
	__u32 value_size;
	__u32 max_entries;
	__u32 map_flags;
	char name[16];
	__u32 ifindex;
	__u32 btf_vmlinux_value_type_id;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 btf_id;
	__u32 btf_key_type_id;
	__u32 btf_value_type_id;
	__u32 btf_vmlinux_id;
	__u64 map_extra;
};

typedef u64 (*bpf_callback_t)(u64, u64, u64, u64, u64);

struct bpf_prog_aux;

struct bpf_map_ops {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map *, struct file *);
	void (*map_free)(struct bpf_map *);
	int (*map_get_next_key)(struct bpf_map *, void *, void *);
	void (*map_release_uref)(struct bpf_map *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
	int (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_lookup_and_delete_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_update_batch)(struct bpf_map *, struct file *, const union bpf_attr *, union bpf_attr *);
	int (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	void * (*map_lookup_elem)(struct bpf_map *, void *);
	long int (*map_update_elem)(struct bpf_map *, void *, void *, u64);
	long int (*map_delete_elem)(struct bpf_map *, void *);
	long int (*map_push_elem)(struct bpf_map *, void *, u64);
	long int (*map_pop_elem)(struct bpf_map *, void *);
	long int (*map_peek_elem)(struct bpf_map *, void *);
	void * (*map_lookup_percpu_elem)(struct bpf_map *, void *, u32);
	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
	void (*map_fd_put_ptr)(struct bpf_map *, void *, bool);
	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
	long unsigned int (*map_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
	long int (*map_redirect)(struct bpf_map *, u64, u64);
	bool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);
	int (*map_set_for_each_callback_args)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *);
	long int (*map_for_each_callback)(struct bpf_map *, bpf_callback_t, void *, u64);
	u64 (*map_mem_usage)(const struct bpf_map *);
	int *map_btf_id;
	const struct bpf_iter_seq_info *iter_seq_info;
};

struct rcuwait {
	struct task_struct *task;
};

struct irq_work {
	struct __call_single_node node;
	void (*func)(struct irq_work *);
	struct rcuwait irqwait;
};

struct bpf_mem_cache {
	struct llist_head free_llist;
	local_t active;
	struct llist_head free_llist_extra;
	struct irq_work refill_work;
	struct obj_cgroup *objcg;
	int unit_size;
	int free_cnt;
	int low_watermark;
	int high_watermark;
	int batch;
	int percpu_size;
	bool draining;
	struct bpf_mem_cache *tgt;
	struct llist_head free_by_rcu;
	struct llist_node *free_by_rcu_tail;
	struct llist_head waiting_for_gp;
	struct llist_node *waiting_for_gp_tail;
	struct callback_head rcu;
	atomic_t call_rcu_in_progress;
	struct llist_head free_llist_extra_rcu;
	struct llist_head free_by_rcu_ttrace;
	struct llist_head waiting_for_gp_ttrace;
	struct callback_head rcu_ttrace;
	atomic_t call_rcu_ttrace_in_progress;
};

struct bpf_mem_caches {
	struct bpf_mem_cache cache[11];
};

struct bpf_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	u64 delegate_cmds;
	u64 delegate_maps;
	u64 delegate_progs;
	u64 delegate_attachs;
};

struct bpf_mprog_fp {
	struct bpf_prog *prog;
};

struct bpf_mprog_bundle;

struct bpf_mprog_entry {
	struct bpf_mprog_fp fp_items[64];
	struct bpf_mprog_bundle *parent;
};

struct bpf_mprog_cp {
	struct bpf_link *link;
};

struct bpf_mprog_bundle {
	struct bpf_mprog_entry a;
	struct bpf_mprog_entry b;
	struct bpf_mprog_cp cp_items[64];
	struct bpf_prog *ref;
	atomic64_t revision;
	u32 count;
};

struct bpf_nested_pt_regs {
	struct pt_regs regs[3];
};

struct bpf_nh_params {
	u32 nh_family;
	union {
		u32 ipv4_nh;
		struct in6_addr ipv6_nh;
	};
};

struct bpf_redirect_info {
	u64 tgt_index;
	void *tgt_value;
	struct bpf_map *map;
	u32 flags;
	u32 map_id;
	enum bpf_map_type map_type;
	struct bpf_nh_params nh;
	u32 kern_flags;
};

struct bpf_net_context {
	struct bpf_redirect_info ri;
	struct list_head cpu_map_flush_list;
	struct list_head dev_map_flush_list;
	struct list_head xskmap_map_flush_list;
};

struct bpf_netns_link {
	struct bpf_link link;
	enum bpf_attach_type type;
	enum netns_bpf_attach_type netns_type;
	struct net *net;
	struct list_head node;
};

typedef unsigned int nf_hookfn(void *, struct sk_buff *, const struct nf_hook_state *);

struct nf_hook_ops {
	nf_hookfn *hook;
	struct net_device *dev;
	void *priv;
	u8 pf;
	enum nf_hook_ops_type hook_ops_type: 8;
	unsigned int hooknum;
	int priority;
};

struct nf_defrag_hook;

struct bpf_nf_link {
	struct bpf_link link;
	struct nf_hook_ops hook_ops;
	netns_tracker ns_tracker;
	struct net *net;
	u32 dead;
	const struct nf_defrag_hook *defrag_hook;
};

struct bpf_prog_offload_ops;

struct bpf_offload_dev {
	const struct bpf_prog_offload_ops *ops;
	struct list_head netdevs;
	void *priv;
};

struct rhash_head {
	struct rhash_head *next;
};

struct bpf_offload_netdev {
	struct rhash_head l;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	struct list_head progs;
	struct list_head maps;
	struct list_head offdev_netdevs;
};

struct bpf_offloaded_map {
	struct bpf_map map;
	struct net_device *netdev;
	const struct bpf_map_dev_ops *dev_ops;
	void *dev_priv;
	struct list_head offloads;
};

struct bpf_perf_event_value {
	__u64 counter;
	__u64 enabled;
	__u64 running;
};

struct bpf_perf_link {
	struct bpf_link link;
	struct file *perf_file;
};

struct bpf_pidns_info {
	__u32 pid;
	__u32 tgid;
};

struct bpf_preload_info {
	char link_name[16];
	struct bpf_link *link;
};

struct bpf_preload_ops {
	int (*preload)(struct bpf_preload_info *);
	struct module *owner;
};

struct sock_filter {
	__u16 code;
	__u8 jt;
	__u8 jf;
	__u32 k;
};

struct bpf_prog_stats;

struct sock_fprog_kern;

struct bpf_prog {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinding_requested: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	u16 call_get_stack: 1;
	u16 call_get_func_ip: 1;
	u16 tstamp_type_access: 1;
	u16 sleepable: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_stats *stats;
	int *active;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	struct bpf_prog_aux *aux;
	struct sock_fprog_kern *orig_prog;
	union {
		struct {
			struct {} __empty_insns;
			struct sock_filter insns[0];
		};
		struct {
			struct {} __empty_insnsi;
			struct bpf_insn insnsi[0];
		};
	};
};

struct bpf_trampoline;

struct bpf_prog_ops;

struct btf_mod_pair;

struct user_struct;

struct bpf_token;

struct bpf_prog_offload;

struct exception_table_entry;

struct bpf_prog_aux {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 real_func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	struct btf *attach_btf;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	void *priv_stack_ptr;
	struct mutex dst_mutex;
	struct bpf_prog *dst_prog;
	struct bpf_trampoline *dst_trampoline;
	enum bpf_prog_type saved_dst_prog_type;
	enum bpf_attach_type saved_dst_attach_type;
	bool verifier_zext;
	bool dev_bound;
	bool offload_requested;
	bool attach_btf_trace;
	bool attach_tracing_prog;
	bool func_proto_unreliable;
	bool tail_call_reachable;
	bool xdp_has_frags;
	bool exception_cb;
	bool exception_boundary;
	bool is_extended;
	bool jits_use_priv_stack;
	bool priv_stack_requested;
	bool changes_pkt_data;
	u64 prog_array_member_cnt;
	struct mutex ext_mutex;
	struct bpf_arena *arena;
	void (*recursion_detected)(struct bpf_prog *);
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor *poke_tab;
	struct bpf_kfunc_desc_tab *kfunc_tab;
	struct bpf_kfunc_btf_tab *kfunc_btf_tab;
	u32 size_poke_tab;
	struct bpf_ksym ksym;
	const struct bpf_prog_ops *ops;
	struct bpf_map **used_maps;
	struct mutex used_maps_mutex;
	struct btf_mod_pair *used_btfs;
	struct bpf_prog *prog;
	struct user_struct *user;
	u64 load_time;
	u32 verified_insns;
	int cgroup_atype;
	struct bpf_map *cgroup_storage[2];
	char name[16];
	u64 (*bpf_exception_cb)(u64, u64, u64, u64, u64);
	void *security;
	struct bpf_token *token;
	struct bpf_prog_offload *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	struct module *mod;
	u32 num_exentries;
	struct exception_table_entry *extable;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
};

struct bpf_prog_dummy {
	struct bpf_prog prog;
};

struct bpf_prog_info {
	__u32 type;
	__u32 id;
	__u8 tag[8];
	__u32 jited_prog_len;
	__u32 xlated_prog_len;
	__u64 jited_prog_insns;
	__u64 xlated_prog_insns;
	__u64 load_time;
	__u32 created_by_uid;
	__u32 nr_map_ids;
	__u64 map_ids;
	char name[16];
	__u32 ifindex;
	__u32 gpl_compatible: 1;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 nr_jited_ksyms;
	__u32 nr_jited_func_lens;
	__u64 jited_ksyms;
	__u64 jited_func_lens;
	__u32 btf_id;
	__u32 func_info_rec_size;
	__u64 func_info;
	__u32 nr_func_info;
	__u32 nr_line_info;
	__u64 line_info;
	__u64 jited_line_info;
	__u32 nr_jited_line_info;
	__u32 line_info_rec_size;
	__u32 jited_line_info_rec_size;
	__u32 nr_prog_tags;
	__u64 prog_tags;
	__u64 run_time_ns;
	__u64 run_cnt;
	__u64 recursion_misses;
	__u32 verified_insns;
	__u32 attach_btf_obj_id;
	__u32 attach_btf_id;
};

struct bpf_prog_kstats {
	u64 nsecs;
	u64 cnt;
	u64 misses;
};

struct bpf_prog_list {
	struct hlist_node node;
	struct bpf_prog *prog;
	struct bpf_cgroup_link *link;
	struct bpf_cgroup_storage *storage[2];
};

struct bpf_prog_offload {
	struct bpf_prog *prog;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct bpf_prog_offload_ops {
	int (*insn_hook)(struct bpf_verifier_env *, int, int);
	int (*finalize)(struct bpf_verifier_env *);
	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
	int (*prepare)(struct bpf_prog *);
	int (*translate)(struct bpf_prog *);
	void (*destroy)(struct bpf_prog *);
};

struct bpf_prog_ops {
	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);
};

struct bpf_prog_pack {
	struct list_head list;
	void *ptr;
	long unsigned int bitmap[0];
};

struct bpf_prog_stats {
	u64_stats_t cnt;
	u64_stats_t nsecs;
	u64_stats_t misses;
	struct u64_stats_sync syncp;
	long: 64;
};

struct bpf_queue_stack {
	struct bpf_map map;
	raw_spinlock_t lock;
	u32 head;
	u32 tail;
	u32 size;
	char elements[0];
};

struct tracepoint;

struct bpf_raw_event_map {
	struct tracepoint *tp;
	void *bpf_func;
	u32 num_args;
	u32 writable_size;
	long: 64;
};

struct bpf_raw_tp_link {
	struct bpf_link link;
	struct bpf_raw_event_map *btp;
	u64 cookie;
};

struct bpf_raw_tp_null_args {
	const char *func;
	u64 mask;
};

struct bpf_raw_tp_regs {
	struct pt_regs regs[3];
};

struct bpf_raw_tp_test_run_info {
	struct bpf_prog *prog;
	void *ctx;
	u32 retval;
};

struct bpf_rb_node {
	__u64 __opaque[4];
};

struct bpf_rb_node_kern {
	struct rb_node rb_node;
	void *owner;
};

struct bpf_rb_root {
	__u64 __opaque[2];
};

struct bpf_redir_neigh {
	__u32 nh_family;
	union {
		__be32 ipv4_nh;
		__u32 ipv6_nh[4];
	};
};

struct bpf_refcount {
	__u32 __opaque[1];
};

struct bpf_reference_state {
	enum ref_state_type type;
	int id;
	int insn_idx;
	void *ptr;
};

struct bpf_reg_types {
	const enum bpf_reg_type types[10];
	u32 *btf_id;
};

struct bpf_ringbuf {
	wait_queue_head_t waitq;
	struct irq_work work;
	u64 mask;
	struct page **pages;
	int nr_pages;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	raw_spinlock_t spinlock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t busy;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int consumer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int producer_pos;
	long unsigned int pending_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_ringbuf_hdr {
	u32 len;
	u32 pg_off;
};

struct bpf_ringbuf_map {
	struct bpf_map map;
	struct bpf_ringbuf *rb;
};

struct bpf_sanitize_info {
	struct bpf_insn_aux_data aux;
	bool mask_to_left;
};

struct bpf_session_run_ctx {
	struct bpf_run_ctx run_ctx;
	bool is_return;
	void *data;
};

struct bpf_tramp_link {
	struct bpf_link link;
	struct hlist_node tramp_hlist;
	u64 cookie;
};

struct bpf_shim_tramp_link {
	struct bpf_tramp_link link;
	struct bpf_trampoline *trampoline;
};

struct sk_psock_progs {
	struct bpf_prog *msg_parser;
	struct bpf_prog *stream_parser;
	struct bpf_prog *stream_verdict;
	struct bpf_prog *skb_verdict;
	struct bpf_link *msg_parser_link;
	struct bpf_link *stream_parser_link;
	struct bpf_link *stream_verdict_link;
	struct bpf_link *skb_verdict_link;
};

struct bpf_shtab_bucket;

struct bpf_shtab {
	struct bpf_map map;
	struct bpf_shtab_bucket *buckets;
	u32 buckets_num;
	u32 elem_size;
	struct sk_psock_progs progs;
	atomic_t count;
};

struct bpf_shtab_bucket {
	struct hlist_head head;
	spinlock_t lock;
};

struct bpf_shtab_elem {
	struct callback_head rcu;
	u32 hash;
	struct sock *sk;
	struct hlist_node node;
	u8 key[0];
};

struct bpf_sk_storage_diag {
	u32 nr_maps;
	struct bpf_map *maps[0];
};

struct qdisc_skb_cb {
	struct {
		unsigned int pkt_len;
		u16 slave_dev_queue_mapping;
		u16 tc_classid;
	};
	unsigned char data[20];
};

struct bpf_skb_data_end {
	struct qdisc_skb_cb qdisc_cb;
	void *data_meta;
	void *data_end;
};

struct bpf_sock_tuple {
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
			__be16 sport;
			__be16 dport;
		} ipv4;
		struct {
			__be32 saddr[4];
			__be32 daddr[4];
			__be16 sport;
			__be16 dport;
		} ipv6;
	};
};

struct bpf_sockopt_buf {
	u8 data[32];
};

struct bpf_stab {
	struct bpf_map map;
	struct sock **sks;
	struct sk_psock_progs progs;
	spinlock_t lock;
};

struct bpf_stack_build_id {
	__s32 status;
	unsigned char build_id[20];
	union {
		__u64 offset;
		__u64 ip;
	};
};

struct stack_map_bucket;

struct bpf_stack_map {
	struct bpf_map map;
	void *elems;
	struct pcpu_freelist freelist;
	u32 n_buckets;
	struct stack_map_bucket *buckets[0];
};

struct bpf_stack_state {
	struct bpf_reg_state spilled_ptr;
	u8 slot_type[8];
};

struct bpf_storage_blob {
	struct bpf_local_storage *storage;
};

struct bpf_storage_buffer {
	struct callback_head rcu;
	char data[0];
};

struct bpf_verifier_ops;

struct btf_member;

struct bpf_struct_ops {
	const struct bpf_verifier_ops *verifier_ops;
	int (*init)(struct btf *);
	int (*check_member)(const struct btf_type *, const struct btf_member *, const struct bpf_prog *);
	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
	int (*reg)(void *, struct bpf_link *);
	void (*unreg)(void *, struct bpf_link *);
	int (*update)(void *, void *, struct bpf_link *);
	int (*validate)(void *);
	void *cfi_stubs;
	struct module *owner;
	const char *name;
	struct btf_func_model func_models[64];
};

struct bpf_struct_ops_arg_info {
	struct bpf_ctx_arg_aux *info;
	u32 cnt;
};

struct bpf_struct_ops_common_value {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
};

struct bpf_struct_ops_bpf_dummy_ops {
	struct bpf_struct_ops_common_value common;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct bpf_dummy_ops data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_struct_ops_desc {
	struct bpf_struct_ops *st_ops;
	const struct btf_type *type;
	const struct btf_type *value_type;
	u32 type_id;
	u32 value_id;
	struct bpf_struct_ops_arg_info *arg_info;
};

struct bpf_struct_ops_link {
	struct bpf_link link;
	struct bpf_map *map;
	wait_queue_head_t wait_hup;
};

struct bpf_struct_ops_value {
	struct bpf_struct_ops_common_value common;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_struct_ops_map {
	struct bpf_map map;
	const struct bpf_struct_ops_desc *st_ops_desc;
	struct mutex lock;
	struct bpf_link **links;
	struct bpf_ksym **ksyms;
	u32 funcs_cnt;
	u32 image_pages_cnt;
	void *image_pages[8];
	struct btf *btf;
	struct bpf_struct_ops_value *uvalue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct bpf_struct_ops_value kvalue;
};

struct rate_sample;

union tcp_cc_info;

struct tcp_congestion_ops {
	u32 (*ssthresh)(struct sock *);
	void (*cong_avoid)(struct sock *, u32, u32);
	void (*set_state)(struct sock *, u8);
	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
	void (*in_ack_event)(struct sock *, u32);
	void (*pkts_acked)(struct sock *, const struct ack_sample *);
	u32 (*min_tso_segs)(struct sock *);
	void (*cong_control)(struct sock *, u32, int, const struct rate_sample *);
	u32 (*undo_cwnd)(struct sock *);
	u32 (*sndbuf_expand)(struct sock *);
	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
	char name[16];
	struct module *owner;
	struct list_head list;
	u32 key;
	u32 flags;
	void (*init)(struct sock *);
	void (*release)(struct sock *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_struct_ops_tcp_congestion_ops {
	struct bpf_struct_ops_common_value common;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct tcp_congestion_ops data;
};

struct bpf_subprog_arg_info {
	enum bpf_arg_type arg_type;
	union {
		u32 mem_size;
		u32 btf_id;
	};
};

struct bpf_subprog_info {
	u32 start;
	u32 linfo_idx;
	u16 stack_depth;
	u16 stack_extra;
	s16 fastcall_stack_off;
	bool has_tail_call: 1;
	bool tail_call_reachable: 1;
	bool has_ld_abs: 1;
	bool is_cb: 1;
	bool is_async_cb: 1;
	bool is_exception_cb: 1;
	bool args_cached: 1;
	bool keep_fastcall_stack: 1;
	bool changes_pkt_data: 1;
	enum priv_stack_mode priv_stack_mode;
	u8 arg_cnt;
	struct bpf_subprog_arg_info args[5];
};

struct tcp_iter_state {
	struct seq_net_private p;
	enum tcp_seq_states state;
	struct sock *syn_wait_sk;
	int bucket;
	int offset;
	int sbucket;
	int num;
	loff_t last_pos;
};

struct bpf_tcp_iter_state {
	struct tcp_iter_state state;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	struct sock **batch;
	bool st_bucket_done;
};

struct bpf_tcp_req_attrs {
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 mss;
	u8 rcv_wscale;
	u8 snd_wscale;
	u8 ecn_ok;
	u8 wscale_ok;
	u8 sack_ok;
	u8 tstamp_ok;
	u8 usec_ts_ok;
	u8 reserved[3];
};

struct bpf_tcp_sock {
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u64 bytes_received;
	__u64 bytes_acked;
	__u32 dsack_dups;
	__u32 delivered;
	__u32 delivered_ce;
	__u32 icsk_retransmits;
};

struct bpf_test_timer {
	enum {
		NO_PREEMPT = 0,
		NO_MIGRATE = 1,
	} mode;
	u32 i;
	u64 time_start;
	u64 time_spent;
};

struct bpf_throw_ctx {
	struct bpf_prog_aux *aux;
	u64 sp;
	u64 bp;
	int cnt;
};

struct bpf_timer {
	__u64 __opaque[2];
};

struct user_namespace;

struct bpf_token {
	struct work_struct work;
	atomic64_t refcnt;
	struct user_namespace *userns;
	u64 allowed_cmds;
	u64 allowed_maps;
	u64 allowed_progs;
	u64 allowed_attachs;
	void *security;
};

struct bpf_trace_module {
	struct module *module;
	struct list_head list;
};

struct bpf_trace_run_ctx {
	struct bpf_run_ctx run_ctx;
	u64 bpf_cookie;
	bool is_uprobe;
};

union perf_sample_weight {
	__u64 full;
	struct {
		__u32 var1_dw;
		__u16 var2_w;
		__u16 var3_w;
	};
};

union perf_mem_data_src {
	__u64 val;
	struct {
		__u64 mem_op: 5;
		__u64 mem_lvl: 14;
		__u64 mem_snoop: 5;
		__u64 mem_lock: 2;
		__u64 mem_dtlb: 7;
		__u64 mem_lvl_num: 4;
		__u64 mem_remote: 1;
		__u64 mem_snoopx: 2;
		__u64 mem_blk: 3;
		__u64 mem_hops: 3;
		__u64 mem_rsvd: 18;
	};
};

struct perf_regs {
	__u64 abi;
	struct pt_regs *regs;
};

struct perf_callchain_entry;

struct perf_raw_record;

struct perf_branch_stack;

struct perf_sample_data {
	u64 sample_flags;
	u64 period;
	u64 dyn_size;
	u64 type;
	struct {
		u32 pid;
		u32 tid;
	} tid_entry;
	u64 time;
	u64 id;
	struct {
		u32 cpu;
		u32 reserved;
	} cpu_entry;
	u64 ip;
	struct perf_callchain_entry *callchain;
	struct perf_raw_record *raw;
	struct perf_branch_stack *br_stack;
	u64 *br_stack_cntr;
	union perf_sample_weight weight;
	union perf_mem_data_src data_src;
	u64 txn;
	struct perf_regs regs_user;
	struct perf_regs regs_intr;
	u64 stack_user_size;
	u64 stream_id;
	u64 cgroup;
	u64 addr;
	u64 phys_addr;
	u64 data_page_size;
	u64 code_page_size;
	u64 aux_size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_trace_sample_data {
	struct perf_sample_data sds[3];
};

struct bpf_tracing_link {
	struct bpf_tramp_link link;
	enum bpf_attach_type attach_type;
	struct bpf_trampoline *trampoline;
	struct bpf_prog *tgt_prog;
};

struct bpf_tramp_image {
	void *image;
	int size;
	struct bpf_ksym ksym;
	struct percpu_ref pcref;
	void *ip_after_call;
	void *ip_epilogue;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct bpf_tramp_links {
	struct bpf_tramp_link *links[38];
	int nr_links;
};

struct bpf_tramp_run_ctx {
	struct bpf_run_ctx run_ctx;
	u64 bpf_cookie;
	struct bpf_run_ctx *saved_run_ctx;
};

struct ftrace_ops;

struct bpf_trampoline {
	struct hlist_node hlist;
	struct ftrace_ops *fops;
	struct mutex mutex;
	refcount_t refcnt;
	u32 flags;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
		bool ftrace_managed;
	} func;
	struct bpf_prog *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	struct bpf_tramp_image *cur_image;
};

struct bpf_tunnel_key {
	__u32 tunnel_id;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
	__u8 tunnel_tos;
	__u8 tunnel_ttl;
	union {
		__u16 tunnel_ext;
		__be16 tunnel_flags;
	};
	__u32 tunnel_label;
	union {
		__u32 local_ipv4;
		__u32 local_ipv6[4];
	};
};

struct bpf_tuple {
	struct bpf_prog *prog;
	struct bpf_link *link;
};

struct udp_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct bpf_udp_iter_state {
	struct udp_iter_state state;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	int offset;
	struct sock **batch;
	bool st_bucket_done;
};

struct bpf_unix_iter_state {
	struct seq_net_private p;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	struct sock **batch;
	bool st_bucket_done;
};

struct uprobe_consumer {
	int (*handler)(struct uprobe_consumer *, struct pt_regs *, __u64 *);
	int (*ret_handler)(struct uprobe_consumer *, long unsigned int, struct pt_regs *, __u64 *);
	bool (*filter)(struct uprobe_consumer *, struct mm_struct *);
	struct list_head cons_node;
	__u64 id;
};

struct bpf_uprobe_multi_link;

struct uprobe;

struct bpf_uprobe {
	struct bpf_uprobe_multi_link *link;
	loff_t offset;
	long unsigned int ref_ctr_offset;
	u64 cookie;
	struct uprobe *uprobe;
	struct uprobe_consumer consumer;
	bool session;
};

struct bpf_uprobe_multi_link {
	struct path path;
	struct bpf_link link;
	u32 cnt;
	u32 flags;
	struct bpf_uprobe *uprobes;
	struct task_struct *task;
};

struct bpf_uprobe_multi_run_ctx {
	struct bpf_session_run_ctx session_ctx;
	long unsigned int entry_ip;
	struct bpf_uprobe *uprobe;
};

struct btf_mod_pair {
	struct btf *btf;
	struct module *module;
};

struct bpf_verifier_log {
	u64 start_pos;
	u64 end_pos;
	char *ubuf;
	u32 level;
	u32 len_total;
	u32 len_max;
	char kbuf[1024];
};

struct bpf_verifier_stack_elem;

struct bpf_verifier_state;

struct bpf_verifier_state_list;

struct bpf_verifier_env {
	u32 insn_idx;
	u32 prev_insn_idx;
	struct bpf_prog *prog;
	const struct bpf_verifier_ops *ops;
	struct module *attach_btf_mod;
	struct bpf_verifier_stack_elem *head;
	int stack_size;
	bool strict_alignment;
	bool test_state_freq;
	bool test_reg_invariants;
	struct bpf_verifier_state *cur_state;
	struct bpf_verifier_state_list **explored_states;
	struct bpf_verifier_state_list *free_list;
	struct bpf_map *used_maps[64];
	struct btf_mod_pair used_btfs[64];
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 id_gen;
	u32 hidden_subprog_cnt;
	int exception_callback_subprog;
	bool explore_alu_limits;
	bool allow_ptr_leaks;
	bool allow_uninit_stack;
	bool bpf_capable;
	bool bypass_spec_v1;
	bool bypass_spec_v4;
	bool seen_direct_write;
	bool seen_exception;
	struct bpf_insn_aux_data *insn_aux_data;
	const struct bpf_line_info *prev_linfo;
	struct bpf_verifier_log log;
	struct bpf_subprog_info subprog_info[258];
	union {
		struct bpf_idmap idmap_scratch;
		struct bpf_idset idset_scratch;
	};
	struct {
		int *insn_state;
		int *insn_stack;
		int cur_stack;
	} cfg;
	struct backtrack_state bt;
	struct bpf_insn_hist_entry *insn_hist;
	struct bpf_insn_hist_entry *cur_hist_ent;
	u32 insn_hist_cap;
	u32 pass_cnt;
	u32 subprog_cnt;
	u32 prev_insn_processed;
	u32 insn_processed;
	u32 prev_jmps_processed;
	u32 jmps_processed;
	u64 verification_time;
	u32 max_states_per_insn;
	u32 total_states;
	u32 peak_states;
	u32 longest_mark_read_walk;
	bpfptr_t fd_array;
	u32 scratched_regs;
	u64 scratched_stack_slots;
	u64 prev_log_pos;
	u64 prev_insn_print_pos;
	struct bpf_reg_state fake_reg[2];
	char tmp_str_buf[320];
	struct bpf_insn insn_buf[32];
	struct bpf_insn epilogue_buf[32];
};

struct bpf_verifier_ops {
	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
	int (*gen_epilogue)(struct bpf_insn *, const struct bpf_prog *, s16);
	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
	int (*btf_struct_access)(struct bpf_verifier_log *, const struct bpf_reg_state *, int, int);
};

struct bpf_verifier_state {
	struct bpf_func_state *frame[8];
	struct bpf_verifier_state *parent;
	struct bpf_reference_state *refs;
	u32 branches;
	u32 insn_idx;
	u32 curframe;
	u32 acquired_refs;
	u32 active_locks;
	u32 active_preempt_locks;
	u32 active_irq_id;
	bool active_rcu_lock;
	bool speculative;
	bool used_as_loop_entry;
	bool in_sleepable;
	u32 first_insn_idx;
	u32 last_insn_idx;
	struct bpf_verifier_state *loop_entry;
	u32 insn_hist_start;
	u32 insn_hist_end;
	u32 dfs_depth;
	u32 callback_unroll_depth;
	u32 may_goto_depth;
};

struct bpf_verifier_stack_elem {
	struct bpf_verifier_state st;
	int insn_idx;
	int prev_insn_idx;
	struct bpf_verifier_stack_elem *next;
	u32 log_pos;
};

struct bpf_verifier_state_list {
	struct bpf_verifier_state state;
	struct bpf_verifier_state_list *next;
	int miss_cnt;
	int hit_cnt;
};

struct bpf_work {
	struct bpf_async_cb cb;
	struct work_struct work;
	struct work_struct delete_work;
};

struct bpf_wq {
	__u64 __opaque[2];
};

struct bpf_xdp_link;

struct bpf_xdp_entity {
	struct bpf_prog *prog;
	struct bpf_xdp_link *link;
};

struct bpf_xdp_link {
	struct bpf_link link;
	struct net_device *dev;
	int flags;
};

struct bpf_xdp_sock {
	__u32 queue_id;
};

struct bpf_xfrm_info {
	u32 if_id;
	int link;
};

struct bpf_xfrm_state {
	__u32 reqid;
	__u32 spi;
	__u16 family;
	__u16 ext;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
};

struct bpf_xfrm_state_opts {
	s32 error;
	s32 netns_id;
	u32 mark;
	xfrm_address_t daddr;
	__be32 spi;
	u8 proto;
	u16 family;
};

struct bpffs_btf_enums {
	const struct btf *btf;
	const struct btf_type *cmd_t;
	const struct btf_type *map_t;
	const struct btf_type *prog_t;
	const struct btf_type *attach_t;
};

struct trace_entry {
	short unsigned int type;
	unsigned char flags;
	unsigned char preempt_count;
	int pid;
};

struct bprint_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *fmt;
	u32 buf[0];
};

struct bputs_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *str;
};

struct br2684_dev {
	struct net_device *net_dev;
	struct list_head br2684_devs;
	int number;
	struct list_head brvccs;
	int mac_was_set;
	enum br2684_payload payload;
};

struct br2684_filter {
	__be32 prefix;
	__be32 netmask;
};

struct br2684_filter_set {
	struct br2684_if_spec ifspec;
	struct br2684_filter filter;
};

struct br2684_vcc {
	struct atm_vcc *atmvcc;
	struct net_device *device;
	void (*old_push)(struct atm_vcc *, struct sk_buff *);
	void (*old_pop)(struct atm_vcc *, struct sk_buff *);
	void (*old_release_cb)(struct atm_vcc *);
	struct module *old_owner;
	enum br2684_encaps encaps;
	struct list_head brvccs;
	struct br2684_filter filter;
	unsigned int copies_needed;
	unsigned int copies_failed;
	atomic_t qspace;
};

struct br_boolopt_multi {
	__u32 optval;
	__u32 optmask;
};

struct mac_addr {
	unsigned char addr[6];
};

struct br_cfm_cc_ccm_tx_info {
	struct mac_addr dmac;
	u32 period;
	bool seq_no_update;
	bool if_tlv;
	u8 if_tlv_value;
	bool port_tlv;
	u8 port_tlv_value;
};

struct br_cfm_maid {
	u8 data[48];
};

struct br_cfm_cc_config {
	struct br_cfm_maid exp_maid;
	enum br_cfm_ccm_interval exp_interval;
	bool enable;
};

struct br_cfm_cc_peer_status {
	u8 port_tlv_value;
	u8 if_tlv_value;
	u8 ccm_defect: 1;
	u8 rdi: 1;
	u8 seen: 1;
	u8 tlv_seen: 1;
	u8 seq_unexp_seen: 1;
};

struct br_cfm_common_hdr {
	__u8 mdlevel_version;
	__u8 opcode;
	__u8 flags;
	__u8 tlv_offset;
};

struct br_cfm_mep_create {
	enum br_cfm_domain domain;
	enum br_cfm_mep_direction direction;
	u32 ifindex;
};

struct br_cfm_mep_config {
	u32 mdlevel;
	u32 mepid;
	struct mac_addr unicast_mac;
};

struct br_cfm_mep_status {
	bool opcode_unexp_seen;
	bool version_unexp_seen;
	bool rx_level_low_seen;
};

struct net_bridge_port;

struct br_cfm_mep {
	struct hlist_node head;
	u32 instance;
	struct br_cfm_mep_create create;
	struct br_cfm_mep_config config;
	struct br_cfm_cc_config cc_config;
	struct br_cfm_cc_ccm_tx_info cc_ccm_tx_info;
	struct hlist_head peer_mep_list;
	struct net_bridge_port *b_port;
	long unsigned int ccm_tx_end;
	struct delayed_work ccm_tx_dwork;
	u32 ccm_tx_snumber;
	u32 ccm_rx_snumber;
	struct br_cfm_mep_status status;
	bool rdi;
	struct callback_head rcu;
};

struct br_cfm_peer_mep {
	struct hlist_node head;
	struct br_cfm_mep *mep;
	struct delayed_work ccm_rx_dwork;
	u32 mepid;
	struct br_cfm_cc_peer_status cc_status;
	u32 ccm_rx_count_miss;
	struct callback_head rcu;
};

struct bridge_id {
	unsigned char prio[2];
	unsigned char addr[6];
};

typedef struct bridge_id bridge_id;

struct br_config_bpdu {
	unsigned int topology_change: 1;
	unsigned int topology_change_ack: 1;
	bridge_id root;
	int root_path_cost;
	bridge_id bridge_id;
	port_id port_id;
	int message_age;
	int max_age;
	int hello_time;
	int forward_delay;
};

struct br_frame_type {
	__be16 type;
	int (*frame_handler)(struct net_bridge_port *, struct sk_buff *);
	struct hlist_node list;
};

struct br_input_skb_cb {
	struct net_device *brdev;
	u16 frag_max_size;
	u8 igmp;
	u8 mrouters_only: 1;
	u8 proxyarp_replied: 1;
	u8 src_port_isolated: 1;
	u8 promisc: 1;
	u8 vlan_filtered: 1;
	u8 br_netfilter_broute: 1;
	u32 backup_nhid;
};

struct br_ip {
	union {
		__be32 ip4;
		struct in6_addr ip6;
	} src;
	union {
		__be32 ip4;
		struct in6_addr ip6;
		unsigned char mac_addr[6];
	} dst;
	__be16 proto;
	__u16 vid;
};

struct br_ip_list {
	struct list_head list;
	struct br_ip addr;
};

struct br_mcast_stats {
	__u64 igmp_v1queries[2];
	__u64 igmp_v2queries[2];
	__u64 igmp_v3queries[2];
	__u64 igmp_leaves[2];
	__u64 igmp_v1reports[2];
	__u64 igmp_v2reports[2];
	__u64 igmp_v3reports[2];
	__u64 igmp_parse_errors;
	__u64 mld_v1queries[2];
	__u64 mld_v2queries[2];
	__u64 mld_leaves[2];
	__u64 mld_v1reports[2];
	__u64 mld_v2reports[2];
	__u64 mld_parse_errors;
	__u64 mcast_bytes[2];
	__u64 mcast_packets[2];
};

struct net_bridge;

struct br_mdb_entry;

struct br_mdb_src_entry;

struct br_mdb_config {
	struct net_bridge *br;
	struct net_bridge_port *p;
	struct br_mdb_entry *entry;
	struct br_ip group;
	bool src_entry;
	u8 filter_mode;
	u16 nlflags;
	struct br_mdb_src_entry *src_entries;
	int num_src_entries;
	u8 rt_protocol;
};

struct br_mdb_entry {
	__u32 ifindex;
	__u8 state;
	__u8 flags;
	__u16 vid;
	struct {
		union {
			__be32 ip4;
			struct in6_addr ip6;
			unsigned char mac_addr[6];
		} u;
		__be16 proto;
	} addr;
};

struct br_mdb_flush_desc {
	u32 port_ifindex;
	u16 vid;
	u8 rt_protocol;
	u8 state;
	u8 state_mask;
};

struct br_mdb_src_entry {
	struct br_ip addr;
};

struct br_mrp {
	struct hlist_node list;
	struct net_bridge_port *p_port;
	struct net_bridge_port *s_port;
	struct net_bridge_port *i_port;
	u32 ring_id;
	u16 in_id;
	u16 prio;
	enum br_mrp_ring_role_type ring_role;
	u8 ring_role_offloaded;
	enum br_mrp_ring_state_type ring_state;
	u32 ring_transitions;
	enum br_mrp_in_role_type in_role;
	u8 in_role_offloaded;
	enum br_mrp_in_state_type in_state;
	u32 in_transitions;
	struct delayed_work test_work;
	u32 test_interval;
	long unsigned int test_end;
	u32 test_count_miss;
	u32 test_max_miss;
	bool test_monitor;
	struct delayed_work in_test_work;
	u32 in_test_interval;
	long unsigned int in_test_end;
	u32 in_test_count_miss;
	u32 in_test_max_miss;
	u32 seq_id;
	struct callback_head rcu;
};

struct br_mrp_common_hdr {
	__be16 seq_id;
	__u8 domain[16];
};

struct br_mrp_in_role {
	__u32 ring_id;
	__u32 in_role;
	__u32 i_ifindex;
	__u16 in_id;
};

struct br_mrp_in_state {
	__u32 in_state;
	__u16 in_id;
};

struct br_mrp_in_test_hdr {
	__be16 id;
	__u8 sa[6];
	__be16 port_role;
	__be16 state;
	__be16 transitions;
	__be32 timestamp;
} __attribute__((packed));

struct br_mrp_instance {
	__u32 ring_id;
	__u32 p_ifindex;
	__u32 s_ifindex;
	__u16 prio;
};

struct br_mrp_oui_hdr {
	__u8 oui[3];
};

struct br_mrp_ring_role {
	__u32 ring_id;
	__u32 ring_role;
};

struct br_mrp_ring_state {
	__u32 ring_id;
	__u32 ring_state;
};

struct br_mrp_ring_test_hdr {
	__be16 prio;
	__u8 sa[6];
	__be16 port_role;
	__be16 state;
	__be16 transitions;
	__be32 timestamp;
} __attribute__((packed));

struct br_mrp_start_in_test {
	__u32 interval;
	__u32 max_miss;
	__u32 period;
	__u16 in_id;
};

struct br_mrp_start_test {
	__u32 ring_id;
	__u32 interval;
	__u32 max_miss;
	__u32 period;
	__u32 monitor;
};

struct br_mrp_sub_option1_hdr {
	__u8 type;
	__u8 data[2];
};

struct br_mrp_tlv_hdr {
	__u8 type;
	__u8 length;
};

struct br_port_msg {
	__u8 family;
	__u32 ifindex;
};

struct metadata_dst;

struct br_tunnel_info {
	__be64 tunnel_id;
	struct metadata_dst *tunnel_dst;
};

struct br_vlan_bind_walk_data {
	u16 vid;
	struct net_device *result;
};

struct br_vlan_link_state_walk_data {
	struct net_bridge *br;
};

struct br_vlan_msg {
	__u8 family;
	__u8 reserved1;
	__u16 reserved2;
	__u32 ifindex;
};

struct branch_entry {
	union {
		struct {
			u64 ip: 58;
			u64 ip_sign_ext: 5;
			u64 mispredict: 1;
		} split;
		u64 full;
	} from;
	union {
		struct {
			u64 ip: 58;
			u64 ip_sign_ext: 3;
			u64 reserved: 1;
			u64 spec: 1;
			u64 valid: 1;
		} split;
		u64 full;
	} to;
};

struct bridge_mcast_other_query {
	struct timer_list timer;
	struct timer_list delay_timer;
};

struct bridge_mcast_own_query {
	struct timer_list timer;
	u32 startup_sent;
};

struct bridge_mcast_querier {
	struct br_ip addr;
	int port_ifidx;
	seqcount_spinlock_t seq;
};

struct bridge_mcast_stats {
	struct br_mcast_stats mstats;
	struct u64_stats_sync syncp;
};

struct bridge_stp_xstats {
	__u64 transition_blk;
	__u64 transition_fwd;
	__u64 rx_bpdu;
	__u64 tx_bpdu;
	__u64 rx_tcn;
	__u64 tx_tcn;
};

struct bridge_vlan_info {
	__u16 flags;
	__u16 vid;
};

struct bridge_vlan_xstats {
	__u64 rx_bytes;
	__u64 rx_packets;
	__u64 tx_bytes;
	__u64 tx_packets;
	__u16 vid;
	__u16 flags;
	__u32 pad2;
};

struct brnf_frag_data {
	local_lock_t bh_lock;
	char mac[22];
	u8 encap_size;
	u8 size;
	u16 vlan_tci;
	__be16 vlan_proto;
};

struct brnf_net {
	bool enabled;
	struct ctl_table_header *ctl_hdr;
	int call_iptables;
	int call_ip6tables;
	int call_arptables;
	int filter_vlan_tagged;
	int filter_pppoe_tagged;
	int pass_vlan_indev;
};

struct broadcast_sk {
	struct sock *sk;
	struct work_struct work;
};

struct brport_attribute {
	struct attribute attr;
	ssize_t (*show)(struct net_bridge_port *, char *);
	int (*store)(struct net_bridge_port *, long unsigned int);
	int (*store_raw)(struct net_bridge_port *, char *);
};

struct fs_pin {
	wait_queue_head_t wait;
	int done;
	struct hlist_node s_list;
	struct hlist_node m_list;
	void (*kill)(struct fs_pin *);
};

struct bsd_acct_struct {
	struct fs_pin pin;
	atomic_long_t count;
	struct callback_head rcu;
	struct mutex lock;
	bool active;
	bool check_space;
	long unsigned int needcheck;
	struct file *file;
	struct pid_namespace *ns;
	struct work_struct work;
	struct completion done;
	acct_t ac;
};

struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

struct sg_io_v4;

typedef int bsg_sg_io_fn(struct request_queue *, struct sg_io_v4 *, bool, unsigned int);

struct bsg_device {
	struct request_queue *queue;
	struct device device;
	struct cdev cdev;
	int max_queue;
	unsigned int timeout;
	unsigned int reserved_size;
	bsg_sg_io_fn *sg_io_fn;
};

typedef bool busy_tag_iter_fn(struct request *, void *);

struct bt_iter_data {
	struct blk_mq_hw_ctx *hctx;
	struct request_queue *q;
	busy_tag_iter_fn *fn;
	void *data;
	bool reserved;
};

struct bt_tags_iter_data {
	struct blk_mq_tags *tags;
	busy_tag_iter_fn *fn;
	void *data;
	unsigned int flags;
};

struct btf_header {
	__u16 magic;
	__u8 version;
	__u8 flags;
	__u32 hdr_len;
	__u32 type_off;
	__u32 type_len;
	__u32 str_off;
	__u32 str_len;
};

struct btf_kfunc_set_tab;

struct btf_id_dtor_kfunc_tab;

struct btf_struct_metas;

struct btf_struct_ops_tab;

struct btf {
	void *data;
	struct btf_type **types;
	u32 *resolved_ids;
	u32 *resolved_sizes;
	const char *strings;
	void *nohdr_data;
	struct btf_header hdr;
	u32 nr_types;
	u32 types_size;
	u32 data_size;
	refcount_t refcnt;
	u32 id;
	struct callback_head rcu;
	struct btf_kfunc_set_tab *kfunc_set_tab;
	struct btf_id_dtor_kfunc_tab *dtor_kfunc_tab;
	struct btf_struct_metas *struct_meta_tab;
	struct btf_struct_ops_tab *struct_ops_tab;
	struct btf *base_btf;
	u32 start_id;
	u32 start_str_off;
	char name[56];
	bool kernel_btf;
	__u32 *base_id_map;
};

struct btf_anon_stack {
	u32 tid;
	u32 offset;
};

struct btf_array {
	__u32 type;
	__u32 index_type;
	__u32 nelems;
};

struct btf_decl_tag {
	__s32 component_idx;
};

struct btf_enum {
	__u32 name_off;
	__s32 val;
};

struct btf_enum64 {
	__u32 name_off;
	__u32 val_lo32;
	__u32 val_hi32;
};

typedef void (*btf_dtor_kfunc_t)(void *);

struct btf_field_kptr {
	struct btf *btf;
	struct module *module;
	btf_dtor_kfunc_t dtor;
	u32 btf_id;
};

struct btf_field_graph_root {
	struct btf *btf;
	u32 value_btf_id;
	u32 node_offset;
	struct btf_record *value_rec;
};

struct btf_field {
	u32 offset;
	u32 size;
	enum btf_field_type type;
	union {
		struct btf_field_kptr kptr;
		struct btf_field_graph_root graph_root;
	};
};

struct btf_field_desc {
	int t_off_cnt;
	int t_offs[2];
	int m_sz;
	int m_off_cnt;
	int m_offs[1];
};

struct btf_field_info {
	enum btf_field_type type;
	u32 off;
	union {
		struct {
			u32 type_id;
		} kptr;
		struct {
			const char *node_name;
			u32 value_btf_id;
		} graph_root;
	};
};

struct btf_field_iter {
	struct btf_field_desc desc;
	void *p;
	int m_idx;
	int off_idx;
	int vlen;
};

struct btf_id_dtor_kfunc {
	u32 btf_id;
	u32 kfunc_btf_id;
};

struct btf_id_dtor_kfunc_tab {
	u32 cnt;
	struct btf_id_dtor_kfunc dtors[0];
};

struct btf_id_set {
	u32 cnt;
	u32 ids[0];
};

struct btf_id_set8 {
	u32 cnt;
	u32 flags;
	struct {
		u32 id;
		u32 flags;
	} pairs[0];
};

typedef int (*btf_kfunc_filter_t)(const struct bpf_prog *, u32);

struct btf_kfunc_hook_filter {
	btf_kfunc_filter_t filters[16];
	u32 nr_filters;
};

struct btf_kfunc_id_set {
	struct module *owner;
	struct btf_id_set8 *set;
	btf_kfunc_filter_t filter;
};

struct btf_kfunc_set_tab {
	struct btf_id_set8 *sets[14];
	struct btf_kfunc_hook_filter hook_filters[14];
};

struct btf_verifier_env;

struct resolve_vertex;

struct btf_show;

struct btf_kind_operations {
	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
	void (*show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct btf_show *);
};

struct btf_member {
	__u32 name_off;
	__u32 type;
	__u32 offset;
};

struct btf_module {
	struct list_head list;
	struct module *module;
	struct btf *btf;
	struct bin_attribute *sysfs_attr;
	int flags;
};

struct btf_name_info {
	const char *name;
	bool needs_size: 1;
	unsigned int size: 31;
	__u32 id;
};

struct btf_param {
	__u32 name_off;
	__u32 type;
};

struct btf_ptr {
	void *ptr;
	__u32 type_id;
	__u32 flags;
};

struct btf_record {
	u32 cnt;
	u32 field_mask;
	int spin_lock_off;
	int timer_off;
	int wq_off;
	int refcount_off;
	struct btf_field fields[0];
};

struct btf_relocate {
	struct btf *btf;
	const struct btf *base_btf;
	const struct btf *dist_base_btf;
	unsigned int nr_base_types;
	unsigned int nr_split_types;
	unsigned int nr_dist_base_types;
	int dist_str_len;
	int base_str_len;
	__u32 *id_map;
	__u32 *str_map;
};

struct btf_sec_info {
	u32 off;
	u32 len;
};

struct btf_show {
	u64 flags;
	void *target;
	void (*showfn)(struct btf_show *, const char *, struct __va_list_tag *);
	const struct btf *btf;
	struct {
		u8 depth;
		u8 depth_to_show;
		u8 depth_check;
		u8 array_member: 1;
		u8 array_terminated: 1;
		u16 array_encoding;
		u32 type_id;
		int status;
		const struct btf_type *type;
		const struct btf_member *member;
		char name[80];
	} state;
	struct {
		u32 size;
		void *head;
		void *data;
		u8 safe[32];
	} obj;
};

struct btf_show_snprintf {
	struct btf_show show;
	int len_left;
	int len;
};

struct btf_struct_meta {
	u32 btf_id;
	struct btf_record *record;
};

struct btf_struct_metas {
	u32 cnt;
	struct btf_struct_meta types[0];
};

struct btf_struct_ops_tab {
	u32 cnt;
	u32 capacity;
	struct bpf_struct_ops_desc ops[0];
};

struct btf_type {
	__u32 name_off;
	__u32 info;
	union {
		__u32 size;
		__u32 type;
	};
};

struct btf_var {
	__u32 linkage;
};

struct btf_var_secinfo {
	__u32 type;
	__u32 offset;
	__u32 size;
};

struct resolve_vertex {
	const struct btf_type *t;
	u32 type_id;
	u16 next_member;
};

struct btf_verifier_env {
	struct btf *btf;
	u8 *visit_states;
	struct resolve_vertex stack[32];
	struct bpf_verifier_log log;
	u32 log_type_id;
	u32 top_stack;
	enum verifier_phase phase;
	enum resolve_mode resolve_mode;
};

struct btrfs_delayed_root;

struct btrfs_async_delayed_work {
	struct btrfs_delayed_root *delayed_root;
	int nr;
	struct btrfs_work work;
};

struct btrfs_backref_node;

struct btrfs_fs_info;

struct btrfs_backref_cache {
	struct rb_root rb_root;
	struct btrfs_backref_node *path[8];
	struct list_head pending[8];
	u64 last_trans;
	int nr_nodes;
	int nr_edges;
	struct list_head pending_edge;
	struct list_head useless_node;
	struct btrfs_fs_info *fs_info;
	bool is_reloc;
};

struct btrfs_backref_edge {
	struct list_head list[2];
	struct btrfs_backref_node *node[2];
};

struct btrfs_key {
	__u64 objectid;
	__u8 type;
	__u64 offset;
} __attribute__((packed));

struct btrfs_path;

struct btrfs_backref_iter {
	u64 bytenr;
	struct btrfs_path *path;
	struct btrfs_fs_info *fs_info;
	struct btrfs_key cur_key;
	u32 item_ptr;
	u32 cur_ptr;
	u32 end_ptr;
};

struct btrfs_root;

struct extent_buffer;

struct btrfs_backref_node {
	struct {
		struct rb_node rb_node;
		u64 bytenr;
	};
	u64 new_bytenr;
	u64 owner;
	struct list_head list;
	struct list_head upper;
	struct list_head lower;
	struct btrfs_root *root;
	struct extent_buffer *eb;
	unsigned int level: 8;
	unsigned int locked: 1;
	unsigned int processed: 1;
	unsigned int checked: 1;
	unsigned int pending: 1;
	unsigned int detached: 1;
	unsigned int is_reloc_root: 1;
};

struct ulist_node;

struct ulist {
	long unsigned int nnodes;
	struct list_head nodes;
	struct rb_root root;
	struct ulist_node *prealloc;
};

struct btrfs_backref_shared_cache_entry {
	u64 bytenr;
	u64 gen;
	bool is_shared;
};

struct btrfs_backref_share_check_ctx {
	struct ulist refs;
	u64 curr_leaf_bytenr;
	u64 prev_leaf_bytenr;
	struct btrfs_backref_shared_cache_entry path_cache_entries[8];
	bool use_path_cache;
	struct {
		u64 bytenr;
		bool is_shared;
	} prev_extents_cache[8];
	int prev_extents_cache_slot;
};

typedef int iterate_extent_inodes_t(u64, u64, u64, u64, void *);

struct btrfs_trans_handle;

struct btrfs_extent_item;

struct btrfs_backref_walk_ctx {
	u64 bytenr;
	u64 extent_item_pos;
	bool ignore_extent_item_pos;
	bool skip_inode_ref_list;
	struct btrfs_trans_handle *trans;
	struct btrfs_fs_info *fs_info;
	u64 time_seq;
	struct ulist *refs;
	struct ulist *roots;
	bool (*cache_lookup)(u64, void *, const u64 **, int *);
	void (*cache_store)(u64, const struct ulist *, void *);
	iterate_extent_inodes_t *indirect_ref_iterator;
	int (*check_extent_item)(u64, const struct btrfs_extent_item *, const struct extent_buffer *, void *);
	bool (*skip_data_ref)(u64, u64, u64, void *);
	void *user_ctx;
};

struct btrfs_balance_args {
	__u64 profiles;
	union {
		__u64 usage;
		struct {
			__u32 usage_min;
			__u32 usage_max;
		};
	};
	__u64 devid;
	__u64 pstart;
	__u64 pend;
	__u64 vstart;
	__u64 vend;
	__u64 target;
	__u64 flags;
	union {
		__u64 limit;
		struct {
			__u32 limit_min;
			__u32 limit_max;
		};
	};
	__u32 stripes_min;
	__u32 stripes_max;
	__u64 unused[6];
};

struct btrfs_balance_progress {
	__u64 expected;
	__u64 considered;
	__u64 completed;
};

struct btrfs_balance_control {
	struct btrfs_balance_args data;
	struct btrfs_balance_args meta;
	struct btrfs_balance_args sys;
	u64 flags;
	struct btrfs_balance_progress stat;
};

struct btrfs_disk_balance_args {
	__le64 profiles;
	union {
		__le64 usage;
		struct {
			__le32 usage_min;
			__le32 usage_max;
		};
	};
	__le64 devid;
	__le64 pstart;
	__le64 pend;
	__le64 vstart;
	__le64 vend;
	__le64 target;
	__le64 flags;
	union {
		__le64 limit;
		struct {
			__le32 limit_min;
			__le32 limit_max;
		};
	};
	__le32 stripes_min;
	__le32 stripes_max;
	__le64 unused[6];
};

struct btrfs_balance_item {
	__le64 flags;
	struct btrfs_disk_balance_args data;
	struct btrfs_disk_balance_args meta;
	struct btrfs_disk_balance_args sys;
	__le64 unused[4];
};

struct btrfs_tree_parent_check {
	u64 owner_root;
	u64 transid;
	struct btrfs_key first_key;
	bool has_first_key;
	u8 level;
};

typedef void (*btrfs_bio_end_io_t)(struct btrfs_bio *);

struct btrfs_ordered_extent;

struct btrfs_ordered_sum;

struct btrfs_bio {
	struct btrfs_inode *inode;
	u64 file_offset;
	union {
		struct {
			u8 *csum;
			u8 csum_inline[64];
			struct bvec_iter saved_iter;
		};
		struct {
			struct btrfs_ordered_extent *ordered;
			struct btrfs_ordered_sum *sums;
			u64 orig_physical;
		};
		struct btrfs_tree_parent_check parent_check;
	};
	btrfs_bio_end_io_t end_io;
	void *private;
	unsigned int mirror_num;
	atomic_t pending_ios;
	struct work_struct end_io_work;
	struct btrfs_fs_info *fs_info;
	blk_status_t status;
	struct bio bio;
};

struct btrfs_bio_ctrl {
	struct btrfs_bio *bbio;
	enum btrfs_compression_type compress_type;
	u32 len_to_oe_boundary;
	blk_opf_t opf;
	btrfs_bio_end_io_t end_io_func;
	struct writeback_control *wbc;
	long unsigned int submit_bitmap;
};

struct btrfs_io_ctl {
	void *cur;
	void *orig;
	struct page *page;
	struct page **pages;
	struct btrfs_fs_info *fs_info;
	struct inode *inode;
	long unsigned int size;
	int index;
	int num_pages;
	int entries;
	int bitmaps;
};

struct btrfs_caching_control;

struct btrfs_space_info;

struct btrfs_free_space_ctl;

struct btrfs_chunk_map;

struct btrfs_block_group {
	struct btrfs_fs_info *fs_info;
	struct btrfs_inode *inode;
	spinlock_t lock;
	u64 start;
	u64 length;
	u64 pinned;
	u64 reserved;
	u64 used;
	u64 delalloc_bytes;
	u64 bytes_super;
	u64 flags;
	u64 cache_generation;
	u64 global_root_id;
	u64 commit_used;
	u32 bitmap_high_thresh;
	u32 bitmap_low_thresh;
	struct rw_semaphore data_rwsem;
	long unsigned int full_stripe_len;
	long unsigned int runtime_flags;
	unsigned int ro;
	int disk_cache_state;
	int cached;
	struct btrfs_caching_control *caching_ctl;
	struct btrfs_space_info *space_info;
	struct btrfs_free_space_ctl *free_space_ctl;
	struct rb_node cache_node;
	struct list_head list;
	refcount_t refs;
	struct list_head cluster_list;
	struct list_head bg_list;
	struct list_head ro_list;
	atomic_t frozen;
	struct list_head discard_list;
	int discard_index;
	u64 discard_eligible_time;
	u64 discard_cursor;
	enum btrfs_discard_state discard_state;
	struct list_head dirty_list;
	struct list_head io_list;
	struct btrfs_io_ctl io_ctl;
	atomic_t reservations;
	atomic_t nocow_writers;
	struct mutex free_space_lock;
	int swap_extents;
	u64 alloc_offset;
	u64 zone_unusable;
	u64 zone_capacity;
	u64 meta_write_pointer;
	struct btrfs_chunk_map *physical_map;
	struct list_head active_bg_list;
	struct work_struct zone_finish_work;
	struct extent_buffer *last_eb;
	enum btrfs_block_group_size_class size_class;
	u64 reclaim_mark;
};

struct btrfs_block_group_item {
	__le64 used;
	__le64 chunk_objectid;
	__le64 flags;
};

struct btrfs_block_rsv {
	u64 size;
	u64 reserved;
	struct btrfs_space_info *space_info;
	spinlock_t lock;
	bool full;
	bool failfast;
	enum btrfs_rsv_type type: 8;
	u64 qgroup_rsv_size;
	u64 qgroup_rsv_reserved;
};

struct btrfs_caching_control {
	struct list_head list;
	struct mutex mutex;
	wait_queue_head_t wait;
	struct btrfs_work work;
	struct btrfs_block_group *block_group;
	atomic_t progress;
	refcount_t count;
};

struct btrfs_stripe {
	__le64 devid;
	__le64 offset;
	__u8 dev_uuid[16];
};

struct btrfs_chunk {
	__le64 length;
	__le64 owner;
	__le64 stripe_len;
	__le64 type;
	__le32 io_align;
	__le32 io_width;
	__le32 sector_size;
	__le16 num_stripes;
	__le16 sub_stripes;
	struct btrfs_stripe stripe;
};

struct btrfs_chunk_map {
	struct rb_node rb_node;
	int verified_stripes;
	refcount_t refs;
	u64 start;
	u64 chunk_len;
	u64 stripe_size;
	u64 type;
	int io_align;
	int io_width;
	int num_stripes;
	int sub_stripes;
	struct btrfs_io_stripe stripes[0];
};

struct btrfs_cmd_header {
	__le32 len;
	__le16 cmd;
	__le32 crc;
} __attribute__((packed));

struct btrfs_commit_stats {
	u64 commit_count;
	u64 max_commit_dur;
	u64 last_commit_dur;
	u64 total_commit_dur;
};

struct shrinker;

struct btrfs_compr_pool {
	struct shrinker *shrinker;
	spinlock_t lock;
	struct list_head list;
	int count;
	int thresh;
};

struct workspace_manager;

struct btrfs_compress_op {
	struct workspace_manager *workspace_manager;
	unsigned int max_level;
	unsigned int default_level;
};

struct btrfs_csum_item {
	__u8 csum;
};

struct btrfs_csums {
	u16 size;
	const char name[10];
	const char driver[12];
};

struct btrfs_data_container {
	__u32 bytes_left;
	__u32 bytes_missing;
	__u32 elem_cnt;
	__u32 elem_missed;
	__u64 val[0];
};

struct btrfs_data_ref {
	u64 objectid;
	u64 offset;
};

struct btrfs_delalloc_work {
	struct inode *inode;
	struct completion completion;
	struct list_head list;
	struct btrfs_work work;
};

struct btrfs_disk_key {
	__le64 objectid;
	__u8 type;
	__le64 offset;
} __attribute__((packed));

struct btrfs_delayed_extent_op {
	struct btrfs_disk_key key;
	bool update_key;
	bool update_flags;
	u64 flags_to_set;
};

struct btrfs_delayed_node;

struct btrfs_delayed_item {
	struct rb_node rb_node;
	u64 index;
	struct list_head tree_list;
	struct list_head readdir_list;
	struct list_head log_list;
	u64 bytes_reserved;
	struct btrfs_delayed_node *delayed_node;
	refcount_t refs;
	enum btrfs_delayed_item_type type: 8;
	bool logged;
	u16 data_len;
	char data[0];
};

struct btrfs_timespec {
	__le64 sec;
	__le32 nsec;
} __attribute__((packed));

struct btrfs_inode_item {
	__le64 generation;
	__le64 transid;
	__le64 size;
	__le64 nbytes;
	__le64 block_group;
	__le32 nlink;
	__le32 uid;
	__le32 gid;
	__le32 mode;
	__le64 rdev;
	__le64 flags;
	__le64 sequence;
	__le64 reserved[4];
	struct btrfs_timespec atime;
	struct btrfs_timespec ctime;
	struct btrfs_timespec mtime;
	struct btrfs_timespec otime;
};

struct btrfs_delayed_node {
	u64 inode_id;
	u64 bytes_reserved;
	struct btrfs_root *root;
	struct list_head n_list;
	struct list_head p_list;
	struct rb_root_cached ins_root;
	struct rb_root_cached del_root;
	struct mutex mutex;
	struct btrfs_inode_item inode_item;
	refcount_t refs;
	int count;
	u64 index_cnt;
	long unsigned int flags;
	u32 curr_index_batch_size;
	u32 index_item_leaves;
};

struct btrfs_delayed_ref_head {
	u64 bytenr;
	u64 num_bytes;
	struct mutex mutex;
	refcount_t refs;
	spinlock_t lock;
	struct rb_root_cached ref_tree;
	struct list_head ref_add_list;
	struct btrfs_delayed_extent_op *extent_op;
	int total_ref_mod;
	int ref_mod;
	u64 owning_root;
	u64 reserved_bytes;
	u8 level;
	bool must_insert_reserved;
	bool is_data;
	bool is_system;
	bool processing;
	bool tracked;
};

struct btrfs_tree_ref {
	int level;
};

struct btrfs_delayed_ref_node {
	struct rb_node ref_node;
	struct list_head add_list;
	u64 bytenr;
	u64 num_bytes;
	u64 seq;
	u64 ref_root;
	u64 parent;
	refcount_t refs;
	int ref_mod;
	unsigned int action: 8;
	unsigned int type: 8;
	union {
		struct btrfs_tree_ref tree_ref;
		struct btrfs_data_ref data_ref;
	};
};

struct btrfs_delayed_ref_root {
	struct xarray head_refs;
	struct xarray dirty_extents;
	spinlock_t lock;
	long unsigned int num_heads;
	long unsigned int num_heads_ready;
	u64 pending_csums;
	long unsigned int flags;
	u64 run_delayed_start;
	u64 qgroup_to_skip;
};

struct btrfs_delayed_root {
	spinlock_t lock;
	struct list_head node_list;
	struct list_head prepare_list;
	atomic_t items;
	atomic_t items_seq;
	int nodes;
	wait_queue_head_t wait;
};

struct btrfs_dev_extent {
	__le64 chunk_tree;
	__le64 chunk_objectid;
	__le64 chunk_offset;
	__le64 length;
	__u8 chunk_tree_uuid[16];
};

struct btrfs_dev_item {
	__le64 devid;
	__le64 total_bytes;
	__le64 bytes_used;
	__le32 io_align;
	__le32 io_width;
	__le32 sector_size;
	__le64 type;
	__le64 generation;
	__le64 start_offset;
	__le32 dev_group;
	__u8 seek_speed;
	__u8 bandwidth;
	__u8 uuid[16];
	__u8 fsid[16];
} __attribute__((packed));

struct btrfs_dev_lookup_args {
	u64 devid;
	u8 *uuid;
	u8 *fsid;
	bool missing;
};

struct btrfs_scrub_progress {
	__u64 data_extents_scrubbed;
	__u64 tree_extents_scrubbed;
	__u64 data_bytes_scrubbed;
	__u64 tree_bytes_scrubbed;
	__u64 read_errors;
	__u64 csum_errors;
	__u64 verify_errors;
	__u64 no_csum;
	__u64 csum_discards;
	__u64 super_errors;
	__u64 malloc_errors;
	__u64 uncorrectable_errors;
	__u64 corrected_errors;
	__u64 last_physical;
	__u64 unverified_errors;
};

struct btrfs_dev_replace {
	u64 replace_state;
	time64_t time_started;
	time64_t time_stopped;
	atomic64_t num_write_errors;
	atomic64_t num_uncorrectable_read_errors;
	u64 cursor_left;
	u64 committed_cursor_left;
	u64 cursor_left_last_write_of_item;
	u64 cursor_right;
	u64 cont_reading_from_srcdev_mode;
	int is_valid;
	int item_needs_writeback;
	struct btrfs_device *srcdev;
	struct btrfs_device *tgtdev;
	struct mutex lock_finishing_cancel_unmount;
	struct rw_semaphore rwsem;
	struct btrfs_scrub_progress scrub_progress;
	struct percpu_counter bio_counter;
	wait_queue_head_t replace_wait;
	struct task_struct *replace_task;
};

struct btrfs_dev_replace_item {
	__le64 src_devid;
	__le64 cursor_left;
	__le64 cursor_right;
	__le64 cont_reading_from_srcdev_mode;
	__le64 replace_state;
	__le64 time_started;
	__le64 time_stopped;
	__le64 num_write_errors;
	__le64 num_uncorrectable_read_errors;
};

struct btrfs_dev_stats_item {
	__le64 values[5];
};

struct extent_io_tree {
	struct rb_root state;
	union {
		struct btrfs_fs_info *fs_info;
		struct btrfs_inode *inode;
	};
	u8 owner;
	spinlock_t lock;
};

struct btrfs_fs_devices;

struct rcu_string;

struct btrfs_zoned_device_info;

struct scrub_ctx;

struct btrfs_device {
	struct list_head dev_list;
	struct list_head dev_alloc_list;
	struct list_head post_commit_list;
	struct btrfs_fs_devices *fs_devices;
	struct btrfs_fs_info *fs_info;
	struct rcu_string *name;
	u64 generation;
	struct file *bdev_file;
	struct block_device *bdev;
	struct btrfs_zoned_device_info *zone_info;
	dev_t devt;
	long unsigned int dev_state;
	blk_status_t last_flush_error;
	u64 devid;
	u64 total_bytes;
	u64 disk_total_bytes;
	u64 bytes_used;
	u32 io_align;
	u32 io_width;
	u64 type;
	atomic_t sb_write_errors;
	u32 sector_size;
	u8 uuid[16];
	u64 commit_total_bytes;
	u64 commit_bytes_used;
	struct bio flush_bio;
	struct completion flush_wait;
	struct scrub_ctx *scrub_ctx;
	int dev_stats_valid;
	atomic_t dev_stats_ccnt;
	atomic_t dev_stat_values[5];
	struct extent_io_tree alloc_state;
	struct completion kobj_unregister;
	struct kobject devid_kobj;
	u64 scrub_speed_max;
};

struct btrfs_device_info {
	struct btrfs_device *dev;
	u64 dev_offset;
	u64 max_avail;
	u64 total_avail;
};

struct extent_changeset;

struct btrfs_dio_data {
	ssize_t submitted;
	struct extent_changeset *data_reserved;
	struct btrfs_ordered_extent *ordered;
	bool data_space_reserved;
	bool nocow_done;
};

struct btrfs_dio_private {
	u64 file_offset;
	u32 bytes;
	struct btrfs_bio bbio;
};

struct btrfs_dir_item {
	struct btrfs_disk_key location;
	__le64 transid;
	__le16 data_len;
	__le16 name_len;
	__u8 type;
} __attribute__((packed));

struct btrfs_dir_list {
	u64 ino;
	struct list_head list;
};

struct btrfs_dir_log_item {
	__le64 end;
};

struct btrfs_discard_ctl {
	struct workqueue_struct *discard_workers;
	struct delayed_work work;
	spinlock_t lock;
	struct btrfs_block_group *block_group;
	struct list_head discard_list[3];
	u64 prev_discard;
	u64 prev_discard_time;
	atomic_t discardable_extents;
	atomic64_t discardable_bytes;
	u64 max_discard_size;
	u64 delay_ms;
	u32 iops_limit;
	u32 kbps_limit;
	u64 discard_extent_bytes;
	u64 discard_bitmap_bytes;
	atomic64_t discard_bytes_saved;
};

struct btrfs_discard_stripe {
	struct btrfs_device *dev;
	u64 physical;
	u64 length;
};

struct btrfs_drew_lock {
	atomic_t readers;
	atomic_t writers;
	wait_queue_head_t pending_writers;
	wait_queue_head_t pending_readers;
};

struct btrfs_drop_extents_args {
	struct btrfs_path *path;
	u64 start;
	u64 end;
	bool drop_cache;
	bool replace_extent;
	u32 extent_item_size;
	u64 drop_end;
	u64 bytes_found;
	bool extent_inserted;
};

struct btrfs_eb_write_context {
	struct writeback_control *wbc;
	struct extent_buffer *eb;
	struct btrfs_block_group *zoned_bg;
};

struct btrfs_em_shrink_ctx {
	long int nr_to_scan;
	long int scanned;
};

struct btrfs_encoded_read_private {
	struct completion done;
	void *uring_ctx;
	refcount_t pending_refs;
	blk_status_t status;
};

struct btrfs_extent_data_ref {
	__le64 root;
	__le64 objectid;
	__le64 offset;
	__le32 count;
} __attribute__((packed));

struct btrfs_extent_inline_ref {
	__u8 type;
	__le64 offset;
} __attribute__((packed));

struct btrfs_extent_item {
	__le64 refs;
	__le64 generation;
	__le64 flags;
};

struct btrfs_extent_owner_ref {
	__le64 root_id;
};

struct btrfs_failed_bio {
	struct btrfs_bio *bbio;
	int num_copies;
	atomic_t repair_count;
};

struct kobj_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
};

struct btrfs_feature_attr {
	struct kobj_attribute kobj_attr;
	enum btrfs_feature_set feature_set;
	u64 feature_bit;
};

struct btrfs_fid {
	u64 objectid;
	u64 root_objectid;
	u32 gen;
	u64 parent_objectid;
	u32 parent_gen;
	u64 parent_root_objectid;
} __attribute__((packed));

struct btrfs_fiemap_entry {
	u64 offset;
	u64 phys;
	u64 len;
	u32 flags;
};

struct btrfs_file_extent {
	u64 disk_bytenr;
	u64 disk_num_bytes;
	u64 num_bytes;
	u64 ram_bytes;
	u64 offset;
	u8 compression;
};

struct btrfs_file_extent_item {
	__le64 generation;
	__le64 ram_bytes;
	__u8 compression;
	__u8 encryption;
	__le16 other_encoding;
	__u8 type;
	__le64 disk_bytenr;
	__le64 disk_num_bytes;
	__le64 offset;
	__le64 num_bytes;
} __attribute__((packed));

struct extent_state;

struct btrfs_file_private {
	void *filldir_buf;
	u64 last_index;
	struct extent_state *llseek_cached_state;
	struct task_struct *owner_task;
};

struct btrfs_free_cluster {
	spinlock_t lock;
	spinlock_t refill_lock;
	struct rb_root root;
	u64 max_size;
	u64 window_start;
	bool fragmented;
	struct btrfs_block_group *block_group;
	struct list_head block_group_list;
};

struct btrfs_free_space {
	struct rb_node offset_index;
	struct rb_node bytes_index;
	u64 offset;
	u64 bytes;
	u64 max_extent_size;
	long unsigned int *bitmap;
	struct list_head list;
	enum btrfs_trim_state trim_state;
	s32 bitmap_extents;
};

struct btrfs_free_space_op;

struct btrfs_free_space_ctl {
	spinlock_t tree_lock;
	struct rb_root free_space_offset;
	struct rb_root_cached free_space_bytes;
	u64 free_space;
	int extents_thresh;
	int free_extents;
	int total_bitmaps;
	int unit;
	u64 start;
	s32 discardable_extents[2];
	s64 discardable_bytes[2];
	const struct btrfs_free_space_op *op;
	struct btrfs_block_group *block_group;
	struct mutex cache_writeout_mutex;
	struct list_head trimming_ranges;
};

struct btrfs_free_space_entry {
	__le64 offset;
	__le64 bytes;
	__u8 type;
} __attribute__((packed));

struct btrfs_free_space_header {
	struct btrfs_disk_key location;
	__le64 generation;
	__le64 num_entries;
	__le64 num_bitmaps;
} __attribute__((packed));

struct btrfs_free_space_info {
	__le32 extent_count;
	__le32 flags;
};

struct btrfs_free_space_op {
	bool (*use_bitmap)(struct btrfs_free_space_ctl *, struct btrfs_free_space *);
};

struct btrfs_fs_context {
	char *subvol_name;
	u64 subvol_objectid;
	u64 max_inline;
	u32 commit_interval;
	u32 metadata_ratio;
	u32 thread_pool_size;
	long long unsigned int mount_opt;
	long unsigned int compress_type: 4;
	unsigned int compress_level;
	refcount_t refs;
};

struct btrfs_fs_devices {
	u8 fsid[16];
	u8 metadata_uuid[16];
	struct list_head fs_list;
	u64 num_devices;
	u64 open_devices;
	u64 rw_devices;
	u64 missing_devices;
	u64 total_rw_bytes;
	u64 total_devices;
	u64 latest_generation;
	struct btrfs_device *latest_dev;
	struct mutex device_list_mutex;
	struct list_head devices;
	struct list_head alloc_list;
	struct list_head seed_list;
	int opened;
	bool rotating;
	bool discardable;
	bool seeding;
	bool temp_fsid;
	bool collect_fs_stats;
	struct btrfs_fs_info *fs_info;
	struct kobject fsid_kobj;
	struct kobject *devices_kobj;
	struct kobject *devinfo_kobj;
	struct completion kobj_unregister;
	enum btrfs_chunk_allocation_policy chunk_alloc_policy;
	enum btrfs_read_policy read_policy;
};

struct semaphore {
	raw_spinlock_t lock;
	unsigned int count;
	struct list_head wait_list;
};

struct queue_limits {
	blk_features_t features;
	blk_flags_t flags;
	long unsigned int seg_boundary_mask;
	long unsigned int virt_boundary_mask;
	unsigned int max_hw_sectors;
	unsigned int max_dev_sectors;
	unsigned int chunk_sectors;
	unsigned int max_sectors;
	unsigned int max_user_sectors;
	unsigned int max_segment_size;
	unsigned int min_segment_size;
	unsigned int physical_block_size;
	unsigned int logical_block_size;
	unsigned int alignment_offset;
	unsigned int io_min;
	unsigned int io_opt;
	unsigned int max_discard_sectors;
	unsigned int max_hw_discard_sectors;
	unsigned int max_user_discard_sectors;
	unsigned int max_secure_erase_sectors;
	unsigned int max_write_zeroes_sectors;
	unsigned int max_hw_zone_append_sectors;
	unsigned int max_zone_append_sectors;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	unsigned int zone_write_granularity;
	unsigned int atomic_write_hw_max;
	unsigned int atomic_write_max_sectors;
	unsigned int atomic_write_hw_boundary;
	unsigned int atomic_write_boundary_sectors;
	unsigned int atomic_write_hw_unit_min;
	unsigned int atomic_write_unit_min;
	unsigned int atomic_write_hw_unit_max;
	unsigned int atomic_write_unit_max;
	short unsigned int max_segments;
	short unsigned int max_integrity_segments;
	short unsigned int max_discard_segments;
	unsigned int max_open_zones;
	unsigned int max_active_zones;
	unsigned int dma_alignment;
	unsigned int dma_pad_mask;
	struct blk_integrity integrity;
};

struct lockdep_map {};

struct btrfs_transaction;

struct btrfs_super_block;

struct btrfs_stripe_hash_table;

struct reloc_control;

struct crypto_shash;

struct btrfs_fs_info {
	u8 chunk_tree_uuid[16];
	long unsigned int flags;
	struct btrfs_root *tree_root;
	struct btrfs_root *chunk_root;
	struct btrfs_root *dev_root;
	struct btrfs_root *fs_root;
	struct btrfs_root *quota_root;
	struct btrfs_root *uuid_root;
	struct btrfs_root *data_reloc_root;
	struct btrfs_root *block_group_root;
	struct btrfs_root *stripe_root;
	struct btrfs_root *log_root_tree;
	rwlock_t global_root_lock;
	struct rb_root global_root_tree;
	spinlock_t fs_roots_radix_lock;
	struct xarray fs_roots_radix;
	rwlock_t block_group_cache_lock;
	struct rb_root_cached block_group_cache_tree;
	atomic64_t free_chunk_space;
	struct extent_io_tree excluded_extents;
	struct rb_root_cached mapping_tree;
	rwlock_t mapping_tree_lock;
	struct btrfs_block_rsv global_block_rsv;
	struct btrfs_block_rsv trans_block_rsv;
	struct btrfs_block_rsv chunk_block_rsv;
	struct btrfs_block_rsv delayed_block_rsv;
	struct btrfs_block_rsv delayed_refs_rsv;
	struct btrfs_block_rsv empty_block_rsv;
	u64 generation;
	u64 last_trans_committed;
	u64 last_reloc_trans;
	u64 last_trans_log_full_commit;
	long long unsigned int mount_opt;
	long unsigned int compress_type: 4;
	unsigned int compress_level;
	u32 commit_interval;
	u64 max_inline;
	struct btrfs_transaction *running_transaction;
	wait_queue_head_t transaction_throttle;
	wait_queue_head_t transaction_wait;
	wait_queue_head_t transaction_blocked_wait;
	wait_queue_head_t async_submit_wait;
	spinlock_t super_lock;
	struct btrfs_super_block *super_copy;
	struct btrfs_super_block *super_for_commit;
	struct super_block *sb;
	struct inode *btree_inode;
	struct mutex tree_log_mutex;
	struct mutex transaction_kthread_mutex;
	struct mutex cleaner_mutex;
	struct mutex chunk_mutex;
	struct mutex ro_block_group_mutex;
	struct btrfs_stripe_hash_table *stripe_hash_table;
	struct mutex ordered_operations_mutex;
	struct rw_semaphore commit_root_sem;
	struct rw_semaphore cleanup_work_sem;
	struct rw_semaphore subvol_sem;
	spinlock_t trans_lock;
	struct mutex reloc_mutex;
	struct list_head trans_list;
	struct list_head dead_roots;
	struct list_head caching_block_groups;
	spinlock_t delayed_iput_lock;
	struct list_head delayed_iputs;
	atomic_t nr_delayed_iputs;
	wait_queue_head_t delayed_iputs_wait;
	atomic64_t tree_mod_seq;
	rwlock_t tree_mod_log_lock;
	struct rb_root tree_mod_log;
	struct list_head tree_mod_seq_list;
	atomic_t async_delalloc_pages;
	spinlock_t ordered_root_lock;
	struct list_head ordered_roots;
	struct mutex delalloc_root_mutex;
	spinlock_t delalloc_root_lock;
	struct list_head delalloc_roots;
	struct btrfs_workqueue *workers;
	struct btrfs_workqueue *delalloc_workers;
	struct btrfs_workqueue *flush_workers;
	struct workqueue_struct *endio_workers;
	struct workqueue_struct *endio_meta_workers;
	struct workqueue_struct *rmw_workers;
	struct workqueue_struct *compressed_write_workers;
	struct btrfs_workqueue *endio_write_workers;
	struct btrfs_workqueue *endio_freespace_worker;
	struct btrfs_workqueue *caching_workers;
	struct btrfs_workqueue *fixup_workers;
	struct btrfs_workqueue *delayed_workers;
	struct task_struct *transaction_kthread;
	struct task_struct *cleaner_kthread;
	u32 thread_pool_size;
	struct kobject *space_info_kobj;
	struct kobject *qgroups_kobj;
	struct kobject *discard_kobj;
	struct percpu_counter stats_read_blocks;
	struct percpu_counter dirty_metadata_bytes;
	struct percpu_counter delalloc_bytes;
	struct percpu_counter ordered_bytes;
	s32 dirty_metadata_batch;
	s32 delalloc_batch;
	struct percpu_counter evictable_extent_maps;
	u64 em_shrinker_last_root;
	u64 em_shrinker_last_ino;
	atomic64_t em_shrinker_nr_to_scan;
	struct work_struct em_shrinker_work;
	struct list_head dirty_cowonly_roots;
	struct btrfs_fs_devices *fs_devices;
	struct list_head space_info;
	struct btrfs_space_info *data_sinfo;
	struct reloc_control *reloc_ctl;
	struct btrfs_free_cluster data_alloc_cluster;
	struct btrfs_free_cluster meta_alloc_cluster;
	spinlock_t defrag_inodes_lock;
	struct rb_root defrag_inodes;
	atomic_t defrag_running;
	seqlock_t profiles_lock;
	u64 avail_data_alloc_bits;
	u64 avail_metadata_alloc_bits;
	u64 avail_system_alloc_bits;
	spinlock_t balance_lock;
	struct mutex balance_mutex;
	atomic_t balance_pause_req;
	atomic_t balance_cancel_req;
	struct btrfs_balance_control *balance_ctl;
	wait_queue_head_t balance_wait_q;
	atomic_t reloc_cancel_req;
	u32 data_chunk_allocations;
	u32 metadata_ratio;
	void *bdev_holder;
	struct mutex scrub_lock;
	atomic_t scrubs_running;
	atomic_t scrub_pause_req;
	atomic_t scrubs_paused;
	atomic_t scrub_cancel_req;
	wait_queue_head_t scrub_pause_wait;
	refcount_t scrub_workers_refcnt;
	u32 sectors_per_page;
	struct workqueue_struct *scrub_workers;
	struct btrfs_discard_ctl discard_ctl;
	u64 qgroup_flags;
	struct rb_root qgroup_tree;
	spinlock_t qgroup_lock;
	struct ulist *qgroup_ulist;
	struct mutex qgroup_ioctl_lock;
	struct list_head dirty_qgroups;
	u64 qgroup_seq;
	struct mutex qgroup_rescan_lock;
	struct btrfs_key qgroup_rescan_progress;
	struct btrfs_workqueue *qgroup_rescan_workers;
	struct completion qgroup_rescan_completion;
	struct btrfs_work qgroup_rescan_work;
	bool qgroup_rescan_running;
	u8 qgroup_drop_subtree_thres;
	u64 qgroup_enable_gen;
	int fs_error;
	long unsigned int fs_state;
	struct btrfs_delayed_root *delayed_root;
	spinlock_t buffer_lock;
	struct xarray buffer_radix;
	int backup_root_index;
	struct btrfs_dev_replace dev_replace;
	struct semaphore uuid_tree_rescan_sem;
	struct work_struct async_reclaim_work;
	struct work_struct async_data_reclaim_work;
	struct work_struct preempt_reclaim_work;
	struct work_struct reclaim_bgs_work;
	struct list_head reclaim_bgs;
	int bg_reclaim_threshold;
	spinlock_t unused_bgs_lock;
	struct list_head unused_bgs;
	struct mutex unused_bg_unpin_mutex;
	struct mutex reclaim_bgs_lock;
	u32 nodesize;
	u32 sectorsize;
	u32 sectorsize_bits;
	u32 csum_size;
	u32 csums_per_leaf;
	u32 stripesize;
	u64 max_extent_size;
	spinlock_t swapfile_pins_lock;
	struct rb_root swapfile_pins;
	struct crypto_shash *csum_shash;
	enum btrfs_exclusive_operation exclusive_operation;
	u64 zone_size;
	struct queue_limits limits;
	u64 max_zone_append_size;
	struct mutex zoned_meta_io_lock;
	spinlock_t treelog_bg_lock;
	u64 treelog_bg;
	spinlock_t relocation_bg_lock;
	u64 data_reloc_bg;
	struct mutex zoned_data_reloc_io_lock;
	struct btrfs_block_group *active_meta_bg;
	struct btrfs_block_group *active_system_bg;
	u64 nr_global_roots;
	spinlock_t zone_active_bgs_lock;
	struct list_head zone_active_bgs;
	struct btrfs_commit_stats commit_stats;
	u64 last_root_drop_gen;
	struct lockdep_map btrfs_trans_num_writers_map;
	struct lockdep_map btrfs_trans_num_extwriters_map;
	struct lockdep_map btrfs_state_change_map[4];
	struct lockdep_map btrfs_trans_pending_ordered_map;
	struct lockdep_map btrfs_ordered_extent_map;
};

struct btrfs_header {
	__u8 csum[32];
	__u8 fsid[16];
	__le64 bytenr;
	__le64 flags;
	__u8 chunk_tree_uuid[16];
	__le64 generation;
	__le64 owner;
	__le32 nritems;
	__u8 level;
} __attribute__((packed));

struct btrfs_iget_args {
	u64 ino;
	struct btrfs_root *root;
};

struct btrfs_ino_list {
	u64 ino;
	u64 parent;
	struct list_head list;
};

struct extent_map_tree {
	struct rb_root root;
	struct list_head modified_extents;
	rwlock_t lock;
};

struct btrfs_inode {
	struct btrfs_root *root;
	u8 prop_compress;
	u8 defrag_compress;
	spinlock_t lock;
	struct extent_map_tree extent_tree;
	struct extent_io_tree io_tree;
	struct extent_io_tree *file_extent_tree;
	struct mutex log_mutex;
	unsigned int outstanding_extents;
	spinlock_t ordered_tree_lock;
	struct rb_root ordered_tree;
	struct rb_node *ordered_tree_last;
	struct list_head delalloc_inodes;
	long unsigned int runtime_flags;
	u64 generation;
	u64 last_trans;
	u64 logged_trans;
	int last_sub_trans;
	int last_log_commit;
	union {
		u64 delalloc_bytes;
		u64 first_dir_index_to_log;
	};
	union {
		u64 new_delalloc_bytes;
		u64 last_dir_index_offset;
	};
	union {
		u64 defrag_bytes;
		u64 reloc_block_group_start;
	};
	u64 disk_i_size;
	union {
		u64 index_cnt;
		u64 csum_bytes;
	};
	u64 dir_index;
	u64 last_unlink_trans;
	union {
		u64 last_reflink_trans;
		u64 ref_root_id;
	};
	u32 flags;
	u32 ro_flags;
	struct btrfs_block_rsv block_rsv;
	struct btrfs_delayed_node *delayed_node;
	u64 i_otime_sec;
	u32 i_otime_nsec;
	struct list_head delayed_iput;
	struct rw_semaphore i_mmap_lock;
	struct inode vfs_inode;
};

struct btrfs_inode_extref {
	__le64 parent_objectid;
	__le64 index;
	__le16 name_len;
	__u8 name[0];
} __attribute__((packed));

struct btrfs_inode_info {
	u64 size;
	u64 gen;
	u64 mode;
	u64 uid;
	u64 gid;
	u64 rdev;
	u64 fileattr;
	u64 nlink;
};

struct btrfs_inode_ref {
	__le64 index;
	__le16 name_len;
} __attribute__((packed));

struct btrfs_io_context {
	refcount_t refs;
	struct btrfs_fs_info *fs_info;
	u64 map_type;
	struct bio *orig_bio;
	atomic_t error;
	u16 max_errors;
	bool use_rst;
	u64 logical;
	u64 size;
	struct list_head rst_ordered_entry;
	u16 num_stripes;
	u16 mirror_num;
	u16 replace_nr_stripes;
	s16 replace_stripe_src;
	u64 full_stripe_logical;
	struct btrfs_io_stripe stripes[0];
};

struct btrfs_io_geometry {
	u32 stripe_index;
	u32 stripe_nr;
	int mirror_num;
	int num_stripes;
	u64 stripe_offset;
	u64 raid56_full_stripe_start;
	int max_errors;
	enum btrfs_map_op op;
	bool use_rst;
};

struct btrfs_ioctl_balance_args {
	__u64 flags;
	__u64 state;
	struct btrfs_balance_args data;
	struct btrfs_balance_args meta;
	struct btrfs_balance_args sys;
	struct btrfs_balance_progress stat;
	__u64 unused[72];
};

struct btrfs_ioctl_defrag_range_args {
	__u64 start;
	__u64 len;
	__u64 flags;
	__u32 extent_thresh;
	__u32 compress_type;
	__u32 unused[4];
};

struct btrfs_ioctl_dev_info_args {
	__u64 devid;
	__u8 uuid[16];
	__u64 bytes_used;
	__u64 total_bytes;
	__u8 fsid[16];
	__u64 unused[377];
	__u8 path[1024];
};

struct btrfs_ioctl_dev_replace_start_params {
	__u64 srcdevid;
	__u64 cont_reading_from_srcdev_mode;
	__u8 srcdev_name[1025];
	__u8 tgtdev_name[1025];
};

struct btrfs_ioctl_dev_replace_status_params {
	__u64 replace_state;
	__u64 progress_1000;
	__u64 time_started;
	__u64 time_stopped;
	__u64 num_write_errors;
	__u64 num_uncorrectable_read_errors;
};

struct btrfs_ioctl_dev_replace_args {
	__u64 cmd;
	__u64 result;
	union {
		struct btrfs_ioctl_dev_replace_start_params start;
		struct btrfs_ioctl_dev_replace_status_params status;
	};
	__u64 spare[64];
};

struct btrfs_ioctl_encoded_io_args {
	const struct iovec *iov;
	long unsigned int iovcnt;
	__s64 offset;
	__u64 flags;
	__u64 len;
	__u64 unencoded_len;
	__u64 unencoded_offset;
	__u32 compression;
	__u32 encryption;
	__u8 reserved[64];
};

struct btrfs_ioctl_feature_flags {
	__u64 compat_flags;
	__u64 compat_ro_flags;
	__u64 incompat_flags;
};

struct btrfs_ioctl_fs_info_args {
	__u64 max_id;
	__u64 num_devices;
	__u8 fsid[16];
	__u32 nodesize;
	__u32 sectorsize;
	__u32 clone_alignment;
	__u16 csum_type;
	__u16 csum_size;
	__u64 flags;
	__u64 generation;
	__u8 metadata_uuid[16];
	__u8 reserved[944];
};

struct btrfs_ioctl_get_dev_stats {
	__u64 devid;
	__u64 nr_items;
	__u64 flags;
	__u64 values[5];
	__u64 unused[121];
};

struct btrfs_ioctl_timespec {
	__u64 sec;
	__u32 nsec;
};

struct btrfs_ioctl_get_subvol_info_args {
	__u64 treeid;
	char name[256];
	__u64 parent_id;
	__u64 dirid;
	__u64 generation;
	__u64 flags;
	__u8 uuid[16];
	__u8 parent_uuid[16];
	__u8 received_uuid[16];
	__u64 ctransid;
	__u64 otransid;
	__u64 stransid;
	__u64 rtransid;
	struct btrfs_ioctl_timespec ctime;
	struct btrfs_ioctl_timespec otime;
	struct btrfs_ioctl_timespec stime;
	struct btrfs_ioctl_timespec rtime;
	__u64 reserved[8];
};

struct btrfs_ioctl_get_subvol_rootref_args {
	__u64 min_treeid;
	struct {
		__u64 treeid;
		__u64 dirid;
	} rootref[255];
	__u8 num_items;
	__u8 align[7];
};

struct btrfs_ioctl_ino_lookup_args {
	__u64 treeid;
	__u64 objectid;
	char name[4080];
};

struct btrfs_ioctl_ino_lookup_user_args {
	__u64 dirid;
	__u64 treeid;
	char name[256];
	char path[3824];
};

struct btrfs_ioctl_ino_path_args {
	__u64 inum;
	__u64 size;
	__u64 reserved[4];
	__u64 fspath;
};

struct btrfs_ioctl_logical_ino_args {
	__u64 logical;
	__u64 size;
	__u64 reserved[3];
	__u64 flags;
	__u64 inodes;
};

struct btrfs_ioctl_qgroup_assign_args {
	__u64 assign;
	__u64 src;
	__u64 dst;
};

struct btrfs_ioctl_qgroup_create_args {
	__u64 create;
	__u64 qgroupid;
};

struct btrfs_qgroup_limit {
	__u64 flags;
	__u64 max_rfer;
	__u64 max_excl;
	__u64 rsv_rfer;
	__u64 rsv_excl;
};

struct btrfs_ioctl_qgroup_limit_args {
	__u64 qgroupid;
	struct btrfs_qgroup_limit lim;
};

struct btrfs_ioctl_quota_ctl_args {
	__u64 cmd;
	__u64 status;
};

struct btrfs_ioctl_quota_rescan_args {
	__u64 flags;
	__u64 progress;
	__u64 reserved[6];
};

struct btrfs_ioctl_received_subvol_args {
	char uuid[16];
	__u64 stransid;
	__u64 rtransid;
	struct btrfs_ioctl_timespec stime;
	struct btrfs_ioctl_timespec rtime;
	__u64 flags;
	__u64 reserved[16];
};

struct btrfs_ioctl_timespec_32 {
	__u64 sec;
	__u32 nsec;
} __attribute__((packed));

struct btrfs_ioctl_received_subvol_args_32 {
	char uuid[16];
	__u64 stransid;
	__u64 rtransid;
	struct btrfs_ioctl_timespec_32 stime;
	struct btrfs_ioctl_timespec_32 rtime;
	__u64 flags;
	__u64 reserved[16];
};

struct btrfs_ioctl_scrub_args {
	__u64 devid;
	__u64 start;
	__u64 end;
	__u64 flags;
	struct btrfs_scrub_progress progress;
	__u64 unused[109];
};

struct btrfs_ioctl_search_key {
	__u64 tree_id;
	__u64 min_objectid;
	__u64 max_objectid;
	__u64 min_offset;
	__u64 max_offset;
	__u64 min_transid;
	__u64 max_transid;
	__u32 min_type;
	__u32 max_type;
	__u32 nr_items;
	__u32 unused;
	__u64 unused1;
	__u64 unused2;
	__u64 unused3;
	__u64 unused4;
};

struct btrfs_ioctl_search_args {
	struct btrfs_ioctl_search_key key;
	char buf[3992];
};

struct btrfs_ioctl_search_args_v2 {
	struct btrfs_ioctl_search_key key;
	__u64 buf_size;
	__u64 buf[0];
};

struct btrfs_ioctl_search_header {
	__u64 transid;
	__u64 objectid;
	__u64 offset;
	__u32 type;
	__u32 len;
};

struct btrfs_ioctl_send_args {
	__s64 send_fd;
	__u64 clone_sources_count;
	__u64 *clone_sources;
	__u64 parent_root;
	__u64 flags;
	__u32 version;
	__u8 reserved[28];
};

struct btrfs_ioctl_space_info {
	__u64 flags;
	__u64 total_bytes;
	__u64 used_bytes;
};

struct btrfs_ioctl_space_args {
	__u64 space_slots;
	__u64 total_spaces;
	struct btrfs_ioctl_space_info spaces[0];
};

struct btrfs_ioctl_subvol_wait {
	__u64 subvolid;
	__u32 mode;
	__u32 count;
};

struct btrfs_ioctl_vol_args {
	__s64 fd;
	char name[4088];
};

struct btrfs_qgroup_inherit;

struct btrfs_ioctl_vol_args_v2 {
	__s64 fd;
	__u64 transid;
	__u64 flags;
	union {
		struct {
			__u64 size;
			struct btrfs_qgroup_inherit *qgroup_inherit;
		};
		__u64 unused[4];
	};
	union {
		char name[4040];
		__u64 devid;
		__u64 subvolid;
	};
};

struct btrfs_item {
	struct btrfs_disk_key key;
	__le32 offset;
	__le32 size;
} __attribute__((packed));

struct btrfs_item_batch {
	const struct btrfs_key *keys;
	const u32 *data_sizes;
	u32 total_data_size;
	int nr;
};

struct btrfs_key_ptr {
	struct btrfs_disk_key key;
	__le64 blockptr;
	__le64 generation;
} __attribute__((packed));

struct btrfs_log_ctx {
	int log_ret;
	int log_transid;
	bool log_new_dentries;
	bool logging_new_name;
	bool logging_new_delayed_dentries;
	bool logged_before;
	struct btrfs_inode *inode;
	struct list_head list;
	struct list_head ordered_extents;
	struct list_head conflict_inodes;
	int num_conflict_inodes;
	bool logging_conflict_inodes;
	struct extent_buffer *scratch_eb;
};

struct maple_tree {
	union {
		spinlock_t ma_lock;
		lockdep_map_p ma_external_lock;
	};
	unsigned int ma_flags;
	void *ma_root;
};

struct btrfs_lru_cache {
	struct list_head lru_list;
	struct maple_tree entries;
	unsigned int size;
	unsigned int max_size;
};

struct btrfs_map_token {
	struct extent_buffer *eb;
	char *kaddr;
	long unsigned int offset;
};

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
	bool is_nokey_name;
};

struct btrfs_new_inode_args {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool orphan;
	bool subvol;
	struct posix_acl *default_acl;
	struct posix_acl *acl;
	struct fscrypt_name fname;
};

struct btrfs_ordered_extent {
	u64 file_offset;
	u64 num_bytes;
	u64 ram_bytes;
	u64 disk_bytenr;
	u64 disk_num_bytes;
	u64 offset;
	u64 bytes_left;
	u64 truncated_len;
	long unsigned int flags;
	int compress_type;
	int qgroup_rsv;
	refcount_t refs;
	struct btrfs_inode *inode;
	struct list_head list;
	struct list_head log_list;
	wait_queue_head_t wait;
	struct rb_node rb_node;
	struct list_head root_extent_list;
	struct btrfs_work work;
	struct completion completion;
	struct btrfs_work flush_work;
	struct list_head work_list;
	struct list_head bioc_list;
};

struct btrfs_ordered_sum {
	u64 logical;
	u32 len;
	struct list_head list;
	u8 sums[0];
};

struct btrfs_path {
	struct extent_buffer *nodes[8];
	int slots[8];
	u8 locks[8];
	u8 reada;
	u8 lowest_level;
	unsigned int search_for_split: 1;
	unsigned int keep_locks: 1;
	unsigned int skip_locking: 1;
	unsigned int search_commit_root: 1;
	unsigned int need_commit_sem: 1;
	unsigned int skip_release_on_error: 1;
	unsigned int search_for_extension: 1;
	unsigned int nowait: 1;
};

struct btrfs_root_item;

struct btrfs_pending_snapshot {
	struct dentry *dentry;
	struct btrfs_inode *dir;
	struct btrfs_root *root;
	struct btrfs_root_item *root_item;
	struct btrfs_root *snap;
	struct btrfs_qgroup_inherit *inherit;
	struct btrfs_path *path;
	struct btrfs_block_rsv block_rsv;
	int error;
	dev_t anon_dev;
	bool readonly;
	struct list_head list;
};

struct btrfs_plug_cb {
	struct blk_plug_cb cb;
	struct btrfs_fs_info *info;
	struct list_head rbio_list;
};

struct btrfs_qgroup_rsv {
	u64 values[3];
};

struct btrfs_qgroup {
	u64 qgroupid;
	u64 rfer;
	u64 rfer_cmpr;
	u64 excl;
	u64 excl_cmpr;
	u64 lim_flags;
	u64 max_rfer;
	u64 max_excl;
	u64 rsv_rfer;
	u64 rsv_excl;
	struct btrfs_qgroup_rsv rsv;
	struct list_head groups;
	struct list_head members;
	struct list_head dirty;
	struct list_head iterator;
	struct list_head nested_iterator;
	struct rb_node node;
	u64 old_refcnt;
	u64 new_refcnt;
	struct kobject kobj;
};

struct btrfs_qgroup_extent_record {
	u64 num_bytes;
	u32 data_rsv;
	u64 data_rsv_refroot;
	struct ulist *old_roots;
};

struct btrfs_qgroup_info_item {
	__le64 generation;
	__le64 rfer;
	__le64 rfer_cmpr;
	__le64 excl;
	__le64 excl_cmpr;
};

struct btrfs_qgroup_inherit {
	__u64 flags;
	__u64 num_qgroups;
	__u64 num_ref_copies;
	__u64 num_excl_copies;
	struct btrfs_qgroup_limit lim;
	__u64 qgroups[0];
};

struct btrfs_qgroup_limit_item {
	__le64 flags;
	__le64 max_rfer;
	__le64 max_excl;
	__le64 rsv_rfer;
	__le64 rsv_excl;
};

struct btrfs_qgroup_list {
	struct list_head next_group;
	struct list_head next_member;
	struct btrfs_qgroup *group;
	struct btrfs_qgroup *member;
};

struct btrfs_qgroup_status_item {
	__le64 version;
	__le64 generation;
	__le64 flags;
	__le64 rescan;
	__le64 enable_gen;
};

struct btrfs_qgroup_swapped_block {
	struct rb_node node;
	int level;
	bool trace_leaf;
	u64 subvol_bytenr;
	u64 subvol_generation;
	u64 reloc_bytenr;
	u64 reloc_generation;
	u64 last_snapshot;
	struct btrfs_key first_key;
};

struct btrfs_qgroup_swapped_blocks {
	spinlock_t lock;
	bool swapped;
	struct rb_root blocks[8];
};

struct btrfs_raid_attr {
	u8 sub_stripes;
	u8 dev_stripes;
	u8 devs_max;
	u8 devs_min;
	u8 tolerated_failures;
	u8 devs_increment;
	u8 ncopies;
	u8 nparity;
	u8 mindev_error;
	const char raid_name[8];
	u64 bg_flag;
};

struct sector_ptr;

struct btrfs_raid_bio {
	struct btrfs_io_context *bioc;
	struct list_head hash_list;
	struct list_head stripe_cache;
	struct work_struct work;
	struct bio_list bio_list;
	spinlock_t bio_list_lock;
	struct list_head plug_list;
	long unsigned int flags;
	enum btrfs_rbio_ops operation;
	u16 nr_pages;
	u16 nr_sectors;
	u8 nr_data;
	u8 real_stripes;
	u8 stripe_npages;
	u8 stripe_nsectors;
	u8 scrubp;
	int bio_list_bytes;
	refcount_t refs;
	atomic_t stripes_pending;
	wait_queue_head_t io_wait;
	long unsigned int dbitmap;
	long unsigned int finish_pbitmap;
	struct page **stripe_pages;
	struct sector_ptr *bio_sectors;
	struct sector_ptr *stripe_sectors;
	void **finish_pointers;
	long unsigned int *error_bitmap;
	u8 *csum_buf;
	long unsigned int *csum_bitmap;
};

struct btrfs_raid_stride {
	__le64 devid;
	__le64 physical;
};

struct btrfs_ref {
	enum btrfs_ref_type type;
	enum btrfs_delayed_ref_action action;
	bool skip_qgroup;
	u64 bytenr;
	u64 num_bytes;
	u64 owning_root;
	u64 ref_root;
	u64 parent;
	union {
		struct btrfs_data_ref data_ref;
		struct btrfs_tree_ref tree_ref;
	};
};

struct btrfs_rename_ctx {
	u64 index;
};

struct btrfs_replace_extent_info {
	u64 disk_offset;
	u64 disk_len;
	u64 data_offset;
	u64 data_len;
	u64 file_offset;
	char *extent_buf;
	bool is_new_extent;
	bool update_times;
	int qgroup_reserved;
	int insertions;
};

struct btrfs_root_item {
	struct btrfs_inode_item inode;
	__le64 generation;
	__le64 root_dirid;
	__le64 bytenr;
	__le64 byte_limit;
	__le64 bytes_used;
	__le64 last_snapshot;
	__le64 flags;
	__le32 refs;
	struct btrfs_disk_key drop_progress;
	__u8 drop_level;
	__u8 level;
	__le64 generation_v2;
	__u8 uuid[16];
	__u8 parent_uuid[16];
	__u8 received_uuid[16];
	__le64 ctransid;
	__le64 otransid;
	__le64 stransid;
	__le64 rtransid;
	struct btrfs_timespec ctime;
	struct btrfs_timespec otime;
	struct btrfs_timespec stime;
	struct btrfs_timespec rtime;
	__le64 reserved[8];
} __attribute__((packed));

struct btrfs_root {
	struct rb_node rb_node;
	struct extent_buffer *node;
	struct extent_buffer *commit_root;
	struct btrfs_root *log_root;
	struct btrfs_root *reloc_root;
	long unsigned int state;
	struct btrfs_root_item root_item;
	struct btrfs_key root_key;
	struct btrfs_fs_info *fs_info;
	struct extent_io_tree dirty_log_pages;
	struct mutex objectid_mutex;
	spinlock_t accounting_lock;
	struct btrfs_block_rsv *block_rsv;
	struct mutex log_mutex;
	wait_queue_head_t log_writer_wait;
	wait_queue_head_t log_commit_wait[2];
	struct list_head log_ctxs[2];
	atomic_t log_writers;
	atomic_t log_commit[2];
	atomic_t log_batch;
	int log_transid;
	int log_transid_committed;
	int last_log_commit;
	pid_t log_start_pid;
	u64 last_trans;
	u64 free_objectid;
	struct btrfs_key defrag_progress;
	struct btrfs_key defrag_max;
	struct list_head dirty_list;
	struct list_head root_list;
	struct xarray inodes;
	struct xarray delayed_nodes;
	dev_t anon_dev;
	spinlock_t root_item_lock;
	refcount_t refs;
	struct mutex delalloc_mutex;
	spinlock_t delalloc_lock;
	struct list_head delalloc_inodes;
	struct list_head delalloc_root;
	u64 nr_delalloc_inodes;
	struct mutex ordered_extent_mutex;
	spinlock_t ordered_extent_lock;
	struct list_head ordered_extents;
	struct list_head ordered_root;
	u64 nr_ordered_extents;
	struct list_head reloc_dirty_list;
	int send_in_progress;
	int dedupe_in_progress;
	struct btrfs_drew_lock snapshot_lock;
	atomic_t snapshot_force_cow;
	spinlock_t qgroup_meta_rsv_lock;
	u64 qgroup_meta_rsv_pertrans;
	u64 qgroup_meta_rsv_prealloc;
	wait_queue_head_t qgroup_flush_wait;
	atomic_t nr_swapfiles;
	struct btrfs_qgroup_swapped_blocks swapped_blocks;
	struct extent_io_tree log_csum_range;
	u64 relocation_src_root;
};

struct btrfs_root_backup {
	__le64 tree_root;
	__le64 tree_root_gen;
	__le64 chunk_root;
	__le64 chunk_root_gen;
	__le64 extent_root;
	__le64 extent_root_gen;
	__le64 fs_root;
	__le64 fs_root_gen;
	__le64 dev_root;
	__le64 dev_root_gen;
	__le64 csum_root;
	__le64 csum_root_gen;
	__le64 total_bytes;
	__le64 bytes_used;
	__le64 num_devices;
	__le64 unused_64[4];
	__u8 tree_root_level;
	__u8 chunk_root_level;
	__u8 extent_root_level;
	__u8 fs_root_level;
	__u8 dev_root_level;
	__u8 csum_root_level;
	__u8 unused_8[10];
};

struct btrfs_root_ref {
	__le64 dirid;
	__le64 sequence;
	__le16 name_len;
} __attribute__((packed));

struct btrfs_seq_list {
	struct list_head list;
	u64 seq;
};

struct btrfs_shared_data_ref {
	__le32 count;
};

struct btrfs_space_info {
	struct btrfs_fs_info *fs_info;
	spinlock_t lock;
	u64 total_bytes;
	u64 bytes_used;
	u64 bytes_pinned;
	u64 bytes_reserved;
	u64 bytes_may_use;
	u64 bytes_readonly;
	u64 bytes_zone_unusable;
	u64 max_extent_size;
	u64 chunk_size;
	int bg_reclaim_threshold;
	int clamp;
	unsigned int full: 1;
	unsigned int chunk_alloc: 1;
	unsigned int flush: 1;
	unsigned int force_alloc;
	u64 disk_used;
	u64 disk_total;
	u64 flags;
	struct list_head list;
	struct list_head ro_bgs;
	struct list_head priority_tickets;
	struct list_head tickets;
	u64 reclaim_size;
	u64 tickets_id;
	struct rw_semaphore groups_sem;
	struct list_head block_groups[9];
	struct kobject kobj;
	struct kobject *block_group_kobjs[9];
	u64 reclaim_count;
	u64 reclaim_bytes;
	u64 reclaim_errors;
	bool dynamic_reclaim;
	bool periodic_reclaim;
	bool periodic_reclaim_ready;
	s64 reclaimable_bytes;
};

struct btrfs_squota_delta {
	u64 root;
	u64 num_bytes;
	u64 generation;
	bool is_inc;
	bool is_data;
};

struct btrfs_stream_header {
	char magic[13];
	__le32 version;
} __attribute__((packed));

struct btrfs_stripe_extent {
	struct {
		struct {} __empty_strides;
		struct btrfs_raid_stride strides[0];
	};
};

struct btrfs_stripe_hash {
	struct list_head hash_list;
	spinlock_t lock;
};

struct btrfs_stripe_hash_table {
	struct list_head stripe_cache;
	spinlock_t cache_lock;
	int cache_size;
	struct btrfs_stripe_hash table[0];
};

struct btrfs_subpage {
	spinlock_t lock;
	union {
		atomic_t eb_refs;
		atomic_t nr_locked;
	};
	long unsigned int bitmaps[0];
};

struct btrfs_super_block {
	__u8 csum[32];
	__u8 fsid[16];
	__le64 bytenr;
	__le64 flags;
	__le64 magic;
	__le64 generation;
	__le64 root;
	__le64 chunk_root;
	__le64 log_root;
	__le64 __unused_log_root_transid;
	__le64 total_bytes;
	__le64 bytes_used;
	__le64 root_dir_objectid;
	__le64 num_devices;
	__le32 sectorsize;
	__le32 nodesize;
	__le32 __unused_leafsize;
	__le32 stripesize;
	__le32 sys_chunk_array_size;
	__le64 chunk_root_generation;
	__le64 compat_flags;
	__le64 compat_ro_flags;
	__le64 incompat_flags;
	__le16 csum_type;
	__u8 root_level;
	__u8 chunk_root_level;
	__u8 log_root_level;
	struct btrfs_dev_item dev_item;
	char label[256];
	__le64 cache_generation;
	__le64 uuid_tree_generation;
	__u8 metadata_uuid[16];
	__u64 nr_global_roots;
	__le64 reserved[27];
	__u8 sys_chunk_array[2048];
	struct btrfs_root_backup super_roots[4];
	__u8 padding[565];
} __attribute__((packed));

struct btrfs_swap_info {
	u64 start;
	u64 block_start;
	u64 block_len;
	u64 lowest_ppage;
	u64 highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
};

struct btrfs_swapfile_pin {
	struct rb_node node;
	void *ptr;
	struct inode *inode;
	bool is_block_group;
	int bg_extent_count;
};

struct btrfs_tlv_header {
	__le16 tlv_type;
	__le16 tlv_len;
};

struct btrfs_trans_handle {
	u64 transid;
	u64 bytes_reserved;
	u64 delayed_refs_bytes_reserved;
	u64 chunk_bytes_reserved;
	long unsigned int delayed_ref_updates;
	long unsigned int delayed_ref_csum_deletions;
	struct btrfs_transaction *transaction;
	struct btrfs_block_rsv *block_rsv;
	struct btrfs_block_rsv *orig_rsv;
	struct btrfs_pending_snapshot *pending_snapshot;
	refcount_t use_count;
	unsigned int type;
	short int aborted;
	bool adding_csums;
	bool allocating_chunk;
	bool removing_chunk;
	bool reloc_reserved;
	bool in_fsync;
	struct btrfs_fs_info *fs_info;
	struct list_head new_bgs;
	struct btrfs_block_rsv delayed_rsv;
};

struct btrfs_transaction {
	u64 transid;
	atomic_t num_extwriters;
	atomic_t num_writers;
	refcount_t use_count;
	long unsigned int flags;
	enum btrfs_trans_state state;
	int aborted;
	struct list_head list;
	struct extent_io_tree dirty_pages;
	time64_t start_time;
	wait_queue_head_t writer_wait;
	wait_queue_head_t commit_wait;
	struct list_head pending_snapshots;
	struct list_head dev_update_list;
	struct list_head switch_commits;
	struct list_head dirty_bgs;
	struct list_head io_bgs;
	struct list_head dropped_roots;
	struct extent_io_tree pinned_extents;
	struct mutex cache_write_mutex;
	spinlock_t dirty_bgs_lock;
	struct list_head deleted_bgs;
	spinlock_t dropped_roots_lock;
	struct btrfs_delayed_ref_root delayed_refs;
	struct btrfs_fs_info *fs_info;
	atomic_t pending_ordered;
	wait_queue_head_t pending_wait;
};

struct btrfs_tree_block_info {
	struct btrfs_disk_key key;
	__u8 level;
};

struct btrfs_trim_range {
	u64 start;
	u64 bytes;
	struct list_head list;
};

struct btrfs_truncate_control {
	struct btrfs_inode *inode;
	u64 new_size;
	u64 extents_found;
	u64 last_size;
	u64 sub_bytes;
	u64 ino;
	u32 min_type;
	bool skip_ref_updates;
	bool clear_extent_range;
};

struct btrfs_uring_encoded_data {
	struct btrfs_ioctl_encoded_io_args args;
	struct iovec iovstack[8];
	struct iovec *iov;
	struct iov_iter iter;
};

struct io_uring_cmd;

struct btrfs_uring_priv {
	struct io_uring_cmd *cmd;
	struct page **pages;
	long unsigned int nr_pages;
	struct kiocb iocb;
	struct iovec *iov;
	struct iov_iter iter;
	struct extent_state *cached_state;
	u64 count;
	u64 start;
	u64 lockend;
	int err;
	bool compressed;
};

struct btrfs_workqueue {
	struct workqueue_struct *normal_wq;
	struct btrfs_fs_info *fs_info;
	struct list_head ordered_list;
	spinlock_t list_lock;
	atomic_t pending;
	int limit_active;
	int current_active;
	int thresh;
	unsigned int count;
	spinlock_t thres_lock;
};

struct btrfs_writepage_fixup {
	struct folio *folio;
	struct btrfs_inode *inode;
	struct btrfs_work work;
};

struct btrfs_zoned_device_info {
	u64 zone_size;
	u8 zone_size_shift;
	u32 nr_zones;
	unsigned int max_active_zones;
	int reserved_active_zones;
	atomic_t active_zones_left;
	long unsigned int *seq_zones;
	long unsigned int *empty_zones;
	long unsigned int *active_zones;
	struct blk_zone *zone_cache;
	struct blk_zone sb_zones[6];
};

struct bts_phys {
	struct page *page;
	long unsigned int size;
	long unsigned int offset;
	long unsigned int displacement;
};

struct bts_buffer {
	size_t real_size;
	unsigned int nr_pages;
	unsigned int nr_bufs;
	unsigned int cur_buf;
	bool snapshot;
	local_t data_size;
	local_t head;
	long unsigned int end;
	void **data_pages;
	struct bts_phys buf[0];
};

struct perf_buffer;

struct perf_output_handle {
	struct perf_event *event;
	struct perf_buffer *rb;
	long unsigned int wakeup;
	long unsigned int size;
	u64 aux_flags;
	union {
		void *addr;
		long unsigned int head;
	};
	int page;
};

struct debug_store {
	u64 bts_buffer_base;
	u64 bts_index;
	u64 bts_absolute_maximum;
	u64 bts_interrupt_threshold;
	u64 pebs_buffer_base;
	u64 pebs_index;
	u64 pebs_absolute_maximum;
	u64 pebs_interrupt_threshold;
	u64 pebs_event_reset[48];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bts_ctx {
	struct perf_output_handle handle;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct debug_store ds_back;
	int state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bts_record {
	u64 from;
	u64 to;
	u64 flags;
};

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct bucket {
	struct hlist_nulls_head head;
	raw_spinlock_t raw_lock;
};

struct bucket_item {
	u32 count;
};

struct rhash_lock_head;

struct bucket_table {
	unsigned int size;
	unsigned int nest;
	u32 hash_rnd;
	struct list_head walkers;
	struct callback_head rcu;
	struct bucket_table *future_tbl;
	struct lockdep_map dep_map;
	long: 64;
	struct rhash_lock_head *buckets[0];
};

struct buddy_page_mask {
	u32 page_mask;
	u8 type;
	u8 num_channels;
};

struct buf_sel_arg {
	struct iovec *iovs;
	size_t out_len;
	size_t max_len;
	short unsigned int nr_iovs;
	short unsigned int mode;
};

struct buffer_aux {
	int hash_verified;
};

struct buffer_data_page {
	u64 time_stamp;
	local_t commit;
	unsigned char data[0];
};

struct buffer_data_read_page {
	unsigned int order;
	struct buffer_data_page *data;
};

typedef void bh_end_io_t(struct buffer_head *, int);

struct buffer_head {
	long unsigned int b_state;
	struct buffer_head *b_this_page;
	union {
		struct page *b_page;
		struct folio *b_folio;
	};
	sector_t b_blocknr;
	size_t b_size;
	char *b_data;
	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;
	void *b_private;
	struct list_head b_assoc_buffers;
	struct address_space *b_assoc_map;
	atomic_t b_count;
	spinlock_t b_uptodate_lock;
};

struct buffer_page {
	struct list_head list;
	local_t write;
	unsigned int read;
	local_t entries;
	long unsigned int real_end;
	unsigned int order;
	u32 id: 30;
	u32 range: 1;
	struct buffer_data_page *page;
};

struct buffer_ref {
	struct trace_buffer *buffer;
	void *page;
	int cpu;
	refcount_t refcount;
};

struct buffer_tree {
	union {
		struct rw_semaphore lock;
		rwlock_t spinlock;
	} u;
	struct rb_root root;
	long: 64;
	long: 64;
};

struct bug_entry {
	int bug_addr_disp;
	int file_disp;
	short unsigned int line;
	short unsigned int flags;
};

struct builtin_fw {
	char *name;
	void *data;
	long unsigned int size;
};

struct group_data {
	int limit[21];
	int base[20];
	int permute[258];
	int minLen;
	int maxLen;
};

struct bunzip_data {
	int writeCopies;
	int writePos;
	int writeRunCountdown;
	int writeCount;
	int writeCurrent;
	long int (*fill)(void *, long unsigned int);
	long int inbufCount;
	long int inbufPos;
	unsigned char *inbuf;
	unsigned int inbufBitCount;
	unsigned int inbufBits;
	unsigned int crc32Table[256];
	unsigned int headerCRC;
	unsigned int totalCRC;
	unsigned int writeCRC;
	unsigned int *dbuf;
	unsigned int dbufSize;
	unsigned char selectors[32768];
	struct group_data groups[6];
	int io_error;
	int byteCount[256];
	unsigned char symToByte[256];
	unsigned char mtfSymbol[256];
};

struct bus_attribute {
	struct attribute attr;
	ssize_t (*show)(const struct bus_type *, char *);
	ssize_t (*store)(const struct bus_type *, const char *, size_t);
};

struct bus_dma_region {
	phys_addr_t cpu_start;
	dma_addr_t dma_start;
	u64 size;
};

struct bus_type {
	const char *name;
	const char *dev_name;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;
	int (*match)(struct device *, const struct device_driver *);
	int (*uevent)(const struct device *, struct kobj_uevent_env *);
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	void (*remove)(struct device *);
	void (*shutdown)(struct device *);
	const struct cpumask * (*irq_get_affinity)(struct device *, unsigned int);
	int (*online)(struct device *);
	int (*offline)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	int (*num_vf)(struct device *);
	int (*dma_configure)(struct device *);
	void (*dma_cleanup)(struct device *);
	const struct dev_pm_ops *pm;
	bool need_parent_lock;
};

struct bvec_iter_all {
	struct bio_vec bv;
	int idx;
	unsigned int done;
};

struct bxt_ddi_buf_trans {
	u8 margin;
	u8 scale;
	u8 enable;
	u8 deemphasis;
};

struct bxt_dpio_phy_info {
	bool dual_channel;
	enum dpio_phy rcomp_phy;
	int reset_delay;
	u32 pwron_mask;
	struct {
		enum port port;
	} channel[2];
};

struct bxt_dpll_hw_state {
	u32 ebb0;
	u32 ebb4;
	u32 pll0;
	u32 pll1;
	u32 pll2;
	u32 pll3;
	u32 pll6;
	u32 pll8;
	u32 pll9;
	u32 pll10;
	u32 pcsdw12;
};

struct byd_data {
	struct timer_list timer;
	struct psmouse *psmouse;
	s32 abs_x;
	s32 abs_y;
	volatile long unsigned int last_touch_time;
	bool btn_left;
	bool btn_right;
	bool touch;
};

struct cache_head;

struct cache_deferred_req {
	struct hlist_node hash;
	struct list_head recent;
	struct cache_head *item;
	void *owner;
	void (*revisit)(struct cache_deferred_req *, int);
};

struct cache_detail {
	struct module *owner;
	int hash_size;
	struct hlist_head *hash_table;
	spinlock_t hash_lock;
	char *name;
	void (*cache_put)(struct kref *);
	int (*cache_upcall)(struct cache_detail *, struct cache_head *);
	void (*cache_request)(struct cache_detail *, struct cache_head *, char **, int *);
	int (*cache_parse)(struct cache_detail *, char *, int);
	int (*cache_show)(struct seq_file *, struct cache_detail *, struct cache_head *);
	void (*warn_no_listener)(struct cache_detail *, int);
	struct cache_head * (*alloc)(void);
	void (*flush)(void);
	int (*match)(struct cache_head *, struct cache_head *);
	void (*init)(struct cache_head *, struct cache_head *);
	void (*update)(struct cache_head *, struct cache_head *);
	time64_t flush_time;
	struct list_head others;
	time64_t nextcheck;
	int entries;
	struct list_head queue;
	atomic_t writers;
	time64_t last_close;
	time64_t last_warn;
	union {
		struct proc_dir_entry *procfs;
		struct dentry *pipefs;
	};
	struct net *net;
};

struct cache_head {
	struct hlist_node cache_list;
	time64_t expiry_time;
	time64_t last_refresh;
	struct kref ref;
	long unsigned int flags;
};

struct cache_map {
	u64 start;
	u64 end;
	u64 flags;
	u64 type: 8;
	u64 fixed: 1;
};

struct cache_queue {
	struct list_head list;
	int reader;
};

struct cache_reader {
	struct cache_queue q;
	int offset;
};

struct cache_req {
	struct cache_deferred_req * (*defer)(struct cache_req *);
	long unsigned int thread_wait;
};

struct cache_request {
	struct cache_queue q;
	struct cache_head *item;
	char *buf;
	int len;
	int readers;
};

struct intel_iommu;

struct cache_tag {
	struct list_head node;
	enum cache_tag_type type;
	struct intel_iommu *iommu;
	struct device *dev;
	u16 domain_id;
	ioasid_t pasid;
	unsigned int users;
};

struct cacheinfo {
	unsigned int id;
	enum cache_type type;
	unsigned int level;
	unsigned int coherency_line_size;
	unsigned int number_of_sets;
	unsigned int ways_of_associativity;
	unsigned int physical_line_partition;
	unsigned int size;
	cpumask_t shared_cpu_map;
	unsigned int attributes;
	void *fw_token;
	bool disable_sysfs;
	void *priv;
};

struct cacheline_padding {
	char x[0];
};

struct cachestat {
	__u64 nr_cache;
	__u64 nr_dirty;
	__u64 nr_writeback;
	__u64 nr_evicted;
	__u64 nr_recently_evicted;
};

struct cachestat_range {
	__u64 off;
	__u64 len;
};

struct cobalt_vars {
	u32 count;
	u32 rec_inv_sqrt;
	ktime_t drop_next;
	ktime_t blue_timer;
	u32 p_drop;
	bool dropping;
	bool ecn_marked;
};

struct cake_flow {
	struct sk_buff *head;
	struct sk_buff *tail;
	struct list_head flowchain;
	s32 deficit;
	u32 dropped;
	struct cobalt_vars cvars;
	u16 srchost;
	u16 dsthost;
	u8 set;
};

struct cake_heap_entry {
	u16 t: 3;
	u16 b: 10;
};

struct cake_host {
	u32 srchost_tag;
	u32 dsthost_tag;
	u16 srchost_bulk_flow_count;
	u16 dsthost_bulk_flow_count;
};

struct qdisc_watchdog {
	struct hrtimer timer;
	struct Qdisc *qdisc;
};

struct cake_tin_data;

struct cake_sched_data {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct cake_tin_data *tins;
	struct cake_heap_entry overflow_heap[8192];
	u16 overflow_timeout;
	u16 tin_cnt;
	u8 tin_mode;
	u8 flow_mode;
	u8 ack_filter;
	u8 atm_mode;
	u32 fwmark_mask;
	u16 fwmark_shft;
	u16 rate_shft;
	ktime_t time_next_packet;
	ktime_t failsafe_next_packet;
	u64 rate_ns;
	u64 rate_bps;
	u16 rate_flags;
	s16 rate_overhead;
	u16 rate_mpu;
	u64 interval;
	u64 target;
	u32 buffer_used;
	u32 buffer_max_used;
	u32 buffer_limit;
	u32 buffer_config_limit;
	u16 cur_tin;
	u16 cur_flow;
	struct qdisc_watchdog watchdog;
	const u8 *tin_index;
	const u8 *tin_order;
	ktime_t last_packet_time;
	ktime_t avg_window_begin;
	u64 avg_packet_interval;
	u64 avg_window_bytes;
	u64 avg_peak_bandwidth;
	ktime_t last_reconfig_time;
	u32 avg_netoff;
	u16 max_netlen;
	u16 max_adjlen;
	u16 min_netlen;
	u16 min_adjlen;
};

struct cobalt_params {
	u64 interval;
	u64 target;
	u64 mtu_time;
	u32 p_inc;
	u32 p_dec;
};

struct cake_tin_data {
	struct cake_flow flows[1024];
	u32 backlogs[1024];
	u32 tags[1024];
	u16 overflow_idx[1024];
	struct cake_host hosts[1024];
	u16 flow_quantum;
	struct cobalt_params cparams;
	u32 drop_overlimit;
	u16 bulk_flow_count;
	u16 sparse_flow_count;
	u16 decaying_flow_count;
	u16 unresponsive_flow_count;
	u32 max_skblen;
	struct list_head new_flows;
	struct list_head old_flows;
	struct list_head decaying_flows;
	ktime_t time_next_packet;
	u64 tin_rate_ns;
	u64 tin_rate_bps;
	u16 tin_rate_shft;
	u16 tin_quantum;
	s32 tin_deficit;
	u32 tin_backlog;
	u32 tin_dropped;
	u32 tin_ecn_mark;
	u32 packets;
	u64 bytes;
	u32 ack_drops;
	u64 avge_delay;
	u64 peak_delay;
	u64 base_delay;
	u32 way_directs;
	u32 way_hits;
	u32 way_misses;
	u32 way_collisions;
};

struct calipso_doi {
	u32 doi;
	u32 type;
	refcount_t refcount;
	struct list_head list;
	struct callback_head rcu;
};

struct calipso_map_cache_bkt {
	spinlock_t lock;
	u32 size;
	struct list_head list;
};

struct netlbl_lsm_cache;

struct calipso_map_cache_entry {
	u32 hash;
	unsigned char *key;
	size_t key_len;
	struct netlbl_lsm_cache *lsm_data;
	u32 activity;
	struct list_head list;
};

struct call_function_data {
	call_single_data_t *csd;
	cpumask_var_t cpumask;
	cpumask_var_t cpumask_ipi;
};

struct cb_process_state;

struct xdr_stream;

struct callback_op {
	__be32 (*process_op)(void *, void *, struct cb_process_state *);
	__be32 (*decode_args)(struct svc_rqst *, struct xdr_stream *, void *);
	__be32 (*encode_res)(struct svc_rqst *, struct xdr_stream *, const void *);
	long int res_maxsize;
};

struct callchain_cpus_entries {
	struct callback_head callback_head;
	struct perf_callchain_entry *cpu_entries[0];
};

struct callthunk_sites {
	s32 *call_start;
	s32 *call_end;
	struct alt_instr *alt_start;
	struct alt_instr *alt_end;
};

struct can_nocow_file_extent_args {
	u64 start;
	u64 end;
	bool writeback_path;
	bool free_path;
	struct btrfs_file_extent file_extent;
};

struct compact_control;

struct capture_control {
	struct compact_control *cc;
	struct page *page;
};

struct yenta_socket;

struct cardbus_type {
	int (*override)(struct yenta_socket *);
	void (*save_state)(struct yenta_socket *);
	void (*restore_state)(struct yenta_socket *);
	int (*sock_init)(struct yenta_socket *);
};

struct cb_compound_hdr_arg {
	unsigned int taglen;
	const char *tag;
	unsigned int minorversion;
	unsigned int cb_ident;
	unsigned int nops;
};

struct cb_compound_hdr_res {
	__be32 *status;
	unsigned int taglen;
	const char *tag;
	__be32 *nops;
};

struct nfs_fh {
	short unsigned int size;
	unsigned char data[128];
};

struct cb_getattrargs {
	struct nfs_fh fh;
	uint32_t bitmap[3];
};

struct cb_getattrres {
	__be32 status;
	uint32_t bitmap[3];
	uint64_t size;
	uint64_t change_attr;
	struct timespec64 atime;
	struct timespec64 ctime;
	struct timespec64 mtime;
};

struct cb_id {
	__u32 idx;
	__u32 val;
};

struct cb_kernel {
	const void *data;
	u32 size;
};

struct nfs_client;

struct nfs4_slot;

struct cb_process_state {
	struct nfs_client *clp;
	struct nfs4_slot *slot;
	struct net *net;
	u32 minorversion;
	__be32 drc_status;
	unsigned int referring_calls;
};

struct nfs4_stateid_struct {
	union {
		char data[16];
		struct {
			__be32 seqid;
			char other[12];
		};
	};
	enum {
		NFS4_INVALID_STATEID_TYPE = 0,
		NFS4_SPECIAL_STATEID_TYPE = 1,
		NFS4_OPEN_STATEID_TYPE = 2,
		NFS4_LOCK_STATEID_TYPE = 3,
		NFS4_DELEGATION_STATEID_TYPE = 4,
		NFS4_LAYOUT_STATEID_TYPE = 5,
		NFS4_PNFS_DS_STATEID_TYPE = 6,
		NFS4_REVOKED_STATEID_TYPE = 7,
	} type;
};

typedef struct nfs4_stateid_struct nfs4_stateid;

struct cb_recallargs {
	struct nfs_fh fh;
	nfs4_stateid stateid;
	uint32_t truncate;
};

struct cbcmac_desc_ctx {
	unsigned int len;
	u8 dg[0];
};

struct crypto_cipher;

struct cbcmac_tfm_ctx {
	struct crypto_cipher *child;
};

struct cbs_sched_data {
	bool offload;
	int queue;
	atomic64_t port_rate;
	s64 last;
	s64 credits;
	s32 locredit;
	s32 hicredit;
	s64 sendslope;
	s64 idleslope;
	struct qdisc_watchdog watchdog;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct Qdisc *qdisc;
	struct list_head cbs_list;
};

struct ccid_operations;

struct ccid {
	struct ccid_operations *ccid_ops;
	char ccid_priv[0];
};

struct ccid2_hc_rx_sock {
	u32 rx_num_data_pkts;
};

struct ccid2_seq;

struct ccid2_hc_tx_sock {
	u32 tx_cwnd;
	u32 tx_ssthresh;
	u32 tx_pipe;
	u32 tx_packets_acked;
	struct ccid2_seq *tx_seqbuf[128];
	int tx_seqbufc;
	struct ccid2_seq *tx_seqh;
	struct ccid2_seq *tx_seqt;
	u32 tx_srtt;
	u32 tx_mdev;
	u32 tx_mdev_max;
	u32 tx_rttvar;
	u32 tx_rto;
	u64 tx_rtt_seq: 48;
	struct timer_list tx_rtotimer;
	struct sock *sk;
	u32 tx_cwnd_used;
	u32 tx_expected_wnd;
	u32 tx_cwnd_stamp;
	u32 tx_lsndtime;
	u64 tx_rpseq;
	int tx_rpdupack;
	u32 tx_last_cong;
	u64 tx_high_ack;
	struct list_head tx_av_chunks;
};

struct ccid2_seq {
	u64 ccid2s_seq;
	u32 ccid2s_sent;
	int ccid2s_acked;
	struct ccid2_seq *ccid2s_prev;
	struct ccid2_seq *ccid2s_next;
};

struct tfrc_rx_hist_entry;

struct tfrc_rx_hist {
	struct tfrc_rx_hist_entry *ring[4];
	u8 loss_count: 2;
	u8 loss_start: 2;
};

struct tfrc_loss_interval;

struct tfrc_loss_hist {
	struct tfrc_loss_interval *ring[9];
	u8 counter;
	u32 i_mean;
};

struct ccid3_hc_rx_sock {
	u8 rx_last_counter: 4;
	enum ccid3_hc_rx_states rx_state: 8;
	u32 rx_bytes_recv;
	u32 rx_x_recv;
	u32 rx_rtt;
	ktime_t rx_tstamp_last_feedback;
	struct tfrc_rx_hist rx_hist;
	struct tfrc_loss_hist rx_li_hist;
	u16 rx_s;
};

struct tfrc_tx_hist_entry;

struct ccid3_hc_tx_sock {
	u64 tx_x;
	u64 tx_x_recv;
	u32 tx_x_calc;
	u32 tx_rtt;
	u32 tx_p;
	u32 tx_t_rto;
	u32 tx_t_ipi;
	u16 tx_s;
	enum ccid3_hc_tx_states tx_state: 8;
	u8 tx_last_win_count;
	ktime_t tx_t_last_win_count;
	struct timer_list tx_no_feedback_timer;
	struct sock *sk;
	ktime_t tx_t_ld;
	ktime_t tx_t_nom;
	struct tfrc_tx_hist_entry *tx_hist;
};

struct ccid_dependency {
	u8 dependent_feat;
	bool is_local: 1;
	bool is_mandatory: 1;
	u8 val;
};

struct tcp_info;

struct ccid_operations {
	unsigned char ccid_id;
	__u32 ccid_ccmps;
	const char *ccid_name;
	struct kmem_cache *ccid_hc_rx_slab;
	struct kmem_cache *ccid_hc_tx_slab;
	char ccid_hc_rx_slab_name[32];
	char ccid_hc_tx_slab_name[32];
	__u32 ccid_hc_rx_obj_size;
	__u32 ccid_hc_tx_obj_size;
	int (*ccid_hc_rx_init)(struct ccid *, struct sock *);
	int (*ccid_hc_tx_init)(struct ccid *, struct sock *);
	void (*ccid_hc_rx_exit)(struct sock *);
	void (*ccid_hc_tx_exit)(struct sock *);
	void (*ccid_hc_rx_packet_recv)(struct sock *, struct sk_buff *);
	int (*ccid_hc_rx_parse_options)(struct sock *, u8, u8, u8 *, u8);
	int (*ccid_hc_rx_insert_options)(struct sock *, struct sk_buff *);
	void (*ccid_hc_tx_packet_recv)(struct sock *, struct sk_buff *);
	int (*ccid_hc_tx_parse_options)(struct sock *, u8, u8, u8 *, u8);
	int (*ccid_hc_tx_send_packet)(struct sock *, struct sk_buff *);
	void (*ccid_hc_tx_packet_sent)(struct sock *, unsigned int);
	void (*ccid_hc_rx_get_info)(struct sock *, struct tcp_info *);
	void (*ccid_hc_tx_get_info)(struct sock *, struct tcp_info *);
	int (*ccid_hc_rx_getsockopt)(struct sock *, const int, int, u32 *, int *);
	int (*ccid_hc_tx_getsockopt)(struct sock *, const int, int, u32 *, int *);
};

struct ccm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn mac;
};

struct cdg_minmax {
	union {
		struct {
			s32 min;
			s32 max;
		};
		u64 v64;
	};
};

struct cdg {
	struct cdg_minmax rtt;
	struct cdg_minmax rtt_prev;
	struct cdg_minmax *gradients;
	struct cdg_minmax gsum;
	bool gfilled;
	u8 tail;
	u8 state;
	u8 delack;
	u32 rtt_seq;
	u32 shadow_wnd;
	u16 backoff_cnt;
	u16 sample_cnt;
	s32 delay_min;
	u32 last_ack;
	u32 round_start;
};

struct cdrom_msf0 {
	__u8 minute;
	__u8 second;
	__u8 frame;
};

union cdrom_addr {
	struct cdrom_msf0 msf;
	int lba;
};

struct cdrom_device_ops;

struct cdrom_device_info {
	const struct cdrom_device_ops *ops;
	struct list_head list;
	struct gendisk *disk;
	void *handle;
	int mask;
	int speed;
	int capacity;
	unsigned int options: 30;
	unsigned int mc_flags: 2;
	unsigned int vfs_events;
	unsigned int ioctl_events;
	int use_count;
	char name[20];
	__u8 sanyo_slot: 2;
	__u8 keeplocked: 1;
	__u8 reserved: 5;
	int cdda_method;
	__u8 last_sense;
	__u8 media_written;
	short unsigned int mmc3_profile;
	int (*exit)(struct cdrom_device_info *);
	int mrw_mode_page;
	bool opened_for_data;
	__s64 last_media_change_ms;
};

struct cdrom_multisession;

struct cdrom_mcn;

struct packet_command;

struct cdrom_device_ops {
	int (*open)(struct cdrom_device_info *, int);
	void (*release)(struct cdrom_device_info *);
	int (*drive_status)(struct cdrom_device_info *, int);
	unsigned int (*check_events)(struct cdrom_device_info *, unsigned int, int);
	int (*tray_move)(struct cdrom_device_info *, int);
	int (*lock_door)(struct cdrom_device_info *, int);
	int (*select_speed)(struct cdrom_device_info *, long unsigned int);
	int (*get_last_session)(struct cdrom_device_info *, struct cdrom_multisession *);
	int (*get_mcn)(struct cdrom_device_info *, struct cdrom_mcn *);
	int (*reset)(struct cdrom_device_info *);
	int (*audio_ioctl)(struct cdrom_device_info *, unsigned int, void *);
	int (*generic_packet)(struct cdrom_device_info *, struct packet_command *);
	int (*read_cdda_bpc)(struct cdrom_device_info *, void *, u32, u32, u8 *);
	const int capability;
};

struct request_sense;

struct cdrom_generic_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct request_sense *sense;
	unsigned char data_direction;
	int quiet;
	int timeout;
	union {
		void *reserved[1];
		void *unused;
	};
};

struct cdrom_mcn {
	__u8 medium_catalog_number[14];
};

struct cdrom_multisession {
	union cdrom_addr addr;
	__u8 xa_flag;
	__u8 addr_format;
};

struct cdrom_tocentry {
	__u8 cdte_track;
	__u8 cdte_adr: 4;
	__u8 cdte_ctrl: 4;
	__u8 cdte_format;
	union cdrom_addr cdte_addr;
	__u8 cdte_datamode;
};

struct clock_event_device;

struct ce_unbind {
	struct clock_event_device *ce;
	int res;
};

struct cea_db {
	u8 tag_length;
	u8 data[0];
};

struct drm_edid;

struct drm_edid_iter {
	const struct drm_edid *drm_edid;
	int index;
};

struct displayid_iter {
	const struct drm_edid *drm_edid;
	const u8 *section;
	int length;
	int idx;
	int ext_index;
	u8 version;
	u8 primary_use;
};

struct cea_db_iter {
	struct drm_edid_iter edid_iter;
	struct displayid_iter displayid_iter;
	const u8 *collection;
	int index;
	int end;
};

struct cea_exception_stacks {
	char DF_stack_guard[4096];
	char DF_stack[8192];
	char NMI_stack_guard[4096];
	char NMI_stack[8192];
	char DB_stack_guard[4096];
	char DB_stack[8192];
	char MCE_stack_guard[4096];
	char MCE_stack[8192];
	char VC_stack_guard[4096];
	char VC_stack[8192];
	char VC2_stack_guard[4096];
	char VC2_stack[8192];
	char IST_top_guard[4096];
};

struct cea_sad {
	u8 format;
	u8 channels;
	u8 freq;
	u8 byte2;
};

struct cec_adapter;

struct cec_msg;

struct cec_adap_ops {
	int (*adap_enable)(struct cec_adapter *, bool);
	int (*adap_monitor_all_enable)(struct cec_adapter *, bool);
	int (*adap_monitor_pin_enable)(struct cec_adapter *, bool);
	int (*adap_log_addr)(struct cec_adapter *, u8);
	void (*adap_unconfigured)(struct cec_adapter *);
	int (*adap_transmit)(struct cec_adapter *, u8, u32, struct cec_msg *);
	void (*adap_nb_transmit_canceled)(struct cec_adapter *, const struct cec_msg *);
	void (*adap_status)(struct cec_adapter *, struct seq_file *);
	void (*adap_free)(struct cec_adapter *);
	int (*error_inj_show)(struct cec_adapter *, struct seq_file *);
	bool (*error_inj_parse_line)(struct cec_adapter *, char *);
	void (*configured)(struct cec_adapter *);
	int (*received)(struct cec_adapter *, struct cec_msg *);
};

struct cec_devnode {
	struct device dev;
	struct cdev cdev;
	int minor;
	struct mutex lock;
	bool registered;
	bool unregistered;
	struct mutex lock_fhs;
	struct list_head fhs;
};

struct cec_log_addrs {
	__u8 log_addr[4];
	__u16 log_addr_mask;
	__u8 cec_version;
	__u8 num_log_addrs;
	__u32 vendor_id;
	__u32 flags;
	char osd_name[15];
	__u8 primary_device_type[4];
	__u8 log_addr_type[4];
	__u8 all_device_types[4];
	__u8 features[48];
};

struct cec_drm_connector_info {
	__u32 card_no;
	__u32 connector_id;
};

struct cec_connector_info {
	__u32 type;
	union {
		struct cec_drm_connector_info drm;
		__u32 raw[16];
	};
};

struct rc_dev;

struct cec_data;

struct cec_fh;

struct cec_adapter {
	struct module *owner;
	char name[32];
	struct cec_devnode devnode;
	struct mutex lock;
	struct rc_dev *rc;
	struct list_head transmit_queue;
	unsigned int transmit_queue_sz;
	struct list_head wait_queue;
	struct cec_data *transmitting;
	bool transmit_in_progress;
	bool transmit_in_progress_aborted;
	unsigned int xfer_timeout_ms;
	struct task_struct *kthread_config;
	struct completion config_completion;
	struct task_struct *kthread;
	wait_queue_head_t kthread_waitq;
	const struct cec_adap_ops *ops;
	void *priv;
	u32 capabilities;
	u8 available_log_addrs;
	u16 phys_addr;
	bool needs_hpd;
	bool is_enabled;
	bool is_claiming_log_addrs;
	bool is_configuring;
	bool must_reconfigure;
	bool is_configured;
	bool cec_pin_is_high;
	bool adap_controls_phys_addr;
	u8 last_initiator;
	u32 monitor_all_cnt;
	u32 monitor_pin_cnt;
	u32 follower_cnt;
	struct cec_fh *cec_follower;
	struct cec_fh *cec_initiator;
	bool passthrough;
	struct cec_log_addrs log_addrs;
	struct cec_connector_info conn_info;
	u32 tx_timeout_cnt;
	u32 tx_low_drive_cnt;
	u32 tx_error_cnt;
	u32 tx_arb_lost_cnt;
	u32 tx_low_drive_log_cnt;
	u32 tx_error_log_cnt;
	struct dentry *cec_dir;
	u32 sequence;
	char input_phys[40];
};

struct cec_msg {
	__u64 tx_ts;
	__u64 rx_ts;
	__u32 len;
	__u32 timeout;
	__u32 sequence;
	__u32 flags;
	__u8 msg[16];
	__u8 reply;
	__u8 rx_status;
	__u8 tx_status;
	__u8 tx_arb_lost_cnt;
	__u8 tx_nack_cnt;
	__u8 tx_low_drive_cnt;
	__u8 tx_error_cnt;
};

struct cec_data {
	struct list_head list;
	struct list_head xfer_list;
	struct cec_adapter *adap;
	struct cec_msg msg;
	u8 match_len;
	u8 match_reply[5];
	struct cec_fh *fh;
	struct delayed_work work;
	struct completion c;
	u8 attempts;
	bool blocking;
	bool completed;
};

struct cec_event_state_change {
	__u16 phys_addr;
	__u16 log_addr_mask;
	__u16 have_conn_info;
};

struct cec_event_lost_msgs {
	__u32 lost_msgs;
};

struct cec_event {
	__u64 ts;
	__u32 event;
	__u32 flags;
	union {
		struct cec_event_state_change state_change;
		struct cec_event_lost_msgs lost_msgs;
		__u32 raw[16];
	};
};

struct cec_event_entry {
	struct list_head list;
	struct cec_event ev;
};

struct cec_fh {
	struct list_head list;
	struct list_head xfer_list;
	struct cec_adapter *adap;
	u8 mode_initiator;
	u8 mode_follower;
	wait_queue_head_t wait;
	struct mutex lock;
	struct list_head events[8];
	u16 queued_events[8];
	unsigned int total_queued_events;
	struct cec_event_entry core_events[2];
	struct list_head msgs;
	unsigned int queued_msgs;
};

struct cee_pfc {
	__u8 willing;
	__u8 error;
	__u8 pfc_en;
	__u8 tcs_supported;
};

struct cee_pg {
	__u8 willing;
	__u8 error;
	__u8 pg_en;
	__u8 tcs_supported;
	__u8 pg_bw[8];
	__u8 prio_pg[8];
};

struct cet_user_state {
	u64 user_cet;
	u64 user_ssp;
};

struct cfg80211_txq_stats {
	u32 filled;
	u32 backlog_bytes;
	u32 backlog_packets;
	u32 flows;
	u32 drops;
	u32 ecn_marks;
	u32 overlimit;
	u32 overmemory;
	u32 collisions;
	u32 tx_bytes;
	u32 tx_packets;
	u32 max_flows;
};

struct cfg80211_tid_stats {
	u32 filled;
	u64 rx_msdu;
	u64 tx_msdu;
	u64 tx_msdu_retries;
	u64 tx_msdu_failed;
	struct cfg80211_txq_stats txq_stats;
};

struct cfs_bandwidth {
	raw_spinlock_t lock;
	ktime_t period;
	u64 quota;
	u64 runtime;
	u64 burst;
	u64 runtime_snap;
	s64 hierarchical_quota;
	u8 idle;
	u8 period_active;
	u8 slack_started;
	struct hrtimer period_timer;
	struct hrtimer slack_timer;
	struct list_head throttled_cfs_rq;
	int nr_periods;
	int nr_throttled;
	int nr_burst;
	u64 throttled_time;
	u64 burst_time;
};

struct load_weight {
	long unsigned int weight;
	u32 inv_weight;
};

struct sched_avg {
	u64 last_update_time;
	u64 load_sum;
	u64 runnable_sum;
	u32 util_sum;
	u32 period_contrib;
	long unsigned int load_avg;
	long unsigned int runnable_avg;
	long unsigned int util_avg;
	unsigned int util_est;
};

struct sched_entity;

struct task_group;

struct cfs_rq {
	struct load_weight load;
	unsigned int nr_queued;
	unsigned int h_nr_queued;
	unsigned int h_nr_runnable;
	unsigned int h_nr_idle;
	s64 avg_vruntime;
	u64 avg_load;
	u64 min_vruntime;
	struct rb_root_cached tasks_timeline;
	struct sched_entity *curr;
	struct sched_entity *next;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
	struct {
		raw_spinlock_t lock;
		int nr;
		long unsigned int load_avg;
		long unsigned int util_avg;
		long unsigned int runnable_avg;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	} removed;
	u64 last_update_tg_load_avg;
	long unsigned int tg_load_avg_contrib;
	long int propagate;
	long int prop_runnable_sum;
	long unsigned int h_load;
	u64 last_h_load_update;
	struct sched_entity *h_load_next;
	struct rq *rq;
	int on_list;
	struct list_head leaf_cfs_rq_list;
	struct task_group *tg;
	int idle;
	int runtime_enabled;
	s64 runtime_remaining;
	u64 throttled_pelt_idle;
	u64 throttled_clock;
	u64 throttled_clock_pelt;
	u64 throttled_clock_pelt_time;
	u64 throttled_clock_self;
	u64 throttled_clock_self_time;
	int throttled;
	int throttle_count;
	struct list_head throttled_list;
	struct list_head throttled_csd_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cfs_schedulable_data {
	struct task_group *tg;
	u64 period;
	u64 quota;
};

struct kernfs_ops;

struct kernfs_open_file;

struct cftype {
	char name[64];
	long unsigned int private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys *ss;
	struct list_head node;
	struct kernfs_ops *kf_ops;
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	struct lock_class_key lockdep_key;
};

struct cgroup_file {
	struct kernfs_node *kn;
	long unsigned int notified_at;
	struct timer_list notify_timer;
};

struct task_cputime {
	u64 stime;
	u64 utime;
	long long unsigned int sum_exec_runtime;
};

struct cgroup_base_stat {
	struct task_cputime cputime;
	u64 ntime;
};

struct prev_cputime {
	u64 utime;
	u64 stime;
	raw_spinlock_t lock;
};

struct cgroup_bpf {
	struct bpf_prog_array *effective[38];
	struct hlist_head progs[38];
	u8 flags[38];
	struct list_head storages;
	struct bpf_prog_array *inactive;
	struct percpu_ref refcnt;
	struct work_struct release_work;
};

struct cgroup_freezer_state {
	bool freeze;
	bool e_freeze;
	int nr_frozen_descendants;
	int nr_frozen_tasks;
};

struct cgroup_root;

struct cgroup_rstat_cpu;

struct psi_group;

struct cgroup {
	struct cgroup_subsys_state self;
	long unsigned int flags;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	unsigned int kill_seq;
	struct kernfs_node *kn;
	struct cgroup_file procs_file;
	struct cgroup_file events_file;
	struct cgroup_file psi_files[3];
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state *subsys[15];
	int nr_dying_subsys[15];
	struct cgroup_root *root;
	struct list_head cset_links;
	struct list_head e_csets[15];
	struct cgroup *dom_cgrp;
	struct cgroup *old_dom_cgrp;
	struct cgroup_rstat_cpu *rstat_cpu;
	struct list_head rstat_css_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad_;
	struct cgroup *rstat_flush_next;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group *psi;
	struct cgroup_bpf bpf;
	struct cgroup_freezer_state freezer;
	struct bpf_local_storage *bpf_cgrp_storage;
	struct cgroup *ancestors[0];
	long: 64;
};

struct cgroup__safe_rcu {
	struct kernfs_node *kn;
};

struct cgroup_cls_state {
	struct cgroup_subsys_state css;
	u32 classid;
};

struct css_set;

struct css_task_iter {
	struct cgroup_subsys *ss;
	unsigned int flags;
	struct list_head *cset_pos;
	struct list_head *cset_head;
	struct list_head *tcset_pos;
	struct list_head *tcset_head;
	struct list_head *task_pos;
	struct list_head *cur_tasks_head;
	struct css_set *cur_cset;
	struct css_set *cur_dcset;
	struct task_struct *cur_task;
	struct list_head iters_node;
};

struct cgroup_of_peak {
	long unsigned int value;
	struct list_head list;
};

struct cgroup_namespace;

struct cgroup_pidlist;

struct cgroup_file_ctx {
	struct cgroup_namespace *ns;
	struct {
		void *trigger;
	} psi;
	struct {
		bool started;
		struct css_task_iter iter;
	} procs;
	struct {
		struct cgroup_pidlist *pidlist;
	} procs1;
	struct cgroup_of_peak peak;
};

struct kernfs_root;

struct kernfs_fs_context {
	struct kernfs_root *root;
	void *ns_tag;
	long unsigned int magic;
	bool new_sb_created;
};

struct cgroup_fs_context {
	struct kernfs_fs_context kfc;
	struct cgroup_root *root;
	struct cgroup_namespace *ns;
	unsigned int flags;
	bool cpuset_clone_children;
	bool none;
	bool all_ss;
	u16 subsys_mask;
	char *name;
	char *release_agent;
};

struct cgroup_iter_priv {
	struct cgroup_subsys_state *start_css;
	bool visited_all;
	bool terminate;
	int order;
};

struct cgroup_lsm_atype {
	u32 attach_btf_id;
	int refcnt;
};

struct cgroup_taskset {
	struct list_head src_csets;
	struct list_head dst_csets;
	int nr_tasks;
	int ssid;
	struct list_head *csets;
	struct css_set *cur_cset;
	struct task_struct *cur_task;
};

struct cgroup_mgctx {
	struct list_head preloaded_src_csets;
	struct list_head preloaded_dst_csets;
	struct cgroup_taskset tset;
	u16 ss_mask;
};

struct proc_ns_operations;

struct ns_common {
	struct dentry *stashed;
	const struct proc_ns_operations *ops;
	unsigned int inum;
	refcount_t count;
};

struct ucounts;

struct cgroup_namespace {
	struct ns_common ns;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct css_set *root_cset;
};

struct cgroup_pidlist {
	struct {
		enum cgroup_filetype type;
		struct pid_namespace *ns;
	} key;
	pid_t *list;
	int length;
	struct list_head links;
	struct cgroup *owner;
	struct delayed_work destroy_dwork;
};

struct cgroup_root {
	struct kernfs_root *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	struct list_head root_list;
	struct callback_head rcu;
	long: 64;
	long: 64;
	struct cgroup cgrp;
	struct cgroup *cgrp_ancestor_storage;
	atomic_t nr_cgrps;
	unsigned int flags;
	char release_agent_path[4096];
	char name[64];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct cgroup_rstat_cpu {
	struct u64_stats_sync bsync;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat subtree_bstat;
	struct cgroup_base_stat last_subtree_bstat;
	struct cgroup *updated_children;
	struct cgroup *updated_next;
};

struct cgroup_subsys {
	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
	int (*css_online)(struct cgroup_subsys_state *);
	void (*css_offline)(struct cgroup_subsys_state *);
	void (*css_released)(struct cgroup_subsys_state *);
	void (*css_free)(struct cgroup_subsys_state *);
	void (*css_reset)(struct cgroup_subsys_state *);
	void (*css_killed)(struct cgroup_subsys_state *);
	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*css_local_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)(void);
	int (*can_fork)(struct task_struct *, struct css_set *);
	void (*cancel_fork)(struct task_struct *, struct css_set *);
	void (*fork)(struct task_struct *);
	void (*exit)(struct task_struct *);
	void (*release)(struct task_struct *);
	void (*bind)(struct cgroup_subsys_state *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	unsigned int depends_on;
};

struct cgroupstats {
	__u64 nr_sleeping;
	__u64 nr_running;
	__u64 nr_stopped;
	__u64 nr_uninterruptible;
	__u64 nr_io_wait;
};

struct cgrp_cset_link {
	struct cgroup *cgrp;
	struct css_set *cset;
	struct list_head cset_link;
	struct list_head cgrp_link;
};

struct ch7017_priv {
	u8 dummy;
};

struct ch7xxx_did_struct {
	u8 did;
	char *name;
};

struct ch7xxx_id_struct {
	u8 vid;
	char *name;
};

struct ch7xxx_priv {
	bool quiet;
};

struct linked_page;

struct chain_allocator {
	struct linked_page *chain;
	unsigned int used_space;
	gfp_t gfp_mask;
	int safe_needed;
};

struct e820_entry;

struct change_member {
	struct e820_entry *entry;
	long long unsigned int addr;
};

struct ethnl_reply_data {
	struct net_device *dev;
};

struct ethtool_channels {
	__u32 cmd;
	__u32 max_rx;
	__u32 max_tx;
	__u32 max_other;
	__u32 max_combined;
	__u32 rx_count;
	__u32 tx_count;
	__u32 other_count;
	__u32 combined_count;
};

struct channels_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_channels channels;
};

struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;
	unsigned int baseminor;
	int minorct;
	char name[64];
	struct cdev *cdev;
};

struct qdisc_walker {
	int stop;
	int skip;
	int count;
	int (*fn)(struct Qdisc *, long unsigned int, struct qdisc_walker *);
};

struct check_loop_arg {
	struct qdisc_walker w;
	struct Qdisc *p;
	int depth;
};

struct check_mount {
	struct vfsmount *mnt;
	unsigned int mounted;
};

struct check_owner {
	struct list_head list;
	xfs_daddr_t daddr;
	int level;
};

struct check_pkt_len_arg {
	u16 pkt_len;
	bool exec_for_greater;
	bool exec_for_lesser_equal;
};

struct child_device_config {
	u16 handle;
	u16 device_type;
	union {
		u8 device_id[10];
		struct {
			u8 i2c_speed;
			u8 dp_onboard_redriver_preemph: 3;
			u8 dp_onboard_redriver_vswing: 3;
			u8 dp_onboard_redriver_present: 1;
			u8 reserved0: 1;
			u8 dp_ondock_redriver_preemph: 3;
			u8 dp_ondock_redriver_vswing: 3;
			u8 dp_ondock_redriver_present: 1;
			u8 reserved1: 1;
			u8 hdmi_level_shifter_value: 5;
			u8 hdmi_max_data_rate: 3;
			u16 dtd_buf_ptr;
			u8 edidless_efp: 1;
			u8 compression_enable: 1;
			u8 compression_method_cps: 1;
			u8 ganged_edp: 1;
			u8 lttpr_non_transparent: 1;
			u8 disable_compression_for_ext_disp: 1;
			u8 reserved2: 2;
			u8 compression_structure_index: 4;
			u8 reserved3: 4;
			u8 hdmi_max_frl_rate: 4;
			u8 hdmi_max_frl_rate_valid: 1;
			u8 reserved4: 3;
			u8 reserved5;
		};
	};
	u16 addin_offset;
	u8 dvo_port;
	u8 i2c_pin;
	u8 target_addr;
	u8 ddc_pin;
	u16 edid_ptr;
	u8 dvo_cfg;
	union {
		struct {
			u8 dvo2_port;
			u8 i2c2_pin;
			u8 target2_addr;
			u8 ddc2_pin;
		};
		struct {
			u8 efp_routed: 1;
			u8 lane_reversal: 1;
			u8 lspcon: 1;
			u8 iboost: 1;
			u8 hpd_invert: 1;
			u8 use_vbt_vswing: 1;
			u8 dp_max_lane_count: 2;
			u8 hdmi_support: 1;
			u8 dp_support: 1;
			u8 tmds_support: 1;
			u8 support_reserved: 5;
			u8 aux_channel;
			u8 dongle_detect;
		};
	};
	u8 pipe_cap: 2;
	u8 sdvo_stall: 1;
	u8 hpd_status: 2;
	u8 integrated_encoder: 1;
	u8 capabilities_reserved: 2;
	u8 dvo_wiring;
	union {
		u8 dvo2_wiring;
		u8 mipi_bridge_type;
	};
	u16 extended_type;
	u8 dvo_function;
	u8 dp_usb_type_c: 1;
	u8 tbt: 1;
	u8 flags2_reserved: 2;
	u8 dp_port_trace_length: 4;
	u8 dp_gpio_index;
	u16 dp_gpio_pin_num;
	u8 dp_iboost_level: 4;
	u8 hdmi_iboost_level: 4;
	u8 dp_max_link_rate: 3;
	u8 dp_max_link_rate_reserved: 5;
	u8 efp_index;
} __attribute__((packed));

struct iolatency_grp;

struct child_latency_info {
	spinlock_t lock;
	u64 last_scale_event;
	u64 scale_lat;
	u64 nr_samples;
	struct iolatency_grp *scale_grp;
	atomic_t scale_cookie;
};

struct chipset {
	u32 vendor;
	u32 device;
	u32 class;
	u32 class_mask;
	u32 flags;
	void (*f)(int, int, int);
};

struct chksum_ctx {
	u32 key;
};

struct chksum_desc_ctx {
	__u16 crc;
};

struct chksum_desc_ctx___2 {
	u32 crc;
};

struct reciprocal_value {
	u32 m;
	u8 sh1;
	u8 sh2;
};

struct red_parms {
	u32 qth_min;
	u32 qth_max;
	u32 Scell_max;
	u32 max_P;
	struct reciprocal_value max_P_reciprocal;
	u32 qth_delta;
	u32 target_min;
	u32 target_max;
	u8 Scell_log;
	u8 Wlog;
	u8 Plog;
	u8 Stab[256];
};

struct red_vars {
	int qcount;
	u32 qR;
	long unsigned int qavg;
	ktime_t qidlestart;
};

struct choke_sched_data {
	u32 limit;
	unsigned char flags;
	struct red_parms parms;
	struct red_vars vars;
	struct {
		u32 prob_drop;
		u32 prob_mark;
		u32 forced_drop;
		u32 forced_mark;
		u32 pdrop;
		u32 matched;
	} stats;
	unsigned int head;
	unsigned int tail;
	unsigned int tab_mask;
	struct sk_buff **tab;
};

struct flow_keys_digest {
	u8 data[16];
};

struct choke_skb_cb {
	u8 keys_valid;
	struct flow_keys_digest keys;
};

struct cipher_context {
	char iv[20];
	char rec_seq[8];
};

struct cipso_v4_std_map_tbl;

struct cipso_v4_doi {
	u32 doi;
	u32 type;
	union {
		struct cipso_v4_std_map_tbl *std;
	} map;
	u8 tags[5];
	refcount_t refcount;
	struct list_head list;
	struct callback_head rcu;
};

struct cipso_v4_map_cache_bkt {
	spinlock_t lock;
	u32 size;
	struct list_head list;
};

struct cipso_v4_map_cache_entry {
	u32 hash;
	unsigned char *key;
	size_t key_len;
	struct netlbl_lsm_cache *lsm_data;
	u32 activity;
	struct list_head list;
};

struct cipso_v4_std_map_tbl {
	struct {
		u32 *cipso;
		u32 *local;
		u32 cipso_size;
		u32 local_size;
	} lvl;
	struct {
		u32 *cipso;
		u32 *local;
		u32 cipso_size;
		u32 local_size;
	} cat;
};

struct cis_cache_entry {
	struct list_head node;
	unsigned int addr;
	unsigned int len;
	unsigned int attr;
	unsigned char cache[0];
};

struct cistpl_device_t {
	u_char ndev;
	struct {
		u_char type;
		u_char wp;
		u_int speed;
		u_int size;
	} dev[4];
};

typedef struct cistpl_device_t cistpl_device_t;

struct cistpl_checksum_t {
	u_short addr;
	u_short len;
	u_char sum;
};

typedef struct cistpl_checksum_t cistpl_checksum_t;

struct cistpl_longlink_t {
	u_int addr;
};

typedef struct cistpl_longlink_t cistpl_longlink_t;

struct cistpl_longlink_mfc_t {
	u_char nfn;
	struct {
		u_char space;
		u_int addr;
	} fn[8];
};

typedef struct cistpl_longlink_mfc_t cistpl_longlink_mfc_t;

struct cistpl_vers_1_t {
	u_char major;
	u_char minor;
	u_char ns;
	u_char ofs[4];
	char str[254];
};

typedef struct cistpl_vers_1_t cistpl_vers_1_t;

struct cistpl_altstr_t {
	u_char ns;
	u_char ofs[4];
	char str[254];
};

typedef struct cistpl_altstr_t cistpl_altstr_t;

struct cistpl_jedec_t {
	u_char nid;
	struct {
		u_char mfr;
		u_char info;
	} id[4];
};

typedef struct cistpl_jedec_t cistpl_jedec_t;

struct cistpl_manfid_t {
	u_short manf;
	u_short card;
};

typedef struct cistpl_manfid_t cistpl_manfid_t;

struct cistpl_funcid_t {
	u_char func;
	u_char sysinit;
};

typedef struct cistpl_funcid_t cistpl_funcid_t;

struct cistpl_funce_t {
	u_char type;
	u_char data[0];
};

typedef struct cistpl_funce_t cistpl_funce_t;

struct cistpl_bar_t {
	u_char attr;
	u_int size;
};

typedef struct cistpl_bar_t cistpl_bar_t;

struct cistpl_config_t {
	u_char last_idx;
	u_int base;
	u_int rmask[4];
	u_char subtuples;
};

typedef struct cistpl_config_t cistpl_config_t;

struct cistpl_power_t {
	u_char present;
	u_char flags;
	u_int param[7];
};

typedef struct cistpl_power_t cistpl_power_t;

struct cistpl_timing_t {
	u_int wait;
	u_int waitscale;
	u_int ready;
	u_int rdyscale;
	u_int reserved;
	u_int rsvscale;
};

typedef struct cistpl_timing_t cistpl_timing_t;

struct cistpl_io_t {
	u_char flags;
	u_char nwin;
	struct {
		u_int base;
		u_int len;
	} win[16];
};

typedef struct cistpl_io_t cistpl_io_t;

struct cistpl_irq_t {
	u_int IRQInfo1;
	u_int IRQInfo2;
};

typedef struct cistpl_irq_t cistpl_irq_t;

struct cistpl_mem_t {
	u_char flags;
	u_char nwin;
	struct {
		u_int len;
		u_int card_addr;
		u_int host_addr;
	} win[8];
};

typedef struct cistpl_mem_t cistpl_mem_t;

struct cistpl_cftable_entry_t {
	u_char index;
	u_short flags;
	u_char interface;
	cistpl_power_t vcc;
	cistpl_power_t vpp1;
	cistpl_power_t vpp2;
	cistpl_timing_t timing;
	cistpl_io_t io;
	cistpl_irq_t irq;
	cistpl_mem_t mem;
	u_char subtuples;
};

typedef struct cistpl_cftable_entry_t cistpl_cftable_entry_t;

struct cistpl_cftable_entry_cb_t {
	u_char index;
	u_int flags;
	cistpl_power_t vcc;
	cistpl_power_t vpp1;
	cistpl_power_t vpp2;
	u_char io;
	cistpl_irq_t irq;
	u_char mem;
	u_char subtuples;
};

typedef struct cistpl_cftable_entry_cb_t cistpl_cftable_entry_cb_t;

struct cistpl_device_geo_t {
	u_char ngeo;
	struct {
		u_char buswidth;
		u_int erase_block;
		u_int read_block;
		u_int write_block;
		u_int partition;
		u_int interleave;
	} geo[4];
};

typedef struct cistpl_device_geo_t cistpl_device_geo_t;

struct cistpl_vers_2_t {
	u_char vers;
	u_char comply;
	u_short dindex;
	u_char vspec8;
	u_char vspec9;
	u_char nhdr;
	u_char vendor;
	u_char info;
	char str[244];
};

typedef struct cistpl_vers_2_t cistpl_vers_2_t;

struct cistpl_org_t {
	u_char data_org;
	char desc[30];
};

typedef struct cistpl_org_t cistpl_org_t;

struct cistpl_format_t {
	u_char type;
	u_char edc;
	u_int offset;
	u_int length;
};

typedef struct cistpl_format_t cistpl_format_t;

union cisparse_t {
	cistpl_device_t device;
	cistpl_checksum_t checksum;
	cistpl_longlink_t longlink;
	cistpl_longlink_mfc_t longlink_mfc;
	cistpl_vers_1_t version_1;
	cistpl_altstr_t altstr;
	cistpl_jedec_t jedec;
	cistpl_manfid_t manfid;
	cistpl_funcid_t funcid;
	cistpl_funce_t funce;
	cistpl_bar_t bar;
	cistpl_config_t config;
	cistpl_cftable_entry_t cftable_entry;
	cistpl_cftable_entry_cb_t cftable_entry_cb;
	cistpl_device_geo_t device_geo;
	cistpl_vers_2_t vers_2;
	cistpl_org_t org;
	cistpl_format_t format;
};

typedef union cisparse_t cisparse_t;

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(const struct class *, const struct class_attribute *, char *);
	ssize_t (*store)(const struct class *, const struct class_attribute *, const char *, size_t);
};

struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

struct class_compat {
	struct kobject *kobj;
};

struct klist_iter {
	struct klist *i_klist;
	struct klist_node *i_cur;
};

struct subsys_private;

struct class_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
	struct subsys_private *sp;
};

struct class_dir {
	struct kobject kobj;
	const struct class *class;
};

struct class_interface {
	struct list_head node;
	const struct class *class;
	int (*add_dev)(struct device *);
	void (*remove_dev)(struct device *);
};

struct clear_refs_private {
	enum clear_refs_types type;
};

struct dma_fence_ops;

struct dma_fence {
	spinlock_t *lock;
	const struct dma_fence_ops *ops;
	union {
		struct list_head cb_list;
		ktime_t timestamp;
		struct callback_head rcu;
	};
	u64 context;
	u64 seqno;
	long unsigned int flags;
	struct kref refcount;
	int error;
};

struct i915_sw_fence;

typedef int (*i915_sw_fence_notify_t)(struct i915_sw_fence *, enum i915_sw_fence_notify);

struct i915_sw_fence {
	wait_queue_head_t wait;
	i915_sw_fence_notify_t fn;
	atomic_t pending;
	int error;
};

struct i915_sw_dma_fence_cb {
	struct dma_fence_cb base;
	struct i915_sw_fence *fence;
};

struct dma_fence_work_ops;

struct dma_fence_work {
	struct dma_fence dma;
	spinlock_t lock;
	struct i915_sw_fence chain;
	struct i915_sw_dma_fence_cb cb;
	struct work_struct work;
	const struct dma_fence_work_ops *ops;
};

struct drm_i915_gem_object;

struct clflush {
	struct dma_fence_work base;
	struct drm_i915_gem_object *obj;
};

struct clgstate {
	u8 state;
	u32 a1;
	u32 a2;
	u32 a3;
	u32 a4;
	u32 a5;
};

struct clip_priv {
	int number;
	spinlock_t xoff_lock;
	struct net_device *next;
};

struct neigh_table;

struct neigh_hash_table;

struct neigh_seq_state {
	struct seq_net_private p;
	struct neigh_table *tbl;
	struct neigh_hash_table *nht;
	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
	unsigned int bucket;
	unsigned int flags;
};

struct clip_seq_state {
	struct neigh_seq_state ns;
	struct clip_vcc *vcc;
};

struct clip_vcc {
	struct atm_vcc *vcc;
	struct atmarp_entry *entry;
	int xoff;
	unsigned char encap;
	long unsigned int last_use;
	long unsigned int idle_timeout;
	void (*old_push)(struct atm_vcc *, struct sk_buff *);
	void (*old_pop)(struct atm_vcc *, struct sk_buff *);
	struct clip_vcc *next;
};

struct clock_event_device {
	void (*event_handler)(struct clock_event_device *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
	ktime_t next_event;
	u64 max_delta_ns;
	u64 min_delta_ns;
	u32 mult;
	u32 shift;
	enum clock_event_state state_use_accessors;
	unsigned int features;
	long unsigned int retries;
	int (*set_state_periodic)(struct clock_event_device *);
	int (*set_state_oneshot)(struct clock_event_device *);
	int (*set_state_oneshot_stopped)(struct clock_event_device *);
	int (*set_state_shutdown)(struct clock_event_device *);
	int (*tick_resume)(struct clock_event_device *);
	void (*broadcast)(const struct cpumask *);
	void (*suspend)(struct clock_event_device *);
	void (*resume)(struct clock_event_device *);
	long unsigned int min_delta_ticks;
	long unsigned int max_delta_ticks;
	const char *name;
	int rating;
	int irq;
	int bound_on;
	const struct cpumask *cpumask;
	struct list_head list;
	struct module *owner;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct clock_identity {
	u8 id[8];
};

struct clocksource_base;

struct clocksource {
	u64 (*read)(struct clocksource *);
	u64 mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
	u32 uncertainty_margin;
	u64 max_cycles;
	u64 max_raw_delta;
	const char *name;
	struct list_head list;
	u32 freq_khz;
	int rating;
	enum clocksource_ids id;
	enum vdso_clock_mode vdso_clock_mode;
	long unsigned int flags;
	struct clocksource_base *base;
	int (*enable)(struct clocksource *);
	void (*disable)(struct clocksource *);
	void (*suspend)(struct clocksource *);
	void (*resume)(struct clocksource *);
	void (*mark_unstable)(struct clocksource *);
	void (*tick_stable)(struct clocksource *);
	struct list_head wd_list;
	u64 cs_last;
	u64 wd_last;
	struct module *owner;
};

struct clocksource_base {
	enum clocksource_ids id;
	u32 freq_khz;
	u64 offset;
	u32 numerator;
	u32 denominator;
};

struct clone_args {
	__u64 flags;
	__u64 pidfd;
	__u64 child_tid;
	__u64 parent_tid;
	__u64 exit_signal;
	__u64 stack;
	__u64 stack_size;
	__u64 tls;
	__u64 set_tid;
	__u64 set_tid_size;
	__u64 cgroup;
};

struct dm_table;

struct dm_io;

struct clone_info {
	struct dm_table *map;
	struct bio *bio;
	struct dm_io *io;
	sector_t sector;
	unsigned int sector_count;
	bool is_abnormal_io: 1;
	bool submit_as_polled: 1;
};

struct clone_root {
	struct btrfs_root *root;
	u64 ino;
	u64 offset;
	u64 num_bytes;
	bool found_ref;
};

struct cls_bpf_head {
	struct list_head plist;
	struct idr handle_idr;
	struct callback_head rcu;
};

struct cls_bpf_prog {
	struct bpf_prog *filter;
	struct list_head link;
	struct tcf_result res;
	bool exts_integrated;
	u32 gen_flags;
	unsigned int in_hw_count;
	struct tcf_exts exts;
	u32 handle;
	u16 bpf_num_ops;
	struct sock_filter *bpf_ops;
	const char *bpf_name;
	struct tcf_proto *tp;
	struct rcu_work rwork;
};

struct cls_cgroup_head {
	u32 handle;
	struct tcf_exts exts;
	struct tcf_ematch_tree ematches;
	struct tcf_proto *tp;
	struct rcu_work rwork;
};

struct flow_dissector_key_meta {
	int ingress_ifindex;
	u16 ingress_iftype;
	u8 l2_miss;
};

struct flow_dissector_key_control {
	u16 thoff;
	u16 addr_type;
	u32 flags;
};

struct flow_dissector_key_basic {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
};

struct flow_dissector_key_eth_addrs {
	unsigned char dst[6];
	unsigned char src[6];
};

struct flow_dissector_key_vlan {
	union {
		struct {
			u16 vlan_id: 12;
			u16 vlan_dei: 1;
			u16 vlan_priority: 3;
		};
		__be16 vlan_tci;
	};
	__be16 vlan_tpid;
	__be16 vlan_eth_type;
	u16 padding;
};

struct flow_dissector_key_ipv4_addrs {
	__be32 src;
	__be32 dst;
};

struct flow_dissector_key_ipv6_addrs {
	struct in6_addr src;
	struct in6_addr dst;
};

struct flow_dissector_key_ports {
	union {
		__be32 ports;
		struct {
			__be16 src;
			__be16 dst;
		};
	};
};

struct flow_dissector_key_icmp {
	struct {
		u8 type;
		u8 code;
	};
	u16 id;
};

struct flow_dissector_key_arp {
	__u32 sip;
	__u32 tip;
	__u8 op;
	unsigned char sha[6];
	unsigned char tha[6];
};

struct flow_dissector_key_keyid {
	__be32 keyid;
};

struct flow_dissector_mpls_lse {
	u32 mpls_ttl: 8;
	u32 mpls_bos: 1;
	u32 mpls_tc: 3;
	u32 mpls_label: 20;
};

struct flow_dissector_key_mpls {
	struct flow_dissector_mpls_lse ls[7];
	u8 used_lses;
};

struct flow_dissector_key_tcp {
	__be16 flags;
};

struct flow_dissector_key_ip {
	__u8 tos;
	__u8 ttl;
};

struct flow_dissector_key_enc_opts {
	u8 data[255];
	u8 len;
	u32 dst_opt_type;
};

struct flow_dissector_key_ports_range {
	union {
		struct flow_dissector_key_ports tp;
		struct {
			struct flow_dissector_key_ports tp_min;
			struct flow_dissector_key_ports tp_max;
		};
	};
};

struct flow_dissector_key_ct {
	u16 ct_state;
	u16 ct_zone;
	u32 ct_mark;
	u32 ct_labels[4];
};

struct flow_dissector_key_hash {
	u32 hash;
};

struct flow_dissector_key_num_of_vlans {
	u8 num_of_vlans;
};

struct flow_dissector_key_pppoe {
	__be16 session_id;
	__be16 ppp_proto;
	__be16 type;
};

struct flow_dissector_key_l2tpv3 {
	__be32 session_id;
};

struct flow_dissector_key_ipsec {
	__be32 spi;
};

struct flow_dissector_key_cfm {
	u8 mdl_ver;
	u8 opcode;
};

struct fl_flow_key {
	struct flow_dissector_key_meta meta;
	struct flow_dissector_key_control control;
	struct flow_dissector_key_control enc_control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_eth_addrs eth;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_arp arp;
	struct flow_dissector_key_keyid enc_key_id;
	union {
		struct flow_dissector_key_ipv4_addrs enc_ipv4;
		struct flow_dissector_key_ipv6_addrs enc_ipv6;
	};
	struct flow_dissector_key_ports enc_tp;
	struct flow_dissector_key_mpls mpls;
	struct flow_dissector_key_tcp tcp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_ip enc_ip;
	struct flow_dissector_key_enc_opts enc_opts;
	struct flow_dissector_key_ports_range tp_range;
	struct flow_dissector_key_ct ct;
	struct flow_dissector_key_hash hash;
	struct flow_dissector_key_num_of_vlans num_of_vlans;
	struct flow_dissector_key_pppoe pppoe;
	struct flow_dissector_key_l2tpv3 l2tpv3;
	struct flow_dissector_key_ipsec ipsec;
	struct flow_dissector_key_cfm cfm;
	long: 0;
};

struct fl_flow_mask;

struct cls_fl_filter {
	struct fl_flow_mask *mask;
	struct rhash_head ht_node;
	struct fl_flow_key mkey;
	struct tcf_exts exts;
	struct tcf_result res;
	struct fl_flow_key key;
	struct list_head list;
	struct list_head hw_list;
	u32 handle;
	u32 flags;
	u32 in_hw_count;
	u8 needs_tc_skb_ext: 1;
	struct rcu_work rwork;
	struct net_device *hw_dev;
	refcount_t refcnt;
	bool deleted;
};

typedef u32 (*rht_hashfn_t)(const void *, u32, u32);

typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);

struct rhashtable_compare_arg;

typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);

struct rhashtable_params {
	u16 nelem_hint;
	u16 key_len;
	u16 key_offset;
	u16 head_offset;
	unsigned int max_size;
	u16 min_size;
	bool automatic_shrinking;
	rht_hashfn_t hashfn;
	rht_obj_hashfn_t obj_hashfn;
	rht_obj_cmpfn_t obj_cmpfn;
};

struct rhashtable {
	struct bucket_table *tbl;
	unsigned int key_len;
	unsigned int max_elems;
	struct rhashtable_params p;
	bool rhlist;
	struct work_struct run_work;
	struct mutex mutex;
	spinlock_t lock;
	atomic_t nelems;
};

struct cls_fl_head {
	struct rhashtable ht;
	spinlock_t masks_lock;
	struct list_head masks;
	struct list_head hw_filters;
	struct rcu_work rwork;
	struct idr handle_idr;
};

struct tc_matchall_pcnt;

struct cls_mall_head {
	struct tcf_exts exts;
	struct tcf_result res;
	u32 handle;
	u32 flags;
	unsigned int in_hw_count;
	struct tc_matchall_pcnt *pf;
	struct rcu_work rwork;
	bool deleting;
};

typedef void tcf_chain_head_change_t(struct tcf_proto *, void *);

struct tcf_block_ext_info {
	enum flow_block_binder_type binder_type;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
	u32 block_index;
};

struct mini_Qdisc {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct gnet_stats_basic_sync *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	long unsigned int rcu_state;
};

struct mini_Qdisc_pair {
	struct mini_Qdisc miniq1;
	struct mini_Qdisc miniq2;
	struct mini_Qdisc **p_miniq;
};

struct clsact_sched_data {
	struct tcf_block *ingress_block;
	struct tcf_block *egress_block;
	struct tcf_block_ext_info ingress_block_info;
	struct tcf_block_ext_info egress_block_info;
	struct mini_Qdisc_pair miniqp_ingress;
	struct mini_Qdisc_pair miniqp_egress;
};

struct cmac_desc_ctx {
	unsigned int len;
	u8 odds[0];
};

struct cmac_tfm_ctx {
	struct crypto_cipher *child;
	__be64 consts[0];
};

struct drm_i915_cmd_descriptor;

struct cmd_node {
	const struct drm_i915_cmd_descriptor *desc;
	struct hlist_node node;
};

struct cmis_cdb_advert_rpl {
	u8 inst_supported;
	u8 read_write_len_ext;
	u8 resv1;
	u8 resv2;
};

struct cmis_cdb_fw_mng_features_rpl {
	u8 resv1;
	u8 resv2;
	u8 start_cmd_payload_size;
	u8 resv3;
	u8 read_write_len_ext;
	u8 write_mechanism;
	u8 resv4;
	u8 resv5;
	__be16 max_duration_start;
	__be16 resv6;
	__be16 max_duration_write;
	__be16 max_duration_complete;
	__be16 resv7;
};

struct cmis_cdb_module_features_rpl {
	u8 resv1[34];
	__be16 max_completion_time;
};

struct cmis_cdb_query_status_pl {
	u16 response_delay;
};

struct cmis_cdb_query_status_rpl {
	u8 length;
	u8 status;
};

struct cmis_cdb_run_fw_image_pl {
	u8 resv1;
	u8 image_to_run;
	u16 delay_to_reset;
};

struct cmis_cdb_start_fw_download_pl_h {
	__be32 image_size;
	__be32 resv1;
};

struct cmis_cdb_start_fw_download_pl {
	union {
		struct {
			__be32 image_size;
			__be32 resv1;
		};
		struct cmis_cdb_start_fw_download_pl_h head;
	};
	u8 vendor_data[112];
};

struct cmis_cdb_write_fw_block_epl_pl {
	u8 fw_block[2048];
};

struct cmis_cdb_write_fw_block_lpl_pl {
	__be32 block_address;
	u8 fw_block[116];
};

struct cmis_fw_update_fw_mng_features {
	u8 start_cmd_payload_size;
	u8 write_mechanism;
	u16 max_duration_start;
	u16 max_duration_write;
	u16 max_duration_complete;
};

struct cmis_password_entry_pl {
	__be32 password;
};

struct cmis_rev_rpl {
	u8 rev;
};

struct cmis_wait_for_cond_rpl {
	u8 state;
};

struct cmos_rtc;

struct rtc_time;

struct cmos_read_alarm_callback_param {
	struct cmos_rtc *cmos;
	struct rtc_time *time;
	unsigned char rtc_control;
};

struct rtc_time {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};

struct rtc_wkalrm {
	unsigned char enabled;
	unsigned char pending;
	struct rtc_time time;
};

struct rtc_device;

struct cmos_rtc {
	struct rtc_device *rtc;
	struct device *dev;
	int irq;
	struct resource *iomem;
	time64_t alarm_expires;
	void (*wake_on)(struct device *);
	void (*wake_off)(struct device *);
	u8 enabled_wake;
	u8 suspend_ctrl;
	u8 day_alrm;
	u8 mon_alrm;
	u8 century;
	struct rtc_wkalrm saved_wkalrm;
};

struct cmos_rtc_board_info {
	void (*wake_on)(struct device *);
	void (*wake_off)(struct device *);
	u32 flags;
	int address_space;
	u8 rtc_day_alarm;
	u8 rtc_mon_alarm;
	u8 rtc_century;
};

struct cmos_set_alarm_callback_param {
	struct cmos_rtc *cmos;
	unsigned char mon;
	unsigned char mday;
	unsigned char hrs;
	unsigned char min;
	unsigned char sec;
	struct rtc_wkalrm *t;
};

struct crypto_comp;

struct cmp_data {
	struct task_struct *thr;
	struct crypto_comp *cc;
	atomic_t ready;
	atomic_t stop;
	int ret;
	wait_queue_head_t go;
	wait_queue_head_t done;
	size_t unc_len;
	size_t cmp_len;
	unsigned char unc[131072];
	unsigned char cmp[143360];
};

struct cmsghdr {
	__kernel_size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

struct cn_callback_id {
	unsigned char name[32];
	struct cb_id id;
};

struct cn_queue_dev;

struct cn_msg;

struct netlink_skb_parms;

struct cn_callback_entry {
	struct list_head callback_entry;
	refcount_t refcnt;
	struct cn_queue_dev *pdev;
	struct cn_callback_id id;
	void (*callback)(struct cn_msg *, struct netlink_skb_parms *);
	u32 seq;
	u32 group;
};

struct cn_dev {
	struct cb_id id;
	u32 seq;
	u32 groups;
	struct sock *nls;
	struct cn_queue_dev *cbdev;
};

struct cn_msg {
	struct cb_id id;
	__u32 seq;
	__u32 ack;
	__u16 len;
	__u16 flags;
	__u8 data[0];
};

struct cn_queue_dev {
	atomic_t refcnt;
	unsigned char name[32];
	struct list_head queue_list;
	spinlock_t queue_lock;
	struct sock *nls;
};

struct ethtool_coalesce {
	__u32 cmd;
	__u32 rx_coalesce_usecs;
	__u32 rx_max_coalesced_frames;
	__u32 rx_coalesce_usecs_irq;
	__u32 rx_max_coalesced_frames_irq;
	__u32 tx_coalesce_usecs;
	__u32 tx_max_coalesced_frames;
	__u32 tx_coalesce_usecs_irq;
	__u32 tx_max_coalesced_frames_irq;
	__u32 stats_block_coalesce_usecs;
	__u32 use_adaptive_rx_coalesce;
	__u32 use_adaptive_tx_coalesce;
	__u32 pkt_rate_low;
	__u32 rx_coalesce_usecs_low;
	__u32 rx_max_coalesced_frames_low;
	__u32 tx_coalesce_usecs_low;
	__u32 tx_max_coalesced_frames_low;
	__u32 pkt_rate_high;
	__u32 rx_coalesce_usecs_high;
	__u32 rx_max_coalesced_frames_high;
	__u32 tx_coalesce_usecs_high;
	__u32 tx_max_coalesced_frames_high;
	__u32 rate_sample_interval;
};

struct kernel_ethtool_coalesce {
	u8 use_cqe_mode_tx;
	u8 use_cqe_mode_rx;
	u32 tx_aggr_max_bytes;
	u32 tx_aggr_max_frames;
	u32 tx_aggr_time_usecs;
};

struct coalesce_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_coalesce coalesce;
	struct kernel_ethtool_coalesce kernel_coalesce;
	u32 supported_params;
};

struct cobalt_skb_cb {
	ktime_t enqueue_time;
	u32 adjusted_len;
};

struct codel_params {
	codel_time_t target;
	codel_time_t ce_threshold;
	codel_time_t interval;
	u32 mtu;
	bool ecn;
	u8 ce_threshold_selector;
	u8 ce_threshold_mask;
};

struct codel_vars {
	u32 count;
	u32 lastcount;
	bool dropping;
	u16 rec_inv_sqrt;
	codel_time_t first_above_time;
	codel_time_t drop_next;
	codel_time_t ldelay;
};

struct codel_stats {
	u32 maxpacket;
	u32 drop_count;
	u32 drop_len;
	u32 ecn_mark;
	u32 ce_mark;
};

struct codel_sched_data {
	struct codel_params params;
	struct codel_vars vars;
	struct codel_stats stats;
	u32 drop_overlimit;
};

struct codel_skb_cb {
	codel_time_t enqueue_time;
	unsigned int mem_usage;
};

struct color_conversion {
	u16 ry;
	u16 gy;
	u16 by;
	u16 ay;
	u16 ru;
	u16 gu;
	u16 bu;
	u16 au;
	u16 rv;
	u16 gv;
	u16 bv;
	u16 av;
};

struct comm_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	char comm[16];
};

struct commit_header {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
	unsigned char h_chksum_type;
	unsigned char h_chksum_size;
	unsigned char h_padding[2];
	__be32 h_chksum[8];
	__be64 h_commit_sec;
	__be32 h_commit_nsec;
};

struct lsm_network_audit;

struct lsm_ioctlop_audit;

struct lsm_ibpkey_audit;

struct lsm_ibendport_audit;

struct common_audit_data {
	char type;
	union {
		struct path path;
		struct dentry *dentry;
		struct inode *inode;
		struct lsm_network_audit *net;
		int cap;
		int ipc_id;
		struct task_struct *tsk;
		struct {
			key_serial_t key;
			char *key_desc;
		} key_struct;
		char *kmod_name;
		struct lsm_ioctlop_audit *op;
		struct file *file;
		struct lsm_ibpkey_audit *ibpkey;
		struct lsm_ibendport_audit *ibendport;
		int reason;
		const char *anonclass;
		u16 nlmsg_type;
	} u;
	union {};
};

struct zone;

struct compact_control {
	struct list_head freepages[11];
	struct list_head migratepages;
	unsigned int nr_freepages;
	unsigned int nr_migratepages;
	long unsigned int free_pfn;
	long unsigned int migrate_pfn;
	long unsigned int fast_start_pfn;
	struct zone *zone;
	long unsigned int total_migrate_scanned;
	long unsigned int total_free_scanned;
	short unsigned int fast_search_fail;
	short int search_order;
	const gfp_t gfp_mask;
	int order;
	int migratetype;
	const unsigned int alloc_flags;
	const int highest_zoneidx;
	enum migrate_mode mode;
	bool ignore_skip_hint;
	bool no_set_skip_hint;
	bool ignore_block_suitable;
	bool direct_compaction;
	bool proactive_compaction;
	bool whole_zone;
	bool contended;
	bool finish_pageblock;
	bool alloc_contig;
};

struct compat_group_filter {
	union {
		struct {
			__u32 gf_interface_aux;
			struct __kernel_sockaddr_storage gf_group_aux;
			__u32 gf_fmode_aux;
			__u32 gf_numsrc_aux;
			struct __kernel_sockaddr_storage gf_slist[1];
		} __attribute__((packed));
		struct {
			__u32 gf_interface;
			struct __kernel_sockaddr_storage gf_group;
			__u32 gf_fmode;
			__u32 gf_numsrc;
			struct __kernel_sockaddr_storage gf_slist_flex[0];
		} __attribute__((packed));
	};
};

struct compat_group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
} __attribute__((packed));

struct compat_group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
} __attribute__((packed));

struct compat_if_dqblk {
	compat_u64 dqb_bhardlimit;
	compat_u64 dqb_bsoftlimit;
	compat_u64 dqb_curspace;
	compat_u64 dqb_ihardlimit;
	compat_u64 dqb_isoftlimit;
	compat_u64 dqb_curinodes;
	compat_u64 dqb_btime;
	compat_u64 dqb_itime;
	compat_uint_t dqb_valid;
};

struct compat_if_settings {
	unsigned int type;
	unsigned int size;
	compat_uptr_t ifs_ifsu;
};

struct compat_ifconf {
	compat_int_t ifc_len;
	compat_caddr_t ifcbuf;
};

struct compat_ifmap {
	compat_ulong_t mem_start;
	compat_ulong_t mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct compat_ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		compat_int_t ifru_ivalue;
		compat_int_t ifru_mtu;
		struct compat_ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		compat_caddr_t ifru_data;
		struct compat_if_settings ifru_settings;
	} ifr_ifru;
};

struct compat_iovec {
	compat_uptr_t iov_base;
	compat_size_t iov_len;
};

struct compat_msghdr {
	compat_uptr_t msg_name;
	compat_int_t msg_namelen;
	compat_uptr_t msg_iov;
	compat_size_t msg_iovlen;
	compat_uptr_t msg_control;
	compat_size_t msg_controllen;
	compat_uint_t msg_flags;
};

struct compat_mmsghdr {
	struct compat_msghdr msg_hdr;
	compat_uint_t msg_len;
};

struct compat_nfs_string {
	compat_uint_t len;
	compat_uptr_t data;
};

struct compat_nfs4_mount_data_v1 {
	compat_int_t version;
	compat_int_t flags;
	compat_int_t rsize;
	compat_int_t wsize;
	compat_int_t timeo;
	compat_int_t retrans;
	compat_int_t acregmin;
	compat_int_t acregmax;
	compat_int_t acdirmin;
	compat_int_t acdirmax;
	struct compat_nfs_string client_addr;
	struct compat_nfs_string mnt_path;
	struct compat_nfs_string hostname;
	compat_uint_t host_addrlen;
	compat_uptr_t host_addr;
	compat_int_t proto;
	compat_int_t auth_flavourlen;
	compat_uptr_t auth_flavours;
};

struct compat_resume_swap_area {
	compat_loff_t offset;
	u32 dev;
} __attribute__((packed));

struct compat_sg_io_hdr {
	compat_int_t interface_id;
	compat_int_t dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	compat_uint_t dxfer_len;
	compat_uint_t dxferp;
	compat_uptr_t cmdp;
	compat_uptr_t sbp;
	compat_uint_t timeout;
	compat_uint_t flags;
	compat_int_t pack_id;
	compat_uptr_t usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	compat_int_t resid;
	compat_uint_t duration;
	compat_uint_t info;
};

struct compat_sock_fprog {
	u16 len;
	compat_uptr_t filter;
};

struct component_ops;

struct component {
	struct list_head node;
	struct aggregate_device *adev;
	bool bound;
	const struct component_ops *ops;
	int subcomponent;
	struct device *dev;
};

struct component_master_ops {
	int (*bind)(struct device *);
	void (*unbind)(struct device *);
};

struct component_match_array;

struct component_match {
	size_t alloc;
	size_t num;
	struct component_match_array *compare;
};

struct component_match_array {
	void *data;
	int (*compare)(struct device *, void *);
	int (*compare_typed)(struct device *, int, void *);
	void (*release)(struct device *, void *);
	struct component *component;
	bool duplicate;
};

struct component_ops {
	int (*bind)(struct device *, struct device *, void *);
	void (*unbind)(struct device *, struct device *, void *);
};

struct compound_hdr {
	int32_t status;
	uint32_t nops;
	__be32 *nops_p;
	uint32_t taglen;
	char *tag;
	uint32_t replen;
	u32 minorversion;
};

typedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

struct compressed_bio {
	unsigned int nr_folios;
	struct folio **compressed_folios;
	u64 start;
	unsigned int len;
	unsigned int compressed_len;
	u8 compress_type;
	bool writeback;
	union {
		struct btrfs_bio *orig_bbio;
		struct work_struct write_end_work;
	};
	struct btrfs_bio bbio;
};

struct consw;

struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};

struct config_group;

struct config_item_type;

struct config_item {
	char *ci_name;
	char ci_namebuf[20];
	struct kref ci_kref;
	struct list_head ci_entry;
	struct config_item *ci_parent;
	struct config_group *ci_group;
	const struct config_item_type *ci_type;
	struct dentry *ci_dentry;
};

struct configfs_subsystem;

struct config_group {
	struct config_item cg_item;
	struct list_head cg_children;
	struct configfs_subsystem *cg_subsys;
	struct list_head default_groups;
	struct list_head group_entry;
};

struct configfs_item_operations;

struct configfs_group_operations;

struct configfs_attribute;

struct configfs_bin_attribute;

struct config_item_type {
	struct module *ct_owner;
	struct configfs_item_operations *ct_item_ops;
	struct configfs_group_operations *ct_group_ops;
	struct configfs_attribute **ct_attrs;
	struct configfs_bin_attribute **ct_bin_attrs;
};

struct deflate_state;

typedef struct deflate_state deflate_state;

typedef block_state (*compress_func)(deflate_state *, int);

struct config_s {
	ush good_length;
	ush max_lazy;
	ush nice_length;
	ush max_chain;
	compress_func func;
};

typedef struct config_s config;

struct config_t {
	struct kref ref;
	unsigned int state;
	struct resource io[2];
	struct resource mem[4];
};

typedef struct config_t config_t;

struct configfs_attribute {
	const char *ca_name;
	struct module *ca_owner;
	umode_t ca_mode;
	ssize_t (*show)(struct config_item *, char *);
	ssize_t (*store)(struct config_item *, const char *, size_t);
};

struct configfs_bin_attribute {
	struct configfs_attribute cb_attr;
	void *cb_private;
	size_t cb_max_size;
	ssize_t (*read)(struct config_item *, void *, size_t);
	ssize_t (*write)(struct config_item *, const void *, size_t);
};

struct configfs_buffer {
	size_t count;
	loff_t pos;
	char *page;
	struct configfs_item_operations *ops;
	struct mutex mutex;
	int needs_read_fill;
	bool read_in_progress;
	bool write_in_progress;
	char *bin_buffer;
	int bin_buffer_size;
	int cb_max_size;
	struct config_item *item;
	struct module *owner;
	union {
		struct configfs_attribute *attr;
		struct configfs_bin_attribute *bin_attr;
	};
};

struct iattr;

struct configfs_fragment;

struct configfs_dirent {
	atomic_t s_count;
	int s_dependent_count;
	struct list_head s_sibling;
	struct list_head s_children;
	int s_links;
	void *s_element;
	int s_type;
	umode_t s_mode;
	struct dentry *s_dentry;
	struct iattr *s_iattr;
	struct configfs_fragment *s_frag;
};

struct configfs_fragment {
	atomic_t frag_count;
	struct rw_semaphore frag_sem;
	bool frag_dead;
};

struct configfs_group_operations {
	struct config_item * (*make_item)(struct config_group *, const char *);
	struct config_group * (*make_group)(struct config_group *, const char *);
	void (*disconnect_notify)(struct config_group *, struct config_item *);
	void (*drop_item)(struct config_group *, struct config_item *);
	bool (*is_visible)(struct config_item *, struct configfs_attribute *, int);
	bool (*is_bin_visible)(struct config_item *, struct configfs_bin_attribute *, int);
};

struct configfs_item_operations {
	void (*release)(struct config_item *);
	int (*allow_link)(struct config_item *, struct config_item *);
	void (*drop_link)(struct config_item *, struct config_item *);
};

struct configfs_subsystem {
	struct config_group su_group;
	struct mutex su_mutex;
};

struct connect_timeout_data {
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct conntrack_gc_work {
	struct delayed_work dwork;
	u32 next_bucket;
	u32 avg_timeout;
	u32 count;
	u32 start_time;
	bool exiting;
	bool early_drop;
};

struct console;

struct printk_buffers;

struct nbcon_context {
	struct console *console;
	unsigned int spinwait_max_us;
	enum nbcon_prio prio;
	unsigned int allow_unsafe_takeover: 1;
	unsigned int backlog: 1;
	struct printk_buffers *pbufs;
	u64 seq;
};

struct tty_driver;

struct nbcon_write_context;

struct console {
	char name[16];
	void (*write)(struct console *, const char *, unsigned int);
	int (*read)(struct console *, char *, unsigned int);
	struct tty_driver * (*device)(struct console *, int *);
	void (*unblank)(void);
	int (*setup)(struct console *, char *);
	int (*exit)(struct console *);
	int (*match)(struct console *, char *, int, char *);
	short int flags;
	short int index;
	int cflag;
	uint ispeed;
	uint ospeed;
	u64 seq;
	long unsigned int dropped;
	void *data;
	struct hlist_node node;
	void (*write_atomic)(struct console *, struct nbcon_write_context *);
	void (*write_thread)(struct console *, struct nbcon_write_context *);
	void (*device_lock)(struct console *, long unsigned int *);
	void (*device_unlock)(struct console *, long unsigned int);
	atomic_t nbcon_state;
	atomic_long_t nbcon_seq;
	struct nbcon_context nbcon_device_ctxt;
	atomic_long_t nbcon_prev_seq;
	struct printk_buffers *pbufs;
	struct task_struct *kthread;
	struct rcuwait rcuwait;
	struct irq_work irq_work;
};

struct winsize {
	short unsigned int ws_row;
	short unsigned int ws_col;
	short unsigned int ws_xpixel;
	short unsigned int ws_ypixel;
};

struct hvc_struct;

struct console___2 {
	struct list_head list;
	struct hvc_struct *hvc;
	struct winsize ws;
	u32 vtermno;
};

struct console_cmdline {
	char name[16];
	int index;
	char devname[32];
	bool user_specified;
	char *options;
};

struct console_flush_type {
	bool nbcon_atomic;
	bool nbcon_offload;
	bool legacy_direct;
	bool legacy_offload;
};

struct console_font {
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct console_font_op {
	unsigned int op;
	unsigned int flags;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct constant_table {
	const char *name;
	int value;
};

struct vc_data;

struct consw {
	struct module *owner;
	const char * (*con_startup)(void);
	void (*con_init)(struct vc_data *, bool);
	void (*con_deinit)(struct vc_data *);
	void (*con_clear)(struct vc_data *, unsigned int, unsigned int, unsigned int);
	void (*con_putc)(struct vc_data *, u16, unsigned int, unsigned int);
	void (*con_putcs)(struct vc_data *, const u16 *, unsigned int, unsigned int, unsigned int);
	void (*con_cursor)(struct vc_data *, bool);
	bool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);
	bool (*con_switch)(struct vc_data *);
	bool (*con_blank)(struct vc_data *, enum vesa_blank_mode, bool);
	int (*con_font_set)(struct vc_data *, const struct console_font *, unsigned int, unsigned int);
	int (*con_font_get)(struct vc_data *, struct console_font *, unsigned int);
	int (*con_font_default)(struct vc_data *, struct console_font *, const char *);
	int (*con_resize)(struct vc_data *, unsigned int, unsigned int, bool);
	void (*con_set_palette)(struct vc_data *, const unsigned char *);
	void (*con_scrolldelta)(struct vc_data *, int);
	bool (*con_set_origin)(struct vc_data *);
	void (*con_save_screen)(struct vc_data *);
	u8 (*con_build_attr)(struct vc_data *, u8, enum vc_intensity, bool, bool, bool, bool);
	void (*con_invert_region)(struct vc_data *, u16 *, int);
	void (*con_debug_enter)(struct vc_data *);
	void (*con_debug_leave)(struct vc_data *);
};

struct microcode_amd;

struct cont_desc {
	struct microcode_amd *mc;
	u32 psize;
	u8 *data;
	size_t size;
};

struct container_dev {
	struct device dev;
	int (*offline)(struct container_dev *);
};

struct context_entry {
	u64 lo;
	u64 hi;
};

struct guc_update_context_policy_header {
	u32 action;
	u32 ctx_id;
};

struct guc_klv_generic_dw_t {
	u32 kl;
	u32 value;
};

struct guc_update_context_policy {
	struct guc_update_context_policy_header header;
	struct guc_klv_generic_dw_t klv[5];
};

struct context_policy {
	u32 count;
	struct guc_update_context_policy h2g;
};

struct context_tracking {
	atomic_t state;
	long int nesting;
	long int nmi_nesting;
};

struct contig_page_info {
	long unsigned int free_pages;
	long unsigned int free_blocks_total;
	long unsigned int free_blocks_suitable;
};

struct virtio_net_ctrl_hdr {
	__u8 class;
	__u8 cmd;
};

struct control_buf {
	struct virtio_net_ctrl_hdr hdr;
	virtio_net_ctrl_ack status;
};

struct cooling_spec {
	long unsigned int upper;
	long unsigned int lower;
	unsigned int weight;
};

struct copy_subpage_arg {
	struct folio *dst;
	struct folio *src;
	struct vm_area_struct *vma;
};

struct core_name {
	char *corename;
	int used;
	int size;
};

struct core_thread {
	struct task_struct *task;
	struct core_thread *next;
};

struct core_state {
	atomic_t nr_threads;
	struct core_thread dumper;
	struct completion startup;
};

struct core_text {
	long unsigned int base;
	long unsigned int end;
	const char *name;
};

struct core_vma_metadata {
	long unsigned int start;
	long unsigned int end;
	long unsigned int flags;
	long unsigned int dump_size;
	long unsigned int pgoff;
	struct file *file;
};

struct kernel_siginfo;

typedef struct kernel_siginfo kernel_siginfo_t;

struct coredump_params {
	const kernel_siginfo_t *siginfo;
	struct file *file;
	long unsigned int limit;
	long unsigned int mm_flags;
	int cpu;
	loff_t written;
	loff_t pos;
	loff_t to_skip;
	int vma_count;
	size_t vma_data_size;
	struct core_vma_metadata *vma_meta;
};

struct coredump_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct pgprot {
	pgprotval_t pgprot;
};

typedef struct pgprot pgprot_t;

struct cpa_data {
	long unsigned int *vaddr;
	pgd_t *pgd;
	pgprot_t mask_set;
	pgprot_t mask_clr;
	long unsigned int numpages;
	long unsigned int curpage;
	long unsigned int pfn;
	unsigned int flags;
	unsigned int force_split: 1;
	unsigned int force_static_prot: 1;
	unsigned int force_flush_all: 1;
	struct page **pages;
};

struct cparams {
	u16 i;
	u16 t;
	u16 m;
	u16 c;
};

struct cpc_reg {
	u8 descriptor;
	u16 length;
	u8 space_id;
	u8 bit_width;
	u8 bit_offset;
	u8 access_width;
	u64 address;
} __attribute__((packed));

struct cpc_register_resource {
	acpi_object_type type;
	u64 *sys_mem_vaddr;
	union {
		struct cpc_reg reg;
		u64 int_value;
	} cpc_entry;
};

struct cpc_desc {
	int num_entries;
	int version;
	int cpu_id;
	int write_cmd_status;
	int write_cmd_id;
	raw_spinlock_t rmw_lock;
	struct cpc_register_resource cpc_regs[21];
	struct acpi_psd_package domain_info;
	struct kobject kobj;
};

struct cpio_data {
	void *data;
	size_t size;
	char name[18];
};

struct cppc_perf_caps {
	u32 guaranteed_perf;
	u32 highest_perf;
	u32 nominal_perf;
	u32 lowest_perf;
	u32 lowest_nonlinear_perf;
	u32 lowest_freq;
	u32 nominal_freq;
	u32 energy_perf;
	bool auto_sel;
};

struct cppc_perf_ctrls {
	u32 max_perf;
	u32 min_perf;
	u32 desired_perf;
	u32 energy_perf;
};

struct cppc_perf_fb_ctrs {
	u64 reference;
	u64 delivered;
	u64 reference_perf;
	u64 wraparound_time;
};

struct cppc_cpudata {
	struct list_head node;
	struct cppc_perf_caps perf_caps;
	struct cppc_perf_ctrls perf_ctrls;
	struct cppc_perf_fb_ctrs perf_fb_ctrs;
	unsigned int shared_type;
	cpumask_var_t shared_cpu_map;
};

struct pcc_mbox_chan;

struct cppc_pcc_data {
	struct pcc_mbox_chan *pcc_channel;
	void *pcc_comm_addr;
	bool pcc_channel_acquired;
	unsigned int deadline_us;
	unsigned int pcc_mpar;
	unsigned int pcc_mrtt;
	unsigned int pcc_nominal;
	bool pending_pcc_write_cmd;
	bool platform_owns_pcc;
	unsigned int pcc_write_cnt;
	struct rw_semaphore pcc_lock;
	wait_queue_head_t pcc_write_wait_q;
	ktime_t last_cmd_cmpl_time;
	ktime_t last_mpar_reset;
	int mpar_count;
	int refcount;
};

struct cpu {
	int node_id;
	int hotpluggable;
	struct device dev;
};

struct cpu_attr {
	struct device_attribute attr;
	const struct cpumask * const map;
};

struct cpu_cacheinfo {
	struct cacheinfo *info_list;
	unsigned int per_cpu_data_slice_size;
	unsigned int num_levels;
	unsigned int num_leaves;
	bool cpu_map_populated;
	bool early_ci_levels;
};

struct update_util_data {
	void (*func)(struct update_util_data *, u64, unsigned int);
};

struct policy_dbs_info;

struct cpu_dbs_info {
	u64 prev_cpu_idle;
	u64 prev_update_time;
	u64 prev_cpu_nice;
	unsigned int prev_load;
	struct update_util_data update_util;
	struct policy_dbs_info *policy_dbs;
};

struct cpuinfo_x86;

struct cpu_dev {
	const char *c_vendor;
	const char *c_ident[2];
	void (*c_early_init)(struct cpuinfo_x86 *);
	void (*c_bsp_init)(struct cpuinfo_x86 *);
	void (*c_init)(struct cpuinfo_x86 *);
	void (*c_identify)(struct cpuinfo_x86 *);
	void (*c_detect_tlb)(struct cpuinfo_x86 *);
	int c_x86_vendor;
};

struct cpu_down_work {
	unsigned int cpu;
	enum cpuhp_state target;
};

struct entry_stack {
	char stack[4096];
};

struct entry_stack_page {
	struct entry_stack stack;
};

struct x86_hw_tss {
	u32 reserved1;
	u64 sp0;
	u64 sp1;
	u64 sp2;
	u64 reserved2;
	u64 ist[7];
	u32 reserved3;
	u32 reserved4;
	u16 reserved5;
	u16 io_bitmap_base;
} __attribute__((packed));

struct x86_io_bitmap {
	u64 prev_sequence;
	unsigned int prev_max;
	long unsigned int bitmap[1025];
	long unsigned int mapall[1025];
};

struct tss_struct {
	struct x86_hw_tss x86_tss;
	struct x86_io_bitmap io_bitmap;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct debug_store_buffers {
	char bts_buffer[65536];
	char pebs_buffer[65536];
};

struct cpu_entry_area {
	char gdt[4096];
	struct entry_stack_page entry_stack_page;
	struct tss_struct tss;
	struct cea_exception_stacks estacks;
	struct debug_store cpu_debug_store;
	struct debug_store_buffers cpu_debug_buffers;
};

struct folio_batch {
	unsigned char nr;
	unsigned char i;
	bool percpu_pvec_drained;
	struct folio *folios[31];
};

struct cpu_fbatches {
	local_lock_t lock;
	struct folio_batch lru_add;
	struct folio_batch lru_deactivate_file;
	struct folio_batch lru_deactivate;
	struct folio_batch lru_lazyfree;
	struct folio_batch lru_activate;
	local_lock_t lock_irq;
	struct folio_batch lru_move_tail;
};

struct perf_branch_entry {
	__u64 from;
	__u64 to;
	__u64 mispred: 1;
	__u64 predicted: 1;
	__u64 in_tx: 1;
	__u64 abort: 1;
	__u64 cycles: 16;
	__u64 type: 4;
	__u64 spec: 2;
	__u64 new_type: 4;
	__u64 priv: 3;
	__u64 reserved: 31;
};

struct perf_branch_stack {
	__u64 nr;
	__u64 hw_idx;
	struct perf_branch_entry entries[0];
};

struct perf_guest_switch_msr {
	unsigned int msr;
	u64 host;
	u64 guest;
};

struct er_account;

struct intel_shared_regs;

struct intel_excl_cntrs;

struct cpu_hw_events {
	struct perf_event *events[64];
	long unsigned int active_mask[1];
	long unsigned int dirty[1];
	int enabled;
	int n_events;
	int n_added;
	int n_txn;
	int n_txn_pair;
	int n_txn_metric;
	int assign[64];
	u64 tags[64];
	struct perf_event *event_list[64];
	struct event_constraint *event_constraint[64];
	int n_excl;
	unsigned int txn_flags;
	int is_fake;
	struct debug_store *ds;
	void *ds_pebs_vaddr;
	void *ds_bts_vaddr;
	u64 pebs_enabled;
	int n_pebs;
	int n_large_pebs;
	int n_pebs_via_pt;
	int pebs_output;
	u64 pebs_data_cfg;
	u64 active_pebs_data_cfg;
	int pebs_record_size;
	u64 fixed_ctrl_val;
	u64 active_fixed_ctrl_val;
	int lbr_users;
	int lbr_pebs_users;
	struct perf_branch_stack lbr_stack;
	struct perf_branch_entry lbr_entries[32];
	u64 lbr_counters[32];
	union {
		struct er_account *lbr_sel;
		struct er_account *lbr_ctl;
	};
	u64 br_sel;
	void *last_task_ctx;
	int last_log_id;
	int lbr_select;
	void *lbr_xsave;
	u64 intel_ctrl_guest_mask;
	u64 intel_ctrl_host_mask;
	struct perf_guest_switch_msr guest_switch_msrs[64];
	u64 intel_cp_status;
	struct intel_shared_regs *shared_regs;
	struct event_constraint *constraint_list;
	struct intel_excl_cntrs *excl_cntrs;
	int excl_thread_id;
	u64 tfa_shadow;
	int n_metric;
	struct amd_nb *amd_nb;
	int brs_active;
	u64 perf_ctr_virt_mask;
	int n_pair;
	void *kfree_on_online[2];
	struct pmu *pmu;
};

struct cpu_itimer {
	u64 expires;
	u64 incr;
};

struct cpu_perf_ibs {
	struct perf_event *event;
	long unsigned int state[1];
};

struct cpu_rmap {
	struct kref refcount;
	u16 size;
	void **obj;
	struct {
		u16 index;
		u16 dist;
	} near[0];
};

struct cpu_signature {
	unsigned int sig;
	unsigned int pf;
	unsigned int rev;
};

struct cpu_stop_done {
	atomic_t nr_todo;
	int ret;
	struct completion completion;
};

typedef int (*cpu_stop_fn_t)(void *);

struct cpu_stop_work {
	struct list_head list;
	cpu_stop_fn_t fn;
	long unsigned int caller;
	void *arg;
	struct cpu_stop_done *done;
};

struct cpu_stopper {
	struct task_struct *thread;
	raw_spinlock_t lock;
	bool enabled;
	struct list_head works;
	struct cpu_stop_work stop_work;
	long unsigned int caller;
	cpu_stop_fn_t fn;
};

struct cpu_timer {
	struct timerqueue_node node;
	struct timerqueue_head *head;
	struct pid *pid;
	struct list_head elist;
	bool firing;
	bool nanosleep;
	struct task_struct *handling;
};

struct cpu_vfs_cap_data {
	__u32 magic_etc;
	kuid_t rootid;
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
};

struct kernel_cpustat;

struct cpuacct {
	struct cgroup_subsys_state css;
	u64 *cpuusage;
	struct kernel_cpustat *cpustat;
};

struct pstate_data {
	int current_pstate;
	int min_pstate;
	int max_pstate;
	int max_pstate_physical;
	int perf_ctl_scaling;
	int scaling;
	int turbo_pstate;
	unsigned int min_freq;
	unsigned int max_freq;
	unsigned int turbo_freq;
};

struct vid_data {
	int min;
	int max;
	int turbo;
	int32_t ratio;
};

struct sample {
	int32_t core_avg_perf;
	int32_t busy_scaled;
	u64 aperf;
	u64 mperf;
	u64 tsc;
	u64 time;
};

struct cpudata {
	int cpu;
	unsigned int policy;
	struct update_util_data update_util;
	bool update_util_set;
	struct pstate_data pstate;
	struct vid_data vid;
	u64 last_update;
	u64 last_sample_time;
	u64 aperf_mperf_shift;
	u64 prev_aperf;
	u64 prev_mperf;
	u64 prev_tsc;
	struct sample sample;
	int32_t min_perf_ratio;
	int32_t max_perf_ratio;
	struct acpi_processor_performance acpi_perf_data;
	bool valid_pss_table;
	unsigned int iowait_boost;
	s16 epp_powersave;
	s16 epp_policy;
	s16 epp_default;
	s16 epp_cached;
	u64 hwp_req_cached;
	u64 hwp_cap_cached;
	u64 last_io_update;
	unsigned int capacity_perf;
	unsigned int sched_flags;
	u32 hwp_boost_min;
	bool suspended;
	struct delayed_work hwp_notify_work;
};

struct cpudl_item;

struct cpudl {
	raw_spinlock_t lock;
	int size;
	cpumask_var_t free_cpus;
	struct cpudl_item *elements;
};

struct cpudl_item {
	u64 dl;
	int cpu;
	int idx;
};

struct cpufreq_cpuinfo {
	unsigned int max_freq;
	unsigned int min_freq;
	unsigned int transition_latency;
};

struct cpufreq_policy;

struct cpufreq_policy_data;

struct freq_attr;

struct cpufreq_driver {
	char name[16];
	u16 flags;
	void *driver_data;
	int (*init)(struct cpufreq_policy *);
	int (*verify)(struct cpufreq_policy_data *);
	int (*setpolicy)(struct cpufreq_policy *);
	int (*target)(struct cpufreq_policy *, unsigned int, unsigned int);
	int (*target_index)(struct cpufreq_policy *, unsigned int);
	unsigned int (*fast_switch)(struct cpufreq_policy *, unsigned int);
	void (*adjust_perf)(unsigned int, long unsigned int, long unsigned int, long unsigned int);
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get)(unsigned int);
	void (*update_limits)(unsigned int);
	int (*bios_limit)(int, unsigned int *);
	int (*online)(struct cpufreq_policy *);
	int (*offline)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
	void (*ready)(struct cpufreq_policy *);
	struct freq_attr **attr;
	bool boost_enabled;
	int (*set_boost)(struct cpufreq_policy *, int);
	void (*register_em)(struct cpufreq_policy *);
};

struct cpufreq_freqs {
	struct cpufreq_policy *policy;
	unsigned int old;
	unsigned int new;
	u8 flags;
};

struct cpufreq_frequency_table {
	unsigned int flags;
	unsigned int driver_data;
	unsigned int frequency;
};

struct cpufreq_governor {
	char name[16];
	int (*init)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*start)(struct cpufreq_policy *);
	void (*stop)(struct cpufreq_policy *);
	void (*limits)(struct cpufreq_policy *);
	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
	struct list_head governor_list;
	struct module *owner;
	u8 flags;
};

struct plist_head {
	struct list_head node_list;
};

struct pm_qos_constraints {
	struct plist_head list;
	s32 target_value;
	s32 default_value;
	s32 no_constraint_value;
	enum pm_qos_type type;
	struct blocking_notifier_head *notifiers;
};

struct freq_constraints {
	struct pm_qos_constraints min_freq;
	struct blocking_notifier_head min_freq_notifiers;
	struct pm_qos_constraints max_freq;
	struct blocking_notifier_head max_freq_notifiers;
};

struct cpufreq_stats;

struct cpufreq_policy {
	cpumask_var_t cpus;
	cpumask_var_t related_cpus;
	cpumask_var_t real_cpus;
	unsigned int shared_type;
	unsigned int cpu;
	struct clk *clk;
	struct cpufreq_cpuinfo cpuinfo;
	unsigned int min;
	unsigned int max;
	unsigned int cur;
	unsigned int suspend_freq;
	unsigned int policy;
	unsigned int last_policy;
	struct cpufreq_governor *governor;
	void *governor_data;
	char last_governor[16];
	struct work_struct update;
	struct freq_constraints constraints;
	struct freq_qos_request *min_freq_req;
	struct freq_qos_request *max_freq_req;
	struct cpufreq_frequency_table *freq_table;
	enum cpufreq_table_sorting freq_table_sorted;
	struct list_head policy_list;
	struct kobject kobj;
	struct completion kobj_unregister;
	struct rw_semaphore rwsem;
	bool fast_switch_possible;
	bool fast_switch_enabled;
	bool strict_target;
	bool efficiencies_available;
	unsigned int transition_delay_us;
	bool dvfs_possible_from_any_cpu;
	bool boost_enabled;
	unsigned int cached_target_freq;
	unsigned int cached_resolved_idx;
	bool transition_ongoing;
	spinlock_t transition_lock;
	wait_queue_head_t transition_wait;
	struct task_struct *transition_task;
	struct cpufreq_stats *stats;
	void *driver_data;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct cpufreq_policy_data {
	struct cpufreq_cpuinfo cpuinfo;
	struct cpufreq_frequency_table *freq_table;
	unsigned int cpu;
	unsigned int min;
	unsigned int max;
};

struct cpuhp_cpu_state {
	enum cpuhp_state state;
	enum cpuhp_state target;
	enum cpuhp_state fail;
	struct task_struct *thread;
	bool should_run;
	bool rollback;
	bool single;
	bool bringup;
	struct hlist_node *node;
	struct hlist_node *last;
	enum cpuhp_state cb_state;
	int result;
	atomic_t ap_sync_state;
	struct completion done_up;
	struct completion done_down;
};

struct cpuhp_step {
	const char *name;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} startup;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} teardown;
	struct hlist_head list;
	bool cant_stop;
	bool multi_instance;
};

union cpuid10_eax {
	struct {
		unsigned int version_id: 8;
		unsigned int num_counters: 8;
		unsigned int bit_width: 8;
		unsigned int mask_length: 8;
	} split;
	unsigned int full;
};

union cpuid10_ebx {
	struct {
		unsigned int no_unhalted_core_cycles: 1;
		unsigned int no_instructions_retired: 1;
		unsigned int no_unhalted_reference_cycles: 1;
		unsigned int no_llc_reference: 1;
		unsigned int no_llc_misses: 1;
		unsigned int no_branch_instruction_retired: 1;
		unsigned int no_branch_misses_retired: 1;
	} split;
	unsigned int full;
};

union cpuid10_edx {
	struct {
		unsigned int num_counters_fixed: 5;
		unsigned int bit_width_fixed: 8;
		unsigned int reserved1: 2;
		unsigned int anythread_deprecated: 1;
		unsigned int reserved2: 16;
	} split;
	unsigned int full;
};

union cpuid28_eax {
	struct {
		unsigned int lbr_depth_mask: 8;
		unsigned int reserved: 22;
		unsigned int lbr_deep_c_reset: 1;
		unsigned int lbr_lip: 1;
	} split;
	unsigned int full;
};

union cpuid28_ebx {
	struct {
		unsigned int lbr_cpl: 1;
		unsigned int lbr_filter: 1;
		unsigned int lbr_call_stack: 1;
	} split;
	unsigned int full;
};

union cpuid28_ecx {
	struct {
		unsigned int lbr_mispred: 1;
		unsigned int lbr_timed_lbr: 1;
		unsigned int lbr_br_type: 1;
		unsigned int reserved: 13;
		unsigned int lbr_counters: 4;
	} split;
	unsigned int full;
};

union cpuid35_eax {
	struct {
		unsigned int leaf0: 1;
		unsigned int cntr_subleaf: 1;
		unsigned int acr_subleaf: 1;
		unsigned int events_subleaf: 1;
		unsigned int reserved: 28;
	} split;
	unsigned int full;
};

union cpuid35_ebx {
	struct {
		unsigned int umask2: 1;
		unsigned int eq: 1;
		unsigned int reserved: 30;
	} split;
	unsigned int full;
};

union cpuid_0x80000022_ebx {
	struct {
		unsigned int num_core_pmc: 4;
		unsigned int lbr_v2_stack_sz: 6;
		unsigned int num_df_pmc: 6;
		unsigned int num_umc_pmc: 6;
	} split;
	unsigned int full;
};

union cpuid_1_eax {
	struct {
		__u32 stepping: 4;
		__u32 model: 4;
		__u32 family: 4;
		__u32 __reserved0: 4;
		__u32 ext_model: 4;
		__u32 ext_fam: 8;
		__u32 __reserved1: 4;
	};
	__u32 full;
};

struct cpuid_bit {
	u16 feature;
	u8 reg;
	u8 bit;
	u32 level;
	u32 sub_leaf;
};

struct cpuid_dep {
	unsigned int feature;
	unsigned int depends;
};

struct cpuid_dependent_feature {
	u32 feature;
	u32 level;
};

struct cpuid_regs {
	u32 eax;
	u32 ebx;
	u32 ecx;
	u32 edx;
};

struct cpuid_regs_done {
	struct cpuid_regs regs;
	struct completion done;
};

struct cpuidle_device;

struct cpuidle_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_device *, char *);
	ssize_t (*store)(struct cpuidle_device *, const char *, size_t);
};

struct cpuidle_state_usage {
	long long unsigned int disable;
	long long unsigned int usage;
	u64 time_ns;
	long long unsigned int above;
	long long unsigned int below;
	long long unsigned int rejected;
	long long unsigned int s2idle_usage;
	long long unsigned int s2idle_time;
};

struct cpuidle_driver_kobj;

struct cpuidle_state_kobj;

struct cpuidle_device_kobj;

struct cpuidle_device {
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int poll_time_limit: 1;
	unsigned int cpu;
	ktime_t next_hrtimer;
	int last_state_idx;
	u64 last_residency_ns;
	u64 poll_limit_ns;
	u64 forced_idle_latency_limit_ns;
	struct cpuidle_state_usage states_usage[10];
	struct cpuidle_state_kobj *kobjs[10];
	struct cpuidle_driver_kobj *kobj_driver;
	struct cpuidle_device_kobj *kobj_dev;
	struct list_head device_list;
};

struct cpuidle_device_kobj {
	struct cpuidle_device *dev;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_driver;

struct cpuidle_state {
	char name[16];
	char desc[32];
	s64 exit_latency_ns;
	s64 target_residency_ns;
	unsigned int flags;
	unsigned int exit_latency;
	int power_usage;
	unsigned int target_residency;
	int (*enter)(struct cpuidle_device *, struct cpuidle_driver *, int);
	void (*enter_dead)(struct cpuidle_device *, int);
	int (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver *, int);
};

struct cpuidle_driver {
	const char *name;
	struct module *owner;
	unsigned int bctimer: 1;
	struct cpuidle_state states[10];
	int state_count;
	int safe_state_index;
	struct cpumask *cpumask;
	const char *governor;
};

struct cpuidle_governor {
	char name[16];
	struct list_head governor_list;
	unsigned int rating;
	int (*enable)(struct cpuidle_driver *, struct cpuidle_device *);
	void (*disable)(struct cpuidle_driver *, struct cpuidle_device *);
	int (*select)(struct cpuidle_driver *, struct cpuidle_device *, bool *);
	void (*reflect)(struct cpuidle_device *, int);
};

struct cpuidle_state_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_state *, struct cpuidle_state_usage *, char *);
	ssize_t (*store)(struct cpuidle_state *, struct cpuidle_state_usage *, const char *, size_t);
};

struct cpuidle_state_kobj {
	struct cpuidle_state *state;
	struct cpuidle_state_usage *state_usage;
	struct completion kobj_unregister;
	struct kobject kobj;
	struct cpuidle_device *device;
};

struct cpuinfo_topology {
	u32 apicid;
	u32 initial_apicid;
	u32 pkg_id;
	u32 die_id;
	u32 cu_id;
	u32 core_id;
	u32 logical_pkg_id;
	u32 logical_die_id;
	u32 logical_core_id;
	u32 amd_node_id;
	u32 llc_id;
	u32 l2c_id;
	union {
		u32 cpu_type;
		struct {
			u32 intel_native_model_id: 24;
			u32 intel_type: 8;
		};
		struct {
			u32 amd_num_processors: 16;
			u32 amd_power_eff_ranking: 8;
			u32 amd_native_model_id: 4;
			u32 amd_type: 4;
		};
	};
};

struct cpuinfo_x86 {
	union {
		struct {
			__u8 x86_model;
			__u8 x86;
			__u8 x86_vendor;
			__u8 x86_reserved;
		};
		__u32 x86_vfm;
	};
	__u8 x86_stepping;
	int x86_tlbsize;
	__u32 vmx_capability[5];
	__u8 x86_virt_bits;
	__u8 x86_phys_bits;
	__u32 extended_cpuid_level;
	int cpuid_level;
	union {
		__u32 x86_capability[24];
		long unsigned int x86_capability_alignment;
	};
	char x86_vendor_id[16];
	char x86_model_id[64];
	struct cpuinfo_topology topo;
	unsigned int x86_cache_size;
	int x86_cache_alignment;
	int x86_cache_max_rmid;
	int x86_cache_occ_scale;
	int x86_cache_mbm_width_offset;
	int x86_power;
	long unsigned int loops_per_jiffy;
	u64 ppin;
	u16 x86_clflush_size;
	u16 booted_cores;
	u16 cpu_index;
	bool smt_active;
	u32 microcode;
	u8 x86_cache_bits;
	unsigned int initialized: 1;
};

struct cpumap {
	unsigned int available;
	unsigned int allocated;
	unsigned int managed;
	unsigned int managed_allocated;
	bool initialized;
	bool online;
	long unsigned int *managed_map;
	long unsigned int alloc_map[0];
};

union cpumask_rcuhead {
	cpumask_t cpumask;
	struct callback_head rcu;
};

struct cpupri_vec {
	atomic_t count;
	cpumask_var_t mask;
};

struct cpupri {
	struct cpupri_vec pri_to_cpu[101];
	int *cpu_to_pri;
};

struct fmeter {
	int cnt;
	int val;
	time64_t time;
	spinlock_t lock;
};

struct uf_node {
	struct uf_node *parent;
	unsigned int rank;
};

struct cpuset {
	struct cgroup_subsys_state css;
	long unsigned int flags;
	cpumask_var_t cpus_allowed;
	nodemask_t mems_allowed;
	cpumask_var_t effective_cpus;
	nodemask_t effective_mems;
	cpumask_var_t effective_xcpus;
	cpumask_var_t exclusive_cpus;
	nodemask_t old_mems_allowed;
	struct fmeter fmeter;
	int attach_in_progress;
	int relax_domain_level;
	int nr_subparts;
	int partition_root_state;
	int nr_deadline_tasks;
	int nr_migrate_dl_tasks;
	u64 sum_migrate_dl_bw;
	enum prs_errcode prs_err;
	struct cgroup_file partition_file;
	struct list_head remote_sibling;
	struct uf_node node;
};

struct cpuset_migrate_mm_work {
	struct work_struct work;
	struct mm_struct *mm;
	nodemask_t from;
	nodemask_t to;
};

struct range {
	u64 start;
	u64 end;
};

struct crash_mem {
	unsigned int max_nr_ranges;
	unsigned int nr_ranges;
	struct range ranges[0];
};

struct crb_regs_head;

struct crb_regs_tail;

struct crb_priv {
	u32 sm;
	const char *hid;
	struct crb_regs_head *regs_h;
	struct crb_regs_tail *regs_t;
	u8 *cmd;
	u8 *rsp;
	u32 cmd_size;
	u32 smc_func_id;
	u32 *pluton_start_addr;
	u32 *pluton_reply_addr;
};

struct crb_regs_head {
	u32 loc_state;
	u32 reserved1;
	u32 loc_ctrl;
	u32 loc_sts;
	u8 reserved2[32];
	u64 intf_id;
	u64 ctrl_ext;
};

struct crb_regs_tail {
	u32 ctrl_req;
	u32 ctrl_sts;
	u32 ctrl_cancel;
	u32 ctrl_start;
	u32 ctrl_int_enable;
	u32 ctrl_int_sts;
	u32 ctrl_cmd_size;
	u32 ctrl_cmd_pa_low;
	u32 ctrl_cmd_pa_high;
	u32 ctrl_rsp_size;
	u64 ctrl_rsp_pa;
};

struct crc_data {
	struct task_struct *thr;
	atomic_t ready;
	atomic_t stop;
	unsigned int run_threads;
	wait_queue_head_t go;
	wait_queue_head_t done;
	u32 *crc32;
	size_t *unc_len[3];
	unsigned char *unc[3];
};

struct drm_i915_private;

struct intel_memory_region;

struct create_ext {
	struct drm_i915_private *i915;
	struct intel_memory_region *placements[7];
	unsigned int n_placements;
	unsigned int placement_mask;
	long unsigned int flags;
	unsigned int pat_index;
};

struct i915_gem_proto_context;

struct drm_i915_file_private;

struct create_ext___2 {
	struct i915_gem_proto_context *pc;
	struct drm_i915_file_private *fpriv;
};

struct group_info;

struct cred {
	atomic_long_t usage;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	void *security;
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

struct crndstate {
	u32 last;
	u32 rho;
};

struct crng {
	u8 key[32];
	long unsigned int generation;
	local_lock_t lock;
};

struct crs_csi2 {
	struct list_head entry;
	acpi_handle handle;
	struct acpi_device_software_nodes *swnodes;
	struct list_head connections;
	u32 port_count;
};

struct crs_csi2_connection {
	struct list_head entry;
	struct acpi_resource_csi2_serialbus csi2_data;
	acpi_handle remote_handle;
	char remote_name[0];
};

struct crypto_tfm {
	refcount_t refcnt;
	u32 crt_flags;
	int node;
	void (*exit)(struct crypto_tfm *);
	struct crypto_alg *__crt_alg;
	void *__crt_ctx[0];
};

struct crypto_acomp {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_aead {
	unsigned int authsize;
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_aead_spawn {
	struct crypto_spawn base;
};

struct crypto_aes_ctx {
	u32 key_enc[60];
	u32 key_dec[60];
	u32 key_length;
};

struct crypto_ahash {
	bool using_shash;
	unsigned int statesize;
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_akcipher {
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_akcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_akcipher_sync_data {
	struct crypto_akcipher *tfm;
	const void *src;
	void *dst;
	unsigned int slen;
	unsigned int dlen;
	struct akcipher_request *req;
	struct crypto_wait cwait;
	struct scatterlist sg;
	u8 *buf;
};

struct crypto_attr_alg {
	char name[128];
};

struct crypto_attr_type {
	u32 type;
	u32 mask;
};

struct crypto_skcipher;

struct crypto_authenc_ctx {
	struct crypto_ahash *auth;
	struct crypto_skcipher *enc;
	struct crypto_sync_skcipher *null;
};

struct crypto_authenc_esn_ctx {
	unsigned int reqoff;
	struct crypto_ahash *auth;
	struct crypto_skcipher *enc;
	struct crypto_sync_skcipher *null;
};

struct crypto_authenc_key_param {
	__be32 enckeylen;
};

struct crypto_authenc_keys {
	const u8 *authkey;
	const u8 *enckey;
	unsigned int authkeylen;
	unsigned int enckeylen;
};

struct crypto_ccm_ctx {
	struct crypto_ahash *mac;
	struct crypto_skcipher *ctr;
};

struct crypto_ccm_req_priv_ctx {
	u8 odata[16];
	u8 idata[16];
	u8 auth_tag[16];
	u32 flags;
	struct scatterlist src[3];
	struct scatterlist dst[3];
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	};
};

struct crypto_cipher {
	struct crypto_tfm base;
};

struct crypto_cipher_spawn {
	struct crypto_spawn base;
};

struct crypto_comp {
	struct crypto_tfm base;
};

struct crypto_gcm_ctx {
	struct crypto_skcipher *ctr;
	struct crypto_ahash *ghash;
};

struct crypto_gcm_ghash_ctx {
	unsigned int cryptlen;
	struct scatterlist *src;
	int (*complete)(struct aead_request *, u32);
};

struct crypto_gcm_req_priv_ctx {
	u8 iv[16];
	u8 auth_tag[16];
	u8 iauth_tag[16];
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct scatterlist sg;
	struct crypto_gcm_ghash_ctx ghash_ctx;
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	} u;
};

struct crypto_hash_walk {
	char *data;
	unsigned int offset;
	unsigned int flags;
	struct page *pg;
	unsigned int entrylen;
	unsigned int total;
	struct scatterlist *sg;
};

struct crypto_kpp {
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_kpp_spawn {
	struct crypto_spawn base;
};

struct crypto_larval {
	struct crypto_alg alg;
	struct crypto_alg *adult;
	struct completion completion;
	u32 mask;
	bool test_started;
};

struct crypto_lskcipher {
	struct crypto_tfm base;
};

struct crypto_lskcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_queue {
	struct list_head list;
	struct list_head *backlog;
	unsigned int qlen;
	unsigned int max_qlen;
};

struct crypto_rfc3686_ctx {
	struct crypto_skcipher *child;
	u8 nonce[4];
};

struct crypto_rfc3686_req_ctx {
	u8 iv[16];
	struct skcipher_request subreq;
};

struct crypto_rfc4106_ctx {
	struct crypto_aead *child;
	u8 nonce[4];
};

struct crypto_rfc4106_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct aead_request subreq;
};

struct crypto_rfc4309_ctx {
	struct crypto_aead *child;
	u8 nonce[3];
};

struct crypto_rfc4309_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct aead_request subreq;
};

struct crypto_rfc4543_ctx {
	struct crypto_aead *child;
	struct crypto_sync_skcipher *null;
	u8 nonce[4];
};

struct crypto_rfc4543_instance_ctx {
	struct crypto_aead_spawn aead;
};

struct crypto_rfc4543_req_ctx {
	struct aead_request subreq;
};

struct crypto_rng {
	struct crypto_tfm base;
};

struct crypto_scomp {
	struct crypto_tfm base;
};

struct crypto_shash {
	unsigned int descsize;
	struct crypto_tfm base;
};

struct crypto_shash_spawn {
	struct crypto_spawn base;
};

struct crypto_sig {
	struct crypto_tfm base;
};

struct crypto_sig_spawn {
	struct crypto_spawn base;
};

struct crypto_skcipher {
	unsigned int reqsize;
	struct crypto_tfm base;
};

struct crypto_sync_skcipher {
	struct crypto_skcipher base;
};

struct rtattr;

struct crypto_template {
	struct list_head list;
	struct hlist_head instances;
	struct module *module;
	int (*create)(struct crypto_template *, struct rtattr **);
	char name[128];
};

struct crypto_test_param {
	char driver[128];
	char alg[128];
	u32 type;
};

struct crypto_type {
	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
	unsigned int (*extsize)(struct crypto_alg *);
	int (*init_tfm)(struct crypto_tfm *);
	void (*show)(struct seq_file *, struct crypto_alg *);
	int (*report)(struct sk_buff *, struct crypto_alg *);
	void (*free)(struct crypto_instance *);
	unsigned int type;
	unsigned int maskclear;
	unsigned int maskset;
	unsigned int tfmsize;
};

struct rtattr {
	short unsigned int rta_len;
	short unsigned int rta_type;
};

struct cryptomgr_param {
	struct rtattr *tb[34];
	struct {
		struct rtattr attr;
		struct crypto_attr_type data;
	} type;
	struct {
		struct rtattr attr;
		struct crypto_attr_alg data;
	} attrs[32];
	char template[128];
	struct crypto_larval *larval;
	u32 otype;
	u32 omask;
};

struct csi2_resources_walk_data {
	acpi_handle handle;
	struct list_head connections;
};

struct css_set {
	struct cgroup_subsys_state *subsys[15];
	refcount_t refcount;
	struct css_set *dom_cset;
	struct cgroup *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[15];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_src_preload_node;
	struct list_head mg_dst_preload_node;
	struct list_head mg_node;
	struct cgroup *mg_src_cgrp;
	struct cgroup *mg_dst_cgrp;
	struct css_set *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

struct css_set__safe_rcu {
	struct cgroup *dfl_cgrp;
};

struct cstate {
	int state;
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
};

struct cstate_entry {
	struct {
		unsigned int eax;
		unsigned int ecx;
	} states[8];
};

struct cstate_model {
	long unsigned int core_events;
	long unsigned int pkg_events;
	long unsigned int module_events;
	long unsigned int quirks;
};

struct csum_pseudo_header {
	__be64 data_seq;
	__be32 subflow_seq;
	__be16 data_len;
	__sum16 csum;
};

struct csum_state {
	__wsum csum;
	size_t off;
};

struct ct_data_s {
	union {
		ush freq;
		ush code;
	} fc;
	union {
		ush dad;
		ush len;
	} dl;
};

typedef struct ct_data_s ct_data;

struct ct_expect_iter_state {
	struct seq_net_private p;
	unsigned int bucket;
};

struct ct_incoming_msg {
	struct list_head link;
	u32 size;
	u32 msg[0];
};

struct ct_iter_state {
	struct seq_net_private p;
	struct hlist_nulls_head *hash;
	unsigned int htable_size;
	unsigned int bucket;
	u_int64_t time_now;
};

struct ct_request {
	struct list_head link;
	u32 fence;
	u32 status;
	u32 response_len;
	u32 *response_buf;
};

struct ctl_table_root;

struct ctl_table_set;

struct ctl_dir;

struct ctl_node;

struct ctl_table_header {
	union {
		struct {
			const struct ctl_table *ctl_table;
			int ctl_table_size;
			int used;
			int count;
			int nreg;
		};
		struct callback_head rcu;
	};
	struct completion *unregistering;
	const struct ctl_table *ctl_table_arg;
	struct ctl_table_root *root;
	struct ctl_table_set *set;
	struct ctl_dir *parent;
	struct ctl_node *node;
	struct hlist_head inodes;
	enum {
		SYSCTL_TABLE_TYPE_DEFAULT = 0,
		SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY = 1,
	} type;
};

struct ctl_dir {
	struct ctl_table_header header;
	struct rb_root root;
};

struct ctl_node {
	struct rb_node node;
	struct ctl_table_header *header;
};

typedef int proc_handler(const struct ctl_table *, int, void *, size_t *, loff_t *);

struct ctl_table_poll;

struct ctl_table {
	const char *procname;
	void *data;
	int maxlen;
	umode_t mode;
	proc_handler *proc_handler;
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};

struct ctl_table_poll {
	atomic_t event;
	wait_queue_head_t wait;
};

struct ctl_table_set {
	int (*is_seen)(struct ctl_table_set *);
	struct ctl_dir dir;
};

struct ctl_table_root {
	struct ctl_table_set default_set;
	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
	void (*set_ownership)(struct ctl_table_header *, kuid_t *, kgid_t *);
	int (*permissions)(struct ctl_table_header *, const struct ctl_table *);
};

union nf_inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

union nf_conntrack_man_proto {
	__be16 all;
	struct {
		__be16 port;
	} tcp;
	struct {
		__be16 port;
	} udp;
	struct {
		__be16 id;
	} icmp;
	struct {
		__be16 port;
	} dccp;
	struct {
		__be16 port;
	} sctp;
	struct {
		__be16 key;
	} gre;
};

struct nf_conntrack_man {
	union nf_inet_addr u3;
	union nf_conntrack_man_proto u;
	u_int16_t l3num;
};

struct nf_conntrack_tuple {
	struct nf_conntrack_man src;
	struct {
		union nf_inet_addr u3;
		union {
			__be16 all;
			struct {
				__be16 port;
			} tcp;
			struct {
				__be16 port;
			} udp;
			struct {
				u_int8_t type;
				u_int8_t code;
			} icmp;
			struct {
				__be16 port;
			} dccp;
			struct {
				__be16 port;
			} sctp;
			struct {
				__be16 key;
			} gre;
		} u;
		u_int8_t protonum;
		struct {} __nfct_hash_offsetend;
		u_int8_t dir;
	} dst;
};

struct nf_conntrack_zone {
	u16 id;
	u8 flags;
	u8 dir;
};

struct ctnetlink_filter_u32 {
	u32 val;
	u32 mask;
};

struct ctnetlink_filter {
	u8 family;
	bool zone_filter;
	u_int32_t orig_flags;
	u_int32_t reply_flags;
	struct nf_conntrack_tuple orig;
	struct nf_conntrack_tuple reply;
	struct nf_conntrack_zone zone;
	struct ctnetlink_filter_u32 mark;
	struct ctnetlink_filter_u32 status;
};

struct nf_conn;

struct ctnetlink_list_dump_ctx {
	struct nf_conn *last;
	unsigned int cpu;
	bool done;
};

struct nf_conntrack_l4proto;

struct nf_ct_timeout {
	__u16 l3num;
	const struct nf_conntrack_l4proto *l4proto;
	char data[0];
};

struct ctnl_timeout {
	struct list_head head;
	struct list_head free_head;
	struct callback_head callback_head;
	refcount_t refcnt;
	char name[32];
	struct nf_ct_timeout timeout;
};

struct netlink_policy_dump_state;

struct genl_family;

struct genl_op_iter;

struct ctrl_dump_policy_ctx {
	struct netlink_policy_dump_state *state;
	const struct genl_family *rt;
	struct genl_op_iter *op_iter;
	u32 op;
	u16 fam_id;
	u8 dump_map: 1;
	u8 single_op: 1;
};

struct ctx_rq_wait {
	struct completion comp;
	atomic_t count;
};

struct ctx_switch_entry {
	struct trace_entry ent;
	unsigned int prev_pid;
	unsigned int next_pid;
	unsigned int next_cpu;
	unsigned char prev_prio;
	unsigned char prev_state;
	unsigned char next_prio;
	unsigned char next_state;
};

struct fuse_conn;

struct fuse_mount {
	struct fuse_conn *fc;
	struct super_block *sb;
	struct list_head fc_entry;
	struct callback_head rcu;
};

struct fuse_forget_one {
	uint64_t nodeid;
	uint64_t nlookup;
};

struct fuse_forget_link {
	struct fuse_forget_one forget_one;
	struct fuse_forget_link *next;
};

struct fasync_struct;

struct fuse_iqueue_ops;

struct fuse_iqueue {
	unsigned int connected;
	spinlock_t lock;
	wait_queue_head_t waitq;
	u64 reqctr;
	struct list_head pending;
	struct list_head interrupts;
	struct fuse_forget_link forget_list_head;
	struct fuse_forget_link *forget_list_tail;
	int forget_batch;
	struct fasync_struct *fasync;
	const struct fuse_iqueue_ops *ops;
	void *priv;
};

struct fuse_sync_bucket;

struct fuse_ring;

struct fuse_conn {
	spinlock_t lock;
	refcount_t count;
	atomic_t dev_count;
	struct callback_head rcu;
	kuid_t user_id;
	kgid_t group_id;
	struct pid_namespace *pid_ns;
	struct user_namespace *user_ns;
	unsigned int max_read;
	unsigned int max_write;
	unsigned int max_pages;
	unsigned int max_pages_limit;
	struct fuse_iqueue iq;
	atomic64_t khctr;
	struct rb_root polled_files;
	unsigned int max_background;
	unsigned int congestion_threshold;
	unsigned int num_background;
	unsigned int active_background;
	struct list_head bg_queue;
	spinlock_t bg_lock;
	int initialized;
	int blocked;
	wait_queue_head_t blocked_waitq;
	unsigned int connected;
	bool aborted;
	unsigned int conn_error: 1;
	unsigned int conn_init: 1;
	unsigned int async_read: 1;
	unsigned int abort_err: 1;
	unsigned int atomic_o_trunc: 1;
	unsigned int export_support: 1;
	unsigned int writeback_cache: 1;
	unsigned int parallel_dirops: 1;
	unsigned int handle_killpriv: 1;
	unsigned int cache_symlinks: 1;
	unsigned int legacy_opts_show: 1;
	unsigned int handle_killpriv_v2: 1;
	unsigned int no_open: 1;
	unsigned int no_opendir: 1;
	unsigned int no_fsync: 1;
	unsigned int no_fsyncdir: 1;
	unsigned int no_flush: 1;
	unsigned int no_setxattr: 1;
	unsigned int setxattr_ext: 1;
	unsigned int no_getxattr: 1;
	unsigned int no_listxattr: 1;
	unsigned int no_removexattr: 1;
	unsigned int no_lock: 1;
	unsigned int no_access: 1;
	unsigned int no_create: 1;
	unsigned int no_interrupt: 1;
	unsigned int no_bmap: 1;
	unsigned int no_poll: 1;
	unsigned int big_writes: 1;
	unsigned int dont_mask: 1;
	unsigned int no_flock: 1;
	unsigned int no_fallocate: 1;
	unsigned int no_rename2: 1;
	unsigned int auto_inval_data: 1;
	unsigned int explicit_inval_data: 1;
	unsigned int do_readdirplus: 1;
	unsigned int readdirplus_auto: 1;
	unsigned int async_dio: 1;
	unsigned int no_lseek: 1;
	unsigned int posix_acl: 1;
	unsigned int default_permissions: 1;
	unsigned int allow_other: 1;
	unsigned int no_copy_file_range: 1;
	unsigned int destroy: 1;
	unsigned int delete_stale: 1;
	unsigned int no_control: 1;
	unsigned int no_force_umount: 1;
	unsigned int auto_submounts: 1;
	unsigned int sync_fs: 1;
	unsigned int init_security: 1;
	unsigned int create_supp_group: 1;
	unsigned int inode_dax: 1;
	unsigned int no_tmpfile: 1;
	unsigned int direct_io_allow_mmap: 1;
	unsigned int no_statx: 1;
	unsigned int passthrough: 1;
	unsigned int use_pages_for_kvec_io: 1;
	unsigned int io_uring;
	int max_stack_depth;
	atomic_t num_waiting;
	unsigned int minor;
	struct list_head entry;
	dev_t dev;
	struct dentry *ctl_dentry[5];
	int ctl_ndents;
	u32 scramble_key[4];
	atomic64_t attr_version;
	atomic64_t evict_ctr;
	void (*release)(struct fuse_conn *);
	struct rw_semaphore killsb;
	struct list_head devices;
	struct list_head mounts;
	struct fuse_sync_bucket *curr_bucket;
	struct idr backing_files_map;
	struct fuse_ring *ring;
};

struct cuse_conn {
	struct list_head list;
	struct fuse_mount fm;
	struct fuse_conn fc;
	struct cdev *cdev;
	struct device *dev;
	bool unrestricted_ioctl;
};

struct cuse_devinfo {
	const char *name;
};

struct fuse_in_arg {
	unsigned int size;
	const void *value;
};

struct fuse_arg {
	unsigned int size;
	void *value;
};

struct fuse_args {
	uint64_t nodeid;
	uint32_t opcode;
	uint8_t in_numargs;
	uint8_t out_numargs;
	uint8_t ext_idx;
	bool force: 1;
	bool noreply: 1;
	bool nocreds: 1;
	bool in_pages: 1;
	bool out_pages: 1;
	bool user_pages: 1;
	bool out_argvar: 1;
	bool page_zeroing: 1;
	bool page_replace: 1;
	bool may_block: 1;
	bool is_ext: 1;
	bool is_pinned: 1;
	bool invalidate_vmap: 1;
	struct fuse_in_arg in_args[4];
	struct fuse_arg out_args[2];
	void (*end)(struct fuse_mount *, struct fuse_args *, int);
	void *vmap_base;
};

struct fuse_folio_desc;

struct fuse_args_pages {
	struct fuse_args args;
	struct folio **folios;
	struct fuse_folio_desc *descs;
	unsigned int num_folios;
};

struct cuse_init_in {
	uint32_t major;
	uint32_t minor;
	uint32_t unused;
	uint32_t flags;
};

struct cuse_init_out {
	uint32_t major;
	uint32_t minor;
	uint32_t unused;
	uint32_t flags;
	uint32_t max_read;
	uint32_t max_write;
	uint32_t dev_major;
	uint32_t dev_minor;
	uint32_t spare[10];
};

struct fuse_folio_desc {
	unsigned int length;
	unsigned int offset;
};

struct cuse_init_args {
	struct fuse_args_pages ap;
	struct cuse_init_in in;
	struct cuse_init_out out;
	struct folio *folio;
	struct fuse_folio_desc desc;
};

struct cvt_timing {
	u8 code[3];
};

struct cxsr_latency {
	bool is_desktop: 1;
	bool is_ddr3: 1;
	u16 fsb_freq;
	u16 mem_freq;
	u16 display_sr;
	u16 display_hpll_disable;
	u16 cursor_sr;
	u16 cursor_hpll_disable;
};

struct cyc2ns_data {
	u32 cyc2ns_mul;
	u32 cyc2ns_shift;
	u64 cyc2ns_offset;
};

struct cyc2ns {
	struct cyc2ns_data data[2];
	seqcount_latch_t seq;
};

struct cyclecounter {
	u64 (*read)(const struct cyclecounter *);
	u64 mask;
	u32 mult;
	u32 shift;
};

struct cytp_contact {
	int x;
	int y;
	int z;
};

struct cytp_data {
	int fw_version;
	int pkt_size;
	int mode;
	int tp_min_pressure;
	int tp_max_pressure;
	int tp_width;
	int tp_high;
	int tp_max_abs_x;
	int tp_max_abs_y;
	int tp_res_x;
	int tp_res_y;
	int tp_metrics_supported;
};

struct cytp_report_data {
	int contact_cnt;
	struct cytp_contact contacts[2];
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int tap: 1;
};

struct dahash_test {
	uint16_t start;
	uint16_t length;
	xfs_dahash_t dahash;
	xfs_dahash_t ascii_ci_dahash;
};

struct data_chunk {
	size_t size;
	size_t icg;
	size_t dst_icg;
	size_t src_icg;
};

struct data_reloc_warn {
	struct btrfs_path path;
	struct btrfs_fs_info *fs_info;
	u64 extent_item_size;
	u64 logical;
	int mirror_num;
};

struct llc_sap;

struct datalink_proto {
	unsigned char type[8];
	struct llc_sap *sap;
	short unsigned int header_length;
	int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	int (*request)(struct datalink_proto *, struct sk_buff *, const unsigned char *);
	struct list_head node;
};

struct table_instance;

struct mask_cache;

struct mask_array;

struct flow_table {
	struct table_instance *ti;
	struct table_instance *ufid_ti;
	struct mask_cache *mask_cache;
	struct mask_array *mask_array;
	long unsigned int last_rehash;
	unsigned int count;
	unsigned int ufid_count;
};

struct dp_meter_instance;

struct dp_meter_table {
	struct dp_meter_instance *ti;
	u32 count;
	u32 max_meters_allowed;
};

struct dp_stats_percpu;

struct dp_nlsk_pids;

struct datapath {
	struct callback_head rcu;
	struct list_head list_node;
	struct flow_table table;
	struct hlist_head *ports;
	struct dp_stats_percpu *stats_percpu;
	possible_net_t net;
	u32 user_features;
	u32 max_headroom;
	struct dp_meter_table meter_tbl;
	struct dp_nlsk_pids *upcall_portids;
};

struct dax_device;

struct dax_holder_operations {
	int (*notify_failure)(struct dax_device *, u64, u64, int);
};

struct dax_operations {
	long int (*direct_access)(struct dax_device *, long unsigned int, long int, enum dax_access_mode, void **, pfn_t *);
	int (*zero_page_range)(struct dax_device *, long unsigned int, size_t);
	size_t (*recovery_write)(struct dax_device *, long unsigned int, void *, size_t, struct iov_iter *);
};

struct gov_attr_set {
	struct kobject kobj;
	struct list_head policy_list;
	struct mutex update_lock;
	int usage_count;
};

struct dbs_governor;

struct dbs_data {
	struct gov_attr_set attr_set;
	struct dbs_governor *gov;
	void *tuners;
	unsigned int ignore_nice_load;
	unsigned int sampling_rate;
	unsigned int sampling_down_factor;
	unsigned int up_threshold;
	unsigned int io_is_busy;
};

struct sysfs_ops;

struct kobj_type {
	void (*release)(struct kobject *);
	const struct sysfs_ops *sysfs_ops;
	const struct attribute_group **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(const struct kobject *);
	const void * (*namespace)(const struct kobject *);
	void (*get_ownership)(const struct kobject *, kuid_t *, kgid_t *);
};

struct dbs_governor {
	struct cpufreq_governor gov;
	struct kobj_type kobj_type;
	struct dbs_data *gdbs_data;
	unsigned int (*gov_dbs_update)(struct cpufreq_policy *);
	struct policy_dbs_info * (*alloc)(void);
	void (*free)(struct policy_dbs_info *);
	int (*init)(struct dbs_data *);
	void (*exit)(struct dbs_data *);
	void (*start)(struct cpufreq_policy *);
};

struct dbuf_slice_conf_entry {
	u8 active_pipes;
	u8 dbuf_mask[4];
	bool join_mbus;
};

struct dcb_app {
	__u8 selector;
	__u8 priority;
	__u16 protocol;
};

struct dcb_app_type {
	int ifindex;
	struct dcb_app app;
	struct list_head list;
	u8 dcbx;
};

struct dcb_ieee_app_dscp_map {
	u8 map[64];
};

struct dcb_ieee_app_prio_map {
	u64 map[8];
};

struct dcb_peer_app_info {
	__u8 willing;
	__u8 error;
};

struct dcb_rewr_prio_pcp_map {
	u16 map[8];
};

struct dcbmsg {
	__u8 dcb_family;
	__u8 cmd;
	__u16 dcb_pad;
};

struct dcbnl_buffer {
	__u8 prio2buffer[8];
	__u32 buffer_size[8];
	__u32 total_size;
};

struct ieee_ets;

struct ieee_maxrate;

struct ieee_qcn;

struct ieee_qcn_stats;

struct ieee_pfc;

struct dcbnl_rtnl_ops {
	int (*ieee_getets)(struct net_device *, struct ieee_ets *);
	int (*ieee_setets)(struct net_device *, struct ieee_ets *);
	int (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *);
	int (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *);
	int (*ieee_getqcn)(struct net_device *, struct ieee_qcn *);
	int (*ieee_setqcn)(struct net_device *, struct ieee_qcn *);
	int (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *);
	int (*ieee_getpfc)(struct net_device *, struct ieee_pfc *);
	int (*ieee_setpfc)(struct net_device *, struct ieee_pfc *);
	int (*ieee_getapp)(struct net_device *, struct dcb_app *);
	int (*ieee_setapp)(struct net_device *, struct dcb_app *);
	int (*ieee_delapp)(struct net_device *, struct dcb_app *);
	int (*ieee_peer_getets)(struct net_device *, struct ieee_ets *);
	int (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *);
	u8 (*getstate)(struct net_device *);
	u8 (*setstate)(struct net_device *, u8);
	void (*getpermhwaddr)(struct net_device *, u8 *);
	void (*setpgtccfgtx)(struct net_device *, int, u8, u8, u8, u8);
	void (*setpgbwgcfgtx)(struct net_device *, int, u8);
	void (*setpgtccfgrx)(struct net_device *, int, u8, u8, u8, u8);
	void (*setpgbwgcfgrx)(struct net_device *, int, u8);
	void (*getpgtccfgtx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);
	void (*getpgbwgcfgtx)(struct net_device *, int, u8 *);
	void (*getpgtccfgrx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);
	void (*getpgbwgcfgrx)(struct net_device *, int, u8 *);
	void (*setpfccfg)(struct net_device *, int, u8);
	void (*getpfccfg)(struct net_device *, int, u8 *);
	u8 (*setall)(struct net_device *);
	u8 (*getcap)(struct net_device *, int, u8 *);
	int (*getnumtcs)(struct net_device *, int, u8 *);
	int (*setnumtcs)(struct net_device *, int, u8);
	u8 (*getpfcstate)(struct net_device *);
	void (*setpfcstate)(struct net_device *, u8);
	void (*getbcncfg)(struct net_device *, int, u32 *);
	void (*setbcncfg)(struct net_device *, int, u32);
	void (*getbcnrp)(struct net_device *, int, u8 *);
	void (*setbcnrp)(struct net_device *, int, u8);
	int (*setapp)(struct net_device *, u8, u16, u8);
	int (*getapp)(struct net_device *, u8, u16);
	u8 (*getfeatcfg)(struct net_device *, int, u8 *);
	u8 (*setfeatcfg)(struct net_device *, int, u8);
	u8 (*getdcbx)(struct net_device *);
	u8 (*setdcbx)(struct net_device *, u8);
	int (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *);
	int (*peer_getapptable)(struct net_device *, struct dcb_app *);
	int (*cee_peer_getpg)(struct net_device *, struct cee_pg *);
	int (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *);
	int (*dcbnl_getbuffer)(struct net_device *, struct dcbnl_buffer *);
	int (*dcbnl_setbuffer)(struct net_device *, struct dcbnl_buffer *);
	int (*dcbnl_setapptrust)(struct net_device *, u8 *, int);
	int (*dcbnl_getapptrust)(struct net_device *, u8 *, int *);
	int (*dcbnl_setrewr)(struct net_device *, struct dcb_app *);
	int (*dcbnl_delrewr)(struct net_device *, struct dcb_app *);
};

struct inet_cork {
	unsigned int flags;
	__be32 addr;
	struct ip_options *opt;
	unsigned int fragsize;
	int length;
	struct dst_entry *dst;
	u8 tx_flags;
	__u8 ttl;
	__s16 tos;
	u32 priority;
	__u16 gso_size;
	u32 ts_opt_id;
	u64 transmit_time;
	u32 mark;
};

struct flowi_tunnel {
	__be64 tun_id;
};

struct flowi_common {
	int flowic_oif;
	int flowic_iif;
	int flowic_l3mdev;
	__u32 flowic_mark;
	__u8 flowic_tos;
	__u8 flowic_scope;
	__u8 flowic_proto;
	__u8 flowic_flags;
	__u32 flowic_secid;
	kuid_t flowic_uid;
	__u32 flowic_multipath_hash;
	struct flowi_tunnel flowic_tun_key;
};

union flowi_uli {
	struct {
		__be16 dport;
		__be16 sport;
	} ports;
	struct {
		__u8 type;
		__u8 code;
	} icmpt;
	__be32 gre_key;
	struct {
		__u8 type;
	} mht;
};

struct flowi4 {
	struct flowi_common __fl_common;
	__be32 saddr;
	__be32 daddr;
	union flowi_uli uli;
};

struct flowi6 {
	struct flowi_common __fl_common;
	struct in6_addr daddr;
	struct in6_addr saddr;
	__be32 flowlabel;
	union flowi_uli uli;
	__u32 mp_hash;
};

struct flowi {
	union {
		struct flowi_common __fl_common;
		struct flowi4 ip4;
		struct flowi6 ip6;
	} u;
};

struct inet_cork_full {
	struct inet_cork base;
	struct flowi fl;
};

struct ipv6_pinfo;

struct ip_options_rcu;

struct ip_mc_socklist;

struct inet_sock {
	struct sock sk;
	struct ipv6_pinfo *pinet6;
	long unsigned int inet_flags;
	__be32 inet_saddr;
	__s16 uc_ttl;
	__be16 inet_sport;
	struct ip_options_rcu *inet_opt;
	atomic_t inet_id;
	__u8 tos;
	__u8 min_ttl;
	__u8 mc_ttl;
	__u8 pmtudisc;
	__u8 rcv_tos;
	__u8 convert_csum;
	int uc_index;
	int mc_index;
	__be32 mc_addr;
	u32 local_port_range;
	struct ip_mc_socklist *mc_list;
	struct inet_cork_full cork;
};

struct request_sock;

struct tcp_fastopen_context;

struct fastopen_queue {
	struct request_sock *rskq_rst_head;
	struct request_sock *rskq_rst_tail;
	spinlock_t lock;
	int qlen;
	int max_qlen;
	struct tcp_fastopen_context *ctx;
};

struct request_sock_queue {
	spinlock_t rskq_lock;
	u8 rskq_defer_accept;
	u32 synflood_warned;
	atomic_t qlen;
	atomic_t young;
	struct request_sock *rskq_accept_head;
	struct request_sock *rskq_accept_tail;
	struct fastopen_queue fastopenq;
};

struct inet_bind_bucket;

struct inet_bind2_bucket;

struct inet_connection_sock_af_ops;

struct tcp_ulp_ops;

struct inet_connection_sock {
	struct inet_sock icsk_inet;
	struct request_sock_queue icsk_accept_queue;
	struct inet_bind_bucket *icsk_bind_hash;
	struct inet_bind2_bucket *icsk_bind2_hash;
	long unsigned int icsk_timeout;
	struct timer_list icsk_retransmit_timer;
	struct timer_list icsk_delack_timer;
	__u32 icsk_rto;
	__u32 icsk_rto_min;
	__u32 icsk_delack_max;
	__u32 icsk_pmtu_cookie;
	const struct tcp_congestion_ops *icsk_ca_ops;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	const struct tcp_ulp_ops *icsk_ulp_ops;
	void *icsk_ulp_data;
	void (*icsk_clean_acked)(struct sock *, u32);
	unsigned int (*icsk_sync_mss)(struct sock *, u32);
	__u8 icsk_ca_state: 5;
	__u8 icsk_ca_initialized: 1;
	__u8 icsk_ca_setsockopt: 1;
	__u8 icsk_ca_dst_locked: 1;
	__u8 icsk_retransmits;
	__u8 icsk_pending;
	__u8 icsk_backoff;
	__u8 icsk_syn_retries;
	__u8 icsk_probes_out;
	__u16 icsk_ext_hdr_len;
	struct {
		__u8 pending;
		__u8 quick;
		__u8 pingpong;
		__u8 retry;
		__u32 ato: 8;
		__u32 lrcv_flowlabel: 20;
		__u32 unused: 4;
		long unsigned int timeout;
		__u32 lrcvtime;
		__u16 last_seg_size;
		__u16 rcv_mss;
	} icsk_ack;
	struct {
		int search_high;
		int search_low;
		u32 probe_size: 31;
		u32 enabled: 1;
		u32 probe_timestamp;
	} icsk_mtup;
	u32 icsk_probes_tstamp;
	u32 icsk_user_timeout;
	u64 icsk_ca_priv[13];
};

struct dccp_options_received {
	u64 dccpor_ndp: 48;
	u32 dccpor_timestamp;
	u32 dccpor_timestamp_echo;
	u32 dccpor_elapsed_time;
};

struct tasklet_struct {
	struct tasklet_struct *next;
	long unsigned int state;
	atomic_t count;
	bool use_callback;
	union {
		void (*func)(long unsigned int);
		void (*callback)(struct tasklet_struct *);
	};
	long unsigned int data;
};

struct dccp_service_list;

struct dccp_ackvec;

struct dccp_sock {
	struct inet_connection_sock dccps_inet_connection;
	__u64 dccps_swl;
	__u64 dccps_swh;
	__u64 dccps_awl;
	__u64 dccps_awh;
	__u64 dccps_iss;
	__u64 dccps_isr;
	__u64 dccps_osr;
	__u64 dccps_gss;
	__u64 dccps_gsr;
	__u64 dccps_gar;
	__be32 dccps_service;
	__u32 dccps_mss_cache;
	struct dccp_service_list *dccps_service_list;
	__u32 dccps_timestamp_echo;
	__u32 dccps_timestamp_time;
	__u16 dccps_l_ack_ratio;
	__u16 dccps_r_ack_ratio;
	__u64 dccps_l_seq_win: 48;
	long: 16;
	__u64 dccps_r_seq_win: 48;
	__u8 dccps_pcslen: 4;
	__u8 dccps_pcrlen: 4;
	__u8 dccps_send_ndp_count: 1;
	long: 7;
	__u64 dccps_ndp_count: 48;
	long unsigned int dccps_rate_last;
	struct list_head dccps_featneg;
	struct dccp_ackvec *dccps_hc_rx_ackvec;
	struct ccid *dccps_hc_rx_ccid;
	struct ccid *dccps_hc_tx_ccid;
	struct dccp_options_received dccps_options_received;
	__u8 dccps_qpolicy;
	__u32 dccps_tx_qlen;
	enum dccp_role dccps_role: 2;
	__u8 dccps_hc_rx_insert_options: 1;
	__u8 dccps_hc_tx_insert_options: 1;
	__u8 dccps_server_timewait: 1;
	__u8 dccps_sync_scheduled: 1;
	struct tasklet_struct dccps_xmitlet;
	struct timer_list dccps_xmit_timer;
};

struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	int ipi6_ifindex;
};

struct ipv6_txoptions;

struct inet6_cork {
	struct ipv6_txoptions *opt;
	u8 hop_limit;
	u8 tclass;
};

struct ipv6_mc_socklist;

struct ipv6_ac_socklist;

struct ipv6_fl_socklist;

struct ipv6_pinfo {
	struct in6_addr saddr;
	struct in6_pktinfo sticky_pktinfo;
	const struct in6_addr *daddr_cache;
	const struct in6_addr *saddr_cache;
	__be32 flow_label;
	__u32 frag_size;
	s16 hop_limit;
	u8 mcast_hops;
	int ucast_oif;
	int mcast_oif;
	union {
		struct {
			__u16 srcrt: 1;
			__u16 osrcrt: 1;
			__u16 rxinfo: 1;
			__u16 rxoinfo: 1;
			__u16 rxhlim: 1;
			__u16 rxohlim: 1;
			__u16 hopopts: 1;
			__u16 ohopopts: 1;
			__u16 dstopts: 1;
			__u16 odstopts: 1;
			__u16 rxflow: 1;
			__u16 rxtclass: 1;
			__u16 rxpmtu: 1;
			__u16 rxorigdstaddr: 1;
			__u16 recvfragsize: 1;
		} bits;
		__u16 all;
	} rxopt;
	__u8 srcprefs;
	__u8 pmtudisc;
	__u8 min_hopcount;
	__u8 tclass;
	__be32 rcv_flowinfo;
	__u32 dst_cookie;
	struct ipv6_mc_socklist *ipv6_mc_list;
	struct ipv6_ac_socklist *ipv6_ac_list;
	struct ipv6_fl_socklist *ipv6_fl_list;
	struct ipv6_txoptions *opt;
	struct sk_buff *pktoptions;
	struct sk_buff *rxpmtu;
	struct inet6_cork cork;
};

struct dccp6_sock {
	struct dccp_sock dccp;
	struct ipv6_pinfo inet6;
};

struct dccp_ackvec {
	u8 av_buf[506];
	u16 av_buf_head;
	u16 av_buf_tail;
	u64 av_buf_ackno: 48;
	long: 16;
	u64 av_tail_ackno: 48;
	bool av_buf_nonce[2];
	u8 av_overflow: 1;
	struct list_head av_records;
};

struct dccp_ackvec_parsed {
	u8 *vec;
	u8 len;
	u8 nonce: 1;
	struct list_head node;
};

struct dccp_ackvec_record {
	struct list_head avr_node;
	u64 avr_ack_seqno: 48;
	long: 16;
	u64 avr_ack_ackno: 48;
	u16 avr_ack_ptr;
	u8 avr_ack_runlen;
	u8 avr_ack_nonce: 1;
};

struct dccp_feat_entry {
	dccp_feat_val val;
	enum dccp_feat_state state: 8;
	u8 feat_num;
	bool needs_mandatory;
	bool needs_confirm;
	bool empty_confirm;
	bool is_local;
	struct list_head node;
};

struct dccp_hdr {
	__be16 dccph_sport;
	__be16 dccph_dport;
	__u8 dccph_doff;
	__u8 dccph_cscov: 4;
	__u8 dccph_ccval: 4;
	__sum16 dccph_checksum;
	__u8 dccph_x: 1;
	__u8 dccph_type: 4;
	__u8 dccph_reserved: 3;
	__u8 dccph_seq2;
	__be16 dccph_seq;
};

struct dccp_hdr_ack_bits {
	__be16 dccph_reserved1;
	__be16 dccph_ack_nr_high;
	__be32 dccph_ack_nr_low;
};

struct dccp_hdr_ext {
	__be32 dccph_seq_low;
};

struct dccp_hdr_request {
	__be32 dccph_req_service;
};

struct dccp_hdr_reset {
	struct dccp_hdr_ack_bits dccph_reset_ack;
	__u8 dccph_reset_code;
	__u8 dccph_reset_data[3];
};

struct dccp_hdr_response {
	struct dccp_hdr_ack_bits dccph_resp_ack;
	__be32 dccph_resp_service;
};

struct dccp_mib {
	long unsigned int mibs[15];
};

struct dccp_qpolicy_operations {
	void (*push)(struct sock *, struct sk_buff *);
	bool (*full)(struct sock *);
	struct sk_buff * (*top)(struct sock *);
	__be32 params;
};

struct request_sock_ops;

struct saved_syn;

struct request_sock {
	struct sock_common __req_common;
	struct request_sock *dl_next;
	u16 mss;
	u8 num_retrans;
	u8 syncookie: 1;
	u8 num_timeout: 7;
	u32 ts_recent;
	struct timer_list rsk_timer;
	const struct request_sock_ops *rsk_ops;
	struct sock *sk;
	struct saved_syn *saved_syn;
	u32 secid;
	u32 peer_secid;
	u32 timeout;
};

struct inet_request_sock {
	struct request_sock req;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u16 tstamp_ok: 1;
	u16 sack_ok: 1;
	u16 wscale_ok: 1;
	u16 ecn_ok: 1;
	u16 acked: 1;
	u16 no_srccheck: 1;
	u16 smc_ok: 1;
	u32 ir_mark;
	union {
		struct ip_options_rcu *ireq_opt;
		struct {
			struct ipv6_txoptions *ipv6_opt;
			struct sk_buff *pktopts;
		};
	};
};

struct dccp_request_sock {
	struct inet_request_sock dreq_inet_rsk;
	__u64 dreq_iss;
	__u64 dreq_gss;
	__u64 dreq_isr;
	__u64 dreq_gsr;
	__be32 dreq_service;
	spinlock_t dreq_lock;
	struct list_head dreq_featneg;
	__u32 dreq_timestamp_echo;
	__u32 dreq_timestamp_time;
};

struct dccp_service_list {
	__u32 dccpsl_nr;
	__be32 dccpsl_list[0];
};

struct dccp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u8 dccpd_type: 4;
	__u8 dccpd_ccval: 4;
	__u8 dccpd_reset_code;
	__u8 dccpd_reset_data[3];
	__u16 dccpd_opt_len;
	__u64 dccpd_seq;
	__u64 dccpd_ack_seq;
};

struct dccp_v4_pernet {
	struct sock *v4_ctl_sk;
};

struct dccp_v6_pernet {
	struct sock *v6_ctl_sk;
};

struct tcp_plb_state {
	u8 consec_cong_rounds: 5;
	u8 unused: 3;
	u32 pause_until;
};

struct dctcp {
	u32 old_delivered;
	u32 old_delivered_ce;
	u32 prior_rcv_nxt;
	u32 dctcp_alpha;
	u32 next_seq;
	u32 ce_state;
	u32 loss_cwnd;
	struct tcp_plb_state plb;
};

struct io_stats_per_prio {
	uint32_t inserted;
	uint32_t merged;
	uint32_t dispatched;
	atomic_t completed;
};

struct dd_per_prio {
	struct list_head dispatch;
	struct rb_root sort_list[2];
	struct list_head fifo_list[2];
	sector_t latest_pos[2];
	struct io_stats_per_prio stats;
};

struct ddebug_class_map {
	struct list_head link;
	struct module *mod;
	const char *mod_name;
	const char **class_names;
	const int length;
	const int base;
	enum class_map_type map_type;
};

struct ddpehdr {
	__be16 deh_len_hops;
	__be16 deh_sum;
	__be16 deh_dnet;
	__be16 deh_snet;
	__u8 deh_dnode;
	__u8 deh_snode;
	__u8 deh_dport;
	__u8 deh_sport;
};

struct deadline_data {
	struct dd_per_prio per_prio[3];
	enum dd_data_dir last_dir;
	unsigned int batching;
	unsigned int starved;
	int fifo_expire[2];
	int fifo_batch;
	int writes_starved;
	int front_merges;
	u32 async_depth;
	int prio_aging_expire;
	spinlock_t lock;
};

struct debug_reply_data {
	struct ethnl_reply_data base;
	u32 msg_mask;
};

struct debugfs_blob_wrapper {
	void *data;
	long unsigned int size;
};

struct debugfs_cancellation {
	struct list_head list;
	void (*cancel)(struct dentry *, void *);
	void *cancel_data;
};

struct debugfs_devm_entry {
	int (*read)(struct seq_file *, void *);
	struct device *dev;
};

struct debugfs_fs_info {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	unsigned int opts;
};

struct debugfs_short_fops;

struct debugfs_fsdata {
	const struct file_operations *real_fops;
	const struct debugfs_short_fops *short_fops;
	struct {
		refcount_t active_users;
		struct completion active_users_drained;
		struct mutex cancellations_mtx;
		struct list_head cancellations;
		unsigned int methods;
	};
};

typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);

struct debugfs_inode_info {
	struct inode vfs_inode;
	union {
		const void *raw;
		const struct file_operations *real_fops;
		const struct debugfs_short_fops *short_fops;
		debugfs_automount_t automount;
	};
	const void *aux;
};

struct debugfs_reg32 {
	char *name;
	long unsigned int offset;
};

struct debugfs_regset32 {
	const struct debugfs_reg32 *regs;
	int nregs;
	void *base;
	struct device *dev;
};

struct debugfs_short_fops {
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	loff_t (*llseek)(struct file *, loff_t, int);
};

struct debugfs_u32_array {
	u32 *array;
	u32 n_elements;
};

struct dec_data {
	struct task_struct *thr;
	struct crypto_comp *cc;
	atomic_t ready;
	atomic_t stop;
	int ret;
	wait_queue_head_t go;
	wait_queue_head_t done;
	size_t unc_len;
	size_t cmp_len;
	unsigned char unc[131072];
	unsigned char cmp[143360];
};

struct decryptor_desc {
	u8 iv[16];
	struct skcipher_request *req;
	struct scatterlist frags[4];
	int fragno;
	int fraglen;
};

struct default_wait_cb {
	struct dma_fence_cb base;
	struct task_struct *task;
};

struct internal_state;

struct z_stream_s {
	const Byte *next_in;
	uLong avail_in;
	uLong total_in;
	Byte *next_out;
	uLong avail_out;
	uLong total_out;
	char *msg;
	struct internal_state *state;
	void *workspace;
	int data_type;
	uLong adler;
	uLong reserved;
};

struct deflate_ctx {
	struct z_stream_s comp_stream;
	struct z_stream_s decomp_stream;
};

typedef struct z_stream_s z_stream;

typedef z_stream *z_streamp;

struct static_tree_desc_s;

typedef struct static_tree_desc_s static_tree_desc;

struct tree_desc_s {
	ct_data *dyn_tree;
	int max_code;
	static_tree_desc *stat_desc;
};

struct deflate_state {
	z_streamp strm;
	int status;
	Byte *pending_buf;
	ulg pending_buf_size;
	Byte *pending_out;
	int pending;
	int noheader;
	Byte data_type;
	Byte method;
	int last_flush;
	uInt w_size;
	uInt w_bits;
	uInt w_mask;
	Byte *window;
	ulg window_size;
	Pos *prev;
	Pos *head;
	uInt ins_h;
	uInt hash_size;
	uInt hash_bits;
	uInt hash_mask;
	uInt hash_shift;
	long int block_start;
	uInt match_length;
	IPos prev_match;
	int match_available;
	uInt strstart;
	uInt match_start;
	uInt lookahead;
	uInt prev_length;
	uInt max_chain_length;
	uInt max_lazy_match;
	int level;
	int strategy;
	uInt good_match;
	int nice_match;
	struct ct_data_s dyn_ltree[573];
	struct ct_data_s dyn_dtree[61];
	struct ct_data_s bl_tree[39];
	struct tree_desc_s l_desc;
	struct tree_desc_s d_desc;
	struct tree_desc_s bl_desc;
	ush bl_count[16];
	int heap[573];
	int heap_len;
	int heap_max;
	uch depth[573];
	uch *l_buf;
	uInt lit_bufsize;
	uInt last_lit;
	ush *d_buf;
	ulg opt_len;
	ulg static_len;
	ulg compressed_len;
	uInt matches;
	int last_eob_len;
	ush bi_buf;
	int bi_valid;
};

struct deflate_workspace {
	deflate_state deflate_memory;
	Byte *window_memory;
	Pos *prev_memory;
	Pos *head_memory;
	char *overlay_memory;
};

typedef struct deflate_workspace deflate_workspace;

struct defrag_target_range {
	struct list_head list;
	u64 start;
	u64 len;
};

struct delayed_call {
	void (*fn)(void *);
	void *arg;
};

struct delayed_uprobe {
	struct list_head list;
	struct uprobe *uprobe;
	struct mm_struct *mm;
};

struct demotion_nodes {
	nodemask_t preferred;
};

struct hlist_bl_node {
	struct hlist_bl_node *next;
	struct hlist_bl_node **pprev;
};

union shortname_store {
	unsigned char string[40];
	long unsigned int words[5];
};

struct lockref {
	union {
		__u64 lock_count;
		struct {
			spinlock_t lock;
			int count;
		};
	};
};

struct dentry_operations;

struct dentry {
	unsigned int d_flags;
	seqcount_spinlock_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry *d_parent;
	struct qstr d_name;
	struct inode *d_inode;
	union shortname_store d_shortname;
	const struct dentry_operations *d_op;
	struct super_block *d_sb;
	long unsigned int d_time;
	void *d_fsdata;
	struct lockref d_lockref;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct hlist_node d_sib;
	struct hlist_head d_children;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
};

struct dentry__safe_trusted {
	struct inode *d_inode;
};

struct dentry_info_args {
	int parent_ino;
	int dname_len;
	int ino;
	int inode_len;
	char *dname;
};

struct dentry_operations {
	int (*d_revalidate)(struct inode *, const struct qstr *, struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char * (*d_dname)(struct dentry *, char *, int);
	struct vfsmount * (*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry * (*d_real)(struct dentry *, enum d_real_type);
	bool (*d_unalias_trylock)(const struct dentry *);
	void (*d_unalias_unlock)(const struct dentry *);
	long: 64;
};

struct dentry_stat_t {
	long int nr_dentry;
	long int nr_unused;
	long int age_limit;
	long int want_pages;
	long int nr_negative;
	long int dummy;
};

struct des3_ede_ctx {
	u32 expkey[96];
};

struct des_ctx {
	u32 expkey[32];
};

struct desc_ptr {
	short unsigned int size;
	long unsigned int address;
} __attribute__((packed));

struct desc_struct {
	u16 limit0;
	u16 base0;
	u16 base1: 8;
	u16 type: 4;
	u16 s: 1;
	u16 dpl: 2;
	u16 p: 1;
	u16 limit1: 4;
	u16 avl: 1;
	u16 l: 1;
	u16 d: 1;
	u16 g: 1;
	u16 base2: 8;
};

struct slab;

struct detached_freelist {
	struct slab *slab;
	void *tail;
	void *freelist;
	int cnt;
	struct kmem_cache *s;
};

struct detailed_data_monitor_range {
	u8 min_vfreq;
	u8 max_vfreq;
	u8 min_hfreq_khz;
	u8 max_hfreq_khz;
	u8 pixel_clock_mhz;
	u8 flags;
	union {
		struct {
			u8 reserved;
			u8 hfreq_start_khz;
			u8 c;
			__le16 m;
			u8 k;
			u8 j;
		} __attribute__((packed)) gtf2;
		struct {
			u8 version;
			u8 data1;
			u8 data2;
			u8 supported_aspects;
			u8 flags;
			u8 supported_scalings;
			u8 preferred_refresh;
		} cvt;
	} formula;
};

struct detailed_data_string {
	u8 str[13];
};

struct detailed_data_wpindex {
	u8 white_yx_lo;
	u8 white_x_hi;
	u8 white_y_hi;
	u8 gamma;
};

struct detailed_mode_closure {
	struct drm_connector *connector;
	const struct drm_edid *drm_edid;
	bool preferred;
	int modes;
};

struct std_timing {
	u8 hsize;
	u8 vfreq_aspect;
};

struct detailed_non_pixel {
	u8 pad1;
	u8 type;
	u8 pad2;
	union {
		struct detailed_data_string str;
		struct detailed_data_monitor_range range;
		struct detailed_data_wpindex color;
		struct std_timing timings[6];
		struct cvt_timing cvt[4];
	} data;
};

struct detailed_pixel_timing {
	u8 hactive_lo;
	u8 hblank_lo;
	u8 hactive_hblank_hi;
	u8 vactive_lo;
	u8 vblank_lo;
	u8 vactive_vblank_hi;
	u8 hsync_offset_lo;
	u8 hsync_pulse_width_lo;
	u8 vsync_offset_pulse_width_lo;
	u8 hsync_vsync_offset_pulse_width_hi;
	u8 width_mm_lo;
	u8 height_mm_lo;
	u8 width_height_mm_hi;
	u8 hborder;
	u8 vborder;
	u8 misc;
};

struct detailed_timing {
	__le16 pixel_clock;
	union {
		struct detailed_pixel_timing pixel_data;
		struct detailed_non_pixel other_data;
	} data;
};

struct detected_devices_node {
	struct list_head list;
	dev_t dev;
};

struct dev_cgroup {
	struct cgroup_subsys_state css;
	struct list_head exceptions;
	enum devcg_behavior behavior;
};

struct dev_exception_item {
	u32 major;
	u32 minor;
	short int type;
	short int access;
	struct list_head list;
	struct callback_head rcu;
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

struct dev_ifalias {
	struct callback_head rcuhead;
	char ifalias[0];
};

struct iommu_fault_param;

struct iommu_fwspec;

struct dev_iommu {
	struct mutex lock;
	struct iommu_fault_param *fault_param;
	struct iommu_fwspec *fwspec;
	struct iommu_device *iommu_dev;
	void *priv;
	u32 max_pasids;
	u32 attach_deferred: 1;
	u32 pci_32bit_workaround: 1;
	u32 require_direct: 1;
	u32 shadow_on_flush: 1;
};

struct dev_kfree_skb_cb {
	enum skb_drop_reason reason;
};

struct vmem_altmap {
	long unsigned int base_pfn;
	const long unsigned int end_pfn;
	const long unsigned int reserve;
	long unsigned int free;
	long unsigned int align;
	long unsigned int alloc;
	bool inaccessible;
};

struct dev_pagemap_ops;

struct dev_pagemap {
	struct vmem_altmap altmap;
	struct percpu_ref ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	long unsigned int vmemmap_shift;
	const struct dev_pagemap_ops *ops;
	void *owner;
	int nr_range;
	union {
		struct range range;
		struct {
			struct {} __empty_ranges;
			struct range ranges[0];
		};
	};
};

struct vm_fault;

struct dev_pagemap_ops {
	void (*page_free)(struct page *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
	int (*memory_failure)(struct dev_pagemap *, long unsigned int, long unsigned int, int);
};

struct dev_pasid_info {
	struct list_head link_domain;
	struct device *dev;
	ioasid_t pasid;
};

struct dev_pm_ops {
	int (*prepare)(struct device *);
	void (*complete)(struct device *);
	int (*suspend)(struct device *);
	int (*resume)(struct device *);
	int (*freeze)(struct device *);
	int (*thaw)(struct device *);
	int (*poweroff)(struct device *);
	int (*restore)(struct device *);
	int (*suspend_late)(struct device *);
	int (*resume_early)(struct device *);
	int (*freeze_late)(struct device *);
	int (*thaw_early)(struct device *);
	int (*poweroff_late)(struct device *);
	int (*restore_early)(struct device *);
	int (*suspend_noirq)(struct device *);
	int (*resume_noirq)(struct device *);
	int (*freeze_noirq)(struct device *);
	int (*thaw_noirq)(struct device *);
	int (*poweroff_noirq)(struct device *);
	int (*restore_noirq)(struct device *);
	int (*runtime_suspend)(struct device *);
	int (*runtime_resume)(struct device *);
	int (*runtime_idle)(struct device *);
};

struct dev_pm_domain {
	struct dev_pm_ops ops;
	int (*start)(struct device *);
	void (*detach)(struct device *, bool);
	int (*activate)(struct device *);
	void (*sync)(struct device *);
	void (*dismiss)(struct device *);
	int (*set_performance_state)(struct device *, unsigned int);
};

struct dev_pm_domain_attach_data {
	const char * const *pd_names;
	const u32 num_pd_names;
	const u32 pd_flags;
};

struct device_link;

struct dev_pm_domain_list {
	struct device **pd_devs;
	struct device_link **pd_links;
	u32 *opp_tokens;
	u32 num_pds;
};

struct opp_table;

struct dev_pm_opp;

typedef int (*config_clks_t)(struct device *, struct opp_table *, struct dev_pm_opp *, void *, bool);

struct regulator;

typedef int (*config_regulators_t)(struct device *, struct dev_pm_opp *, struct dev_pm_opp *, struct regulator **, unsigned int);

struct dev_pm_opp_config {
	const char * const *clk_names;
	config_clks_t config_clks;
	const char *prop_name;
	config_regulators_t config_regulators;
	const unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char * const *regulator_names;
	struct device *required_dev;
	unsigned int required_dev_index;
};

struct pm_qos_flags {
	struct list_head list;
	s32 effective_flags;
};

struct dev_pm_qos_request;

struct dev_pm_qos {
	struct pm_qos_constraints resume_latency;
	struct pm_qos_constraints latency_tolerance;
	struct freq_constraints freq;
	struct pm_qos_flags flags;
	struct dev_pm_qos_request *resume_latency_req;
	struct dev_pm_qos_request *latency_tolerance_req;
	struct dev_pm_qos_request *flags_req;
};

struct pm_qos_flags_request {
	struct list_head node;
	s32 flags;
};

struct dev_pm_qos_request {
	enum dev_pm_qos_req_type type;
	union {
		struct plist_node pnode;
		struct pm_qos_flags_request flr;
		struct freq_qos_request freq;
	} data;
	struct device *dev;
};

struct dev_printk_info {
	char subsystem[16];
	char device[48];
};

struct dev_table_entry {
	union {
		u64 data[4];
		u128 data128[2];
	};
};

struct device_attach_data {
	struct device *dev;
	bool check_async;
	bool want_async;
	bool have_async;
};

union device_attr_group_devres {
	const struct attribute_group *group;
	const struct attribute_group **groups;
};

struct device_dma_parameters {
	unsigned int max_segment_size;
	unsigned int min_align_mask;
	long unsigned int segment_boundary_mask;
};

struct dmar_domain;

struct pasid_table;

struct device_domain_info {
	struct list_head link;
	u32 segment;
	u8 bus;
	u8 devfn;
	u16 pfsid;
	u8 pasid_supported: 3;
	u8 pasid_enabled: 1;
	u8 pri_supported: 1;
	u8 pri_enabled: 1;
	u8 ats_supported: 1;
	u8 ats_enabled: 1;
	u8 dtlb_extra_inval: 1;
	u8 ats_qdep;
	struct device *dev;
	struct intel_iommu *iommu;
	struct dmar_domain *domain;
	struct pasid_table *pasid_table;
	struct rb_node node;
};

struct device_link {
	struct device *supplier;
	struct list_head s_node;
	struct device *consumer;
	struct list_head c_node;
	struct device link_dev;
	enum device_link_state status;
	u32 flags;
	refcount_t rpm_active;
	struct kref kref;
	struct work_struct rm_work;
	bool supplier_preactivated;
};

struct property;

struct device_node {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node *parent;
	struct device_node *child;
	struct device_node *sibling;
	long unsigned int _flags;
	void *data;
};

struct device_physical_location {
	enum device_physical_location_panel panel;
	enum device_physical_location_vertical_position vertical_position;
	enum device_physical_location_horizontal_position horizontal_position;
	bool dock;
	bool lid;
};

struct klist_node {
	void *n_klist;
	struct list_head n_node;
	struct kref n_ref;
};

struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	struct klist_node knode_class;
	struct list_head deferred_probe;
	const struct device_driver *async_driver;
	char *deferred_probe_reason;
	struct device *device;
	u8 dead: 1;
};

struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(const struct device *, struct kobj_uevent_env *);
	char * (*devnode)(const struct device *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device *);
	const struct dev_pm_ops *pm;
};

struct devid_map {
	struct list_head list;
	u8 id;
	u32 devid;
	bool cmd_line;
};

struct devinet_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table devinet_vars[33];
};

struct ratelimit_state {
	raw_spinlock_t lock;
	int interval;
	int burst;
	int printed;
	int missed;
	unsigned int flags;
	long unsigned int begin;
};

struct printk_buffers {
	char outbuf[2048];
	char scratchbuf[1024];
};

struct devkmsg_user {
	atomic64_t seq;
	struct ratelimit_state rs;
	struct mutex lock;
	struct printk_buffers pbufs;
};

struct devlink;

struct netdev_phys_item_id {
	unsigned char id[32];
	unsigned char id_len;
};

struct devlink_port_phys_attrs {
	u32 port_number;
	u32 split_subport_number;
};

struct devlink_port_pci_pf_attrs {
	u32 controller;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_pci_vf_attrs {
	u32 controller;
	u16 pf;
	u16 vf;
	u8 external: 1;
};

struct devlink_port_pci_sf_attrs {
	u32 controller;
	u32 sf;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_attrs {
	u8 split: 1;
	u8 splittable: 1;
	u32 lanes;
	enum devlink_port_flavour flavour;
	struct netdev_phys_item_id switch_id;
	union {
		struct devlink_port_phys_attrs phys;
		struct devlink_port_pci_pf_attrs pci_pf;
		struct devlink_port_pci_vf_attrs pci_vf;
		struct devlink_port_pci_sf_attrs pci_sf;
	};
};

struct devlink_linecard;

struct devlink_port_ops;

struct ib_device;

struct devlink_rate;

struct devlink_port {
	struct list_head list;
	struct list_head region_list;
	struct devlink *devlink;
	const struct devlink_port_ops *ops;
	unsigned int index;
	spinlock_t type_lock;
	enum devlink_port_type type;
	enum devlink_port_type desired_type;
	union {
		struct {
			struct net_device *netdev;
			int ifindex;
			char ifname[16];
		} type_eth;
		struct {
			struct ib_device *ibdev;
		} type_ib;
	};
	struct devlink_port_attrs attrs;
	u8 attrs_set: 1;
	u8 switch_port: 1;
	u8 registered: 1;
	u8 initialized: 1;
	struct delayed_work type_warn_dw;
	struct list_head reporter_list;
	struct devlink_rate *devlink_rate;
	struct devlink_linecard *linecard;
	u32 rel_index;
};

struct devlink_port_ops {
	int (*port_split)(struct devlink *, struct devlink_port *, unsigned int, struct netlink_ext_ack *);
	int (*port_unsplit)(struct devlink *, struct devlink_port *, struct netlink_ext_ack *);
	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
	int (*port_del)(struct devlink *, struct devlink_port *, struct netlink_ext_ack *);
	int (*port_fn_hw_addr_get)(struct devlink_port *, u8 *, int *, struct netlink_ext_ack *);
	int (*port_fn_hw_addr_set)(struct devlink_port *, const u8 *, int, struct netlink_ext_ack *);
	int (*port_fn_roce_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_roce_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_migratable_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_migratable_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_state_get)(struct devlink_port *, enum devlink_port_fn_state *, enum devlink_port_fn_opstate *, struct netlink_ext_ack *);
	int (*port_fn_state_set)(struct devlink_port *, enum devlink_port_fn_state, struct netlink_ext_ack *);
	int (*port_fn_ipsec_crypto_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_ipsec_crypto_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_ipsec_packet_get)(struct devlink_port *, bool *, struct netlink_ext_ack *);
	int (*port_fn_ipsec_packet_set)(struct devlink_port *, bool, struct netlink_ext_ack *);
	int (*port_fn_max_io_eqs_get)(struct devlink_port *, u32 *, struct netlink_ext_ack *);
	int (*port_fn_max_io_eqs_set)(struct devlink_port *, u32, struct netlink_ext_ack *);
};

struct devlink_rate {
	struct list_head list;
	enum devlink_rate_type type;
	struct devlink *devlink;
	void *priv;
	u64 tx_share;
	u64 tx_max;
	struct devlink_rate *parent;
	union {
		struct devlink_port *devlink_port;
		struct {
			char *name;
			refcount_t refcnt;
		};
	};
	u32 tx_priority;
	u32 tx_weight;
};

typedef void (*dr_release_t)(struct device *, void *);

struct devres_node {
	struct list_head entry;
	dr_release_t release;
	const char *name;
	size_t size;
};

struct devres {
	struct devres_node node;
	u8 data[0];
};

struct devres_group {
	struct devres_node node[2];
	void *id;
	int color;
};

union dfixed {
	u32 full;
};

typedef union dfixed fixed20_12;

struct dg2_snps_phy_buf_trans {
	u8 vswing;
	u8 pre_cursor;
	u8 post_cursor;
};

struct dh {
	const void *key;
	const void *p;
	const void *g;
	unsigned int key_size;
	unsigned int p_size;
	unsigned int g_size;
};

struct gcry_mpi;

typedef struct gcry_mpi *MPI;

struct dh_ctx {
	MPI p;
	MPI g;
	MPI xa;
};

struct dh_safe_prime {
	unsigned int max_strength;
	unsigned int p_size;
	const char *p;
};

struct dh_safe_prime_instance_ctx {
	struct crypto_kpp_spawn dh_spawn;
	const struct dh_safe_prime *safe_prime;
};

struct dh_safe_prime_tfm_ctx {
	struct crypto_kpp *dh_tfm;
};

struct dictionary {
	uint8_t *buf;
	size_t start;
	size_t pos;
	size_t full;
	size_t limit;
	size_t end;
	uint32_t size;
	uint32_t size_max;
	uint32_t allocated;
	enum xz_mode mode;
};

struct die_args {
	struct pt_regs *regs;
	const char *str;
	long int err;
	int trapnr;
	int signr;
};

struct dim_stats {
	int ppms;
	int bpms;
	int epms;
	int cpms;
	int cpe_ratio;
};

struct dim_sample {
	ktime_t time;
	u32 pkt_ctr;
	u32 byte_ctr;
	u16 event_ctr;
	u32 comp_ctr;
};

struct dim {
	u8 state;
	struct dim_stats prev_stats;
	struct dim_sample start_sample;
	struct dim_sample measuring_sample;
	struct work_struct work;
	void *priv;
	u8 profile_ix;
	u8 mode;
	u8 tune_state;
	u8 steps_right;
	u8 steps_left;
	u8 tired;
};

struct dim_cq_moder {
	u16 usec;
	u16 pkts;
	u16 comps;
	u8 cq_period_mode;
	struct callback_head rcu;
};

struct dim_irq_moder {
	u8 profile_flags;
	u8 coal_flags;
	u8 dim_rx_mode;
	u8 dim_tx_mode;
	struct dim_cq_moder *rx_profile;
	struct dim_cq_moder *tx_profile;
	void (*rx_dim_work)(struct work_struct *);
	void (*tx_dim_work)(struct work_struct *);
};

typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);

struct dio {
	int flags;
	blk_opf_t opf;
	struct gendisk *bio_disk;
	struct inode *inode;
	loff_t i_size;
	dio_iodone_t *end_io;
	bool is_pinned;
	void *private;
	spinlock_t bio_lock;
	int page_errors;
	int is_async;
	bool defer_completion;
	bool should_dirty;
	int io_error;
	long unsigned int refcount;
	struct bio *bio_list;
	struct task_struct *waiter;
	struct kiocb *iocb;
	ssize_t result;
	union {
		struct page *pages[64];
		struct work_struct complete_work;
	};
	long: 64;
};

typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);

struct dio_submit {
	struct bio *bio;
	unsigned int blkbits;
	unsigned int blkfactor;
	unsigned int start_zero_done;
	int pages_in_io;
	sector_t block_in_file;
	unsigned int blocks_available;
	int reap_counter;
	sector_t final_block_in_request;
	int boundary;
	get_block_t *get_block;
	loff_t logical_offset_in_bio;
	sector_t final_block_in_bio;
	sector_t next_block_for_io;
	struct page *cur_page;
	unsigned int cur_page_offset;
	unsigned int cur_page_len;
	sector_t cur_page_block;
	loff_t cur_page_fs_offset;
	struct iov_iter *iter;
	unsigned int head;
	unsigned int tail;
	size_t from;
	size_t to;
};

struct dioattr {
	__u32 d_mem;
	__u32 d_miniosz;
	__u32 d_maxiosz;
};

struct dir_context;

typedef bool (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);

struct dir_context {
	filldir_t actor;
	loff_t pos;
};

struct dir_entry {
	u64 ino;
	u64 offset;
	unsigned int type;
	int name_len;
};

struct dir_entry___2 {
	struct list_head list;
	time64_t mtime;
	char name[0];
};

struct fname;

struct dir_private_info {
	struct rb_root root;
	struct rb_node *curr_node;
	struct fname *extra_fname;
	loff_t last_pos;
	__u32 curr_hash;
	__u32 curr_minor_hash;
	__u32 next_hash;
	u64 cookie;
	bool initialized;
};

struct wb_domain;

struct dirty_throttle_control {
	struct wb_domain *dom;
	struct dirty_throttle_control *gdtc;
	struct bdi_writeback *wb;
	struct fprop_local_percpu *wb_completions;
	long unsigned int avail;
	long unsigned int dirty;
	long unsigned int thresh;
	long unsigned int bg_thresh;
	long unsigned int limit;
	long unsigned int wb_dirty;
	long unsigned int wb_thresh;
	long unsigned int wb_bg_thresh;
	long unsigned int pos_ratio;
	bool freerun;
	bool dirty_exceeded;
};

struct disk_events {
	struct list_head node;
	struct gendisk *disk;
	spinlock_t lock;
	struct mutex block_mutex;
	int block;
	unsigned int pending;
	unsigned int clearing;
	long int poll_msecs;
	struct delayed_work dwork;
};

struct disk_stats {
	u64 nsecs[4];
	long unsigned int sectors[4];
	long unsigned int ios[4];
	long unsigned int merges[4];
	long unsigned int io_ticks;
	local_t in_flight[2];
};

struct dispatch_rq_data {
	struct blk_mq_hw_ctx *hctx;
	struct request *rq;
};

struct displayid_block {
	u8 tag;
	u8 rev;
	u8 num_bytes;
};

struct displayid_detailed_timings_1 {
	u8 pixel_clock[3];
	u8 flags;
	u8 hactive[2];
	u8 hblank[2];
	u8 hsync[2];
	u8 hsw[2];
	u8 vactive[2];
	u8 vblank[2];
	u8 vsync[2];
	u8 vsw[2];
};

struct displayid_detailed_timing_block {
	struct displayid_block base;
	struct displayid_detailed_timings_1 timings[0];
};

struct displayid_header {
	u8 rev;
	u8 bytes;
	u8 prod_id;
	u8 ext_count;
};

struct displayid_tiled_block {
	struct displayid_block base;
	u8 tile_cap;
	u8 topo[3];
	u8 tile_size[4];
	u8 tile_pixel_bezel[5];
	u8 topology_id[8];
};

struct displayid_vesa_vendor_specific_block {
	struct displayid_block base;
	u8 oui[3];
	u8 data_structure_type;
	u8 mso;
};

struct distr_item {
	__be32 type;
	__be32 lower;
	__be32 upper;
	__be32 port;
	__be32 key;
};

struct disttable {
	u32 size;
	s16 table[0];
};

struct dl_bw {
	raw_spinlock_t lock;
	u64 bw;
	u64 total_bw;
};

struct dl_rq {
	struct rb_root_cached root;
	unsigned int dl_nr_running;
	struct {
		u64 curr;
		u64 next;
	} earliest_dl;
	bool overloaded;
	struct rb_root_cached pushable_dl_tasks_root;
	u64 running_bw;
	u64 this_bw;
	u64 extra_bw;
	u64 max_bw;
	u64 bw_ratio;
};

struct dm_arg {
	unsigned int min;
	unsigned int max;
	char *error;
};

struct dm_arg_set {
	unsigned int argc;
	char **argv;
};

struct dm_bio_details {
	struct block_device *bi_bdev;
	int __bi_remaining;
	long unsigned int bi_flags;
	struct bvec_iter bi_iter;
	bio_end_io_t *bi_end_io;
};

struct dm_blkdev_id {
	u8 *id;
	enum blk_unique_id type;
};

struct lru_entry {
	struct list_head list;
	atomic_t referenced;
};

struct dm_bufio_client;

struct dm_buffer {
	struct rb_node node;
	sector_t block;
	void *data;
	unsigned char data_mode;
	atomic_t hold_count;
	long unsigned int last_accessed;
	long unsigned int state;
	struct lru_entry lru;
	unsigned char list_mode;
	blk_status_t read_error;
	blk_status_t write_error;
	unsigned int dirty_start;
	unsigned int dirty_end;
	unsigned int write_start;
	unsigned int write_end;
	struct list_head write_list;
	struct dm_bufio_client *c;
	void (*end_io)(struct dm_buffer *, blk_status_t);
};

struct lru {
	struct list_head *cursor;
	long unsigned int count;
	struct list_head iterators;
};

struct dm_buffer_cache {
	struct lru lru[2];
	unsigned int num_locks;
	bool no_sleep;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct buffer_tree trees[0];
};

struct dm_io_client;

struct dm_bufio_client {
	struct block_device *bdev;
	unsigned int block_size;
	s8 sectors_per_block_bits;
	bool no_sleep;
	struct mutex lock;
	spinlock_t spinlock;
	int async_write_error;
	void (*alloc_callback)(struct dm_buffer *);
	void (*write_callback)(struct dm_buffer *);
	struct kmem_cache *slab_buffer;
	struct kmem_cache *slab_cache;
	struct dm_io_client *dm_io;
	struct list_head reserved_buffers;
	unsigned int need_reserved_buffers;
	unsigned int minimum_buffers;
	sector_t start;
	struct shrinker *shrinker;
	struct work_struct shrink_work;
	atomic_long_t need_shrink;
	wait_queue_head_t free_buffer_wait;
	struct list_head client_list;
	long unsigned int oldest_buffer;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dm_buffer_cache cache;
};

struct dm_dev {
	struct block_device *bdev;
	struct file *bdev_file;
	struct dax_device *dax_dev;
	blk_mode_t mode;
	char name[16];
};

struct dm_dev_internal {
	struct list_head list;
	refcount_t count;
	struct dm_dev *dm_dev;
};

struct dm_dirty_log_type;

struct dm_target;

struct dm_dirty_log {
	struct dm_dirty_log_type *type;
	int (*flush_callback_fn)(struct dm_target *);
	void *context;
};

struct dm_dirty_log_type {
	const char *name;
	struct module *module;
	struct list_head list;
	int (*ctr)(struct dm_dirty_log *, struct dm_target *, unsigned int, char **);
	void (*dtr)(struct dm_dirty_log *);
	int (*presuspend)(struct dm_dirty_log *);
	int (*postsuspend)(struct dm_dirty_log *);
	int (*resume)(struct dm_dirty_log *);
	uint32_t (*get_region_size)(struct dm_dirty_log *);
	int (*is_clean)(struct dm_dirty_log *, region_t);
	int (*in_sync)(struct dm_dirty_log *, region_t, int);
	int (*flush)(struct dm_dirty_log *);
	void (*mark_region)(struct dm_dirty_log *, region_t);
	void (*clear_region)(struct dm_dirty_log *, region_t);
	int (*get_resync_work)(struct dm_dirty_log *, region_t *);
	void (*set_region_sync)(struct dm_dirty_log *, region_t, int);
	region_t (*get_sync_count)(struct dm_dirty_log *);
	int (*status)(struct dm_dirty_log *, status_type_t, char *, unsigned int);
	int (*is_remote_recovering)(struct dm_dirty_log *, region_t);
};

struct dm_file {
	volatile unsigned int global_event_nr;
};

struct dm_ima_device_table_metadata {
	char *device_metadata;
	unsigned int device_metadata_len;
	unsigned int num_targets;
	char *hash;
	unsigned int hash_len;
};

struct dm_ima_measurements {
	struct dm_ima_device_table_metadata active_table;
	struct dm_ima_device_table_metadata inactive_table;
	unsigned int dm_version_str_len;
};

struct dm_stats_aux {
	bool merged;
	long long unsigned int duration_ns;
};

struct dm_target_io {
	short unsigned int magic;
	blk_short_t flags;
	unsigned int target_bio_nr;
	struct dm_io *io;
	struct dm_target *ti;
	unsigned int *len_ptr;
	sector_t old_sector;
	struct bio clone;
};

struct mapped_device;

struct dm_io {
	short unsigned int magic;
	blk_short_t flags;
	spinlock_t lock;
	long unsigned int start_time;
	void *data;
	struct dm_io *next;
	struct dm_stats_aux stats_aux;
	blk_status_t status;
	atomic_t io_count;
	struct mapped_device *md;
	struct bio *orig_bio;
	unsigned int sector_offset;
	unsigned int sectors;
	struct dm_target_io tio;
};

struct dm_io_client {
	mempool_t pool;
	struct bio_set bios;
};

struct page_list;

struct dm_io_memory {
	enum dm_io_mem_type type;
	unsigned int offset;
	union {
		struct page_list *pl;
		struct bio *bio;
		void *vma;
		void *addr;
	} ptr;
};

typedef void (*io_notify_fn)(long unsigned int, void *);

struct dm_io_notify {
	io_notify_fn fn;
	void *context;
};

struct dm_io_region {
	struct block_device *bdev;
	sector_t sector;
	sector_t count;
};

struct dm_io_request {
	blk_opf_t bi_opf;
	struct dm_io_memory mem;
	struct dm_io_notify notify;
	struct dm_io_client *client;
};

struct dm_ioctl {
	__u32 version[3];
	__u32 data_size;
	__u32 data_start;
	__u32 target_count;
	__s32 open_count;
	__u32 flags;
	__u32 event_nr;
	__u32 padding;
	__u64 dev;
	char name[128];
	char uuid[129];
	char data[7];
};

struct dm_kcopyd_throttle;

struct dm_kcopyd_client {
	struct page_list *pages;
	unsigned int nr_reserved_pages;
	unsigned int nr_free_pages;
	unsigned int sub_job_size;
	struct dm_io_client *io_client;
	wait_queue_head_t destroyq;
	mempool_t job_pool;
	struct workqueue_struct *kcopyd_wq;
	struct work_struct kcopyd_work;
	struct dm_kcopyd_throttle *throttle;
	atomic_t nr_jobs;
	spinlock_t job_lock;
	struct list_head callback_jobs;
	struct list_head complete_jobs;
	struct list_head io_jobs;
	struct list_head pages_jobs;
};

struct dm_kcopyd_throttle {
	unsigned int throttle;
	unsigned int num_io_jobs;
	unsigned int io_period;
	unsigned int total_period;
	unsigned int last_jiffies;
};

struct dm_kobject_holder {
	struct kobject kobj;
	struct completion completion;
};

struct dm_md_mempools {
	struct bio_set bs;
	struct bio_set io_bs;
};

struct dm_name_list {
	__u64 dev;
	__u32 next;
	char name[0];
};

struct pr_keys;

struct pr_held_reservation;

struct dm_pr {
	u64 old_key;
	u64 new_key;
	u32 flags;
	bool abort;
	bool fail_early;
	int ret;
	enum pr_type type;
	struct pr_keys *read_keys;
	struct pr_held_reservation *rsv;
};

struct mirror;

struct dm_raid1_bio_record {
	struct mirror *m;
	struct dm_bio_details details;
	region_t write_region;
};

struct dm_region_hash;

struct dm_region {
	struct dm_region_hash *rh;
	region_t key;
	int state;
	struct list_head hash_list;
	struct list_head list;
	atomic_t pending;
	struct bio_list delayed_bios;
};

struct dm_region_hash {
	uint32_t region_size;
	unsigned int region_shift;
	struct dm_dirty_log *log;
	rwlock_t hash_lock;
	unsigned int mask;
	unsigned int nr_buckets;
	unsigned int prime;
	unsigned int shift;
	struct list_head *buckets;
	int flush_failure;
	unsigned int max_recovery;
	spinlock_t region_lock;
	atomic_t recovery_in_flight;
	struct list_head clean_regions;
	struct list_head quiesced_regions;
	struct list_head recovered_regions;
	struct list_head failed_recovered_regions;
	struct semaphore recovery_count;
	mempool_t region_pool;
	void *context;
	sector_t target_begin;
	void (*dispatch_bios)(void *, struct bio_list *);
	void (*wakeup_workers)(void *);
	void (*wakeup_all_recovery_waiters)(void *);
};

struct dm_rq_target_io;

struct dm_rq_clone_bio_info {
	struct bio *orig;
	struct dm_rq_target_io *tio;
	struct bio clone;
};

struct kthread_work;

typedef void (*kthread_work_func_t)(struct kthread_work *);

struct kthread_worker;

struct kthread_work {
	struct list_head node;
	kthread_work_func_t func;
	struct kthread_worker *worker;
	int canceling;
};

union map_info {
	void *ptr;
};

struct dm_rq_target_io {
	struct mapped_device *md;
	struct dm_target *ti;
	struct request *orig;
	struct request *clone;
	struct kthread_work work;
	blk_status_t error;
	union map_info info;
	struct dm_stats_aux stats_aux;
	long unsigned int duration_jiffies;
	unsigned int n_sectors;
	unsigned int completed;
};

struct dm_stat_percpu {
	long long unsigned int sectors[2];
	long long unsigned int ios[2];
	long long unsigned int merges[2];
	long long unsigned int ticks[2];
	long long unsigned int io_ticks[2];
	long long unsigned int io_ticks_total;
	long long unsigned int time_in_queue;
	long long unsigned int *histogram;
};

struct dm_stat_shared {
	atomic_t in_flight[2];
	long long unsigned int stamp;
	struct dm_stat_percpu tmp;
};

struct dm_stat {
	struct list_head list_entry;
	int id;
	unsigned int stat_flags;
	size_t n_entries;
	sector_t start;
	sector_t end;
	sector_t step;
	unsigned int n_histogram_entries;
	long long unsigned int *histogram_boundaries;
	const char *program_id;
	const char *aux_data;
	struct callback_head callback_head;
	size_t shared_alloc_size;
	size_t percpu_alloc_size;
	size_t histogram_alloc_size;
	struct dm_stat_percpu *stat_percpu[64];
	struct dm_stat_shared stat_shared[0];
};

struct dm_stats_last_position;

struct dm_stats {
	struct mutex mutex;
	struct list_head list;
	struct dm_stats_last_position *last;
	bool precise_timestamps;
};

struct dm_stats_last_position {
	sector_t last_sector;
	unsigned int last_rw;
};

struct dm_sysfs_attr {
	struct attribute attr;
	ssize_t (*show)(struct mapped_device *, char *);
	ssize_t (*store)(struct mapped_device *, const char *, size_t);
};

struct target_type;

struct dm_table {
	struct mapped_device *md;
	enum dm_queue_mode type;
	unsigned int depth;
	unsigned int counts[16];
	sector_t *index[16];
	unsigned int num_targets;
	unsigned int num_allocated;
	sector_t *highs;
	struct dm_target *targets;
	struct target_type *immutable_target_type;
	bool integrity_supported: 1;
	bool singleton: 1;
	bool flush_bypasses_map: 1;
	blk_mode_t mode;
	struct list_head devices;
	struct rw_semaphore devices_lock;
	void (*event_fn)(void *);
	void *event_context;
	struct dm_md_mempools *mempools;
};

struct dm_target {
	struct dm_table *table;
	struct target_type *type;
	sector_t begin;
	sector_t len;
	uint32_t max_io_len;
	unsigned int num_flush_bios;
	unsigned int num_discard_bios;
	unsigned int num_secure_erase_bios;
	unsigned int num_write_zeroes_bios;
	unsigned int per_io_data_size;
	void *private;
	char *error;
	bool flush_supported: 1;
	bool discards_supported: 1;
	bool zone_reset_all_supported: 1;
	bool max_discard_granularity: 1;
	bool limit_swap_bios: 1;
	bool emulate_zone_append: 1;
	bool accounts_remapped_io: 1;
	bool needs_bio_set_dev: 1;
	bool flush_bypasses_map: 1;
	bool mempool_needs_integrity: 1;
};

struct dm_target_deps {
	__u32 count;
	__u32 padding;
	__u64 dev[0];
};

struct dm_target_msg {
	__u64 sector;
	char message[0];
};

struct dm_target_spec {
	__u64 sector_start;
	__u64 length;
	__s32 status;
	__u32 next;
	char target_type[16];
};

struct dm_target_versions {
	__u32 next;
	__u32 version[3];
	char name[0];
};

struct dm_verity_fec;

struct dm_verity {
	struct dm_dev *data_dev;
	struct dm_dev *hash_dev;
	struct dm_target *ti;
	struct dm_bufio_client *bufio;
	char *alg_name;
	struct crypto_ahash *ahash_tfm;
	struct crypto_shash *shash_tfm;
	u8 *root_digest;
	u8 *salt;
	u8 *initial_hashstate;
	u8 *zero_digest;
	u8 *root_digest_sig;
	unsigned int sig_size;
	unsigned int salt_size;
	sector_t hash_start;
	sector_t data_blocks;
	sector_t hash_blocks;
	unsigned char data_dev_block_bits;
	unsigned char hash_dev_block_bits;
	unsigned char hash_per_block_bits;
	unsigned char levels;
	unsigned char version;
	bool hash_failed: 1;
	bool use_bh_wq: 1;
	unsigned int digest_size;
	unsigned int hash_reqsize;
	enum verity_mode mode;
	enum verity_mode error_mode;
	unsigned int corrupted_errs;
	struct workqueue_struct *verify_wq;
	sector_t hash_level_block[63];
	struct dm_verity_fec *fec;
	long unsigned int *validated_blocks;
	char *signature_key_desc;
	struct dm_io_client *io;
	mempool_t recheck_pool;
};

struct dm_verity_digest {
	const char *alg;
	const u8 *digest;
	size_t digest_len;
};

struct dm_verity_fec {
	struct dm_dev *dev;
	struct dm_bufio_client *data_bufio;
	struct dm_bufio_client *bufio;
	size_t io_size;
	sector_t start;
	sector_t blocks;
	sector_t rounds;
	sector_t hash_blocks;
	unsigned char roots;
	unsigned char rsn;
	mempool_t rs_pool;
	mempool_t prealloc_pool;
	mempool_t extra_pool;
	mempool_t output_pool;
	struct kmem_cache *cache;
};

struct dm_verity_io {
	struct dm_verity *v;
	bio_end_io_t *orig_bi_end_io;
	struct bvec_iter iter;
	sector_t block;
	unsigned int n_blocks;
	bool in_bh;
	bool had_mismatch;
	struct work_struct work;
	struct work_struct bh_work;
	u8 real_digest[64];
	u8 want_digest[64];
};

struct dm_verity_prefetch_work {
	struct work_struct work;
	struct dm_verity *v;
	short unsigned int ioprio;
	sector_t block;
	unsigned int n_blocks;
};

struct dm_verity_sig_opts {
	unsigned int sig_size;
	u8 *sig;
};

typedef void (*dma_async_tx_callback)(void *);

struct dmaengine_result;

typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);

struct dmaengine_unmap_data;

struct dma_descriptor_metadata_ops;

struct dma_async_tx_descriptor {
	dma_cookie_t cookie;
	enum dma_ctrl_flags flags;
	dma_addr_t phys;
	struct dma_chan *chan;
	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
	int (*desc_free)(struct dma_async_tx_descriptor *);
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
	struct dmaengine_unmap_data *unmap;
	enum dma_desc_metadata_mode desc_metadata_mode;
	struct dma_descriptor_metadata_ops *metadata_ops;
};

struct dma_block {
	struct dma_block *next_block;
	dma_addr_t dma;
};

struct iosys_map {
	union {
		void *vaddr_iomem;
		void *vaddr;
	};
	bool is_iomem;
};

struct dma_buf_poll_cb_t {
	struct dma_fence_cb cb;
	wait_queue_head_t *poll;
	__poll_t active;
};

struct dma_buf_ops;

struct dma_resv;

struct dma_buf {
	size_t size;
	struct file *file;
	struct list_head attachments;
	const struct dma_buf_ops *ops;
	unsigned int vmapping_counter;
	struct iosys_map vmap_ptr;
	const char *exp_name;
	const char *name;
	spinlock_t name_lock;
	struct module *owner;
	struct list_head list_node;
	void *priv;
	struct dma_resv *resv;
	wait_queue_head_t poll;
	struct dma_buf_poll_cb_t cb_in;
	struct dma_buf_poll_cb_t cb_out;
};

struct dma_buf_attachment;

struct dma_buf_attach_ops {
	bool allow_peer2peer;
	void (*move_notify)(struct dma_buf_attachment *);
};

struct dma_buf_attachment {
	struct dma_buf *dmabuf;
	struct device *dev;
	struct list_head node;
	struct sg_table *sgt;
	enum dma_data_direction dir;
	bool peer2peer;
	const struct dma_buf_attach_ops *importer_ops;
	void *importer_priv;
	void *priv;
};

struct dma_buf_export_info {
	const char *exp_name;
	struct module *owner;
	const struct dma_buf_ops *ops;
	size_t size;
	int flags;
	struct dma_resv *resv;
	void *priv;
};

struct dma_buf_export_sync_file {
	__u32 flags;
	__s32 fd;
};

struct dma_buf_import_sync_file {
	__u32 flags;
	__s32 fd;
};

struct dma_buf_ops {
	bool cache_sgt_mapping;
	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*pin)(struct dma_buf_attachment *);
	void (*unpin)(struct dma_buf_attachment *);
	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
	void (*release)(struct dma_buf *);
	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
	int (*vmap)(struct dma_buf *, struct iosys_map *);
	void (*vunmap)(struct dma_buf *, struct iosys_map *);
};

struct dma_buf_sync {
	__u64 flags;
};

struct dma_chan___2 {
	int lock;
	const char *device_id;
};

struct dma_device;

struct dma_chan_dev;

struct dma_chan_percpu;

struct dma_router;

struct dma_chan {
	struct dma_device *device;
	struct device *slave;
	dma_cookie_t cookie;
	dma_cookie_t completed_cookie;
	int chan_id;
	struct dma_chan_dev *dev;
	const char *name;
	char *dbg_client_name;
	struct list_head device_node;
	struct dma_chan_percpu *local;
	int client_count;
	int table_count;
	struct dma_router *router;
	void *route_data;
	void *private;
};

struct dma_chan_dev {
	struct dma_chan *chan;
	struct device device;
	int dev_id;
	bool chan_dma_dev;
};

struct dma_chan_percpu {
	long unsigned int memcpy_count;
	long unsigned int bytes_transferred;
};

struct dma_chan_tbl_ent {
	struct dma_chan *chan;
};

struct dma_descriptor_metadata_ops {
	int (*attach)(struct dma_async_tx_descriptor *, void *, size_t);
	void * (*get_ptr)(struct dma_async_tx_descriptor *, size_t *, size_t *);
	int (*set_len)(struct dma_async_tx_descriptor *, size_t);
};

struct dma_slave_map;

struct dma_filter {
	dma_filter_fn fn;
	int mapcnt;
	const struct dma_slave_map *map;
};

struct dma_vec;

struct dma_interleaved_template;

struct dma_slave_caps;

struct dma_slave_config;

struct dma_tx_state;

struct dma_device {
	struct kref ref;
	unsigned int chancnt;
	unsigned int privatecnt;
	struct list_head channels;
	struct list_head global_node;
	struct dma_filter filter;
	dma_cap_mask_t cap_mask;
	enum dma_desc_metadata_mode desc_metadata_modes;
	short unsigned int max_xor;
	short unsigned int max_pq;
	enum dmaengine_alignment copy_align;
	enum dmaengine_alignment xor_align;
	enum dmaengine_alignment pq_align;
	enum dmaengine_alignment fill_align;
	int dev_id;
	struct device *dev;
	struct module *owner;
	struct ida chan_ida;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool descriptor_reuse;
	enum dma_residue_granularity residue_granularity;
	int (*device_alloc_chan_resources)(struct dma_chan *);
	int (*device_router_config)(struct dma_chan *);
	void (*device_free_chan_resources)(struct dma_chan *);
	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan *, dma_addr_t, int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan *, struct scatterlist *, unsigned int, int, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_peripheral_dma_vec)(struct dma_chan *, const struct dma_vec *, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, long unsigned int, void *);
	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan *, struct dma_interleaved_template *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan *, dma_addr_t, u64, long unsigned int);
	void (*device_caps)(struct dma_chan *, struct dma_slave_caps *);
	int (*device_config)(struct dma_chan *, struct dma_slave_config *);
	int (*device_pause)(struct dma_chan *);
	int (*device_resume)(struct dma_chan *);
	int (*device_terminate_all)(struct dma_chan *);
	void (*device_synchronize)(struct dma_chan *);
	enum dma_status (*device_tx_status)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *);
	void (*device_issue_pending)(struct dma_chan *);
	void (*device_release)(struct dma_device *);
	void (*dbg_summary_show)(struct seq_file *, struct dma_device *);
	struct dentry *dbg_dev_root;
};

struct dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
	long unsigned int attrs;
};

struct dma_fence_array;

struct dma_fence_array_cb {
	struct dma_fence_cb cb;
	struct dma_fence_array *array;
};

struct dma_fence_array {
	struct dma_fence base;
	spinlock_t lock;
	unsigned int num_fences;
	atomic_t num_pending;
	struct dma_fence **fences;
	struct irq_work work;
	struct dma_fence_array_cb callbacks[0];
};

struct dma_fence_chain {
	struct dma_fence base;
	struct dma_fence *prev;
	u64 prev_seqno;
	struct dma_fence *fence;
	union {
		struct dma_fence_cb cb;
		struct irq_work work;
	};
	spinlock_t lock;
};

struct dma_fence_ops {
	bool use_64bit_seqno;
	const char * (*get_driver_name)(struct dma_fence *);
	const char * (*get_timeline_name)(struct dma_fence *);
	bool (*enable_signaling)(struct dma_fence *);
	bool (*signaled)(struct dma_fence *);
	long int (*wait)(struct dma_fence *, bool, long int);
	void (*release)(struct dma_fence *);
	void (*fence_value_str)(struct dma_fence *, char *, int);
	void (*timeline_value_str)(struct dma_fence *, char *, int);
	void (*set_deadline)(struct dma_fence *, ktime_t);
};

struct dma_fence_unwrap {
	struct dma_fence *chain;
	struct dma_fence *array;
	unsigned int index;
};

struct dma_fence_work_ops {
	const char *name;
	void (*work)(struct dma_fence_work *);
	void (*release)(struct dma_fence_work *);
};

struct dma_interleaved_template {
	dma_addr_t src_start;
	dma_addr_t dst_start;
	enum dma_transfer_direction dir;
	bool src_inc;
	bool dst_inc;
	bool src_sgl;
	bool dst_sgl;
	size_t numf;
	size_t frame_size;
	struct data_chunk sgl[0];
};

struct dma_map_ops {
	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);
	void (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);
	struct page * (*alloc_pages_op)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);
	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);
	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
	dma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device *, u64);
	u64 (*get_required_mask)(struct device *);
	size_t (*max_mapping_size)(struct device *);
	size_t (*opt_mapping_size)(void);
	long unsigned int (*get_merge_boundary)(struct device *);
};

struct dma_page {
	struct list_head page_list;
	void *vaddr;
	dma_addr_t dma;
};

struct dma_pool {
	struct list_head page_list;
	spinlock_t lock;
	struct dma_block *next_block;
	size_t nr_blocks;
	size_t nr_active;
	size_t nr_pages;
	struct device *dev;
	unsigned int size;
	unsigned int allocation;
	unsigned int boundary;
	char name[32];
	struct list_head pools;
};

struct dma_pte {
	u64 val;
};

struct ww_acquire_ctx;

struct ww_mutex {
	struct mutex base;
	struct ww_acquire_ctx *ctx;
};

struct dma_resv_list;

struct dma_resv {
	struct ww_mutex lock;
	struct dma_resv_list *fences;
};

struct dma_resv_iter {
	struct dma_resv *obj;
	enum dma_resv_usage usage;
	struct dma_fence *fence;
	enum dma_resv_usage fence_usage;
	unsigned int index;
	struct dma_resv_list *fences;
	unsigned int num_fences;
	bool is_restarted;
};

struct dma_resv_list {
	struct callback_head rcu;
	u32 num_fences;
	u32 max_fences;
	struct dma_fence *table[0];
};

struct dma_router {
	struct device *dev;
	void (*route_free)(struct device *, void *);
};

struct dma_sgt_handle {
	struct sg_table sgt;
	struct page **pages;
};

struct dma_slave_caps {
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool cmd_pause;
	bool cmd_resume;
	bool cmd_terminate;
	enum dma_residue_granularity residue_granularity;
	bool descriptor_reuse;
};

struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	u32 src_port_window_size;
	u32 dst_port_window_size;
	bool device_fc;
	void *peripheral_config;
	size_t peripheral_size;
};

struct dma_slave_map {
	const char *devname;
	const char *slave;
	void *param;
};

struct dma_tx_state {
	dma_cookie_t last;
	dma_cookie_t used;
	u32 residue;
	u32 in_flight_bytes;
};

struct dma_vec {
	dma_addr_t addr;
	size_t len;
};

struct dmabuf_cmsg {
	__u64 frag_offset;
	__u32 frag_size;
	__u32 frag_token;
	__u32 dmabuf_id;
	__u32 flags;
};

struct net_iov;

struct net_devmem_dmabuf_binding;

struct dmabuf_genpool_chunk_owner {
	long unsigned int base_virtual;
	dma_addr_t base_dma_addr;
	struct net_iov *niovs;
	size_t num_niovs;
	struct net_devmem_dmabuf_binding *binding;
};

struct dmabuf_token {
	__u32 token_start;
	__u32 token_count;
};

struct dmaengine_desc_callback {
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
};

struct dmaengine_result {
	enum dmaengine_tx_result result;
	u32 residue;
};

struct dmaengine_unmap_data {
	u8 map_cnt;
	u8 to_cnt;
	u8 from_cnt;
	u8 bidi_cnt;
	struct device *dev;
	struct kref kref;
	size_t len;
	dma_addr_t addr[0];
};

struct dmaengine_unmap_pool {
	struct kmem_cache *cache;
	const char *name;
	mempool_t *pool;
	size_t size;
};

struct dmar_dev_scope;

struct dmar_atsr_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	struct dmar_dev_scope *devices;
	int devices_cnt;
	u8 include_all: 1;
};

struct dmar_dev_scope {
	struct device *dev;
	u8 bus;
	u8 devfn;
};

struct iommu_hwpt_vtd_s1 {
	__u64 flags;
	__u64 pgtbl_addr;
	__u32 addr_width;
	__u32 __reserved;
};

struct mmu_notifier_ops;

struct mmu_notifier {
	struct hlist_node hlist;
	const struct mmu_notifier_ops *ops;
	struct mm_struct *mm;
	struct callback_head rcu;
	unsigned int users;
};

struct iommu_domain_geometry {
	dma_addr_t aperture_start;
	dma_addr_t aperture_end;
	bool force_aperture;
};

struct iommu_domain;

typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);

struct iommu_domain_ops;

struct iommu_dirty_ops;

struct iommu_dma_cookie;

struct iopf_group;

struct iommu_domain {
	unsigned int type;
	const struct iommu_domain_ops *ops;
	const struct iommu_dirty_ops *dirty_ops;
	const struct iommu_ops *owner;
	long unsigned int pgsize_bitmap;
	struct iommu_domain_geometry geometry;
	struct iommu_dma_cookie *iova_cookie;
	int (*iopf_handler)(struct iopf_group *);
	void *fault_data;
	union {
		struct {
			iommu_fault_handler_t handler;
			void *handler_token;
		};
		struct {
			struct mm_struct *mm;
			int users;
			struct list_head next;
		};
	};
};

struct qi_batch;

struct dmar_domain {
	int nid;
	struct xarray iommu_array;
	u8 iommu_coherency: 1;
	u8 force_snooping: 1;
	u8 set_pte_snp: 1;
	u8 use_first_level: 1;
	u8 dirty_tracking: 1;
	u8 nested_parent: 1;
	u8 has_mappings: 1;
	spinlock_t lock;
	struct list_head devices;
	struct list_head dev_pasids;
	spinlock_t cache_lock;
	struct list_head cache_tags;
	struct qi_batch *qi_batch;
	int iommu_superpage;
	union {
		struct {
			struct dma_pte *pgd;
			int gaw;
			int agaw;
			u64 max_addr;
			spinlock_t s1_lock;
			struct list_head s1_domains;
		};
		struct {
			struct dmar_domain *s2_domain;
			struct iommu_hwpt_vtd_s1 s1_cfg;
			struct list_head s2_link;
		};
		struct {
			struct mmu_notifier notifier;
		};
	};
	struct iommu_domain domain;
};

struct dmar_drhd_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	u64 reg_base_addr;
	long unsigned int reg_size;
	struct dmar_dev_scope *devices;
	int devices_cnt;
	u16 segment;
	u8 ignored: 1;
	u8 include_all: 1;
	u8 gfx_dedicated: 1;
	struct intel_iommu *iommu;
};

struct dmar_pci_path {
	u8 bus;
	u8 device;
	u8 function;
};

struct dmar_pci_notify_info {
	struct pci_dev *dev;
	long unsigned int event;
	int bus;
	u16 seg;
	u16 level;
	struct dmar_pci_path path[0];
};

typedef int (*dmar_res_handler_t)(struct acpi_dmar_header *, void *);

struct dmar_res_callback {
	dmar_res_handler_t cb[6];
	void *arg[6];
	bool ignore_unhandled;
	bool print_entry;
};

struct dmar_rmrr_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	u64 base_address;
	u64 end_address;
	struct dmar_dev_scope *devices;
	int devices_cnt;
};

struct dmar_satc_unit {
	struct list_head list;
	struct acpi_dmar_header *hdr;
	struct dmar_dev_scope *devices;
	struct intel_iommu *iommu;
	int devices_cnt;
	u8 atc_required: 1;
};

struct dmc_fw_info {
	u32 mmio_count;
	i915_reg_t mmioaddr[20];
	u32 mmiodata[20];
	u32 dmc_offset;
	u32 start_mmioaddr;
	u32 dmc_fw_size;
	u32 *payload;
	bool present;
};

struct dmi_device {
	struct list_head list;
	int type;
	const char *name;
	void *device_data;
};

struct dmi_dev_onboard {
	struct dmi_device dev;
	int instance;
	int segment;
	int bus;
	int devfn;
};

struct dmi_device_attribute {
	struct device_attribute dev_attr;
	int field;
};

struct dmi_entry_attr_show_data {
	struct attribute *attr;
	char *buf;
};

struct dmi_header {
	u8 type;
	u8 length;
	u16 handle;
};

struct dmi_memdev_info {
	const char *device;
	const char *bank;
	u64 size;
	u16 handle;
	u8 type;
};

struct dmi_onboard_device_info {
	const char *name;
	u8 type;
	short unsigned int i2c_addr;
	const char *i2c_type;
};

struct dmi_read_state {
	char *buf;
	loff_t pos;
	size_t count;
};

struct dmi_strmatch {
	unsigned char slot: 7;
	unsigned char exact_match: 1;
	char substr[79];
};

struct dmi_sysfs_entry;

struct dmi_sysfs_attribute {
	struct attribute attr;
	ssize_t (*show)(struct dmi_sysfs_entry *, char *);
};

struct dmi_sysfs_entry {
	struct dmi_header dh;
	struct kobject kobj;
	int instance;
	int position;
	struct list_head list;
	struct kobject *child;
};

struct dmi_sysfs_mapped_attribute {
	struct attribute attr;
	ssize_t (*show)(struct dmi_sysfs_entry *, const struct dmi_header *, char *);
};

struct dmi_system_event_log {
	struct dmi_header header;
	u16 area_length;
	u16 header_start_offset;
	u16 data_start_offset;
	u8 access_method;
	u8 status;
	u32 change_token;
	union {
		struct {
			u16 index_addr;
			u16 data_addr;
		} io;
		u32 phys_addr32;
		u16 gpnv_handle;
		u32 access_method_address;
	};
	u8 header_format;
	u8 type_descriptors_supported_count;
	u8 per_log_type_descriptor_length;
	u8 supported_log_type_descriptos[0];
} __attribute__((packed));

struct dmi_system_id {
	int (*callback)(const struct dmi_system_id *);
	const char *ident;
	struct dmi_strmatch matches[4];
	void *driver_data;
};

struct dnotify_struct;

struct dnotify_mark {
	struct fsnotify_mark fsn_mark;
	struct dnotify_struct *dn;
};

typedef void *fl_owner_t;

struct dnotify_struct {
	struct dnotify_struct *dn_next;
	__u32 dn_mask;
	int dn_fd;
	struct file *dn_filp;
	fl_owner_t dn_owner;
};

struct dns_payload_header {
	__u8 zero;
	__u8 content;
	__u8 version;
};

struct dns_server_list_v1_header {
	struct dns_payload_header hdr;
	__u8 source;
	__u8 status;
	__u8 nr_servers;
};

struct do_proc_dointvec_minmax_conv_param {
	int *min;
	int *max;
};

struct do_proc_douintvec_minmax_conv_param {
	unsigned int *min;
	unsigned int *max;
};

struct dock_dependent_device {
	struct list_head list;
	struct acpi_device *adev;
};

struct platform_device;

struct dock_station {
	acpi_handle handle;
	long unsigned int last_dock_time;
	u32 flags;
	struct list_head dependent_devices;
	struct list_head sibling;
	struct platform_device *dock_device;
};

struct dotl_iattr_map {
	int iattr_valid;
	int p9_iattr_valid;
};

struct dotl_openflag_map {
	int open_flag;
	int dotl_flag;
};

struct double_list {
	struct list_head *top;
	struct list_head *bottom;
};

struct drm_edp_backlight_info {
	u8 pwmgen_bit_count;
	u8 pwm_freq_pre_divider;
	u16 max;
	bool lsb_reg_used: 1;
	bool aux_enable: 1;
	bool aux_set: 1;
};

struct drm_dp_aux;

struct dp_aux_backlight {
	struct backlight_device *base;
	struct drm_dp_aux *aux;
	struct drm_edp_backlight_info info;
	bool enabled;
};

struct ovs_flow_stats {
	__u64 n_packets;
	__u64 n_bytes;
};

struct dp_meter_band {
	u32 type;
	u32 rate;
	u32 burst_size;
	u64 bucket;
	struct ovs_flow_stats stats;
};

struct dp_meter {
	spinlock_t lock;
	struct callback_head rcu;
	u32 id;
	u16 kbps: 1;
	u16 keep_stats: 1;
	u16 n_bands;
	u32 max_delta_t;
	u64 used;
	struct ovs_flow_stats stats;
	struct dp_meter_band bands[0];
};

struct dp_meter_instance {
	struct callback_head rcu;
	u32 n_meters;
	struct dp_meter *dp_meters[0];
};

struct dp_nlsk_pids {
	struct callback_head rcu;
	u32 n_pids;
	u32 pids[0];
};

struct dp_sdp_header {
	u8 HB0;
	u8 HB1;
	u8 HB2;
	u8 HB3;
};

struct dp_sdp {
	struct dp_sdp_header sdp_header;
	u8 db[32];
};

struct dp_stats_percpu {
	u64 n_hit;
	u64 n_missed;
	u64 n_lost;
	u64 n_mask_hit;
	u64 n_cache_hit;
	struct u64_stats_sync syncp;
};

struct ip_tunnel_info;

struct dp_upcall_info {
	struct ip_tunnel_info *egress_tun_info;
	const struct nlattr *userdata;
	const struct nlattr *actions;
	int actions_len;
	u32 portid;
	u8 cmd;
	u16 mru;
};

struct dpages {
	void (*get_page)(struct dpages *, struct page **, long unsigned int *, unsigned int *);
	void (*next_page)(struct dpages *);
	union {
		unsigned int context_u;
		struct bvec_iter context_bi;
	};
	void *context_ptr;
	void *vma_invalidate_address;
	long unsigned int vma_invalidate_size;
};

struct dpcd_quirk {
	u8 oui[3];
	u8 device_id[6];
	bool is_branch;
	u32 quirks;
};

struct dpll {
	int n;
	int m1;
	int m2;
	int p1;
	int p2;
	int dot;
	int vco;
	int m;
	int p;
};

struct intel_shared_dpll_funcs;

struct dpll_info {
	const char *name;
	const struct intel_shared_dpll_funcs *funcs;
	enum intel_dpll_id id;
	enum intel_display_power_domain power_domain;
	bool always_on;
	bool is_alt_port_dpll;
};

struct dql {
	unsigned int num_queued;
	unsigned int adj_limit;
	unsigned int last_obj_cnt;
	short unsigned int stall_thrs;
	long unsigned int history_head;
	long unsigned int history[4];
	long: 64;
	unsigned int limit;
	unsigned int num_completed;
	unsigned int prev_ovlimit;
	unsigned int prev_num_queued;
	unsigned int prev_last_obj_cnt;
	unsigned int lowest_slack;
	long unsigned int slack_start_time;
	unsigned int max_limit;
	unsigned int min_limit;
	unsigned int slack_hold_time;
	short unsigned int stall_max;
	long unsigned int last_reap;
	long unsigned int stall_cnt;
};

struct dqstats {
	long unsigned int stat[8];
	struct percpu_counter counter[8];
};

struct kqid {
	union {
		kuid_t uid;
		kgid_t gid;
		kprojid_t projid;
	};
	enum quota_type type;
};

struct mem_dqblk {
	qsize_t dqb_bhardlimit;
	qsize_t dqb_bsoftlimit;
	qsize_t dqb_curspace;
	qsize_t dqb_rsvspace;
	qsize_t dqb_ihardlimit;
	qsize_t dqb_isoftlimit;
	qsize_t dqb_curinodes;
	time64_t dqb_btime;
	time64_t dqb_itime;
};

struct dquot {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	long unsigned int dq_flags;
	struct mem_dqblk dq_dqb;
};

struct dquot_operations {
	int (*write_dquot)(struct dquot *);
	struct dquot * (*alloc_dquot)(struct super_block *, int);
	void (*destroy_dquot)(struct dquot *);
	int (*acquire_dquot)(struct dquot *);
	int (*release_dquot)(struct dquot *);
	int (*mark_dirty)(struct dquot *);
	int (*write_info)(struct super_block *, int);
	qsize_t * (*get_reserved_space)(struct inode *);
	int (*get_projid)(struct inode *, kprojid_t *);
	int (*get_inode_usage)(struct inode *, qsize_t *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct dquot_warn {
	struct super_block *w_sb;
	struct kqid w_dq_id;
	short int w_type;
};

struct dram_dimm_info {
	u16 size;
	u8 width;
	u8 ranks;
};

struct dram_channel_info {
	struct dram_dimm_info dimm_l;
	struct dram_dimm_info dimm_s;
	u8 ranks;
	bool is_16gb_dimm;
};

struct dram_info {
	bool wm_lv_0_adjust_needed;
	u8 num_channels;
	bool symmetric_memory;
	enum intel_dram_type type;
	u8 num_qgv_points;
	u8 num_psf_gv_points;
};

struct drbg_core {
	drbg_flag_t flags;
	__u8 statelen;
	__u8 blocklen_bytes;
	char cra_name[128];
	char backend_cra_name[128];
};

struct drbg_string {
	const unsigned char *buf;
	size_t len;
	struct list_head list;
};

struct drbg_state_ops;

struct drbg_state {
	struct mutex drbg_mutex;
	unsigned char *V;
	unsigned char *Vbuf;
	unsigned char *C;
	unsigned char *Cbuf;
	size_t reseed_ctr;
	size_t reseed_threshold;
	unsigned char *scratchpad;
	unsigned char *scratchpadbuf;
	void *priv_data;
	struct crypto_skcipher *ctr_handle;
	struct skcipher_request *ctr_req;
	__u8 *outscratchpadbuf;
	__u8 *outscratchpad;
	struct crypto_wait ctr_wait;
	struct scatterlist sg_in;
	struct scatterlist sg_out;
	enum drbg_seed_state seeded;
	long unsigned int last_seed_time;
	bool pr;
	bool fips_primed;
	unsigned char *prev;
	struct crypto_rng *jent;
	const struct drbg_state_ops *d_ops;
	const struct drbg_core *core;
	struct drbg_string test_data;
};

struct drbg_state_ops {
	int (*update)(struct drbg_state *, struct list_head *, int);
	int (*generate)(struct drbg_state *, unsigned char *, unsigned int, struct list_head *);
	int (*crypto_init)(struct drbg_state *);
	int (*crypto_fini)(struct drbg_state *);
};

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *, char *);
	ssize_t (*store)(struct device_driver *, const char *, size_t);
};

struct module_kobject;

struct driver_private {
	struct kobject kobj;
	struct klist klist_devices;
	struct klist_node knode_bus;
	struct module_kobject *mkobj;
	struct device_driver *driver;
};

struct drm_object_properties;

struct drm_mode_object {
	uint32_t id;
	uint32_t type;
	struct drm_object_properties *properties;
	struct kref refcount;
	void (*free_cb)(struct kref *);
};

struct drm_device;

struct drm_format_info;

struct drm_framebuffer_funcs;

struct drm_gem_object;

struct drm_framebuffer {
	struct drm_device *dev;
	struct list_head head;
	struct drm_mode_object base;
	char comm[16];
	const struct drm_format_info *format;
	const struct drm_framebuffer_funcs *funcs;
	unsigned int pitches[4];
	unsigned int offsets[4];
	uint64_t modifier;
	unsigned int width;
	unsigned int height;
	int flags;
	struct list_head filp_head;
	struct drm_gem_object *obj[4];
};

struct drm_afbc_framebuffer {
	struct drm_framebuffer base;
	u32 block_width;
	u32 block_height;
	u32 aligned_width;
	u32 aligned_height;
	u32 offset;
	u32 afbc_size;
};

struct drm_rect {
	int x1;
	int y1;
	int x2;
	int y2;
};

struct drm_atomic_helper_damage_iter {
	struct drm_rect plane_src;
	const struct drm_rect *clips;
	uint32_t num_clips;
	uint32_t curr_clip;
	bool full_update;
};

struct drm_modeset_acquire_ctx;

struct drm_atomic_state {
	struct kref ref;
	struct drm_device *dev;
	bool allow_modeset: 1;
	bool legacy_cursor_update: 1;
	bool async_update: 1;
	bool duplicated: 1;
	struct __drm_planes_state *planes;
	struct __drm_crtcs_state *crtcs;
	int num_connector;
	struct __drm_connnectors_state *connectors;
	int num_private_objs;
	struct __drm_private_objs_state *private_objs;
	struct drm_modeset_acquire_ctx *acquire_ctx;
	struct drm_crtc_commit *fake_commit;
	struct work_struct commit_work;
};

struct drm_audio_component_ops;

struct drm_audio_component_audio_ops;

struct drm_audio_component {
	struct device *dev;
	const struct drm_audio_component_ops *ops;
	const struct drm_audio_component_audio_ops *audio_ops;
	struct completion master_bind_complete;
};

struct drm_audio_component_audio_ops {
	void *audio_ptr;
	void (*pin_eld_notify)(void *, int, int);
	int (*pin2port)(void *, int);
	int (*master_bind)(struct device *, struct drm_audio_component *);
	void (*master_unbind)(struct device *, struct drm_audio_component *);
};

struct drm_audio_component_ops {
	struct module *owner;
	long unsigned int (*get_power)(struct device *);
	void (*put_power)(struct device *, long unsigned int);
	void (*codec_wake_override)(struct device *, bool);
	int (*get_cdclk_freq)(struct device *);
	int (*sync_audio_rate)(struct device *, int, int, int);
	int (*get_eld)(struct device *, int, int, bool *, unsigned char *, int);
};

struct drm_auth {
	drm_magic_t magic;
};

struct drm_modeset_lock {
	struct ww_mutex mutex;
	struct list_head head;
};

struct drm_private_state_funcs;

struct drm_private_obj {
	struct list_head head;
	struct drm_modeset_lock lock;
	struct drm_private_state *state;
	const struct drm_private_state_funcs *funcs;
};

struct drm_encoder;

struct drm_bridge_timings;

struct drm_bridge_funcs;

struct i2c_adapter;

struct drm_bridge {
	struct drm_private_obj base;
	struct drm_device *dev;
	struct drm_encoder *encoder;
	struct list_head chain_node;
	struct device_node *of_node;
	struct list_head list;
	const struct drm_bridge_timings *timings;
	const struct drm_bridge_funcs *funcs;
	void *driver_private;
	enum drm_bridge_ops ops;
	int type;
	bool interlace_allowed;
	bool ycbcr_420_allowed;
	bool pre_enable_prev_first;
	struct i2c_adapter *ddc;
	struct mutex hpd_mutex;
	void (*hpd_cb)(void *, enum drm_connector_status);
	void *hpd_data;
	const char *vendor;
	const char *product;
	unsigned int supported_formats;
	unsigned int max_bpc;
	struct device *hdmi_audio_dev;
	int hdmi_audio_max_i2s_playback_channels;
	unsigned int hdmi_audio_spdif_playback: 1;
	int hdmi_audio_dai_port;
};

struct hdmi_codec_daifmt;

struct hdmi_codec_params;

struct drm_display_info;

struct drm_display_mode;

struct drm_bridge_state;

struct drm_bridge_funcs {
	int (*attach)(struct drm_bridge *, enum drm_bridge_attach_flags);
	void (*detach)(struct drm_bridge *);
	enum drm_mode_status (*mode_valid)(struct drm_bridge *, const struct drm_display_info *, const struct drm_display_mode *);
	bool (*mode_fixup)(struct drm_bridge *, const struct drm_display_mode *, struct drm_display_mode *);
	void (*disable)(struct drm_bridge *);
	void (*post_disable)(struct drm_bridge *);
	void (*mode_set)(struct drm_bridge *, const struct drm_display_mode *, const struct drm_display_mode *);
	void (*pre_enable)(struct drm_bridge *);
	void (*enable)(struct drm_bridge *);
	void (*atomic_pre_enable)(struct drm_bridge *, struct drm_bridge_state *);
	void (*atomic_enable)(struct drm_bridge *, struct drm_bridge_state *);
	void (*atomic_disable)(struct drm_bridge *, struct drm_bridge_state *);
	void (*atomic_post_disable)(struct drm_bridge *, struct drm_bridge_state *);
	struct drm_bridge_state * (*atomic_duplicate_state)(struct drm_bridge *);
	void (*atomic_destroy_state)(struct drm_bridge *, struct drm_bridge_state *);
	u32 * (*atomic_get_output_bus_fmts)(struct drm_bridge *, struct drm_bridge_state *, struct drm_crtc_state *, struct drm_connector_state *, unsigned int *);
	u32 * (*atomic_get_input_bus_fmts)(struct drm_bridge *, struct drm_bridge_state *, struct drm_crtc_state *, struct drm_connector_state *, u32, unsigned int *);
	int (*atomic_check)(struct drm_bridge *, struct drm_bridge_state *, struct drm_crtc_state *, struct drm_connector_state *);
	struct drm_bridge_state * (*atomic_reset)(struct drm_bridge *);
	enum drm_connector_status (*detect)(struct drm_bridge *);
	int (*get_modes)(struct drm_bridge *, struct drm_connector *);
	const struct drm_edid * (*edid_read)(struct drm_bridge *, struct drm_connector *);
	void (*hpd_notify)(struct drm_bridge *, enum drm_connector_status);
	void (*hpd_enable)(struct drm_bridge *);
	void (*hpd_disable)(struct drm_bridge *);
	enum drm_mode_status (*hdmi_tmds_char_rate_valid)(const struct drm_bridge *, const struct drm_display_mode *, long long unsigned int);
	int (*hdmi_clear_infoframe)(struct drm_bridge *, enum hdmi_infoframe_type);
	int (*hdmi_write_infoframe)(struct drm_bridge *, enum hdmi_infoframe_type, const u8 *, size_t);
	int (*hdmi_audio_startup)(struct drm_connector *, struct drm_bridge *);
	int (*hdmi_audio_prepare)(struct drm_connector *, struct drm_bridge *, struct hdmi_codec_daifmt *, struct hdmi_codec_params *);
	void (*hdmi_audio_shutdown)(struct drm_connector *, struct drm_bridge *);
	int (*hdmi_audio_mute_stream)(struct drm_connector *, struct drm_bridge *, bool, int);
	void (*debugfs_init)(struct drm_bridge *, struct dentry *);
};

struct drm_private_state {
	struct drm_atomic_state *state;
	struct drm_private_obj *obj;
};

struct drm_bus_cfg {
	u32 format;
	u32 flags;
};

struct drm_bridge_state {
	struct drm_private_state base;
	struct drm_bridge *bridge;
	struct drm_bus_cfg input_bus_cfg;
	struct drm_bus_cfg output_bus_cfg;
};

struct drm_bridge_timings {
	u32 input_bus_flags;
	u32 setup_time_ps;
	u32 hold_time_ps;
	bool dual_link;
};

struct drm_buddy_block;

struct drm_buddy {
	struct list_head *free_list;
	struct drm_buddy_block **roots;
	unsigned int n_roots;
	unsigned int max_order;
	u64 chunk_size;
	u64 size;
	u64 avail;
	u64 clear_avail;
};

struct drm_buddy_block {
	u64 header;
	struct drm_buddy_block *left;
	struct drm_buddy_block *right;
	struct drm_buddy_block *parent;
	void *private;
	struct list_head link;
	struct list_head tmp_link;
};

struct drm_client {
	int idx;
	int auth;
	long unsigned int pid;
	long unsigned int uid;
	long unsigned int magic;
	long unsigned int iocs;
};

struct drm_client_dev;

struct drm_client_buffer {
	struct drm_client_dev *client;
	u32 pitch;
	struct drm_gem_object *gem;
	struct iosys_map map;
	struct drm_framebuffer *fb;
};

struct drm_client_funcs;

struct drm_file;

struct drm_mode_set;

struct drm_client_dev {
	struct drm_device *dev;
	const char *name;
	struct list_head list;
	const struct drm_client_funcs *funcs;
	struct drm_file *file;
	struct mutex modeset_mutex;
	struct drm_mode_set *modesets;
	bool suspended;
	bool hotplug_failed;
};

struct drm_client_funcs {
	struct module *owner;
	void (*unregister)(struct drm_client_dev *);
	int (*restore)(struct drm_client_dev *);
	int (*hotplug)(struct drm_client_dev *);
	int (*suspend)(struct drm_client_dev *, bool);
	int (*resume)(struct drm_client_dev *, bool);
};

struct drm_client_offset {
	int x;
	int y;
};

struct drm_clip_rect {
	short unsigned int x1;
	short unsigned int y1;
	short unsigned int x2;
	short unsigned int y2;
};

struct drm_connector_tv_margins {
	unsigned int bottom;
	unsigned int left;
	unsigned int right;
	unsigned int top;
};

struct drm_cmdline_mode {
	char name[32];
	bool specified;
	bool refresh_specified;
	bool bpp_specified;
	unsigned int pixel_clock;
	int xres;
	int yres;
	int bpp;
	int refresh;
	bool rb;
	bool interlace;
	bool cvt;
	bool margins;
	enum drm_connector_force force;
	unsigned int rotation_reflection;
	enum drm_panel_orientation panel_orientation;
	struct drm_connector_tv_margins tv_margins;
	enum drm_connector_tv_mode tv_mode;
	bool tv_mode_specified;
};

struct drm_color_ctm {
	__u64 matrix[9];
};

struct drm_color_lut {
	__u16 red;
	__u16 green;
	__u16 blue;
	__u16 reserved;
};

struct drm_conn_prop_enum_list {
	int type;
	const char *name;
	struct ida ida;
};

struct drm_scrambling {
	bool supported;
	bool low_rates;
};

struct drm_scdc {
	bool supported;
	bool read_request;
	struct drm_scrambling scrambling;
};

struct drm_hdmi_dsc_cap {
	bool v_1p2;
	bool native_420;
	bool all_bpp;
	u8 bpc_supported;
	u8 max_slices;
	int clk_per_slice;
	u8 max_lanes;
	u8 max_frl_rate_per_lane;
	u8 total_chunk_kbytes;
};

struct drm_hdmi_info {
	struct drm_scdc scdc;
	long unsigned int y420_vdb_modes[4];
	long unsigned int y420_cmdb_modes[4];
	u8 y420_dc_modes;
	u8 max_frl_rate_per_lane;
	u8 max_lanes;
	struct drm_hdmi_dsc_cap dsc_cap;
};

struct drm_monitor_range_info {
	u16 min_vfreq;
	u16 max_vfreq;
};

struct drm_luminance_range_info {
	u32 min_luminance;
	u32 max_luminance;
};

struct drm_display_info {
	unsigned int width_mm;
	unsigned int height_mm;
	unsigned int bpc;
	enum subpixel_order subpixel_order;
	int panel_orientation;
	u32 color_formats;
	const u32 *bus_formats;
	unsigned int num_bus_formats;
	u32 bus_flags;
	int max_tmds_clock;
	bool dvi_dual;
	bool is_hdmi;
	bool has_audio;
	bool has_hdmi_infoframe;
	bool rgb_quant_range_selectable;
	u8 edid_hdmi_rgb444_dc_modes;
	u8 edid_hdmi_ycbcr444_dc_modes;
	u8 cea_rev;
	struct drm_hdmi_info hdmi;
	bool non_desktop;
	struct drm_monitor_range_info monitor_range;
	struct drm_luminance_range_info luminance_range;
	u8 mso_stream_count;
	u8 mso_pixel_overlap;
	u32 max_dsc_bpp;
	u8 *vics;
	int vics_len;
	u32 quirks;
	u16 source_physical_address;
};

struct drm_property;

struct drm_object_properties {
	int count;
	struct drm_property *properties[64];
	uint64_t values[64];
};

struct drm_privacy_screen;

struct hdr_static_metadata {
	__u8 eotf;
	__u8 metadata_type;
	__u16 max_cll;
	__u16 max_fall;
	__u16 min_cll;
};

struct hdr_sink_metadata {
	__u32 metadata_type;
	union {
		struct hdr_static_metadata hdmi_type1;
	};
};

struct hdmi_any_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
};

struct hdmi_avi_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	bool itc;
	unsigned char pixel_repeat;
	enum hdmi_colorspace colorspace;
	enum hdmi_scan_mode scan_mode;
	enum hdmi_colorimetry colorimetry;
	enum hdmi_picture_aspect picture_aspect;
	enum hdmi_active_aspect active_aspect;
	enum hdmi_extended_colorimetry extended_colorimetry;
	enum hdmi_quantization_range quantization_range;
	enum hdmi_nups nups;
	unsigned char video_code;
	enum hdmi_ycc_quantization_range ycc_quantization_range;
	enum hdmi_content_type content_type;
	short unsigned int top_bar;
	short unsigned int bottom_bar;
	short unsigned int left_bar;
	short unsigned int right_bar;
};

struct hdmi_spd_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	char vendor[8];
	char product[16];
	enum hdmi_spd_sdi sdi;
};

struct hdmi_vendor_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned int oui;
	u8 vic;
	enum hdmi_3d_structure s3d_struct;
	unsigned int s3d_ext_data;
};

union hdmi_vendor_any_infoframe {
	struct {
		enum hdmi_infoframe_type type;
		unsigned char version;
		unsigned char length;
		unsigned int oui;
	} any;
	struct hdmi_vendor_infoframe hdmi;
};

struct hdmi_audio_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned char channels;
	enum hdmi_audio_coding_type coding_type;
	enum hdmi_audio_sample_size sample_size;
	enum hdmi_audio_sample_frequency sample_frequency;
	enum hdmi_audio_coding_type_ext coding_type_ext;
	unsigned char channel_allocation;
	unsigned char level_shift_value;
	bool downmix_inhibit;
};

struct hdmi_drm_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_eotf eotf;
	enum hdmi_metadata_type metadata_type;
	struct {
		u16 x;
		u16 y;
	} display_primaries[3];
	struct {
		u16 x;
		u16 y;
	} white_point;
	u16 max_display_mastering_luminance;
	u16 min_display_mastering_luminance;
	u16 max_cll;
	u16 max_fall;
};

union hdmi_infoframe {
	struct hdmi_any_infoframe any;
	struct hdmi_avi_infoframe avi;
	struct hdmi_spd_infoframe spd;
	union hdmi_vendor_any_infoframe vendor;
	struct hdmi_audio_infoframe audio;
	struct hdmi_drm_infoframe drm;
};

struct drm_connector_hdmi_infoframe {
	union hdmi_infoframe data;
	bool set;
};

struct drm_connector_hdmi_funcs;

struct drm_connector_hdmi {
	unsigned char vendor[8];
	unsigned char product[16];
	long unsigned int supported_formats;
	const struct drm_connector_hdmi_funcs *funcs;
	struct {
		struct mutex lock;
		struct drm_connector_hdmi_infoframe audio;
	} infoframes;
};

struct drm_connector_hdmi_audio_funcs;

struct drm_connector_hdmi_audio {
	const struct drm_connector_hdmi_audio_funcs *funcs;
	struct platform_device *codec_pdev;
	struct mutex lock;
	void (*plugged_cb)(struct device *, bool);
	struct device *plugged_cb_dev;
	bool last_state;
	int dai_port;
};

struct drm_connector_funcs;

struct drm_property_blob;

struct drm_connector_helper_funcs;

struct drm_tile_group;

struct drm_connector {
	struct drm_device *dev;
	struct device *kdev;
	struct device_attribute *attr;
	struct fwnode_handle *fwnode;
	struct list_head head;
	struct list_head global_connector_list_entry;
	struct drm_mode_object base;
	char *name;
	struct mutex mutex;
	unsigned int index;
	int connector_type;
	int connector_type_id;
	bool interlace_allowed;
	bool doublescan_allowed;
	bool stereo_allowed;
	bool ycbcr_420_allowed;
	enum drm_connector_registration_state registration_state;
	struct list_head modes;
	enum drm_connector_status status;
	struct list_head probed_modes;
	struct drm_display_info display_info;
	const struct drm_connector_funcs *funcs;
	struct drm_property_blob *edid_blob_ptr;
	struct drm_object_properties properties;
	struct drm_property *scaling_mode_property;
	struct drm_property *vrr_capable_property;
	struct drm_property *colorspace_property;
	struct drm_property_blob *path_blob_ptr;
	unsigned int max_bpc;
	struct drm_property *max_bpc_property;
	struct drm_privacy_screen *privacy_screen;
	struct notifier_block privacy_screen_notifier;
	struct drm_property *privacy_screen_sw_state_property;
	struct drm_property *privacy_screen_hw_state_property;
	struct drm_property *broadcast_rgb_property;
	uint8_t polled;
	int dpms;
	const struct drm_connector_helper_funcs *helper_private;
	struct drm_cmdline_mode cmdline_mode;
	enum drm_connector_force force;
	const struct drm_edid *edid_override;
	struct mutex edid_override_mutex;
	u64 epoch_counter;
	u32 possible_encoders;
	struct drm_encoder *encoder;
	uint8_t eld[128];
	struct mutex eld_mutex;
	bool latency_present[2];
	int video_latency[2];
	int audio_latency[2];
	struct i2c_adapter *ddc;
	int null_edid_counter;
	unsigned int bad_edid_counter;
	bool edid_corrupt;
	u8 real_edid_checksum;
	struct dentry *debugfs_entry;
	struct drm_connector_state *state;
	struct drm_property_blob *tile_blob_ptr;
	bool has_tile;
	struct drm_tile_group *tile_group;
	bool tile_is_single_monitor;
	uint8_t num_h_tile;
	uint8_t num_v_tile;
	uint8_t tile_h_loc;
	uint8_t tile_v_loc;
	uint16_t tile_h_size;
	uint16_t tile_v_size;
	struct llist_node free_node;
	struct hdr_sink_metadata hdr_sink_metadata;
	struct drm_connector_hdmi hdmi;
	struct drm_connector_hdmi_audio hdmi_audio;
};

struct drm_printer;

struct drm_connector_funcs {
	int (*dpms)(struct drm_connector *, int);
	void (*reset)(struct drm_connector *);
	enum drm_connector_status (*detect)(struct drm_connector *, bool);
	void (*force)(struct drm_connector *);
	int (*fill_modes)(struct drm_connector *, uint32_t, uint32_t);
	int (*set_property)(struct drm_connector *, struct drm_property *, uint64_t);
	int (*late_register)(struct drm_connector *);
	void (*early_unregister)(struct drm_connector *);
	void (*destroy)(struct drm_connector *);
	struct drm_connector_state * (*atomic_duplicate_state)(struct drm_connector *);
	void (*atomic_destroy_state)(struct drm_connector *, struct drm_connector_state *);
	int (*atomic_set_property)(struct drm_connector *, struct drm_connector_state *, struct drm_property *, uint64_t);
	int (*atomic_get_property)(struct drm_connector *, const struct drm_connector_state *, struct drm_property *, uint64_t *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_connector_state *);
	void (*oob_hotplug_event)(struct drm_connector *, enum drm_connector_status);
	void (*debugfs_init)(struct drm_connector *, struct dentry *);
};

struct drm_connector_hdmi_audio_funcs {
	int (*startup)(struct drm_connector *);
	int (*prepare)(struct drm_connector *, struct hdmi_codec_daifmt *, struct hdmi_codec_params *);
	void (*shutdown)(struct drm_connector *);
	int (*mute_stream)(struct drm_connector *, bool, int);
};

struct drm_connector_hdmi_funcs {
	enum drm_mode_status (*tmds_char_rate_valid)(const struct drm_connector *, const struct drm_display_mode *, long long unsigned int);
	int (*clear_infoframe)(struct drm_connector *, enum hdmi_infoframe_type);
	int (*write_infoframe)(struct drm_connector *, enum hdmi_infoframe_type, const u8 *, size_t);
	const struct drm_edid * (*read_edid)(struct drm_connector *);
};

struct drm_connector_hdmi_state {
	enum drm_hdmi_broadcast_rgb broadcast_rgb;
	struct {
		struct drm_connector_hdmi_infoframe avi;
		struct drm_connector_hdmi_infoframe hdr_drm;
		struct drm_connector_hdmi_infoframe spd;
		struct drm_connector_hdmi_infoframe hdmi;
	} infoframes;
	bool is_limited_range;
	unsigned int output_bpc;
	enum hdmi_colorspace output_format;
	long long unsigned int tmds_char_rate;
};

struct drm_writeback_connector;

struct drm_writeback_job;

struct drm_connector_helper_funcs {
	int (*get_modes)(struct drm_connector *);
	int (*detect_ctx)(struct drm_connector *, struct drm_modeset_acquire_ctx *, bool);
	enum drm_mode_status (*mode_valid)(struct drm_connector *, struct drm_display_mode *);
	int (*mode_valid_ctx)(struct drm_connector *, struct drm_display_mode *, struct drm_modeset_acquire_ctx *, enum drm_mode_status *);
	struct drm_encoder * (*best_encoder)(struct drm_connector *);
	struct drm_encoder * (*atomic_best_encoder)(struct drm_connector *, struct drm_atomic_state *);
	int (*atomic_check)(struct drm_connector *, struct drm_atomic_state *);
	void (*atomic_commit)(struct drm_connector *, struct drm_atomic_state *);
	int (*prepare_writeback_job)(struct drm_writeback_connector *, struct drm_writeback_job *);
	void (*cleanup_writeback_job)(struct drm_writeback_connector *, struct drm_writeback_job *);
	void (*enable_hpd)(struct drm_connector *);
	void (*disable_hpd)(struct drm_connector *);
};

struct drm_connector_list_iter {
	struct drm_device *dev;
	struct drm_connector *conn;
};

struct drm_tv_connector_state {
	enum drm_mode_subconnector select_subconnector;
	enum drm_mode_subconnector subconnector;
	struct drm_connector_tv_margins margins;
	unsigned int legacy_mode;
	unsigned int mode;
	unsigned int brightness;
	unsigned int contrast;
	unsigned int flicker_reduction;
	unsigned int overscan;
	unsigned int saturation;
	unsigned int hue;
};

struct drm_connector_state {
	struct drm_connector *connector;
	struct drm_crtc *crtc;
	struct drm_encoder *best_encoder;
	enum drm_link_status link_status;
	struct drm_atomic_state *state;
	struct drm_crtc_commit *commit;
	struct drm_tv_connector_state tv;
	bool self_refresh_aware;
	enum hdmi_picture_aspect picture_aspect_ratio;
	unsigned int content_type;
	unsigned int hdcp_content_type;
	unsigned int scaling_mode;
	unsigned int content_protection;
	enum drm_colorspace colorspace;
	struct drm_writeback_job *writeback_job;
	u8 max_requested_bpc;
	u8 max_bpc;
	enum drm_privacy_screen_status privacy_screen_sw_state;
	struct drm_property_blob *hdr_output_metadata;
	struct drm_connector_hdmi_state hdmi;
};

struct drm_display_mode {
	int clock;
	u16 hdisplay;
	u16 hsync_start;
	u16 hsync_end;
	u16 htotal;
	u16 hskew;
	u16 vdisplay;
	u16 vsync_start;
	u16 vsync_end;
	u16 vtotal;
	u16 vscan;
	u32 flags;
	int crtc_clock;
	u16 crtc_hdisplay;
	u16 crtc_hblank_start;
	u16 crtc_hblank_end;
	u16 crtc_hsync_start;
	u16 crtc_hsync_end;
	u16 crtc_htotal;
	u16 crtc_hskew;
	u16 crtc_vdisplay;
	u16 crtc_vblank_start;
	u16 crtc_vblank_end;
	u16 crtc_vsync_start;
	u16 crtc_vsync_end;
	u16 crtc_vtotal;
	u16 width_mm;
	u16 height_mm;
	u8 type;
	bool expose_to_userspace;
	struct list_head head;
	char name[32];
	enum drm_mode_status status;
	enum hdmi_picture_aspect picture_aspect_ratio;
};

struct drm_crtc_crc_entry;

struct drm_crtc_crc {
	spinlock_t lock;
	const char *source;
	bool opened;
	bool overflow;
	struct drm_crtc_crc_entry *entries;
	int head;
	int tail;
	size_t values_cnt;
	wait_queue_head_t wq;
};

struct drm_crtc_funcs;

struct drm_crtc_helper_funcs;

struct drm_self_refresh_data;

struct drm_crtc {
	struct drm_device *dev;
	struct device_node *port;
	struct list_head head;
	char *name;
	struct drm_modeset_lock mutex;
	struct drm_mode_object base;
	struct drm_plane *primary;
	struct drm_plane *cursor;
	unsigned int index;
	int cursor_x;
	int cursor_y;
	bool enabled;
	struct drm_display_mode mode;
	struct drm_display_mode hwmode;
	int x;
	int y;
	const struct drm_crtc_funcs *funcs;
	uint32_t gamma_size;
	uint16_t *gamma_store;
	const struct drm_crtc_helper_funcs *helper_private;
	struct drm_object_properties properties;
	struct drm_property *scaling_filter_property;
	struct drm_crtc_state *state;
	struct list_head commit_list;
	spinlock_t commit_lock;
	struct dentry *debugfs_entry;
	struct drm_crtc_crc crc;
	unsigned int fence_context;
	spinlock_t fence_lock;
	long unsigned int fence_seqno;
	char timeline_name[32];
	struct drm_self_refresh_data *self_refresh_data;
};

struct drm_pending_vblank_event;

struct drm_crtc_commit {
	struct drm_crtc *crtc;
	struct kref ref;
	struct completion flip_done;
	struct completion hw_done;
	struct completion cleanup_done;
	struct list_head commit_entry;
	struct drm_pending_vblank_event *event;
	bool abort_completion;
};

struct drm_crtc_crc_entry {
	bool has_frame_counter;
	uint32_t frame;
	uint32_t crcs[10];
};

struct drm_crtc_funcs {
	void (*reset)(struct drm_crtc *);
	int (*cursor_set)(struct drm_crtc *, struct drm_file *, uint32_t, uint32_t, uint32_t);
	int (*cursor_set2)(struct drm_crtc *, struct drm_file *, uint32_t, uint32_t, uint32_t, int32_t, int32_t);
	int (*cursor_move)(struct drm_crtc *, int, int);
	int (*gamma_set)(struct drm_crtc *, u16 *, u16 *, u16 *, uint32_t, struct drm_modeset_acquire_ctx *);
	void (*destroy)(struct drm_crtc *);
	int (*set_config)(struct drm_mode_set *, struct drm_modeset_acquire_ctx *);
	int (*page_flip)(struct drm_crtc *, struct drm_framebuffer *, struct drm_pending_vblank_event *, uint32_t, struct drm_modeset_acquire_ctx *);
	int (*page_flip_target)(struct drm_crtc *, struct drm_framebuffer *, struct drm_pending_vblank_event *, uint32_t, uint32_t, struct drm_modeset_acquire_ctx *);
	int (*set_property)(struct drm_crtc *, struct drm_property *, uint64_t);
	struct drm_crtc_state * (*atomic_duplicate_state)(struct drm_crtc *);
	void (*atomic_destroy_state)(struct drm_crtc *, struct drm_crtc_state *);
	int (*atomic_set_property)(struct drm_crtc *, struct drm_crtc_state *, struct drm_property *, uint64_t);
	int (*atomic_get_property)(struct drm_crtc *, const struct drm_crtc_state *, struct drm_property *, uint64_t *);
	int (*late_register)(struct drm_crtc *);
	void (*early_unregister)(struct drm_crtc *);
	int (*set_crc_source)(struct drm_crtc *, const char *);
	int (*verify_crc_source)(struct drm_crtc *, const char *, size_t *);
	const char * const * (*get_crc_sources)(struct drm_crtc *, size_t *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_crtc_state *);
	u32 (*get_vblank_counter)(struct drm_crtc *);
	int (*enable_vblank)(struct drm_crtc *);
	void (*disable_vblank)(struct drm_crtc *);
	bool (*get_vblank_timestamp)(struct drm_crtc *, int *, ktime_t *, bool);
};

struct drm_crtc_get_sequence {
	__u32 crtc_id;
	__u32 active;
	__u64 sequence;
	__s64 sequence_ns;
};

struct drm_crtc_helper_funcs {
	void (*dpms)(struct drm_crtc *, int);
	void (*prepare)(struct drm_crtc *);
	void (*commit)(struct drm_crtc *);
	enum drm_mode_status (*mode_valid)(struct drm_crtc *, const struct drm_display_mode *);
	bool (*mode_fixup)(struct drm_crtc *, const struct drm_display_mode *, struct drm_display_mode *);
	int (*mode_set)(struct drm_crtc *, struct drm_display_mode *, struct drm_display_mode *, int, int, struct drm_framebuffer *);
	void (*mode_set_nofb)(struct drm_crtc *);
	int (*mode_set_base)(struct drm_crtc *, int, int, struct drm_framebuffer *);
	int (*mode_set_base_atomic)(struct drm_crtc *, struct drm_framebuffer *, int, int, enum mode_set_atomic);
	void (*disable)(struct drm_crtc *);
	int (*atomic_check)(struct drm_crtc *, struct drm_atomic_state *);
	void (*atomic_begin)(struct drm_crtc *, struct drm_atomic_state *);
	void (*atomic_flush)(struct drm_crtc *, struct drm_atomic_state *);
	void (*atomic_enable)(struct drm_crtc *, struct drm_atomic_state *);
	void (*atomic_disable)(struct drm_crtc *, struct drm_atomic_state *);
	bool (*get_scanout_position)(struct drm_crtc *, bool, int *, int *, ktime_t *, ktime_t *, const struct drm_display_mode *);
};

struct drm_crtc_queue_sequence {
	__u32 crtc_id;
	__u32 flags;
	__u64 sequence;
	__u64 user_data;
};

struct drm_crtc_state {
	struct drm_crtc *crtc;
	bool enable;
	bool active;
	bool planes_changed: 1;
	bool mode_changed: 1;
	bool active_changed: 1;
	bool connectors_changed: 1;
	bool zpos_changed: 1;
	bool color_mgmt_changed: 1;
	bool no_vblank: 1;
	u32 plane_mask;
	u32 connector_mask;
	u32 encoder_mask;
	struct drm_display_mode adjusted_mode;
	struct drm_display_mode mode;
	struct drm_property_blob *mode_blob;
	struct drm_property_blob *degamma_lut;
	struct drm_property_blob *ctm;
	struct drm_property_blob *gamma_lut;
	u32 target_vblank;
	bool async_flip;
	bool vrr_enabled;
	bool self_refresh_active;
	enum drm_scaling_filter scaling_filter;
	struct drm_pending_vblank_event *event;
	struct drm_crtc_commit *commit;
	struct drm_atomic_state *state;
};

struct drm_debugfs_info {
	const char *name;
	int (*show)(struct seq_file *, void *);
	u32 driver_features;
	void *data;
};

struct drm_debugfs_entry {
	struct drm_device *dev;
	struct drm_debugfs_info file;
	struct list_head list;
};

struct drm_mode_config_funcs;

struct drm_mode_config_helper_funcs;

struct drm_mode_config {
	struct mutex mutex;
	struct drm_modeset_lock connection_mutex;
	struct drm_modeset_acquire_ctx *acquire_ctx;
	struct mutex idr_mutex;
	struct idr object_idr;
	struct idr tile_idr;
	struct mutex fb_lock;
	int num_fb;
	struct list_head fb_list;
	spinlock_t connector_list_lock;
	int num_connector;
	struct ida connector_ida;
	struct list_head connector_list;
	struct llist_head connector_free_list;
	struct work_struct connector_free_work;
	int num_encoder;
	struct list_head encoder_list;
	int num_total_plane;
	struct list_head plane_list;
	struct raw_spinlock panic_lock;
	int num_crtc;
	struct list_head crtc_list;
	struct list_head property_list;
	struct list_head privobj_list;
	int min_width;
	int min_height;
	int max_width;
	int max_height;
	const struct drm_mode_config_funcs *funcs;
	bool poll_enabled;
	bool poll_running;
	bool delayed_event;
	struct delayed_work output_poll_work;
	struct mutex blob_lock;
	struct list_head property_blob_list;
	struct drm_property *edid_property;
	struct drm_property *dpms_property;
	struct drm_property *path_property;
	struct drm_property *tile_property;
	struct drm_property *link_status_property;
	struct drm_property *plane_type_property;
	struct drm_property *prop_src_x;
	struct drm_property *prop_src_y;
	struct drm_property *prop_src_w;
	struct drm_property *prop_src_h;
	struct drm_property *prop_crtc_x;
	struct drm_property *prop_crtc_y;
	struct drm_property *prop_crtc_w;
	struct drm_property *prop_crtc_h;
	struct drm_property *prop_fb_id;
	struct drm_property *prop_in_fence_fd;
	struct drm_property *prop_out_fence_ptr;
	struct drm_property *prop_crtc_id;
	struct drm_property *prop_fb_damage_clips;
	struct drm_property *prop_active;
	struct drm_property *prop_mode_id;
	struct drm_property *prop_vrr_enabled;
	struct drm_property *dvi_i_subconnector_property;
	struct drm_property *dvi_i_select_subconnector_property;
	struct drm_property *dp_subconnector_property;
	struct drm_property *tv_subconnector_property;
	struct drm_property *tv_select_subconnector_property;
	struct drm_property *legacy_tv_mode_property;
	struct drm_property *tv_mode_property;
	struct drm_property *tv_left_margin_property;
	struct drm_property *tv_right_margin_property;
	struct drm_property *tv_top_margin_property;
	struct drm_property *tv_bottom_margin_property;
	struct drm_property *tv_brightness_property;
	struct drm_property *tv_contrast_property;
	struct drm_property *tv_flicker_reduction_property;
	struct drm_property *tv_overscan_property;
	struct drm_property *tv_saturation_property;
	struct drm_property *tv_hue_property;
	struct drm_property *scaling_mode_property;
	struct drm_property *aspect_ratio_property;
	struct drm_property *content_type_property;
	struct drm_property *degamma_lut_property;
	struct drm_property *degamma_lut_size_property;
	struct drm_property *ctm_property;
	struct drm_property *gamma_lut_property;
	struct drm_property *gamma_lut_size_property;
	struct drm_property *suggested_x_property;
	struct drm_property *suggested_y_property;
	struct drm_property *non_desktop_property;
	struct drm_property *panel_orientation_property;
	struct drm_property *writeback_fb_id_property;
	struct drm_property *writeback_pixel_formats_property;
	struct drm_property *writeback_out_fence_ptr_property;
	struct drm_property *hdr_output_metadata_property;
	struct drm_property *content_protection_property;
	struct drm_property *hdcp_content_type_property;
	uint32_t preferred_depth;
	uint32_t prefer_shadow;
	bool quirk_addfb_prefer_xbgr_30bpp;
	bool quirk_addfb_prefer_host_byte_order;
	bool async_page_flip;
	bool fb_modifiers_not_supported;
	bool normalize_zpos;
	struct drm_property *modifiers_property;
	struct drm_property *size_hints_property;
	uint32_t cursor_width;
	uint32_t cursor_height;
	struct drm_atomic_state *suspend_state;
	const struct drm_mode_config_helper_funcs *helper_private;
};

struct drm_vram_mm;

struct drm_driver;

struct drm_minor;

struct drm_master;

struct drm_vblank_crtc;

struct drm_vma_offset_manager;

struct drm_fb_helper;

struct drm_device {
	int if_version;
	struct kref ref;
	struct device *dev;
	struct {
		struct list_head resources;
		void *final_kfree;
		spinlock_t lock;
	} managed;
	const struct drm_driver *driver;
	void *dev_private;
	struct drm_minor *primary;
	struct drm_minor *render;
	struct drm_minor *accel;
	bool registered;
	struct drm_master *master;
	u32 driver_features;
	bool unplugged;
	struct inode *anon_inode;
	char *unique;
	struct mutex struct_mutex;
	struct mutex master_mutex;
	atomic_t open_count;
	struct mutex filelist_mutex;
	struct list_head filelist;
	struct list_head filelist_internal;
	struct mutex clientlist_mutex;
	struct list_head clientlist;
	bool vblank_disable_immediate;
	struct drm_vblank_crtc *vblank;
	spinlock_t vblank_time_lock;
	spinlock_t vbl_lock;
	u32 max_vblank_count;
	struct list_head vblank_event_list;
	spinlock_t event_lock;
	unsigned int num_crtcs;
	struct drm_mode_config mode_config;
	struct mutex object_name_lock;
	struct idr object_name_idr;
	struct drm_vma_offset_manager *vma_offset_manager;
	struct drm_vram_mm *vram_mm;
	enum switch_power_state switch_power_state;
	struct drm_fb_helper *fb_helper;
	struct dentry *debugfs_root;
};

struct drm_dmi_panel_orientation_data {
	int width;
	int height;
	const char * const *bios_dates;
	int orientation;
};

struct drm_dp_as_sdp {
	unsigned char sdp_type;
	unsigned char revision;
	unsigned char length;
	int vtotal;
	int target_rr;
	int duration_incr_ms;
	int duration_decr_ms;
	bool target_rr_divider;
	enum operation_mode mode;
};

struct rt_mutex_base {
	raw_spinlock_t wait_lock;
	struct rb_root_cached waiters;
	struct task_struct *owner;
};

struct rt_mutex {
	struct rt_mutex_base rtmutex;
};

struct i2c_algorithm;

struct i2c_lock_operations;

struct i2c_bus_recovery_info;

struct i2c_adapter_quirks;

struct i2c_adapter {
	struct module *owner;
	unsigned int class;
	const struct i2c_algorithm *algo;
	void *algo_data;
	const struct i2c_lock_operations *lock_ops;
	struct rt_mutex bus_lock;
	struct rt_mutex mux_lock;
	int timeout;
	int retries;
	struct device dev;
	long unsigned int locked_flags;
	int nr;
	char name[48];
	struct completion dev_released;
	struct mutex userspace_clients_lock;
	struct list_head userspace_clients;
	struct i2c_bus_recovery_info *bus_recovery_info;
	const struct i2c_adapter_quirks *quirks;
	struct irq_domain *host_notify_domain;
	struct regulator *bus_regulator;
	struct dentry *debugfs;
	long unsigned int addrs_in_instantiation[2];
};

struct drm_dp_aux_cec {
	struct mutex lock;
	struct cec_adapter *adap;
	struct drm_connector *connector;
	struct delayed_work unregister_work;
};

struct drm_dp_aux_msg;

struct drm_dp_aux {
	const char *name;
	struct i2c_adapter ddc;
	struct device *dev;
	struct drm_device *drm_dev;
	struct drm_crtc *crtc;
	struct mutex hw_mutex;
	struct work_struct crc_work;
	u8 crc_count;
	ssize_t (*transfer)(struct drm_dp_aux *, struct drm_dp_aux_msg *);
	int (*wait_hpd_asserted)(struct drm_dp_aux *, long unsigned int);
	unsigned int i2c_nack_count;
	unsigned int i2c_defer_count;
	struct drm_dp_aux_cec cec;
	bool is_remote;
	bool powered_down;
};

struct drm_dp_aux_msg {
	unsigned int address;
	u8 request;
	u8 reply;
	void *buffer;
	size_t size;
};

struct drm_dp_dpcd_ident {
	u8 oui[3];
	u8 device_id[6];
	u8 hw_rev;
	u8 sw_major_rev;
	u8 sw_minor_rev;
};

struct drm_dp_desc {
	struct drm_dp_dpcd_ident ident;
	u32 quirks;
};

struct drm_dp_mst_port;

struct drm_dp_mst_atomic_payload {
	struct drm_dp_mst_port *port;
	s8 vc_start_slot;
	u8 vcpi;
	int time_slots;
	int pbn;
	bool delete: 1;
	bool dsc_enabled: 1;
	enum drm_dp_mst_payload_allocation payload_allocation_status;
	struct list_head next;
};

struct drm_dp_mst_topology_mgr;

struct drm_dp_mst_branch {
	struct kref topology_kref;
	struct kref malloc_kref;
	struct list_head destroy_next;
	u8 rad[8];
	u8 lct;
	int num_ports;
	struct list_head ports;
	struct drm_dp_mst_port *port_parent;
	struct drm_dp_mst_topology_mgr *mgr;
	bool link_address_sent;
	guid_t guid;
};

struct drm_dp_mst_port {
	struct kref topology_kref;
	struct kref malloc_kref;
	u8 port_num;
	bool input;
	bool mcs;
	bool ddps;
	u8 pdt;
	bool ldps;
	u8 dpcd_rev;
	u8 num_sdp_streams;
	u8 num_sdp_stream_sinks;
	uint16_t full_pbn;
	struct list_head next;
	struct drm_dp_mst_branch *mstb;
	struct drm_dp_aux aux;
	struct drm_dp_aux *passthrough_aux;
	struct drm_dp_mst_branch *parent;
	struct drm_connector *connector;
	struct drm_dp_mst_topology_mgr *mgr;
	const struct drm_edid *cached_edid;
	bool fec_capable;
};

struct drm_dp_mst_topology_cbs {
	struct drm_connector * (*add_connector)(struct drm_dp_mst_topology_mgr *, struct drm_dp_mst_port *, const char *);
	void (*poll_hpd_irq)(struct drm_dp_mst_topology_mgr *);
};

struct drm_dp_sideband_msg_hdr {
	u8 lct;
	u8 lcr;
	u8 rad[8];
	bool broadcast;
	bool path_msg;
	u8 msg_len;
	bool somt;
	bool eomt;
	bool seqno;
};

struct drm_dp_sideband_msg_rx {
	u8 chunk[48];
	u8 msg[256];
	u8 curchunk_len;
	u8 curchunk_idx;
	u8 curchunk_hdrlen;
	u8 curlen;
	bool have_somt;
	bool have_eomt;
	struct drm_dp_sideband_msg_hdr initial_hdr;
};

struct drm_dp_mst_topology_mgr {
	struct drm_private_obj base;
	struct drm_device *dev;
	const struct drm_dp_mst_topology_cbs *cbs;
	int max_dpcd_transaction_bytes;
	struct drm_dp_aux *aux;
	int max_payloads;
	int conn_base_id;
	struct drm_dp_sideband_msg_rx up_req_recv;
	struct drm_dp_sideband_msg_rx down_rep_recv;
	struct mutex lock;
	struct mutex probe_lock;
	bool mst_state: 1;
	bool payload_id_table_cleared: 1;
	bool reset_rx_state: 1;
	u8 payload_count;
	u8 next_start_slot;
	struct drm_dp_mst_branch *mst_primary;
	u8 dpcd[15];
	u8 sink_count;
	const struct drm_private_state_funcs *funcs;
	struct mutex qlock;
	struct list_head tx_msg_downq;
	wait_queue_head_t tx_waitq;
	struct work_struct work;
	struct work_struct tx_work;
	struct list_head destroy_port_list;
	struct list_head destroy_branch_device_list;
	struct mutex delayed_destroy_lock;
	struct workqueue_struct *delayed_destroy_wq;
	struct work_struct delayed_destroy_work;
	struct list_head up_req_list;
	struct mutex up_req_lock;
	struct work_struct up_req_work;
};

struct drm_dp_mst_topology_state {
	struct drm_private_state base;
	struct drm_dp_mst_topology_mgr *mgr;
	u32 pending_crtc_mask;
	struct drm_crtc_commit **commit_deps;
	size_t num_commit_deps;
	u32 payload_mask;
	struct list_head payloads;
	u8 total_avail_slots;
	u8 start_slot;
	fixed20_12 pbn_div;
};

struct drm_dp_sideband_msg_req_body {
	u8 req_type;
	union ack_req u;
};

struct drm_dp_pending_up_req {
	struct drm_dp_sideband_msg_hdr hdr;
	struct drm_dp_sideband_msg_req_body msg;
	struct list_head next;
};

struct drm_dp_phy_test_params {
	int link_rate;
	u8 num_lanes;
	u8 phy_pattern;
	u8 hbr2_reset[2];
	u8 custom80[10];
	bool enhanced_frame_cap;
};

struct drm_dp_sideband_msg_reply_body {
	u8 reply_type;
	u8 req_type;
	union ack_replies u;
};

struct drm_dp_sideband_msg_tx {
	u8 msg[256];
	u8 chunk[48];
	u8 cur_offset;
	u8 cur_len;
	struct drm_dp_mst_branch *dst;
	struct list_head next;
	int seqno;
	int state;
	bool path_msg;
	struct drm_dp_sideband_msg_reply_body reply;
};

struct drm_dp_tunnel;

struct ref_tracker;

struct drm_dp_tunnel_ref {
	struct drm_dp_tunnel *tunnel;
	struct ref_tracker *tracker;
};

struct drm_dp_vsc_sdp {
	unsigned char sdp_type;
	unsigned char revision;
	unsigned char length;
	enum dp_pixelformat pixelformat;
	enum dp_colorimetry colorimetry;
	int bpc;
	enum dp_dynamic_range dynamic_range;
	enum dp_content_type content_type;
};

struct drm_mode_create_dumb;

struct drm_fb_helper_surface_size;

struct drm_ioctl_desc;

struct drm_driver {
	int (*load)(struct drm_device *, long unsigned int);
	int (*open)(struct drm_device *, struct drm_file *);
	void (*postclose)(struct drm_device *, struct drm_file *);
	void (*unload)(struct drm_device *);
	void (*release)(struct drm_device *);
	void (*master_set)(struct drm_device *, struct drm_file *, bool);
	void (*master_drop)(struct drm_device *, struct drm_file *);
	void (*debugfs_init)(struct drm_minor *);
	struct drm_gem_object * (*gem_create_object)(struct drm_device *, size_t);
	int (*prime_handle_to_fd)(struct drm_device *, struct drm_file *, uint32_t, uint32_t, int *);
	int (*prime_fd_to_handle)(struct drm_device *, struct drm_file *, int, uint32_t *);
	struct drm_gem_object * (*gem_prime_import)(struct drm_device *, struct dma_buf *);
	struct drm_gem_object * (*gem_prime_import_sg_table)(struct drm_device *, struct dma_buf_attachment *, struct sg_table *);
	int (*dumb_create)(struct drm_file *, struct drm_device *, struct drm_mode_create_dumb *);
	int (*dumb_map_offset)(struct drm_file *, struct drm_device *, uint32_t, uint64_t *);
	int (*fbdev_probe)(struct drm_fb_helper *, struct drm_fb_helper_surface_size *);
	void (*show_fdinfo)(struct drm_printer *, struct drm_file *);
	int major;
	int minor;
	int patchlevel;
	char *name;
	char *desc;
	u32 driver_features;
	const struct drm_ioctl_desc *ioctls;
	int num_ioctls;
	const struct file_operations *fops;
};

struct drm_dsc_rc_range_parameters {
	u8 range_min_qp;
	u8 range_max_qp;
	u8 range_bpg_offset;
};

struct drm_dsc_config {
	u8 line_buf_depth;
	u8 bits_per_component;
	bool convert_rgb;
	u8 slice_count;
	u16 slice_width;
	u16 slice_height;
	bool simple_422;
	u16 pic_width;
	u16 pic_height;
	u8 rc_tgt_offset_high;
	u8 rc_tgt_offset_low;
	u16 bits_per_pixel;
	u8 rc_edge_factor;
	u8 rc_quant_incr_limit1;
	u8 rc_quant_incr_limit0;
	u16 initial_xmit_delay;
	u16 initial_dec_delay;
	bool block_pred_enable;
	u8 first_line_bpg_offset;
	u16 initial_offset;
	u16 rc_buf_thresh[14];
	struct drm_dsc_rc_range_parameters rc_range_params[15];
	u16 rc_model_size;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	u8 initial_scale_value;
	u16 scale_decrement_interval;
	u16 scale_increment_interval;
	u16 nfl_bpg_offset;
	u16 slice_bpg_offset;
	u16 final_offset;
	bool vbr_enable;
	u8 mux_word_size;
	u16 slice_chunk_size;
	u16 rc_bits;
	u8 dsc_version_minor;
	u8 dsc_version_major;
	bool native_422;
	bool native_420;
	u8 second_line_bpg_offset;
	u16 nsl_bpg_offset;
	u16 second_line_offset_adj;
};

struct drm_dsc_picture_parameter_set {
	u8 dsc_version;
	u8 pps_identifier;
	u8 pps_reserved;
	u8 pps_3;
	u8 pps_4;
	u8 bits_per_pixel_low;
	__be16 pic_height;
	__be16 pic_width;
	__be16 slice_height;
	__be16 slice_width;
	__be16 chunk_size;
	u8 initial_xmit_delay_high;
	u8 initial_xmit_delay_low;
	__be16 initial_dec_delay;
	u8 pps20_reserved;
	u8 initial_scale_value;
	__be16 scale_increment_interval;
	u8 scale_decrement_interval_high;
	u8 scale_decrement_interval_low;
	u8 pps26_reserved;
	u8 first_line_bpg_offset;
	__be16 nfl_bpg_offset;
	__be16 slice_bpg_offset;
	__be16 initial_offset;
	__be16 final_offset;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	__be16 rc_model_size;
	u8 rc_edge_factor;
	u8 rc_quant_incr_limit0;
	u8 rc_quant_incr_limit1;
	u8 rc_tgt_offset;
	u8 rc_buf_thresh[14];
	__be16 rc_range_parameters[15];
	u8 native_422_420;
	u8 second_line_bpg_offset;
	__be16 nsl_bpg_offset;
	__be16 second_line_offset_adj;
	u32 pps_long_94_reserved;
	u32 pps_long_98_reserved;
	u32 pps_long_102_reserved;
	u32 pps_long_106_reserved;
	u32 pps_long_110_reserved;
	u32 pps_long_114_reserved;
	u32 pps_long_118_reserved;
	u32 pps_long_122_reserved;
	__be16 pps_short_126_reserved;
} __attribute__((packed));

struct drm_dsc_pps_infoframe {
	struct dp_sdp_header pps_header;
	struct drm_dsc_picture_parameter_set pps_payload;
};

struct edid;

struct drm_edid {
	size_t size;
	const struct edid *edid;
};

struct drm_edid_ident {
	u32 panel_id;
	const char *name;
};

struct drm_edid_match_closure {
	const struct drm_edid_ident *ident;
	bool matched;
};

struct drm_edid_product_id {
	__be16 manufacturer_name;
	__le16 product_code;
	__le32 serial_number;
	u8 week_of_manufacture;
	u8 year_of_manufacture;
} __attribute__((packed));

struct drm_encoder_funcs;

struct drm_encoder_helper_funcs;

struct drm_encoder {
	struct drm_device *dev;
	struct list_head head;
	struct drm_mode_object base;
	char *name;
	int encoder_type;
	unsigned int index;
	uint32_t possible_crtcs;
	uint32_t possible_clones;
	struct drm_crtc *crtc;
	struct list_head bridge_chain;
	const struct drm_encoder_funcs *funcs;
	const struct drm_encoder_helper_funcs *helper_private;
	struct dentry *debugfs_entry;
};

struct drm_encoder_funcs {
	void (*reset)(struct drm_encoder *);
	void (*destroy)(struct drm_encoder *);
	int (*late_register)(struct drm_encoder *);
	void (*early_unregister)(struct drm_encoder *);
	void (*debugfs_init)(struct drm_encoder *, struct dentry *);
};

struct drm_encoder_helper_funcs {
	void (*dpms)(struct drm_encoder *, int);
	enum drm_mode_status (*mode_valid)(struct drm_encoder *, const struct drm_display_mode *);
	bool (*mode_fixup)(struct drm_encoder *, const struct drm_display_mode *, struct drm_display_mode *);
	void (*prepare)(struct drm_encoder *);
	void (*commit)(struct drm_encoder *);
	void (*mode_set)(struct drm_encoder *, struct drm_display_mode *, struct drm_display_mode *);
	void (*atomic_mode_set)(struct drm_encoder *, struct drm_crtc_state *, struct drm_connector_state *);
	enum drm_connector_status (*detect)(struct drm_encoder *, struct drm_connector *);
	void (*atomic_disable)(struct drm_encoder *, struct drm_atomic_state *);
	void (*atomic_enable)(struct drm_encoder *, struct drm_atomic_state *);
	void (*disable)(struct drm_encoder *);
	void (*enable)(struct drm_encoder *);
	int (*atomic_check)(struct drm_encoder *, struct drm_crtc_state *, struct drm_connector_state *);
};

struct drm_encoder_slave_funcs;

struct drm_encoder_slave {
	struct drm_encoder base;
	const struct drm_encoder_slave_funcs *slave_funcs;
	void *slave_priv;
	void *bus_priv;
};

struct drm_encoder_slave_funcs {
	void (*set_config)(struct drm_encoder *, void *);
	void (*destroy)(struct drm_encoder *);
	void (*dpms)(struct drm_encoder *, int);
	void (*save)(struct drm_encoder *);
	void (*restore)(struct drm_encoder *);
	bool (*mode_fixup)(struct drm_encoder *, const struct drm_display_mode *, struct drm_display_mode *);
	int (*mode_valid)(struct drm_encoder *, struct drm_display_mode *);
	void (*mode_set)(struct drm_encoder *, struct drm_display_mode *, struct drm_display_mode *);
	enum drm_connector_status (*detect)(struct drm_encoder *, struct drm_connector *);
	int (*get_modes)(struct drm_encoder *, struct drm_connector *);
	int (*create_resources)(struct drm_encoder *, struct drm_connector *);
	int (*set_property)(struct drm_encoder *, struct drm_connector *, struct drm_property *, uint64_t);
};

struct drm_event {
	__u32 type;
	__u32 length;
};

struct drm_event_crtc_sequence {
	struct drm_event base;
	__u64 user_data;
	__s64 time_ns;
	__u64 sequence;
};

struct drm_event_vblank {
	struct drm_event base;
	__u64 user_data;
	__u32 tv_sec;
	__u32 tv_usec;
	__u32 sequence;
	__u32 crtc_id;
};

struct ww_acquire_ctx {
	struct task_struct *task;
	long unsigned int stamp;
	unsigned int acquired;
	short unsigned int wounded;
	short unsigned int is_wait_die;
};

struct drm_exec {
	u32 flags;
	struct ww_acquire_ctx ticket;
	unsigned int num_objects;
	unsigned int max_objects;
	struct drm_gem_object **objects;
	struct drm_gem_object *contended;
	struct drm_gem_object *prelocked;
};

struct fb_info;

struct fb_deferred_io {
	long unsigned int delay;
	bool sort_pagereflist;
	int open_count;
	struct mutex lock;
	struct list_head pagereflist;
	struct page * (*get_page)(struct fb_info *, long unsigned int);
	void (*deferred_io)(struct fb_info *, struct list_head *);
};

struct drm_fb_helper_funcs;

struct drm_fb_helper {
	struct drm_client_dev client;
	struct drm_client_buffer *buffer;
	struct drm_framebuffer *fb;
	struct drm_device *dev;
	const struct drm_fb_helper_funcs *funcs;
	struct fb_info *info;
	u32 pseudo_palette[17];
	struct drm_clip_rect damage_clip;
	spinlock_t damage_lock;
	struct work_struct damage_work;
	struct work_struct resume_work;
	struct mutex lock;
	struct list_head kernel_fb_list;
	bool delayed_hotplug;
	bool deferred_setup;
	int preferred_bpp;
	struct fb_deferred_io fbdefio;
};

struct drm_fb_helper_funcs {
	int (*fb_probe)(struct drm_fb_helper *, struct drm_fb_helper_surface_size *);
	int (*fb_dirty)(struct drm_fb_helper *, struct drm_clip_rect *);
};

struct drm_fb_helper_surface_size {
	u32 fb_width;
	u32 fb_height;
	u32 surface_width;
	u32 surface_height;
	u32 surface_bpp;
	u32 surface_depth;
};

struct drm_prime_file_private {
	struct mutex lock;
	struct rb_root dmabufs;
	struct rb_root handles;
};

struct drm_file {
	bool authenticated;
	bool stereo_allowed;
	bool universal_planes;
	bool atomic;
	bool aspect_ratio_allowed;
	bool writeback_connectors;
	bool was_master;
	bool is_master;
	bool supports_virtualized_cursor_plane;
	struct drm_master *master;
	spinlock_t master_lookup_lock;
	struct pid *pid;
	u64 client_id;
	drm_magic_t magic;
	struct list_head lhead;
	struct drm_minor *minor;
	struct idr object_idr;
	spinlock_t table_lock;
	struct idr syncobj_idr;
	spinlock_t syncobj_table_lock;
	struct file *filp;
	void *driver_priv;
	struct list_head fbs;
	struct mutex fbs_lock;
	struct list_head blobs;
	wait_queue_head_t event_wait;
	struct list_head pending_event_list;
	struct list_head event_list;
	int event_space;
	struct mutex event_read_lock;
	struct drm_prime_file_private prime;
	const char *client_name;
	struct mutex client_name_lock;
};

struct drm_flip_task {
	struct list_head node;
	void *data;
};

struct drm_flip_work;

typedef void (*drm_flip_func_t)(struct drm_flip_work *, void *);

struct drm_flip_work {
	const char *name;
	drm_flip_func_t func;
	struct work_struct worker;
	struct list_head queued;
	struct list_head commited;
	spinlock_t lock;
};

struct drm_format_conv_state {
	struct {
		void *mem;
		size_t size;
		bool preallocated;
	} tmp;
};

struct drm_format_info {
	u32 format;
	u8 depth;
	u8 num_planes;
	union {
		u8 cpp[4];
		u8 char_per_block[4];
	};
	u8 block_w[4];
	u8 block_h[4];
	u8 hsub;
	u8 vsub;
	bool has_alpha;
	bool is_yuv;
	bool is_color_indexed;
};

struct drm_format_modifier {
	__u64 formats;
	__u32 offset;
	__u32 pad;
	__u64 modifier;
};

struct drm_format_modifier_blob {
	__u32 version;
	__u32 flags;
	__u32 count_formats;
	__u32 formats_offset;
	__u32 count_modifiers;
	__u32 modifiers_offset;
};

struct drm_framebuffer_funcs {
	void (*destroy)(struct drm_framebuffer *);
	int (*create_handle)(struct drm_framebuffer *, struct drm_file *, unsigned int *);
	int (*dirty)(struct drm_framebuffer *, struct drm_file *, unsigned int, unsigned int, struct drm_clip_rect *, unsigned int);
};

struct drm_gem_close {
	__u32 handle;
	__u32 pad;
};

struct drm_gem_flink {
	__u32 handle;
	__u32 name;
};

struct drm_gem_lru {
	struct mutex *lock;
	long int count;
	struct list_head list;
};

struct drm_vma_offset_node {
	rwlock_t vm_lock;
	struct drm_mm_node vm_node;
	struct rb_root vm_files;
	void *driver_private;
};

struct drm_gem_object_funcs;

struct drm_gem_object {
	struct kref refcount;
	unsigned int handle_count;
	struct drm_device *dev;
	struct file *filp;
	struct drm_vma_offset_node vma_node;
	size_t size;
	int name;
	struct dma_buf *dma_buf;
	struct dma_buf_attachment *import_attach;
	struct dma_resv *resv;
	struct dma_resv _resv;
	struct {
		struct list_head list;
	} gpuva;
	const struct drm_gem_object_funcs *funcs;
	struct list_head lru_node;
	struct drm_gem_lru *lru;
};

struct drm_gem_object_funcs {
	void (*free)(struct drm_gem_object *);
	int (*open)(struct drm_gem_object *, struct drm_file *);
	void (*close)(struct drm_gem_object *, struct drm_file *);
	void (*print_info)(struct drm_printer *, unsigned int, const struct drm_gem_object *);
	struct dma_buf * (*export)(struct drm_gem_object *, int);
	int (*pin)(struct drm_gem_object *);
	void (*unpin)(struct drm_gem_object *);
	struct sg_table * (*get_sg_table)(struct drm_gem_object *);
	int (*vmap)(struct drm_gem_object *, struct iosys_map *);
	void (*vunmap)(struct drm_gem_object *, struct iosys_map *);
	int (*mmap)(struct drm_gem_object *, struct vm_area_struct *);
	int (*evict)(struct drm_gem_object *);
	enum drm_gem_object_status (*status)(struct drm_gem_object *);
	size_t (*rss)(struct drm_gem_object *);
	const struct vm_operations_struct *vm_ops;
};

struct drm_gem_open {
	__u32 name;
	__u32 handle;
	__u64 size;
};

struct drm_gem_shmem_object {
	struct drm_gem_object base;
	struct page **pages;
	unsigned int pages_use_count;
	int madv;
	struct list_head madv_list;
	struct sg_table *sgt;
	void *vaddr;
	unsigned int vmap_use_count;
	bool pages_mark_dirty_on_put: 1;
	bool pages_mark_accessed_on_put: 1;
	bool map_wc: 1;
};

struct drm_get_cap {
	__u64 capability;
	__u64 value;
};

struct drm_gpuvm;

struct drm_gpuvm_bo;

struct drm_gpuva {
	struct drm_gpuvm *vm;
	struct drm_gpuvm_bo *vm_bo;
	enum drm_gpuva_flags flags;
	struct {
		u64 addr;
		u64 range;
	} va;
	struct {
		u64 offset;
		struct drm_gem_object *obj;
		struct list_head entry;
	} gem;
	struct {
		struct rb_node node;
		struct list_head entry;
		u64 __subtree_last;
	} rb;
};

struct drm_gpuva_op_map {
	struct {
		u64 addr;
		u64 range;
	} va;
	struct {
		u64 offset;
		struct drm_gem_object *obj;
	} gem;
};

struct drm_gpuva_op_unmap;

struct drm_gpuva_op_remap {
	struct drm_gpuva_op_map *prev;
	struct drm_gpuva_op_map *next;
	struct drm_gpuva_op_unmap *unmap;
};

struct drm_gpuva_op_unmap {
	struct drm_gpuva *va;
	bool keep;
};

struct drm_gpuva_op_prefetch {
	struct drm_gpuva *va;
};

struct drm_gpuva_op {
	struct list_head entry;
	enum drm_gpuva_op_type op;
	union {
		struct drm_gpuva_op_map map;
		struct drm_gpuva_op_remap remap;
		struct drm_gpuva_op_unmap unmap;
		struct drm_gpuva_op_prefetch prefetch;
	};
};

struct drm_gpuvm_ops;

struct drm_gpuvm {
	const char *name;
	enum drm_gpuvm_flags flags;
	struct drm_device *drm;
	u64 mm_start;
	u64 mm_range;
	struct {
		struct rb_root_cached tree;
		struct list_head list;
	} rb;
	struct kref kref;
	struct drm_gpuva kernel_alloc_node;
	const struct drm_gpuvm_ops *ops;
	struct drm_gem_object *r_obj;
	struct {
		struct list_head list;
		struct list_head *local_list;
		spinlock_t lock;
	} extobj;
	struct {
		struct list_head list;
		struct list_head *local_list;
		spinlock_t lock;
	} evict;
};

struct drm_gpuvm_bo {
	struct drm_gpuvm *vm;
	struct drm_gem_object *obj;
	bool evicted;
	struct kref kref;
	struct {
		struct list_head gpuva;
		struct {
			struct list_head gem;
			struct list_head extobj;
			struct list_head evict;
		} entry;
	} list;
};

struct drm_gpuvm_ops {
	void (*vm_free)(struct drm_gpuvm *);
	struct drm_gpuva_op * (*op_alloc)(void);
	void (*op_free)(struct drm_gpuva_op *);
	struct drm_gpuvm_bo * (*vm_bo_alloc)(void);
	void (*vm_bo_free)(struct drm_gpuvm_bo *);
	int (*vm_bo_validate)(struct drm_gpuvm_bo *, struct drm_exec *);
	int (*sm_step_map)(struct drm_gpuva_op *, void *);
	int (*sm_step_remap)(struct drm_gpuva_op *, void *);
	int (*sm_step_unmap)(struct drm_gpuva_op *, void *);
};

struct i2c_client;

struct i2c_device_id;

struct i2c_board_info;

struct i2c_driver {
	unsigned int class;
	int (*probe)(struct i2c_client *);
	void (*remove)(struct i2c_client *);
	void (*shutdown)(struct i2c_client *);
	void (*alert)(struct i2c_client *, enum i2c_alert_protocol, unsigned int);
	int (*command)(struct i2c_client *, unsigned int, void *);
	struct device_driver driver;
	const struct i2c_device_id *id_table;
	int (*detect)(struct i2c_client *, struct i2c_board_info *);
	const short unsigned int *address_list;
	struct list_head clients;
	u32 flags;
};

struct drm_i2c_encoder_driver {
	struct i2c_driver i2c_driver;
	int (*encoder_init)(struct i2c_client *, struct drm_device *, struct drm_encoder_slave *);
};

struct drm_i915_clock_gating_funcs {
	void (*init_clock_gating)(struct drm_i915_private *);
};

struct drm_i915_cmd_descriptor {
	u32 flags;
	struct {
		u32 value;
		u32 mask;
	} cmd;
	union {
		u32 fixed;
		u32 mask;
	} length;
	struct {
		u32 offset;
		u32 mask;
		u32 step;
	} reg;
	struct {
		u32 offset;
		u32 mask;
		u32 expected;
		u32 condition_offset;
		u32 condition_mask;
	} bits[3];
};

struct drm_i915_cmd_table {
	const struct drm_i915_cmd_descriptor *table;
	int count;
};

struct i915_engine_class_instance {
	__u16 engine_class;
	__u16 engine_instance;
};

struct drm_i915_engine_info {
	struct i915_engine_class_instance engine;
	__u32 rsvd0;
	__u64 flags;
	__u64 capabilities;
	__u16 logical_instance;
	__u16 rsvd1[3];
	__u64 rsvd2[3];
};

struct drm_i915_error_state_buf {
	struct drm_i915_private *i915;
	struct scatterlist *sgl;
	struct scatterlist *cur;
	struct scatterlist *end;
	char *buf;
	size_t bytes;
	size_t size;
	loff_t iter;
	int err;
};

struct i915_drm_client;

struct drm_i915_file_private {
	struct drm_i915_private *i915;
	union {
		struct drm_file *file;
		struct callback_head rcu;
	};
	struct mutex proto_context_lock;
	struct xarray proto_context_xa;
	struct xarray context_xa;
	struct xarray vm_xa;
	unsigned int bsd_engine;
	atomic_t ban_score;
	long unsigned int hang_timestamp;
	struct i915_drm_client *client;
};

struct drm_i915_gem_busy {
	__u32 handle;
	__u32 busy;
};

struct drm_i915_gem_caching {
	__u32 handle;
	__u32 caching;
};

struct drm_i915_gem_context_create_ext {
	__u32 ctx_id;
	__u32 flags;
	__u64 extensions;
};

struct i915_user_extension {
	__u64 next_extension;
	__u32 name;
	__u32 flags;
	__u32 rsvd[4];
};

struct drm_i915_gem_context_param {
	__u32 ctx_id;
	__u32 size;
	__u64 param;
	__u64 value;
};

struct drm_i915_gem_context_create_ext_setparam {
	struct i915_user_extension base;
	struct drm_i915_gem_context_param param;
};

struct drm_i915_gem_context_destroy {
	__u32 ctx_id;
	__u32 pad;
};

struct drm_i915_gem_context_param_sseu {
	struct i915_engine_class_instance engine;
	__u32 flags;
	__u64 slice_mask;
	__u64 subslice_mask;
	__u16 min_eus_per_subslice;
	__u16 max_eus_per_subslice;
	__u32 rsvd;
};

struct drm_i915_gem_create {
	__u64 size;
	__u32 handle;
	__u32 pad;
};

struct drm_i915_gem_create_ext {
	__u64 size;
	__u32 handle;
	__u32 flags;
	__u64 extensions;
};

struct drm_i915_gem_create_ext_memory_regions {
	struct i915_user_extension base;
	__u32 pad;
	__u32 num_regions;
	__u64 regions;
};

struct drm_i915_gem_create_ext_protected_content {
	struct i915_user_extension base;
	__u32 flags;
};

struct drm_i915_gem_create_ext_set_pat {
	struct i915_user_extension base;
	__u32 pat_index;
	__u32 rsvd;
};

struct drm_i915_gem_exec_fence {
	__u32 handle;
	__u32 flags;
};

struct drm_i915_gem_exec_object2 {
	__u32 handle;
	__u32 relocation_count;
	__u64 relocs_ptr;
	__u64 alignment;
	__u64 offset;
	__u64 flags;
	union {
		__u64 rsvd1;
		__u64 pad_to_size;
	};
	__u64 rsvd2;
};

struct drm_i915_gem_execbuffer2 {
	__u64 buffers_ptr;
	__u32 buffer_count;
	__u32 batch_start_offset;
	__u32 batch_len;
	__u32 DR1;
	__u32 DR4;
	__u32 num_cliprects;
	__u64 cliprects_ptr;
	__u64 flags;
	__u64 rsvd1;
	__u64 rsvd2;
};

struct drm_i915_gem_execbuffer_ext_timeline_fences {
	struct i915_user_extension base;
	__u64 fence_count;
	__u64 handles_ptr;
	__u64 values_ptr;
};

struct drm_i915_gem_get_aperture {
	__u64 aper_size;
	__u64 aper_available_size;
};

struct drm_i915_gem_get_tiling {
	__u32 handle;
	__u32 tiling_mode;
	__u32 swizzle_mode;
	__u32 phys_swizzle_mode;
};

struct drm_i915_gem_madvise {
	__u32 handle;
	__u32 madv;
	__u32 retained;
};

struct drm_i915_gem_memory_class_instance {
	__u16 memory_class;
	__u16 memory_instance;
};

struct drm_i915_gem_mmap {
	__u32 handle;
	__u32 pad;
	__u64 offset;
	__u64 size;
	__u64 addr_ptr;
	__u64 flags;
};

struct drm_i915_gem_mmap_offset {
	__u32 handle;
	__u32 pad;
	__u64 offset;
	__u64 flags;
	__u64 extensions;
};

struct ttm_device;

struct ttm_resource;

struct ttm_tt;

struct ttm_lru_bulk_move;

struct ttm_buffer_object {
	struct drm_gem_object base;
	struct ttm_device *bdev;
	enum ttm_bo_type type;
	uint32_t page_alignment;
	void (*destroy)(struct ttm_buffer_object *);
	struct kref kref;
	struct ttm_resource *resource;
	struct ttm_tt *ttm;
	bool deleted;
	struct ttm_lru_bulk_move *bulk_move;
	unsigned int priority;
	unsigned int pin_count;
	struct work_struct delayed_delete;
	struct sg_table *sg;
};

struct i915_page_sizes {
	unsigned int phys;
	unsigned int sg;
};

struct i915_gem_object_page_iter {
	struct scatterlist *sg_pos;
	unsigned int sg_idx;
	struct xarray radix;
	struct mutex lock;
};

struct interval_tree_node {
	struct rb_node rb;
	long unsigned int start;
	long unsigned int last;
	long unsigned int __subtree_last;
};

struct mmu_interval_notifier_ops;

struct mmu_interval_notifier {
	struct interval_tree_node interval_tree;
	const struct mmu_interval_notifier_ops *ops;
	struct mm_struct *mm;
	struct hlist_node deferred_item;
	long unsigned int invalidate_seq;
};

struct i915_gem_userptr {
	uintptr_t ptr;
	long unsigned int notifier_seq;
	struct mmu_interval_notifier notifier;
	struct page **pvec;
	int page_ref;
};

struct drm_i915_gem_object_ops;

struct i915_address_space;

struct intel_frontbuffer;

struct i915_refct_sgt;

struct drm_i915_gem_object {
	union {
		struct drm_gem_object base;
		struct ttm_buffer_object __do_not_access;
	};
	const struct drm_i915_gem_object_ops *ops;
	struct {
		spinlock_t lock;
		struct list_head list;
		struct rb_root tree;
	} vma;
	struct list_head lut_list;
	spinlock_t lut_lock;
	struct list_head obj_link;
	struct i915_address_space *shares_resv_from;
	struct i915_drm_client *client;
	struct list_head client_link;
	union {
		struct callback_head rcu;
		struct llist_node freed;
	};
	unsigned int userfault_count;
	struct list_head userfault_link;
	struct {
		spinlock_t lock;
		struct rb_root offsets;
	} mmo;
	long unsigned int flags;
	unsigned int mem_flags;
	unsigned int pat_index: 6;
	unsigned int pat_set_by_user: 1;
	unsigned int cache_coherent: 2;
	unsigned int cache_dirty: 1;
	unsigned int is_dpt: 1;
	u16 read_domains;
	u16 write_domain;
	struct intel_frontbuffer *frontbuffer;
	unsigned int tiling_and_stride;
	struct {
		atomic_t pages_pin_count;
		atomic_t shrink_pin;
		bool ttm_shrinkable;
		bool unknown_state;
		struct intel_memory_region **placements;
		int n_placements;
		struct intel_memory_region *region;
		struct ttm_resource *res;
		struct list_head region_link;
		struct i915_refct_sgt *rsgt;
		struct sg_table *pages;
		void *mapping;
		struct i915_page_sizes page_sizes;
		struct i915_gem_object_page_iter get_page;
		struct i915_gem_object_page_iter get_dma_page;
		struct list_head link;
		unsigned int madv: 2;
		bool dirty: 1;
		u32 tlb[2];
	} mm;
	struct {
		struct i915_refct_sgt *cached_io_rsgt;
		struct i915_gem_object_page_iter get_io_page;
		struct drm_i915_gem_object *backup;
		bool created: 1;
	} ttm;
	u32 pxp_key_instance;
	long unsigned int *bit_17;
	union {
		struct i915_gem_userptr userptr;
		struct drm_mm_node *stolen;
		resource_size_t bo_offset;
		long unsigned int scratch;
		u64 encode;
		void *gvt_info;
	};
};

struct drm_i915_gem_pread;

struct drm_i915_gem_pwrite;

struct drm_i915_gem_object_ops {
	unsigned int flags;
	int (*get_pages)(struct drm_i915_gem_object *);
	void (*put_pages)(struct drm_i915_gem_object *, struct sg_table *);
	int (*truncate)(struct drm_i915_gem_object *);
	int (*shrink)(struct drm_i915_gem_object *, unsigned int);
	int (*pread)(struct drm_i915_gem_object *, const struct drm_i915_gem_pread *);
	int (*pwrite)(struct drm_i915_gem_object *, const struct drm_i915_gem_pwrite *);
	u64 (*mmap_offset)(struct drm_i915_gem_object *);
	void (*unmap_virtual)(struct drm_i915_gem_object *);
	int (*dmabuf_export)(struct drm_i915_gem_object *);
	void (*adjust_lru)(struct drm_i915_gem_object *);
	void (*delayed_free)(struct drm_i915_gem_object *);
	int (*migrate)(struct drm_i915_gem_object *, struct intel_memory_region *, unsigned int);
	void (*release)(struct drm_i915_gem_object *);
	const struct vm_operations_struct *mmap_ops;
	const char *name;
};

struct drm_i915_gem_pread {
	__u32 handle;
	__u32 pad;
	__u64 offset;
	__u64 size;
	__u64 data_ptr;
};

struct drm_i915_gem_pwrite {
	__u32 handle;
	__u32 pad;
	__u64 offset;
	__u64 size;
	__u64 data_ptr;
};

struct drm_i915_gem_relocation_entry {
	__u32 target_handle;
	__u32 delta;
	__u64 offset;
	__u64 presumed_offset;
	__u32 read_domains;
	__u32 write_domain;
};

struct drm_i915_gem_set_domain {
	__u32 handle;
	__u32 read_domains;
	__u32 write_domain;
};

struct drm_i915_gem_set_tiling {
	__u32 handle;
	__u32 tiling_mode;
	__u32 stride;
	__u32 swizzle_mode;
};

struct drm_i915_gem_sw_finish {
	__u32 handle;
};

struct drm_i915_gem_userptr {
	__u64 user_ptr;
	__u64 user_size;
	__u32 flags;
	__u32 handle;
};

struct drm_i915_gem_vm_control {
	__u64 extensions;
	__u32 flags;
	__u32 vm_id;
};

struct drm_i915_gem_wait {
	__u32 bo_handle;
	__u32 flags;
	__s64 timeout_ns;
};

struct drm_i915_get_pipe_from_crtc_id {
	__u32 crtc_id;
	__u32 pipe;
};

struct drm_i915_getparam {
	__s32 param;
	int *value;
};

typedef struct drm_i915_getparam drm_i915_getparam_t;

struct drm_i915_memory_region_info {
	struct drm_i915_gem_memory_class_instance region;
	__u32 rsvd0;
	__u64 probed_size;
	__u64 unallocated_size;
	union {
		__u64 rsvd1[8];
		struct {
			__u64 probed_cpu_visible_size;
			__u64 unallocated_cpu_visible_size;
		};
	};
};

struct drm_i915_mocs_entry {
	u32 control_value;
	u16 l3cc_value;
	u16 used;
};

struct drm_i915_mocs_table {
	unsigned int size;
	unsigned int n_entries;
	const struct drm_i915_mocs_entry *table;
	u8 uc_index;
	u8 wb_index;
	u8 unused_entries_index;
};

struct drm_i915_perf_oa_config {
	char uuid[36];
	__u32 n_mux_regs;
	__u32 n_boolean_regs;
	__u32 n_flex_regs;
	__u64 mux_regs_ptr;
	__u64 boolean_regs_ptr;
	__u64 flex_regs_ptr;
};

struct drm_i915_perf_open_param {
	__u32 flags;
	__u32 num_properties;
	__u64 properties_ptr;
};

struct drm_i915_perf_record_header {
	__u32 type;
	__u16 pad;
	__u16 size;
};

struct intel_display_platforms {
	union {
		struct {
			long unsigned int g4x: 1;
			long unsigned int mobile: 1;
			long unsigned int dgfx: 1;
			long unsigned int i830: 1;
			long unsigned int i845g: 1;
			long unsigned int i85x: 1;
			long unsigned int i865g: 1;
			long unsigned int i915g: 1;
			long unsigned int i915gm: 1;
			long unsigned int i945g: 1;
			long unsigned int i945gm: 1;
			long unsigned int g33: 1;
			long unsigned int pineview: 1;
			long unsigned int i965g: 1;
			long unsigned int i965gm: 1;
			long unsigned int g45: 1;
			long unsigned int gm45: 1;
			long unsigned int ironlake: 1;
			long unsigned int sandybridge: 1;
			long unsigned int ivybridge: 1;
			long unsigned int valleyview: 1;
			long unsigned int haswell: 1;
			long unsigned int haswell_ult: 1;
			long unsigned int haswell_ulx: 1;
			long unsigned int broadwell: 1;
			long unsigned int broadwell_ult: 1;
			long unsigned int broadwell_ulx: 1;
			long unsigned int cherryview: 1;
			long unsigned int skylake: 1;
			long unsigned int skylake_ult: 1;
			long unsigned int skylake_ulx: 1;
			long unsigned int broxton: 1;
			long unsigned int kabylake: 1;
			long unsigned int kabylake_ult: 1;
			long unsigned int kabylake_ulx: 1;
			long unsigned int geminilake: 1;
			long unsigned int coffeelake: 1;
			long unsigned int coffeelake_ult: 1;
			long unsigned int coffeelake_ulx: 1;
			long unsigned int cometlake: 1;
			long unsigned int cometlake_ult: 1;
			long unsigned int cometlake_ulx: 1;
			long unsigned int icelake: 1;
			long unsigned int icelake_port_f: 1;
			long unsigned int jasperlake: 1;
			long unsigned int elkhartlake: 1;
			long unsigned int tigerlake: 1;
			long unsigned int tigerlake_uy: 1;
			long unsigned int rocketlake: 1;
			long unsigned int dg1: 1;
			long unsigned int alderlake_s: 1;
			long unsigned int alderlake_s_raptorlake_s: 1;
			long unsigned int alderlake_p: 1;
			long unsigned int alderlake_p_alderlake_n: 1;
			long unsigned int alderlake_p_raptorlake_p: 1;
			long unsigned int alderlake_p_raptorlake_u: 1;
			long unsigned int dg2: 1;
			long unsigned int dg2_g10: 1;
			long unsigned int dg2_g11: 1;
			long unsigned int dg2_g12: 1;
			long unsigned int meteorlake: 1;
			long unsigned int lunarlake: 1;
			long unsigned int battlemage: 1;
			long unsigned int pantherlake: 1;
		};
		long unsigned int bitmap[1];
	};
};

struct intel_global_state_funcs;

struct intel_global_obj {
	struct list_head head;
	struct intel_global_state *state;
	const struct intel_global_state_funcs *funcs;
};

struct intel_bw_info {
	unsigned int deratedbw[8];
	unsigned int psf_bw[3];
	unsigned int peakbw[8];
	u8 num_qgv_points;
	u8 num_psf_gv_points;
	u8 num_planes;
};

struct intel_cdclk_config {
	unsigned int cdclk;
	unsigned int vco;
	unsigned int ref;
	unsigned int bypass;
	u8 voltage_level;
	bool joined_mbus;
};

typedef struct ref_tracker *intel_wakeref_t;

struct intel_display_ip_ver {
	u16 ver;
	u16 rel;
	u16 step;
};

struct intel_display_runtime_info {
	struct intel_display_ip_ver ip;
	int step;
	u32 rawclk_freq;
	u8 pipe_mask;
	u8 cpu_transcoder_mask;
	u16 port_mask;
	u8 num_sprites[4];
	u8 num_scalers[4];
	u8 fbc_mask;
	bool has_hdcp;
	bool has_dmc;
	bool has_dsc;
	bool edp_typec_support;
	bool has_dbuf_overlap_detection;
};

struct intel_power_domain_mask {
	long unsigned int bits[2];
};

struct i915_power_well;

struct i915_power_domains {
	bool initializing;
	bool display_core_suspended;
	int power_well_count;
	u32 dc_state;
	u32 target_dc_state;
	u32 allowed_dc_mask;
	intel_wakeref_t init_wakeref;
	intel_wakeref_t disable_wakeref;
	struct mutex lock;
	int domain_use_count[76];
	struct delayed_work async_put_work;
	intel_wakeref_t async_put_wakeref;
	struct intel_power_domain_mask async_put_domains[2];
	int async_put_next_delay;
	struct i915_power_well *power_wells;
};

struct drm_modeset_acquire_ctx {
	struct ww_acquire_ctx ww_ctx;
	struct drm_modeset_lock *contended;
	depot_stack_handle_t stack_depot;
	struct list_head locked;
	bool trylock_only;
	bool interruptible;
};

struct drm_dp_tunnel_mgr;

struct intel_encoder;

struct intel_audio_state {
	struct intel_encoder *encoder;
	u8 eld[128];
};

struct i915_audio_component;

struct intel_audio {
	struct i915_audio_component *component;
	bool component_registered;
	struct mutex mutex;
	int power_refcount;
	u32 freq_cntrl;
	struct intel_audio_state state[7];
	struct {
		struct platform_device *platdev;
		int irq;
	} lpe;
};

struct i9xx_dpll_hw_state {
	u32 dpll;
	u32 dpll_md;
	u32 fp0;
	u32 fp1;
};

struct hsw_dpll_hw_state {
	u32 wrpll;
	u32 spll;
};

struct skl_dpll_hw_state {
	u32 ctrl1;
	u32 cfgcr1;
	u32 cfgcr2;
};

struct icl_dpll_hw_state {
	u32 cfgcr0;
	u32 cfgcr1;
	u32 div0;
	u32 mg_refclkin_ctl;
	u32 mg_clktop2_coreclkctl1;
	u32 mg_clktop2_hsclkctl;
	u32 mg_pll_div0;
	u32 mg_pll_div1;
	u32 mg_pll_lf;
	u32 mg_pll_frac_lock;
	u32 mg_pll_ssc;
	u32 mg_pll_bias;
	u32 mg_pll_tdc_coldst_bias;
	u32 mg_pll_bias_mask;
	u32 mg_pll_tdc_coldst_bias_mask;
};

struct intel_mpllb_state {
	u32 clock;
	u32 ref_control;
	u32 mpllb_cp;
	u32 mpllb_div;
	u32 mpllb_div2;
	u32 mpllb_fracn1;
	u32 mpllb_fracn2;
	u32 mpllb_sscen;
	u32 mpllb_sscstep;
};

struct intel_c10pll_state {
	u32 clock;
	u8 tx;
	u8 cmn;
	u8 pll[20];
};

struct intel_c20pll_state {
	u32 clock;
	u16 tx[3];
	u16 cmn[4];
	union {
		u16 mplla[10];
		u16 mpllb[11];
	};
};

struct intel_cx0pll_state {
	union {
		struct intel_c10pll_state c10;
		struct intel_c20pll_state c20;
	};
	bool ssc_enabled;
	bool use_c10;
	bool tbt_mode;
};

struct intel_dpll_hw_state {
	union {
		struct i9xx_dpll_hw_state i9xx;
		struct hsw_dpll_hw_state hsw;
		struct skl_dpll_hw_state skl;
		struct bxt_dpll_hw_state bxt;
		struct icl_dpll_hw_state icl;
		struct intel_mpllb_state mpllb;
		struct intel_cx0pll_state cx0pll;
	};
};

struct intel_shared_dpll_state {
	u8 pipe_mask;
	struct intel_dpll_hw_state hw_state;
};

struct intel_shared_dpll {
	struct intel_shared_dpll_state state;
	u8 index;
	u8 active_mask;
	bool on;
	const struct dpll_info *info;
	intel_wakeref_t wakeref;
};

struct intel_dpll_mgr;

struct intel_dpll {
	struct mutex lock;
	int num_shared_dpll;
	struct intel_shared_dpll shared_dplls[9];
	const struct intel_dpll_mgr *mgr;
	struct {
		int nssc;
		int ssc;
	} ref_clks;
	u8 pch_ssc_use;
};

struct intel_frontbuffer_tracking {
	spinlock_t lock;
	unsigned int busy_bits;
	unsigned int flip_bits;
};

struct intel_hotplug {
	struct delayed_work hotplug_work;
	const u32 *hpd;
	const u32 *pch_hpd;
	struct {
		long unsigned int last_jiffies;
		int count;
		enum {
			HPD_ENABLED = 0,
			HPD_DISABLED = 1,
			HPD_MARK_DISABLED = 2,
		} state;
	} stats[15];
	u32 event_bits;
	u32 retry_bits;
	struct delayed_work reenable_work;
	u32 long_port_mask;
	u32 short_port_mask;
	struct work_struct dig_port_work;
	struct work_struct poll_init_work;
	bool poll_enabled;
	bool detection_work_enabled;
	unsigned int hpd_storm_threshold;
	u8 hpd_short_storm_enabled;
	long unsigned int oob_hotplug_last_state;
	struct workqueue_struct *dp_wq;
	bool ignore_long_hpd;
};

struct intel_display_params {
	char *dmc_firmware_path;
	char *vbt_firmware;
	int lvds_channel_mode;
	int panel_use_ssc;
	int vbt_sdvo_panel_type;
	int enable_dc;
	bool enable_dpt;
	bool enable_dsb;
	bool enable_sagv;
	int disable_power_well;
	bool enable_ips;
	int invert_brightness;
	int edp_vswing;
	int enable_dpcd_backlight;
	bool load_detect_test;
	bool force_reset_modeset_test;
	bool disable_display;
	bool verbose_state_checks;
	bool nuclear_pageflip;
	bool enable_dp_mst;
	int enable_fbc;
	int enable_psr;
	bool psr_safest_params;
	bool enable_psr2_sel_fetch;
	int enable_dmc_wl;
};

struct sdvo_device_mapping {
	u8 initialized;
	u8 dvo_port;
	u8 target_addr;
	u8 dvo_wiring;
	u8 i2c_pin;
	u8 ddc_pin;
};

struct intel_vbt_data {
	u16 version;
	unsigned int int_tv_support: 1;
	unsigned int int_crt_support: 1;
	unsigned int lvds_use_ssc: 1;
	unsigned int int_lvds_support: 1;
	unsigned int display_clock_mode: 1;
	unsigned int fdi_rx_polarity_inverted: 1;
	int lvds_ssc_freq;
	enum drm_panel_orientation orientation;
	bool override_afc_startup;
	u8 override_afc_startup_val;
	int crt_ddc_pin;
	struct list_head display_devices;
	struct list_head bdb_blocks;
	struct sdvo_device_mapping sdvo_mappings[2];
};

struct intel_dmc_wl {
	spinlock_t lock;
	bool enabled;
	bool taken;
	refcount_t refcount;
	u32 dc_state;
	struct delayed_work work;
};

struct ilk_wm_values {
	u32 wm_pipe[3];
	u32 wm_lp[3];
	u32 wm_lp_spr[3];
	bool enable_fbc_wm;
	enum intel_ddb_partitioning partitioning;
};

struct g4x_pipe_wm {
	u16 plane[8];
	u16 fbc;
};

struct g4x_sr_wm {
	u16 plane;
	u16 cursor;
	u16 fbc;
};

struct vlv_wm_ddl_values {
	u8 plane[8];
};

struct vlv_wm_values {
	struct g4x_pipe_wm pipe[3];
	struct g4x_sr_wm sr;
	struct vlv_wm_ddl_values ddl[3];
	u8 level;
	bool cxsr;
};

struct g4x_wm_values {
	struct g4x_pipe_wm pipe[2];
	struct g4x_sr_wm sr;
	struct g4x_sr_wm hpll;
	bool cxsr;
	bool hpll_en;
	bool fbc_en;
};

struct intel_wm {
	u16 pri_latency[5];
	u16 spr_latency[5];
	u16 cur_latency[5];
	u16 skl_latency[8];
	union {
		struct ilk_wm_values hw;
		struct vlv_wm_values vlv;
		struct g4x_wm_values g4x;
	};
	u8 num_levels;
	struct mutex wm_mutex;
	bool ipc_enabled;
};

struct intel_display_funcs;

struct intel_cdclk_funcs;

struct intel_dpll_funcs;

struct intel_hotplug_funcs;

struct intel_wm_funcs;

struct intel_fdi_funcs;

struct intel_color_funcs;

struct intel_audio_funcs;

struct intel_cdclk_vals;

struct intel_dmc;

struct intel_fbdev;

struct intel_gmbus;

struct i915_hdcp_arbiter;

struct intel_hdcp_gsc_message;

struct intel_display_device_info;

struct intel_fbc;

struct intel_opregion;

struct intel_overlay;

struct intel_display {
	struct drm_device *drm;
	struct intel_display_platforms platform;
	struct {
		const struct intel_display_funcs *display;
		const struct intel_cdclk_funcs *cdclk;
		const struct intel_dpll_funcs *dpll;
		const struct intel_hotplug_funcs *hotplug;
		const struct intel_wm_funcs *wm;
		const struct intel_fdi_funcs *fdi;
		const struct intel_color_funcs *color;
		const struct intel_audio_funcs *audio;
	} funcs;
	struct {
		bool any_task_allowed;
		struct task_struct *allowed_task;
	} access;
	struct {
		struct mutex lock;
	} backlight;
	struct {
		struct intel_global_obj obj;
		struct intel_bw_info max[6];
	} bw;
	struct {
		struct intel_cdclk_config hw;
		const struct intel_cdclk_vals *table;
		struct intel_global_obj obj;
		unsigned int max_cdclk_freq;
		unsigned int max_dotclk_freq;
		unsigned int skl_preferred_vco_freq;
	} cdclk;
	struct {
		struct drm_property_blob *glk_linear_degamma_lut;
	} color;
	struct {
		u8 enabled_slices;
		struct intel_global_obj obj;
	} dbuf;
	struct {
		spinlock_t phy_lock;
	} dkl;
	struct {
		struct intel_dmc *dmc;
		intel_wakeref_t wakeref;
	} dmc;
	struct {
		u32 mmio_base;
	} dsi;
	struct {
		struct intel_fbdev *fbdev;
		struct work_struct suspend_work;
	} fbdev;
	struct {
		unsigned int pll_freq;
		u32 rx_config;
	} fdi;
	struct {
		struct list_head obj_list;
	} global;
	struct {
		u32 mmio_base;
		struct mutex mutex;
		struct intel_gmbus *bus[15];
		wait_queue_head_t wait_queue;
	} gmbus;
	struct {
		struct i915_hdcp_arbiter *arbiter;
		bool comp_added;
		struct intel_hdcp_gsc_message *hdcp_message;
		struct mutex hdcp_mutex;
	} hdcp;
	struct {
		u32 state;
	} hti;
	struct {
		const struct intel_display_device_info *__device_info;
		struct intel_display_runtime_info __runtime_info;
	} info;
	struct {
		bool false_color;
	} ips;
	struct {
		bool vlv_display_irqs_enabled;
		u8 vblank_enabled;
		int vblank_wa_num_pipes;
		struct work_struct vblank_dc_work;
		u32 de_irq_mask[4];
		u32 pipestat_irq_mask[4];
	} irq;
	struct {
		wait_queue_head_t waitqueue;
		struct mutex lock;
		struct intel_global_obj obj;
	} pmdemand;
	struct {
		struct i915_power_domains domains;
		u32 chv_phy_control;
		bool chv_phy_assert[2];
	} power;
	struct {
		u32 mmio_base;
		struct mutex mutex;
	} pps;
	struct {
		struct drm_property *broadcast_rgb;
		struct drm_property *force_audio;
	} properties;
	struct {
		long unsigned int mask;
	} quirks;
	struct {
		struct drm_atomic_state *modeset_state;
		struct drm_modeset_acquire_ctx reset_ctx;
		u32 saveDSPARB;
		u32 saveSWF0[16];
		u32 saveSWF1[16];
		u32 saveSWF3[3];
		u16 saveGCDGMBUS;
	} restore;
	struct {
		enum {
			I915_SAGV_UNKNOWN = 0,
			I915_SAGV_DISABLED = 1,
			I915_SAGV_ENABLED = 2,
			I915_SAGV_NOT_CONTROLLED = 3,
		} status;
		u32 block_time_us;
	} sagv;
	struct {
		u8 phy_failed_calibration;
	} snps;
	struct {
		u32 chv_dpll_md[4];
		u32 bxt_phy_grc;
	} state;
	struct {
		struct workqueue_struct *modeset;
		struct workqueue_struct *flip;
		struct workqueue_struct *cleanup;
	} wq;
	struct drm_dp_tunnel_mgr *dp_tunnel_mgr;
	struct intel_audio audio;
	struct intel_dpll dpll;
	struct intel_fbc *fbc[4];
	struct intel_frontbuffer_tracking fb_tracking;
	struct intel_hotplug hotplug;
	struct intel_opregion *opregion;
	struct intel_overlay *overlay;
	struct intel_display_params params;
	struct intel_vbt_data vbt;
	struct intel_dmc_wl wl;
	struct intel_wm wm;
};

struct i915_params {
	int modeset;
	int enable_guc;
	int guc_log_level;
	char *guc_firmware_path;
	char *huc_firmware_path;
	char *gsc_firmware_path;
	bool memtest;
	int mmio_debug;
	unsigned int reset;
	unsigned int inject_probe_failure;
	char *force_probe;
	unsigned int request_timeout_ms;
	unsigned int lmem_size;
	unsigned int lmem_bar_size;
	bool enable_hangcheck;
	bool error_capture;
	bool enable_gvt;
	bool enable_debug_only_api;
};

struct intel_ip_version {
	u8 ver;
	u8 rel;
	u8 step;
};

struct intel_step_info {
	u8 graphics_step;
	u8 media_step;
};

struct intel_runtime_info {
	struct {
		struct intel_ip_version ip;
	} graphics;
	struct {
		struct intel_ip_version ip;
	} media;
	u32 platform_mask[2];
	u16 device_id;
	struct intel_step_info step;
	unsigned int page_sizes;
	enum intel_ppgtt_type ppgtt_type;
	unsigned int ppgtt_size;
	bool has_pooled_eu;
};

struct intel_driver_caps {
	unsigned int scheduler;
	bool has_logical_contexts: 1;
};

struct i915_dsm {
	struct resource stolen;
	struct resource reserved;
	resource_size_t usable_size;
};

struct intel_uncore;

struct intel_uncore_funcs {
	enum forcewake_domains (*read_fw_domains)(struct intel_uncore *, i915_reg_t);
	enum forcewake_domains (*write_fw_domains)(struct intel_uncore *, i915_reg_t);
	u8 (*mmio_readb)(struct intel_uncore *, i915_reg_t, bool);
	u16 (*mmio_readw)(struct intel_uncore *, i915_reg_t, bool);
	u32 (*mmio_readl)(struct intel_uncore *, i915_reg_t, bool);
	u64 (*mmio_readq)(struct intel_uncore *, i915_reg_t, bool);
	void (*mmio_writeb)(struct intel_uncore *, i915_reg_t, u8, bool);
	void (*mmio_writew)(struct intel_uncore *, i915_reg_t, u16, bool);
	void (*mmio_writel)(struct intel_uncore *, i915_reg_t, u32, bool);
};

struct intel_gt;

struct intel_runtime_pm;

struct intel_forcewake_range;

struct i915_range;

struct intel_uncore_fw_get;

struct intel_uncore_forcewake_domain;

struct intel_uncore_mmio_debug;

struct intel_uncore {
	void *regs;
	struct drm_i915_private *i915;
	struct intel_gt *gt;
	struct intel_runtime_pm *rpm;
	spinlock_t lock;
	u32 gsi_offset;
	unsigned int flags;
	const struct intel_forcewake_range *fw_domains_table;
	unsigned int fw_domains_table_entries;
	const struct i915_range *shadowed_reg_table;
	unsigned int shadowed_reg_table_entries;
	struct notifier_block pmic_bus_access_nb;
	const struct intel_uncore_fw_get *fw_get_funcs;
	struct intel_uncore_funcs funcs;
	unsigned int fifo_count;
	enum forcewake_domains fw_domains;
	enum forcewake_domains fw_domains_active;
	enum forcewake_domains fw_domains_timer;
	enum forcewake_domains fw_domains_saved;
	struct intel_uncore_forcewake_domain *fw_domain[16];
	unsigned int user_forcewake_count;
	struct intel_uncore_mmio_debug *debug;
};

struct intel_uncore_mmio_debug {
	spinlock_t lock;
	int unclaimed_mmio_check;
	int saved_mmio_check;
	u32 suspend_count;
};

struct i915_virtual_gpu {
	struct mutex lock;
	bool active;
	u32 caps;
	u32 *initial_mmio;
	u8 *initial_cfg_space;
	struct list_head entry;
};

struct intel_gvt;

struct pm_qos_request {
	struct plist_node node;
	struct pm_qos_constraints *qos;
};

struct drm_mm {
	void (*color_adjust)(const struct drm_mm_node *, long unsigned int, u64 *, u64 *);
	struct list_head hole_stack;
	struct drm_mm_node head_node;
	struct rb_root_cached interval_tree;
	struct rb_root_cached holes_size;
	struct rb_root holes_addr;
	long unsigned int scan_active;
};

struct i915_gem_mm {
	struct intel_memory_region *stolen_region;
	struct drm_mm stolen;
	struct mutex stolen_lock;
	spinlock_t obj_lock;
	struct list_head purge_list;
	struct list_head shrink_list;
	struct llist_head free_list;
	struct work_struct free_work;
	atomic_t free_count;
	struct vfsmount *gemfs;
	struct intel_memory_region *regions[7];
	struct notifier_block oom_notifier;
	struct notifier_block vmap_notifier;
	struct shrinker *shrinker;
	u64 shrink_memory;
	u32 shrink_count;
};

struct intel_l3_parity {
	u32 *remap_info[2];
	struct work_struct error_work;
	int which_slice;
};

struct i915_gpu_coredump;

struct i915_gpu_error {
	spinlock_t lock;
	struct i915_gpu_coredump *first_error;
	atomic_t pending_fb_pin;
	atomic_t reset_count;
	atomic_t reset_engine_count[5];
};

struct intel_wakeref_auto {
	struct drm_i915_private *i915;
	struct timer_list timer;
	intel_wakeref_t wakeref;
	spinlock_t lock;
	refcount_t count;
};

struct intel_runtime_pm {
	atomic_t wakeref_count;
	struct device *kdev;
	bool available;
	bool no_wakeref_tracking;
	spinlock_t lmem_userfault_lock;
	struct list_head lmem_userfault_list;
	struct intel_wakeref_auto userfault_wakeref;
};

struct i915_perf;

struct i915_perf_stream;

struct i915_oa_ops {
	bool (*is_valid_b_counter_reg)(struct i915_perf *, u32);
	bool (*is_valid_mux_reg)(struct i915_perf *, u32);
	bool (*is_valid_flex_reg)(struct i915_perf *, u32);
	int (*enable_metric_set)(struct i915_perf_stream *, struct i915_active *);
	void (*disable_metric_set)(struct i915_perf_stream *);
	void (*oa_enable)(struct i915_perf_stream *);
	void (*oa_disable)(struct i915_perf_stream *);
	int (*read)(struct i915_perf_stream *, char *, size_t, size_t *);
	u32 (*oa_hw_tail_read)(struct i915_perf_stream *);
};

struct i915_oa_format;

struct i915_perf {
	struct drm_i915_private *i915;
	struct kobject *metrics_kobj;
	struct mutex metrics_lock;
	struct idr metrics_idr;
	struct ratelimit_state spurious_report_rs;
	struct ratelimit_state tail_pointer_race;
	u32 gen7_latched_oastatus1;
	u32 ctx_oactxctrl_offset;
	u32 ctx_flexeu0_offset;
	u32 gen8_valid_ctx_bit;
	struct i915_oa_ops ops;
	const struct i915_oa_format *oa_formats;
	long unsigned int format_mask[1];
	atomic64_t noa_programming_delay;
};

struct i915_gem_contexts {
	spinlock_t lock;
	struct list_head list;
};

struct i915_pmu_sample {
	u64 cur;
};

struct i915_pmu {
	struct {
		struct hlist_node node;
		unsigned int cpu;
	} cpuhp;
	struct pmu base;
	bool registered;
	const char *name;
	spinlock_t lock;
	unsigned int unparked;
	struct hrtimer timer;
	u32 enable;
	ktime_t timer_last;
	unsigned int enable_count[9];
	bool timer_enabled;
	struct i915_pmu_sample sample[8];
	ktime_t sleep_last[2];
	long unsigned int irq_count;
	struct attribute_group events_attr_group;
	void *i915_attr;
	void *pmu_attr;
};

struct dmem_cgroup_region;

struct ttm_resource_manager_func;

struct ttm_resource_manager {
	bool use_type;
	bool use_tt;
	struct ttm_device *bdev;
	uint64_t size;
	const struct ttm_resource_manager_func *func;
	spinlock_t move_lock;
	struct dma_fence *move;
	struct list_head lru[4];
	uint64_t usage;
	struct dmem_cgroup_region *cg;
};

struct ttm_pool;

struct ttm_pool_type {
	struct ttm_pool *pool;
	unsigned int order;
	enum ttm_caching caching;
	struct list_head shrinker_list;
	spinlock_t lock;
	struct list_head pages;
};

struct ttm_pool {
	struct device *dev;
	int nid;
	bool use_dma_alloc;
	bool use_dma32;
	struct {
		struct ttm_pool_type orders[11];
	} caching[3];
};

struct ttm_device_funcs;

struct ttm_device {
	struct list_head device_list;
	const struct ttm_device_funcs *funcs;
	struct ttm_resource_manager sysman;
	struct ttm_resource_manager *man_drv[8];
	struct drm_vma_offset_manager *vma_manager;
	struct ttm_pool pool;
	spinlock_t lru_lock;
	struct list_head unevictable;
	struct address_space *dev_mapping;
	struct workqueue_struct *wq;
};

struct intel_device_info;

struct vlv_s0ix_state;

struct i915_hwmon;

struct intel_pxp;

struct drm_i915_private {
	struct drm_device drm;
	struct intel_display display;
	bool do_release;
	struct i915_params params;
	const struct intel_device_info *__info;
	struct intel_runtime_info __runtime;
	struct intel_driver_caps caps;
	struct i915_dsm dsm;
	struct intel_uncore uncore;
	struct intel_uncore_mmio_debug mmio_debug;
	struct i915_virtual_gpu vgpu;
	struct intel_gvt *gvt;
	struct {
		struct pci_dev *pdev;
		struct resource mch_res;
		bool mchbar_need_disable;
	} gmch;
	union {
		struct llist_head uabi_engines_llist;
		struct list_head uabi_engines_list;
		struct rb_root uabi_engines;
	};
	unsigned int engine_uabi_class_count[5];
	spinlock_t irq_lock;
	bool irqs_enabled;
	struct mutex sbi_lock;
	struct {
		struct mutex lock;
		struct pm_qos_request qos;
	} vlv_iosf_sb;
	struct mutex sb_lock;
	u32 irq_mask;
	bool preserve_bios_swizzle;
	unsigned int fsb_freq;
	unsigned int mem_freq;
	unsigned int is_ddr3;
	unsigned int hpll_freq;
	unsigned int czclk_freq;
	struct workqueue_struct *wq;
	struct workqueue_struct *unordered_wq;
	const struct drm_i915_clock_gating_funcs *clock_gating_funcs;
	enum intel_pch pch_type;
	short unsigned int pch_id;
	long unsigned int gem_quirks;
	struct i915_gem_mm mm;
	struct intel_l3_parity l3_parity;
	u32 edram_size_mb;
	struct i915_gpu_error gpu_error;
	u32 suspend_count;
	struct vlv_s0ix_state *vlv_s0ix_state;
	struct dram_info dram_info;
	struct intel_runtime_pm runtime_pm;
	struct i915_perf perf;
	struct i915_hwmon *hwmon;
	struct intel_gt *gt[2];
	struct kobject *sysfs_gt;
	struct intel_gt *media_gt;
	struct {
		struct i915_gem_contexts contexts;
		struct file *mmap_singleton;
	} gem;
	struct intel_pxp *pxp;
	struct i915_pmu pmu;
	struct ttm_device bdev;
};

struct drm_i915_query {
	__u32 num_items;
	__u32 flags;
	__u64 items_ptr;
};

struct drm_i915_query_engine_info {
	__u32 num_engines;
	__u32 rsvd[3];
	struct drm_i915_engine_info engines[0];
};

struct drm_i915_query_guc_submission_version {
	__u32 branch;
	__u32 major;
	__u32 minor;
	__u32 patch;
};

struct drm_i915_query_item {
	__u64 query_id;
	__s32 length;
	__u32 flags;
	__u64 data_ptr;
};

struct drm_i915_query_memory_regions {
	__u32 num_regions;
	__u32 rsvd[3];
	struct drm_i915_memory_region_info regions[0];
};

struct drm_i915_query_perf_config {
	union {
		__u64 n_configs;
		__u64 config;
		char uuid[36];
	};
	__u32 flags;
	__u8 data[0];
};

struct drm_i915_query_topology_info {
	__u16 flags;
	__u16 max_slices;
	__u16 max_subslices;
	__u16 max_eus_per_subslice;
	__u16 subslice_offset;
	__u16 subslice_stride;
	__u16 eu_offset;
	__u16 eu_stride;
	__u8 data[0];
};

struct drm_i915_reg_descriptor {
	i915_reg_t addr;
	u32 mask;
	u32 value;
};

struct drm_i915_reg_read {
	__u64 offset;
	__u64 val;
};

struct drm_i915_reg_table {
	const struct drm_i915_reg_descriptor *regs;
	int num_regs;
};

struct drm_i915_reset_stats {
	__u32 ctx_id;
	__u32 flags;
	__u32 reset_count;
	__u32 batch_active;
	__u32 batch_pending;
	__u32 pad;
};

struct drm_info_list {
	const char *name;
	int (*show)(struct seq_file *, void *);
	u32 driver_features;
	void *data;
};

struct drm_info_node {
	struct drm_minor *minor;
	const struct drm_info_list *info_ent;
	struct list_head list;
	struct dentry *dent;
};

struct drm_intel_overlay_attrs {
	__u32 flags;
	__u32 color_key;
	__s32 brightness;
	__u32 contrast;
	__u32 saturation;
	__u32 gamma0;
	__u32 gamma1;
	__u32 gamma2;
	__u32 gamma3;
	__u32 gamma4;
	__u32 gamma5;
};

struct drm_intel_overlay_put_image {
	__u32 flags;
	__u32 bo_handle;
	__u16 stride_Y;
	__u16 stride_UV;
	__u32 offset_Y;
	__u32 offset_U;
	__u32 offset_V;
	__u16 src_width;
	__u16 src_height;
	__u16 src_scan_width;
	__u16 src_scan_height;
	__u32 crtc_id;
	__u16 dst_x;
	__u16 dst_y;
	__u16 dst_width;
	__u16 dst_height;
};

struct drm_intel_sprite_colorkey {
	__u32 plane_id;
	__u32 min_value;
	__u32 channel_mask;
	__u32 max_value;
	__u32 flags;
};

typedef int drm_ioctl_t(struct drm_device *, void *, struct drm_file *);

struct drm_ioctl_desc {
	unsigned int cmd;
	enum drm_ioctl_flags flags;
	drm_ioctl_t *func;
	const char *name;
};

struct drm_master {
	struct kref refcount;
	struct drm_device *dev;
	char *unique;
	int unique_len;
	struct idr magic_map;
	void *driver_priv;
	struct drm_master *lessor;
	int lessee_id;
	struct list_head lessee_list;
	struct list_head lessees;
	struct idr leases;
	struct idr lessee_idr;
};

struct drm_memory_stats {
	u64 shared;
	u64 private;
	u64 resident;
	u64 purgeable;
	u64 active;
};

struct drm_minor {
	int index;
	int type;
	struct device *kdev;
	struct drm_device *dev;
	struct dentry *debugfs_symlink;
	struct dentry *debugfs_root;
};

struct drm_mm_scan {
	struct drm_mm *mm;
	u64 size;
	u64 alignment;
	u64 remainder_mask;
	u64 range_start;
	u64 range_end;
	u64 hit_start;
	u64 hit_end;
	long unsigned int color;
	enum drm_mm_insert_mode mode;
};

struct drm_mode_atomic {
	__u32 flags;
	__u32 count_objs;
	__u64 objs_ptr;
	__u64 count_props_ptr;
	__u64 props_ptr;
	__u64 prop_values_ptr;
	__u64 reserved;
	__u64 user_data;
};

struct drm_mode_card_res {
	__u64 fb_id_ptr;
	__u64 crtc_id_ptr;
	__u64 connector_id_ptr;
	__u64 encoder_id_ptr;
	__u32 count_fbs;
	__u32 count_crtcs;
	__u32 count_connectors;
	__u32 count_encoders;
	__u32 min_width;
	__u32 max_width;
	__u32 min_height;
	__u32 max_height;
};

struct drm_mode_closefb {
	__u32 fb_id;
	__u32 pad;
};

struct drm_mode_fb_cmd2;

struct drm_mode_config_funcs {
	struct drm_framebuffer * (*fb_create)(struct drm_device *, struct drm_file *, const struct drm_mode_fb_cmd2 *);
	const struct drm_format_info * (*get_format_info)(const struct drm_mode_fb_cmd2 *);
	enum drm_mode_status (*mode_valid)(struct drm_device *, const struct drm_display_mode *);
	int (*atomic_check)(struct drm_device *, struct drm_atomic_state *);
	int (*atomic_commit)(struct drm_device *, struct drm_atomic_state *, bool);
	struct drm_atomic_state * (*atomic_state_alloc)(struct drm_device *);
	void (*atomic_state_clear)(struct drm_atomic_state *);
	void (*atomic_state_free)(struct drm_atomic_state *);
};

struct drm_mode_config_helper_funcs {
	void (*atomic_commit_tail)(struct drm_atomic_state *);
	int (*atomic_commit_setup)(struct drm_atomic_state *);
};

struct drm_mode_connector_set_property {
	__u64 value;
	__u32 prop_id;
	__u32 connector_id;
};

struct drm_mode_create_blob {
	__u64 data;
	__u32 length;
	__u32 blob_id;
};

struct drm_mode_create_dumb {
	__u32 height;
	__u32 width;
	__u32 bpp;
	__u32 flags;
	__u32 handle;
	__u32 pitch;
	__u64 size;
};

struct drm_mode_create_lease {
	__u64 object_ids;
	__u32 object_count;
	__u32 flags;
	__u32 lessee_id;
	__u32 fd;
};

struct drm_mode_modeinfo {
	__u32 clock;
	__u16 hdisplay;
	__u16 hsync_start;
	__u16 hsync_end;
	__u16 htotal;
	__u16 hskew;
	__u16 vdisplay;
	__u16 vsync_start;
	__u16 vsync_end;
	__u16 vtotal;
	__u16 vscan;
	__u32 vrefresh;
	__u32 flags;
	__u32 type;
	char name[32];
};

struct drm_mode_crtc {
	__u64 set_connectors_ptr;
	__u32 count_connectors;
	__u32 crtc_id;
	__u32 fb_id;
	__u32 x;
	__u32 y;
	__u32 gamma_size;
	__u32 mode_valid;
	struct drm_mode_modeinfo mode;
};

struct drm_mode_crtc_lut {
	__u32 crtc_id;
	__u32 gamma_size;
	__u64 red;
	__u64 green;
	__u64 blue;
};

struct drm_mode_crtc_page_flip_target {
	__u32 crtc_id;
	__u32 fb_id;
	__u32 flags;
	__u32 sequence;
	__u64 user_data;
};

struct drm_mode_cursor {
	__u32 flags;
	__u32 crtc_id;
	__s32 x;
	__s32 y;
	__u32 width;
	__u32 height;
	__u32 handle;
};

struct drm_mode_cursor2 {
	__u32 flags;
	__u32 crtc_id;
	__s32 x;
	__s32 y;
	__u32 width;
	__u32 height;
	__u32 handle;
	__s32 hot_x;
	__s32 hot_y;
};

struct drm_mode_destroy_blob {
	__u32 blob_id;
};

struct drm_mode_destroy_dumb {
	__u32 handle;
};

struct drm_mode_fb_cmd {
	__u32 fb_id;
	__u32 width;
	__u32 height;
	__u32 pitch;
	__u32 bpp;
	__u32 depth;
	__u32 handle;
};

struct drm_mode_fb_cmd2 {
	__u32 fb_id;
	__u32 width;
	__u32 height;
	__u32 pixel_format;
	__u32 flags;
	__u32 handles[4];
	__u32 pitches[4];
	__u32 offsets[4];
	__u64 modifier[4];
};

struct drm_mode_fb_dirty_cmd {
	__u32 fb_id;
	__u32 flags;
	__u32 color;
	__u32 num_clips;
	__u64 clips_ptr;
};

struct drm_mode_get_blob {
	__u32 blob_id;
	__u32 length;
	__u64 data;
};

struct drm_mode_get_connector {
	__u64 encoders_ptr;
	__u64 modes_ptr;
	__u64 props_ptr;
	__u64 prop_values_ptr;
	__u32 count_modes;
	__u32 count_props;
	__u32 count_encoders;
	__u32 encoder_id;
	__u32 connector_id;
	__u32 connector_type;
	__u32 connector_type_id;
	__u32 connection;
	__u32 mm_width;
	__u32 mm_height;
	__u32 subpixel;
	__u32 pad;
};

struct drm_mode_get_encoder {
	__u32 encoder_id;
	__u32 encoder_type;
	__u32 crtc_id;
	__u32 possible_crtcs;
	__u32 possible_clones;
};

struct drm_mode_get_lease {
	__u32 count_objects;
	__u32 pad;
	__u64 objects_ptr;
};

struct drm_mode_get_plane {
	__u32 plane_id;
	__u32 crtc_id;
	__u32 fb_id;
	__u32 possible_crtcs;
	__u32 gamma_size;
	__u32 count_format_types;
	__u64 format_type_ptr;
};

struct drm_mode_get_plane_res {
	__u64 plane_id_ptr;
	__u32 count_planes;
};

struct drm_mode_get_property {
	__u64 values_ptr;
	__u64 enum_blob_ptr;
	__u32 prop_id;
	__u32 flags;
	char name[32];
	__u32 count_values;
	__u32 count_enum_blobs;
};

struct drm_mode_list_lessees {
	__u32 count_lessees;
	__u32 pad;
	__u64 lessees_ptr;
};

struct drm_mode_map_dumb {
	__u32 handle;
	__u32 pad;
	__u64 offset;
};

struct drm_mode_obj_get_properties {
	__u64 props_ptr;
	__u64 prop_values_ptr;
	__u32 count_props;
	__u32 obj_id;
	__u32 obj_type;
};

struct drm_mode_obj_set_property {
	__u64 value;
	__u32 prop_id;
	__u32 obj_id;
	__u32 obj_type;
};

struct drm_mode_property_enum {
	__u64 value;
	char name[32];
};

struct drm_mode_rect {
	__s32 x1;
	__s32 y1;
	__s32 x2;
	__s32 y2;
};

struct drm_mode_revoke_lease {
	__u32 lessee_id;
};

struct drm_mode_rmfb_work {
	struct work_struct work;
	struct list_head fbs;
};

struct drm_mode_set {
	struct drm_framebuffer *fb;
	struct drm_crtc *crtc;
	struct drm_display_mode *mode;
	uint32_t x;
	uint32_t y;
	struct drm_connector **connectors;
	size_t num_connectors;
};

struct drm_mode_set_plane {
	__u32 plane_id;
	__u32 crtc_id;
	__u32 fb_id;
	__u32 flags;
	__s32 crtc_x;
	__s32 crtc_y;
	__u32 crtc_w;
	__u32 crtc_h;
	__u32 src_x;
	__u32 src_y;
	__u32 src_h;
	__u32 src_w;
};

struct drm_named_mode {
	const char *name;
	unsigned int pixel_clock_khz;
	unsigned int xres;
	unsigned int yres;
	unsigned int flags;
	unsigned int tv_mode;
};

struct sync_file;

struct drm_out_fence_state {
	s32 *out_fence_ptr;
	struct sync_file *sync_file;
	int fd;
};

struct drm_panel_funcs;

struct drm_panel {
	struct device *dev;
	struct backlight_device *backlight;
	const struct drm_panel_funcs *funcs;
	int connector_type;
	struct list_head list;
	struct list_head followers;
	struct mutex follower_lock;
	bool prepare_prev_first;
	bool prepared;
	bool enabled;
};

struct drm_panel_follower_funcs;

struct drm_panel_follower {
	const struct drm_panel_follower_funcs *funcs;
	struct list_head list;
	struct drm_panel *panel;
};

struct drm_panel_follower_funcs {
	int (*panel_prepared)(struct drm_panel_follower *);
	int (*panel_unpreparing)(struct drm_panel_follower *);
};

struct display_timing;

struct drm_panel_funcs {
	int (*prepare)(struct drm_panel *);
	int (*enable)(struct drm_panel *);
	int (*disable)(struct drm_panel *);
	int (*unprepare)(struct drm_panel *);
	int (*get_modes)(struct drm_panel *, struct drm_connector *);
	enum drm_panel_orientation (*get_orientation)(struct drm_panel *);
	int (*get_timings)(struct drm_panel *, unsigned int, struct display_timing *);
	void (*debugfs_init)(struct drm_panel *, struct dentry *);
};

struct drm_pending_event {
	struct completion *completion;
	void (*completion_release)(struct completion *);
	struct drm_event *event;
	struct dma_fence *fence;
	struct drm_file *file_priv;
	struct list_head link;
	struct list_head pending_link;
};

struct drm_pending_vblank_event {
	struct drm_pending_event base;
	unsigned int pipe;
	u64 sequence;
	union {
		struct drm_event base;
		struct drm_event_vblank vbl;
		struct drm_event_crtc_sequence seq;
	} event;
};

struct kmsg_dump_detail;

struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *, struct kmsg_dump_detail *);
	enum kmsg_dump_reason max_reason;
	bool registered;
};

struct drm_plane_funcs;

struct drm_plane_helper_funcs;

struct drm_plane {
	struct drm_device *dev;
	struct list_head head;
	char *name;
	struct drm_modeset_lock mutex;
	struct drm_mode_object base;
	uint32_t possible_crtcs;
	uint32_t *format_types;
	unsigned int format_count;
	bool format_default;
	uint64_t *modifiers;
	unsigned int modifier_count;
	struct drm_crtc *crtc;
	struct drm_framebuffer *fb;
	struct drm_framebuffer *old_fb;
	const struct drm_plane_funcs *funcs;
	struct drm_object_properties properties;
	enum drm_plane_type type;
	unsigned int index;
	const struct drm_plane_helper_funcs *helper_private;
	struct drm_plane_state *state;
	struct drm_property *alpha_property;
	struct drm_property *zpos_property;
	struct drm_property *rotation_property;
	struct drm_property *blend_mode_property;
	struct drm_property *color_encoding_property;
	struct drm_property *color_range_property;
	struct drm_property *scaling_filter_property;
	struct drm_property *hotspot_x_property;
	struct drm_property *hotspot_y_property;
	struct kmsg_dumper kmsg_panic;
};

struct drm_plane_funcs {
	int (*update_plane)(struct drm_plane *, struct drm_crtc *, struct drm_framebuffer *, int, int, unsigned int, unsigned int, uint32_t, uint32_t, uint32_t, uint32_t, struct drm_modeset_acquire_ctx *);
	int (*disable_plane)(struct drm_plane *, struct drm_modeset_acquire_ctx *);
	void (*destroy)(struct drm_plane *);
	void (*reset)(struct drm_plane *);
	int (*set_property)(struct drm_plane *, struct drm_property *, uint64_t);
	struct drm_plane_state * (*atomic_duplicate_state)(struct drm_plane *);
	void (*atomic_destroy_state)(struct drm_plane *, struct drm_plane_state *);
	int (*atomic_set_property)(struct drm_plane *, struct drm_plane_state *, struct drm_property *, uint64_t);
	int (*atomic_get_property)(struct drm_plane *, const struct drm_plane_state *, struct drm_property *, uint64_t *);
	int (*late_register)(struct drm_plane *);
	void (*early_unregister)(struct drm_plane *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_plane_state *);
	bool (*format_mod_supported)(struct drm_plane *, uint32_t, uint64_t);
};

struct drm_scanout_buffer;

struct drm_plane_helper_funcs {
	int (*prepare_fb)(struct drm_plane *, struct drm_plane_state *);
	void (*cleanup_fb)(struct drm_plane *, struct drm_plane_state *);
	int (*begin_fb_access)(struct drm_plane *, struct drm_plane_state *);
	void (*end_fb_access)(struct drm_plane *, struct drm_plane_state *);
	int (*atomic_check)(struct drm_plane *, struct drm_atomic_state *);
	void (*atomic_update)(struct drm_plane *, struct drm_atomic_state *);
	void (*atomic_enable)(struct drm_plane *, struct drm_atomic_state *);
	void (*atomic_disable)(struct drm_plane *, struct drm_atomic_state *);
	int (*atomic_async_check)(struct drm_plane *, struct drm_atomic_state *);
	void (*atomic_async_update)(struct drm_plane *, struct drm_atomic_state *);
	int (*get_scanout_buffer)(struct drm_plane *, struct drm_scanout_buffer *);
	void (*panic_flush)(struct drm_plane *);
};

struct drm_plane_size_hint {
	__u16 width;
	__u16 height;
};

struct drm_plane_state {
	struct drm_plane *plane;
	struct drm_crtc *crtc;
	struct drm_framebuffer *fb;
	struct dma_fence *fence;
	int32_t crtc_x;
	int32_t crtc_y;
	uint32_t crtc_w;
	uint32_t crtc_h;
	uint32_t src_x;
	uint32_t src_y;
	uint32_t src_h;
	uint32_t src_w;
	int32_t hotspot_x;
	int32_t hotspot_y;
	u16 alpha;
	uint16_t pixel_blend_mode;
	unsigned int rotation;
	unsigned int zpos;
	unsigned int normalized_zpos;
	enum drm_color_encoding color_encoding;
	enum drm_color_range color_range;
	struct drm_property_blob *fb_damage_clips;
	bool ignore_damage_clips;
	struct drm_rect src;
	struct drm_rect dst;
	bool visible;
	enum drm_scaling_filter scaling_filter;
	struct drm_crtc_commit *commit;
	struct drm_atomic_state *state;
	bool color_mgmt_changed: 1;
};

struct drm_prime_handle {
	__u32 handle;
	__u32 flags;
	__s32 fd;
};

struct drm_prime_member {
	struct dma_buf *dma_buf;
	uint32_t handle;
	struct rb_node dmabuf_rb;
	struct rb_node handle_rb;
};

struct drm_print_iterator {
	void *data;
	ssize_t start;
	ssize_t remain;
	ssize_t offset;
};

struct va_format;

struct drm_printer {
	void (*printfn)(struct drm_printer *, struct va_format *);
	void (*puts)(struct drm_printer *, const char *);
	void *arg;
	const void *origin;
	const char *prefix;
	struct {
		unsigned int series;
		unsigned int counter;
	} line;
	enum drm_debug_category category;
};

struct drm_private_state_funcs {
	struct drm_private_state * (*atomic_duplicate_state)(struct drm_private_obj *);
	void (*atomic_destroy_state)(struct drm_private_obj *, struct drm_private_state *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_private_state *);
};

struct drm_prop_enum_list {
	int type;
	const char *name;
};

struct drm_property {
	struct list_head head;
	struct drm_mode_object base;
	uint32_t flags;
	char name[32];
	uint32_t num_values;
	uint64_t *values;
	struct drm_device *dev;
	struct list_head enum_list;
};

struct drm_property_blob {
	struct drm_mode_object base;
	struct drm_device *dev;
	struct list_head head_global;
	struct list_head head_file;
	size_t length;
	void *data;
};

struct drm_property_enum {
	uint64_t value;
	struct list_head head;
	char name[32];
};

struct drm_scanout_buffer {
	const struct drm_format_info *format;
	struct iosys_map map[4];
	unsigned int width;
	unsigned int height;
	unsigned int pitch[4];
	void (*set_pixel)(struct drm_scanout_buffer *, unsigned int, unsigned int, u32);
};

struct ewma_psr_time {
	long unsigned int internal;
};

struct drm_self_refresh_data {
	struct drm_crtc *crtc;
	struct delayed_work entry_work;
	struct mutex avg_mutex;
	struct ewma_psr_time entry_avg_ms;
	struct ewma_psr_time exit_avg_ms;
};

struct drm_set_client_cap {
	__u64 capability;
	__u64 value;
};

struct drm_set_client_name {
	__u64 name_len;
	__u64 name;
};

struct drm_set_version {
	int drm_di_major;
	int drm_di_minor;
	int drm_dd_major;
	int drm_dd_minor;
};

struct drm_shadow_plane_state {
	struct drm_plane_state base;
	struct drm_format_conv_state fmtcnv_state;
	struct iosys_map map[4];
	struct iosys_map data[4];
};

struct drm_simple_display_pipe_funcs;

struct drm_simple_display_pipe {
	struct drm_crtc crtc;
	struct drm_plane plane;
	struct drm_encoder encoder;
	struct drm_connector *connector;
	const struct drm_simple_display_pipe_funcs *funcs;
};

struct drm_simple_display_pipe_funcs {
	enum drm_mode_status (*mode_valid)(struct drm_simple_display_pipe *, const struct drm_display_mode *);
	void (*enable)(struct drm_simple_display_pipe *, struct drm_crtc_state *, struct drm_plane_state *);
	void (*disable)(struct drm_simple_display_pipe *);
	int (*check)(struct drm_simple_display_pipe *, struct drm_plane_state *, struct drm_crtc_state *);
	void (*update)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	int (*prepare_fb)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	void (*cleanup_fb)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	int (*begin_fb_access)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	void (*end_fb_access)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	int (*enable_vblank)(struct drm_simple_display_pipe *);
	void (*disable_vblank)(struct drm_simple_display_pipe *);
	void (*reset_crtc)(struct drm_simple_display_pipe *);
	struct drm_crtc_state * (*duplicate_crtc_state)(struct drm_simple_display_pipe *);
	void (*destroy_crtc_state)(struct drm_simple_display_pipe *, struct drm_crtc_state *);
	void (*reset_plane)(struct drm_simple_display_pipe *);
	struct drm_plane_state * (*duplicate_plane_state)(struct drm_simple_display_pipe *);
	void (*destroy_plane_state)(struct drm_simple_display_pipe *, struct drm_plane_state *);
};

struct drm_stats {
	long unsigned int count;
	struct {
		long unsigned int value;
		enum drm_stat_type type;
	} data[15];
};

struct drm_syncobj {
	struct kref refcount;
	struct dma_fence *fence;
	struct list_head cb_list;
	struct list_head ev_fd_list;
	spinlock_t lock;
	struct file *file;
};

struct drm_syncobj_array {
	__u64 handles;
	__u32 count_handles;
	__u32 pad;
};

struct drm_syncobj_create {
	__u32 handle;
	__u32 flags;
};

struct drm_syncobj_destroy {
	__u32 handle;
	__u32 pad;
};

struct drm_syncobj_eventfd {
	__u32 handle;
	__u32 flags;
	__u64 point;
	__s32 fd;
	__u32 pad;
};

struct drm_syncobj_handle {
	__u32 handle;
	__u32 flags;
	__s32 fd;
	__u32 pad;
};

struct drm_syncobj_timeline_array {
	__u64 handles;
	__u64 points;
	__u32 count_handles;
	__u32 flags;
};

struct drm_syncobj_timeline_wait {
	__u64 handles;
	__u64 points;
	__s64 timeout_nsec;
	__u32 count_handles;
	__u32 flags;
	__u32 first_signaled;
	__u32 pad;
	__u64 deadline_nsec;
};

struct drm_syncobj_transfer {
	__u32 src_handle;
	__u32 dst_handle;
	__u64 src_point;
	__u64 dst_point;
	__u32 flags;
	__u32 pad;
};

struct drm_syncobj_wait {
	__u64 handles;
	__s64 timeout_nsec;
	__u32 count_handles;
	__u32 flags;
	__u32 first_signaled;
	__u32 pad;
	__u64 deadline_nsec;
};

struct drm_tile_group {
	struct kref refcount;
	struct drm_device *dev;
	int id;
	u8 group_data[8];
};

struct drm_unique {
	__kernel_size_t unique_len;
	char *unique;
};

struct drm_vblank_crtc_config {
	int offdelay_ms;
	bool disable_immediate;
};

struct drm_vblank_crtc {
	struct drm_device *dev;
	wait_queue_head_t queue;
	struct timer_list disable_timer;
	seqlock_t seqlock;
	atomic64_t count;
	ktime_t time;
	atomic_t refcount;
	u32 last;
	u32 max_vblank_count;
	unsigned int inmodeset;
	unsigned int pipe;
	int framedur_ns;
	int linedur_ns;
	struct drm_display_mode hwmode;
	struct drm_vblank_crtc_config config;
	bool enabled;
	struct kthread_worker *worker;
	struct list_head pending_work;
	wait_queue_head_t work_wait_queue;
};

struct drm_vblank_work {
	struct kthread_work base;
	struct drm_vblank_crtc *vblank;
	u64 count;
	int cancelling;
	struct list_head node;
};

struct drm_version {
	int version_major;
	int version_minor;
	int version_patchlevel;
	__kernel_size_t name_len;
	char *name;
	__kernel_size_t date_len;
	char *date;
	__kernel_size_t desc_len;
	char *desc;
};

struct drm_virtgpu_3d_box {
	__u32 x;
	__u32 y;
	__u32 z;
	__u32 w;
	__u32 h;
	__u32 d;
};

struct drm_virtgpu_3d_transfer_from_host {
	__u32 bo_handle;
	struct drm_virtgpu_3d_box box;
	__u32 level;
	__u32 offset;
	__u32 stride;
	__u32 layer_stride;
};

struct drm_virtgpu_3d_transfer_to_host {
	__u32 bo_handle;
	struct drm_virtgpu_3d_box box;
	__u32 level;
	__u32 offset;
	__u32 stride;
	__u32 layer_stride;
};

struct drm_virtgpu_3d_wait {
	__u32 handle;
	__u32 flags;
};

struct drm_virtgpu_context_init {
	__u32 num_params;
	__u32 pad;
	__u64 ctx_set_params;
};

struct drm_virtgpu_context_set_param {
	__u64 param;
	__u64 value;
};

struct drm_virtgpu_execbuffer {
	__u32 flags;
	__u32 size;
	__u64 command;
	__u64 bo_handles;
	__u32 num_bo_handles;
	__s32 fence_fd;
	__u32 ring_idx;
	__u32 syncobj_stride;
	__u32 num_in_syncobjs;
	__u32 num_out_syncobjs;
	__u64 in_syncobjs;
	__u64 out_syncobjs;
};

struct drm_virtgpu_execbuffer_syncobj {
	__u32 handle;
	__u32 flags;
	__u64 point;
};

struct drm_virtgpu_get_caps {
	__u32 cap_set_id;
	__u32 cap_set_ver;
	__u64 addr;
	__u32 size;
	__u32 pad;
};

struct drm_virtgpu_getparam {
	__u64 param;
	__u64 value;
};

struct drm_virtgpu_map {
	__u64 offset;
	__u32 handle;
	__u32 pad;
};

struct drm_virtgpu_resource_create {
	__u32 target;
	__u32 format;
	__u32 bind;
	__u32 width;
	__u32 height;
	__u32 depth;
	__u32 array_size;
	__u32 last_level;
	__u32 nr_samples;
	__u32 flags;
	__u32 bo_handle;
	__u32 res_handle;
	__u32 size;
	__u32 stride;
};

struct drm_virtgpu_resource_create_blob {
	__u32 blob_mem;
	__u32 blob_flags;
	__u32 bo_handle;
	__u32 res_handle;
	__u64 size;
	__u32 pad;
	__u32 cmd_size;
	__u64 cmd;
	__u64 blob_id;
};

struct drm_virtgpu_resource_info {
	__u32 bo_handle;
	__u32 res_handle;
	__u32 size;
	__u32 blob_mem;
};

struct drm_vma_offset_file {
	struct rb_node vm_rb;
	struct drm_file *vm_tag;
	long unsigned int vm_count;
};

struct drm_vma_offset_manager {
	rwlock_t vm_lock;
	struct drm_mm vm_addr_space_mm;
};

struct drm_wait_vblank_request {
	enum drm_vblank_seq_type type;
	unsigned int sequence;
	long unsigned int signal;
};

struct drm_wait_vblank_reply {
	enum drm_vblank_seq_type type;
	unsigned int sequence;
	long int tval_sec;
	long int tval_usec;
};

union drm_wait_vblank {
	struct drm_wait_vblank_request request;
	struct drm_wait_vblank_reply reply;
};

struct drm_writeback_connector {
	struct drm_connector base;
	struct drm_encoder encoder;
	struct drm_property_blob *pixel_formats_blob_ptr;
	spinlock_t job_lock;
	struct list_head job_queue;
	unsigned int fence_context;
	spinlock_t fence_lock;
	long unsigned int fence_seqno;
	char timeline_name[32];
};

struct drm_writeback_job {
	struct drm_writeback_connector *connector;
	bool prepared;
	struct work_struct cleanup_work;
	struct list_head list_entry;
	struct drm_framebuffer *fb;
	struct dma_fence *out_fence;
	void *priv;
};

typedef void (*drmres_release_t)(struct drm_device *, void *);

struct drmres_node {
	struct list_head entry;
	drmres_release_t release;
	const char *name;
	size_t size;
};

struct drmres {
	struct drmres_node node;
	u8 data[0];
};

struct drop_reason_list {
	const char * const *reasons;
	size_t n_reasons;
};

struct drr_class {
	struct Qdisc_class_common common;
	long: 64;
	struct gnet_stats_basic_sync bstats;
	struct gnet_stats_queue qstats;
	struct net_rate_estimator *rate_est;
	struct list_head alist;
	struct Qdisc *qdisc;
	u32 quantum;
	u32 deficit;
};

struct drr_sched {
	struct list_head active;
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct Qdisc_class_hash clhash;
};

struct drv_cmd {
	struct acpi_pct_register *reg;
	u32 val;
	union {
		void (*write)(struct acpi_pct_register *, u32);
		u32 (*read)(struct acpi_pct_register *);
	} func;
};

struct pci_driver;

struct pci_device_id;

struct drv_dev_and_id {
	struct pci_driver *drv;
	struct pci_dev *dev;
	const struct pci_device_id *id;
};

struct dst_cache_pcpu;

struct dst_cache {
	struct dst_cache_pcpu *cache;
	long unsigned int reset_ts;
};

struct dst_cache_pcpu {
	long unsigned int refresh_ts;
	struct dst_entry *dst;
	u32 cookie;
	union {
		struct in_addr in_saddr;
		struct in6_addr in6_saddr;
	};
};

struct dst_ops;

struct xfrm_state;

struct uncached_list;

struct lwtunnel_state;

struct dst_entry {
	struct net_device *dev;
	struct dst_ops *ops;
	long unsigned int _metrics;
	long unsigned int expires;
	struct xfrm_state *xfrm;
	int (*input)(struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	short unsigned int flags;
	short int obsolete;
	short unsigned int header_len;
	short unsigned int trailer_len;
	rcuref_t __rcuref;
	int __use;
	long unsigned int lastuse;
	struct callback_head callback_head;
	short int error;
	short int __pad;
	__u32 tclassid;
	netdevice_tracker dev_tracker;
	struct list_head rt_uncached;
	struct uncached_list *rt_uncached_list;
	struct lwtunnel_state *lwtstate;
};

struct dst_metrics {
	u32 metrics[17];
	refcount_t refcnt;
};

struct dst_ops {
	short unsigned int family;
	unsigned int gc_thresh;
	void (*gc)(struct dst_ops *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device *);
	void (*negative_advice)(struct sock *, struct dst_entry *);
	void (*link_failure)(struct sk_buff *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	struct percpu_counter pcpuc_entries;
	long: 64;
	long: 64;
	long: 64;
};

struct dsthash_dst {
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ip;
		struct {
			__be32 src[4];
			__be32 dst[4];
		} ip6;
	};
	__be16 src_port;
	__be16 dst_port;
};

struct dsthash_ent {
	struct hlist_node node;
	struct dsthash_dst dst;
	spinlock_t lock;
	long unsigned int expires;
	struct {
		long unsigned int prev;
		union {
			struct {
				u_int64_t credit;
				u_int64_t credit_cap;
				u_int64_t cost;
			};
			struct {
				u_int32_t interval;
				u_int32_t prev_window;
				u_int64_t current_rate;
				u_int64_t rate;
				int64_t burst;
			};
		};
	} rateinfo;
	struct callback_head rcu;
};

struct uart_8250_port;

struct uart_8250_dma {
	int (*tx_dma)(struct uart_8250_port *);
	int (*rx_dma)(struct uart_8250_port *);
	void (*prepare_tx_dma)(struct uart_8250_port *);
	void (*prepare_rx_dma)(struct uart_8250_port *);
	dma_filter_fn fn;
	void *rx_param;
	void *tx_param;
	struct dma_slave_config rxconf;
	struct dma_slave_config txconf;
	struct dma_chan *rxchan;
	struct dma_chan *txchan;
	phys_addr_t rx_dma_addr;
	phys_addr_t tx_dma_addr;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	void *rx_buf;
	size_t rx_size;
	size_t tx_size;
	unsigned char tx_running;
	unsigned char tx_err;
	unsigned char rx_running;
};

struct dw8250_port_data {
	int line;
	struct uart_8250_dma dma;
	u32 cpr_value;
	u8 dlf_size;
	bool hw_rs485_support;
};

struct dw_lli {
	__le32 sar;
	__le32 dar;
	__le32 llp;
	__le32 ctllo;
	__le32 ctlhi;
	__le32 sstat;
	__le32 dstat;
};

struct dw_desc {
	struct dw_lli lli;
	struct list_head desc_node;
	struct list_head tx_list;
	struct dma_async_tx_descriptor txd;
	size_t len;
	size_t total_len;
	u32 residue;
};

struct dw_dma_chan;

struct dw_dma_platform_data;

struct dw_dma {
	struct dma_device dma;
	char name[20];
	void *regs;
	struct dma_pool *desc_pool;
	struct tasklet_struct tasklet;
	struct dw_dma_chan *chan;
	u8 all_chan_mask;
	u8 in_use;
	void (*initialize_chan)(struct dw_dma_chan *);
	void (*suspend_chan)(struct dw_dma_chan *, bool);
	void (*resume_chan)(struct dw_dma_chan *, bool);
	u32 (*prepare_ctllo)(struct dw_dma_chan *);
	u32 (*bytes2block)(struct dw_dma_chan *, size_t, unsigned int, size_t *);
	size_t (*block2bytes)(struct dw_dma_chan *, u32, u32);
	void (*set_device_name)(struct dw_dma *, int);
	void (*disable)(struct dw_dma *);
	void (*enable)(struct dw_dma *);
	struct dw_dma_platform_data *pdata;
};

struct dw_dma_slave {
	struct device *dma_dev;
	u8 src_id;
	u8 dst_id;
	u8 m_master;
	u8 p_master;
	u8 channels;
	bool hs_polarity;
};

struct dw_dma_chan {
	struct dma_chan chan;
	void *ch_regs;
	u8 mask;
	u8 priority;
	enum dma_transfer_direction direction;
	struct list_head *tx_node_active;
	spinlock_t lock;
	long unsigned int flags;
	struct list_head active_list;
	struct list_head queue;
	unsigned int descs_allocated;
	unsigned int block_size;
	bool nollp;
	u32 max_burst;
	struct dw_dma_slave dws;
	struct dma_slave_config dma_sconfig;
};

struct dw_dma_chan_regs {
	u32 SAR;
	u32 __pad_SAR;
	u32 DAR;
	u32 __pad_DAR;
	u32 LLP;
	u32 __pad_LLP;
	u32 CTL_LO;
	u32 CTL_HI;
	u32 SSTAT;
	u32 __pad_SSTAT;
	u32 DSTAT;
	u32 __pad_DSTAT;
	u32 SSTATAR;
	u32 __pad_SSTATAR;
	u32 DSTATAR;
	u32 __pad_DSTATAR;
	u32 CFG_LO;
	u32 CFG_HI;
	u32 SGR;
	u32 __pad_SGR;
	u32 DSR;
	u32 __pad_DSR;
};

struct dw_dma_chip {
	struct device *dev;
	int id;
	int irq;
	void *regs;
	struct clk *clk;
	struct dw_dma *dw;
	const struct dw_dma_platform_data *pdata;
};

struct dw_dma_chip_pdata {
	const struct dw_dma_platform_data *pdata;
	int (*probe)(struct dw_dma_chip *);
	int (*remove)(struct dw_dma_chip *);
	struct dw_dma_chip *chip;
	u8 m_master;
	u8 p_master;
};

struct dw_dma_irq_regs {
	u32 XFER;
	u32 __pad_XFER;
	u32 BLOCK;
	u32 __pad_BLOCK;
	u32 SRC_TRAN;
	u32 __pad_SRC_TRAN;
	u32 DST_TRAN;
	u32 __pad_DST_TRAN;
	u32 ERROR;
	u32 __pad_ERROR;
};

struct dw_dma_platform_data {
	u32 nr_masters;
	u32 nr_channels;
	u32 chan_allocation_order;
	u32 chan_priority;
	u32 block_size;
	u32 data_width[4];
	u32 multi_block[8];
	u32 max_burst[8];
	u32 protctl;
	u32 quirks;
};

struct dw_dma_regs {
	struct dw_dma_chan_regs CHAN[8];
	struct dw_dma_irq_regs RAW;
	struct dw_dma_irq_regs STATUS;
	struct dw_dma_irq_regs MASK;
	struct dw_dma_irq_regs CLEAR;
	u32 STATUS_INT;
	u32 __pad_STATUS_INT;
	u32 REQ_SRC;
	u32 __pad_REQ_SRC;
	u32 REQ_DST;
	u32 __pad_REQ_DST;
	u32 SGL_REQ_SRC;
	u32 __pad_SGL_REQ_SRC;
	u32 SGL_REQ_DST;
	u32 __pad_SGL_REQ_DST;
	u32 LAST_SRC;
	u32 __pad_LAST_SRC;
	u32 LAST_DST;
	u32 __pad_LAST_DST;
	u32 CFG;
	u32 __pad_CFG;
	u32 CH_EN;
	u32 __pad_CH_EN;
	u32 ID;
	u32 __pad_ID;
	u32 TEST;
	u32 __pad_TEST;
	u32 CLASS_PRIORITY0;
	u32 __pad_CLASS_PRIORITY0;
	u32 CLASS_PRIORITY1;
	u32 __pad_CLASS_PRIORITY1;
	u32 __reserved;
	u32 DWC_PARAMS[8];
	u32 MULTI_BLK_TYPE;
	u32 MAX_BLK_SIZE;
	u32 DW_PARAMS;
	u32 COMP_TYPE;
	u32 COMP_VERSION;
	u32 FIFO_PARTITION0;
	u32 __pad_FIFO_PARTITION0;
	u32 FIFO_PARTITION1;
	u32 __pad_FIFO_PARTITION1;
	u32 SAI_ERR;
	u32 __pad_SAI_ERR;
	u32 GLOBAL_CFG;
	u32 __pad_GLOBAL_CFG;
};

struct dx_countlimit {
	__le16 limit;
	__le16 count;
};

struct dx_entry {
	__le32 hash;
	__le32 block;
};

struct dx_frame {
	struct buffer_head *bh;
	struct dx_entry *entries;
	struct dx_entry *at;
};

struct dx_hash_info {
	u32 hash;
	u32 minor_hash;
	int hash_version;
	u32 *seed;
};

struct dx_map_entry {
	u32 hash;
	u16 offs;
	u16 size;
};

struct fake_dirent {
	__le32 inode;
	__le16 rec_len;
	u8 name_len;
	u8 file_type;
};

struct dx_node {
	struct fake_dirent fake;
	struct dx_entry entries[0];
};

struct dx_root_info {
	__le32 reserved_zero;
	u8 hash_version;
	u8 info_length;
	u8 indirect_levels;
	u8 unused_flags;
};

struct dx_root {
	struct fake_dirent dot;
	char dot_name[4];
	struct fake_dirent dotdot;
	char dotdot_name[4];
	struct dx_root_info info;
	struct dx_entry entries[0];
};

struct dx_tail {
	u32 dt_reserved;
	__le32 dt_checksum;
};

struct dyn_event_operations;

struct dyn_event {
	struct list_head list;
	struct dyn_event_operations *ops;
};

struct dyn_event_operations {
	struct list_head list;
	int (*create)(const char *);
	int (*show)(struct seq_file *, struct dyn_event *);
	bool (*is_busy)(struct dyn_event *);
	int (*free)(struct dyn_event *);
	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
};

struct dynevent_arg {
	const char *str;
	char separator;
};

struct dynevent_arg_pair {
	const char *lhs;
	const char *rhs;
	char operator;
	char separator;
};

struct seq_buf {
	char *buffer;
	size_t size;
	size_t len;
};

struct dynevent_cmd;

typedef int (*dynevent_create_fn_t)(struct dynevent_cmd *);

struct dynevent_cmd {
	struct seq_buf seq;
	const char *event_name;
	unsigned int n_fields;
	enum dynevent_type type;
	dynevent_create_fn_t run_command;
	void *private_data;
};

struct e820_entry {
	u64 addr;
	u64 size;
	enum e820_type type;
} __attribute__((packed));

struct e820_table {
	__u32 nr_entries;
	struct e820_entry entries[320];
};

struct early_load_data {
	u32 old_rev;
	u32 new_rev;
};

struct uart_icount {
	__u32 cts;
	__u32 dsr;
	__u32 rng;
	__u32 dcd;
	__u32 rx;
	__u32 tx;
	__u32 frame;
	__u32 overrun;
	__u32 parity;
	__u32 brk;
	__u32 buf_overrun;
};

struct serial_rs485 {
	__u32 flags;
	__u32 delay_rts_before_send;
	__u32 delay_rts_after_send;
	union {
		__u32 padding[5];
		struct {
			__u8 addr_recv;
			__u8 addr_dest;
			__u8 padding0[2];
			__u32 padding1[4];
		};
	};
};

struct gpio_desc;

struct serial_iso7816 {
	__u32 flags;
	__u32 tg;
	__u32 sc_fi;
	__u32 sc_di;
	__u32 clk;
	__u32 reserved[5];
};

struct ktermios;

struct uart_state;

struct uart_ops;

struct serial_port_device;

struct uart_port {
	spinlock_t lock;
	long unsigned int iobase;
	unsigned char *membase;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
	int (*rs485_config)(struct uart_port *, struct ktermios *, struct serial_rs485 *);
	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
	unsigned int ctrl_id;
	unsigned int port_id;
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	unsigned int fifosize;
	unsigned char x_char;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char quirks;
	unsigned int read_status_mask;
	unsigned int ignore_status_mask;
	struct uart_state *state;
	struct uart_icount icount;
	struct console *cons;
	upf_t flags;
	upstat_t status;
	bool hw_stopped;
	unsigned int mctrl;
	unsigned int frame_time;
	unsigned int type;
	const struct uart_ops *ops;
	unsigned int custom_divisor;
	unsigned int line;
	unsigned int minor;
	resource_size_t mapbase;
	resource_size_t mapsize;
	struct device *dev;
	struct serial_port_device *port_dev;
	long unsigned int sysrq;
	u8 sysrq_ch;
	unsigned char has_sysrq;
	unsigned char sysrq_seq;
	unsigned char hub6;
	unsigned char suspended;
	unsigned char console_reinit;
	const char *name;
	struct attribute_group *attr_group;
	const struct attribute_group **tty_groups;
	struct serial_rs485 rs485;
	struct serial_rs485 rs485_supported;
	struct gpio_desc *rs485_term_gpio;
	struct gpio_desc *rs485_rx_during_tx_gpio;
	struct serial_iso7816 iso7816;
	void *private_data;
};

struct earlycon_device {
	struct console *con;
	struct uart_port port;
	char options[32];
	unsigned int baud;
};

struct earlycon_id {
	char name[15];
	char name_term;
	char compatible[128];
	int (*setup)(struct earlycon_device *, const char *);
};

struct eb_fence {
	struct drm_syncobj *syncobj;
	struct dma_fence *dma_fence;
	u64 value;
	struct dma_fence_chain *chain_fence;
};

struct eb_vma {
	struct i915_vma *vma;
	unsigned int flags;
	struct drm_i915_gem_exec_object2 *exec;
	struct list_head bind_link;
	struct list_head reloc_link;
	struct hlist_node node;
	u32 handle;
};

struct ebt_entry {
	unsigned int bitmask;
	unsigned int invflags;
	__be16 ethproto;
	char in[16];
	char logical_in[16];
	char out[16];
	char logical_out[16];
	unsigned char sourcemac[6];
	unsigned char sourcemsk[6];
	unsigned char destmac[6];
	unsigned char destmsk[6];
	union {
		struct {
			unsigned int watchers_offset;
			unsigned int target_offset;
			unsigned int next_offset;
		};
		struct {
			unsigned int watchers_offset;
			unsigned int target_offset;
			unsigned int next_offset;
		} offsets;
	};
	unsigned char elems[0];
};

struct ecc_point {
	u64 *x;
	u64 *y;
	u8 ndigits;
};

struct ecc_curve {
	char *name;
	u32 nbits;
	struct ecc_point g;
	u64 *p;
	u64 *n;
	u64 *a;
	u64 *b;
};

struct ecdh {
	char *key;
	short unsigned int key_size;
};

struct ecdh_ctx {
	unsigned int curve_id;
	unsigned int ndigits;
	u64 private_key[9];
};

struct est_timings {
	u8 t1;
	u8 t2;
	u8 mfg_rsvd;
};

struct edid {
	u8 header[8];
	union {
		struct drm_edid_product_id product_id;
		struct {
			u8 mfg_id[2];
			u8 prod_code[2];
			u32 serial;
			u8 mfg_week;
			u8 mfg_year;
		} __attribute__((packed));
	};
	u8 version;
	u8 revision;
	u8 input;
	u8 width_cm;
	u8 height_cm;
	u8 gamma;
	u8 features;
	u8 red_green_lo;
	u8 blue_white_lo;
	u8 red_x;
	u8 red_y;
	u8 green_x;
	u8 green_y;
	u8 blue_x;
	u8 blue_y;
	u8 white_x;
	u8 white_y;
	struct est_timings established_timings;
	struct std_timing standard_timings[8];
	struct detailed_timing detailed_timings[4];
	u8 extensions;
	u8 checksum;
};

struct edid_quirk {
	const struct drm_edid_ident ident;
	u32 quirks;
};

struct eee_config {
	u32 tx_lpi_timer;
	bool tx_lpi_enabled;
	bool eee_enabled;
};

struct ethtool_keee {
	long unsigned int supported[2];
	long unsigned int advertised[2];
	long unsigned int lp_advertised[2];
	u32 tx_lpi_timer;
	bool tx_lpi_enabled;
	bool eee_active;
	bool eee_enabled;
};

struct eee_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_keee eee;
};

struct eeprom_93cx6 {
	void *data;
	void (*register_read)(struct eeprom_93cx6 *);
	void (*register_write)(struct eeprom_93cx6 *);
	int width;
	unsigned int quirks;
	char drive_data;
	char reg_data_in;
	char reg_data_out;
	char reg_data_clock;
	char reg_chip_select;
};

struct eeprom_reply_data {
	struct ethnl_reply_data base;
	u32 length;
	u8 *data;
};

struct ethnl_req_info {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u32 flags;
	u32 phy_index;
};

struct eeprom_req_info {
	struct ethnl_req_info base;
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
};

typedef efi_status_t efi_get_time_t(efi_time_t *, efi_time_cap_t *);

typedef efi_status_t efi_set_time_t(efi_time_t *);

typedef efi_status_t efi_get_wakeup_time_t(efi_bool_t *, efi_bool_t *, efi_time_t *);

typedef efi_status_t efi_set_wakeup_time_t(efi_bool_t, efi_time_t *);

typedef efi_status_t efi_get_variable_t(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);

typedef efi_status_t efi_get_next_variable_t(long unsigned int *, efi_char16_t *, efi_guid_t *);

typedef efi_status_t efi_set_variable_t(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);

typedef efi_status_t efi_query_variable_info_t(u32, u64 *, u64 *, u64 *);

typedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **, long unsigned int, long unsigned int);

typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **, long unsigned int, u64 *, int *);

typedef efi_status_t efi_get_next_high_mono_count_t(u32 *);

typedef void efi_reset_system_t(int, efi_status_t, long unsigned int, efi_char16_t *);

struct efi_memory_map {
	phys_addr_t phys_map;
	void *map;
	void *map_end;
	int nr_map;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

struct efi {
	const efi_runtime_services_t *runtime;
	unsigned int runtime_version;
	unsigned int runtime_supported_mask;
	long unsigned int acpi;
	long unsigned int acpi20;
	long unsigned int smbios;
	long unsigned int smbios3;
	long unsigned int esrt;
	long unsigned int tpm_log;
	long unsigned int tpm_final_log;
	long unsigned int mokvar_table;
	long unsigned int coco_secret;
	long unsigned int unaccepted;
	efi_get_time_t *get_time;
	efi_set_time_t *set_time;
	efi_get_wakeup_time_t *get_wakeup_time;
	efi_set_wakeup_time_t *set_wakeup_time;
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_info_t *query_variable_info;
	efi_query_variable_info_t *query_variable_info_nonblocking;
	efi_update_capsule_t *update_capsule;
	efi_query_capsule_caps_t *query_capsule_caps;
	efi_get_next_high_mono_count_t *get_next_high_mono_count;
	efi_reset_system_t *reset_system;
	struct efi_memory_map memmap;
	long unsigned int flags;
};

struct efi_generic_dev_path {
	u8 type;
	u8 sub_type;
	u16 length;
};

struct efi_mem_range {
	struct range range;
	u64 attribute;
};

struct efi_memory_map_data {
	phys_addr_t phys_map;
	long unsigned int size;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

struct efi_mokvar_sysfs_attr {
	struct bin_attribute bin_attr;
	struct list_head node;
};

struct efi_mokvar_table_entry {
	char name[256];
	u64 data_size;
	u8 data[0];
};

union efi_rts_args {
	struct {
		efi_time_t *time;
		efi_time_cap_t *capabilities;
	} GET_TIME;
	struct {
		efi_time_t *time;
	} SET_TIME;
	struct {
		efi_bool_t *enabled;
		efi_bool_t *pending;
		efi_time_t *time;
	} GET_WAKEUP_TIME;
	struct {
		efi_bool_t enable;
		efi_time_t *time;
	} SET_WAKEUP_TIME;
	struct {
		efi_char16_t *name;
		efi_guid_t *vendor;
		u32 *attr;
		long unsigned int *data_size;
		void *data;
	} GET_VARIABLE;
	struct {
		long unsigned int *name_size;
		efi_char16_t *name;
		efi_guid_t *vendor;
	} GET_NEXT_VARIABLE;
	struct {
		efi_char16_t *name;
		efi_guid_t *vendor;
		u32 attr;
		long unsigned int data_size;
		void *data;
	} SET_VARIABLE;
	struct {
		u32 attr;
		u64 *storage_space;
		u64 *remaining_space;
		u64 *max_variable_size;
	} QUERY_VARIABLE_INFO;
	struct {
		u32 *high_count;
	} GET_NEXT_HIGH_MONO_COUNT;
	struct {
		efi_capsule_header_t **capsules;
		long unsigned int count;
		long unsigned int sg_list;
	} UPDATE_CAPSULE;
	struct {
		efi_capsule_header_t **capsules;
		long unsigned int count;
		u64 *max_size;
		int *reset_type;
	} QUERY_CAPSULE_CAPS;
	struct {
		efi_status_t (*acpi_prm_handler)(u64, void *);
		u64 param_buffer_addr;
		void *context;
	} ACPI_PRM_HANDLER;
};

struct efi_runtime_map_entry {
	efi_memory_desc_t md;
	struct kobject kobj;
};

struct efi_runtime_work {
	union efi_rts_args *args;
	efi_status_t status;
	struct work_struct work;
	enum efi_rts_ids efi_rts_id;
	struct completion efi_rts_comp;
	const void *caller;
};

struct efi_setup_data {
	u64 fw_vendor;
	u64 __unused;
	u64 tables;
	u64 smbios;
	u64 reserved[8];
};

struct efi_system_resource_entry_v1 {
	efi_guid_t fw_class;
	u32 fw_type;
	u32 fw_version;
	u32 lowest_supported_fw_version;
	u32 capsule_flags;
	u32 last_attempt_version;
	u32 last_attempt_status;
};

struct efi_system_resource_table {
	u32 fw_resource_count;
	u32 fw_resource_count_max;
	u64 fw_resource_version;
	u8 entries[0];
};

struct efi_tcg2_final_events_table {
	u64 version;
	u64 nr_events;
	u8 events[0];
};

struct efi_unaccepted_memory {
	u32 version;
	u32 unit_size;
	u64 phys_base;
	u64 size;
	long unsigned int bitmap[0];
};

struct efi_variable {
	efi_char16_t VariableName[512];
	efi_guid_t VendorGuid;
};

struct efivar_entry {
	struct efi_variable var;
	struct inode vfs_inode;
	long unsigned int open_count;
	bool removed;
};

typedef efi_status_t efi_query_variable_store_t(u32, long unsigned int, bool);

struct efivar_operations {
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_store_t *query_variable_store;
	efi_query_variable_info_t *query_variable_info;
};

struct efivarfs_ctx {
	struct dir_context ctx;
	struct super_block *sb;
	struct dentry *dentry;
};

struct efivarfs_mount_opts {
	kuid_t uid;
	kgid_t gid;
};

struct efivarfs_fs_info {
	struct efivarfs_mount_opts mount_opts;
	struct super_block *sb;
	struct notifier_block nb;
	struct notifier_block pm_nb;
};

struct efivars {
	struct kset *kset;
	const struct efivar_operations *ops;
};

struct eg_ctrl_info {
	__u8 DLL_header[256];
	__u8 DH_length;
	__be32 cache_id;
	__be32 tag;
	__be32 mps_ip;
	__be32 eg_dst_ip;
	__u8 in_MPC_data_ATM_addr[20];
	__u16 holding_time;
};

struct eg_cache_entry {
	struct eg_cache_entry *next;
	struct eg_cache_entry *prev;
	time64_t time;
	uint8_t MPS_ctrl_ATM_addr[20];
	struct atm_vcc *shortcut;
	uint32_t packets_rcvd;
	uint16_t entry_state;
	__be32 latest_ip_addr;
	struct eg_ctrl_info ctrl_info;
	refcount_t use;
};

typedef struct eg_cache_entry eg_cache_entry;

struct k_message;

struct mpoa_client;

struct eg_cache_ops {
	eg_cache_entry * (*add_entry)(struct k_message *, struct mpoa_client *);
	eg_cache_entry * (*get_by_cache_id)(__be32, struct mpoa_client *);
	eg_cache_entry * (*get_by_tag)(__be32, struct mpoa_client *);
	eg_cache_entry * (*get_by_vcc)(struct atm_vcc *, struct mpoa_client *);
	eg_cache_entry * (*get_by_src_ip)(__be32, struct mpoa_client *);
	void (*put)(eg_cache_entry *);
	void (*remove_entry)(eg_cache_entry *, struct mpoa_client *);
	void (*update)(eg_cache_entry *, uint16_t);
	void (*clear_expired)(struct mpoa_client *);
	void (*destroy_cache)(struct mpoa_client *);
};

typedef struct eg_ctrl_info eg_ctrl_info;

struct ehci_caps {
	u32 hc_capbase;
	u32 hcs_params;
	u32 hcc_params;
	u8 portroute[8];
};

struct ehci_dbg_port {
	u32 control;
	u32 pids;
	u32 data03;
	u32 data47;
	u32 address;
};

struct ehci_dev {
	u32 bus;
	u32 slot;
	u32 func;
};

struct ehci_regs {
	u32 command;
	u32 status;
	u32 intr_enable;
	u32 frame_index;
	u32 segment;
	u32 frame_list;
	u32 async_next;
	u32 reserved1[2];
	u32 txfill_tuning;
	u32 reserved2[6];
	u32 configured_flag;
	union {
		u32 port_status[15];
		struct {
			u32 reserved3[9];
			u32 usbmode;
		};
	};
	union {
		struct {
			u32 reserved4;
			u32 hostpc[15];
		};
		u32 brcm_insnreg[4];
	};
	u32 reserved5[2];
	u32 usbmode_ex;
};

struct elapaarp {
	__be16 hw_type;
	__be16 pa_type;
	__u8 hw_len;
	__u8 pa_len;
	__be16 function;
	__u8 hw_src[6];
	__u8 pa_src_zero;
	__be16 pa_src_net;
	__u8 pa_src_node;
	__u8 hw_dst[6];
	__u8 pa_dst_zero;
	__be16 pa_dst_net;
	__u8 pa_dst_node;
} __attribute__((packed));

struct elevator_queue;

struct io_cq;

struct elevator_mq_ops {
	int (*init_sched)(struct request_queue *, struct elevator_type *);
	void (*exit_sched)(struct elevator_queue *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*depth_updated)(struct blk_mq_hw_ctx *);
	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
	bool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);
	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
	void (*limit_depth)(blk_opf_t, struct blk_mq_alloc_data *);
	void (*prepare_request)(struct request *);
	void (*finish_request)(struct request *);
	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, blk_insert_t);
	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
	bool (*has_work)(struct blk_mq_hw_ctx *);
	void (*completed_request)(struct request *, u64);
	void (*requeue_request)(struct request *);
	struct request * (*former_request)(struct request_queue *, struct request *);
	struct request * (*next_request)(struct request_queue *, struct request *);
	void (*init_icq)(struct io_cq *);
	void (*exit_icq)(struct io_cq *);
};

struct elevator_queue {
	struct elevator_type *type;
	void *elevator_data;
	struct kobject kobj;
	struct mutex sysfs_lock;
	long unsigned int flags;
	struct hlist_head hash[64];
};

struct elv_fs_entry;

struct elevator_type {
	struct kmem_cache *icq_cache;
	struct elevator_mq_ops ops;
	size_t icq_size;
	size_t icq_align;
	const struct elv_fs_entry *elevator_attrs;
	const char *elevator_name;
	const char *elevator_alias;
	struct module *elevator_owner;
	const struct blk_mq_debugfs_attr *queue_debugfs_attrs;
	const struct blk_mq_debugfs_attr *hctx_debugfs_attrs;
	char icq_cache_name[22];
	struct list_head list;
};

struct elf32_hdr {
	unsigned char e_ident[16];
	Elf32_Half e_type;
	Elf32_Half e_machine;
	Elf32_Word e_version;
	Elf32_Addr e_entry;
	Elf32_Off e_phoff;
	Elf32_Off e_shoff;
	Elf32_Word e_flags;
	Elf32_Half e_ehsize;
	Elf32_Half e_phentsize;
	Elf32_Half e_phnum;
	Elf32_Half e_shentsize;
	Elf32_Half e_shnum;
	Elf32_Half e_shstrndx;
};

typedef struct elf32_hdr Elf32_Ehdr;

struct elf32_note {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
};

typedef struct elf32_note Elf32_Nhdr;

struct elf32_phdr {
	Elf32_Word p_type;
	Elf32_Off p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	Elf32_Word p_filesz;
	Elf32_Word p_memsz;
	Elf32_Word p_flags;
	Elf32_Word p_align;
};

typedef struct elf32_phdr Elf32_Phdr;

struct elf64_hdr {
	unsigned char e_ident[16];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
};

typedef struct elf64_hdr Elf64_Ehdr;

struct elf64_note {
	Elf64_Word n_namesz;
	Elf64_Word n_descsz;
	Elf64_Word n_type;
};

typedef struct elf64_note Elf64_Nhdr;

struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
};

typedef struct elf64_phdr Elf64_Phdr;

struct elf64_rela {
	Elf64_Addr r_offset;
	Elf64_Xword r_info;
	Elf64_Sxword r_addend;
};

typedef struct elf64_rela Elf64_Rela;

struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
};

typedef struct elf64_shdr Elf64_Shdr;

struct elf64_sym {
	Elf64_Word st_name;
	unsigned char st_info;
	unsigned char st_other;
	Elf64_Half st_shndx;
	Elf64_Addr st_value;
	Elf64_Xword st_size;
};

typedef struct elf64_sym Elf64_Sym;

struct memelfnote {
	const char *name;
	int type;
	unsigned int datasz;
	void *data;
};

struct siginfo {
	union {
		struct {
			int si_signo;
			int si_errno;
			int si_code;
			union __sifields _sifields;
		};
		int _si_pad[32];
	};
};

typedef struct siginfo siginfo_t;

struct elf_thread_core_info;

struct elf_note_info {
	struct elf_thread_core_info *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	long unsigned int pr_flag;
	__kernel_uid_t pr_uid;
	__kernel_gid_t pr_gid;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct elf_siginfo {
	int si_signo;
	int si_code;
	int si_errno;
};

struct elf_prstatus_common {
	struct elf_siginfo pr_info;
	short int pr_cursig;
	long unsigned int pr_sigpend;
	long unsigned int pr_sighold;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	struct __kernel_old_timeval pr_utime;
	struct __kernel_old_timeval pr_stime;
	struct __kernel_old_timeval pr_cutime;
	struct __kernel_old_timeval pr_cstime;
};

struct elf_prstatus {
	struct elf_prstatus_common common;
	elf_gregset_t pr_reg;
	int pr_fpvalid;
};

struct elf_thread_core_info {
	struct elf_thread_core_info *next;
	struct task_struct *task;
	struct elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elv_fs_entry {
	struct attribute attr;
	ssize_t (*show)(struct elevator_queue *, char *);
	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};

struct xt_match;

struct em_ipt_match {
	const struct xt_match *match;
	u32 hook;
	u8 nfproto;
	long: 0;
	u8 match_data[0];
};

struct em_ipt_xt_match {
	char *match_name;
	int (*validate_match_data)(struct nlattr **, u8);
};

struct em_perf_table;

struct em_perf_domain {
	struct em_perf_table *em_table;
	int nr_perf_states;
	int min_perf_state;
	int max_perf_state;
	long unsigned int flags;
	long unsigned int cpus[0];
};

struct em_perf_state {
	long unsigned int performance;
	long unsigned int frequency;
	long unsigned int power;
	long unsigned int cost;
	long unsigned int flags;
};

struct em_perf_table {
	struct callback_head rcu;
	struct kref kref;
	struct em_perf_state state[0];
};

struct xdp_mem_info {
	u32 type;
	u32 id;
};

struct xdp_rxq_info {
	struct net_device *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	u32 frag_size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ena_com_rx_buf_info {
	u16 len;
	u16 req_id;
};

struct ena_stats_tx {
	u64 cnt;
	u64 bytes;
	u64 queue_stop;
	u64 prepare_ctx_err;
	u64 queue_wakeup;
	u64 dma_mapping_err;
	u64 linearize;
	u64 linearize_failed;
	u64 napi_comp;
	u64 tx_poll;
	u64 doorbells;
	u64 bad_req_id;
	u64 llq_buffer_copy;
	u64 missed_tx;
	u64 unmask_interrupt;
	u64 last_napi_jiffies;
};

struct ena_stats_rx {
	u64 cnt;
	u64 bytes;
	u64 rx_copybreak_pkt;
	u64 csum_good;
	u64 refil_partial;
	u64 csum_bad;
	u64 page_alloc_fail;
	u64 skb_alloc_fail;
	u64 dma_mapping_err;
	u64 bad_desc_num;
	u64 bad_req_id;
	u64 empty_rx_ring;
	u64 csum_unchecked;
	u64 xdp_aborted;
	u64 xdp_drop;
	u64 xdp_pass;
	u64 xdp_tx;
	u64 xdp_invalid;
	u64 xdp_redirect;
};

struct ena_tx_buffer;

struct ena_rx_buffer;

struct napi_struct;

struct ena_com_dev;

struct ena_adapter;

struct ena_com_io_cq;

struct ena_com_io_sq;

struct ena_ring {
	u16 *free_ids;
	union {
		struct ena_tx_buffer *tx_buffer_info;
		struct ena_rx_buffer *rx_buffer_info;
	};
	struct device *dev;
	struct pci_dev *pdev;
	struct napi_struct *napi;
	struct net_device *netdev;
	struct ena_com_dev *ena_dev;
	struct ena_adapter *adapter;
	struct ena_com_io_cq *ena_com_io_cq;
	struct ena_com_io_sq *ena_com_io_sq;
	struct bpf_prog *xdp_bpf_prog;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	spinlock_t xdp_tx_lock;
	struct ena_ring *xdp_ring;
	u16 next_to_use;
	u16 next_to_clean;
	u16 rx_copybreak;
	u16 rx_headroom;
	u16 qid;
	u16 mtu;
	u16 sgl_size;
	u8 tx_max_header_size;
	bool disable_meta_caching;
	u16 no_interrupt_event_cnt;
	int cpu;
	int numa_node;
	int ring_size;
	enum ena_admin_placement_policy_type tx_mem_queue_type;
	struct ena_com_rx_buf_info ena_bufs[19];
	u32 smoothed_interval;
	u32 per_napi_packets;
	u16 non_empty_napi_events;
	struct u64_stats_sync syncp;
	union {
		struct ena_stats_tx tx_stats;
		struct ena_stats_rx rx_stats;
	};
	u8 *push_buf_intermediate_buf;
	int empty_rx_queue;
	long: 64;
};

struct gro_list {
	struct list_head list;
	int count;
};

struct napi_config;

struct napi_struct {
	struct list_head poll_list;
	long unsigned int state;
	int weight;
	u32 defer_hard_irqs_count;
	long unsigned int gro_bitmask;
	int (*poll)(struct napi_struct *, int);
	int poll_owner;
	int list_owner;
	struct net_device *dev;
	struct gro_list gro_hash[8];
	struct sk_buff *skb;
	struct list_head rx_list;
	int rx_count;
	unsigned int napi_id;
	struct hrtimer timer;
	struct task_struct *thread;
	long unsigned int gro_flush_timeout;
	long unsigned int irq_suspend_timeout;
	u32 defer_hard_irqs;
	struct list_head dev_list;
	struct hlist_node napi_hash_node;
	int irq;
	int index;
	struct napi_config *config;
};

struct ena_napi {
	u8 first_interrupt;
	u8 interrupts_masked;
	struct napi_struct napi;
	struct ena_ring *tx_ring;
	struct ena_ring *rx_ring;
	u32 qid;
	struct dim dim;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef irqreturn_t (*irq_handler_t)(int, void *);

struct ena_irq {
	irq_handler_t handler;
	void *data;
	int cpu;
	u32 vector;
	cpumask_t affinity_hint_mask;
	char name[40];
};

struct ena_stats_dev {
	u64 tx_timeout;
	u64 suspend;
	u64 resume;
	u64 wd_expired;
	u64 interface_up;
	u64 interface_down;
	u64 admin_q_pause;
	u64 rx_drops;
	u64 tx_drops;
	u64 reset_fail;
};

struct ena_admin_eni_stats {
	u64 bw_in_allowance_exceeded;
	u64 bw_out_allowance_exceeded;
	u64 pps_allowance_exceeded;
	u64 conntrack_allowance_exceeded;
	u64 linklocal_allowance_exceeded;
};

struct ena_admin_ena_srd_stats {
	u64 ena_srd_tx_pkts;
	u64 ena_srd_eligible_tx_pkts;
	u64 ena_srd_rx_pkts;
	u64 ena_srd_resource_utilization;
};

struct ena_admin_ena_srd_info {
	u64 flags;
	struct ena_admin_ena_srd_stats ena_srd_stats;
};

struct ena_adapter {
	struct ena_com_dev *ena_dev;
	struct net_device *netdev;
	struct pci_dev *pdev;
	u32 rx_copybreak;
	u32 max_mtu;
	u32 num_io_queues;
	u32 max_num_io_queues;
	int msix_vecs;
	u32 missing_tx_completion_threshold;
	u32 requested_tx_ring_size;
	u32 requested_rx_ring_size;
	u32 max_tx_ring_size;
	u32 max_rx_ring_size;
	u32 msg_enable;
	bool large_llq_header_enabled;
	bool large_llq_header_supported;
	u16 max_tx_sgl_size;
	u16 max_rx_sgl_size;
	u8 mac_addr[6];
	long unsigned int keep_alive_timeout;
	long unsigned int missing_tx_completion_to;
	char name[20];
	long unsigned int flags;
	struct ena_ring tx_ring[128];
	struct ena_ring rx_ring[128];
	struct ena_napi ena_napi[128];
	struct ena_irq irq_tbl[129];
	struct work_struct reset_task;
	struct timer_list timer_service;
	bool wd_state;
	bool dev_up_before_reset;
	bool disable_meta_caching;
	long unsigned int last_keep_alive_jiffies;
	struct u64_stats_sync syncp;
	struct ena_stats_dev dev_stats;
	struct ena_admin_eni_stats eni_stats;
	struct ena_admin_ena_srd_info ena_srd_info;
	u32 last_monitored_tx_qid;
	enum ena_regs_reset_reason_types reset_reason;
	struct bpf_prog *xdp_bpf_prog;
	u32 xdp_first_ring;
	u32 xdp_num_queues;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ena_admin_accel_mode_get {
	u16 supported_flags;
	u16 max_tx_burst_size;
};

struct ena_admin_accel_mode_set {
	u16 enabled_flags;
	u16 reserved;
};

struct ena_admin_accel_mode_req {
	union {
		u32 raw[2];
		struct ena_admin_accel_mode_get get;
		struct ena_admin_accel_mode_set set;
	} u;
};

struct ena_admin_acq_common_desc {
	u16 command;
	u8 status;
	u8 flags;
	u16 extended_status;
	u16 sq_head_indx;
};

struct ena_admin_acq_create_cq_resp_desc {
	struct ena_admin_acq_common_desc acq_common_desc;
	u16 cq_idx;
	u16 cq_actual_depth;
	u32 numa_node_register_offset;
	u32 cq_head_db_register_offset;
	u32 cq_interrupt_unmask_register_offset;
};

struct ena_admin_acq_create_sq_resp_desc {
	struct ena_admin_acq_common_desc acq_common_desc;
	u16 sq_idx;
	u16 reserved;
	u32 sq_doorbell_offset;
	u32 llq_descriptors_offset;
	u32 llq_headers_offset;
};

struct ena_admin_acq_destroy_cq_resp_desc {
	struct ena_admin_acq_common_desc acq_common_desc;
};

struct ena_admin_acq_destroy_sq_resp_desc {
	struct ena_admin_acq_common_desc acq_common_desc;
};

struct ena_admin_acq_entry {
	struct ena_admin_acq_common_desc acq_common_descriptor;
	u32 response_specific_data[14];
};

struct ena_admin_basic_stats {
	u32 tx_bytes_low;
	u32 tx_bytes_high;
	u32 tx_pkts_low;
	u32 tx_pkts_high;
	u32 rx_bytes_low;
	u32 rx_bytes_high;
	u32 rx_pkts_low;
	u32 rx_pkts_high;
	u32 rx_drops_low;
	u32 rx_drops_high;
	u32 tx_drops_low;
	u32 tx_drops_high;
};

struct ena_admin_customer_metrics {
	u64 reported_metrics;
};

struct ena_admin_acq_get_stats_resp {
	struct ena_admin_acq_common_desc acq_common_desc;
	union {
		u64 raw[7];
		struct ena_admin_basic_stats basic_stats;
		struct ena_admin_eni_stats eni_stats;
		struct ena_admin_ena_srd_info ena_srd_info;
		struct ena_admin_customer_metrics customer_metrics;
	} u;
};

struct ena_admin_aenq_common_desc {
	u16 group;
	u16 syndrome;
	u8 flags;
	u8 reserved1[3];
	u32 timestamp_low;
	u32 timestamp_high;
};

struct ena_admin_aenq_entry {
	struct ena_admin_aenq_common_desc aenq_common_desc;
	u32 inline_data_w4[12];
};

struct ena_admin_aenq_keep_alive_desc {
	struct ena_admin_aenq_common_desc aenq_common_desc;
	u32 rx_drops_low;
	u32 rx_drops_high;
	u32 tx_drops_low;
	u32 tx_drops_high;
};

struct ena_admin_aenq_link_change_desc {
	struct ena_admin_aenq_common_desc aenq_common_desc;
	u32 flags;
};

struct ena_admin_aq_common_desc {
	u16 command_id;
	u8 opcode;
	u8 flags;
};

struct ena_common_mem_addr {
	u32 mem_addr_low;
	u16 mem_addr_high;
	u16 reserved16;
};

struct ena_admin_aq_create_cq_cmd {
	struct ena_admin_aq_common_desc aq_common_descriptor;
	u8 cq_caps_1;
	u8 cq_caps_2;
	u16 cq_depth;
	u32 msix_vector;
	struct ena_common_mem_addr cq_ba;
};

struct ena_admin_aq_create_sq_cmd {
	struct ena_admin_aq_common_desc aq_common_descriptor;
	u8 sq_identity;
	u8 reserved8_w1;
	u8 sq_caps_2;
	u8 sq_caps_3;
	u16 cq_idx;
	u16 sq_depth;
	struct ena_common_mem_addr sq_ba;
	struct ena_common_mem_addr sq_head_writeback;
	u32 reserved0_w7;
	u32 reserved0_w8;
};

struct ena_admin_aq_destroy_cq_cmd {
	struct ena_admin_aq_common_desc aq_common_descriptor;
	u16 cq_idx;
	u16 reserved1;
};

struct ena_admin_sq {
	u16 sq_idx;
	u8 sq_identity;
	u8 reserved1;
};

struct ena_admin_aq_destroy_sq_cmd {
	struct ena_admin_aq_common_desc aq_common_descriptor;
	struct ena_admin_sq sq;
};

struct ena_admin_ctrl_buff_info {
	u32 length;
	struct ena_common_mem_addr address;
};

struct ena_admin_aq_entry {
	struct ena_admin_aq_common_desc aq_common_descriptor;
	union {
		u32 inline_data_w1[3];
		struct ena_admin_ctrl_buff_info control_buffer;
	} u;
	u32 inline_data_w4[12];
};

struct ena_admin_aq_get_stats_cmd {
	struct ena_admin_aq_common_desc aq_common_descriptor;
	union {
		u32 inline_data_w1[3];
		struct ena_admin_ctrl_buff_info control_buffer;
	} u;
	u8 type;
	u8 scope;
	u16 reserved3;
	u16 queue_idx;
	u16 device_id;
	u64 requested_metrics;
};

struct ena_admin_device_attr_feature_desc {
	u32 impl_id;
	u32 device_version;
	u32 supported_features;
	u32 capabilities;
	u32 phys_addr_width;
	u32 virt_addr_width;
	u8 mac_addr[6];
	u8 reserved7[2];
	u32 max_mtu;
};

struct ena_admin_ena_hw_hints {
	u16 mmio_read_timeout;
	u16 driver_watchdog_timeout;
	u16 missing_tx_completion_timeout;
	u16 missed_tx_completion_count_threshold_to_reset;
	u16 admin_completion_tx_timeout;
	u16 netdev_wd_timeout;
	u16 max_tx_sgl_size;
	u16 max_rx_sgl_size;
	u16 reserved[8];
};

struct ena_admin_ena_mmio_req_read_less_resp {
	u16 req_id;
	u16 reg_off;
	u32 reg_val;
};

struct ena_admin_feature_aenq_desc {
	u32 supported_groups;
	u32 enabled_groups;
};

struct ena_admin_feature_intr_moder_desc {
	u16 intr_delay_resolution;
	u16 reserved;
};

struct ena_admin_feature_llq_desc {
	u32 max_llq_num;
	u32 max_llq_depth;
	u16 header_location_ctrl_supported;
	u16 header_location_ctrl_enabled;
	u16 entry_size_ctrl_supported;
	u16 entry_size_ctrl_enabled;
	u16 desc_num_before_header_supported;
	u16 desc_num_before_header_enabled;
	u16 descriptors_stride_ctrl_supported;
	u16 descriptors_stride_ctrl_enabled;
	u32 reserved1;
	struct ena_admin_accel_mode_req accel_mode;
};

struct ena_admin_feature_offload_desc {
	u32 tx;
	u32 rx_supported;
	u32 rx_enabled;
};

struct ena_admin_feature_rss_flow_hash_control {
	u32 key_parts;
	u32 reserved;
	u32 key[10];
};

struct ena_admin_feature_rss_flow_hash_function {
	u32 supported_func;
	u32 selected_func;
	u32 init_val;
};

struct ena_admin_feature_rss_flow_hash_input {
	u16 supported_input_sort;
	u16 enabled_input_sort;
};

struct ena_admin_proto_input {
	u16 fields;
	u16 reserved2;
};

struct ena_admin_feature_rss_hash_control {
	struct ena_admin_proto_input supported_fields[16];
	struct ena_admin_proto_input selected_fields[16];
	struct ena_admin_proto_input reserved2[16];
	struct ena_admin_proto_input reserved3[16];
};

struct ena_admin_rss_ind_table_entry {
	u16 cq_idx;
	u16 reserved;
};

struct ena_admin_feature_rss_ind_table {
	u16 min_size;
	u16 max_size;
	u16 size;
	u16 reserved;
	u32 inline_index;
	struct ena_admin_rss_ind_table_entry inline_entry;
};

struct ena_admin_get_set_feature_common_desc {
	u8 flags;
	u8 feature_id;
	u8 feature_version;
	u8 reserved8;
};

struct ena_admin_get_feat_cmd {
	struct ena_admin_aq_common_desc aq_common_descriptor;
	struct ena_admin_ctrl_buff_info control_buffer;
	struct ena_admin_get_set_feature_common_desc feat_common;
	u32 raw[11];
};

struct ena_admin_queue_feature_desc {
	u32 max_sq_num;
	u32 max_sq_depth;
	u32 max_cq_num;
	u32 max_cq_depth;
	u32 max_legacy_llq_num;
	u32 max_legacy_llq_depth;
	u32 max_header_size;
	u16 max_packet_tx_descs;
	u16 max_packet_rx_descs;
};

struct ena_admin_queue_ext_feature_fields {
	u32 max_tx_sq_num;
	u32 max_tx_cq_num;
	u32 max_rx_sq_num;
	u32 max_rx_cq_num;
	u32 max_tx_sq_depth;
	u32 max_tx_cq_depth;
	u32 max_rx_sq_depth;
	u32 max_rx_cq_depth;
	u32 max_tx_header_size;
	u16 max_per_packet_tx_descs;
	u16 max_per_packet_rx_descs;
};

struct ena_admin_queue_ext_feature_desc {
	u8 version;
	u8 reserved1[3];
	union {
		struct ena_admin_queue_ext_feature_fields max_queue_ext;
		u32 raw[10];
	};
};

struct ena_admin_get_feature_link_desc {
	u32 speed;
	u32 supported;
	u32 flags;
};

struct ena_admin_get_feat_resp {
	struct ena_admin_acq_common_desc acq_common_desc;
	union {
		u32 raw[14];
		struct ena_admin_device_attr_feature_desc dev_attr;
		struct ena_admin_feature_llq_desc llq;
		struct ena_admin_queue_feature_desc max_queue;
		struct ena_admin_queue_ext_feature_desc max_queue_ext;
		struct ena_admin_feature_aenq_desc aenq;
		struct ena_admin_get_feature_link_desc link;
		struct ena_admin_feature_offload_desc offload;
		struct ena_admin_feature_rss_flow_hash_function flow_hash_func;
		struct ena_admin_feature_rss_flow_hash_input flow_hash_input;
		struct ena_admin_feature_rss_ind_table ind_table;
		struct ena_admin_feature_intr_moder_desc intr_moderation;
		struct ena_admin_ena_hw_hints hw_hints;
	} u;
};

struct ena_admin_host_info {
	u32 os_type;
	u8 os_dist_str[128];
	u32 os_dist;
	u8 kernel_ver_str[32];
	u32 kernel_ver;
	u32 driver_version;
	u32 supported_network_features[2];
	u16 ena_spec_version;
	u16 bdf;
	u16 num_cpus;
	u16 reserved;
	u32 driver_supported_features;
};

struct ena_admin_set_feature_mtu_desc {
	u32 mtu;
};

struct ena_admin_set_feature_host_attr_desc {
	struct ena_common_mem_addr os_info_ba;
	struct ena_common_mem_addr debug_ba;
	u32 debug_area_size;
};

struct ena_admin_set_feat_cmd {
	struct ena_admin_aq_common_desc aq_common_descriptor;
	struct ena_admin_ctrl_buff_info control_buffer;
	struct ena_admin_get_set_feature_common_desc feat_common;
	union {
		u32 raw[11];
		struct ena_admin_set_feature_mtu_desc mtu;
		struct ena_admin_set_feature_host_attr_desc host_attr;
		struct ena_admin_feature_aenq_desc aenq;
		struct ena_admin_feature_rss_flow_hash_function flow_hash_func;
		struct ena_admin_feature_rss_flow_hash_input flow_hash_input;
		struct ena_admin_feature_rss_ind_table ind_table;
		struct ena_admin_feature_llq_desc llq;
	} u;
};

struct ena_admin_set_feat_resp {
	struct ena_admin_acq_common_desc acq_common_desc;
	union {
		u32 raw[14];
	} u;
};

typedef void (*ena_aenq_handler)(void *, struct ena_admin_aenq_entry *);

struct ena_aenq_handlers {
	ena_aenq_handler handlers[256];
	ena_aenq_handler unimplemented_handler;
};

struct ena_com_admin_cq {
	struct ena_admin_acq_entry *entries;
	dma_addr_t dma_addr;
	u16 head;
	u8 phase;
};

struct ena_com_admin_sq {
	struct ena_admin_aq_entry *entries;
	dma_addr_t dma_addr;
	u32 *db_addr;
	u16 head;
	u16 tail;
	u8 phase;
};

struct ena_com_stats_admin {
	u64 aborted_cmd;
	u64 submitted_cmd;
	u64 completed_cmd;
	u64 out_of_space;
	u64 no_completion;
};

struct ena_comp_ctx;

struct ena_com_admin_queue {
	void *q_dmadev;
	struct ena_com_dev *ena_dev;
	spinlock_t q_lock;
	struct ena_comp_ctx *comp_ctx;
	u32 completion_timeout;
	u16 q_depth;
	struct ena_com_admin_cq cq;
	struct ena_com_admin_sq sq;
	bool polling;
	u16 curr_cmd_id;
	bool running_state;
	atomic_t outstanding_cmds;
	struct ena_com_stats_admin stats;
};

struct ena_com_aenq {
	u16 head;
	u8 phase;
	struct ena_admin_aenq_entry *entries;
	dma_addr_t dma_addr;
	u16 q_depth;
	struct ena_aenq_handlers *aenq_handlers;
};

struct ena_com_buf {
	dma_addr_t paddr;
	u16 len;
};

struct ena_com_create_io_ctx {
	enum ena_admin_placement_policy_type mem_queue_type;
	enum queue_direction direction;
	int numa_node;
	u32 msix_vector;
	u16 queue_size;
	u16 qid;
};

struct ena_com_io_desc_addr {
	u8 *pbuf_dev_addr;
	u8 *virt_addr;
	dma_addr_t phys_addr;
};

struct ena_com_io_cq {
	struct ena_com_io_desc_addr cdesc_addr;
	u32 *unmask_reg;
	u32 *numa_node_cfg_reg;
	long: 64;
	long: 64;
	long: 64;
	u32 msix_vector;
	enum queue_direction direction;
	u16 cur_rx_pkt_cdesc_count;
	u16 cur_rx_pkt_cdesc_start_idx;
	u16 q_depth;
	u16 qid;
	u16 idx;
	u16 head;
	u8 phase;
	u8 cdesc_entry_size_in_bytes;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ena_com_tx_meta {
	u16 mss;
	u16 l3_hdr_len;
	u16 l3_hdr_offset;
	u16 l4_hdr_len;
};

struct ena_com_llq_info {
	u16 header_location_ctrl;
	u16 desc_stride_ctrl;
	u16 desc_list_entry_size_ctrl;
	u16 desc_list_entry_size;
	u16 descs_num_before_header;
	u16 descs_per_entry;
	u16 max_entries_in_tx_burst;
	bool disable_meta_caching;
};

struct ena_com_llq_pkt_ctrl {
	u8 *curr_bounce_buf;
	u16 idx;
	u16 descs_left_in_line;
};

struct ena_com_io_bounce_buffer_control {
	u8 *base_buffer;
	u16 next_to_use;
	u16 buffer_size;
	u16 buffers_num;
};

struct ena_com_io_sq {
	struct ena_com_io_desc_addr desc_addr;
	u32 *db_addr;
	enum queue_direction direction;
	enum ena_admin_placement_policy_type mem_queue_type;
	bool disable_meta_caching;
	u32 msix_vector;
	struct ena_com_tx_meta cached_tx_meta;
	struct ena_com_llq_info llq_info;
	struct ena_com_llq_pkt_ctrl llq_buf_ctrl;
	struct ena_com_io_bounce_buffer_control bounce_buf_ctrl;
	u16 q_depth;
	u16 qid;
	u16 idx;
	u16 tail;
	u16 next_to_comp;
	u16 llq_last_copy_tail;
	u32 tx_max_header_size;
	u8 phase;
	u8 desc_entry_size;
	u8 dma_addr_bits;
	u16 entries_in_tx_burst_left;
};

struct ena_com_mmio_read {
	struct ena_admin_ena_mmio_req_read_less_resp *read_resp;
	dma_addr_t read_resp_dma_addr;
	u32 reg_read_to;
	u16 seq_num;
	bool readless_supported;
	spinlock_t lock;
};

struct ena_rss {
	u16 *host_rss_ind_tbl;
	struct ena_admin_rss_ind_table_entry *rss_ind_tbl;
	dma_addr_t rss_ind_tbl_dma_addr;
	u16 tbl_log_size;
	enum ena_admin_hash_functions hash_func;
	struct ena_admin_feature_rss_flow_hash_control *hash_key;
	dma_addr_t hash_key_dma_addr;
	u32 hash_init_val;
	struct ena_admin_feature_rss_hash_control *hash_ctrl;
	dma_addr_t hash_ctrl_dma_addr;
};

struct ena_host_attribute {
	u8 *debug_area_virt_addr;
	dma_addr_t debug_area_dma_addr;
	u32 debug_area_size;
	struct ena_admin_host_info *host_info;
	dma_addr_t host_info_dma_addr;
};

struct ena_intr_moder_entry;

struct ena_customer_metrics {
	u64 supported_metrics;
	dma_addr_t buffer_dma_addr;
	void *buffer_virt_addr;
	u32 buffer_len;
};

struct ena_com_dev {
	struct ena_com_admin_queue admin_queue;
	struct ena_com_aenq aenq;
	struct ena_com_io_cq io_cq_queues[256];
	struct ena_com_io_sq io_sq_queues[256];
	u8 *reg_bar;
	void *mem_bar;
	void *dmadev;
	struct net_device *net_device;
	enum ena_admin_placement_policy_type tx_mem_queue_type;
	u32 tx_max_header_size;
	u16 stats_func;
	u16 stats_queue;
	u32 ena_min_poll_delay_us;
	struct ena_com_mmio_read mmio_read;
	struct ena_rss rss;
	u32 supported_features;
	u32 capabilities;
	u32 dma_addr_bits;
	struct ena_host_attribute host_attr;
	bool adaptive_coalescing;
	u16 intr_delay_resolution;
	u32 intr_moder_tx_interval;
	u32 intr_moder_rx_interval;
	struct ena_intr_moder_entry *intr_moder_tbl;
	struct ena_com_llq_info llq_info;
	struct ena_customer_metrics customer_metrics;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ena_com_dev_get_features_ctx {
	struct ena_admin_queue_feature_desc max_queues;
	struct ena_admin_queue_ext_feature_desc max_queue_ext;
	struct ena_admin_device_attr_feature_desc dev_attr;
	struct ena_admin_feature_aenq_desc aenq;
	struct ena_admin_feature_offload_desc offload;
	struct ena_admin_ena_hw_hints hw_hints;
	struct ena_admin_feature_llq_desc llq;
};

struct ena_com_rx_ctx {
	struct ena_com_rx_buf_info *ena_bufs;
	enum ena_eth_io_l3_proto_index l3_proto;
	enum ena_eth_io_l4_proto_index l4_proto;
	bool l3_csum_err;
	bool l4_csum_err;
	u8 l4_csum_checked;
	bool frag;
	u32 hash;
	u16 descs;
	u16 max_bufs;
	u8 pkt_offset;
};

struct ena_com_stats_ctx {
	struct ena_admin_aq_get_stats_cmd get_cmd;
	struct ena_admin_acq_get_stats_resp get_resp;
};

struct ena_com_tx_ctx {
	struct ena_com_tx_meta ena_meta;
	struct ena_com_buf *ena_bufs;
	void *push_header;
	enum ena_eth_io_l3_proto_index l3_proto;
	enum ena_eth_io_l4_proto_index l4_proto;
	u16 num_bufs;
	u16 req_id;
	u16 header_len;
	u8 meta_valid;
	u8 tso_enable;
	u8 l3_csum_enable;
	u8 l4_csum_enable;
	u8 l4_csum_partial;
	u8 df;
};

struct ena_comp_ctx {
	struct completion wait_event;
	struct ena_admin_acq_entry *user_cqe;
	u32 comp_size;
	enum ena_cmd_status status;
	u8 comp_status;
	u8 cmd_opcode;
	bool occupied;
};

struct ena_eth_io_intr_reg {
	u32 intr_control;
};

struct ena_eth_io_numa_node_cfg_reg {
	u32 numa_cfg;
};

struct ena_eth_io_rx_cdesc_base {
	u32 status;
	u16 length;
	u16 req_id;
	u32 hash;
	u16 sub_qid;
	u8 offset;
	u8 reserved;
};

struct ena_eth_io_rx_desc {
	u16 length;
	u8 reserved2;
	u8 ctrl;
	u16 req_id;
	u16 reserved6;
	u32 buff_addr_lo;
	u16 buff_addr_hi;
	u16 reserved16_w3;
};

struct ena_eth_io_tx_cdesc {
	u16 req_id;
	u8 status;
	u8 flags;
	u16 sub_qid;
	u16 sq_head_idx;
};

struct ena_eth_io_tx_desc {
	u32 len_ctrl;
	u32 meta_ctrl;
	u32 buff_addr_lo;
	u32 buff_addr_hi_hdr_sz;
};

struct ena_eth_io_tx_meta_desc {
	u32 len_ctrl;
	u32 word1;
	u32 word2;
	u32 reserved;
};

struct ena_hw_metrics {
	char name[32];
};

struct ena_llq_configurations {
	enum ena_admin_llq_header_location llq_header_location;
	enum ena_admin_llq_ring_entry_size llq_ring_entry_size;
	enum ena_admin_llq_stride_ctrl llq_stride_ctrl;
	enum ena_admin_llq_num_descs_before_header llq_num_decs_before_header;
	u16 llq_ring_entry_size_value;
};

struct ena_rx_buffer {
	struct sk_buff *skb;
	struct page *page;
	dma_addr_t dma_addr;
	u32 page_offset;
	u32 buf_offset;
	struct ena_com_buf ena_buf;
	long: 64;
	long: 64;
};

struct ena_stats {
	char name[32];
	int stat_offset;
};

struct xdp_frame;

struct ena_tx_buffer {
	union {
		struct sk_buff *skb;
		struct xdp_frame *xdpf;
	};
	u32 tx_descs;
	u32 num_of_bufs;
	u32 total_tx_size;
	u8 map_linear_data;
	u8 print_once;
	long unsigned int last_jiffies;
	struct ena_com_buf bufs[19];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_event_file;

struct enable_trigger_data {
	struct trace_event_file *file;
	bool enable;
	bool hist;
};

union encrypted_buff {
	u8 e_kpub_km[128];
	u8 e_kh_km_m[32];
	struct {
		u8 e_kh_km[16];
		u8 m[16];
	};
};

struct xdr_buf;

struct encryptor_desc {
	u8 iv[16];
	struct skcipher_request *req;
	int pos;
	struct xdr_buf *outbuf;
	struct page **pages;
	struct scatterlist infrags[4];
	struct scatterlist outfrags[4];
	int fragno;
	int fraglen;
};

struct energy_env {
	long unsigned int task_busy_time;
	long unsigned int pd_busy_time;
	long unsigned int cpu_cap;
	long unsigned int pd_cap;
};

struct engine_mmio_base {
	u32 graphics_ver: 8;
	u32 base: 24;
};

struct engine_info {
	u8 class;
	u8 instance;
	struct engine_mmio_base mmio_bases[3];
};

struct entropy_timer_state {
	long unsigned int entropy;
	struct timer_list timer;
	atomic_t samples;
	unsigned int samples_per_bit;
};

typedef struct poll_table_struct poll_table;

struct epitem;

struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};

struct epoll_filefd {
	struct file *file;
	int fd;
} __attribute__((packed));

struct epoll_event {
	__poll_t events;
	__u64 data;
} __attribute__((packed));

struct eppoll_entry;

struct eventpoll;

struct epitem {
	union {
		struct rb_node rbn;
		struct callback_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;
	bool dying;
	struct eppoll_entry *pwqlist;
	struct eventpoll *ep;
	struct hlist_node fllink;
	struct wakeup_source *ws;
	struct epoll_event event;
};

struct epitems_head {
	struct hlist_head epitems;
	struct epitems_head *next;
};

struct epoll_params {
	__u32 busy_poll_usecs;
	__u16 busy_poll_budget;
	__u8 prefer_busy_poll;
	__u8 __pad;
};

struct eppoll_entry {
	struct eppoll_entry *next;
	struct epitem *base;
	wait_queue_entry_t wait;
	wait_queue_head_t *whead;
};

struct trace_eprobe;

struct eprobe_data {
	struct trace_event_file *file;
	struct trace_eprobe *ep;
};

struct eprobe_trace_entry_head {
	struct trace_entry ent;
};

struct equiv_cpu_entry {
	u32 installed_cpu;
	u32 fixed_errata_mask;
	u32 fixed_errata_compare;
	u16 equiv_cpu;
	u16 res;
};

struct equiv_cpu_table {
	unsigned int num_entries;
	struct equiv_cpu_entry *entry;
};

struct er_account {
	raw_spinlock_t lock;
	u64 config;
	u64 reg;
	atomic_t ref;
};

struct err_info {
	const char **errs;
	u8 type;
	u16 pos;
	u64 ts;
};

struct error_info {
	short unsigned int code12;
	short unsigned int size;
};

struct error_info2 {
	unsigned char code1;
	unsigned char code2_min;
	unsigned char code2_max;
	const char *str;
	const char *fmt;
};

struct errormap {
	char *name;
	int val;
	int namelen;
	struct hlist_node list;
};

struct erspan_base_hdr {
	__u8 vlan_upper: 4;
	__u8 ver: 4;
	__u8 vlan: 8;
	__u8 session_id_upper: 2;
	__u8 t: 1;
	__u8 en: 2;
	__u8 cos: 3;
	__u8 session_id: 8;
};

struct erspan_md2 {
	__be32 timestamp;
	__be16 sgt;
	__u8 hwid_upper: 2;
	__u8 ft: 5;
	__u8 p: 1;
	__u8 o: 1;
	__u8 gra: 2;
	__u8 dir: 1;
	__u8 hwid: 4;
};

struct erspan_metadata {
	int version;
	union {
		__be32 index;
		struct erspan_md2 md2;
	} u;
};

struct ip_esp_hdr;

struct esp_info {
	struct ip_esp_hdr *esph;
	__be64 seqno;
	int tfclen;
	int tailen;
	int plen;
	int clen;
	int len;
	int nfrags;
	__u8 proto;
	bool inplace;
};

struct esp_output_extra {
	__be32 seqhi;
	u32 esphoff;
};

struct esp_skb_cb {
	struct xfrm_skb_cb xfrm;
	void *tmp;
};

struct esp_tcp_sk {
	struct sock *sk;
	struct callback_head rcu;
};

struct strp_stats {
	long long unsigned int msgs;
	long long unsigned int bytes;
	unsigned int mem_fail;
	unsigned int need_more_hdr;
	unsigned int msg_too_big;
	unsigned int msg_timeouts;
	unsigned int bad_hdr_len;
};

typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);

struct strparser;

struct strp_callbacks {
	int (*parse_msg)(struct strparser *, struct sk_buff *);
	void (*rcv_msg)(struct strparser *, struct sk_buff *);
	int (*read_sock)(struct strparser *, read_descriptor_t *, sk_read_actor_t);
	int (*read_sock_done)(struct strparser *, int);
	void (*abort_parser)(struct strparser *, int);
	void (*lock)(struct strparser *);
	void (*unlock)(struct strparser *);
};

struct strparser {
	struct sock *sk;
	u32 stopped: 1;
	u32 paused: 1;
	u32 aborted: 1;
	u32 interrupted: 1;
	u32 unrecov_intr: 1;
	struct sk_buff **skb_nextp;
	struct sk_buff *skb_head;
	unsigned int need_bytes;
	struct delayed_work msg_timer_work;
	struct work_struct work;
	struct strp_stats stats;
	struct strp_callbacks cb;
};

struct espintcp_msg {
	struct sk_buff *skb;
	struct sk_msg skmsg;
	int offset;
	int len;
};

struct espintcp_ctx {
	struct strparser strp;
	struct sk_buff_head ike_queue;
	struct sk_buff_head out_queue;
	struct espintcp_msg partial;
	void (*saved_data_ready)(struct sock *);
	void (*saved_write_space)(struct sock *);
	void (*saved_destruct)(struct sock *);
	struct work_struct work;
	bool tx_running;
};

struct esre_entry;

struct esre_attribute {
	struct attribute attr;
	ssize_t (*show)(struct esre_entry *, char *);
};

struct esre_entry {
	union {
		struct efi_system_resource_entry_v1 *esre1;
	} esre;
	struct kobject kobj;
	struct list_head list;
};

struct estack_pages {
	u32 offs;
	u16 size;
	u16 type;
};

struct etf_sched_data {
	bool offload;
	bool deadline_mode;
	bool skip_sock_check;
	int clockid;
	int queue;
	s32 delta;
	ktime_t last;
	struct rb_root_cached head;
	struct qdisc_watchdog watchdog;
	ktime_t (*get_time)(void);
};

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

struct ethnl_request_ops;

struct ethnl_dump_ctx {
	const struct ethnl_request_ops *ops;
	struct ethnl_req_info *req_info;
	struct ethnl_reply_data *reply_data;
	long unsigned int pos_ifindex;
};

struct ethnl_module_fw_flash_ntf_params {
	u32 portid;
	u32 seq;
	bool closed_sock;
};

struct phy_req_info;

struct ethnl_phy_dump_ctx {
	struct phy_req_info *phy_req_info;
	long unsigned int ifindex;
	long unsigned int phy_index;
};

struct genl_info;

struct ethnl_request_ops {
	u8 request_cmd;
	u8 reply_cmd;
	u16 hdr_attr;
	unsigned int req_info_size;
	unsigned int reply_data_size;
	bool allow_nodev_do;
	u8 set_ntf_cmd;
	int (*parse_request)(struct ethnl_req_info *, struct nlattr **, struct netlink_ext_ack *);
	int (*prepare_data)(const struct ethnl_req_info *, struct ethnl_reply_data *, const struct genl_info *);
	int (*reply_size)(const struct ethnl_req_info *, const struct ethnl_reply_data *);
	int (*fill_reply)(struct sk_buff *, const struct ethnl_req_info *, const struct ethnl_reply_data *);
	void (*cleanup_data)(struct ethnl_reply_data *);
	int (*set_validate)(struct ethnl_req_info *, struct genl_info *);
	int (*set)(struct ethnl_req_info *, struct genl_info *);
};

struct ethnl_sock_priv {
	struct net_device *dev;
	u32 portid;
	enum ethnl_sock_type type;
};

struct tsinfo_req_info;

struct tsinfo_reply_data;

struct ethnl_tsinfo_dump_ctx {
	struct tsinfo_req_info *req_info;
	struct tsinfo_reply_data *reply_data;
	long unsigned int pos_ifindex;
	bool netdev_dump_done;
	long unsigned int pos_phyindex;
	enum hwtstamp_provider_qualifier pos_phcqualifier;
};

struct ethnl_tunnel_info_dump_ctx {
	struct ethnl_req_info req_info;
	long unsigned int ifindex;
};

struct ethtool_ah_espip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 spi;
	__u8 tos;
};

struct ethtool_ah_espip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 spi;
	__u8 tclass;
};

struct ethtool_c33_pse_ext_state_info {
	enum ethtool_c33_pse_ext_state c33_pse_ext_state;
	union {
		enum ethtool_c33_pse_ext_substate_error_condition error_condition;
		enum ethtool_c33_pse_ext_substate_mr_pse_enable mr_pse_enable;
		enum ethtool_c33_pse_ext_substate_option_detect_ted option_detect_ted;
		enum ethtool_c33_pse_ext_substate_option_vport_lim option_vport_lim;
		enum ethtool_c33_pse_ext_substate_ovld_detected ovld_detected;
		enum ethtool_c33_pse_ext_substate_power_not_available power_not_available;
		enum ethtool_c33_pse_ext_substate_short_detected short_detected;
		u32 __c33_pse_ext_substate;
	};
};

struct ethtool_c33_pse_pw_limit_range {
	u32 min;
	u32 max;
};

struct ethtool_cmd {
	__u32 cmd;
	__u32 supported;
	__u32 advertising;
	__u16 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 transceiver;
	__u8 autoneg;
	__u8 mdio_support;
	__u32 maxtxpkt;
	__u32 maxrxpkt;
	__u16 speed_hi;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__u32 lp_advertising;
	__u32 reserved[2];
};

struct ethtool_cmis_cdb {
	u8 cmis_rev;
	u8 read_write_len_ext;
	u16 max_completion_time;
};

struct ethtool_cmis_cdb_request {
	__be16 id;
	union {
		struct {
			__be16 epl_len;
			u8 lpl_len;
			u8 chk_code;
			u8 resv1;
			u8 resv2;
			u8 payload[120];
		};
		struct {
			__be16 epl_len;
			u8 lpl_len;
			u8 chk_code;
			u8 resv1;
			u8 resv2;
			u8 payload[120];
		} body;
	};
	u8 *epl;
};

struct ethtool_cmis_cdb_cmd_args {
	struct ethtool_cmis_cdb_request req;
	u16 max_duration;
	u8 read_write_len_ext;
	u8 msleep_pre_rpl;
	u8 rpl_exp_len;
	u8 flags;
	char *err_msg;
};

struct ethtool_cmis_cdb_rpl_hdr {
	u8 rpl_len;
	u8 rpl_chk_code;
};

struct ethtool_cmis_cdb_rpl {
	struct ethtool_cmis_cdb_rpl_hdr hdr;
	u8 payload[120];
};

struct ethtool_module_fw_flash_params {
	__be32 password;
	u8 password_valid: 1;
};

struct firmware;

struct ethtool_cmis_fw_update_params {
	struct net_device *dev;
	struct ethtool_module_fw_flash_params params;
	struct ethnl_module_fw_flash_ntf_params ntf_params;
	const struct firmware *fw;
};

struct ethtool_flash {
	__u32 cmd;
	__u32 region;
	char data[128];
};

struct ethtool_drvinfo {
	__u32 cmd;
	char driver[32];
	char version[32];
	char fw_version[32];
	char bus_info[32];
	char erom_version[32];
	char reserved2[12];
	__u32 n_priv_flags;
	__u32 n_stats;
	__u32 testinfo_len;
	__u32 eedump_len;
	__u32 regdump_len;
};

struct ethtool_devlink_compat {
	struct devlink *devlink;
	union {
		struct ethtool_flash efl;
		struct ethtool_drvinfo info;
	};
};

struct ethtool_dump {
	__u32 cmd;
	__u32 version;
	__u32 flag;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eee {
	__u32 cmd;
	__u32 supported;
	__u32 advertised;
	__u32 lp_advertised;
	__u32 eee_active;
	__u32 eee_enabled;
	__u32 tx_lpi_enabled;
	__u32 tx_lpi_timer;
	__u32 reserved[2];
};

struct ethtool_eeprom {
	__u32 cmd;
	__u32 magic;
	__u32 offset;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eth_ctrl_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 MACControlFramesTransmitted;
			u64 MACControlFramesReceived;
			u64 UnsupportedOpcodesReceived;
		};
		struct {
			u64 MACControlFramesTransmitted;
			u64 MACControlFramesReceived;
			u64 UnsupportedOpcodesReceived;
		} stats;
	};
};

struct ethtool_eth_mac_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 FramesTransmittedOK;
			u64 SingleCollisionFrames;
			u64 MultipleCollisionFrames;
			u64 FramesReceivedOK;
			u64 FrameCheckSequenceErrors;
			u64 AlignmentErrors;
			u64 OctetsTransmittedOK;
			u64 FramesWithDeferredXmissions;
			u64 LateCollisions;
			u64 FramesAbortedDueToXSColls;
			u64 FramesLostDueToIntMACXmitError;
			u64 CarrierSenseErrors;
			u64 OctetsReceivedOK;
			u64 FramesLostDueToIntMACRcvError;
			u64 MulticastFramesXmittedOK;
			u64 BroadcastFramesXmittedOK;
			u64 FramesWithExcessiveDeferral;
			u64 MulticastFramesReceivedOK;
			u64 BroadcastFramesReceivedOK;
			u64 InRangeLengthErrors;
			u64 OutOfRangeLengthField;
			u64 FrameTooLongErrors;
		};
		struct {
			u64 FramesTransmittedOK;
			u64 SingleCollisionFrames;
			u64 MultipleCollisionFrames;
			u64 FramesReceivedOK;
			u64 FrameCheckSequenceErrors;
			u64 AlignmentErrors;
			u64 OctetsTransmittedOK;
			u64 FramesWithDeferredXmissions;
			u64 LateCollisions;
			u64 FramesAbortedDueToXSColls;
			u64 FramesLostDueToIntMACXmitError;
			u64 CarrierSenseErrors;
			u64 OctetsReceivedOK;
			u64 FramesLostDueToIntMACRcvError;
			u64 MulticastFramesXmittedOK;
			u64 BroadcastFramesXmittedOK;
			u64 FramesWithExcessiveDeferral;
			u64 MulticastFramesReceivedOK;
			u64 BroadcastFramesReceivedOK;
			u64 InRangeLengthErrors;
			u64 OutOfRangeLengthField;
			u64 FrameTooLongErrors;
		} stats;
	};
};

struct ethtool_eth_phy_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 SymbolErrorDuringCarrier;
		};
		struct {
			u64 SymbolErrorDuringCarrier;
		} stats;
	};
};

struct ethtool_fec_stat {
	u64 total;
	u64 lanes[8];
};

struct ethtool_fec_stats {
	struct ethtool_fec_stat corrected_blocks;
	struct ethtool_fec_stat uncorrectable_blocks;
	struct ethtool_fec_stat corrected_bits;
};

struct ethtool_fecparam {
	__u32 cmd;
	__u32 active_fec;
	__u32 fec;
	__u32 reserved;
};

struct ethtool_flow_ext {
	__u8 padding[2];
	unsigned char h_dest[6];
	__be16 vlan_etype;
	__be16 vlan_tci;
	__be32 data[2];
};

struct ethtool_tcpip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be16 psrc;
	__be16 pdst;
	__u8 tos;
};

struct ethtool_usrip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 l4_4_bytes;
	__u8 tos;
	__u8 ip_ver;
	__u8 proto;
};

struct ethtool_tcpip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be16 psrc;
	__be16 pdst;
	__u8 tclass;
};

struct ethtool_usrip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 l4_4_bytes;
	__u8 tclass;
	__u8 l4_proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec tcp_ip4_spec;
	struct ethtool_tcpip4_spec udp_ip4_spec;
	struct ethtool_tcpip4_spec sctp_ip4_spec;
	struct ethtool_ah_espip4_spec ah_ip4_spec;
	struct ethtool_ah_espip4_spec esp_ip4_spec;
	struct ethtool_usrip4_spec usr_ip4_spec;
	struct ethtool_tcpip6_spec tcp_ip6_spec;
	struct ethtool_tcpip6_spec udp_ip6_spec;
	struct ethtool_tcpip6_spec sctp_ip6_spec;
	struct ethtool_ah_espip6_spec ah_ip6_spec;
	struct ethtool_ah_espip6_spec esp_ip6_spec;
	struct ethtool_usrip6_spec usr_ip6_spec;
	struct ethhdr ether_spec;
	__u8 hdata[52];
};

struct ethtool_forced_speed_map {
	u32 speed;
	long unsigned int caps[2];
	const u32 *cap_arr;
	u32 arr_size;
};

struct ethtool_get_features_block {
	__u32 available;
	__u32 requested;
	__u32 active;
	__u32 never_changed;
};

struct ethtool_gfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_get_features_block features[0];
};

struct ethtool_gstrings {
	__u32 cmd;
	__u32 string_set;
	__u32 len;
	__u8 data[0];
};

struct ethtool_link_ext_state_info {
	enum ethtool_link_ext_state link_ext_state;
	union {
		enum ethtool_link_ext_substate_autoneg autoneg;
		enum ethtool_link_ext_substate_link_training link_training;
		enum ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch;
		enum ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity;
		enum ethtool_link_ext_substate_cable_issue cable_issue;
		enum ethtool_link_ext_substate_module module;
		u32 __link_ext_substate;
	};
};

struct ethtool_link_ext_stats {
	u64 link_down_events;
};

struct ethtool_link_settings {
	__u32 cmd;
	__u32 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 autoneg;
	__u8 mdio_support;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__s8 link_mode_masks_nwords;
	__u8 transceiver;
	__u8 master_slave_cfg;
	__u8 master_slave_state;
	__u8 rate_matching;
	__u32 reserved[7];
};

struct ethtool_link_ksettings {
	struct ethtool_link_settings base;
	struct {
		long unsigned int supported[2];
		long unsigned int advertising[2];
		long unsigned int lp_advertising[2];
	} link_modes;
	u32 lanes;
};

struct ethtool_link_usettings {
	struct ethtool_link_settings base;
	struct {
		__u32 supported[4];
		__u32 advertising[4];
		__u32 lp_advertising[4];
	} link_modes;
};

struct ethtool_mm_cfg {
	u32 verify_time;
	bool verify_enabled;
	bool tx_enabled;
	bool pmac_enabled;
	u32 tx_min_frag_size;
};

struct ethtool_mm_state {
	u32 verify_time;
	u32 max_verify_time;
	enum ethtool_mm_verify_status verify_status;
	bool tx_enabled;
	bool tx_active;
	bool pmac_enabled;
	bool verify_enabled;
	u32 tx_min_frag_size;
	u32 rx_min_frag_size;
};

struct ethtool_mm_stats {
	u64 MACMergeFrameAssErrorCount;
	u64 MACMergeFrameSmdErrorCount;
	u64 MACMergeFrameAssOkCount;
	u64 MACMergeFragCountRx;
	u64 MACMergeFragCountTx;
	u64 MACMergeHoldCount;
};

struct ethtool_modinfo {
	__u32 cmd;
	__u32 type;
	__u32 eeprom_len;
	__u32 reserved[8];
};

struct ethtool_module_eeprom {
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
	u8 *data;
};

struct ethtool_module_fw_flash {
	struct list_head list;
	netdevice_tracker dev_tracker;
	struct work_struct work;
	struct ethtool_cmis_fw_update_params fw_update;
};

struct ethtool_module_power_mode_params {
	enum ethtool_module_power_mode_policy policy;
	enum ethtool_module_power_mode mode;
};

struct ethtool_netdev_state {
	struct xarray rss_ctx;
	struct mutex rss_lock;
	unsigned int wol_enabled: 1;
	unsigned int module_fw_flash_in_progress: 1;
};

struct ethtool_regs;

struct ethtool_wolinfo;

struct ethtool_ringparam;

struct kernel_ethtool_ringparam;

struct ethtool_pause_stats;

struct ethtool_pauseparam;

struct ethtool_test;

struct ethtool_stats;

struct ethtool_rxnfc;

struct ethtool_rxfh_param;

struct ethtool_rxfh_context;

struct kernel_ethtool_ts_info;

struct ethtool_ts_stats;

struct ethtool_tunable;

struct ethtool_rmon_stats;

struct ethtool_rmon_hist_range;

struct ethtool_ops {
	u32 cap_link_lanes_supported: 1;
	u32 cap_rss_ctx_supported: 1;
	u32 cap_rss_sym_xor_supported: 1;
	u32 rxfh_per_ctx_key: 1;
	u32 cap_rss_rxnfc_adds: 1;
	u32 rxfh_indir_space;
	u16 rxfh_key_space;
	u16 rxfh_priv_size;
	u32 rxfh_max_num_contexts;
	u32 supported_coalesce_params;
	u32 supported_ring_params;
	u32 supported_hwtstamp_qualifiers;
	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device *);
	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device *);
	void (*set_msglevel)(struct net_device *, u32);
	int (*nway_reset)(struct net_device *);
	u32 (*get_link)(struct net_device *);
	int (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);
	void (*get_link_ext_stats)(struct net_device *, struct ethtool_link_ext_stats *);
	int (*get_eeprom_len)(struct net_device *);
	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *, struct kernel_ethtool_ringparam *, struct netlink_ext_ack *);
	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *, struct kernel_ethtool_ringparam *, struct netlink_ext_ack *);
	void (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);
	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device *, u32, u8 *);
	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device *);
	void (*complete)(struct net_device *);
	u32 (*get_priv_flags)(struct net_device *);
	int (*set_priv_flags)(struct net_device *, u32);
	int (*get_sset_count)(struct net_device *, int);
	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device *, struct ethtool_flash *);
	int (*reset)(struct net_device *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device *);
	u32 (*get_rxfh_indir_size)(struct net_device *);
	int (*get_rxfh)(struct net_device *, struct ethtool_rxfh_param *);
	int (*set_rxfh)(struct net_device *, struct ethtool_rxfh_param *, struct netlink_ext_ack *);
	int (*create_rxfh_context)(struct net_device *, struct ethtool_rxfh_context *, const struct ethtool_rxfh_param *, struct netlink_ext_ack *);
	int (*modify_rxfh_context)(struct net_device *, struct ethtool_rxfh_context *, const struct ethtool_rxfh_param *, struct netlink_ext_ack *);
	int (*remove_rxfh_context)(struct net_device *, struct ethtool_rxfh_context *, u32, struct netlink_ext_ack *);
	void (*get_channels)(struct net_device *, struct ethtool_channels *);
	int (*set_channels)(struct net_device *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device *, struct kernel_ethtool_ts_info *);
	void (*get_ts_stats)(struct net_device *, struct ethtool_ts_stats *);
	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device *, struct ethtool_keee *);
	int (*set_eee)(struct net_device *, struct ethtool_keee *);
	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
	void (*get_fec_stats)(struct net_device *, struct ethtool_fec_stats *);
	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
	int (*set_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
	void (*get_eth_phy_stats)(struct net_device *, struct ethtool_eth_phy_stats *);
	void (*get_eth_mac_stats)(struct net_device *, struct ethtool_eth_mac_stats *);
	void (*get_eth_ctrl_stats)(struct net_device *, struct ethtool_eth_ctrl_stats *);
	void (*get_rmon_stats)(struct net_device *, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);
	int (*get_module_power_mode)(struct net_device *, struct ethtool_module_power_mode_params *, struct netlink_ext_ack *);
	int (*set_module_power_mode)(struct net_device *, const struct ethtool_module_power_mode_params *, struct netlink_ext_ack *);
	int (*get_mm)(struct net_device *, struct ethtool_mm_state *);
	int (*set_mm)(struct net_device *, struct ethtool_mm_cfg *, struct netlink_ext_ack *);
	void (*get_mm_stats)(struct net_device *, struct ethtool_mm_stats *);
};

struct ethtool_pause_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 tx_pause_frames;
			u64 rx_pause_frames;
		};
		struct {
			u64 tx_pause_frames;
			u64 rx_pause_frames;
		} stats;
	};
};

struct ethtool_pauseparam {
	__u32 cmd;
	__u32 autoneg;
	__u32 rx_pause;
	__u32 tx_pause;
};

struct ethtool_per_queue_op {
	__u32 cmd;
	__u32 sub_command;
	__u32 queue_mask[128];
	char data[0];
};

struct ethtool_perm_addr {
	__u32 cmd;
	__u32 size;
	__u8 data[0];
};

struct phy_device;

struct phy_plca_cfg;

struct phy_plca_status;

struct phy_tdr_config;

struct ethtool_phy_ops {
	int (*get_sset_count)(struct phy_device *);
	int (*get_strings)(struct phy_device *, u8 *);
	int (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_plca_cfg)(struct phy_device *, struct phy_plca_cfg *);
	int (*set_plca_cfg)(struct phy_device *, const struct phy_plca_cfg *, struct netlink_ext_ack *);
	int (*get_plca_status)(struct phy_device *, struct phy_plca_status *);
	int (*start_cable_test)(struct phy_device *, struct netlink_ext_ack *);
	int (*start_cable_test_tdr)(struct phy_device *, struct netlink_ext_ack *, const struct phy_tdr_config *);
};

struct ethtool_phy_stats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 rx_errors;
	u64 tx_packets;
	u64 tx_bytes;
	u64 tx_errors;
};

struct ethtool_pse_control_status {
	enum ethtool_podl_pse_admin_state podl_admin_state;
	enum ethtool_podl_pse_pw_d_status podl_pw_status;
	enum ethtool_c33_pse_admin_state c33_admin_state;
	enum ethtool_c33_pse_pw_d_status c33_pw_status;
	u32 c33_pw_class;
	u32 c33_actual_pw;
	struct ethtool_c33_pse_ext_state_info c33_ext_state_info;
	u32 c33_avail_pw_limit;
	struct ethtool_c33_pse_pw_limit_range *c33_pw_limit_ranges;
	u32 c33_pw_limit_nb_ranges;
};

struct ethtool_regs {
	__u32 cmd;
	__u32 version;
	__u32 len;
	__u8 data[0];
};

struct ethtool_ringparam {
	__u32 cmd;
	__u32 rx_max_pending;
	__u32 rx_mini_max_pending;
	__u32 rx_jumbo_max_pending;
	__u32 tx_max_pending;
	__u32 rx_pending;
	__u32 rx_mini_pending;
	__u32 rx_jumbo_pending;
	__u32 tx_pending;
};

struct ethtool_rmon_hist_range {
	u16 low;
	u16 high;
};

struct ethtool_rmon_stats {
	enum ethtool_mac_stats_src src;
	union {
		struct {
			u64 undersize_pkts;
			u64 oversize_pkts;
			u64 fragments;
			u64 jabbers;
			u64 hist[10];
			u64 hist_tx[10];
		};
		struct {
			u64 undersize_pkts;
			u64 oversize_pkts;
			u64 fragments;
			u64 jabbers;
			u64 hist[10];
			u64 hist_tx[10];
		} stats;
	};
};

struct ethtool_rx_flow_key {
	struct flow_dissector_key_basic basic;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
};

struct flow_dissector {
	long long unsigned int used_keys;
	short unsigned int offset[33];
};

struct ethtool_rx_flow_match {
	struct flow_dissector dissector;
	struct ethtool_rx_flow_key key;
	struct ethtool_rx_flow_key mask;
};

struct flow_rule;

struct ethtool_rx_flow_rule {
	struct flow_rule *rule;
	long unsigned int priv[0];
};

struct ethtool_rx_flow_spec {
	__u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	__u64 ring_cookie;
	__u32 location;
};

struct ethtool_rx_flow_spec_input {
	const struct ethtool_rx_flow_spec *fs;
	u32 rss_ctx;
};

struct ethtool_rxfh {
	__u32 cmd;
	__u32 rss_context;
	__u32 indir_size;
	__u32 key_size;
	__u8 hfunc;
	__u8 input_xfrm;
	__u8 rsvd8[2];
	__u32 rsvd32;
	__u32 rss_config[0];
};

struct ethtool_rxfh_context {
	u32 indir_size;
	u32 key_size;
	u16 priv_size;
	u8 hfunc;
	u8 input_xfrm;
	u8 indir_configured: 1;
	u8 key_configured: 1;
	u32 key_off;
	long: 0;
	u8 data[0];
};

struct ethtool_rxfh_param {
	u8 hfunc;
	u32 indir_size;
	u32 *indir;
	u32 key_size;
	u8 *key;
	u32 rss_context;
	u8 rss_delete;
	u8 input_xfrm;
};

struct ethtool_rxnfc {
	__u32 cmd;
	__u32 flow_type;
	__u64 data;
	struct ethtool_rx_flow_spec fs;
	union {
		__u32 rule_cnt;
		__u32 rss_context;
	};
	__u32 rule_locs[0];
};

struct ethtool_set_features_block {
	__u32 valid;
	__u32 requested;
};

struct ethtool_sfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_set_features_block features[0];
};

struct ethtool_sset_info {
	__u32 cmd;
	__u32 reserved;
	__u64 sset_mask;
	__u32 data[0];
};

struct ethtool_stats {
	__u32 cmd;
	__u32 n_stats;
	__u64 data[0];
};

struct ethtool_test {
	__u32 cmd;
	__u32 flags;
	__u32 reserved;
	__u32 len;
	__u64 data[0];
};

struct ethtool_ts_info {
	__u32 cmd;
	__u32 so_timestamping;
	__s32 phc_index;
	__u32 tx_types;
	__u32 tx_reserved[3];
	__u32 rx_filters;
	__u32 rx_reserved[3];
};

struct ethtool_ts_stats {
	union {
		struct {
			u64 pkts;
			u64 onestep_pkts_unconfirmed;
			u64 lost;
			u64 err;
		};
		struct {
			u64 pkts;
			u64 onestep_pkts_unconfirmed;
			u64 lost;
			u64 err;
		} tx_stats;
	};
};

struct ethtool_tunable {
	__u32 cmd;
	__u32 id;
	__u32 type_id;
	__u32 len;
	void *data[0];
};

struct ethtool_value {
	__u32 cmd;
	__u32 data;
};

struct ethtool_wolinfo {
	__u32 cmd;
	__u32 supported;
	__u32 wolopts;
	__u8 sopass[6];
};

struct ets_class {
	struct list_head alist;
	struct Qdisc *qdisc;
	u32 quantum;
	u32 deficit;
	struct gnet_stats_basic_sync bstats;
	struct gnet_stats_queue qstats;
	long: 64;
};

struct ets_sched {
	struct list_head active;
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	unsigned int nbands;
	unsigned int nstrict;
	u8 prio2band[16];
	long: 64;
	struct ets_class classes[16];
};

struct input_handler;

struct input_value;

struct input_handle {
	void *private;
	int open;
	const char *name;
	struct input_dev *dev;
	struct input_handler *handler;
	unsigned int (*handle_events)(struct input_handle *, struct input_value *, unsigned int);
	struct list_head d_node;
	struct list_head h_node;
};

struct evdev_client;

struct evdev {
	int open;
	struct input_handle handle;
	struct evdev_client *grab;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
};

struct input_event {
	__kernel_ulong_t __sec;
	__kernel_ulong_t __usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct evdev_client {
	unsigned int head;
	unsigned int tail;
	unsigned int packet_head;
	spinlock_t buffer_lock;
	wait_queue_head_t wait;
	struct fasync_struct *fasync;
	struct evdev *evdev;
	struct list_head node;
	enum input_clock_type clk_type;
	bool revoked;
	long unsigned int *evmasks[32];
	unsigned int bufsize;
	struct input_event buffer[0];
};

struct event_trigger_data;

struct event_trigger_ops;

struct event_command {
	struct list_head list;
	char *name;
	enum event_trigger_type trigger_type;
	int flags;
	int (*parse)(struct event_command *, struct trace_event_file *, char *, char *, char *);
	int (*reg)(char *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg)(char *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg_all)(struct trace_event_file *);
	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
};

struct event_counter {
	u32 count;
	u32 flags;
};

struct event_file_link {
	struct trace_event_file *file;
	struct list_head list;
};

struct prog_entry;

struct event_filter {
	struct prog_entry *prog;
	char *filter_string;
};

struct perf_cpu_context;

struct perf_event_context;

typedef void (*event_f)(struct perf_event *, struct perf_cpu_context *, struct perf_event_context *, void *);

struct event_function_struct {
	struct perf_event *event;
	event_f func;
	void *data;
};

struct event_mod_load {
	struct list_head list;
	char *module;
	char *match;
	char *system;
	char *event;
};

struct event_subsystem {
	struct list_head list;
	const char *name;
	struct event_filter *filter;
	int ref_count;
};

struct event_trigger_data {
	long unsigned int count;
	int ref;
	int flags;
	struct event_trigger_ops *ops;
	struct event_command *cmd_ops;
	struct event_filter *filter;
	char *filter_str;
	void *private_data;
	bool paused;
	bool paused_tmp;
	struct list_head list;
	char *name;
	struct list_head named_list;
	struct event_trigger_data *named_data;
};

struct ring_buffer_event;

struct event_trigger_ops {
	void (*trigger)(struct event_trigger_data *, struct trace_buffer *, void *, struct ring_buffer_event *);
	int (*init)(struct event_trigger_data *);
	void (*free)(struct event_trigger_data *);
	int (*print)(struct seq_file *, struct event_trigger_data *);
};

struct eventfd_ctx {
	struct kref kref;
	wait_queue_head_t wqh;
	__u64 count;
	unsigned int flags;
	int id;
};

struct eventfs_attr {
	int mode;
	kuid_t uid;
	kgid_t gid;
};

typedef int (*eventfs_callback)(const char *, umode_t *, void **, const struct file_operations **);

typedef void (*eventfs_release)(const char *, void *);

struct eventfs_entry {
	const char *name;
	eventfs_callback callback;
	eventfs_release release;
};

struct eventfs_inode {
	union {
		struct list_head list;
		struct callback_head rcu;
	};
	struct list_head children;
	const struct eventfs_entry *entries;
	const char *name;
	struct eventfs_attr *entry_attrs;
	void *data;
	struct eventfs_attr attr;
	struct kref kref;
	unsigned int is_freed: 1;
	unsigned int is_events: 1;
	unsigned int nr_entries: 30;
	unsigned int ino;
};

struct eventfs_root_inode {
	struct eventfs_inode ei;
	struct dentry *events_dir;
};

struct eventpoll {
	struct mutex mtx;
	wait_queue_head_t wq;
	wait_queue_head_t poll_wait;
	struct list_head rdllist;
	rwlock_t lock;
	struct rb_root_cached rbr;
	struct epitem *ovflist;
	struct wakeup_source *ws;
	struct user_struct *user;
	struct file *file;
	u64 gen;
	struct hlist_head refs;
	refcount_t refcount;
	unsigned int napi_id;
	u32 busy_poll_usecs;
	u16 busy_poll_budget;
	bool prefer_busy_poll;
};

struct evict_params {
	gfp_t gfp;
	long unsigned int age_hz;
	long unsigned int last_accessed;
};

typedef enum evict_result (*b_predicate)(struct dm_buffer *, void *);

struct lock_history;

struct evict_wrapper {
	struct lock_history *lh;
	b_predicate pred;
	void *context;
};

struct evm_ima_xattr_data_hdr {
	u8 type;
};

struct evm_ima_xattr_data {
	union {
		struct {
			u8 type;
		};
		struct evm_ima_xattr_data_hdr hdr;
	};
	u8 data[0];
};

struct ewma__engine_latency {
	long unsigned int internal;
};

struct ewma_pkt_len {
	long unsigned int internal;
};

struct ewma_runtime {
	long unsigned int internal;
};

struct exar8250_board;

struct exar8250 {
	unsigned int nr;
	unsigned int osc_freq;
	struct exar8250_board *board;
	struct eeprom_93cx6 eeprom;
	void *virt;
	int line[0];
};

struct exar8250_board {
	unsigned int num_ports;
	unsigned int reg_shift;
	int (*setup)(struct exar8250 *, struct pci_dev *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct exar8250_platform {
	int (*rs485_config)(struct uart_port *, struct ktermios *, struct serial_rs485 *);
	const struct serial_rs485 *rs485_supported;
	int (*register_gpio)(struct pci_dev *, struct uart_8250_port *);
	void (*unregister_gpio)(struct uart_8250_port *);
};

struct exception_stacks {
	char DF_stack_guard[0];
	char DF_stack[8192];
	char NMI_stack_guard[0];
	char NMI_stack[8192];
	char DB_stack_guard[0];
	char DB_stack[8192];
	char MCE_stack_guard[0];
	char MCE_stack[8192];
	char VC_stack_guard[0];
	char VC_stack[0];
	char VC2_stack_guard[0];
	char VC2_stack[0];
	char IST_top_guard[0];
};

struct exception_table_entry {
	int insn;
	int fixup;
	int data;
};

struct exec_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct i915_request;

struct execlists_capture {
	struct work_struct work;
	struct i915_request *rq;
	struct i915_gpu_coredump *error;
};

struct execmem_range {
	long unsigned int start;
	long unsigned int end;
	long unsigned int fallback_start;
	long unsigned int fallback_end;
	pgprot_t pgprot;
	unsigned int alignment;
	enum execmem_range_flags flags;
};

struct execmem_info {
	struct execmem_range ranges[5];
};

struct execute_cb {
	struct irq_work work;
	struct i915_sw_fence *fence;
};

struct execute_work {
	struct work_struct work;
};

struct exit_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__u32 exit_code;
	__u32 exit_signal;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct fid;

struct iomap;

struct handle_to_path_ctx;

struct export_operations {
	int (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);
	struct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
	struct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
	int (*get_name)(struct dentry *, char *, struct dentry *);
	struct dentry * (*get_parent)(struct dentry *);
	int (*commit_metadata)(struct inode *);
	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
	int (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);
	int (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);
	int (*permission)(struct handle_to_path_ctx *, unsigned int);
	struct file * (*open)(struct path *, unsigned int);
	long unsigned int flags;
};

struct ext4_free_extent {
	ext4_lblk_t fe_logical;
	ext4_grpblk_t fe_start;
	ext4_group_t fe_group;
	ext4_grpblk_t fe_len;
};

struct ext4_prealloc_space;

struct ext4_locality_group;

struct ext4_allocation_context {
	struct inode *ac_inode;
	struct super_block *ac_sb;
	struct ext4_free_extent ac_o_ex;
	struct ext4_free_extent ac_g_ex;
	struct ext4_free_extent ac_b_ex;
	struct ext4_free_extent ac_f_ex;
	ext4_grpblk_t ac_orig_goal_len;
	__u32 ac_flags;
	__u32 ac_groups_linear_remaining;
	__u16 ac_groups_scanned;
	__u16 ac_found;
	__u16 ac_cX_found[5];
	__u16 ac_tail;
	__u16 ac_buddy;
	__u8 ac_status;
	__u8 ac_criteria;
	__u8 ac_2order;
	__u8 ac_op;
	struct folio *ac_bitmap_folio;
	struct folio *ac_buddy_folio;
	struct ext4_prealloc_space *ac_pa;
	struct ext4_locality_group *ac_lg;
};

struct ext4_allocation_request {
	struct inode *inode;
	unsigned int len;
	ext4_lblk_t logical;
	ext4_lblk_t lleft;
	ext4_lblk_t lright;
	ext4_fsblk_t goal;
	ext4_fsblk_t pleft;
	ext4_fsblk_t pright;
	unsigned int flags;
};

struct ext4_attr {
	struct attribute attr;
	short int attr_id;
	short int attr_ptr;
	short unsigned int attr_size;
	union {
		int offset;
		void *explicit_ptr;
	} u;
};

struct ext4_group_info;

struct ext4_buddy {
	struct folio *bd_buddy_folio;
	void *bd_buddy;
	struct folio *bd_bitmap_folio;
	void *bd_bitmap;
	struct ext4_group_info *bd_info;
	struct super_block *bd_sb;
	__u16 bd_blkbits;
	ext4_group_t bd_group;
};

struct ext4_dir_entry {
	__le32 inode;
	__le16 rec_len;
	__le16 name_len;
	char name[255];
};

struct ext4_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[255];
};

struct ext4_dir_entry_hash {
	__le32 hash;
	__le32 minor_hash;
};

struct ext4_dir_entry_tail {
	__le32 det_reserved_zero1;
	__le16 det_rec_len;
	__u8 det_reserved_zero2;
	__u8 det_reserved_ft;
	__le32 det_checksum;
};

struct ext4_err_translation {
	int code;
	int errno;
};

struct ext4_es_stats {
	long unsigned int es_stats_shrunk;
	struct percpu_counter es_stats_cache_hits;
	struct percpu_counter es_stats_cache_misses;
	u64 es_stats_scan_time;
	u64 es_stats_max_scan_time;
	struct percpu_counter es_stats_all_cnt;
	struct percpu_counter es_stats_shk_cnt;
};

struct extent_status;

struct ext4_es_tree {
	struct rb_root root;
	struct extent_status *cache_es;
};

struct ext4_extent;

struct ext4_extent_idx;

struct ext4_extent_header;

struct ext4_ext_path {
	ext4_fsblk_t p_block;
	__u16 p_depth;
	__u16 p_maxdepth;
	struct ext4_extent *p_ext;
	struct ext4_extent_idx *p_idx;
	struct ext4_extent_header *p_hdr;
	struct buffer_head *p_bh;
};

struct ext4_extent {
	__le32 ee_block;
	__le16 ee_len;
	__le16 ee_start_hi;
	__le32 ee_start_lo;
};

struct ext4_extent_header {
	__le16 eh_magic;
	__le16 eh_entries;
	__le16 eh_max;
	__le16 eh_depth;
	__le32 eh_generation;
};

struct ext4_extent_idx {
	__le32 ei_block;
	__le32 ei_leaf_lo;
	__le16 ei_leaf_hi;
	__u16 ei_unused;
};

struct ext4_extent_tail {
	__le32 et_checksum;
};

struct ext4_fc_add_range {
	__le32 fc_ino;
	__u8 fc_ex[12];
};

struct ext4_fc_alloc_region {
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	int ino;
	int len;
};

struct ext4_fc_del_range {
	__le32 fc_ino;
	__le32 fc_lblk;
	__le32 fc_len;
};

struct ext4_fc_dentry_info {
	__le32 fc_parent_ino;
	__le32 fc_ino;
	__u8 fc_dname[0];
};

struct name_snapshot {
	struct qstr name;
	union shortname_store inline_name;
};

struct ext4_fc_dentry_update {
	int fcd_op;
	int fcd_parent;
	int fcd_ino;
	struct name_snapshot fcd_name;
	struct list_head fcd_list;
	struct list_head fcd_dilist;
};

struct ext4_fc_head {
	__le32 fc_features;
	__le32 fc_tid;
};

struct ext4_fc_inode {
	__le32 fc_ino;
	__u8 fc_raw_inode[0];
};

struct ext4_fc_replay_state {
	int fc_replay_num_tags;
	int fc_replay_expected_off;
	int fc_current_pass;
	int fc_cur_tag;
	int fc_crc;
	struct ext4_fc_alloc_region *fc_regions;
	int fc_regions_size;
	int fc_regions_used;
	int fc_regions_valid;
	int *fc_modified_inodes;
	int fc_modified_inodes_used;
	int fc_modified_inodes_size;
};

struct ext4_fc_stats {
	unsigned int fc_ineligible_reason_count[10];
	long unsigned int fc_num_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_failed_commits;
	long unsigned int fc_skipped_commits;
	long unsigned int fc_numblks;
	u64 s_fc_avg_commit_time;
};

struct ext4_fc_tail {
	__le32 fc_tid;
	__le32 fc_crc;
};

struct ext4_fc_tl {
	__le16 fc_tag;
	__le16 fc_len;
};

struct ext4_fc_tl_mem {
	u16 fc_tag;
	u16 fc_len;
};

struct ext4_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	struct dx_hash_info hinfo;
};

struct ext4_free_data {
	struct list_head efd_list;
	struct rb_node efd_node;
	ext4_group_t efd_group;
	ext4_grpblk_t efd_start_cluster;
	ext4_grpblk_t efd_count;
	tid_t efd_tid;
};

struct fscrypt_dummy_policy {};

struct ext4_fs_context {
	char *s_qf_names[3];
	struct fscrypt_dummy_policy dummy_enc_policy;
	int s_jquota_fmt;
	short unsigned int qname_spec;
	long unsigned int vals_s_flags;
	long unsigned int mask_s_flags;
	long unsigned int journal_devnum;
	long unsigned int s_commit_interval;
	long unsigned int s_stripe;
	unsigned int s_inode_readahead_blks;
	unsigned int s_want_extra_isize;
	unsigned int s_li_wait_mult;
	unsigned int s_max_dir_size_kb;
	unsigned int journal_ioprio;
	unsigned int vals_s_mount_opt;
	unsigned int mask_s_mount_opt;
	unsigned int vals_s_mount_opt2;
	unsigned int mask_s_mount_opt2;
	unsigned int opt_flags;
	unsigned int spec;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	kuid_t s_resuid;
	kgid_t s_resgid;
	ext4_fsblk_t s_sb_block;
};

struct ext4_fsmap {
	struct list_head fmr_list;
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	uint64_t fmr_length;
};

struct ext4_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct ext4_fsmap fmh_keys[2];
};

struct ext4_getfsmap_info;

struct ext4_getfsmap_dev {
	int (*gfd_fn)(struct super_block *, struct ext4_fsmap *, struct ext4_getfsmap_info *);
	u32 gfd_dev;
};

typedef int (*ext4_fsmap_format_t)(struct ext4_fsmap *, void *);

struct ext4_getfsmap_info {
	struct ext4_fsmap_head *gfi_head;
	ext4_fsmap_format_t gfi_formatter;
	void *gfi_format_arg;
	ext4_fsblk_t gfi_next_fsblk;
	u32 gfi_dev;
	ext4_group_t gfi_agno;
	struct ext4_fsmap gfi_low;
	struct ext4_fsmap gfi_high;
	struct ext4_fsmap gfi_lastfree;
	struct list_head gfi_meta_list;
	bool gfi_last;
};

struct ext4_group_desc {
	__le32 bg_block_bitmap_lo;
	__le32 bg_inode_bitmap_lo;
	__le32 bg_inode_table_lo;
	__le16 bg_free_blocks_count_lo;
	__le16 bg_free_inodes_count_lo;
	__le16 bg_used_dirs_count_lo;
	__le16 bg_flags;
	__le32 bg_exclude_bitmap_lo;
	__le16 bg_block_bitmap_csum_lo;
	__le16 bg_inode_bitmap_csum_lo;
	__le16 bg_itable_unused_lo;
	__le16 bg_checksum;
	__le32 bg_block_bitmap_hi;
	__le32 bg_inode_bitmap_hi;
	__le32 bg_inode_table_hi;
	__le16 bg_free_blocks_count_hi;
	__le16 bg_free_inodes_count_hi;
	__le16 bg_used_dirs_count_hi;
	__le16 bg_itable_unused_hi;
	__le32 bg_exclude_bitmap_hi;
	__le16 bg_block_bitmap_csum_hi;
	__le16 bg_inode_bitmap_csum_hi;
	__u32 bg_reserved;
};

struct ext4_group_info {
	long unsigned int bb_state;
	struct rb_root bb_free_root;
	ext4_grpblk_t bb_first_free;
	ext4_grpblk_t bb_free;
	ext4_grpblk_t bb_fragments;
	int bb_avg_fragment_size_order;
	ext4_grpblk_t bb_largest_free_order;
	ext4_group_t bb_group;
	struct list_head bb_prealloc_list;
	struct rw_semaphore alloc_sem;
	struct list_head bb_avg_fragment_size_node;
	struct list_head bb_largest_free_order_node;
	ext4_grpblk_t bb_counters[0];
};

struct ext4_iloc {
	struct buffer_head *bh;
	long unsigned int offset;
	ext4_group_t block_group;
};

struct ext4_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size_lo;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks_lo;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_version;
		} linux1;
		struct {
			__u32 h_i_translator;
		} hurd1;
		struct {
			__u32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl_lo;
	__le32 i_size_high;
	__le32 i_obso_faddr;
	union {
		struct {
			__le16 l_i_blocks_high;
			__le16 l_i_file_acl_high;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__le16 l_i_checksum_lo;
			__le16 l_i_reserved;
		} linux2;
		struct {
			__le16 h_i_reserved1;
			__u16 h_i_mode_high;
			__u16 h_i_uid_high;
			__u16 h_i_gid_high;
			__u32 h_i_author;
		} hurd2;
		struct {
			__le16 h_i_reserved1;
			__le16 m_i_file_acl_high;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
	__le16 i_extra_isize;
	__le16 i_checksum_hi;
	__le32 i_ctime_extra;
	__le32 i_mtime_extra;
	__le32 i_atime_extra;
	__le32 i_crtime;
	__le32 i_crtime_extra;
	__le32 i_version_hi;
	__le32 i_projid;
};

struct ext4_pending_tree {
	struct rb_root root;
};

struct jbd2_inode;

struct ext4_inode_info {
	__le32 i_data[15];
	__u32 i_dtime;
	ext4_fsblk_t i_file_acl;
	ext4_group_t i_block_group;
	ext4_lblk_t i_dir_start_lookup;
	long unsigned int i_flags;
	struct rw_semaphore xattr_sem;
	union {
		struct list_head i_orphan;
		unsigned int i_orphan_idx;
	};
	struct list_head i_fc_dilist;
	struct list_head i_fc_list;
	ext4_lblk_t i_fc_lblk_start;
	ext4_lblk_t i_fc_lblk_len;
	atomic_t i_fc_updates;
	atomic_t i_unwritten;
	wait_queue_head_t i_fc_wait;
	struct mutex i_fc_lock;
	loff_t i_disksize;
	struct rw_semaphore i_data_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;
	spinlock_t i_raw_lock;
	struct timespec64 i_crtime;
	atomic_t i_prealloc_active;
	unsigned int i_reserved_data_blocks;
	struct rb_root i_prealloc_node;
	rwlock_t i_prealloc_lock;
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;
	unsigned int i_es_shk_nr;
	ext4_lblk_t i_es_shrink_lblk;
	ext4_group_t i_last_alloc_group;
	struct ext4_pending_tree i_pending_tree;
	__u16 i_extra_isize;
	u16 i_inline_off;
	u16 i_inline_size;
	qsize_t i_reserved_quota;
	spinlock_t i_completed_io_lock;
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	spinlock_t i_block_reservation_lock;
	tid_t i_sync_tid;
	tid_t i_datasync_tid;
	struct dquot *i_dquot[3];
	__u32 i_csum_seed;
	kprojid_t i_projid;
};

struct jbd2_journal_handle;

typedef struct jbd2_journal_handle handle_t;

struct ext4_io_end {
	struct list_head list;
	handle_t *handle;
	struct inode *inode;
	struct bio *bio;
	unsigned int flag;
	refcount_t count;
	struct list_head list_vec;
};

typedef struct ext4_io_end ext4_io_end_t;

struct ext4_io_end_vec {
	struct list_head list;
	loff_t offset;
	ssize_t size;
};

struct ext4_io_submit {
	struct writeback_control *io_wbc;
	struct bio *io_bio;
	ext4_io_end_t *io_end;
	sector_t io_next_block;
};

struct ext4_journal_cb_entry {
	struct list_head jce_list;
	void (*jce_func)(struct super_block *, struct ext4_journal_cb_entry *, int);
};

struct jbd2_buffer_trigger_type {
	void (*t_frozen)(struct jbd2_buffer_trigger_type *, struct buffer_head *, void *, size_t);
	void (*t_abort)(struct jbd2_buffer_trigger_type *, struct buffer_head *);
};

struct ext4_journal_trigger {
	struct jbd2_buffer_trigger_type tr_triggers;
	struct super_block *sb;
};

struct ext4_lazy_init {
	long unsigned int li_state;
	struct list_head li_request_list;
	struct mutex li_list_mtx;
};

struct ext4_li_request {
	struct super_block *lr_super;
	enum ext4_li_mode lr_mode;
	ext4_group_t lr_first_not_zeroed;
	ext4_group_t lr_next_group;
	struct list_head lr_request;
	long unsigned int lr_next_sched;
	long unsigned int lr_timeout;
};

struct ext4_locality_group {
	struct mutex lg_mutex;
	struct list_head lg_prealloc_list[10];
	spinlock_t lg_prealloc_lock;
};

struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
};

struct ext4_mount_options {
	long unsigned int s_mount_opt;
	long unsigned int s_mount_opt2;
	kuid_t s_resuid;
	kgid_t s_resgid;
	long unsigned int s_commit_interval;
	u32 s_min_batch_time;
	u32 s_max_batch_time;
	int s_jquota_fmt;
	char *s_qf_names[3];
};

struct ext4_new_group_data;

struct ext4_new_flex_group_data {
	struct ext4_new_group_data *groups;
	__u16 *bg_flags;
	ext4_group_t resize_bg;
	ext4_group_t count;
};

struct ext4_new_group_data {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 mdata_blocks;
	__u32 free_clusters_count;
};

struct ext4_new_group_input {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
};

struct ext4_orphan_block {
	atomic_t ob_free_entries;
	struct buffer_head *ob_bh;
};

struct ext4_orphan_block_tail {
	__le32 ob_magic;
	__le32 ob_checksum;
};

struct ext4_orphan_info {
	int of_blocks;
	__u32 of_csum_seed;
	struct ext4_orphan_block *of_binfo;
};

struct ext4_prealloc_space {
	union {
		struct rb_node inode_node;
		struct list_head lg_list;
	} pa_node;
	struct list_head pa_group_list;
	union {
		struct list_head pa_tmp_list;
		struct callback_head pa_rcu;
	} u;
	spinlock_t pa_lock;
	atomic_t pa_count;
	unsigned int pa_deleted;
	ext4_fsblk_t pa_pstart;
	ext4_lblk_t pa_lstart;
	ext4_grpblk_t pa_len;
	ext4_grpblk_t pa_free;
	short unsigned int pa_type;
	union {
		rwlock_t *inode_lock;
		spinlock_t *lg_lock;
	} pa_node_lock;
	struct inode *pa_inode;
};

struct ext4_rcu_ptr {
	struct callback_head rcu;
	void *ptr;
};

struct ext4_renament {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool is_dir;
	int dir_nlink_delta;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	int inlined;
	struct buffer_head *dir_bh;
	struct ext4_dir_entry_2 *parent_de;
	int dir_inlined;
};

struct rcu_sync {
	int gp_state;
	int gp_count;
	wait_queue_head_t gp_wait;
	struct callback_head cb_head;
};

struct percpu_rw_semaphore {
	struct rcu_sync rss;
	unsigned int *read_count;
	struct rcuwait writer;
	wait_queue_head_t waiters;
	atomic_t block;
};

struct ext4_super_block;

struct journal_s;

struct ext4_system_blocks;

struct flex_groups;

struct mb_cache;

struct ext4_sb_info {
	long unsigned int s_desc_size;
	long unsigned int s_inodes_per_block;
	long unsigned int s_blocks_per_group;
	long unsigned int s_clusters_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	ext4_group_t s_groups_count;
	ext4_group_t s_blockfile_groups;
	long unsigned int s_overhead;
	unsigned int s_cluster_ratio;
	unsigned int s_cluster_bits;
	loff_t s_bitmap_maxbytes;
	struct buffer_head *s_sbh;
	struct ext4_super_block *s_es;
	struct buffer_head **s_group_desc;
	unsigned int s_mount_opt;
	unsigned int s_mount_opt2;
	long unsigned int s_mount_flags;
	unsigned int s_def_mount_opt;
	unsigned int s_def_mount_opt2;
	ext4_fsblk_t s_sb_block;
	atomic64_t s_resv_clusters;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	unsigned int s_inode_readahead_blks;
	unsigned int s_inode_goal;
	u32 s_hash_seed[4];
	int s_def_hash_version;
	int s_hash_unsigned;
	struct percpu_counter s_freeclusters_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct percpu_counter s_dirtyclusters_counter;
	struct percpu_counter s_sra_exceeded_retry_limit;
	struct blockgroup_lock *s_blockgroup_lock;
	struct proc_dir_entry *s_proc;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct super_block *s_sb;
	struct buffer_head *s_mmp_bh;
	struct journal_s *s_journal;
	long unsigned int s_ext4_flags;
	struct mutex s_orphan_lock;
	struct list_head s_orphan;
	struct ext4_orphan_info s_orphan_info;
	long unsigned int s_commit_interval;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	struct file *s_journal_bdev_file;
	char *s_qf_names[3];
	int s_jquota_fmt;
	unsigned int s_want_extra_isize;
	struct ext4_system_blocks *s_system_blks;
	struct ext4_group_info ***s_group_info;
	struct inode *s_buddy_cache;
	spinlock_t s_md_lock;
	short unsigned int *s_mb_offsets;
	unsigned int *s_mb_maxs;
	unsigned int s_group_info_size;
	unsigned int s_mb_free_pending;
	struct list_head s_freed_data_list[2];
	struct list_head s_discard_list;
	struct work_struct s_discard_work;
	atomic_t s_retry_alloc_pending;
	struct list_head *s_mb_avg_fragment_size;
	rwlock_t *s_mb_avg_fragment_size_locks;
	struct list_head *s_mb_largest_free_orders;
	rwlock_t *s_mb_largest_free_orders_locks;
	long unsigned int s_stripe;
	unsigned int s_mb_max_linear_groups;
	unsigned int s_mb_stream_request;
	unsigned int s_mb_max_to_scan;
	unsigned int s_mb_min_to_scan;
	unsigned int s_mb_stats;
	unsigned int s_mb_order2_reqs;
	unsigned int s_mb_group_prealloc;
	unsigned int s_max_dir_size_kb;
	long unsigned int s_mb_last_group;
	long unsigned int s_mb_last_start;
	unsigned int s_mb_prefetch;
	unsigned int s_mb_prefetch_limit;
	unsigned int s_mb_best_avail_max_trim_order;
	atomic_t s_bal_reqs;
	atomic_t s_bal_success;
	atomic_t s_bal_allocated;
	atomic_t s_bal_ex_scanned;
	atomic_t s_bal_cX_ex_scanned[5];
	atomic_t s_bal_groups_scanned;
	atomic_t s_bal_goals;
	atomic_t s_bal_len_goals;
	atomic_t s_bal_breaks;
	atomic_t s_bal_2orders;
	atomic_t s_bal_p2_aligned_bad_suggestions;
	atomic_t s_bal_goal_fast_bad_suggestions;
	atomic_t s_bal_best_avail_bad_suggestions;
	atomic64_t s_bal_cX_groups_considered[5];
	atomic64_t s_bal_cX_hits[5];
	atomic64_t s_bal_cX_failed[5];
	atomic_t s_mb_buddies_generated;
	atomic64_t s_mb_generation_time;
	atomic_t s_mb_lost_chunks;
	atomic_t s_mb_preallocated;
	atomic_t s_mb_discarded;
	atomic_t s_lock_busy;
	struct ext4_locality_group *s_locality_groups;
	long unsigned int s_sectors_written_start;
	u64 s_kbytes_written;
	unsigned int s_extent_max_zeroout_kb;
	unsigned int s_log_groups_per_flex;
	struct flex_groups **s_flex_groups;
	ext4_group_t s_flex_groups_allocated;
	struct workqueue_struct *rsv_conversion_wq;
	struct timer_list s_err_report;
	struct ext4_li_request *s_li_request;
	unsigned int s_li_wait_mult;
	struct task_struct *s_mmp_tsk;
	long unsigned int s_last_trim_minblks;
	__u32 s_csum_seed;
	struct shrinker *s_es_shrinker;
	struct list_head s_es_list;
	long int s_es_nr_inode;
	struct ext4_es_stats s_es_stats;
	struct mb_cache *s_ea_block_cache;
	struct mb_cache *s_ea_inode_cache;
	long: 64;
	long: 64;
	spinlock_t s_es_lock;
	struct ext4_journal_trigger s_journal_triggers[1];
	struct ratelimit_state s_err_ratelimit_state;
	struct ratelimit_state s_warning_ratelimit_state;
	struct ratelimit_state s_msg_ratelimit_state;
	atomic_t s_warning_count;
	atomic_t s_msg_count;
	struct fscrypt_dummy_policy s_dummy_enc_policy;
	struct percpu_rw_semaphore s_writepages_rwsem;
	struct dax_device *s_daxdev;
	u64 s_dax_part_off;
	errseq_t s_bdev_wb_err;
	spinlock_t s_bdev_wb_lock;
	spinlock_t s_error_lock;
	int s_add_error_count;
	int s_first_error_code;
	__u32 s_first_error_line;
	__u32 s_first_error_ino;
	__u64 s_first_error_block;
	const char *s_first_error_func;
	time64_t s_first_error_time;
	int s_last_error_code;
	__u32 s_last_error_line;
	__u32 s_last_error_ino;
	__u64 s_last_error_block;
	const char *s_last_error_func;
	time64_t s_last_error_time;
	struct work_struct s_sb_upd_work;
	unsigned int s_awu_min;
	unsigned int s_awu_max;
	atomic_t s_fc_subtid;
	struct list_head s_fc_q[2];
	struct list_head s_fc_dentry_q[2];
	unsigned int s_fc_bytes;
	spinlock_t s_fc_lock;
	struct buffer_head *s_fc_bh;
	struct ext4_fc_stats s_fc_stats;
	tid_t s_fc_ineligible_tid;
	struct ext4_fc_replay_state s_fc_replay_state;
	long: 64;
};

struct ext4_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count_lo;
	__le32 s_r_blocks_count_lo;
	__le32 s_free_blocks_count_lo;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_cluster_size;
	__le32 s_blocks_per_group;
	__le32 s_clusters_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__le16 s_reserved_gdt_blocks;
	__u8 s_journal_uuid[16];
	__le32 s_journal_inum;
	__le32 s_journal_dev;
	__le32 s_last_orphan;
	__le32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_jnl_backup_type;
	__le16 s_desc_size;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__le32 s_mkfs_time;
	__le32 s_jnl_blocks[17];
	__le32 s_blocks_count_hi;
	__le32 s_r_blocks_count_hi;
	__le32 s_free_blocks_count_hi;
	__le16 s_min_extra_isize;
	__le16 s_want_extra_isize;
	__le32 s_flags;
	__le16 s_raid_stride;
	__le16 s_mmp_update_interval;
	__le64 s_mmp_block;
	__le32 s_raid_stripe_width;
	__u8 s_log_groups_per_flex;
	__u8 s_checksum_type;
	__u8 s_encryption_level;
	__u8 s_reserved_pad;
	__le64 s_kbytes_written;
	__le32 s_snapshot_inum;
	__le32 s_snapshot_id;
	__le64 s_snapshot_r_blocks_count;
	__le32 s_snapshot_list;
	__le32 s_error_count;
	__le32 s_first_error_time;
	__le32 s_first_error_ino;
	__le64 s_first_error_block;
	__u8 s_first_error_func[32];
	__le32 s_first_error_line;
	__le32 s_last_error_time;
	__le32 s_last_error_ino;
	__le32 s_last_error_line;
	__le64 s_last_error_block;
	__u8 s_last_error_func[32];
	__u8 s_mount_opts[64];
	__le32 s_usr_quota_inum;
	__le32 s_grp_quota_inum;
	__le32 s_overhead_clusters;
	__le32 s_backup_bgs[2];
	__u8 s_encrypt_algos[4];
	__u8 s_encrypt_pw_salt[16];
	__le32 s_lpf_ino;
	__le32 s_prj_quota_inum;
	__le32 s_checksum_seed;
	__u8 s_wtime_hi;
	__u8 s_mtime_hi;
	__u8 s_mkfs_time_hi;
	__u8 s_lastcheck_hi;
	__u8 s_first_error_time_hi;
	__u8 s_last_error_time_hi;
	__u8 s_first_error_errcode;
	__u8 s_last_error_errcode;
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__le32 s_orphan_file_inum;
	__le32 s_reserved[94];
	__le32 s_checksum;
};

struct ext4_system_blocks {
	struct rb_root root;
	struct callback_head rcu;
};

struct ext4_system_zone {
	struct rb_node node;
	ext4_fsblk_t start_blk;
	unsigned int count;
	u32 ino;
};

struct ext4_xattr_entry;

struct ext4_xattr_search {
	struct ext4_xattr_entry *first;
	void *base;
	void *end;
	struct ext4_xattr_entry *here;
	int not_found;
};

struct ext4_xattr_block_find {
	struct ext4_xattr_search s;
	struct buffer_head *bh;
};

struct ext4_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_inum;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

struct ext4_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__le32 h_checksum;
	__u32 h_reserved[3];
};

struct ext4_xattr_ibody_find {
	struct ext4_xattr_search s;
	struct ext4_iloc iloc;
};

struct ext4_xattr_ibody_header {
	__le32 h_magic;
};

struct ext4_xattr_info {
	const char *name;
	const void *value;
	size_t value_len;
	int name_index;
	int in_inode;
};

struct ext4_xattr_inode_array {
	unsigned int count;
	struct inode *inodes[0];
};

struct ext_arg {
	size_t argsz;
	struct timespec64 ts;
	const sigset_t *sig;
	ktime_t min_time;
	bool ts_set;
};

struct msg_msg;

struct ext_wait_queue {
	struct task_struct *task;
	struct list_head list;
	struct msg_msg *msg;
	int state;
};

struct extended_signature {
	unsigned int sig;
	unsigned int pf;
	unsigned int cksum;
};

struct extended_sigtable {
	unsigned int count;
	unsigned int cksum;
	unsigned int reserved[3];
	struct extended_signature sigs[0];
};

struct extent_buffer {
	u64 start;
	u32 len;
	u32 folio_size;
	long unsigned int bflags;
	struct btrfs_fs_info *fs_info;
	void *addr;
	spinlock_t refs_lock;
	atomic_t refs;
	int read_mirror;
	s8 log_index;
	u8 folio_shift;
	struct callback_head callback_head;
	struct rw_semaphore lock;
	struct folio *folios[16];
};

struct extent_changeset {
	u64 bytes_changed;
	struct ulist range_changed;
};

struct extent_inode_elem {
	u64 inum;
	u64 offset;
	u64 num_bytes;
	struct extent_inode_elem *next;
};

struct extent_map {
	struct rb_node rb_node;
	u64 start;
	u64 len;
	u64 disk_bytenr;
	u64 disk_num_bytes;
	u64 offset;
	u64 ram_bytes;
	u64 generation;
	u32 flags;
	refcount_t refs;
	struct list_head list;
};

struct extent_state {
	u64 start;
	u64 end;
	struct rb_node rb_node;
	wait_queue_head_t wq;
	refcount_t refs;
	u32 state;
};

struct extent_status {
	struct rb_node rb_node;
	ext4_lblk_t es_lblk;
	ext4_lblk_t es_len;
	ext4_fsblk_t es_pblk;
};

struct external_name {
	atomic_t count;
	struct callback_head head;
	unsigned char name[0];
};

struct extra_reg {
	unsigned int event;
	unsigned int msr;
	u64 config_mask;
	u64 valid_mask;
	int idx;
	bool extra_msr_access;
};

struct f815xxa_data {
	spinlock_t lock;
	int idx;
};

struct f_owner_ex {
	int type;
	__kernel_pid_t pid;
};

struct failover_ops;

struct failover {
	struct list_head list;
	struct net_device *failover_dev;
	netdevice_tracker dev_tracker;
	struct failover_ops *ops;
};

struct failover_ops {
	int (*slave_pre_register)(struct net_device *, struct net_device *);
	int (*slave_register)(struct net_device *, struct net_device *);
	int (*slave_pre_unregister)(struct net_device *, struct net_device *);
	int (*slave_unregister)(struct net_device *, struct net_device *);
	int (*slave_link_change)(struct net_device *, struct net_device *);
	int (*slave_name_change)(struct net_device *, struct net_device *);
	rx_handler_result_t (*slave_handle_frame)(struct sk_buff **);
};

struct falloc_range {
	struct list_head list;
	u64 start;
	u64 len;
};

struct fanotify_response_info_header {
	__u8 type;
	__u8 pad;
	__u16 len;
};

struct fanotify_response_info_audit_rule {
	struct fanotify_response_info_header hdr;
	__u32 rule_number;
	__u32 subj_trust;
	__u32 obj_trust;
};

struct fanout_args {
	__u16 id;
	__u16 type_flags;
	__u32 max_num_members;
};

struct fast_pool {
	long unsigned int pool[4];
	long unsigned int last;
	unsigned int count;
	struct timer_list mix;
};

struct fasync_struct {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	struct file *fa_file;
	struct callback_head fa_rcu;
};

struct fat_bios_param_block {
	u16 fat_sector_size;
	u8 fat_sec_per_clus;
	u16 fat_reserved;
	u8 fat_fats;
	u16 fat_dir_entries;
	u16 fat_sectors;
	u16 fat_fat_length;
	u32 fat_total_sect;
	u8 fat16_state;
	u32 fat16_vol_id;
	u32 fat32_length;
	u32 fat32_root_cluster;
	u16 fat32_info_sector;
	u8 fat32_state;
	u32 fat32_vol_id;
};

struct fat_boot_fsinfo {
	__le32 signature1;
	__le32 reserved1[120];
	__le32 signature2;
	__le32 free_clusters;
	__le32 next_cluster;
	__le32 reserved2[4];
};

struct fat_boot_sector {
	__u8 ignored[3];
	__u8 system_id[8];
	__u8 sector_size[2];
	__u8 sec_per_clus;
	__le16 reserved;
	__u8 fats;
	__u8 dir_entries[2];
	__u8 sectors[2];
	__u8 media;
	__le16 fat_length;
	__le16 secs_track;
	__le16 heads;
	__le32 hidden;
	__le32 total_sect;
	union {
		struct {
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat16;
		struct {
			__le32 length;
			__le16 flags;
			__u8 version[2];
			__le32 root_cluster;
			__le16 info_sector;
			__le16 backup_boot;
			__le16 reserved2[6];
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat32;
	};
};

struct fat_cache {
	struct list_head cache_list;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct fat_cache_id {
	unsigned int id;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct fat_entry {
	int entry;
	union {
		u8 *ent12_p[2];
		__le16 *ent16_p;
		__le32 *ent32_p;
	} u;
	int nr_bhs;
	struct buffer_head *bhs[2];
	struct inode *fat_inode;
};

struct fat_fid {
	u32 i_gen;
	u32 i_pos_low;
	u16 i_pos_hi;
	u16 parent_i_pos_hi;
	u32 parent_i_pos_low;
	u32 parent_i_gen;
};

struct fat_floppy_defaults {
	unsigned int nr_sectors;
	unsigned int sec_per_clus;
	unsigned int dir_entries;
	unsigned int media;
	unsigned int fat_length;
};

struct fat_ioctl_filldir_callback {
	struct dir_context ctx;
	void *dirent;
	int result;
	const char *longname;
	int long_len;
	const char *shortname;
	int short_len;
};

struct fat_mount_options {
	kuid_t fs_uid;
	kgid_t fs_gid;
	short unsigned int fs_fmask;
	short unsigned int fs_dmask;
	short unsigned int codepage;
	int time_offset;
	char *iocharset;
	short unsigned int shortname;
	unsigned char name_check;
	unsigned char errors;
	unsigned char nfs;
	short unsigned int allow_utime;
	unsigned int quiet: 1;
	unsigned int showexec: 1;
	unsigned int sys_immutable: 1;
	unsigned int dotsOK: 1;
	unsigned int isvfat: 1;
	unsigned int utf8: 1;
	unsigned int unicode_xlate: 1;
	unsigned int numtail: 1;
	unsigned int flush: 1;
	unsigned int nocase: 1;
	unsigned int usefree: 1;
	unsigned int tz_set: 1;
	unsigned int rodir: 1;
	unsigned int discard: 1;
	unsigned int dos1xfloppy: 1;
	unsigned int debug: 1;
};

struct msdos_dir_entry;

struct fat_slot_info {
	loff_t i_pos;
	loff_t slot_off;
	int nr_slots;
	struct msdos_dir_entry *de;
	struct buffer_head *bh;
};

struct fatent_operations {
	void (*ent_blocknr)(struct super_block *, int, int *, sector_t *);
	void (*ent_set_ptr)(struct fat_entry *, int);
	int (*ent_bread)(struct super_block *, struct fat_entry *, int, sector_t);
	int (*ent_get)(struct fat_entry *);
	void (*ent_put)(struct fat_entry *, int);
	int (*ent_next)(struct fat_entry *);
};

struct fatent_ra {
	sector_t cur;
	sector_t limit;
	unsigned int ra_blocks;
	sector_t ra_advance;
	sector_t ra_next;
	sector_t ra_limit;
};

struct faux_device {
	struct device dev;
};

struct faux_device_ops {
	int (*probe)(struct faux_device *);
	void (*remove)(struct faux_device *);
};

struct faux_object {
	struct faux_device faux_dev;
	const struct faux_device_ops *faux_ops;
};

struct fb_bitfield {
	__u32 offset;
	__u32 length;
	__u32 msb_right;
};

struct fb_blit_caps {
	long unsigned int x[1];
	long unsigned int y[2];
	u32 len;
	u32 flags;
};

struct fb_chroma {
	__u32 redx;
	__u32 greenx;
	__u32 bluex;
	__u32 whitex;
	__u32 redy;
	__u32 greeny;
	__u32 bluey;
	__u32 whitey;
};

struct fb_cmap {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_cmap_user {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_con2fbmap {
	__u32 console;
	__u32 framebuffer;
};

struct fb_copyarea {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 sx;
	__u32 sy;
};

struct fbcurpos {
	__u16 x;
	__u16 y;
};

struct fb_image {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 fg_color;
	__u32 bg_color;
	__u8 depth;
	const char *data;
	struct fb_cmap cmap;
};

struct fb_cursor {
	__u16 set;
	__u16 enable;
	__u16 rop;
	const char *mask;
	struct fbcurpos hot;
	struct fb_image image;
};

struct fb_cvt_data {
	u32 xres;
	u32 yres;
	u32 refresh;
	u32 f_refresh;
	u32 pixclock;
	u32 hperiod;
	u32 hblank;
	u32 hfreq;
	u32 htotal;
	u32 vtotal;
	u32 vsync;
	u32 hsync;
	u32 h_front_porch;
	u32 h_back_porch;
	u32 v_front_porch;
	u32 v_back_porch;
	u32 h_margin;
	u32 v_margin;
	u32 interlace;
	u32 aspect_ratio;
	u32 active_pixels;
	u32 flags;
	u32 status;
};

struct fb_deferred_io_pageref {
	struct page *page;
	long unsigned int offset;
	struct list_head list;
};

struct fb_event {
	struct fb_info *info;
	void *data;
};

struct fb_fillrect {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 color;
	__u32 rop;
};

struct fb_fix_screeninfo {
	char id[16];
	long unsigned int smem_start;
	__u32 smem_len;
	__u32 type;
	__u32 type_aux;
	__u32 visual;
	__u16 xpanstep;
	__u16 ypanstep;
	__u16 ywrapstep;
	__u32 line_length;
	long unsigned int mmio_start;
	__u32 mmio_len;
	__u32 accel;
	__u16 capabilities;
	__u16 reserved[2];
};

struct fb_var_screeninfo {
	__u32 xres;
	__u32 yres;
	__u32 xres_virtual;
	__u32 yres_virtual;
	__u32 xoffset;
	__u32 yoffset;
	__u32 bits_per_pixel;
	__u32 grayscale;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	__u32 nonstd;
	__u32 activate;
	__u32 height;
	__u32 width;
	__u32 accel_flags;
	__u32 pixclock;
	__u32 left_margin;
	__u32 right_margin;
	__u32 upper_margin;
	__u32 lower_margin;
	__u32 hsync_len;
	__u32 vsync_len;
	__u32 sync;
	__u32 vmode;
	__u32 rotate;
	__u32 colorspace;
	__u32 reserved[4];
};

struct fb_videomode;

struct fb_monspecs {
	struct fb_chroma chroma;
	struct fb_videomode *modedb;
	__u8 manufacturer[4];
	__u8 monitor[14];
	__u8 serial_no[14];
	__u8 ascii[14];
	__u32 modedb_len;
	__u32 model;
	__u32 serial;
	__u32 year;
	__u32 week;
	__u32 hfmin;
	__u32 hfmax;
	__u32 dclkmin;
	__u32 dclkmax;
	__u16 input;
	__u16 dpms;
	__u16 signal;
	__u16 vfmin;
	__u16 vfmax;
	__u16 gamma;
	__u16 gtf: 1;
	__u16 misc;
	__u8 version;
	__u8 revision;
	__u8 max_x;
	__u8 max_y;
};

struct fb_pixmap {
	u8 *addr;
	u32 size;
	u32 offset;
	u32 buf_align;
	u32 scan_align;
	u32 access_align;
	u32 flags;
	long unsigned int blit_x[1];
	long unsigned int blit_y[2];
	void (*writeio)(struct fb_info *, void *, void *, unsigned int);
	void (*readio)(struct fb_info *, void *, void *, unsigned int);
};

struct lcd_device;

struct fb_ops;

struct fb_info {
	refcount_t count;
	int node;
	int flags;
	int fbcon_rotate_hint;
	struct mutex lock;
	struct mutex mm_lock;
	struct fb_var_screeninfo var;
	struct fb_fix_screeninfo fix;
	struct fb_monspecs monspecs;
	struct fb_pixmap pixmap;
	struct fb_pixmap sprite;
	struct fb_cmap cmap;
	struct list_head modelist;
	struct fb_videomode *mode;
	struct lcd_device *lcd_dev;
	struct delayed_work deferred_work;
	long unsigned int npagerefs;
	struct fb_deferred_io_pageref *pagerefs;
	struct fb_deferred_io *fbdefio;
	const struct fb_ops *fbops;
	struct device *device;
	struct device *dev;
	int class_flag;
	union {
		char *screen_base;
		char *screen_buffer;
	};
	long unsigned int screen_size;
	void *pseudo_palette;
	u32 state;
	void *fbcon_par;
	void *par;
	bool skip_vt_switch;
	bool skip_panic;
};

struct fb_videomode {
	const char *name;
	u32 refresh;
	u32 xres;
	u32 yres;
	u32 pixclock;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 sync;
	u32 vmode;
	u32 flag;
};

struct fb_modelist {
	struct list_head list;
	struct fb_videomode mode;
};

struct fb_ops {
	struct module *owner;
	int (*fb_open)(struct fb_info *, int);
	int (*fb_release)(struct fb_info *, int);
	ssize_t (*fb_read)(struct fb_info *, char *, size_t, loff_t *);
	ssize_t (*fb_write)(struct fb_info *, const char *, size_t, loff_t *);
	int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *);
	int (*fb_set_par)(struct fb_info *);
	int (*fb_setcolreg)(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, struct fb_info *);
	int (*fb_setcmap)(struct fb_cmap *, struct fb_info *);
	int (*fb_blank)(int, struct fb_info *);
	int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *);
	void (*fb_fillrect)(struct fb_info *, const struct fb_fillrect *);
	void (*fb_copyarea)(struct fb_info *, const struct fb_copyarea *);
	void (*fb_imageblit)(struct fb_info *, const struct fb_image *);
	int (*fb_cursor)(struct fb_info *, struct fb_cursor *);
	int (*fb_sync)(struct fb_info *);
	int (*fb_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_compat_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_mmap)(struct fb_info *, struct vm_area_struct *);
	void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *);
	void (*fb_destroy)(struct fb_info *);
	int (*fb_debug_enter)(struct fb_info *);
	int (*fb_debug_leave)(struct fb_info *);
};

struct fb_plane_view_dims {
	unsigned int width;
	unsigned int height;
	unsigned int tile_width;
	unsigned int tile_height;
};

struct fbcon_display {
	const u_char *fontdata;
	int userfont;
	u_short inverse;
	short int yscroll;
	int vrows;
	int cursor_shape;
	int con_rotate;
	u32 xres_virtual;
	u32 yres_virtual;
	u32 height;
	u32 width;
	u32 bits_per_pixel;
	u32 grayscale;
	u32 nonstd;
	u32 accel_flags;
	u32 rotate;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	const struct fb_videomode *mode;
};

struct fbcon_ops {
	void (*bmove)(struct vc_data *, struct fb_info *, int, int, int, int, int, int);
	void (*clear)(struct vc_data *, struct fb_info *, int, int, int, int);
	void (*putcs)(struct vc_data *, struct fb_info *, const short unsigned int *, int, int, int, int, int);
	void (*clear_margins)(struct vc_data *, struct fb_info *, int, int);
	void (*cursor)(struct vc_data *, struct fb_info *, bool, int, int);
	int (*update_start)(struct fb_info *);
	int (*rotate_font)(struct fb_info *, struct vc_data *);
	struct fb_var_screeninfo var;
	struct delayed_work cursor_work;
	struct fb_cursor cursor_state;
	struct fbcon_display *p;
	struct fb_info *info;
	int currcon;
	int cur_blink_jiffies;
	int cursor_flash;
	int cursor_reset;
	int blank_state;
	int graphics;
	int save_graphics;
	bool initialized;
	int rotate;
	int cur_rotate;
	char *cursor_data;
	u8 *fontbuffer;
	u8 *fontdata;
	u8 *cursor_src;
	u32 cursor_size;
	u32 fd_size;
};

struct fc_log {
	refcount_t usage;
	u8 head;
	u8 tail;
	u8 need_free;
	struct module *owner;
	char *buffer[8];
};

struct fcnvme_ls_rqst_w0 {
	u8 ls_cmd;
	u8 zeros[3];
};

struct fcnvme_lsdesc_rqst {
	__be32 desc_tag;
	__be32 desc_len;
	struct fcnvme_ls_rqst_w0 w0;
	__be32 rsvd12;
};

struct fcnvme_ls_acc_hdr {
	struct fcnvme_ls_rqst_w0 w0;
	__be32 desc_list_len;
	struct fcnvme_lsdesc_rqst rqst;
};

struct fcnvme_lsdesc_assoc_id {
	__be32 desc_tag;
	__be32 desc_len;
	__be64 association_id;
};

struct fcnvme_lsdesc_conn_id {
	__be32 desc_tag;
	__be32 desc_len;
	__be64 connection_id;
};

struct fcnvme_ls_cr_assoc_acc {
	struct fcnvme_ls_acc_hdr hdr;
	struct fcnvme_lsdesc_assoc_id associd;
	struct fcnvme_lsdesc_conn_id connectid;
};

struct fcnvme_lsdesc_cr_assoc_cmd {
	__be32 desc_tag;
	__be32 desc_len;
	__be16 ersp_ratio;
	__be16 rsvd10;
	__be32 rsvd12[9];
	__be16 cntlid;
	__be16 sqsize;
	__be32 rsvd52;
	uuid_t hostid;
	u8 hostnqn[256];
	u8 subnqn[256];
	__be32 rsvd584[108];
};

struct fcnvme_ls_cr_assoc_rqst {
	struct fcnvme_ls_rqst_w0 w0;
	__be32 desc_list_len;
	struct fcnvme_lsdesc_cr_assoc_cmd assoc_cmd;
};

struct fcnvme_ls_cr_conn_acc {
	struct fcnvme_ls_acc_hdr hdr;
	struct fcnvme_lsdesc_conn_id connectid;
};

struct fcnvme_lsdesc_cr_conn_cmd {
	__be32 desc_tag;
	__be32 desc_len;
	__be16 ersp_ratio;
	__be16 rsvd10;
	__be32 rsvd12[9];
	__be16 qid;
	__be16 sqsize;
	__be32 rsvd52;
};

struct fcnvme_ls_cr_conn_rqst {
	struct fcnvme_ls_rqst_w0 w0;
	__be32 desc_list_len;
	struct fcnvme_lsdesc_assoc_id associd;
	struct fcnvme_lsdesc_cr_conn_cmd connect_cmd;
};

struct fcnvme_ls_disconnect_assoc_acc {
	struct fcnvme_ls_acc_hdr hdr;
};

struct fcnvme_lsdesc_disconn_cmd {
	__be32 desc_tag;
	__be32 desc_len;
	__be32 rsvd8[4];
};

struct fcnvme_ls_disconnect_assoc_rqst {
	struct fcnvme_ls_rqst_w0 w0;
	__be32 desc_list_len;
	struct fcnvme_lsdesc_assoc_id associd;
	struct fcnvme_lsdesc_disconn_cmd discon_cmd;
};

struct fcnvme_ls_disconnect_conn_acc {
	struct fcnvme_ls_acc_hdr hdr;
};

struct fcnvme_ls_disconnect_conn_rqst {
	struct fcnvme_ls_rqst_w0 w0;
	__be32 desc_list_len;
	struct fcnvme_lsdesc_assoc_id associd;
	struct fcnvme_lsdesc_conn_id connectid;
};

struct fcnvme_lsdesc_rjt {
	__be32 desc_tag;
	__be32 desc_len;
	u8 rsvd8;
	u8 reason_code;
	u8 reason_explanation;
	u8 vendor;
	__be32 rsvd12;
};

struct fcnvme_ls_rjt {
	struct fcnvme_ls_rqst_w0 w0;
	__be32 desc_list_len;
	struct fcnvme_lsdesc_rqst rqst;
	struct fcnvme_lsdesc_rjt rjt;
};

struct fd {
	long unsigned int word;
};

typedef struct fd class_fd_pos_t;

typedef struct fd class_fd_raw_t;

typedef struct fd class_fd_t;

struct fd_data {
	fmode_t mode;
	unsigned int fd;
};

struct fd_range {
	unsigned int from;
	unsigned int to;
};

struct fdtable {
	unsigned int max_fds;
	struct file **fd;
	long unsigned int *close_on_exec;
	long unsigned int *open_fds;
	long unsigned int *full_fds_bits;
	struct callback_head rcu;
};

struct features_reply_data {
	struct ethnl_reply_data base;
	u32 hw[2];
	u32 wanted[2];
	u32 active[2];
	u32 nochange[2];
	u32 all[2];
};

struct fec_stat_grp {
	u64 stats[9];
	u8 cnt;
};

struct fec_reply_data {
	struct ethnl_reply_data base;
	long unsigned int fec_link_modes[2];
	u32 active_fec;
	u8 fec_auto;
	struct fec_stat_grp corr;
	struct fec_stat_grp uncorr;
	struct fec_stat_grp corr_bits;
};

struct fetch_insn {
	enum fetch_op op;
	union {
		unsigned int param;
		struct {
			unsigned int size;
			int offset;
		};
		struct {
			unsigned char basesize;
			unsigned char lshift;
			unsigned char rshift;
		};
		long unsigned int immediate;
		void *data;
	};
};

struct trace_seq;

typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);

struct fetch_type {
	const char *name;
	size_t size;
	bool is_signed;
	bool is_string;
	print_type_func_t print;
	const char *fmt;
	const char *fmttype;
};

struct ff_condition_effect {
	__u16 right_saturation;
	__u16 left_saturation;
	__s16 right_coeff;
	__s16 left_coeff;
	__u16 deadband;
	__s16 center;
};

struct ff_envelope {
	__u16 attack_length;
	__u16 attack_level;
	__u16 fade_length;
	__u16 fade_level;
};

struct ff_constant_effect {
	__s16 level;
	struct ff_envelope envelope;
};

struct ff_effect;

struct ff_device {
	int (*upload)(struct input_dev *, struct ff_effect *, struct ff_effect *);
	int (*erase)(struct input_dev *, int);
	int (*playback)(struct input_dev *, int, int);
	void (*set_gain)(struct input_dev *, u16);
	void (*set_autocenter)(struct input_dev *, u16);
	void (*destroy)(struct ff_device *);
	void *private;
	long unsigned int ffbit[2];
	struct mutex mutex;
	int max_effects;
	struct ff_effect *effects;
	struct file *effect_owners[0];
};

struct ff_trigger {
	__u16 button;
	__u16 interval;
};

struct ff_replay {
	__u16 length;
	__u16 delay;
};

struct ff_ramp_effect {
	__s16 start_level;
	__s16 end_level;
	struct ff_envelope envelope;
};

struct ff_periodic_effect {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	__s16 *custom_data;
};

struct ff_rumble_effect {
	__u16 strong_magnitude;
	__u16 weak_magnitude;
};

struct ff_effect {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct fib_kuid_range {
	kuid_t start;
	kuid_t end;
};

struct fib_rule_port_range {
	__u16 start;
	__u16 end;
};

struct fib_rule {
	struct list_head list;
	int iifindex;
	int oifindex;
	u32 mark;
	u32 mark_mask;
	u32 flags;
	u32 table;
	u8 action;
	u8 l3mdev;
	u8 proto;
	u8 ip_proto;
	u32 target;
	__be64 tun_id;
	struct fib_rule *ctarget;
	struct net *fr_net;
	refcount_t refcnt;
	u32 pref;
	int suppress_ifgroup;
	int suppress_prefixlen;
	char iifname[16];
	char oifname[16];
	struct fib_kuid_range uid_range;
	struct fib_rule_port_range sport_range;
	struct fib_rule_port_range dport_range;
	struct callback_head rcu;
};

struct fib4_rule {
	struct fib_rule common;
	u8 dst_len;
	u8 src_len;
	dscp_t dscp;
	u8 dscp_full: 1;
	__be32 src;
	__be32 srcmask;
	__be32 dst;
	__be32 dstmask;
	u32 tclassid;
};

struct fib6_node;

struct fib6_walker {
	struct list_head lh;
	struct fib6_node *root;
	struct fib6_node *node;
	struct fib6_info *leaf;
	enum fib6_walk_state state;
	unsigned int skip;
	unsigned int count;
	unsigned int skip_in_node;
	int (*func)(struct fib6_walker *);
	void *args;
};

struct fib6_cleaner {
	struct fib6_walker w;
	struct net *net;
	int (*func)(struct fib6_info *, void *);
	int sernum;
	void *arg;
	bool skip_notify;
};

struct nlmsghdr;

struct nl_info {
	struct nlmsghdr *nlh;
	struct net *nl_net;
	u32 portid;
	u8 skip_notify: 1;
	u8 skip_notify_kernel: 1;
};

struct fib6_config {
	u32 fc_table;
	u32 fc_metric;
	int fc_dst_len;
	int fc_src_len;
	int fc_ifindex;
	u32 fc_flags;
	u32 fc_protocol;
	u16 fc_type;
	u16 fc_delete_all_nh: 1;
	u16 fc_ignore_dev_down: 1;
	u16 __unused: 14;
	u32 fc_nh_id;
	struct in6_addr fc_dst;
	struct in6_addr fc_src;
	struct in6_addr fc_prefsrc;
	struct in6_addr fc_gateway;
	long unsigned int fc_expires;
	struct nlattr *fc_mx;
	int fc_mx_len;
	int fc_mp_len;
	struct nlattr *fc_mp;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
	bool fc_is_fdb;
};

struct fib6_dump_arg {
	struct net *net;
	struct notifier_block *nb;
	struct netlink_ext_ack *extack;
};

struct fib_notifier_info {
	int family;
	struct netlink_ext_ack *extack;
};

struct fib6_entry_notifier_info {
	struct fib_notifier_info info;
	struct fib6_info *rt;
	unsigned int nsiblings;
};

struct fib6_gc_args {
	int timeout;
	int more;
};

struct rt6key {
	struct in6_addr addr;
	int plen;
};

struct rtable;

struct fnhe_hash_bucket;

struct fib_nh_common {
	struct net_device *nhc_dev;
	netdevice_tracker nhc_dev_tracker;
	int nhc_oif;
	unsigned char nhc_scope;
	u8 nhc_family;
	u8 nhc_gw_family;
	unsigned char nhc_flags;
	struct lwtunnel_state *nhc_lwtstate;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} nhc_gw;
	int nhc_weight;
	atomic_t nhc_upper_bound;
	struct rtable **nhc_pcpu_rth_output;
	struct rtable *nhc_rth_input;
	struct fnhe_hash_bucket *nhc_exceptions;
};

struct rt6_info;

struct rt6_exception_bucket;

struct fib6_nh {
	struct fib_nh_common nh_common;
	long unsigned int last_probe;
	struct rt6_info **rt6i_pcpu;
	struct rt6_exception_bucket *rt6i_exception_bucket;
};

struct fib6_table;

struct nexthop;

struct fib6_info {
	struct fib6_table *fib6_table;
	struct fib6_info *fib6_next;
	struct fib6_node *fib6_node;
	union {
		struct list_head fib6_siblings;
		struct list_head nh_list;
	};
	unsigned int fib6_nsiblings;
	refcount_t fib6_ref;
	long unsigned int expires;
	struct hlist_node gc_link;
	struct dst_metrics *fib6_metrics;
	struct rt6key fib6_dst;
	u32 fib6_flags;
	struct rt6key fib6_src;
	struct rt6key fib6_prefsrc;
	u32 fib6_metric;
	u8 fib6_protocol;
	u8 fib6_type;
	u8 offload;
	u8 trap;
	u8 offload_failed;
	u8 should_flush: 1;
	u8 dst_nocount: 1;
	u8 dst_nopolicy: 1;
	u8 fib6_destroying: 1;
	u8 unused: 4;
	struct callback_head rcu;
	struct nexthop *nh;
	struct fib6_nh fib6_nh[0];
};

struct fib6_nh_age_excptn_arg {
	struct fib6_gc_args *gc_args;
	long unsigned int now;
};

struct fib6_nh_del_cached_rt_arg {
	struct fib6_config *cfg;
	struct fib6_info *f6i;
};

struct fib6_nh_dm_arg {
	struct net *net;
	const struct in6_addr *saddr;
	int oif;
	int flags;
	struct fib6_nh *nh;
};

struct rt6_rtnl_dump_arg;

struct fib6_nh_exception_dump_walker {
	struct rt6_rtnl_dump_arg *dump;
	struct fib6_info *rt;
	unsigned int flags;
	unsigned int skip;
	unsigned int count;
};

struct fib6_nh_excptn_arg {
	struct rt6_info *rt;
	int plen;
};

struct fib6_nh_frl_arg {
	u32 flags;
	int oif;
	int strict;
	int *mpri;
	bool *do_rr;
	struct fib6_nh *nh;
};

struct fib6_nh_match_arg {
	const struct net_device *dev;
	const struct in6_addr *gw;
	struct fib6_nh *match;
};

struct fib6_nh_pcpu_arg {
	struct fib6_info *from;
	const struct fib6_table *table;
};

struct fib6_result;

struct fib6_nh_rd_arg {
	struct fib6_result *res;
	struct flowi6 *fl6;
	const struct in6_addr *gw;
	struct rt6_info **ret;
};

struct fib6_node {
	struct fib6_node *parent;
	struct fib6_node *left;
	struct fib6_node *right;
	struct fib6_node *subtree;
	struct fib6_info *leaf;
	__u16 fn_bit;
	__u16 fn_flags;
	int fn_sernum;
	struct fib6_info *rr_ptr;
	struct callback_head rcu;
};

struct fib6_result {
	struct fib6_nh *nh;
	struct fib6_info *f6i;
	u32 fib6_flags;
	u8 fib6_type;
	struct rt6_info *rt6;
};

struct fib6_rule {
	struct fib_rule common;
	struct rt6key src;
	struct rt6key dst;
	__be32 flowlabel;
	__be32 flowlabel_mask;
	dscp_t dscp;
	u8 dscp_full: 1;
};

struct inet_peer_base {
	struct rb_root rb_root;
	seqlock_t lock;
	int total;
};

struct fib6_table {
	struct hlist_node tb6_hlist;
	u32 tb6_id;
	spinlock_t tb6_lock;
	struct fib6_node tb6_root;
	struct inet_peer_base tb6_peers;
	unsigned int flags;
	unsigned int fib_seq;
	struct hlist_head tb6_gc_hlist;
};

struct fib_info;

struct fib_alias {
	struct hlist_node fa_list;
	struct fib_info *fa_info;
	dscp_t fa_dscp;
	u8 fa_type;
	u8 fa_state;
	u8 fa_slen;
	u32 tb_id;
	s16 fa_default;
	u8 offload;
	u8 trap;
	u8 offload_failed;
	struct callback_head rcu;
};

struct rtnexthop;

struct fib_config {
	u8 fc_dst_len;
	dscp_t fc_dscp;
	u8 fc_protocol;
	u8 fc_scope;
	u8 fc_type;
	u8 fc_gw_family;
	u32 fc_table;
	__be32 fc_dst;
	union {
		__be32 fc_gw4;
		struct in6_addr fc_gw6;
	};
	int fc_oif;
	u32 fc_flags;
	u32 fc_priority;
	__be32 fc_prefsrc;
	u32 fc_nh_id;
	struct nlattr *fc_mx;
	struct rtnexthop *fc_mp;
	int fc_mx_len;
	int fc_mp_len;
	u32 fc_flow;
	u32 fc_nlflags;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct fib_dump_filter {
	u32 table_id;
	bool filter_set;
	bool dump_routes;
	bool dump_exceptions;
	bool rtnl_held;
	unsigned char protocol;
	unsigned char rt_type;
	unsigned int flags;
	struct net_device *dev;
};

struct fib_entry_notifier_info {
	struct fib_notifier_info info;
	u32 dst;
	int dst_len;
	struct fib_info *fi;
	dscp_t dscp;
	u8 type;
	u32 tb_id;
};

struct fib_nh {
	struct fib_nh_common nh_common;
	struct hlist_node nh_hash;
	struct fib_info *nh_parent;
	__u32 nh_tclassid;
	__be32 nh_saddr;
	int nh_saddr_genid;
};

struct fib_info {
	struct hlist_node fib_hash;
	struct hlist_node fib_lhash;
	struct list_head nh_list;
	struct net *fib_net;
	refcount_t fib_treeref;
	refcount_t fib_clntref;
	unsigned int fib_flags;
	unsigned char fib_dead;
	unsigned char fib_protocol;
	unsigned char fib_scope;
	unsigned char fib_type;
	__be32 fib_prefsrc;
	u32 fib_tb_id;
	u32 fib_priority;
	struct dst_metrics *fib_metrics;
	int fib_nhs;
	bool fib_nh_is_v6;
	bool nh_updated;
	bool pfsrc_removed;
	struct nexthop *nh;
	struct callback_head rcu;
	struct fib_nh fib_nh[0];
};

struct fib_lookup_arg {
	void *lookup_ptr;
	const void *lookup_data;
	void *result;
	struct fib_rule *rule;
	u32 table;
	int flags;
};

struct fib_nh_exception {
	struct fib_nh_exception *fnhe_next;
	int fnhe_genid;
	__be32 fnhe_daddr;
	u32 fnhe_pmtu;
	bool fnhe_mtu_locked;
	__be32 fnhe_gw;
	long unsigned int fnhe_expires;
	struct rtable *fnhe_rth_input;
	struct rtable *fnhe_rth_output;
	long unsigned int fnhe_stamp;
	struct callback_head rcu;
};

struct fib_nh_notifier_info {
	struct fib_notifier_info info;
	struct fib_nh *fib_nh;
};

struct fib_notifier_net {
	struct list_head fib_notifier_ops;
	struct atomic_notifier_head fib_chain;
};

struct fib_notifier_ops {
	int family;
	struct list_head list;
	unsigned int (*fib_seq_read)(const struct net *);
	int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);
	struct module *owner;
	struct callback_head rcu;
};

struct fib_prop {
	int error;
	u8 scope;
};

struct fib_table;

struct fib_result {
	__be32 prefix;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	u32 tclassid;
	dscp_t dscp;
	struct fib_nh_common *nhc;
	struct fib_info *fi;
	struct fib_table *table;
	struct hlist_head *fa_head;
};

struct fib_result_nl {
	__be32 fl_addr;
	u32 fl_mark;
	unsigned char fl_tos;
	unsigned char fl_scope;
	unsigned char tb_id_in;
	unsigned char tb_id;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	int err;
};

struct key_vector;

struct fib_route_iter {
	struct seq_net_private p;
	struct fib_table *main_tb;
	struct key_vector *tnode;
	loff_t pos;
	t_key key;
};

struct fib_rt_info {
	struct fib_info *fi;
	u32 tb_id;
	__be32 dst;
	int dst_len;
	dscp_t dscp;
	u8 type;
	u8 offload: 1;
	u8 trap: 1;
	u8 offload_failed: 1;
	u8 unused: 5;
};

struct fib_rule_hdr {
	__u8 family;
	__u8 dst_len;
	__u8 src_len;
	__u8 tos;
	__u8 table;
	__u8 res1;
	__u8 res2;
	__u8 action;
	__u32 flags;
};

struct fib_rule_notifier_info {
	struct fib_notifier_info info;
	struct fib_rule *rule;
};

struct fib_rule_uid_range {
	__u32 start;
	__u32 end;
};

struct fib_rules_ops {
	int family;
	struct list_head list;
	int rule_size;
	int addr_size;
	int unresolved_rules;
	int nr_goto_rules;
	unsigned int fib_rules_seq;
	int (*action)(struct fib_rule *, struct flowi *, int, struct fib_lookup_arg *);
	bool (*suppress)(struct fib_rule *, int, struct fib_lookup_arg *);
	int (*match)(struct fib_rule *, struct flowi *, int);
	int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *);
	int (*delete)(struct fib_rule *);
	int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **);
	int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *);
	size_t (*nlmsg_payload)(struct fib_rule *);
	void (*flush_cache)(struct fib_rules_ops *);
	int nlgroup;
	struct list_head rules_list;
	struct module *owner;
	struct net *fro_net;
	struct callback_head rcu;
};

struct fib_table {
	struct hlist_node tb_hlist;
	u32 tb_id;
	int tb_num_default;
	struct callback_head rcu;
	long unsigned int *tb_data;
	long unsigned int __data[0];
};

struct fib_trie_iter {
	struct seq_net_private p;
	struct fib_table *tb;
	struct key_vector *tnode;
	unsigned int index;
	unsigned int depth;
};

struct fid {
	union {
		struct {
			u32 ino;
			u32 gen;
			u32 parent_ino;
			u32 parent_gen;
		} i32;
		struct {
			u64 ino;
			u32 gen;
		} __attribute__((packed)) i64;
		struct {
			u32 block;
			u16 partref;
			u16 parent_partref;
			u32 generation;
			u32 parent_block;
			u32 parent_generation;
		} udf;
		struct {
			struct {} __empty_raw;
			__u32 raw[0];
		};
	};
};

struct field_t {
	unsigned char type;
	unsigned char sz;
	unsigned char lb;
	unsigned char ub;
	short unsigned int attr;
	short unsigned int offset;
	const struct field_t *fields;
};

struct fiemap_extent {
	__u64 fe_logical;
	__u64 fe_physical;
	__u64 fe_length;
	__u64 fe_reserved64[2];
	__u32 fe_flags;
	__u32 fe_reserved[3];
};

struct fiemap {
	__u64 fm_start;
	__u64 fm_length;
	__u32 fm_flags;
	__u32 fm_mapped_extents;
	__u32 fm_extent_count;
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0];
};

struct fiemap_cache {
	struct btrfs_fiemap_entry *entries;
	int entries_size;
	int entries_pos;
	u64 next_search_offset;
	unsigned int extents_mapped;
	u64 offset;
	u64 phys;
	u64 len;
	u32 flags;
	bool cached;
};

struct fiemap_extent_info {
	unsigned int fi_flags;
	unsigned int fi_extents_mapped;
	unsigned int fi_extents_max;
	struct fiemap_extent *fi_extents_start;
};

struct file__safe_trusted {
	struct inode *f_inode;
};

struct file_clone_range {
	__s64 src_fd;
	__u64 src_offset;
	__u64 src_length;
	__u64 dest_offset;
};

struct file_dedupe_range_info {
	__s64 dest_fd;
	__u64 dest_offset;
	__u64 bytes_deduped;
	__s32 status;
	__u32 reserved;
};

struct file_dedupe_range {
	__u64 src_offset;
	__u64 src_length;
	__u16 dest_count;
	__u16 reserved1;
	__u32 reserved2;
	struct file_dedupe_range_info info[0];
};

struct file_extent_cluster {
	u64 start;
	u64 end;
	u64 boundary[128];
	unsigned int nr;
	u64 owning_root;
};

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	unsigned char f_handle[0];
};

struct file_lock_core {
	struct file_lock_core *flc_blocker;
	struct list_head flc_list;
	struct hlist_node flc_link;
	struct list_head flc_blocked_requests;
	struct list_head flc_blocked_member;
	fl_owner_t flc_owner;
	unsigned int flc_flags;
	unsigned char flc_type;
	pid_t flc_pid;
	int flc_link_cpu;
	wait_queue_head_t flc_wait;
	struct file *flc_file;
};

struct lease_manager_operations;

struct file_lease {
	struct file_lock_core c;
	struct fasync_struct *fl_fasync;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	const struct lease_manager_operations *fl_lmops;
};

struct nlm_lockowner;

struct nfs_lock_info {
	u32 state;
	struct nlm_lockowner *owner;
	struct list_head list;
};

struct nfs4_lock_state;

struct nfs4_lock_info {
	struct nfs4_lock_state *owner;
};

struct file_lock_operations;

struct lock_manager_operations;

struct file_lock {
	struct file_lock_core c;
	loff_t fl_start;
	loff_t fl_end;
	const struct file_lock_operations *fl_ops;
	const struct lock_manager_operations *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
		struct {
			struct inode *inode;
		} ceph;
	} fl_u;
};

struct file_lock_context {
	spinlock_t flc_lock;
	struct list_head flc_flock;
	struct list_head flc_posix;
	struct list_head flc_lease;
};

struct file_lock_list_struct {
	spinlock_t lock;
	struct hlist_head hlist;
};

struct file_lock_operations {
	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
	void (*fl_release_private)(struct file_lock *);
};

struct file_operations {
	struct module *owner;
	fop_flags_t fop_flags;
	loff_t (*llseek)(struct file *, loff_t, int);
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *, struct io_comp_batch *, unsigned int);
	int (*iterate_shared)(struct file *, struct dir_context *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	int (*open)(struct inode *, struct file *);
	int (*flush)(struct file *, fl_owner_t);
	int (*release)(struct inode *, struct file *);
	int (*fsync)(struct file *, loff_t, loff_t, int);
	int (*fasync)(int, struct file *, int);
	int (*lock)(struct file *, int, struct file_lock *);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*check_flags)(int);
	int (*flock)(struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*splice_eof)(struct file *);
	int (*setlease)(struct file *, int, struct file_lease **, void **);
	long int (*fallocate)(struct file *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file *, struct file *);
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
	int (*uring_cmd)(struct io_uring_cmd *, unsigned int);
	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *, unsigned int);
};

struct tpm_chip;

struct tpm_space;

struct file_priv {
	struct tpm_chip *chip;
	struct tpm_space *space;
	struct mutex buffer_mutex;
	struct timer_list user_read_timer;
	struct work_struct timeout_work;
	struct work_struct async_work;
	wait_queue_head_t async_wait;
	ssize_t response_length;
	bool response_read;
	bool command_enqueued;
	u8 data_buffer[4096];
};

struct file_range {
	const struct path *path;
	loff_t pos;
	size_t count;
};

struct page_counter;

struct file_region {
	struct list_head link;
	long int from;
	long int to;
	struct page_counter *reservation_counter;
	struct cgroup_subsys_state *css;
};

struct fs_context;

struct fs_parameter_spec;

struct file_system_type {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_spec *parameters;
	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
	void (*kill_sb)(struct super_block *);
	struct module *owner;
	struct file_system_type *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key invalidate_lock_key;
	struct lock_class_key i_mutex_dir_key;
};

struct fileattr {
	u32 flags;
	u32 fsx_xflags;
	u32 fsx_extsize;
	u32 fsx_nextents;
	u32 fsx_projid;
	u32 fsx_cowextsize;
	bool flags_valid: 1;
	bool fsx_valid: 1;
};

struct filename {
	const char *name;
	const char *uptr;
	atomic_t refcnt;
	struct audit_names *aname;
	const char iname[0];
};

struct files_stat_struct {
	long unsigned int nr_files;
	long unsigned int nr_free_files;
	long unsigned int max_files;
};

struct files_struct {
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable *fdt;
	struct fdtable fdtab;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t file_lock;
	unsigned int next_fd;
	long unsigned int close_on_exec_init[1];
	long unsigned int open_fds_init[1];
	long unsigned int full_fds_bits_init[1];
	struct file *fd_array[64];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct filter_list {
	struct list_head list;
	struct event_filter *filter;
};

struct filter_parse_error {
	int lasterr;
	int lasterr_pos;
};

struct regex;

struct ftrace_event_field;

struct filter_pred {
	struct regex *regex;
	struct cpumask *mask;
	short unsigned int *ops;
	struct ftrace_event_field *field;
	u64 val;
	u64 val2;
	enum filter_pred_fn fn_num;
	int offset;
	int not;
	int op;
};

struct find_child_walk_data {
	struct acpi_device *adev;
	u64 address;
	int score;
	bool check_sta;
	bool check_children;
};

typedef ssize_t (*dmi_callback)(struct dmi_sysfs_entry *, const struct dmi_header *, void *);

struct find_dmi_data {
	struct dmi_sysfs_entry *entry;
	dmi_callback callback;
	void *private;
	int instance_countdown;
	ssize_t ret;
};

struct find_free_extent_ctl {
	u64 ram_bytes;
	u64 num_bytes;
	u64 min_alloc_size;
	u64 empty_size;
	u64 flags;
	int delalloc;
	u64 search_start;
	u64 empty_cluster;
	struct btrfs_free_cluster *last_ptr;
	bool use_cluster;
	bool have_caching_bg;
	bool orig_have_caching_bg;
	bool for_treelog;
	bool for_data_reloc;
	int index;
	int loop;
	bool retry_uncached;
	int cached;
	u64 max_extent_size;
	u64 total_free_space;
	u64 found_offset;
	u64 hint_byte;
	enum btrfs_extent_allocation_policy policy;
	bool hinted;
	enum btrfs_block_group_size_class size_class;
};

struct kernel_symbol;

struct find_symbol_arg {
	const char *name;
	bool gplok;
	bool warn;
	struct module *owner;
	const u32 *crc;
	const struct kernel_symbol *sym;
	enum mod_license license;
};

struct find_xattr_ctx {
	const char *name;
	int name_len;
	int found_idx;
	char *found_data;
	int found_data_len;
};

struct firmware {
	size_t size;
	const u8 *data;
	void *priv;
};

struct firmware_cache {
	spinlock_t lock;
	struct list_head head;
	int state;
	spinlock_t name_lock;
	struct list_head fw_names;
	struct delayed_work work;
	struct notifier_block pm_notify;
};

struct firmware_map_entry {
	u64 start;
	u64 end;
	const char *type;
	struct list_head list;
	struct kobject kobj;
};

struct firmware_work {
	struct work_struct work;
	struct module *module;
	const char *name;
	struct device *device;
	void *context;
	void (*cont)(const struct firmware *, void *);
	u32 opt_flags;
};

struct mii_bus;

struct fixed_mdio_bus {
	struct mii_bus *mii_bus;
	struct list_head phys;
};

struct fixed_percpu_data {
	char gs_base[40];
	long unsigned int stack_canary;
};

struct fixed_phy_status {
	int link;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
};

struct fixed_phy {
	int addr;
	struct phy_device *phydev;
	struct fixed_phy_status status;
	bool no_carrier;
	int (*link_update)(struct net_device *, struct fixed_phy_status *);
	struct list_head node;
	struct gpio_desc *link_gpiod;
};

struct fixed_range_block {
	int base_msr;
	int ranges;
};

struct fl_flow_mask_range {
	short unsigned int start;
	short unsigned int end;
};

struct fl_flow_mask {
	struct fl_flow_key key;
	struct fl_flow_mask_range range;
	u32 flags;
	struct rhash_head ht_node;
	struct rhashtable ht;
	struct rhashtable_params filter_ht_params;
	struct flow_dissector dissector;
	struct list_head filters;
	struct rcu_work rwork;
	struct list_head list;
	refcount_t refcnt;
};

struct tcf_chain;

struct fl_flow_tmplt {
	struct fl_flow_key dummy_key;
	struct fl_flow_key mask;
	struct flow_dissector dissector;
	struct tcf_chain *chain;
};

struct flex {
	i915_reg_t reg;
	u32 offset;
	u32 value;
};

struct flex_groups {
	atomic64_t free_clusters;
	atomic_t free_inodes;
	atomic_t used_dirs;
};

struct flock {
	short int l_type;
	short int l_whence;
	__kernel_off_t l_start;
	__kernel_off_t l_len;
	__kernel_pid_t l_pid;
};

struct flock64 {
	short int l_type;
	short int l_whence;
	__kernel_loff_t l_start;
	__kernel_loff_t l_len;
	__kernel_pid_t l_pid;
};

typedef void (*action_destr)(void *);

struct psample_group;

struct nf_flowtable;

struct flow_action_cookie;

struct flow_action_entry {
	enum flow_action_id id;
	u32 hw_index;
	long unsigned int cookie;
	u64 miss_cookie;
	enum flow_action_hw_stats hw_stats;
	action_destr destructor;
	void *destructor_priv;
	union {
		u32 chain_index;
		struct net_device *dev;
		struct {
			u16 vid;
			__be16 proto;
			u8 prio;
		} vlan;
		struct {
			unsigned char dst[6];
			unsigned char src[6];
		} vlan_push_eth;
		struct {
			enum flow_action_mangle_base htype;
			u32 offset;
			u32 mask;
			u32 val;
		} mangle;
		struct ip_tunnel_info *tunnel;
		u32 csum_flags;
		u32 mark;
		u16 ptype;
		u16 rx_queue;
		u32 priority;
		struct {
			u32 ctx;
			u32 index;
			u8 vf;
		} queue;
		struct {
			struct psample_group *psample_group;
			u32 rate;
			u32 trunc_size;
			bool truncate;
		} sample;
		struct {
			u32 burst;
			u64 rate_bytes_ps;
			u64 peakrate_bytes_ps;
			u32 avrate;
			u16 overhead;
			u64 burst_pkt;
			u64 rate_pkt_ps;
			u32 mtu;
			struct {
				enum flow_action_id act_id;
				u32 extval;
			} exceed;
			struct {
				enum flow_action_id act_id;
				u32 extval;
			} notexceed;
		} police;
		struct {
			int action;
			u16 zone;
			struct nf_flowtable *flow_table;
		} ct;
		struct {
			long unsigned int cookie;
			u32 mark;
			u32 labels[4];
			bool orig_dir;
		} ct_metadata;
		struct {
			u32 label;
			__be16 proto;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_push;
		struct {
			__be16 proto;
		} mpls_pop;
		struct {
			u32 label;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_mangle;
		struct {
			s32 prio;
			u64 basetime;
			u64 cycletime;
			u64 cycletimeext;
			u32 num_entries;
			struct action_gate_entry *entries;
		} gate;
		struct {
			u16 sid;
		} pppoe;
	};
	struct flow_action_cookie *user_cookie;
};

struct flow_action {
	unsigned int num_entries;
	struct flow_action_entry entries[0];
};

struct flow_action_cookie {
	u32 cookie_len;
	u8 cookie[0];
};

struct flow_block {
	struct list_head cb_list;
};

typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);

struct flow_block_cb;

struct flow_block_indr {
	struct list_head list;
	struct net_device *dev;
	struct Qdisc *sch;
	enum flow_block_binder_type binder_type;
	void *data;
	void *cb_priv;
	void (*cleanup)(struct flow_block_cb *);
};

struct flow_block_cb {
	struct list_head driver_list;
	struct list_head list;
	flow_setup_cb_t *cb;
	void *cb_ident;
	void *cb_priv;
	void (*release)(void *);
	struct flow_block_indr indr;
	unsigned int refcnt;
};

struct flow_block_offload {
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	bool block_shared;
	bool unlocked_driver_cb;
	struct net *net;
	struct flow_block *block;
	struct list_head cb_list;
	struct list_head *driver_block_list;
	struct netlink_ext_ack *extack;
	struct Qdisc *sch;
	struct list_head *cb_list_head;
};

struct flow_cls_common_offload {
	u32 chain_index;
	__be16 protocol;
	u32 prio;
	bool skip_sw;
	struct netlink_ext_ack *extack;
};

struct flow_stats {
	u64 pkts;
	u64 bytes;
	u64 drops;
	u64 lastused;
	enum flow_action_hw_stats used_hw_stats;
	bool used_hw_stats_valid;
};

struct flow_cls_offload {
	struct flow_cls_common_offload common;
	enum flow_cls_command command;
	bool use_act_stats;
	long unsigned int cookie;
	struct flow_rule *rule;
	struct flow_stats stats;
	u32 classid;
};

struct flow_dissector_key {
	enum flow_dissector_key_id key_id;
	size_t offset;
};

struct flow_dissector_key_tipc {
	__be32 key;
};

struct flow_dissector_key_addrs {
	union {
		struct flow_dissector_key_ipv4_addrs v4addrs;
		struct flow_dissector_key_ipv6_addrs v6addrs;
		struct flow_dissector_key_tipc tipckey;
	};
};

struct flow_dissector_key_tags {
	u32 flow_label;
};

struct flow_filter {
	struct list_head list;
	struct tcf_exts exts;
	struct tcf_ematch_tree ematches;
	struct tcf_proto *tp;
	struct timer_list perturb_timer;
	u32 perturb_period;
	u32 handle;
	u32 nkeys;
	u32 keymask;
	u32 mode;
	u32 mask;
	u32 xor;
	u32 rshift;
	u32 addend;
	u32 divisor;
	u32 baseclass;
	u32 hashrnd;
	struct rcu_work rwork;
};

struct flow_head {
	struct list_head filters;
	struct callback_head rcu;
};

struct flow_indir_dev_info {
	void *data;
	struct net_device *dev;
	struct Qdisc *sch;
	enum tc_setup_type type;
	void (*cleanup)(struct flow_block_cb *);
	struct list_head list;
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	struct list_head *cb_list;
};

typedef int flow_indr_block_bind_cb_t(struct net_device *, struct Qdisc *, void *, enum tc_setup_type, void *, void *, void (*)(struct flow_block_cb *));

struct flow_indr_dev {
	struct list_head list;
	flow_indr_block_bind_cb_t *cb;
	void *cb_priv;
	refcount_t refcnt;
};

struct flow_keys {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_tags tags;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_keyid keyid;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_addrs addrs;
	long: 0;
};

struct flow_keys_basic {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
};

struct flow_match {
	struct flow_dissector *dissector;
	void *mask;
	void *key;
};

struct flow_match_arp {
	struct flow_dissector_key_arp *key;
	struct flow_dissector_key_arp *mask;
};

struct flow_match_basic {
	struct flow_dissector_key_basic *key;
	struct flow_dissector_key_basic *mask;
};

struct flow_match_control {
	struct flow_dissector_key_control *key;
	struct flow_dissector_key_control *mask;
};

struct flow_match_ct {
	struct flow_dissector_key_ct *key;
	struct flow_dissector_key_ct *mask;
};

struct flow_match_enc_keyid {
	struct flow_dissector_key_keyid *key;
	struct flow_dissector_key_keyid *mask;
};

struct flow_match_enc_opts {
	struct flow_dissector_key_enc_opts *key;
	struct flow_dissector_key_enc_opts *mask;
};

struct flow_match_eth_addrs {
	struct flow_dissector_key_eth_addrs *key;
	struct flow_dissector_key_eth_addrs *mask;
};

struct flow_match_icmp {
	struct flow_dissector_key_icmp *key;
	struct flow_dissector_key_icmp *mask;
};

struct flow_match_ip {
	struct flow_dissector_key_ip *key;
	struct flow_dissector_key_ip *mask;
};

struct flow_match_ipsec {
	struct flow_dissector_key_ipsec *key;
	struct flow_dissector_key_ipsec *mask;
};

struct flow_match_ipv4_addrs {
	struct flow_dissector_key_ipv4_addrs *key;
	struct flow_dissector_key_ipv4_addrs *mask;
};

struct flow_match_ipv6_addrs {
	struct flow_dissector_key_ipv6_addrs *key;
	struct flow_dissector_key_ipv6_addrs *mask;
};

struct flow_match_l2tpv3 {
	struct flow_dissector_key_l2tpv3 *key;
	struct flow_dissector_key_l2tpv3 *mask;
};

struct flow_match_meta {
	struct flow_dissector_key_meta *key;
	struct flow_dissector_key_meta *mask;
};

struct flow_match_mpls {
	struct flow_dissector_key_mpls *key;
	struct flow_dissector_key_mpls *mask;
};

struct flow_match_ports {
	struct flow_dissector_key_ports *key;
	struct flow_dissector_key_ports *mask;
};

struct flow_match_ports_range {
	struct flow_dissector_key_ports_range *key;
	struct flow_dissector_key_ports_range *mask;
};

struct flow_match_pppoe {
	struct flow_dissector_key_pppoe *key;
	struct flow_dissector_key_pppoe *mask;
};

struct flow_match_tcp {
	struct flow_dissector_key_tcp *key;
	struct flow_dissector_key_tcp *mask;
};

struct flow_match_vlan {
	struct flow_dissector_key_vlan *key;
	struct flow_dissector_key_vlan *mask;
};

struct flow_offload_tuple {
	union {
		struct in_addr src_v4;
		struct in6_addr src_v6;
	};
	union {
		struct in_addr dst_v4;
		struct in6_addr dst_v6;
	};
	struct {
		__be16 src_port;
		__be16 dst_port;
	};
	int iifidx;
	u8 l3proto;
	u8 l4proto;
	struct {
		u16 id;
		__be16 proto;
	} encap[2];
	struct {} __hash;
	u8 dir: 2;
	u8 xmit_type: 3;
	u8 encap_num: 2;
	char: 1;
	u8 in_vlan_ingress: 2;
	u16 mtu;
	union {
		struct {
			struct dst_entry *dst_cache;
			u32 dst_cookie;
		};
		struct {
			u32 ifidx;
			u32 hw_ifidx;
			u8 h_source[6];
			u8 h_dest[6];
		} out;
		struct {
			u32 iifidx;
		} tc;
	};
};

struct flow_offload_tuple_rhash {
	struct rhash_head node;
	struct flow_offload_tuple tuple;
};

struct flow_offload {
	struct flow_offload_tuple_rhash tuplehash[2];
	struct nf_conn *ct;
	long unsigned int flags;
	u16 type;
	u32 timeout;
	struct callback_head callback_head;
};

struct flow_offload_action {
	struct netlink_ext_ack *extack;
	enum offload_act_command command;
	enum flow_action_id id;
	u32 index;
	long unsigned int cookie;
	struct flow_stats stats;
	struct flow_action action;
};

struct flow_offload_work {
	struct list_head list;
	enum flow_cls_command cmd;
	struct nf_flowtable *flowtable;
	struct flow_offload *flow;
	struct work_struct work;
};

struct flow_offload_xdp {
	struct hlist_node hnode;
	long unsigned int net_device_addr;
	struct list_head head;
};

struct flow_offload_xdp_ft {
	struct list_head head;
	struct nf_flowtable *ft;
	struct callback_head rcuhead;
};

struct flow_ports {
	__be16 source;
	__be16 dest;
};

struct flow_rule {
	struct flow_match match;
	struct flow_action action;
};

struct flush_backlogs {
	cpumask_t flush_cpus;
	struct work_struct w[0];
};

struct flush_busy_ctx_data {
	struct blk_mq_hw_ctx *hctx;
	struct list_head *list;
};

struct kyber_hctx_data;

struct flush_kcq_data {
	struct kyber_hctx_data *khd;
	unsigned int sched_domain;
	struct list_head *list;
};

struct flush_tlb_info {
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	u64 new_tlb_gen;
	unsigned int initiating_cpu;
	u8 stride_shift;
	u8 freed_tables;
	u8 trim_cpumask;
};

struct fmt {
	const char *str;
	unsigned char state;
	unsigned char size;
};

struct fname {
	__u32 hash;
	__u32 minor_hash;
	struct rb_node rb_hash;
	struct fname *next;
	__u32 inode;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

struct fnhe_hash_bucket {
	struct fib_nh_exception *chain;
};

struct focaltech_finger_state {
	bool active;
	bool valid;
	unsigned int x;
	unsigned int y;
};

struct focaltech_hw_state {
	struct focaltech_finger_state fingers[5];
	unsigned int width;
	bool pressed;
};

struct focaltech_data {
	unsigned int x_max;
	unsigned int y_max;
	struct focaltech_hw_state state;
};

struct page_pool;

struct page {
	long unsigned int flags;
	union {
		struct {
			union {
				struct list_head lru;
				struct {
					void *__filler;
					unsigned int mlock_count;
				};
				struct list_head buddy_list;
				struct list_head pcp_list;
			};
			struct address_space *mapping;
			union {
				long unsigned int index;
				long unsigned int share;
			};
			long unsigned int private;
		};
		struct {
			long unsigned int pp_magic;
			struct page_pool *pp;
			long unsigned int _pp_mapping_pad;
			long unsigned int dma_addr;
			atomic_long_t pp_ref_count;
		};
		struct {
			long unsigned int compound_head;
		};
		struct {
			struct dev_pagemap *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		unsigned int page_type;
		atomic_t _mapcount;
	};
	atomic_t _refcount;
	long unsigned int memcg_data;
};

struct folio {
	union {
		struct {
			long unsigned int flags;
			union {
				struct list_head lru;
				struct {
					void *__filler;
					unsigned int mlock_count;
				};
			};
			struct address_space *mapping;
			long unsigned int index;
			union {
				void *private;
				swp_entry_t swap;
			};
			atomic_t _mapcount;
			atomic_t _refcount;
			long unsigned int memcg_data;
		};
		struct page page;
	};
	union {
		struct {
			long unsigned int _flags_1;
			long unsigned int _head_1;
			atomic_t _large_mapcount;
			atomic_t _entire_mapcount;
			atomic_t _nr_pages_mapped;
			atomic_t _pincount;
			unsigned int _folio_nr_pages;
		};
		struct page __page_1;
	};
	union {
		struct {
			long unsigned int _flags_2;
			long unsigned int _head_2;
			void *_hugetlb_subpool;
			void *_hugetlb_cgroup;
			void *_hugetlb_cgroup_rsvd;
			void *_hugetlb_hwpoison;
		};
		struct {
			long unsigned int _flags_2a;
			long unsigned int _head_2a;
			struct list_head _deferred_list;
		};
		struct page __page_2;
	};
};

struct folio_iter {
	struct folio *folio;
	size_t offset;
	size_t length;
	struct folio *_next;
	size_t _seg_count;
	int _i;
};

struct folio_queue {
	struct folio_batch vec;
	u8 orders[31];
	struct folio_queue *next;
	struct folio_queue *prev;
	long unsigned int marks;
	long unsigned int marks2;
	long unsigned int marks3;
	unsigned int rreq_id;
	unsigned int debug_id;
};

struct folio_referenced_arg {
	int mapcount;
	int referenced;
	long unsigned int vm_flags;
	struct mem_cgroup *memcg;
};

struct folio_walk {
	struct page *page;
	enum folio_walk_level level;
	union {
		pte_t *ptep;
		pud_t *pudp;
		pmd_t *pmdp;
	};
	union {
		pte_t pte;
		pud_t pud;
		pmd_t pmd;
	};
	struct vm_area_struct *vma;
	spinlock_t *ptl;
};

struct follow_page_context {
	struct dev_pagemap *pgmap;
	unsigned int page_mask;
};

struct follow_pfnmap_args {
	struct vm_area_struct *vma;
	long unsigned int address;
	spinlock_t *lock;
	pte_t *ptep;
	long unsigned int pfn;
	pgprot_t pgprot;
	bool writable;
	bool special;
};

struct font_data {
	unsigned int extra[4];
	const unsigned char data[0];
};

struct font_desc {
	int idx;
	const char *name;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	const void *data;
	int pref;
};

struct memory_block;

typedef int (*walk_memory_blocks_func_t)(struct memory_block *, void *);

struct for_each_memory_block_cb_data {
	walk_memory_blocks_func_t func;
	void *arg;
};

struct inactive_task_frame {
	long unsigned int r15;
	long unsigned int r14;
	long unsigned int r13;
	long unsigned int r12;
	long unsigned int bx;
	long unsigned int bp;
	long unsigned int ret_addr;
};

struct fork_frame {
	struct inactive_task_frame frame;
	struct pt_regs regs;
};

struct fork_proc_event {
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
	__kernel_pid_t child_pid;
	__kernel_pid_t child_tgid;
};

struct format_state___2 {
	unsigned char state;
	unsigned char size;
	unsigned char flags_or_double_size;
	unsigned char base;
};

struct fown_struct {
	struct file *file;
	rwlock_t lock;
	struct pid *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct fregs_state {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
	u32 status;
};

struct fxregs_state {
	u16 cwd;
	u16 swd;
	u16 twd;
	u16 fop;
	union {
		struct {
			u64 rip;
			u64 rdp;
		};
		struct {
			u32 fip;
			u32 fcs;
			u32 foo;
			u32 fos;
		};
	};
	u32 mxcsr;
	u32 mxcsr_mask;
	u32 st_space[32];
	u32 xmm_space[64];
	u32 padding[12];
	union {
		u32 padding1[12];
		u32 sw_reserved[12];
	};
};

struct math_emu_info;

struct swregs_state {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
	u8 ftop;
	u8 changed;
	u8 lookahead;
	u8 no_update;
	u8 rm;
	u8 alimit;
	struct math_emu_info *info;
	u32 entry_eip;
};

struct xstate_header {
	u64 xfeatures;
	u64 xcomp_bv;
	u64 reserved[6];
};

struct xregs_state {
	struct fxregs_state i387;
	struct xstate_header header;
	u8 extended_state_area[0];
};

union fpregs_state {
	struct fregs_state fsave;
	struct fxregs_state fxsave;
	struct swregs_state soft;
	struct xregs_state xsave;
	u8 __padding[4096];
};

struct fprop_global {
	struct percpu_counter events;
	unsigned int period;
	seqcount_t sequence;
};

struct fpstate {
	unsigned int size;
	unsigned int user_size;
	u64 xfeatures;
	u64 user_xfeatures;
	u64 xfd;
	unsigned int is_valloc: 1;
	unsigned int is_guest: 1;
	unsigned int is_confidential: 1;
	unsigned int in_use: 1;
	long: 64;
	long: 64;
	long: 64;
	union fpregs_state regs;
};

struct fpu_state_perm {
	u64 __state_perm;
	unsigned int __state_size;
	unsigned int __user_state_size;
};

struct fpu {
	unsigned int last_cpu;
	long unsigned int avx512_timestamp;
	struct fpstate *fpstate;
	struct fpstate *__task_fpstate;
	struct fpu_state_perm perm;
	struct fpu_state_perm guest_perm;
	struct fpstate __fpstate;
};

struct fpu_guest {
	u64 xfeatures;
	u64 perm;
	u64 xfd_err;
	unsigned int uabi_size;
	struct fpstate *fpstate;
};

struct fpu_state_config {
	unsigned int max_size;
	unsigned int default_size;
	u64 max_features;
	u64 default_features;
	u64 legacy_features;
	u64 independent_features;
};

struct fq_codel_flow {
	struct sk_buff *head;
	struct sk_buff *tail;
	struct list_head flowchain;
	int deficit;
	struct codel_vars cvars;
};

struct fq_codel_sched_data {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct fq_codel_flow *flows;
	u32 *backlogs;
	u32 flows_cnt;
	u32 quantum;
	u32 drop_batch_size;
	u32 memory_limit;
	struct codel_params cparams;
	struct codel_stats cstats;
	u32 memory_usage;
	u32 drop_overmemory;
	u32 drop_overlimit;
	u32 new_flow_count;
	struct list_head new_flows;
	struct list_head old_flows;
};

struct fq_flow {
	struct rb_root t_root;
	struct sk_buff *head;
	union {
		struct sk_buff *tail;
		long unsigned int age;
	};
	union {
		struct rb_node fq_node;
		u64 stat_fastpath_packets;
	};
	struct sock *sk;
	u32 socket_hash;
	int qlen;
	int credit;
	int band;
	struct fq_flow *next;
	struct rb_node rate_node;
	u64 time_next_packet;
};

struct fq_flow_head {
	struct fq_flow *first;
	struct fq_flow *last;
};

struct fq_perband_flows {
	struct fq_flow_head new_flows;
	struct fq_flow_head old_flows;
	int credit;
	int quantum;
};

struct pie_vars {
	psched_time_t qdelay;
	psched_time_t qdelay_old;
	psched_time_t burst_time;
	psched_time_t dq_tstamp;
	u64 prob;
	u64 accu_prob;
	u64 dq_count;
	u32 avg_dq_rate;
	u32 backlog_old;
};

struct fq_pie_flow {
	struct pie_vars vars;
	s32 deficit;
	u32 backlog;
	u32 qlen;
	struct list_head flowchain;
	struct sk_buff *head;
	struct sk_buff *tail;
};

struct pie_params {
	psched_time_t target;
	u32 tupdate;
	u32 limit;
	u32 alpha;
	u32 beta;
	u8 ecn;
	u8 bytemode;
	u8 dq_rate_estimator;
};

struct pie_stats {
	u32 packets_in;
	u32 dropped;
	u32 overlimit;
	u32 ecn_mark;
	u32 maxq;
};

struct fq_pie_sched_data {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct fq_pie_flow *flows;
	struct Qdisc *sch;
	struct list_head old_flows;
	struct list_head new_flows;
	struct pie_params p_params;
	u32 ecn_prob;
	u32 flows_cnt;
	u32 flows_cursor;
	u32 quantum;
	u32 memory_limit;
	u32 new_flow_count;
	u32 memory_usage;
	u32 overmemory;
	struct pie_stats stats;
	struct timer_list adapt_timer;
};

struct fq_sched_data {
	u64 offload_horizon;
	u32 quantum;
	u32 initial_quantum;
	u32 flow_refill_delay;
	u32 flow_plimit;
	long unsigned int flow_max_rate;
	u64 ce_threshold;
	u64 horizon;
	u32 orphan_mask;
	u32 low_rate_threshold;
	struct rb_root *fq_root;
	u8 rate_enable;
	u8 fq_trees_log;
	u8 horizon_drop;
	u8 prio2band[4];
	u32 timer_slack;
	unsigned int band_nr;
	struct fq_perband_flows band_flows[3];
	struct fq_flow internal;
	struct rb_root delayed;
	u64 time_next_delayed_flow;
	long unsigned int unthrottle_latency_ns;
	u32 band_pkt_count[3];
	u32 flows;
	u32 inactive_flows;
	u32 throttled_flows;
	u64 stat_throttled;
	struct qdisc_watchdog watchdog;
	u64 stat_gc_flows;
	u64 stat_band_drops[3];
	u64 stat_ce_mark;
	u64 stat_horizon_drops;
	u64 stat_horizon_caps;
	u64 stat_flows_plimit;
	u64 stat_pkts_too_long;
	u64 stat_allocation_errors;
};

struct fq_skb_cb {
	u64 time_to_send;
	u8 band;
};

struct inet_frags;

struct fqdir {
	long int high_thresh;
	long int low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags *f;
	struct net *net;
	bool dead;
	long: 64;
	long: 64;
	struct rhashtable rhashtable;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t mem;
	struct work_struct destroy_work;
	struct llist_node free_list;
	long: 64;
	long: 64;
};

struct frag_hdr {
	__u8 nexthdr;
	__u8 reserved;
	__be16 frag_off;
	__be32 identification;
};

struct frag_v4_compare_key {
	__be32 saddr;
	__be32 daddr;
	u32 user;
	u32 vif;
	__be16 id;
	u16 protocol;
};

struct frag_v6_compare_key {
	struct in6_addr saddr;
	struct in6_addr daddr;
	u32 user;
	__be32 id;
	u32 iif;
};

struct inet_frag_queue {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff *fragments_tail;
	struct sk_buff *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	u8 tstamp_type;
	__u8 flags;
	u16 max_size;
	struct fqdir *fqdir;
	struct callback_head rcu;
};

struct frag_queue {
	struct inet_frag_queue q;
	int iif;
	__u16 nhoffset;
	u8 ecn;
};

struct freader {
	void *buf;
	u32 buf_sz;
	int err;
	union {
		struct {
			struct file *file;
			struct folio *folio;
			void *addr;
			loff_t folio_off;
			bool may_fault;
		};
		struct {
			const char *data;
			u64 data_sz;
		};
	};
};

struct free_area {
	struct list_head free_list[5];
	long unsigned int nr_free;
};

struct freerunning_counters {
	unsigned int counter_base;
	unsigned int counter_offset;
	unsigned int box_offset;
	unsigned int num_counters;
	unsigned int bits;
	unsigned int *box_offsets;
};

struct freezer {
	struct cgroup_subsys_state css;
	unsigned int state;
};

struct freq_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpufreq_policy *, char *);
	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t);
};

struct muldiv {
	u32 multiplier;
	u32 divider;
};

struct freq_desc {
	bool use_msr_plat;
	struct muldiv muldiv[16];
	u32 freqs[16];
	u32 mask;
};

struct frontbuffer_fence_cb {
	struct dma_fence_cb base;
	struct intel_frontbuffer *front;
};

struct p_log {
	const char *prefix;
	struct fc_log *log;
};

struct fs_context_operations;

struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex uapi_mutex;
	struct file_system_type *fs_type;
	void *fs_private;
	void *sget_key;
	struct dentry *root;
	struct user_namespace *user_ns;
	struct net *net_ns;
	const struct cred *cred;
	struct p_log log;
	const char *source;
	void *security;
	void *s_fs_info;
	unsigned int sb_flags;
	unsigned int sb_flags_mask;
	unsigned int s_iflags;
	enum fs_context_purpose purpose: 8;
	enum fs_context_phase phase: 8;
	bool need_free: 1;
	bool global: 1;
	bool oldapi: 1;
	bool exclusive: 1;
};

struct fs_parameter;

struct fs_context_operations {
	void (*free)(struct fs_context *);
	int (*dup)(struct fs_context *, struct fs_context *);
	int (*parse_param)(struct fs_context *, struct fs_parameter *);
	int (*parse_monolithic)(struct fs_context *, void *);
	int (*get_tree)(struct fs_context *);
	int (*reconfigure)(struct fs_context *);
};

struct fs_disk_quota {
	__s8 d_version;
	__s8 d_flags;
	__u16 d_fieldmask;
	__u32 d_id;
	__u64 d_blk_hardlimit;
	__u64 d_blk_softlimit;
	__u64 d_ino_hardlimit;
	__u64 d_ino_softlimit;
	__u64 d_bcount;
	__u64 d_icount;
	__s32 d_itimer;
	__s32 d_btimer;
	__u16 d_iwarns;
	__u16 d_bwarns;
	__s8 d_itimer_hi;
	__s8 d_btimer_hi;
	__s8 d_rtbtimer_hi;
	__s8 d_padding2;
	__u64 d_rtb_hardlimit;
	__u64 d_rtb_softlimit;
	__u64 d_rtbcount;
	__s32 d_rtbtimer;
	__u16 d_rtbwarns;
	__s16 d_padding3;
	char d_padding4[8];
};

struct fs_error_report {
	int error;
	struct inode *inode;
	struct super_block *sb;
};

struct fs_parameter {
	const char *key;
	enum fs_value_type type: 8;
	union {
		char *string;
		void *blob;
		struct filename *name;
		struct file *file;
	};
	size_t size;
	int dirfd;
};

struct fs_parse_result;

typedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);

struct fs_parameter_spec {
	const char *name;
	fs_param_type *type;
	u8 opt;
	short unsigned int flags;
	const void *data;
};

struct fs_parse_result {
	bool negated;
	union {
		bool boolean;
		int int_32;
		unsigned int uint_32;
		u64 uint_64;
		kuid_t uid;
		kgid_t gid;
	};
};

struct fs_path {
	union {
		struct {
			char *start;
			char *end;
			char *buf;
			short unsigned int buf_len: 15;
			short unsigned int reversed: 1;
			char inline_buf[0];
		};
		char pad[256];
	};
};

struct fs_qfilestat {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
};

typedef struct fs_qfilestat fs_qfilestat_t;

struct fs_qfilestatv {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
	__u32 qfs_pad;
};

struct fs_quota_stat {
	__s8 qs_version;
	__u16 qs_flags;
	__s8 qs_pad;
	fs_qfilestat_t qs_uquota;
	fs_qfilestat_t qs_gquota;
	__u32 qs_incoredqs;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
};

struct fs_quota_statv {
	__s8 qs_version;
	__u8 qs_pad1;
	__u16 qs_flags;
	__u32 qs_incoredqs;
	struct fs_qfilestatv qs_uquota;
	struct fs_qfilestatv qs_gquota;
	struct fs_qfilestatv qs_pquota;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
	__u16 qs_rtbwarnlimit;
	__u16 qs_pad3;
	__u32 qs_pad4;
	__u64 qs_pad2[7];
};

struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_spinlock_t seq;
	int umask;
	int in_exec;
	struct path root;
	struct path pwd;
};

struct fs_sysfs_path {
	__u8 len;
	__u8 name[128];
};

struct fscache_cache_ops;

struct fscache_cache {
	const struct fscache_cache_ops *ops;
	struct list_head cache_link;
	void *cache_priv;
	refcount_t ref;
	atomic_t n_volumes;
	atomic_t n_accesses;
	atomic_t object_count;
	unsigned int debug_id;
	enum fscache_cache_state state;
	char *name;
};

struct fscache_volume;

struct fscache_cookie;

struct netfs_cache_resources;

struct fscache_cache_ops {
	const char *name;
	void (*acquire_volume)(struct fscache_volume *);
	void (*free_volume)(struct fscache_volume *);
	bool (*lookup_cookie)(struct fscache_cookie *);
	void (*withdraw_cookie)(struct fscache_cookie *);
	void (*resize_cookie)(struct netfs_cache_resources *, loff_t);
	bool (*invalidate_cookie)(struct fscache_cookie *);
	bool (*begin_operation)(struct netfs_cache_resources *, enum fscache_want_state);
	void (*prepare_to_write)(struct fscache_cookie *);
};

struct fscache_cookie {
	refcount_t ref;
	atomic_t n_active;
	atomic_t n_accesses;
	unsigned int debug_id;
	unsigned int inval_counter;
	spinlock_t lock;
	struct fscache_volume *volume;
	void *cache_priv;
	struct hlist_bl_node hash_link;
	struct list_head proc_link;
	struct list_head commit_link;
	struct work_struct work;
	loff_t object_size;
	long unsigned int unused_at;
	long unsigned int flags;
	enum fscache_cookie_state state;
	u8 advice;
	u8 key_len;
	u8 aux_len;
	u32 key_hash;
	union {
		void *key;
		u8 inline_key[16];
	};
	union {
		void *aux;
		u8 inline_aux[8];
	};
};

struct fscache_volume {
	refcount_t ref;
	atomic_t n_cookies;
	atomic_t n_accesses;
	unsigned int debug_id;
	unsigned int key_hash;
	u8 *key;
	struct list_head proc_link;
	struct hlist_bl_node hash_link;
	struct work_struct work;
	struct fscache_cache *cache;
	void *cache_priv;
	spinlock_t lock;
	long unsigned int flags;
	u8 coherency_len;
	u8 coherency[0];
};

struct fsl_mc_obj_desc {
	char type[16];
	int id;
	u16 vendor;
	u16 ver_major;
	u16 ver_minor;
	u8 irq_count;
	u8 region_count;
	u32 state;
	char label[16];
	u16 flags;
};

struct fsl_mc_io;

struct fsl_mc_device_irq;

struct fsl_mc_resource;

struct fsl_mc_device {
	struct device dev;
	u64 dma_mask;
	u16 flags;
	u32 icid;
	u16 mc_handle;
	struct fsl_mc_io *mc_io;
	struct fsl_mc_obj_desc obj_desc;
	struct resource *regions;
	struct fsl_mc_device_irq **irqs;
	struct fsl_mc_resource *resource;
	struct device_link *consumer_link;
	const char *driver_override;
};

struct fsl_mc_resource_pool;

struct fsl_mc_resource {
	enum fsl_mc_pool_type type;
	s32 id;
	void *data;
	struct fsl_mc_resource_pool *parent_pool;
	struct list_head node;
};

struct fsl_mc_device_irq {
	unsigned int virq;
	struct fsl_mc_device *mc_dev;
	u8 dev_irq_index;
	struct fsl_mc_resource resource;
};

struct fsl_mc_io {
	struct device *dev;
	u16 flags;
	u32 portal_size;
	phys_addr_t portal_phys_addr;
	void *portal_virt_addr;
	struct fsl_mc_device *dpmcp_dev;
	union {
		struct mutex mutex;
		raw_spinlock_t spinlock;
	};
};

struct fsmap {
	__u32 fmr_device;
	__u32 fmr_flags;
	__u64 fmr_physical;
	__u64 fmr_owner;
	__u64 fmr_offset;
	__u64 fmr_length;
	__u64 fmr_reserved[3];
};

struct fsmap_head {
	__u32 fmh_iflags;
	__u32 fmh_oflags;
	__u32 fmh_count;
	__u32 fmh_entries;
	__u64 fmh_reserved[6];
	struct fsmap fmh_keys[2];
	struct fsmap fmh_recs[0];
};

struct fsnotify_event {
	struct list_head list;
};

struct inotify_group_private_data {
	spinlock_t idr_lock;
	struct idr idr;
	struct ucounts *ucounts;
};

struct fsnotify_ops;

struct fsnotify_group {
	const struct fsnotify_ops *ops;
	refcount_t refcnt;
	spinlock_t notification_lock;
	struct list_head notification_list;
	wait_queue_head_t notification_waitq;
	unsigned int q_len;
	unsigned int max_events;
	enum fsnotify_group_prio priority;
	bool shutdown;
	int flags;
	unsigned int owner_flags;
	struct mutex mark_mutex;
	atomic_t user_waits;
	struct list_head marks_list;
	struct fasync_struct *fsn_fa;
	struct fsnotify_event *overflow_event;
	struct mem_cgroup *memcg;
	union {
		void *private;
		struct inotify_group_private_data inotify_data;
	};
};

struct fsnotify_iter_info {
	struct fsnotify_mark *marks[5];
	struct fsnotify_group *current_group;
	unsigned int report_mask;
	int srcu_idx;
};

typedef struct fsnotify_mark_connector *fsnotify_connp_t;

struct fsnotify_mark_connector {
	spinlock_t lock;
	unsigned char type;
	unsigned char prio;
	short unsigned int flags;
	union {
		void *obj;
		struct fsnotify_mark_connector *destroy_next;
	};
	struct hlist_head list;
};

struct fsnotify_ops {
	int (*handle_event)(struct fsnotify_group *, u32, const void *, int, struct inode *, const struct qstr *, u32, struct fsnotify_iter_info *);
	int (*handle_inode_event)(struct fsnotify_mark *, u32, struct inode *, struct inode *, const struct qstr *, u32);
	void (*free_group_priv)(struct fsnotify_group *);
	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
	void (*free_event)(struct fsnotify_group *, struct fsnotify_event *);
	void (*free_mark)(struct fsnotify_mark *);
};

struct fsnotify_sb_info {
	struct fsnotify_mark_connector *sb_marks;
	atomic_long_t watched_objects[3];
};

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

struct fsuuid {
	__u32 fsu_len;
	__u32 fsu_flags;
	__u8 fsu_uuid[0];
};

struct fsuuid2 {
	__u8 len;
	__u8 uuid[16];
};

struct fsverity_descriptor {
	__u8 version;
	__u8 hash_algorithm;
	__u8 log_blocksize;
	__u8 salt_size;
	__le32 sig_size;
	__le64 data_size;
	__u8 root_hash[64];
	__u8 salt[32];
	__u8 __reserved[144];
	__u8 signature[0];
};

struct fsverity_digest {
	__u16 digest_algorithm;
	__u16 digest_size;
	__u8 digest[0];
};

struct fsverity_enable_arg {
	__u32 version;
	__u32 hash_algorithm;
	__u32 block_size;
	__u32 salt_size;
	__u64 salt_ptr;
	__u32 sig_size;
	__u32 __reserved1;
	__u64 sig_ptr;
	__u64 __reserved2[11];
};

struct fsxattr {
	__u32 fsx_xflags;
	__u32 fsx_extsize;
	__u32 fsx_nextents;
	__u32 fsx_projid;
	__u32 fsx_cowextsize;
	unsigned char fsx_pad[8];
};

struct ftp_search {
	const char *pattern;
	size_t plen;
	char skip;
	char term;
	enum nf_ct_ftp_type ftptype;
	int (*getnum)(const char *, size_t, struct nf_conntrack_man *, char, unsigned int *);
};

struct trace_seq {
	char buffer[8156];
	struct seq_buf seq;
	size_t readpos;
	int full;
};

struct tracer;

struct ring_buffer_iter;

struct trace_iterator {
	struct trace_array *tr;
	struct tracer *trace;
	struct array_buffer *array_buffer;
	void *private;
	int cpu_file;
	struct mutex mutex;
	struct ring_buffer_iter **buffer_iter;
	long unsigned int iter_flags;
	void *temp;
	unsigned int temp_size;
	char *fmt;
	unsigned int fmt_size;
	atomic_t wait_index;
	struct trace_seq tmp_seq;
	cpumask_var_t started;
	bool closed;
	bool snapshot;
	struct trace_seq seq;
	struct trace_entry *ent;
	long unsigned int lost_events;
	int leftover;
	int ent_size;
	int cpu;
	u64 ts;
	loff_t pos;
	long int idx;
};

struct ftrace_buffer_info {
	struct trace_iterator iter;
	void *spare;
	unsigned int spare_cpu;
	unsigned int spare_size;
	unsigned int read;
};

struct ftrace_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
};

struct ftrace_event_field {
	struct list_head link;
	const char *name;
	const char *type;
	int filter_type;
	int offset;
	int size;
	unsigned int is_signed: 1;
	unsigned int needs_test: 1;
	int len;
};

struct ftrace_stack {
	long unsigned int calls[1024];
};

struct ftrace_stacks {
	struct ftrace_stack stacks[4];
};

struct func_repeats_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
	u16 count;
	u16 top_delta_ts;
	u32 bottom_delta_ts;
};

struct fuse_access_in {
	uint32_t mask;
	uint32_t padding;
};

struct fuse_attr {
	uint64_t ino;
	uint64_t size;
	uint64_t blocks;
	uint64_t atime;
	uint64_t mtime;
	uint64_t ctime;
	uint32_t atimensec;
	uint32_t mtimensec;
	uint32_t ctimensec;
	uint32_t mode;
	uint32_t nlink;
	uint32_t uid;
	uint32_t gid;
	uint32_t rdev;
	uint32_t blksize;
	uint32_t flags;
};

struct fuse_attr_out {
	uint64_t attr_valid;
	uint32_t attr_valid_nsec;
	uint32_t dummy;
	struct fuse_attr attr;
};

struct fuse_backing {
	struct file *file;
	struct cred *cred;
	refcount_t count;
	struct callback_head rcu;
};

struct fuse_backing_map {
	int32_t fd;
	uint32_t flags;
	uint64_t padding;
};

struct fuse_batch_forget_in {
	uint32_t count;
	uint32_t dummy;
};

struct fuse_bmap_in {
	uint64_t block;
	uint32_t blocksize;
	uint32_t padding;
};

struct fuse_bmap_out {
	uint64_t block;
};

struct fuse_copy_file_range_in {
	uint64_t fh_in;
	uint64_t off_in;
	uint64_t nodeid_out;
	uint64_t fh_out;
	uint64_t off_out;
	uint64_t len;
	uint64_t flags;
};

struct fuse_req;

struct pipe_buffer;

struct fuse_copy_state {
	int write;
	struct fuse_req *req;
	struct iov_iter *iter;
	struct pipe_buffer *pipebufs;
	struct pipe_buffer *currbuf;
	struct pipe_inode_info *pipe;
	long unsigned int nr_segs;
	struct page *pg;
	unsigned int len;
	unsigned int offset;
	unsigned int move_pages: 1;
	unsigned int is_uring: 1;
	struct {
		unsigned int copied_sz;
	} ring;
};

struct fuse_create_in {
	uint32_t flags;
	uint32_t mode;
	uint32_t umask;
	uint32_t open_flags;
};

struct fuse_pqueue {
	unsigned int connected;
	spinlock_t lock;
	struct list_head *processing;
	struct list_head io;
};

struct fuse_dev {
	struct fuse_conn *fc;
	struct fuse_pqueue pq;
	struct list_head entry;
};

struct fuse_dirent {
	uint64_t ino;
	uint64_t off;
	uint32_t namelen;
	uint32_t type;
	char name[0];
};

struct fuse_entry_out {
	uint64_t nodeid;
	uint64_t generation;
	uint64_t entry_valid;
	uint64_t attr_valid;
	uint32_t entry_valid_nsec;
	uint32_t attr_valid_nsec;
	struct fuse_attr attr;
};

struct fuse_direntplus {
	struct fuse_entry_out entry_out;
	struct fuse_dirent dirent;
};

struct fuse_ext_header {
	uint32_t size;
	uint32_t type;
};

struct fuse_fallocate_in {
	uint64_t fh;
	uint64_t offset;
	uint64_t length;
	uint32_t mode;
	uint32_t padding;
};

union fuse_file_args;

struct fuse_file {
	struct fuse_mount *fm;
	union fuse_file_args *args;
	u64 kh;
	u64 fh;
	u64 nodeid;
	refcount_t count;
	u32 open_flags;
	struct list_head write_entry;
	struct {
		loff_t pos;
		loff_t cache_off;
		u64 version;
	} readdir;
	struct rb_node polled_node;
	wait_queue_head_t poll_wait;
	enum {
		IOM_NONE = 0,
		IOM_CACHED = 1,
		IOM_UNCACHED = 2,
	} iomode;
	struct file *passthrough;
	const struct cred *cred;
	bool flock: 1;
};

struct fuse_open_out {
	uint64_t fh;
	uint32_t open_flags;
	int32_t backing_id;
};

struct fuse_release_in {
	uint64_t fh;
	uint32_t flags;
	uint32_t release_flags;
	uint64_t lock_owner;
};

struct fuse_release_args {
	struct fuse_args args;
	struct fuse_release_in inarg;
	struct inode *inode;
};

union fuse_file_args {
	struct fuse_open_out open_outarg;
	struct fuse_release_args release_args;
};

struct fuse_file_lock {
	uint64_t start;
	uint64_t end;
	uint32_t type;
	uint32_t pid;
};

struct fuse_writepage_args;

struct fuse_fill_wb_data {
	struct fuse_writepage_args *wpa;
	struct fuse_file *ff;
	struct inode *inode;
	struct folio **orig_folios;
	unsigned int max_folios;
};

struct fuse_flush_in {
	uint64_t fh;
	uint32_t unused;
	uint32_t padding;
	uint64_t lock_owner;
};

struct fuse_forget_in {
	uint64_t nlookup;
};

struct fuse_fs_context {
	int fd;
	struct file *file;
	unsigned int rootmode;
	kuid_t user_id;
	kgid_t group_id;
	bool is_bdev: 1;
	bool fd_present: 1;
	bool rootmode_present: 1;
	bool user_id_present: 1;
	bool group_id_present: 1;
	bool default_permissions: 1;
	bool allow_other: 1;
	bool destroy: 1;
	bool no_control: 1;
	bool no_force_umount: 1;
	bool legacy_opts_show: 1;
	enum fuse_dax_mode dax_mode;
	unsigned int max_read;
	unsigned int blksize;
	const char *subtype;
	struct dax_device *dax_dev;
	void **fudptr;
};

struct fuse_fsync_in {
	uint64_t fh;
	uint32_t fsync_flags;
	uint32_t padding;
};

struct fuse_getattr_in {
	uint32_t getattr_flags;
	uint32_t dummy;
	uint64_t fh;
};

struct fuse_getxattr_in {
	uint32_t size;
	uint32_t padding;
};

struct fuse_getxattr_out {
	uint32_t size;
	uint32_t padding;
};

struct fuse_in_header {
	uint32_t len;
	uint32_t opcode;
	uint64_t unique;
	uint64_t nodeid;
	uint32_t uid;
	uint32_t gid;
	uint32_t pid;
	uint16_t total_extlen;
	uint16_t padding;
};

struct fuse_init_in {
	uint32_t major;
	uint32_t minor;
	uint32_t max_readahead;
	uint32_t flags;
	uint32_t flags2;
	uint32_t unused[11];
};

struct fuse_init_out {
	uint32_t major;
	uint32_t minor;
	uint32_t max_readahead;
	uint32_t flags;
	uint16_t max_background;
	uint16_t congestion_threshold;
	uint32_t max_write;
	uint32_t time_gran;
	uint16_t max_pages;
	uint16_t map_alignment;
	uint32_t flags2;
	uint32_t max_stack_depth;
	uint32_t unused[6];
};

struct fuse_init_args {
	struct fuse_args args;
	struct fuse_init_in in;
	struct fuse_init_out out;
};

struct fuse_submount_lookup;

struct fuse_inode {
	struct inode inode;
	u64 nodeid;
	u64 nlookup;
	struct fuse_forget_link *forget;
	u64 i_time;
	u32 inval_mask;
	umode_t orig_i_mode;
	struct timespec64 i_btime;
	u64 orig_ino;
	u64 attr_version;
	union {
		struct {
			struct list_head write_files;
			struct list_head queued_writes;
			int writectr;
			int iocachectr;
			wait_queue_head_t page_waitq;
			wait_queue_head_t direct_io_waitq;
			struct rb_root writepages;
		};
		struct {
			bool cached;
			loff_t size;
			loff_t pos;
			u64 version;
			struct timespec64 mtime;
			u64 iversion;
			spinlock_t lock;
		} rdc;
	};
	long unsigned int state;
	struct mutex mutex;
	spinlock_t lock;
	struct fuse_submount_lookup *submount_lookup;
	struct fuse_backing *fb;
};

struct fuse_inode_handle {
	u64 nodeid;
	u32 generation;
};

struct fuse_interrupt_in {
	uint64_t unique;
};

struct fuse_read_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t size;
	uint32_t read_flags;
	uint64_t lock_owner;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_write_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t size;
	uint32_t write_flags;
	uint64_t lock_owner;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_write_out {
	uint32_t size;
	uint32_t padding;
};

struct fuse_io_priv;

struct fuse_io_args {
	union {
		struct {
			struct fuse_read_in in;
			u64 attr_ver;
		} read;
		struct {
			struct fuse_write_in in;
			struct fuse_write_out out;
			bool folio_locked;
		} write;
	};
	struct fuse_args_pages ap;
	struct fuse_io_priv *io;
	struct fuse_file *ff;
};

struct fuse_io_priv {
	struct kref refcnt;
	int async;
	spinlock_t lock;
	unsigned int reqs;
	ssize_t bytes;
	size_t size;
	__u64 offset;
	bool write;
	bool should_dirty;
	int err;
	struct kiocb *iocb;
	struct completion *done;
	bool blocking;
};

struct fuse_ioctl_in {
	uint64_t fh;
	uint32_t flags;
	uint32_t cmd;
	uint64_t arg;
	uint32_t in_size;
	uint32_t out_size;
};

struct fuse_ioctl_iovec {
	uint64_t base;
	uint64_t len;
};

struct fuse_ioctl_out {
	int32_t result;
	uint32_t flags;
	uint32_t in_iovs;
	uint32_t out_iovs;
};

struct fuse_iqueue_ops {
	void (*send_forget)(struct fuse_iqueue *, struct fuse_forget_link *);
	void (*send_interrupt)(struct fuse_iqueue *, struct fuse_req *);
	void (*send_req)(struct fuse_iqueue *, struct fuse_req *);
	void (*release)(struct fuse_iqueue *);
};

struct fuse_kstatfs {
	uint64_t blocks;
	uint64_t bfree;
	uint64_t bavail;
	uint64_t files;
	uint64_t ffree;
	uint32_t bsize;
	uint32_t namelen;
	uint32_t frsize;
	uint32_t padding;
	uint32_t spare[6];
};

struct fuse_link_in {
	uint64_t oldnodeid;
};

struct fuse_lk_in {
	uint64_t fh;
	uint64_t owner;
	struct fuse_file_lock lk;
	uint32_t lk_flags;
	uint32_t padding;
};

struct fuse_lk_out {
	struct fuse_file_lock lk;
};

struct fuse_lseek_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t whence;
	uint32_t padding;
};

struct fuse_lseek_out {
	uint64_t offset;
};

struct fuse_mkdir_in {
	uint32_t mode;
	uint32_t umask;
};

struct fuse_mknod_in {
	uint32_t mode;
	uint32_t rdev;
	uint32_t umask;
	uint32_t padding;
};

struct fuse_notify_delete_out {
	uint64_t parent;
	uint64_t child;
	uint32_t namelen;
	uint32_t padding;
};

struct fuse_notify_inval_entry_out {
	uint64_t parent;
	uint32_t namelen;
	uint32_t flags;
};

struct fuse_notify_inval_inode_out {
	uint64_t ino;
	int64_t off;
	int64_t len;
};

struct fuse_notify_poll_wakeup_out {
	uint64_t kh;
};

struct fuse_notify_retrieve_in {
	uint64_t dummy1;
	uint64_t offset;
	uint32_t size;
	uint32_t dummy2;
	uint64_t dummy3;
	uint64_t dummy4;
};

struct fuse_notify_retrieve_out {
	uint64_t notify_unique;
	uint64_t nodeid;
	uint64_t offset;
	uint32_t size;
	uint32_t padding;
};

struct fuse_notify_store_out {
	uint64_t nodeid;
	uint64_t offset;
	uint32_t size;
	uint32_t padding;
};

struct fuse_open_in {
	uint32_t flags;
	uint32_t open_flags;
};

struct fuse_out_header {
	uint32_t len;
	int32_t error;
	uint64_t unique;
};

struct fuse_poll_in {
	uint64_t fh;
	uint64_t kh;
	uint32_t flags;
	uint32_t events;
};

struct fuse_poll_out {
	uint32_t revents;
	uint32_t padding;
};

struct fuse_rename2_in {
	uint64_t newdir;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_req {
	struct list_head list;
	struct list_head intr_entry;
	struct fuse_args *args;
	refcount_t count;
	long unsigned int flags;
	struct {
		struct fuse_in_header h;
	} in;
	struct {
		struct fuse_out_header h;
	} out;
	wait_queue_head_t waitq;
	void *argbuf;
	struct fuse_mount *fm;
	void *ring_entry;
	void *ring_queue;
};

struct fuse_retrieve_args {
	struct fuse_args_pages ap;
	struct fuse_notify_retrieve_in inarg;
};

struct fuse_ring_queue;

struct fuse_ring {
	struct fuse_conn *fc;
	size_t nr_queues;
	size_t max_payload_sz;
	struct fuse_ring_queue **queues;
	unsigned int stop_debug_log: 1;
	wait_queue_head_t stop_waitq;
	struct delayed_work async_teardown_work;
	long unsigned int teardown_time;
	atomic_t queue_refs;
	bool ready;
};

struct fuse_uring_req_header;

struct fuse_ring_ent {
	struct fuse_uring_req_header *headers;
	void *payload;
	struct fuse_ring_queue *queue;
	struct io_uring_cmd *cmd;
	struct list_head list;
	enum fuse_ring_req_state state;
	struct fuse_req *fuse_req;
};

struct fuse_ring_queue {
	struct fuse_ring *ring;
	unsigned int qid;
	spinlock_t lock;
	struct list_head ent_avail_queue;
	struct list_head ent_w_req_queue;
	struct list_head ent_commit_queue;
	struct list_head ent_in_userspace;
	struct list_head ent_released;
	struct list_head fuse_req_queue;
	struct list_head fuse_req_bg_queue;
	struct fuse_pqueue fpq;
	unsigned int active_background;
	bool stopped;
};

struct fuse_secctx {
	uint32_t size;
	uint32_t padding;
};

struct fuse_secctx_header {
	uint32_t size;
	uint32_t nr_secctx;
};

struct fuse_setattr_in {
	uint32_t valid;
	uint32_t padding;
	uint64_t fh;
	uint64_t size;
	uint64_t lock_owner;
	uint64_t atime;
	uint64_t mtime;
	uint64_t ctime;
	uint32_t atimensec;
	uint32_t mtimensec;
	uint32_t ctimensec;
	uint32_t mode;
	uint32_t unused4;
	uint32_t uid;
	uint32_t gid;
	uint32_t unused5;
};

struct fuse_setxattr_in {
	uint32_t size;
	uint32_t flags;
	uint32_t setxattr_flags;
	uint32_t padding;
};

struct fuse_statfs_out {
	struct fuse_kstatfs st;
};

struct fuse_sx_time {
	int64_t tv_sec;
	uint32_t tv_nsec;
	int32_t __reserved;
};

struct fuse_statx {
	uint32_t mask;
	uint32_t blksize;
	uint64_t attributes;
	uint32_t nlink;
	uint32_t uid;
	uint32_t gid;
	uint16_t mode;
	uint16_t __spare0[1];
	uint64_t ino;
	uint64_t size;
	uint64_t blocks;
	uint64_t attributes_mask;
	struct fuse_sx_time atime;
	struct fuse_sx_time btime;
	struct fuse_sx_time ctime;
	struct fuse_sx_time mtime;
	uint32_t rdev_major;
	uint32_t rdev_minor;
	uint32_t dev_major;
	uint32_t dev_minor;
	uint64_t __spare2[14];
};

struct fuse_statx_in {
	uint32_t getattr_flags;
	uint32_t reserved;
	uint64_t fh;
	uint32_t sx_flags;
	uint32_t sx_mask;
};

struct fuse_statx_out {
	uint64_t attr_valid;
	uint32_t attr_valid_nsec;
	uint32_t flags;
	uint64_t spare[2];
	struct fuse_statx stat;
};

struct fuse_submount_lookup {
	refcount_t count;
	u64 nodeid;
	struct fuse_forget_link *forget;
};

struct fuse_supp_groups {
	uint32_t nr_groups;
	uint32_t groups[0];
};

struct fuse_sync_bucket {
	atomic_t count;
	wait_queue_head_t waitq;
	struct callback_head rcu;
};

struct fuse_syncfs_in {
	uint64_t padding;
};

struct fuse_uring_cmd_req {
	uint64_t flags;
	uint64_t commit_id;
	uint16_t qid;
	uint8_t padding[6];
};

struct fuse_uring_ent_in_out {
	uint64_t flags;
	uint64_t commit_id;
	uint32_t payload_sz;
	uint32_t padding;
	uint64_t reserved;
};

struct fuse_uring_pdu {
	struct fuse_ring_ent *ent;
};

struct fuse_uring_req_header {
	char in_out[128];
	char op_in[128];
	struct fuse_uring_ent_in_out ring_ent_in_out;
};

struct fuse_writepage_args {
	struct fuse_io_args ia;
	struct rb_node writepages_entry;
	struct list_head queue_entry;
	struct fuse_writepage_args *next;
	struct inode *inode;
	struct fuse_sync_bucket *bucket;
};

struct futex_hash_bucket {
	atomic_t waiters;
	spinlock_t lock;
	struct plist_head chain;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

union futex_key {
	struct {
		u64 i_seq;
		long unsigned int pgoff;
		unsigned int offset;
	} shared;
	struct {
		union {
			struct mm_struct *mm;
			u64 __tmp;
		};
		long unsigned int address;
		unsigned int offset;
	} private;
	struct {
		u64 ptr;
		long unsigned int word;
		unsigned int offset;
	} both;
};

struct futex_pi_state {
	struct list_head list;
	struct rt_mutex_base pi_mutex;
	struct task_struct *owner;
	refcount_t refcount;
	union futex_key key;
};

struct wake_q_head;

struct futex_q;

typedef void futex_wake_fn(struct wake_q_head *, struct futex_q *);

struct rt_mutex_waiter;

struct futex_q {
	struct plist_node list;
	struct task_struct *task;
	spinlock_t *lock_ptr;
	futex_wake_fn *wake;
	void *wake_data;
	union futex_key key;
	struct futex_pi_state *pi_state;
	struct rt_mutex_waiter *rt_waiter;
	union futex_key *requeue_pi_key;
	u32 bitset;
	atomic_t requeue_state;
};

struct futex_waitv {
	__u64 val;
	__u64 uaddr;
	__u32 flags;
	__u32 __reserved;
};

struct futex_vector {
	struct futex_waitv w;
	struct futex_q q;
};

struct uc_fw_platform_requirement;

struct fw_blobs_by_type {
	const struct uc_fw_platform_requirement *blobs;
	u32 count;
};

struct fw_cache_entry {
	struct list_head list;
	const char *name;
};

struct fw_filter {
	struct fw_filter *next;
	u32 id;
	struct tcf_result res;
	int ifindex;
	struct tcf_exts exts;
	struct tcf_proto *tp;
	struct rcu_work rwork;
};

struct fw_head {
	u32 mask;
	struct fw_filter *ht[256];
	struct callback_head rcu;
};

struct fw_name_devm {
	long unsigned int magic;
	const char *name;
};

struct fw_state {
	struct completion completion;
	enum fw_status status;
};

struct fw_priv {
	struct kref ref;
	struct list_head list;
	struct firmware_cache *fwc;
	struct fw_state fw_st;
	void *data;
	size_t size;
	size_t allocated_size;
	size_t offset;
	u32 opt_flags;
	const char *fw_name;
};

union fw_table_header {
	struct acpi_table_header acpi;
	struct acpi_table_cdat cdat;
};

union fwnet_hwaddr {
	u8 u[16];
	struct {
		__be64 uniq_id;
		u8 max_rec;
		u8 sspd;
		u8 fifo[6];
	} uc;
};

struct fwnode_endpoint {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle *local_fwnode;
};

struct fwnode_link {
	struct fwnode_handle *supplier;
	struct list_head s_hook;
	struct fwnode_handle *consumer;
	struct list_head c_hook;
	u8 flags;
};

struct fwnode_reference_args;

struct fwnode_operations {
	struct fwnode_handle * (*get)(struct fwnode_handle *);
	void (*put)(struct fwnode_handle *);
	bool (*device_is_available)(const struct fwnode_handle *);
	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
	bool (*device_dma_supported)(const struct fwnode_handle *);
	enum dev_dma_attr (*device_get_dma_attr)(const struct fwnode_handle *);
	bool (*property_present)(const struct fwnode_handle *, const char *);
	bool (*property_read_bool)(const struct fwnode_handle *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
	const char * (*get_name)(const struct fwnode_handle *);
	const char * (*get_name_prefix)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
	void * (*iomap)(struct fwnode_handle *, int);
	int (*irq_get)(const struct fwnode_handle *, unsigned int);
	int (*add_links)(struct fwnode_handle *);
};

struct fwnode_reference_args {
	struct fwnode_handle *fwnode;
	unsigned int nargs;
	u64 args[16];
};

struct g4x_wm_state {
	struct g4x_pipe_wm wm;
	struct g4x_sr_wm sr;
	struct g4x_sr_wm hpll;
	bool cxsr;
	bool hpll_en;
	bool fbc_en;
};

struct idt_bits {
	u16 ist: 3;
	u16 zero: 5;
	u16 type: 5;
	u16 dpl: 2;
	u16 p: 1;
};

struct gate_struct {
	u16 offset_low;
	u16 segment;
	struct idt_bits bits;
	u16 offset_middle;
	u32 offset_high;
	u32 reserved;
};

typedef struct gate_struct gate_desc;

struct gatt_mask {
	long unsigned int mask;
	u32 type;
};

struct gcm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn ghash;
};

struct gcr3_tbl_info {
	u64 *gcr3_tbl;
	int glx;
	u32 pasid_cnt;
	u16 domid;
};

struct gcry_mpi {
	int alloced;
	int nlimbs;
	int nbits;
	int sign;
	unsigned int flags;
	mpi_limb_t *d;
};

struct gdt_page {
	struct desc_struct gdt[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct i915_vm_pt_stash;

struct i915_vma_resource;

struct i915_vma_ops {
	void (*bind_vma)(struct i915_address_space *, struct i915_vm_pt_stash *, struct i915_vma_resource *, unsigned int, u32);
	void (*unbind_vma)(struct i915_address_space *, struct i915_vma_resource *);
};

struct i915_page_table;

struct i915_address_space {
	struct kref ref;
	struct work_struct release_work;
	struct drm_mm mm;
	struct {
		struct drm_i915_gem_object *obj;
		struct i915_vma *vma;
	} rsvd;
	struct intel_gt *gt;
	struct drm_i915_private *i915;
	struct drm_i915_file_private *fpriv;
	struct device *dma;
	u64 total;
	u64 reserved;
	u64 min_alignment[4];
	unsigned int bind_async_flags;
	struct mutex mutex;
	struct kref resv_ref;
	struct dma_resv _resv;
	struct drm_i915_gem_object *scratch[4];
	struct list_head bound_list;
	struct list_head unbound_list;
	bool is_ggtt: 1;
	bool is_dpt: 1;
	bool has_read_only: 1;
	bool skip_pte_rewrite: 1;
	u8 top;
	u8 pd_shift;
	u8 scratch_order;
	long unsigned int lmem_pt_obj_flags;
	struct rb_root_cached pending_unbind;
	struct drm_i915_gem_object * (*alloc_pt_dma)(struct i915_address_space *, int);
	struct drm_i915_gem_object * (*alloc_scratch_dma)(struct i915_address_space *, int);
	u64 (*pte_encode)(dma_addr_t, unsigned int, u32);
	void (*allocate_va_range)(struct i915_address_space *, struct i915_vm_pt_stash *, u64, u64);
	void (*clear_range)(struct i915_address_space *, u64, u64);
	void (*scratch_range)(struct i915_address_space *, u64, u64);
	void (*insert_page)(struct i915_address_space *, dma_addr_t, u64, unsigned int, u32);
	void (*insert_entries)(struct i915_address_space *, struct i915_vma_resource *, unsigned int, u32);
	void (*raw_insert_page)(struct i915_address_space *, dma_addr_t, u64, unsigned int, u32);
	void (*raw_insert_entries)(struct i915_address_space *, struct i915_vma_resource *, unsigned int, u32);
	void (*cleanup)(struct i915_address_space *);
	void (*foreach)(struct i915_address_space *, u64, u64, void (*)(struct i915_address_space *, struct i915_page_table *, void *), void *);
	struct i915_vma_ops vma_ops;
};

struct i915_page_directory;

struct i915_ppgtt {
	struct i915_address_space vm;
	struct i915_page_directory *pd;
};

struct gen6_ppgtt {
	struct i915_ppgtt base;
	struct mutex flush;
	struct i915_vma *vma;
	gen6_pte_t *pd_addr;
	u32 pp_dir;
	atomic_t pin_count;
	bool scan_for_unused_pt;
};

struct pcpu_gen_cookie;

struct gen_cookie {
	struct pcpu_gen_cookie *local;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t forward_last;
	atomic64_t reverse_last;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct gen_pool;

typedef long unsigned int (*genpool_algo_t)(long unsigned int *, long unsigned int, long unsigned int, unsigned int, void *, struct gen_pool *, long unsigned int);

struct gen_pool {
	spinlock_t lock;
	struct list_head chunks;
	int min_alloc_order;
	genpool_algo_t algo;
	void *data;
	const char *name;
};

struct gen_pool_chunk {
	struct list_head next_chunk;
	atomic_long_t avail;
	phys_addr_t phys_addr;
	void *owner;
	long unsigned int start_addr;
	long unsigned int end_addr;
	long unsigned int bits[0];
};

struct timer_rand_state;

struct gendisk {
	int major;
	int first_minor;
	int minors;
	char disk_name[32];
	short unsigned int events;
	short unsigned int event_flags;
	struct xarray part_tbl;
	struct block_device *part0;
	const struct block_device_operations *fops;
	struct request_queue *queue;
	void *private_data;
	struct bio_set bio_split;
	int flags;
	long unsigned int state;
	struct mutex open_mutex;
	unsigned int open_partitions;
	struct backing_dev_info *bdi;
	struct kobject queue_kobj;
	struct kobject *slave_dir;
	struct list_head slave_bdevs;
	struct timer_rand_state *random;
	atomic_t sync_io;
	struct disk_events *ev;
	int node_id;
	struct badblocks *bb;
	struct lockdep_map lockdep_map;
	u64 diskseq;
	blk_mode_t open_mode;
	struct blk_independent_access_ranges *ia_ranges;
};

struct geneve_opt {
	__be16 opt_class;
	u8 type;
	u8 length: 5;
	u8 r3: 1;
	u8 r2: 1;
	u8 r1: 1;
	u8 opt_data[0];
};

struct genevehdr {
	u8 opt_len: 6;
	u8 ver: 2;
	u8 rsvd1: 6;
	u8 critical: 1;
	u8 oam: 1;
	__be16 proto_type;
	u8 vni[3];
	u8 rsvd2;
	u8 options[0];
};

struct nla_policy;

struct genl_split_ops {
	union {
		struct {
			int (*pre_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
			int (*doit)(struct sk_buff *, struct genl_info *);
			void (*post_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
		};
		struct {
			int (*start)(struct netlink_callback *);
			int (*dumpit)(struct sk_buff *, struct netlink_callback *);
			int (*done)(struct netlink_callback *);
		};
	};
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genlmsghdr;

struct genl_info {
	u32 snd_seq;
	u32 snd_portid;
	const struct genl_family *family;
	const struct nlmsghdr *nlhdr;
	struct genlmsghdr *genlhdr;
	struct nlattr **attrs;
	possible_net_t _net;
	union {
		u8 ctx[48];
		void *user_ptr[2];
	};
	struct netlink_ext_ack *extack;
};

struct genl_dumpit_info {
	struct genl_split_ops op;
	struct genl_info info;
};

struct genl_ops;

struct genl_small_ops;

struct genl_multicast_group;

struct genl_family {
	unsigned int hdrsize;
	char name[16];
	unsigned int version;
	unsigned int maxattr;
	u8 netnsok: 1;
	u8 parallel_ops: 1;
	u8 n_ops;
	u8 n_small_ops;
	u8 n_split_ops;
	u8 n_mcgrps;
	u8 resv_start_op;
	const struct nla_policy *policy;
	int (*pre_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
	void (*post_doit)(const struct genl_split_ops *, struct sk_buff *, struct genl_info *);
	int (*bind)(int);
	void (*unbind)(int);
	const struct genl_ops *ops;
	const struct genl_small_ops *small_ops;
	const struct genl_split_ops *split_ops;
	const struct genl_multicast_group *mcgrps;
	struct module *module;
	size_t sock_priv_size;
	void (*sock_priv_init)(void *);
	void (*sock_priv_destroy)(void *);
	int id;
	unsigned int mcgrp_offset;
	struct xarray *sock_privs;
};

struct genl_multicast_group {
	char name[16];
	u8 flags;
};

struct genl_op_iter {
	const struct genl_family *family;
	struct genl_split_ops doit;
	struct genl_split_ops dumpit;
	int cmd_idx;
	int entry_idx;
	u32 cmd;
	u8 flags;
};

struct genl_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*start)(struct netlink_callback *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_small_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_start_context {
	const struct genl_family *family;
	struct nlmsghdr *nlh;
	struct netlink_ext_ack *extack;
	const struct genl_split_ops *ops;
	int hdrlen;
};

struct genlmsghdr {
	__u8 cmd;
	__u8 version;
	__u16 reserved;
};

struct genpool_data_align {
	int align;
};

struct genpool_data_fixed {
	long unsigned int offset;
};

struct genradix_iter {
	size_t offset;
	size_t pos;
};

struct genradix_node {
	union {
		struct genradix_node *children[64];
		u8 data[512];
	};
};

struct getbmapx {
	__s64 bmv_offset;
	__s64 bmv_block;
	__s64 bmv_length;
	__s32 bmv_count;
	__s32 bmv_entries;
	__s32 bmv_iflags;
	__s32 bmv_oflags;
	__s32 bmv_unused1;
	__s32 bmv_unused2;
};

struct getcpu_cache {
	long unsigned int blob[16];
};

struct getdents_callback {
	struct dir_context ctx;
	char *name;
	u64 ino;
	int found;
	int sequence;
};

struct linux_dirent;

struct getdents_callback___2 {
	struct dir_context ctx;
	struct linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct linux_dirent64;

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct getfsmap_info {
	struct super_block *gi_sb;
	struct fsmap_head *gi_data;
	unsigned int gi_idx;
	__u32 gi_last_flags;
};

struct input_keymap_entry {
	__u8 flags;
	__u8 len;
	__u16 index;
	__u32 keycode;
	__u8 scancode[32];
};

struct getset_keycode_data {
	struct input_keymap_entry ke;
	int error;
};

struct gf128mul_4k {
	be128 t[256];
};

struct gf128mul_64k {
	struct gf128mul_4k *t[16];
};

struct kvm_memory_slot;

struct gfn_to_hva_cache {
	u64 generation;
	gpa_t gpa;
	long unsigned int hva;
	long unsigned int len;
	struct kvm_memory_slot *memslot;
};

struct kvm;

struct gfn_to_pfn_cache {
	u64 generation;
	gpa_t gpa;
	long unsigned int uhva;
	struct kvm_memory_slot *memslot;
	struct kvm *kvm;
	struct list_head list;
	rwlock_t lock;
	struct mutex refresh_lock;
	void *khva;
	kvm_pfn_t pfn;
	bool active;
	bool valid;
};

struct ghash_ctx {
	struct gf128mul_4k *gf128;
};

struct ghash_desc_ctx {
	u8 buffer[16];
	u32 bytes;
};

struct ghcb_save_area {
	u8 reserved_0x0[203];
	u8 cpl;
	u8 reserved_0xcc[116];
	u64 xss;
	u8 reserved_0x148[24];
	u64 dr7;
	u8 reserved_0x168[16];
	u64 rip;
	u8 reserved_0x180[88];
	u64 rsp;
	u8 reserved_0x1e0[24];
	u64 rax;
	u8 reserved_0x200[264];
	u64 rcx;
	u64 rdx;
	u64 rbx;
	u8 reserved_0x320[8];
	u64 rbp;
	u64 rsi;
	u64 rdi;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u8 reserved_0x380[16];
	u64 sw_exit_code;
	u64 sw_exit_info_1;
	u64 sw_exit_info_2;
	u64 sw_scratch;
	u8 reserved_0x3b0[56];
	u64 xcr0;
	u8 valid_bitmap[16];
	u64 x87_state_gpa;
};

struct ghcb {
	struct ghcb_save_area save;
	u8 reserved_save[1016];
	u8 shared_buffer[2032];
	u8 reserved_0xff0[10];
	u16 protocol_version;
	u32 ghcb_usage;
};

struct global_params {
	bool no_turbo;
	bool turbo_disabled;
	int max_perf_pct;
	int min_perf_pct;
};

struct gmbus_pin {
	const char *name;
	enum gmbus_gpio gpio;
};

struct tc_stats {
	__u64 bytes;
	__u32 packets;
	__u32 drops;
	__u32 overlimits;
	__u32 bps;
	__u32 pps;
	__u32 qlen;
	__u32 backlog;
};

struct gnet_dump {
	spinlock_t *lock;
	struct sk_buff *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

struct gnet_estimator {
	signed char interval;
	unsigned char ewma_log;
};

struct gnet_stats_basic {
	__u64 bytes;
	__u32 packets;
};

struct gnet_stats_rate_est {
	__u32 bps;
	__u32 pps;
};

struct gnet_stats_rate_est64 {
	__u64 bps;
	__u64 pps;
};

struct governor_attr {
	struct attribute attr;
	ssize_t (*show)(struct gov_attr_set *, char *);
	ssize_t (*store)(struct gov_attr_set *, const char *, size_t);
};

struct gpiod_lookup {
	const char *key;
	u16 chip_hwnum;
	const char *con_id;
	unsigned int idx;
	long unsigned int flags;
};

struct gpiod_lookup_table {
	struct list_head list;
	const char *dev_id;
	struct gpiod_lookup table[0];
};

struct gprs_dev {
	struct sock *sk;
	void (*old_state_change)(struct sock *);
	void (*old_data_ready)(struct sock *);
	void (*old_write_space)(struct sock *);
	struct net_device *dev;
};

struct gre_base_hdr {
	__be16 flags;
	__be16 protocol;
};

struct gre_full_hdr {
	struct gre_base_hdr fixed_header;
	__be16 csum;
	__be16 reserved1;
	__be32 key;
	__be32 seq;
};

struct gre_protocol {
	int (*handler)(struct sk_buff *);
	void (*err_handler)(struct sk_buff *, u32);
};

struct gred_sched_data;

struct tc_gred_qopt_offload;

struct gred_sched {
	struct gred_sched_data *tab[16];
	long unsigned int flags;
	u32 red_flags;
	u32 DPs;
	u32 def;
	struct red_vars wred_set;
	struct tc_gred_qopt_offload *opt;
};

struct red_stats {
	u32 prob_drop;
	u32 prob_mark;
	u32 forced_drop;
	u32 forced_mark;
	u32 pdrop;
};

struct gred_sched_data {
	u32 limit;
	u32 DP;
	u32 red_flags;
	u64 bytesin;
	u32 packetsin;
	u32 backlog;
	u8 prio;
	struct red_parms parms;
	struct red_vars vars;
	struct red_stats stats;
};

struct gro_cell {
	struct sk_buff_head napi_skbs;
	struct napi_struct napi;
};

struct gro_cells {
	struct gro_cell *cells;
};

struct gro_remcsum {
	int offset;
	__wsum delta;
};

struct group_device {
	struct list_head list;
	struct device *dev;
	char *name;
};

struct group_filter {
	union {
		struct {
			__u32 gf_interface_aux;
			struct __kernel_sockaddr_storage gf_group_aux;
			__u32 gf_fmode_aux;
			__u32 gf_numsrc_aux;
			struct __kernel_sockaddr_storage gf_slist[1];
		};
		struct {
			__u32 gf_interface;
			struct __kernel_sockaddr_storage gf_group;
			__u32 gf_fmode;
			__u32 gf_numsrc;
			struct __kernel_sockaddr_storage gf_slist_flex[0];
		};
	};
};

struct group_for_pci_data {
	struct pci_dev *pdev;
	struct iommu_group *group;
};

struct group_info {
	refcount_t usage;
	int ngroups;
	kgid_t gid[0];
};

struct group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct gsb_buffer {
	u8 status;
	u8 len;
	union {
		u16 wdata;
		u8 bdata;
		struct {
			struct {} __empty_data;
			u8 data[0];
		};
	};
};

struct gsc_def {
	const char *name;
	long unsigned int bar;
	size_t bar_size;
	bool use_polling;
	bool slow_firmware;
	size_t lmem_size;
};

struct gsc_heci_pkt {
	u64 addr_in;
	u32 size_in;
	u64 addr_out;
	u32 size_out;
};

struct intel_gsc_mtl_header {
	u32 validity_marker;
	u8 heci_client_id;
	u8 reserved1;
	u16 header_version;
	u64 host_session_handle;
	u64 gsc_message_handle;
	u32 message_size;
	u32 flags;
	u32 status;
} __attribute__((packed));

struct intel_gsc_proxy_header {
	u32 hdr;
	u32 source;
	u32 destination;
	u32 status;
};

struct gsc_proxy_msg {
	struct intel_gsc_mtl_header header;
	struct intel_gsc_proxy_header proxy_header;
};

struct intel_context;

struct gsccs_session_resources {
	u64 host_session_handle;
	struct intel_context *ce;
	struct i915_vma *pkt_vma;
	void *pkt_vaddr;
	struct i915_vma *bb_vma;
	void *bb_vaddr;
};

struct rpc_clnt;

struct rpc_pipe_ops;

struct gss_alloc_pdo {
	struct rpc_clnt *clnt;
	const char *name;
	const struct rpc_pipe_ops *upcall_ops;
};

struct rpcsec_gss_oid {
	unsigned int len;
	u8 data[32];
};

struct gss_api_ops;

struct pf_desc;

struct gss_api_mech {
	struct list_head gm_list;
	struct module *gm_owner;
	struct rpcsec_gss_oid gm_oid;
	char *gm_name;
	const struct gss_api_ops *gm_ops;
	int gm_pf_num;
	struct pf_desc *gm_pfs;
	const char *gm_upcall_enctypes;
};

struct gss_ctx;

struct xdr_netobj;

struct gss_api_ops {
	int (*gss_import_sec_context)(const void *, size_t, struct gss_ctx *, time64_t *, gfp_t);
	u32 (*gss_get_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_verify_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_wrap)(struct gss_ctx *, int, struct xdr_buf *, struct page **);
	u32 (*gss_unwrap)(struct gss_ctx *, int, int, struct xdr_buf *);
	void (*gss_delete_sec_context)(void *);
};

struct rpc_authops;

struct rpc_cred_cache;

struct rpc_auth {
	unsigned int au_cslack;
	unsigned int au_rslack;
	unsigned int au_verfsize;
	unsigned int au_ralign;
	long unsigned int au_flags;
	const struct rpc_authops *au_ops;
	rpc_authflavor_t au_flavor;
	refcount_t au_count;
	struct rpc_cred_cache *au_credcache;
};

struct gss_pipe;

struct gss_auth {
	struct kref kref;
	struct hlist_node hash;
	struct rpc_auth rpc_auth;
	struct gss_api_mech *mech;
	enum rpc_gss_svc service;
	struct rpc_clnt *client;
	struct net *net;
	netns_tracker ns_tracker;
	struct gss_pipe *gss_pipe[2];
	const char *target_name;
};

struct xdr_netobj {
	unsigned int len;
	u8 *data;
};

struct gss_cl_ctx {
	refcount_t count;
	enum rpc_gss_proc gc_proc;
	u32 gc_seq;
	u32 gc_seq_xmit;
	spinlock_t gc_seq_lock;
	struct gss_ctx *gc_gss_ctx;
	struct xdr_netobj gc_wire_ctx;
	struct xdr_netobj gc_acceptor;
	u32 gc_win;
	long unsigned int gc_expiry;
	struct callback_head gc_rcu;
};

struct rpc_credops;

struct rpc_cred {
	struct hlist_node cr_hash;
	struct list_head cr_lru;
	struct callback_head cr_rcu;
	struct rpc_auth *cr_auth;
	const struct rpc_credops *cr_ops;
	long unsigned int cr_expire;
	long unsigned int cr_flags;
	refcount_t cr_count;
	const struct cred *cr_cred;
};

struct gss_upcall_msg;

struct gss_cred {
	struct rpc_cred gc_base;
	enum rpc_gss_svc gc_service;
	struct gss_cl_ctx *gc_ctx;
	struct gss_upcall_msg *gc_upcall;
	const char *gc_principal;
	long unsigned int gc_upcall_timestamp;
};

struct gss_ctx {
	struct gss_api_mech *mech_type;
	void *internal_ctx_id;
	unsigned int slack;
	unsigned int align;
};

struct gss_domain {
	struct auth_domain h;
	u32 pseudoflavor;
};

struct krb5_ctx;

struct gss_krb5_enctype {
	const u32 etype;
	const u32 ctype;
	const char *name;
	const char *encrypt_name;
	const char *aux_cipher;
	const char *cksum_name;
	const u16 signalg;
	const u16 sealalg;
	const u32 cksumlength;
	const u32 keyed_cksum;
	const u32 keybytes;
	const u32 keylength;
	const u32 Kc_length;
	const u32 Ke_length;
	const u32 Ki_length;
	int (*derive_key)(const struct gss_krb5_enctype *, const struct xdr_netobj *, struct xdr_netobj *, const struct xdr_netobj *, gfp_t);
	u32 (*encrypt)(struct krb5_ctx *, u32, struct xdr_buf *, struct page **);
	u32 (*decrypt)(struct krb5_ctx *, u32, u32, struct xdr_buf *, u32 *, u32 *);
	u32 (*get_mic)(struct krb5_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*verify_mic)(struct krb5_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*wrap)(struct krb5_ctx *, int, struct xdr_buf *, struct page **);
	u32 (*unwrap)(struct krb5_ctx *, int, int, struct xdr_buf *, unsigned int *, unsigned int *);
};

struct rpc_pipe_dir_object_ops;

struct rpc_pipe_dir_object {
	struct list_head pdo_head;
	const struct rpc_pipe_dir_object_ops *pdo_ops;
	void *pdo_data;
};

struct rpc_pipe;

struct gss_pipe {
	struct rpc_pipe_dir_object pdo;
	struct rpc_pipe *pipe;
	struct rpc_clnt *clnt;
	const char *name;
	struct kref kref;
};

struct rpc_gss_wire_cred {
	u32 gc_v;
	u32 gc_proc;
	u32 gc_seq;
	u32 gc_svc;
	struct xdr_netobj gc_ctx;
};

struct rsc;

struct gss_svc_data {
	struct rpc_gss_wire_cred clcred;
	u32 gsd_databody_offset;
	struct rsc *rsci;
	__be32 gsd_seq_num;
	u8 gsd_scratch[40];
};

struct gss_svc_seq_data {
	u32 sd_max;
	long unsigned int sd_win[2];
	spinlock_t sd_lock;
};

struct rpc_pipe_msg {
	struct list_head list;
	void *data;
	size_t len;
	size_t copied;
	int errno;
};

struct rpc_timer {
	struct list_head list;
	long unsigned int expires;
	struct delayed_work dwork;
};

struct rpc_wait_queue {
	spinlock_t lock;
	struct list_head tasks[4];
	unsigned char maxpriority;
	unsigned char priority;
	unsigned char nr;
	unsigned int qlen;
	struct rpc_timer timer_list;
	const char *name;
};

struct gss_upcall_msg {
	refcount_t count;
	kuid_t uid;
	const char *service_name;
	struct rpc_pipe_msg msg;
	struct list_head list;
	struct gss_auth *auth;
	struct rpc_pipe *pipe;
	struct rpc_wait_queue rpc_waitqueue;
	wait_queue_head_t waitqueue;
	struct gss_cl_ctx *ctx;
	char databuf[256];
};

struct gssp_in_token {
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
};

struct svc_cred {
	kuid_t cr_uid;
	kgid_t cr_gid;
	struct group_info *cr_group_info;
	u32 cr_flavor;
	char *cr_raw_principal;
	char *cr_principal;
	char *cr_targ_princ;
	struct gss_api_mech *cr_gss_mech;
};

struct gssp_upcall_data {
	struct xdr_netobj in_handle;
	struct gssp_in_token in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	struct rpcsec_gss_oid mech_oid;
	struct svc_cred creds;
	int found_creds;
	int major_status;
	int minor_status;
};

typedef struct xdr_netobj utf8string;

typedef struct xdr_netobj gssx_buffer;

struct gssx_option;

struct gssx_option_array {
	u32 count;
	struct gssx_option *data;
};

struct gssx_call_ctx {
	utf8string locale;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_ctx;

struct gssx_cred;

struct gssx_cb;

struct gssx_arg_accept_sec_context {
	struct gssx_call_ctx call_ctx;
	struct gssx_ctx *context_handle;
	struct gssx_cred *cred_handle;
	struct gssp_in_token input_token;
	struct gssx_cb *input_cb;
	u32 ret_deleg_cred;
	struct gssx_option_array options;
	struct page **pages;
	unsigned int npages;
};

struct gssx_cb {
	u64 initiator_addrtype;
	gssx_buffer initiator_address;
	u64 acceptor_addrtype;
	gssx_buffer acceptor_address;
	gssx_buffer application_data;
};

struct gssx_name {
	gssx_buffer display_name;
};

typedef struct gssx_name gssx_name;

struct gssx_cred_element;

struct gssx_cred_element_array {
	u32 count;
	struct gssx_cred_element *data;
};

struct gssx_cred {
	gssx_name desired_name;
	struct gssx_cred_element_array elements;
	gssx_buffer cred_handle_reference;
	u32 needs_release;
};

typedef struct xdr_netobj gssx_OID;

struct gssx_cred_element {
	gssx_name MN;
	gssx_OID mech;
	u32 cred_usage;
	u64 initiator_time_rec;
	u64 acceptor_time_rec;
	struct gssx_option_array options;
};

struct gssx_ctx {
	gssx_buffer exported_context_token;
	gssx_buffer state;
	u32 need_release;
	gssx_OID mech;
	gssx_name src_name;
	gssx_name targ_name;
	u64 lifetime;
	u64 ctx_flags;
	u32 locally_initiated;
	u32 open;
	struct gssx_option_array options;
};

struct gssx_name_attr {
	gssx_buffer attr;
	gssx_buffer value;
	struct gssx_option_array extensions;
};

struct gssx_name_attr_array {
	u32 count;
	struct gssx_name_attr *data;
};

struct gssx_option {
	gssx_buffer option;
	gssx_buffer value;
};

struct gssx_status {
	u64 major_status;
	gssx_OID mech;
	u64 minor_status;
	utf8string major_status_string;
	utf8string minor_status_string;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_res_accept_sec_context {
	struct gssx_status status;
	struct gssx_ctx *context_handle;
	gssx_buffer *output_token;
	struct gssx_option_array options;
};

struct gt_defaults {
	u32 min_freq;
	u32 max_freq;
	u8 rps_up_threshold;
	u8 rps_down_threshold;
};

struct gtp_pdu_session_info {
	u8 pdu_type;
	u8 qfi;
};

struct guc_ct_buffer_desc {
	u32 head;
	u32 tail;
	u32 status;
	u32 reserved[13];
};

struct guc_ctxt_registration_info {
	u32 flags;
	u32 context_idx;
	u32 engine_class;
	u32 engine_submit_mask;
	u32 wq_desc_lo;
	u32 wq_desc_hi;
	u32 wq_base_lo;
	u32 wq_base_hi;
	u32 wq_size;
	u32 hwlrca_lo;
	u32 hwlrca_hi;
};

struct guc_debug_capture_list_header {
	u32 info;
};

struct guc_debug_capture_list {
	struct guc_debug_capture_list_header header;
	struct guc_mmio_reg regs[0];
};

struct guc_sched_wq_desc {
	u32 head;
	u32 tail;
	u32 error_offset;
	u32 wq_status;
	u32 reserved[28];
};

struct guc_process_desc_v69 {
	u32 stage_id;
	u64 db_base_addr;
	u32 head;
	u32 tail;
	u32 error_offset;
	u64 wq_base_addr;
	u32 wq_size_bytes;
	u32 wq_status;
	u32 engine_presence;
	u32 priority;
	u32 reserved[36];
} __attribute__((packed));

union guc_descs {
	struct guc_sched_wq_desc wq_desc;
	struct guc_process_desc_v69 pdesc;
};

struct intel_ctb_coredump {
	u32 raw_head;
	u32 head;
	u32 raw_tail;
	u32 tail;
	u32 raw_status;
	u32 desc_offset;
	u32 cmds_offset;
	u32 size;
};

struct i915_vma_coredump;

struct guc_info {
	struct intel_ctb_coredump ctb[2];
	struct i915_vma_coredump *vma_ctb;
	struct i915_vma_coredump *vma_log;
	u32 timestamp;
	u16 last_fence;
	bool is_guc_capture;
};

struct guc_log_buffer_state {
	u32 marker[2];
	u32 read_ptr;
	u32 write_ptr;
	u32 size;
	u32 sampled_write_ptr;
	u32 wrap_offset;
	union {
		struct {
			u32 flush_to_file: 1;
			u32 buffer_full_cnt: 4;
			u32 reserved: 27;
		};
		u32 flags;
	};
	u32 version;
};

struct guc_log_section {
	u32 max;
	u32 flag;
	u32 default_val;
	const char *name;
};

struct guc_lrc_desc_v69 {
	u32 hw_context_desc;
	u32 slpm_perf_mode_hint;
	u32 slpm_freq_hint;
	u32 engine_submit_mask;
	u8 engine_class;
	u8 reserved0[3];
	u32 priority;
	u32 process_desc;
	u32 wq_addr;
	u32 wq_size;
	u32 context_flags;
	u32 execution_quantum;
	u32 preemption_timeout;
	u32 policy_flags;
	u32 reserved1[19];
};

struct guc_state_capture_group_header_t {
	u32 owner;
	u32 info;
};

struct guc_state_capture_header_t {
	u32 owner;
	u32 info;
	u32 lrca;
	u32 guc_id;
	u32 num_mmios;
};

struct guc_update_scheduling_policy_header {
	u32 action;
};

struct guc_update_scheduling_policy {
	struct guc_update_scheduling_policy_header header;
	u32 data[3];
};

union intel_engine_tlb_inv_reg {
	i915_reg_t reg;
	i915_mcr_reg_t mcr_reg;
};

struct intel_engine_tlb_inv {
	bool mcr;
	union intel_engine_tlb_inv_reg reg;
	u32 request;
	u32 done;
};

struct intel_sseu {
	u8 slice_mask;
	u8 subslice_mask;
	u8 min_eus_per_subslice;
	u8 max_eus_per_subslice;
};

struct intel_wakeref_ops;

struct intel_wakeref {
	atomic_t count;
	struct mutex mutex;
	intel_wakeref_t wakeref;
	struct drm_i915_private *i915;
	const struct intel_wakeref_ops *ops;
	struct delayed_work work;
};

struct intel_engine_pmu {
	u32 enable;
	unsigned int enable_count[3];
	struct i915_pmu_sample sample[3];
};

struct intel_hw_status_page {
	struct list_head timelines;
	struct i915_vma *vma;
	u32 *addr;
};

struct i915_wa_ctx_bb {
	u32 offset;
	u32 size;
};

struct i915_ctx_workarounds {
	struct i915_wa_ctx_bb indirect_ctx;
	struct i915_wa_ctx_bb per_ctx;
	struct i915_vma *vma;
};

struct i915_wa;

struct i915_wa_list {
	struct intel_gt *gt;
	const char *name;
	const char *engine_name;
	struct i915_wa *list;
	unsigned int count;
	unsigned int wa_count;
};

struct intel_engine_execlists {
	struct timer_list timer;
	struct timer_list preempt;
	const struct i915_request *preempt_target;
	u32 ccid;
	u32 yield;
	u32 error_interrupt;
	u32 reset_ccid;
	u32 *submit_reg;
	u32 *ctrl_reg;
	struct i915_request * const *active;
	struct i915_request *inflight[3];
	struct i915_request *pending[3];
	unsigned int port_mask;
	struct rb_root_cached virtual;
	u32 *csb_write;
	u64 *csb_status;
	u8 csb_size;
	u8 csb_head;
};

struct intel_engine_execlists_stats {
	unsigned int active;
	seqcount_t lock;
	ktime_t total;
	ktime_t start;
};

struct intel_engine_guc_stats {
	bool running;
	u32 prev_total;
	u64 total_gt_clks;
	u64 start_gt_clk;
	u64 total;
};

struct i915_sched_engine;

struct intel_ring;

struct intel_timeline;

struct intel_breadcrumbs;

struct intel_context_ops;

struct i915_perf_group;

struct intel_engine_cs {
	struct drm_i915_private *i915;
	struct intel_gt *gt;
	struct intel_uncore *uncore;
	char name[8];
	enum intel_engine_id id;
	enum intel_engine_id legacy_idx;
	unsigned int guc_id;
	intel_engine_mask_t mask;
	u32 reset_domain;
	intel_engine_mask_t logical_mask;
	u8 class;
	u8 instance;
	u16 uabi_class;
	u16 uabi_instance;
	u32 uabi_capabilities;
	u32 context_size;
	u32 mmio_base;
	struct intel_engine_tlb_inv tlb_inv;
	enum forcewake_domains fw_domain;
	unsigned int fw_active;
	long unsigned int context_tag;
	union {
		struct llist_node uabi_llist;
		struct list_head uabi_list;
		struct rb_node uabi_node;
	};
	struct intel_sseu sseu;
	struct i915_sched_engine *sched_engine;
	struct i915_request *request_pool;
	struct intel_context *hung_ce;
	struct llist_head barrier_tasks;
	struct intel_context *kernel_context;
	struct intel_context *bind_context;
	bool bind_context_ready;
	struct list_head pinned_contexts_list;
	intel_engine_mask_t saturated;
	struct {
		struct delayed_work work;
		struct i915_request *systole;
		long unsigned int blocked;
	} heartbeat;
	long unsigned int serial;
	long unsigned int wakeref_serial;
	intel_wakeref_t wakeref_track;
	struct intel_wakeref wakeref;
	struct file *default_state;
	struct {
		struct intel_ring *ring;
		struct intel_timeline *timeline;
	} legacy;
	struct ewma__engine_latency latency;
	struct intel_breadcrumbs *breadcrumbs;
	struct intel_engine_pmu pmu;
	struct intel_hw_status_page status_page;
	struct i915_ctx_workarounds wa_ctx;
	struct i915_wa_list ctx_wa_list;
	struct i915_wa_list wa_list;
	struct i915_wa_list whitelist;
	u32 irq_keep_mask;
	u32 irq_enable_mask;
	void (*irq_enable)(struct intel_engine_cs *);
	void (*irq_disable)(struct intel_engine_cs *);
	void (*irq_handler)(struct intel_engine_cs *, u16);
	void (*sanitize)(struct intel_engine_cs *);
	int (*resume)(struct intel_engine_cs *);
	struct {
		void (*prepare)(struct intel_engine_cs *);
		void (*rewind)(struct intel_engine_cs *, bool);
		void (*cancel)(struct intel_engine_cs *);
		void (*finish)(struct intel_engine_cs *);
	} reset;
	void (*park)(struct intel_engine_cs *);
	void (*unpark)(struct intel_engine_cs *);
	void (*bump_serial)(struct intel_engine_cs *);
	void (*set_default_submission)(struct intel_engine_cs *);
	const struct intel_context_ops *cops;
	int (*request_alloc)(struct i915_request *);
	int (*emit_flush)(struct i915_request *, u32);
	int (*emit_bb_start)(struct i915_request *, u64, u32, unsigned int);
	int (*emit_init_breadcrumb)(struct i915_request *);
	u32 * (*emit_fini_breadcrumb)(struct i915_request *, u32 *);
	unsigned int emit_fini_breadcrumb_dw;
	void (*submit_request)(struct i915_request *);
	void (*release)(struct intel_engine_cs *);
	void (*add_active_request)(struct i915_request *);
	void (*remove_active_request)(struct i915_request *);
	ktime_t (*busyness)(struct intel_engine_cs *, ktime_t *);
	struct intel_engine_execlists execlists;
	struct intel_timeline *retire;
	struct work_struct retire_work;
	struct atomic_notifier_head context_status_notifier;
	unsigned int flags;
	struct hlist_head cmd_hash[512];
	const struct drm_i915_reg_table *reg_tables;
	int reg_table_count;
	u32 (*get_cmd_length_mask)(u32);
	struct {
		union {
			struct intel_engine_execlists_stats execlists;
			struct intel_engine_guc_stats guc;
		};
		ktime_t rps;
	} stats;
	struct {
		long unsigned int heartbeat_interval_ms;
		long unsigned int max_busywait_duration_ns;
		long unsigned int preempt_timeout_ms;
		long unsigned int stop_timeout_ms;
		long unsigned int timeslice_duration_ms;
	} props;
	struct {
		long unsigned int heartbeat_interval_ms;
		long unsigned int max_busywait_duration_ns;
		long unsigned int preempt_timeout_ms;
		long unsigned int stop_timeout_ms;
		long unsigned int timeslice_duration_ms;
	} defaults;
	struct i915_perf_group *oa_group;
};

struct intel_context_stats {
	u64 active;
	struct {
		struct ewma_runtime avg;
		u64 total;
		u32 last;
	} runtime;
};

struct i915_gem_context;

struct intel_context {
	union {
		struct kref ref;
		struct callback_head rcu;
	};
	struct intel_engine_cs *engine;
	struct intel_engine_cs *inflight;
	struct i915_address_space *vm;
	struct i915_gem_context *gem_context;
	struct file *default_state;
	struct list_head signal_link;
	struct list_head signals;
	spinlock_t signal_lock;
	struct i915_vma *state;
	u32 ring_size;
	struct intel_ring *ring;
	struct intel_timeline *timeline;
	intel_wakeref_t wakeref;
	long unsigned int flags;
	struct {
		u64 timeout_us;
	} watchdog;
	u32 *lrc_reg_state;
	union {
		struct {
			u32 lrca;
			u32 ccid;
		};
		u64 desc;
	} lrc;
	u32 tag;
	struct intel_context_stats stats;
	unsigned int active_count;
	atomic_t pin_count;
	struct mutex pin_mutex;
	struct i915_active active;
	const struct intel_context_ops *ops;
	struct intel_sseu sseu;
	struct list_head pinned_contexts_link;
	u8 wa_bb_page;
	struct {
		spinlock_t lock;
		u32 sched_state;
		struct list_head fences;
		struct i915_sw_fence blocked;
		struct list_head requests;
		u8 prio;
		u32 prio_count[4];
		struct delayed_work sched_disable_delay_work;
	} guc_state;
	struct {
		u16 id;
		atomic_t ref;
		struct list_head link;
	} guc_id;
	struct list_head destroyed_link;
	struct {
		union {
			struct list_head child_list;
			struct list_head child_link;
		};
		struct intel_context *parent;
		struct i915_request *last_rq;
		u64 fence_context;
		u32 seqno;
		u8 number_children;
		u8 child_index;
		struct {
			u16 wqi_head;
			u16 wqi_tail;
			u32 *wq_head;
			u32 *wq_tail;
			u32 *wq_status;
			u8 parent_page;
		} guc;
	} parallel;
};

struct guc_virtual_engine {
	struct intel_engine_cs base;
	struct intel_context context;
};

struct guid_block {
	guid_t guid;
	union {
		char object_id[2];
		struct {
			unsigned char notify_id;
			unsigned char reserved;
		};
	};
	u8 instance_count;
	u8 flags;
};

struct gve_adminq_configure_device_resources {
	__be64 counter_array;
	__be64 irq_db_addr;
	__be32 num_counters;
	__be32 num_irq_dbs;
	__be32 irq_db_stride;
	__be32 ntfy_blk_msix_base_idx;
	u8 queue_format;
	u8 padding[7];
};

struct gve_adminq_create_tx_queue {
	__be32 queue_id;
	__be32 reserved;
	__be64 queue_resources_addr;
	__be64 tx_ring_addr;
	__be32 queue_page_list_id;
	__be32 ntfy_id;
	__be64 tx_comp_ring_addr;
	__be16 tx_ring_size;
	__be16 tx_comp_ring_size;
	u8 padding[4];
};

struct gve_adminq_create_rx_queue {
	__be32 queue_id;
	__be32 index;
	__be32 reserved;
	__be32 ntfy_id;
	__be64 queue_resources_addr;
	__be64 rx_desc_ring_addr;
	__be64 rx_data_ring_addr;
	__be32 queue_page_list_id;
	__be16 rx_ring_size;
	__be16 packet_buffer_size;
	__be16 rx_buff_ring_size;
	u8 enable_rsc;
	u8 padding1;
	__be16 header_buffer_size;
	u8 padding2[2];
};

struct gve_adminq_destroy_tx_queue {
	__be32 queue_id;
};

struct gve_adminq_destroy_rx_queue {
	__be32 queue_id;
};

struct gve_adminq_describe_device {
	__be64 device_descriptor_addr;
	__be32 device_descriptor_version;
	__be32 available_length;
};

struct gve_adminq_register_page_list {
	__be32 page_list_id;
	__be32 num_pages;
	__be64 page_address_list_addr;
	__be64 page_size;
};

struct gve_adminq_unregister_page_list {
	__be32 page_list_id;
};

struct gve_adminq_set_driver_parameter {
	__be32 parameter_type;
	u8 reserved[4];
	__be64 parameter_value;
};

struct gve_adminq_report_stats {
	__be64 stats_report_len;
	__be64 stats_report_addr;
	__be64 interval;
};

struct gve_adminq_report_link_speed {
	__be64 link_speed_address;
};

struct gve_adminq_get_ptype_map {
	__be64 ptype_map_len;
	__be64 ptype_map_addr;
};

struct gve_adminq_verify_driver_compatibility {
	__be64 driver_info_len;
	__be64 driver_info_addr;
};

struct gve_adminq_query_flow_rules {
	__be16 opcode;
	u8 padding[2];
	__be32 starting_rule_id;
	__be64 available_length;
	__be64 rule_descriptor_addr;
};

struct gve_adminq_configure_rss {
	__be16 hash_types;
	u8 hash_alg;
	u8 reserved;
	__be16 hash_key_size;
	__be16 hash_lut_size;
	__be64 hash_key_addr;
	__be64 hash_lut_addr;
};

struct gve_adminq_query_rss {
	__be64 available_length;
	__be64 rss_descriptor_addr;
};

struct gve_adminq_extended_command {
	__be32 inner_opcode;
	__be32 inner_length;
	__be64 inner_command_addr;
};

union gve_adminq_command {
	struct {
		__be32 opcode;
		__be32 status;
		union {
			struct gve_adminq_configure_device_resources configure_device_resources;
			struct gve_adminq_create_tx_queue create_tx_queue;
			struct gve_adminq_create_rx_queue create_rx_queue;
			struct gve_adminq_destroy_tx_queue destroy_tx_queue;
			struct gve_adminq_destroy_rx_queue destroy_rx_queue;
			struct gve_adminq_describe_device describe_device;
			struct gve_adminq_register_page_list reg_page_list;
			struct gve_adminq_unregister_page_list unreg_page_list;
			struct gve_adminq_set_driver_parameter set_driver_param;
			struct gve_adminq_report_stats report_stats;
			struct gve_adminq_report_link_speed report_link_speed;
			struct gve_adminq_get_ptype_map get_ptype_map;
			struct gve_adminq_verify_driver_compatibility verify_driver_compatibility;
			struct gve_adminq_query_flow_rules query_flow_rules;
			struct gve_adminq_configure_rss configure_rss;
			struct gve_adminq_query_rss query_rss;
			struct gve_adminq_extended_command extended_command;
		};
	};
	u8 reserved[64];
};

struct gve_flow_spec {
	__be32 src_ip[4];
	__be32 dst_ip[4];
	union {
		struct {
			__be16 src_port;
			__be16 dst_port;
		};
		__be32 spi;
	};
	union {
		u8 tos;
		u8 tclass;
	};
};

struct gve_adminq_flow_rule {
	__be16 flow_type;
	__be16 action;
	struct gve_flow_spec key;
	struct gve_flow_spec mask;
};

struct gve_adminq_configure_flow_rule {
	__be16 opcode;
	u8 padding[2];
	struct gve_adminq_flow_rule rule;
	__be32 location;
};

struct gve_adminq_queried_flow_rule {
	__be32 location;
	struct gve_adminq_flow_rule flow_rule;
};

struct gve_device_descriptor {
	__be64 max_registered_pages;
	__be16 reserved1;
	__be16 tx_queue_entries;
	__be16 rx_queue_entries;
	__be16 default_num_queues;
	__be16 mtu;
	__be16 counters;
	__be16 tx_pages_per_qpl;
	__be16 rx_pages_per_qpl;
	u8 mac[6];
	__be16 num_device_options;
	__be16 total_length;
	u8 reserved2[6];
};

struct gve_device_option {
	__be16 option_id;
	__be16 option_length;
	__be32 required_features_mask;
};

struct gve_device_option_buffer_sizes {
	__be32 supported_features_mask;
	__be16 packet_buffer_size;
	__be16 header_buffer_size;
};

struct gve_device_option_dqo_qpl {
	__be32 supported_features_mask;
	__be16 tx_pages_per_qpl;
	__be16 rx_pages_per_qpl;
};

struct gve_device_option_dqo_rda {
	__be32 supported_features_mask;
	__be32 reserved;
};

struct gve_device_option_flow_steering {
	__be32 supported_features_mask;
	__be32 reserved;
	__be32 max_flow_rules;
};

struct gve_device_option_gqi_qpl {
	__be32 supported_features_mask;
};

struct gve_device_option_gqi_rda {
	__be32 supported_features_mask;
};

struct gve_device_option_jumbo_frames {
	__be32 supported_features_mask;
	__be16 max_mtu;
	u8 padding[2];
};

struct gve_device_option_modify_ring {
	__be32 supported_featured_mask;
	__be16 max_rx_ring_size;
	__be16 max_tx_ring_size;
	__be16 min_rx_ring_size;
	__be16 min_tx_ring_size;
};

struct gve_device_option_rss_config {
	__be32 supported_features_mask;
	__be16 hash_key_size;
	__be16 hash_lut_size;
};

struct gve_driver_info {
	u8 os_type;
	u8 driver_major;
	u8 driver_minor;
	u8 driver_sub;
	__be32 os_version_major;
	__be32 os_version_minor;
	__be32 os_version_sub;
	__be64 driver_capability_flags[4];
	u8 os_version_str1[128];
	u8 os_version_str2[128];
};

struct gve_flow_rules_cache {
	bool rules_cache_synced;
	struct gve_adminq_queried_flow_rule *rules_cache;
	__be32 *rule_ids_cache;
	u32 rules_cache_num;
	u32 rule_ids_cache_num;
};

struct gve_header_buf {
	u8 *data;
	dma_addr_t addr;
};

struct gve_index_list {
	s16 head;
	s16 tail;
};

struct gve_irq_db {
	__be32 index;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct gve_priv;

struct gve_tx_ring;

struct gve_rx_ring;

struct gve_notify_block {
	__be32 *irq_db_index;
	char name[32];
	struct napi_struct napi;
	struct gve_priv *priv;
	struct gve_tx_ring *tx;
	struct gve_rx_ring *rx;
	u32 irq;
};

struct gve_queue_config {
	u16 max_queues;
	u16 num_queues;
};

struct msix_entry;

struct gve_registers;

struct gve_stats_report;

struct gve_ptype_lut;

struct gve_priv {
	struct net_device *dev;
	struct gve_tx_ring *tx;
	struct gve_rx_ring *rx;
	struct gve_notify_block *ntfy_blocks;
	struct gve_irq_db *irq_db_indices;
	dma_addr_t irq_db_indices_bus;
	struct msix_entry *msix_vectors;
	char mgmt_msix_name[32];
	u32 mgmt_msix_idx;
	__be32 *counter_array;
	dma_addr_t counter_array_bus;
	u16 num_event_counters;
	u16 tx_desc_cnt;
	u16 rx_desc_cnt;
	u16 max_tx_desc_cnt;
	u16 max_rx_desc_cnt;
	u16 min_tx_desc_cnt;
	u16 min_rx_desc_cnt;
	bool modify_ring_size_enabled;
	bool default_min_ring_size;
	u16 tx_pages_per_qpl;
	u64 max_registered_pages;
	u64 num_registered_pages;
	struct bpf_prog *xdp_prog;
	u32 rx_copybreak;
	u16 default_num_queues;
	u16 num_xdp_queues;
	struct gve_queue_config tx_cfg;
	struct gve_queue_config rx_cfg;
	u32 num_ntfy_blks;
	struct gve_registers *reg_bar0;
	__be32 *db_bar2;
	u32 msg_enable;
	struct pci_dev *pdev;
	u32 tx_timeo_cnt;
	union gve_adminq_command *adminq;
	dma_addr_t adminq_bus_addr;
	struct dma_pool *adminq_pool;
	struct mutex adminq_lock;
	u32 adminq_mask;
	u32 adminq_prod_cnt;
	u32 adminq_cmd_fail;
	u32 adminq_timeouts;
	u32 adminq_describe_device_cnt;
	u32 adminq_cfg_device_resources_cnt;
	u32 adminq_register_page_list_cnt;
	u32 adminq_unregister_page_list_cnt;
	u32 adminq_create_tx_queue_cnt;
	u32 adminq_create_rx_queue_cnt;
	u32 adminq_destroy_tx_queue_cnt;
	u32 adminq_destroy_rx_queue_cnt;
	u32 adminq_dcfg_device_resources_cnt;
	u32 adminq_set_driver_parameter_cnt;
	u32 adminq_report_stats_cnt;
	u32 adminq_report_link_speed_cnt;
	u32 adminq_get_ptype_map_cnt;
	u32 adminq_verify_driver_compatibility_cnt;
	u32 adminq_query_flow_rules_cnt;
	u32 adminq_cfg_flow_rule_cnt;
	u32 adminq_cfg_rss_cnt;
	u32 adminq_query_rss_cnt;
	u32 interface_up_cnt;
	u32 interface_down_cnt;
	u32 reset_cnt;
	u32 page_alloc_fail;
	u32 dma_mapping_error;
	u32 stats_report_trigger_cnt;
	u32 suspend_cnt;
	u32 resume_cnt;
	struct workqueue_struct *gve_wq;
	struct work_struct service_task;
	struct work_struct stats_report_task;
	long unsigned int service_task_flags;
	long unsigned int state_flags;
	struct gve_stats_report *stats_report;
	u64 stats_report_len;
	dma_addr_t stats_report_bus;
	long unsigned int ethtool_flags;
	long unsigned int stats_report_timer_period;
	struct timer_list stats_report_timer;
	u64 link_speed;
	bool up_before_suspend;
	struct gve_ptype_lut *ptype_lut_dqo;
	u16 data_buffer_size_dqo;
	u16 max_rx_buffer_size;
	enum gve_queue_format queue_format;
	u32 tx_coalesce_usecs;
	u32 rx_coalesce_usecs;
	u16 header_buf_size;
	bool header_split_enabled;
	u32 max_flow_rules;
	u32 num_flow_rules;
	struct gve_flow_rules_cache flow_rules_cache;
	u16 rss_key_size;
	u16 rss_lut_size;
};

struct gve_ptype {
	u8 l3_type;
	u8 l4_type;
};

struct gve_ptype_entry {
	u8 l3_type;
	u8 l4_type;
};

struct gve_ptype_lut {
	struct gve_ptype ptypes[1024];
};

struct gve_ptype_map {
	struct gve_ptype_entry ptypes[1024];
};

struct gve_query_flow_rules_descriptor {
	__be32 num_flow_rules;
	__be32 max_flow_rules;
	__be32 num_queried_rules;
	__be32 total_length;
};

struct gve_query_rss_descriptor {
	__be32 total_length;
	__be16 hash_types;
	u8 hash_alg;
	u8 reserved;
};

struct gve_queue_page_list {
	u32 id;
	u32 num_entries;
	struct page **pages;
	dma_addr_t *page_buses;
};

struct gve_queue_resources {
	union {
		struct {
			__be32 db_index;
			__be32 counter_index;
		};
		u8 reserved[64];
	};
};

struct gve_registers {
	__be32 device_status;
	__be32 driver_status;
	__be32 max_tx_queues;
	__be32 max_rx_queues;
	__be32 adminq_pfn;
	__be32 adminq_doorbell;
	__be32 adminq_event_counter;
	u8 reserved[3];
	u8 driver_version;
	__be32 adminq_base_address_hi;
	__be32 adminq_base_address_lo;
	__be16 adminq_length;
};

struct gve_rx_alloc_rings_cfg {
	struct gve_queue_config *qcfg;
	struct gve_queue_config *qcfg_tx;
	u16 ring_size;
	u16 packet_buffer_size;
	bool raw_addressing;
	bool enable_header_split;
	struct gve_rx_ring *rx;
};

struct gve_rx_desc_dqo;

struct gve_rx_buf_queue_dqo {
	struct gve_rx_desc_dqo *desc_ring;
	dma_addr_t bus;
	u32 head;
	u32 tail;
	u32 mask;
};

struct gve_rx_slot_page_info {
	struct page *page;
	void *page_address;
	u32 page_offset;
	unsigned int buf_size;
	int pagecnt_bias;
	u16 pad;
	u8 can_flip;
};

struct gve_rx_buf_state_dqo {
	struct gve_rx_slot_page_info page_info;
	dma_addr_t addr;
	u32 last_single_ref_offset;
	s16 next;
};

struct gve_rx_cnts {
	u32 ok_pkt_bytes;
	u16 ok_pkt_cnt;
	u16 total_pkt_cnt;
	u16 cont_pkt_cnt;
	u16 desc_err_pkt_cnt;
};

struct gve_rx_compl_desc_dqo {
	u8 rxdid: 4;
	u8 reserved0: 4;
	u8 loopback: 1;
	u8 ipv6_ex_add: 1;
	u8 rx_error: 1;
	u8 reserved1: 5;
	u16 packet_type: 10;
	u16 ip_hdr_err: 1;
	u16 udp_len_err: 1;
	u16 raw_cs_invalid: 1;
	u16 reserved2: 3;
	u16 packet_len: 14;
	u16 generation: 1;
	u16 buffer_queue_id: 1;
	u16 header_len: 10;
	u16 rsc: 1;
	u16 split_header: 1;
	u16 reserved3: 4;
	u8 descriptor_done: 1;
	u8 end_of_packet: 1;
	u8 header_buffer_overflow: 1;
	u8 l3_l4_processed: 1;
	u8 csum_ip_err: 1;
	u8 csum_l4_err: 1;
	u8 csum_external_ip_err: 1;
	u8 csum_external_udp_err: 1;
	u8 status_error1;
	__le16 reserved5;
	__le16 buf_id;
	union {
		__le16 raw_cs;
		__le16 rsc_seg_len;
	};
	__le32 hash;
	__le32 reserved6;
	__le64 reserved7;
};

struct gve_rx_compl_queue_dqo {
	struct gve_rx_compl_desc_dqo *desc_ring;
	dma_addr_t bus;
	int num_free_slots;
	u8 cur_gen_bit;
	u32 head;
	u32 mask;
};

struct gve_rx_ctx {
	struct sk_buff *skb_head;
	struct sk_buff *skb_tail;
	u32 total_size;
	u8 frag_cnt;
	bool drop_pkt;
};

union gve_rx_data_slot;

struct gve_rx_data_queue {
	union gve_rx_data_slot *data_ring;
	dma_addr_t data_bus;
	struct gve_rx_slot_page_info *page_info;
	struct gve_queue_page_list *qpl;
	u8 raw_addressing;
};

union gve_rx_data_slot {
	__be64 qpl_offset;
	__be64 addr;
};

struct gve_rx_desc {
	u8 padding[48];
	__be32 rss_hash;
	__be16 mss;
	__be16 reserved;
	u8 hdr_len;
	u8 hdr_off;
	__sum16 csum;
	__be16 len;
	__be16 flags_seq;
};

struct gve_rx_desc_dqo {
	__le16 buf_id;
	__le16 reserved0;
	__le32 reserved1;
	__le64 buf_addr;
	__le64 header_buf_addr;
	__le64 reserved2;
};

struct gve_rx_desc_queue {
	struct gve_rx_desc *desc_ring;
	dma_addr_t bus;
	u8 seqno;
};

struct page_frag_cache {
	long unsigned int encoded_page;
	__u32 offset;
	__u32 pagecnt_bias;
};

struct xsk_buff_pool;

struct gve_rx_ring {
	struct gve_priv *gve;
	union {
		struct {
			struct gve_rx_desc_queue desc;
			struct gve_rx_data_queue data;
			u32 db_threshold;
			u16 packet_buffer_size;
			u32 qpl_copy_pool_mask;
			u32 qpl_copy_pool_head;
			struct gve_rx_slot_page_info *qpl_copy_pool;
		};
		struct {
			struct gve_rx_buf_queue_dqo bufq;
			struct gve_rx_compl_queue_dqo complq;
			struct gve_rx_buf_state_dqo *buf_states;
			u16 num_buf_states;
			s16 free_buf_states;
			struct gve_index_list recycled_buf_states;
			struct gve_index_list used_buf_states;
			struct gve_queue_page_list *qpl;
			u32 next_qpl_page_idx;
			u16 used_buf_states_cnt;
			struct gve_header_buf hdr_bufs;
			struct page_pool *page_pool;
		} dqo;
	};
	u64 rbytes;
	u64 rx_hsplit_bytes;
	u64 rpackets;
	u32 cnt;
	u32 fill_cnt;
	u32 mask;
	u64 rx_hsplit_pkt;
	u64 rx_copybreak_pkt;
	u64 rx_copied_pkt;
	u64 rx_skb_alloc_fail;
	u64 rx_buf_alloc_fail;
	u64 rx_desc_err_dropped_pkt;
	u64 rx_hsplit_unsplit_pkt;
	u64 rx_cont_packet_cnt;
	u64 rx_frag_flip_cnt;
	u64 rx_frag_copy_cnt;
	u64 rx_frag_alloc_cnt;
	u64 xdp_tx_errors;
	u64 xdp_redirect_errors;
	u64 xdp_alloc_fails;
	u64 xdp_actions[5];
	u32 q_num;
	u32 ntfy_id;
	struct gve_queue_resources *q_resources;
	dma_addr_t q_resources_bus;
	struct u64_stats_sync statss;
	struct gve_rx_ctx ctx;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	struct xdp_rxq_info xsk_rxq;
	struct xsk_buff_pool *xsk_pool;
	struct page_frag_cache page_cache;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct stats {
	__be32 stat_name;
	__be32 queue_id;
	__be64 value;
};

struct gve_stats_report {
	__be64 written_count;
	struct stats stats[0];
};

struct gve_tx_alloc_rings_cfg {
	struct gve_queue_config *qcfg;
	u16 ring_size;
	u16 start_idx;
	u16 num_rings;
	bool raw_addressing;
	struct gve_tx_ring *tx;
};

struct gve_tx_iovec {
	u32 iov_offset;
	u32 iov_len;
	u32 iov_padding;
};

struct gve_tx_buffer_state {
	union {
		struct sk_buff *skb;
		struct xdp_frame *xdp_frame;
	};
	struct {
		u16 size;
		u8 is_xsk;
	} xdp;
	union {
		struct gve_tx_iovec iov[4];
		struct {
			dma_addr_t dma;
			__u32 len;
		};
	};
};

struct gve_tx_compl_desc {
	u16 id: 11;
	u16 type: 3;
	u16 reserved0: 1;
	u16 generation: 1;
	union {
		__le16 tx_head;
		__le16 completion_tag;
	};
	__le32 reserved1;
};

struct gve_tx_context_cmd_dtype {
	u8 dtype: 5;
	u8 tso: 1;
	u8 reserved1: 2;
	u8 reserved2;
};

struct gve_tx_pkt_desc {
	u8 type_flags;
	u8 l4_csum_offset;
	u8 l4_hdr_offset;
	u8 desc_cnt;
	__be16 len;
	__be16 seg_len;
	__be64 seg_addr;
};

struct gve_tx_mtd_desc {
	u8 type_flags;
	u8 path_state;
	__be16 reserved0;
	__be32 path_hash;
	__be64 reserved1;
};

struct gve_tx_seg_desc {
	u8 type_flags;
	u8 l3_offset;
	__be16 reserved;
	__be16 mss;
	__be16 seg_len;
	__be64 seg_addr;
};

union gve_tx_desc {
	struct gve_tx_pkt_desc pkt;
	struct gve_tx_mtd_desc mtd;
	struct gve_tx_seg_desc seg;
};

struct gve_tx_pkt_desc_dqo {
	__le64 buf_addr;
	u8 dtype: 5;
	u8 end_of_packet: 1;
	u8 checksum_offload_enable: 1;
	u8 report_event: 1;
	u8 reserved0;
	__le16 reserved1;
	__le16 compl_tag;
	u16 buf_size: 14;
	u16 reserved2: 2;
};

struct gve_tx_tso_context_desc_dqo {
	u32 tso_total_len: 24;
	u32 flex10: 8;
	u16 mss: 14;
	u16 reserved: 2;
	u8 header_len;
	u8 flex11;
	struct gve_tx_context_cmd_dtype cmd_dtype;
	u8 flex0;
	u8 flex5;
	u8 flex6;
	u8 flex7;
	u8 flex8;
	u8 flex9;
};

struct gve_tx_general_context_desc_dqo {
	u8 flex4;
	u8 flex5;
	u8 flex6;
	u8 flex7;
	u8 flex8;
	u8 flex9;
	u8 flex10;
	u8 flex11;
	struct gve_tx_context_cmd_dtype cmd_dtype;
	u16 reserved;
	u8 flex0;
	u8 flex1;
	u8 flex2;
	u8 flex3;
};

union gve_tx_desc_dqo {
	struct gve_tx_pkt_desc_dqo pkt;
	struct gve_tx_tso_context_desc_dqo tso_ctx;
	struct gve_tx_general_context_desc_dqo general_ctx;
};

struct gve_tx_fifo {
	void *base;
	u32 size;
	atomic_t available;
	u32 head;
	struct gve_queue_page_list *qpl;
};

struct gve_tx_metadata_dqo {
	union {
		struct {
			u8 version;
			u16 path_hash: 15;
			u16 rehash_event: 1;
		} __attribute__((packed));
		u8 bytes[12];
	};
};

struct gve_tx_pending_packet_dqo {
	struct sk_buff *skb;
	union {
		struct {
			dma_addr_t dma[18];
			__u32 len[18];
		};
		s16 tx_qpl_buf_ids[128];
	};
	u16 num_bufs;
	s16 next;
	s16 prev;
	u8 state;
	long unsigned int timeout_jiffies;
};

struct gve_tx_ring {
	union {
		struct {
			struct gve_tx_fifo tx_fifo;
			u32 req;
			u32 done;
		};
		struct {
			s16 free_pending_packets;
			u32 head;
			u32 tail;
			u32 last_re_idx;
			u16 posted_packet_desc_cnt;
			u16 completed_packet_desc_cnt;
			struct {
				s16 free_tx_qpl_buf_head;
				u32 alloc_tx_qpl_buf_cnt;
				u32 free_tx_qpl_buf_cnt;
			};
		} dqo_tx;
	};
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			spinlock_t clean_lock;
			spinlock_t xdp_lock;
		};
		struct {
			u32 head;
			u8 cur_gen_bit;
			atomic_t free_pending_packets;
			atomic_t hw_tx_head;
			struct gve_index_list miss_completions;
			struct gve_index_list timed_out_completions;
			struct {
				atomic_t free_tx_qpl_buf_head;
				atomic_t free_tx_qpl_buf_cnt;
			};
		} dqo_compl;
	};
	u64 pkt_done;
	u64 bytes_done;
	u64 dropped_pkt;
	u64 dma_mapping_error;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			union gve_tx_desc *desc;
			struct gve_tx_buffer_state *info;
		};
		struct {
			union gve_tx_desc_dqo *tx_ring;
			struct gve_tx_compl_desc *compl_ring;
			struct gve_tx_pending_packet_dqo *pending_packets;
			s16 num_pending_packets;
			u32 complq_mask;
			struct {
				struct gve_queue_page_list *qpl;
				s16 *tx_qpl_buf_next;
				u32 num_tx_qpl_bufs;
			};
		} dqo;
	};
	struct netdev_queue *netdev_txq;
	struct gve_queue_resources *q_resources;
	struct device *dev;
	u32 mask;
	u8 raw_addressing;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 q_num;
	u32 stop_queue;
	u32 wake_queue;
	u32 queue_timeout;
	u32 ntfy_id;
	u32 last_kick_msec;
	dma_addr_t bus;
	dma_addr_t q_resources_bus;
	dma_addr_t complq_bus_dqo;
	struct u64_stats_sync statss;
	struct xsk_buff_pool *xsk_pool;
	u32 xdp_xsk_wakeup;
	u32 xdp_xsk_done;
	u64 xdp_xsk_sent;
	u64 xdp_xmit;
	u64 xdp_xmit_errors;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

union handle_parts {
	depot_stack_handle_t handle;
	struct {
		u32 pool_index_plus_1: 17;
		u32 offset: 10;
		u32 extra: 5;
	};
};

struct handle_to_path_ctx {
	struct path root;
	enum handle_to_path_flags flags;
	unsigned int fh_flags;
};

struct handshake_net {
	spinlock_t hn_lock;
	int hn_pending;
	int hn_pending_max;
	struct list_head hn_requests;
	long unsigned int hn_flags;
};

struct handshake_req;

struct handshake_proto {
	int hp_handler_class;
	size_t hp_privsize;
	long unsigned int hp_flags;
	int (*hp_accept)(struct handshake_req *, struct genl_info *, int);
	void (*hp_done)(struct handshake_req *, unsigned int, struct genl_info *);
	void (*hp_destroy)(struct handshake_req *);
};

struct handshake_req {
	struct list_head hr_list;
	struct rhash_head hr_rhash;
	long unsigned int hr_flags;
	const struct handshake_proto *hr_proto;
	struct sock *hr_sk;
	void (*hr_odestruct)(struct sock *);
	char hr_priv[0];
};

struct hash {
	int ino;
	int minor;
	int major;
	umode_t mode;
	struct hash *next;
	char name[4098];
};

struct hash_cell {
	struct rb_node name_node;
	struct rb_node uuid_node;
	bool name_set;
	bool uuid_set;
	char *name;
	char *uuid;
	struct mapped_device *md;
	struct dm_table *new_map;
};

struct htable_gc {
	struct delayed_work dwork;
	struct ip_set *set;
	u32 region;
};

struct hash_ip4_elem {
	__be32 ip;
};

struct htable;

struct hash_ip4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	u8 netmask;
	union nf_inet_addr bitmask;
	struct list_head ad;
	struct hash_ip4_elem next;
};

struct ip_set_skbinfo {
	u32 skbmark;
	u32 skbmarkmask;
	u32 skbprio;
	u16 skbqueue;
	u16 __pad;
};

struct ip_set_ext {
	struct ip_set_skbinfo skbinfo;
	u64 packets;
	u64 bytes;
	char *comment;
	u32 timeout;
	u8 packets_op;
	u8 bytes_op;
	bool target;
};

struct hash_ip4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ip4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ip6_elem {
	union nf_inet_addr ip;
};

struct hash_ip6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	u8 netmask;
	union nf_inet_addr bitmask;
	struct list_head ad;
	struct hash_ip6_elem next;
};

struct hash_ip6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ip6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ipmac4_elem {
	__be32 ip;
	union {
		unsigned char ether[6];
		__be32 foo[2];
	};
};

struct hash_ipmac4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_ipmac4_elem next;
};

struct hash_ipmac4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ipmac4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ipmac6_elem {
	union nf_inet_addr ip;
	union {
		unsigned char ether[6];
		__be32 foo[2];
	};
};

struct hash_ipmac6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_ipmac6_elem next;
};

struct hash_ipmac6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ipmac6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ipmark4_elem {
	__be32 ip;
	__u32 mark;
};

struct hash_ipmark4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u32 markmask;
	u8 bucketsize;
	struct list_head ad;
	struct hash_ipmark4_elem next;
};

struct hash_ipmark4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ipmark4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ipmark6_elem {
	union nf_inet_addr ip;
	__u32 mark;
};

struct hash_ipmark6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u32 markmask;
	u8 bucketsize;
	struct list_head ad;
	struct hash_ipmark6_elem next;
};

struct hash_ipmark6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ipmark6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ipport4_elem {
	__be32 ip;
	__be16 port;
	u8 proto;
	u8 padding;
};

struct hash_ipport4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	u8 netmask;
	union nf_inet_addr bitmask;
	struct list_head ad;
	struct hash_ipport4_elem next;
};

struct hash_ipport4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ipport4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ipport6_elem {
	union nf_inet_addr ip;
	__be16 port;
	u8 proto;
	u8 padding;
};

struct hash_ipport6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	u8 netmask;
	union nf_inet_addr bitmask;
	struct list_head ad;
	struct hash_ipport6_elem next;
};

struct hash_ipport6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ipport6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ipportip4_elem {
	__be32 ip;
	__be32 ip2;
	__be16 port;
	u8 proto;
	u8 padding;
};

struct hash_ipportip4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_ipportip4_elem next;
};

struct hash_ipportip4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ipportip4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ipportip6_elem {
	union nf_inet_addr ip;
	union nf_inet_addr ip2;
	__be16 port;
	u8 proto;
	u8 padding;
};

struct hash_ipportip6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_ipportip6_elem next;
};

struct hash_ipportip6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ipportip6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ipportnet4_elem {
	__be32 ip;
	__be32 ip2;
	__be16 port;
	u8 cidr: 7;
	u8 nomatch: 1;
	u8 proto;
};

struct net_prefixes {
	u32 nets[1];
	u8 cidr[1];
};

struct hash_ipportnet4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_ipportnet4_elem next;
	struct net_prefixes nets[32];
};

struct hash_ipportnet4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ipportnet4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_ipportnet6_elem {
	union nf_inet_addr ip;
	union nf_inet_addr ip2;
	__be16 port;
	u8 cidr: 7;
	u8 nomatch: 1;
	u8 proto;
};

struct hash_ipportnet6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_ipportnet6_elem next;
	struct net_prefixes nets[128];
};

struct hash_ipportnet6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_ipportnet6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_mac4_elem {
	union {
		unsigned char ether[6];
		__be32 foo[2];
	};
};

struct hash_mac4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_mac4_elem next;
};

struct hash_mac4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_mac4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_net4_elem {
	__be32 ip;
	u16 padding0;
	u8 nomatch;
	u8 cidr;
};

struct hash_net4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_net4_elem next;
	struct net_prefixes nets[32];
};

struct hash_net4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_net4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_net6_elem {
	union nf_inet_addr ip;
	u16 padding0;
	u8 nomatch;
	u8 cidr;
};

struct hash_net6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_net6_elem next;
	struct net_prefixes nets[128];
};

struct hash_net6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_net6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_netiface4_elem {
	__be32 ip;
	u8 physdev;
	u8 cidr;
	u8 nomatch;
	u8 elem;
	u8 wildcard;
	char iface[16];
};

struct hash_netiface4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_netiface4_elem next;
	struct net_prefixes nets[33];
};

struct hash_netiface4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_netiface4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_netiface6_elem {
	union nf_inet_addr ip;
	u8 physdev;
	u8 cidr;
	u8 nomatch;
	u8 elem;
	u8 wildcard;
	char iface[16];
};

struct hash_netiface6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_netiface6_elem next;
	struct net_prefixes nets[129];
};

struct hash_netiface6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_netiface6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_netnet4_elem {
	union {
		__be32 ip[2];
		__be64 ipcmp;
	};
	u8 nomatch;
	u8 padding;
	union {
		u8 cidr[2];
		u16 ccmp;
	};
};

struct net_prefixes___2 {
	u32 nets[2];
	u8 cidr[2];
};

struct hash_netnet4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	u8 netmask;
	union nf_inet_addr bitmask;
	struct list_head ad;
	struct hash_netnet4_elem next;
	struct net_prefixes___2 nets[32];
};

struct hash_netnet4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_netnet4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_netnet6_elem {
	union nf_inet_addr ip[2];
	u8 nomatch;
	u8 padding;
	union {
		u8 cidr[2];
		u16 ccmp;
	};
};

struct hash_netnet6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	u8 netmask;
	union nf_inet_addr bitmask;
	struct list_head ad;
	struct hash_netnet6_elem next;
	struct net_prefixes___2 nets[128];
};

struct hash_netnet6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_netnet6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_netport4_elem {
	__be32 ip;
	__be16 port;
	u8 proto;
	u8 cidr: 7;
	u8 nomatch: 1;
};

struct hash_netport4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_netport4_elem next;
	struct net_prefixes nets[32];
};

struct hash_netport4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_netport4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_netport6_elem {
	union nf_inet_addr ip;
	__be16 port;
	u8 proto;
	u8 cidr: 7;
	u8 nomatch: 1;
};

struct hash_netport6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_netport6_elem next;
	struct net_prefixes nets[128];
};

struct hash_netport6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_netport6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_netportnet4_elem {
	union {
		__be32 ip[2];
		__be64 ipcmp;
	};
	__be16 port;
	union {
		u8 cidr[2];
		u16 ccmp;
	};
	u16 padding;
	u8 nomatch;
	u8 proto;
};

struct hash_netportnet4 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_netportnet4_elem next;
	struct net_prefixes___2 nets[33];
};

struct hash_netportnet4_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_netportnet4_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_netportnet6_elem {
	union nf_inet_addr ip[2];
	__be16 port;
	union {
		u8 cidr[2];
		u16 ccmp;
	};
	u16 padding;
	u8 nomatch;
	u8 proto;
};

struct hash_netportnet6 {
	struct htable *table;
	struct htable_gc gc;
	u32 maxelem;
	u32 initval;
	u8 bucketsize;
	struct list_head ad;
	struct hash_netportnet6_elem next;
	struct net_prefixes___2 nets[129];
};

struct hash_netportnet6_resize_ad {
	struct list_head list;
	enum ipset_adt ad;
	struct hash_netportnet6_elem d;
	struct ip_set_ext ext;
	struct ip_set_ext mext;
	u32 flags;
};

struct hash_prefix {
	const char *name;
	const u8 *data;
	size_t size;
};

struct hashlimit_cfg1 {
	__u32 mode;
	__u32 avg;
	__u32 burst;
	__u32 size;
	__u32 max;
	__u32 gc_interval;
	__u32 expire;
	__u8 srcmask;
	__u8 dstmask;
};

struct hashlimit_cfg2 {
	__u64 avg;
	__u64 burst;
	__u32 mode;
	__u32 size;
	__u32 max;
	__u32 gc_interval;
	__u32 expire;
	__u8 srcmask;
	__u8 dstmask;
};

struct hashlimit_cfg3 {
	__u64 avg;
	__u64 burst;
	__u32 mode;
	__u32 size;
	__u32 max;
	__u32 gc_interval;
	__u32 expire;
	__u32 interval;
	__u8 srcmask;
	__u8 dstmask;
};

struct hashlimit_net {
	struct hlist_head htables;
	struct proc_dir_entry *ipt_hashlimit;
	struct proc_dir_entry *ip6t_hashlimit;
};

struct mei_client_properties {
	uuid_le protocol_name;
	u8 protocol_version;
	u8 max_number_of_connections;
	u8 fixed_address;
	u8 single_recv_buf: 1;
	u8 vt_supported: 1;
	u8 reserved: 6;
	u32 max_msg_length;
};

struct hbm_add_client_request {
	u8 hbm_cmd;
	u8 me_addr;
	u8 reserved[2];
	struct mei_client_properties client_properties;
};

struct hbm_add_client_response {
	u8 hbm_cmd;
	u8 me_addr;
	u8 status;
	u8 reserved;
};

struct hbm_capability_request {
	u8 hbm_cmd;
	u8 capability_requested[3];
};

struct hbm_capability_response {
	u8 hbm_cmd;
	u8 capability_granted[3];
};

struct hbm_client_connect_request {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 reserved;
};

struct hbm_client_connect_response {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 status;
};

struct hbm_client_dma_map_request {
	u8 hbm_cmd;
	u8 client_buffer_id;
	u8 reserved[2];
	u32 address_lsb;
	u32 address_msb;
	u32 size;
};

struct hbm_client_dma_response {
	u8 hbm_cmd;
	u8 status;
};

struct hbm_client_dma_unmap_request {
	u8 hbm_cmd;
	u8 status;
	u8 client_buffer_id;
	u8 reserved;
};

struct hbm_dma_mem_dscr {
	u32 addr_hi;
	u32 addr_lo;
	u32 size;
};

struct hbm_dma_ring_ctrl {
	u32 hbuf_wr_idx;
	u32 reserved1;
	u32 hbuf_rd_idx;
	u32 reserved2;
	u32 dbuf_wr_idx;
	u32 reserved3;
	u32 dbuf_rd_idx;
	u32 reserved4;
};

struct hbm_dma_setup_request {
	u8 hbm_cmd;
	u8 reserved[3];
	struct hbm_dma_mem_dscr dma_dscr[3];
};

struct hbm_dma_setup_response {
	u8 hbm_cmd;
	u8 status;
	u8 reserved[2];
};

struct hbm_flow_control {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 reserved[5];
};

struct hbm_host_enum_request {
	u8 hbm_cmd;
	u8 flags;
	u8 reserved[2];
};

struct hbm_host_enum_response {
	u8 hbm_cmd;
	u8 reserved[3];
	u8 valid_addresses[32];
};

struct hbm_host_stop_request {
	u8 hbm_cmd;
	u8 reason;
	u8 reserved[2];
};

struct hbm_version {
	u8 minor_version;
	u8 major_version;
};

struct hbm_host_version_request {
	u8 hbm_cmd;
	u8 reserved;
	struct hbm_version host_version;
};

struct hbm_host_version_response {
	u8 hbm_cmd;
	u8 host_version_supported;
	struct hbm_version me_max_version;
};

struct hbm_notification_request {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 start;
};

struct hbm_notification_response {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 status;
	u8 start;
	u8 reserved[3];
};

struct hbm_power_gate {
	u8 hbm_cmd;
	u8 reserved[3];
};

struct hbm_props_request {
	u8 hbm_cmd;
	u8 me_addr;
	u8 reserved[2];
};

struct hbm_props_response {
	u8 hbm_cmd;
	u8 me_addr;
	u8 status;
	u8 reserved;
	struct mei_client_properties client_properties;
};

struct hbucket {
	struct callback_head rcu;
	long unsigned int used[1];
	u8 size;
	u8 pos;
	long: 0;
	unsigned char value[0];
};

struct hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	long unsigned int start;
};

struct hdcp2_tx_caps {
	u8 version;
	u8 tx_cap_mask[2];
};

struct hdcp2_ake_init {
	u8 msg_id;
	u8 r_tx[8];
	struct hdcp2_tx_caps tx_caps;
};

struct hdcp2_ake_no_stored_km {
	u8 msg_id;
	u8 e_kpub_km[128];
};

struct hdcp2_cert_rx {
	u8 receiver_id[5];
	u8 kpub_rx[131];
	u8 reserved[2];
	u8 dcp_signature[384];
};

struct hdcp2_ake_send_cert {
	u8 msg_id;
	struct hdcp2_cert_rx cert_rx;
	u8 r_rx[8];
	u8 rx_caps[3];
};

struct hdcp2_ake_send_hprime {
	u8 msg_id;
	u8 h_prime[32];
};

struct hdcp2_ake_send_pairing_info {
	u8 msg_id;
	u8 e_kh_km[16];
};

struct hdcp2_dp_errata_stream_type {
	u8 msg_id;
	u8 stream_type;
};

struct hdcp2_dp_msg_data {
	u8 msg_id;
	u32 offset;
	bool msg_detectable;
	u32 timeout;
	u32 timeout2;
	u32 msg_read_timeout;
};

struct hdcp2_hdmi_msg_timeout {
	u8 msg_id;
	u16 timeout;
};

struct hdcp2_lc_init {
	u8 msg_id;
	u8 r_n[8];
};

struct hdcp2_lc_send_lprime {
	u8 msg_id;
	u8 l_prime[32];
};

struct hdcp2_rep_send_ack {
	u8 msg_id;
	u8 v[16];
};

struct hdcp2_rep_send_receiverid_list {
	u8 msg_id;
	u8 rx_info[2];
	u8 seq_num_v[3];
	u8 v_prime[16];
	u8 receiver_ids[155];
};

struct hdcp2_streamid_type {
	u8 stream_id;
	u8 stream_type;
};

struct hdcp2_rep_stream_manage {
	u8 msg_id;
	u8 seq_num_m[3];
	__be16 k;
	struct hdcp2_streamid_type streams[4];
};

struct hdcp2_rep_stream_ready {
	u8 msg_id;
	u8 m_prime[32];
};

struct hdcp2_ske_send_eks {
	u8 msg_id;
	u8 e_dkey_ks[16];
	u8 riv[8];
};

struct hdcp_cmd_header {
	u32 api_version;
	u32 command_id;
	enum fw_hdcp_status status;
	u32 buffer_len;
};

struct hdcp_port_data {
	enum hdcp_ddi hdcp_ddi;
	enum hdcp_transcoder hdcp_transcoder;
	u8 port_type;
	u8 protocol;
	u16 k;
	u32 seq_num_m;
	struct hdcp2_streamid_type *streams;
};

struct hdcp_port_id {
	u8 integrated_port_type;
	u8 physical_port;
	u8 attached_transcoder;
	u8 reserved;
};

struct hdcp_srm_header {
	u8 srm_id;
	u8 reserved;
	__be16 srm_version;
	u8 srm_gen_no;
} __attribute__((packed));

struct hdmi_aud_ncts {
	int sample_rate;
	int clock;
	int n;
	int cts;
};

struct hdr_metadata_infoframe {
	__u8 eotf;
	__u8 metadata_type;
	struct {
		__u16 x;
		__u16 y;
	} display_primaries[3];
	struct {
		__u16 x;
		__u16 y;
	} white_point;
	__u16 max_display_mastering_luminance;
	__u16 min_display_mastering_luminance;
	__u16 max_cll;
	__u16 max_fall;
};

struct hdr_output_metadata {
	__u32 metadata_type;
	union {
		struct hdr_metadata_infoframe hdmi_metadata_type1;
	};
};

struct hh_cache;

struct header_ops {
	int (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff *);
};

struct heuristic_ws {
	u8 *sample;
	u32 sample_size;
	struct bucket_item *bucket;
	struct bucket_item *bucket_b;
	struct list_head list;
};

struct internal_sc {
	u64 sm1;
	u64 ism1;
	u64 dx;
	u64 dy;
	u64 sm2;
	u64 ism2;
};

struct runtime_sc {
	u64 x;
	u64 y;
	u64 sm1;
	u64 ism1;
	u64 dx;
	u64 dy;
	u64 sm2;
	u64 ism2;
};

struct hfsc_sched;

struct hfsc_class {
	struct Qdisc_class_common cl_common;
	long: 64;
	struct gnet_stats_basic_sync bstats;
	struct gnet_stats_queue qstats;
	struct net_rate_estimator *rate_est;
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	unsigned int level;
	struct hfsc_sched *sched;
	struct hfsc_class *cl_parent;
	struct list_head siblings;
	struct list_head children;
	struct Qdisc *qdisc;
	struct rb_node el_node;
	struct rb_root vt_tree;
	struct rb_node vt_node;
	struct rb_root cf_tree;
	struct rb_node cf_node;
	u64 cl_total;
	u64 cl_cumul;
	u64 cl_d;
	u64 cl_e;
	u64 cl_vt;
	u64 cl_f;
	u64 cl_myf;
	u64 cl_cfmin;
	u64 cl_cvtmin;
	u64 cl_vtadj;
	u64 cl_cvtoff;
	struct internal_sc cl_rsc;
	struct internal_sc cl_fsc;
	struct internal_sc cl_usc;
	struct runtime_sc cl_deadline;
	struct runtime_sc cl_eligible;
	struct runtime_sc cl_virtual;
	struct runtime_sc cl_ulimit;
	u8 cl_flags;
	u32 cl_vtperiod;
	u32 cl_parentperiod;
	u32 cl_nactive;
};

struct hfsc_sched {
	u16 defcls;
	long: 64;
	struct hfsc_class root;
	struct Qdisc_class_hash clhash;
	struct rb_root eligible;
	struct qdisc_watchdog watchdog;
	long: 64;
};

struct hh_cache {
	unsigned int hh_len;
	seqlock_t hh_lock;
	long unsigned int hh_data[4];
};

struct hh_flow_state {
	u32 hash_id;
	u32 hit_timestamp;
	struct list_head flowchain;
};

struct wdrr_bucket {
	struct sk_buff *head;
	struct sk_buff *tail;
	struct list_head bucketchain;
	int deficit;
};

struct hhf_sched_data {
	struct wdrr_bucket buckets[2];
	siphash_key_t perturbation;
	u32 quantum;
	u32 drop_overlimit;
	struct list_head *hh_flows;
	u32 hh_flows_limit;
	u32 hh_flows_overlimit;
	u32 hh_flows_total_cnt;
	u32 hh_flows_current_cnt;
	u32 *hhf_arrays[4];
	u32 hhf_arrays_reset_timestamp;
	long unsigned int *hhf_valid_bits[4];
	struct list_head new_buckets;
	struct list_head old_buckets;
	u32 hhf_reset_timeout;
	u32 hhf_admit_bytes;
	u32 hhf_evict_timeout;
	u32 hhf_non_hh_weight;
};

struct hib_bio_batch {
	atomic_t count;
	wait_queue_head_t wait;
	blk_status_t error;
	struct blk_plug plug;
};

struct hlist_bl_head {
	struct hlist_bl_node *first;
};

struct hmac_ctx {
	struct crypto_shash *hash;
	u8 pads[0];
};

union hmark_ports {
	struct {
		__u16 src;
		__u16 dst;
	} p16;
	struct {
		__be16 src;
		__be16 dst;
	} b16;
	__u32 v32;
	__be32 b32;
};

struct hmark_tuple {
	__be32 src;
	__be32 dst;
	union hmark_ports uports;
	u8 proto;
};

struct hop_jumbo_hdr {
	u8 nexthdr;
	u8 hdrlen;
	u8 tlv_type;
	u8 tlv_len;
	__be32 jumbo_payload_len;
};

struct hotplug_slot_ops;

struct pci_slot;

struct hotplug_slot {
	const struct hotplug_slot_ops *ops;
	struct list_head slot_list;
	struct pci_slot *pci_slot;
	struct module *owner;
	const char *mod_name;
};

struct hotplug_slot_ops {
	int (*enable_slot)(struct hotplug_slot *);
	int (*disable_slot)(struct hotplug_slot *);
	int (*set_attention_status)(struct hotplug_slot *, u8);
	int (*hardware_test)(struct hotplug_slot *, u32);
	int (*get_power_status)(struct hotplug_slot *, u8 *);
	int (*get_attention_status)(struct hotplug_slot *, u8 *);
	int (*get_latch_status)(struct hotplug_slot *, u8 *);
	int (*get_adapter_status)(struct hotplug_slot *, u8 *);
	int (*reset_slot)(struct hotplug_slot *, bool);
};

struct housekeeping {
	struct cpumask cpumasks[3];
	long unsigned int flags;
};

struct hpet_timer {
	u64 hpet_config;
	union {
		u64 _hpet_hc64;
		u32 _hpet_hc32;
		long unsigned int _hpet_compare;
	} _u1;
	u64 hpet_fsb[2];
};

struct hpet {
	u64 hpet_cap;
	u64 res0;
	u64 hpet_config;
	u64 res1;
	u64 hpet_isr;
	u64 res2[25];
	union {
		u64 _hpet_mc64;
		u32 _hpet_mc32;
		long unsigned int _hpet_mc;
	} _u0;
	u64 res3;
	struct hpet_timer hpet_timers[0];
};

struct hpet_channel;

struct hpet_base {
	unsigned int nr_channels;
	unsigned int nr_clockevents;
	unsigned int boot_cfg;
	struct hpet_channel *channels;
};

struct hpet_channel {
	struct clock_event_device evt;
	unsigned int num;
	unsigned int cpu;
	unsigned int irq;
	unsigned int in_use;
	enum hpet_mode mode;
	unsigned int boot_cfg;
	char name[10];
	long: 64;
	long: 64;
	long: 64;
};

struct hpet_data {
	long unsigned int hd_phys_address;
	void *hd_address;
	short unsigned int hd_nirqs;
	unsigned int hd_state;
	unsigned int hd_irq[32];
};

struct hpets;

struct hpet_dev {
	struct hpets *hd_hpets;
	struct hpet *hd_hpet;
	struct hpet_timer *hd_timer;
	long unsigned int hd_ireqfreq;
	long unsigned int hd_irqdata;
	wait_queue_head_t hd_waitqueue;
	struct fasync_struct *hd_async_queue;
	unsigned int hd_flags;
	unsigned int hd_irq;
	unsigned int hd_hdwirq;
	char hd_name[7];
};

struct hpet_info {
	long unsigned int hi_ireqfreq;
	long unsigned int hi_flags;
	short unsigned int hi_hpet;
	short unsigned int hi_timer;
};

union hpet_lock {
	struct {
		arch_spinlock_t lock;
		u32 value;
	};
	u64 lockval;
};

struct hpets {
	struct hpets *hp_next;
	struct hpet *hp_hpet;
	long unsigned int hp_hpet_phys;
	long long unsigned int hp_tick_freq;
	long unsigned int hp_delta;
	unsigned int hp_ntimer;
	unsigned int hp_which;
	struct hpet_dev hp_dev[0];
};

struct hprobe {
	enum hprobe_state state;
	int srcu_idx;
	struct uprobe *uprobe;
};

struct hpx_type0 {
	u32 revision;
	u8 cache_line_size;
	u8 latency_timer;
	u8 enable_serr;
	u8 enable_perr;
};

struct hpx_type1 {
	u32 revision;
	u8 max_mem_read;
	u8 avg_max_split;
	u16 tot_max_split;
};

struct hpx_type2 {
	u32 revision;
	u32 unc_err_mask_and;
	u32 unc_err_mask_or;
	u32 unc_err_sever_and;
	u32 unc_err_sever_or;
	u32 cor_err_mask_and;
	u32 cor_err_mask_or;
	u32 adv_err_cap_and;
	u32 adv_err_cap_or;
	u16 pci_exp_devctl_and;
	u16 pci_exp_devctl_or;
	u16 pci_exp_lnkctl_and;
	u16 pci_exp_lnkctl_or;
	u32 sec_unc_err_sever_and;
	u32 sec_unc_err_sever_or;
	u32 sec_unc_err_mask_and;
	u32 sec_unc_err_mask_or;
};

struct hpx_type3 {
	u16 device_type;
	u16 function_type;
	u16 config_space_location;
	u16 pci_exp_cap_id;
	u16 pci_exp_cap_ver;
	u16 pci_exp_vendor_id;
	u16 dvsec_id;
	u16 dvsec_rev;
	u16 match_offset;
	u32 match_mask_and;
	u32 match_value;
	u16 reg_offset;
	u32 reg_mask_and;
	u32 reg_mask_or;
};

struct seqcount_raw_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;

struct hrtimer_cpu_base;

struct hrtimer_clock_base {
	struct hrtimer_cpu_base *cpu_base;
	unsigned int index;
	clockid_t clockid;
	seqcount_raw_spinlock_t seq;
	struct hrtimer *running;
	struct timerqueue_head active;
	ktime_t (*get_time)(void);
	ktime_t offset;
};

struct hrtimer_cpu_base {
	raw_spinlock_t lock;
	unsigned int cpu;
	unsigned int active_bases;
	unsigned int clock_was_set_seq;
	unsigned int hres_active: 1;
	unsigned int in_hrtirq: 1;
	unsigned int hang_detected: 1;
	unsigned int softirq_activated: 1;
	unsigned int online: 1;
	unsigned int nr_events;
	short unsigned int nr_retries;
	short unsigned int nr_hangs;
	unsigned int max_hang_time;
	ktime_t expires_next;
	struct hrtimer *next_timer;
	ktime_t softirq_expires_next;
	struct hrtimer *softirq_next_timer;
	struct hrtimer_clock_base clock_base[8];
	call_single_data_t csd;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct hrtimer_sleeper {
	struct hrtimer timer;
	struct task_struct *task;
};

struct hs_primary_descriptor {
	__u8 foo[8];
	__u8 type[1];
	__u8 id[5];
	__u8 version[1];
	__u8 unused1[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 unused3[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 unused4[28];
	__u8 root_directory_record[34];
};

struct hs_volume_descriptor {
	__u8 foo[8];
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 data[2033];
};

struct hsr_tag {
	__be16 path_and_LSDU_size;
	__be16 sequence_nr;
	__be16 encap_proto;
};

struct hsr_ethhdr {
	struct ethhdr ethhdr;
	struct hsr_tag hsr_tag;
};

struct hsr_port;

struct hsr_node;

struct hsr_frame_info {
	struct sk_buff *skb_std;
	struct sk_buff *skb_hsr;
	struct sk_buff *skb_prp;
	struct hsr_port *port_rcv;
	struct hsr_node *node_src;
	u16 sequence_nr;
	bool is_supervision;
	bool is_proxy_supervision;
	bool is_vlan;
	bool is_local_dest;
	bool is_local_exclusive;
	bool is_from_san;
};

struct hsr_node {
	struct list_head mac_list;
	spinlock_t seq_out_lock;
	unsigned char macaddress_A[6];
	unsigned char macaddress_B[6];
	enum hsr_port_type addr_B_port;
	long unsigned int time_in[5];
	bool time_in_stale[5];
	long unsigned int time_out[5];
	bool san_a;
	bool san_b;
	u16 seq_out[5];
	bool removed;
	struct callback_head callback_head;
};

struct hsr_priv;

struct hsr_port {
	struct list_head port_list;
	struct net_device *dev;
	struct hsr_priv *hsr;
	enum hsr_port_type type;
	struct callback_head rcu;
};

struct hsr_self_node;

struct hsr_proto_ops;

struct hsr_priv {
	struct callback_head callback_head;
	struct list_head ports;
	struct list_head node_db;
	struct list_head proxy_node_db;
	struct hsr_self_node *self_node;
	struct timer_list announce_timer;
	struct timer_list announce_proxy_timer;
	struct timer_list prune_timer;
	struct timer_list prune_proxy_timer;
	int announce_count;
	u16 sequence_nr;
	u16 sup_sequence_nr;
	enum hsr_version prot_version;
	spinlock_t seqnr_lock;
	spinlock_t list_lock;
	struct hsr_proto_ops *proto_ops;
	u8 net_id;
	bool fwd_offloaded;
	bool redbox;
	unsigned char macaddress_redbox[6];
	short: 0;
	unsigned char sup_multicast_addr[6];
	struct dentry *node_tbl_root;
};

struct hsr_proto_ops {
	void (*send_sv_frame)(struct hsr_port *, long unsigned int *, const unsigned char *);
	void (*handle_san_frame)(bool, enum hsr_port_type, struct hsr_node *);
	bool (*drop_frame)(struct hsr_frame_info *, struct hsr_port *);
	struct sk_buff * (*get_untagged_frame)(struct hsr_frame_info *, struct hsr_port *);
	struct sk_buff * (*create_tagged_frame)(struct hsr_frame_info *, struct hsr_port *);
	int (*fill_frame_info)(__be16, struct sk_buff *, struct hsr_frame_info *);
	bool (*invalid_dan_ingress_frame)(__be16);
	void (*update_san_info)(struct hsr_node *, bool);
};

struct hsr_self_node {
	unsigned char macaddress_A[6];
	unsigned char macaddress_B[6];
	struct callback_head callback_head;
};

struct hsr_sup_payload {
	unsigned char macaddress_A[6];
};

struct hsr_sup_tlv {
	u8 HSR_TLV_type;
	u8 HSR_TLV_length;
};

struct hsr_sup_tag {
	__be16 path_and_HSR_ver;
	__be16 sequence_nr;
	struct hsr_sup_tlv tlv;
};

struct vlan_ethhdr {
	union {
		struct {
			unsigned char h_dest[6];
			unsigned char h_source[6];
		};
		struct {
			unsigned char h_dest[6];
			unsigned char h_source[6];
		} addrs;
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct hsr_vlan_ethhdr {
	struct vlan_ethhdr vlanhdr;
	struct hsr_tag hsr_tag;
};

struct hsrv0_ethhdr_sp {
	struct ethhdr ethhdr;
	struct hsr_sup_tag hsr_sup;
};

struct hsrv1_ethhdr_sp {
	struct ethhdr ethhdr;
	struct hsr_tag hsr;
	struct hsr_sup_tag hsr_sup;
};

struct hstate {
	struct mutex resize_lock;
	struct lock_class_key resize_key;
	int next_nid_to_alloc;
	int next_nid_to_free;
	unsigned int order;
	unsigned int demote_order;
	long unsigned int mask;
	long unsigned int max_huge_pages;
	long unsigned int nr_huge_pages;
	long unsigned int free_huge_pages;
	long unsigned int resv_huge_pages;
	long unsigned int surplus_huge_pages;
	long unsigned int nr_overcommit_huge_pages;
	struct list_head hugepage_activelist;
	struct list_head hugepage_freelists[64];
	unsigned int max_huge_pages_node[64];
	unsigned int nr_huge_pages_node[64];
	unsigned int free_huge_pages_node[64];
	unsigned int surplus_huge_pages_node[64];
	char name[32];
};

struct hstcp {
	u32 ai;
};

struct hstcp_aimd_val {
	unsigned int cwnd;
	unsigned int md;
};

struct hsu_dma_chan;

struct hsu_dma {
	struct dma_device dma;
	struct hsu_dma_chan *chan;
	short unsigned int nr_channels;
};

struct virt_dma_desc;

struct virt_dma_chan {
	struct dma_chan chan;
	struct tasklet_struct task;
	void (*desc_free)(struct virt_dma_desc *);
	spinlock_t lock;
	struct list_head desc_allocated;
	struct list_head desc_submitted;
	struct list_head desc_issued;
	struct list_head desc_completed;
	struct list_head desc_terminated;
	struct virt_dma_desc *cyclic;
};

struct hsu_dma_desc;

struct hsu_dma_chan {
	struct virt_dma_chan vchan;
	void *reg;
	enum dma_transfer_direction direction;
	struct dma_slave_config config;
	struct hsu_dma_desc *desc;
};

struct hsu_dma_chip {
	struct device *dev;
	int irq;
	void *regs;
	unsigned int length;
	unsigned int offset;
	struct hsu_dma *hsu;
};

struct virt_dma_desc {
	struct dma_async_tx_descriptor tx;
	struct dmaengine_result tx_result;
	struct list_head node;
};

struct hsu_dma_sg;

struct hsu_dma_desc {
	struct virt_dma_desc vdesc;
	enum dma_transfer_direction direction;
	struct hsu_dma_sg *sg;
	unsigned int nents;
	size_t length;
	unsigned int active;
	enum dma_status status;
};

struct hsu_dma_sg {
	dma_addr_t addr;
	unsigned int len;
};

struct hsu_dma_slave {
	struct device *dma_dev;
	int chan_id;
};

struct hsw_ddi_buf_trans {
	u32 trans1;
	u32 trans2;
	u8 i_boost;
};

union hsw_tsx_tuning {
	struct {
		u32 cycles_last_block: 32;
		u32 hle_abort: 1;
		u32 rtm_abort: 1;
		u32 instruction_abort: 1;
		u32 non_instruction_abort: 1;
		u32 retry: 1;
		u32 data_conflict: 1;
		u32 capacity_writes: 1;
		u32 capacity_reads: 1;
	};
	u64 value;
};

struct hsw_wrpll_rnp {
	unsigned int p;
	unsigned int n2;
	unsigned int r2;
};

struct pcpu_freelist_node {
	struct pcpu_freelist_node *next;
};

struct htab_elem {
	union {
		struct hlist_nulls_node hash_node;
		struct {
			void *padding;
			union {
				struct pcpu_freelist_node fnode;
				struct htab_elem *batch_flink;
			};
		};
	};
	union {
		void *ptr_to_pptr;
		struct bpf_lru_node lru_node;
	};
	u32 hash;
	long: 0;
	char key[0];
};

struct ip_set_region;

struct htable {
	atomic_t ref;
	atomic_t uref;
	u8 htable_bits;
	u32 maxelem;
	struct ip_set_region *hregion;
	struct hbucket *bucket[0];
};

struct psched_ratecfg {
	u64 rate_bytes_ps;
	u32 mult;
	u16 overhead;
	u16 mpu;
	u8 linklayer;
	u8 shift;
};

struct tc_htb_xstats {
	__u32 lends;
	__u32 borrows;
	__u32 giants;
	__s32 tokens;
	__s32 ctokens;
};

struct htb_class_leaf {
	int deficit[8];
	struct Qdisc *q;
	struct netdev_queue *offload_queue;
};

struct htb_prio {
	union {
		struct rb_root row;
		struct rb_root feed;
	};
	struct rb_node *ptr;
	u32 last_ptr_id;
};

struct htb_class_inner {
	struct htb_prio clprio[8];
};

struct htb_class {
	struct Qdisc_class_common common;
	struct psched_ratecfg rate;
	struct psched_ratecfg ceil;
	s64 buffer;
	s64 cbuffer;
	s64 mbuffer;
	u32 prio;
	int quantum;
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	int level;
	unsigned int children;
	struct htb_class *parent;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_sync bstats;
	struct gnet_stats_basic_sync bstats_bias;
	struct tc_htb_xstats xstats;
	s64 tokens;
	s64 ctokens;
	s64 t_c;
	union {
		struct htb_class_leaf leaf;
		struct htb_class_inner inner;
	};
	s64 pq_key;
	int prio_activity;
	enum htb_cmode cmode;
	struct rb_node pq_node;
	struct rb_node node[8];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int drops;
	unsigned int overlimits;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct htb_level {
	struct rb_root wait_pq;
	struct htb_prio hprio[8];
};

struct htb_sched {
	struct Qdisc_class_hash clhash;
	int defcls;
	int rate2quantum;
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	unsigned int warned;
	int direct_qlen;
	struct work_struct work;
	struct qdisc_skb_head direct_queue;
	u32 direct_pkts;
	u32 overlimits;
	struct qdisc_watchdog watchdog;
	s64 now;
	s64 near_ev_cache[8];
	int row_mask[8];
	struct htb_level hlevel[8];
	struct Qdisc **direct_qdiscs;
	unsigned int num_direct_qdiscs;
	bool offload;
};

struct htcp {
	u32 alpha;
	u8 beta;
	u8 modeswitch;
	u16 pkts_acked;
	u32 packetcount;
	u32 minRTT;
	u32 maxRTT;
	u32 last_cong;
	u32 undo_last_cong;
	u32 undo_maxRTT;
	u32 undo_old_maxB;
	u32 minB;
	u32 maxB;
	u32 old_maxB;
	u32 Bi;
	u32 lasttime;
};

struct huge_bootmem_page {
	struct list_head list;
	struct hstate *hstate;
};

struct hugepage_subpool {
	spinlock_t lock;
	long int count;
	long int max_hpages;
	long int used_hpages;
	struct hstate *hstate;
	long int min_hpages;
	long int rsv_hpages;
};

struct page_counter {
	atomic_long_t usage;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad1_;
	long unsigned int emin;
	atomic_long_t min_usage;
	atomic_long_t children_min_usage;
	long unsigned int elow;
	atomic_long_t low_usage;
	atomic_long_t children_low_usage;
	long unsigned int watermark;
	long unsigned int local_watermark;
	long unsigned int failcnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad2_;
	bool protection_support;
	long unsigned int min;
	long unsigned int low;
	long unsigned int high;
	long unsigned int max;
	struct page_counter *parent;
	long: 64;
	long: 64;
};

struct hugetlb_cgroup_per_node;

struct hugetlb_cgroup {
	struct cgroup_subsys_state css;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct page_counter hugepage[2];
	struct page_counter rsvd_hugepage[2];
	atomic_long_t events[2];
	atomic_long_t events_local[2];
	struct cgroup_file events_file[2];
	struct cgroup_file events_local_file[2];
	struct hugetlb_cgroup_per_node *nodeinfo[0];
};

struct hugetlb_cgroup_per_node {
	long unsigned int usage[2];
};

struct hugetlb_vma_lock {
	struct kref refs;
	struct rw_semaphore rw_sema;
	struct vm_area_struct *vma;
};

struct hugetlbfs_fs_context {
	struct hstate *hstate;
	long long unsigned int max_size_opt;
	long long unsigned int min_size_opt;
	long int max_hpages;
	long int nr_inodes;
	long int min_hpages;
	enum hugetlbfs_size_type max_val_type;
	enum hugetlbfs_size_type min_val_type;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct hugetlbfs_inode_info {
	struct inode vfs_inode;
	unsigned int seals;
};

struct hugetlbfs_sb_info {
	long int max_inodes;
	long int free_inodes;
	spinlock_t stat_lock;
	struct hstate *hstate;
	struct hugepage_subpool *spool;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

union hv_hypervisor_version_info {
	struct {
		u32 build_number;
		u32 minor_version: 16;
		u32 major_version: 16;
		u32 service_pack;
		u32 service_number: 24;
		u32 service_branch: 8;
	};
	struct {
		u32 eax;
		u32 ebx;
		u32 ecx;
		u32 edx;
	};
};

union hv_message_flags {
	u8 asu8;
	struct {
		u8 msg_pending: 1;
		u8 reserved: 7;
	};
};

union hv_port_id {
	u32 asu32;
	struct {
		u32 id: 24;
		u32 reserved: 8;
	} u;
};

struct hv_message_header {
	u32 message_type;
	u8 payload_size;
	union hv_message_flags message_flags;
	u8 reserved[2];
	union {
		u64 sender;
		union hv_port_id port;
	};
};

struct hv_message {
	struct hv_message_header header;
	union {
		u64 payload[30];
	} u;
};

struct hv_nested_enlightenments_control {
	struct {
		u32 directhypercall: 1;
		u32 reserved: 31;
	} features;
	struct {
		u32 inter_partition_comm: 1;
		u32 reserved: 31;
	} hypercall_controls;
};

struct hv_ops {
	ssize_t (*get_chars)(uint32_t, u8 *, size_t);
	ssize_t (*put_chars)(uint32_t, const u8 *, size_t);
	int (*flush)(uint32_t, bool);
	int (*notifier_add)(struct hvc_struct *, int);
	void (*notifier_del)(struct hvc_struct *, int);
	void (*notifier_hangup)(struct hvc_struct *, int);
	int (*tiocmget)(struct hvc_struct *);
	int (*tiocmset)(struct hvc_struct *, unsigned int, unsigned int);
	void (*dtr_rts)(struct hvc_struct *, bool);
};

union hv_stimer_config {
	u64 as_uint64;
	struct {
		u64 enable: 1;
		u64 periodic: 1;
		u64 lazy: 1;
		u64 auto_enable: 1;
		u64 apic_vector: 8;
		u64 direct_mode: 1;
		u64 reserved_z0: 3;
		u64 sintx: 4;
		u64 reserved_z1: 44;
	};
};

struct hv_vp_assist_page {
	u32 apic_assist;
	u32 reserved1;
	u32 vtl_entry_reason;
	u32 vtl_reserved;
	u64 vtl_ret_x64rax;
	u64 vtl_ret_x64rcx;
	struct hv_nested_enlightenments_control nested_control;
	u8 enlighten_vmentry;
	u8 reserved2[7];
	u64 current_nested_vmcs;
	u8 synthetic_time_unhalted_timer_expired;
	u8 reserved3[7];
	u8 virtualization_fault_information[40];
	u8 reserved4[8];
	u8 intercept_message[256];
	u8 vtl_ret_actions[256];
};

struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	unsigned int used;
	unsigned int size;
	unsigned int commit;
	unsigned int lookahead;
	unsigned int read;
	bool flags;
	long: 0;
	u8 data[0];
};

struct tty_bufhead {
	struct tty_buffer *head;
	struct work_struct work;
	struct mutex lock;
	atomic_t priority;
	struct tty_buffer sentinel;
	struct llist_head free;
	atomic_t mem_used;
	int mem_limit;
	struct tty_buffer *tail;
};

struct tty_struct;

struct tty_port_operations;

struct tty_port_client_operations;

struct tty_port {
	struct tty_bufhead buf;
	struct tty_struct *tty;
	struct tty_struct *itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t lock;
	int blocked_open;
	int count;
	wait_queue_head_t open_wait;
	wait_queue_head_t delta_msr_wait;
	long unsigned int flags;
	long unsigned int iflags;
	unsigned char console: 1;
	struct mutex mutex;
	struct mutex buf_mutex;
	u8 *xmit_buf;
	struct {
		union {
			struct __kfifo kfifo;
			u8 *type;
			const u8 *const_type;
			char (*rectype)[0];
			u8 *ptr;
			const u8 *ptr_const;
		};
		u8 buf[0];
	} xmit_fifo;
	unsigned int close_delay;
	unsigned int closing_wait;
	int drain_delay;
	struct kref kref;
	void *client_data;
};

struct hvc_struct {
	struct tty_port port;
	spinlock_t lock;
	int index;
	int do_wakeup;
	int outbuf_size;
	int n_outbuf;
	uint32_t vtermno;
	const struct hv_ops *ops;
	int irq_requested;
	int data;
	struct winsize ws;
	struct work_struct tty_resize;
	struct list_head next;
	long unsigned int flags;
	u8 outbuf[0];
};

struct hvm_memmap_table_entry {
	uint64_t addr;
	uint64_t size;
	uint32_t type;
	uint32_t reserved;
};

struct hvm_modlist_entry {
	uint64_t paddr;
	uint64_t size;
	uint64_t cmdline_paddr;
	uint64_t reserved;
};

struct hvm_start_info {
	uint32_t magic;
	uint32_t version;
	uint32_t flags;
	uint32_t nr_modules;
	uint64_t modlist_paddr;
	uint64_t cmdline_paddr;
	uint64_t rsdp_paddr;
	uint64_t memmap_paddr;
	uint32_t memmap_entries;
	uint32_t reserved;
};

struct hw_perf_event_extra {
	u64 config;
	unsigned int reg;
	int alloc;
	int idx;
};

struct rhlist_head {
	struct rhash_head rhead;
	struct rhlist_head *next;
};

struct hw_perf_event {
	union {
		struct {
			u64 config;
			u64 last_tag;
			long unsigned int config_base;
			long unsigned int event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			u64 aux_config;
			unsigned int aux_paused;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			struct arch_hw_breakpoint info;
			struct rhlist_head bp_list;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct *target;
	void *addr_filters;
	long unsigned int addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

struct hw_port_info {
	struct net_device *lower_dev;
	u32 port_id;
};

struct hwlat_entry {
	struct trace_entry ent;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	unsigned int nmi_count;
	unsigned int seqnum;
	unsigned int count;
};

struct hwm_energy_info {
	u32 reg_val_prev;
	long int accum_energy;
};

struct hwm_fan_info {
	u32 reg_val_prev;
	u64 time_prev;
};

struct hwm_drvdata {
	struct i915_hwmon *hwmon;
	struct intel_uncore *uncore;
	struct device *hwmon_dev;
	struct hwm_energy_info ei;
	struct hwm_fan_info fi;
	char name[12];
	int gt_n;
	bool reset_in_progress;
	wait_queue_head_t waitq;
};

struct hwm_reg {
	i915_reg_t gt_perf_status;
	i915_reg_t pkg_temp;
	i915_reg_t pkg_power_sku_unit;
	i915_reg_t pkg_power_sku;
	i915_reg_t pkg_rapl_limit;
	i915_reg_t energy_status_all;
	i915_reg_t energy_status_tile;
	i915_reg_t fan_speed;
};

struct hwmon_channel_info {
	enum hwmon_sensor_types type;
	const u32 *config;
};

struct hwmon_ops;

struct hwmon_chip_info {
	const struct hwmon_ops *ops;
	const struct hwmon_channel_info * const *info;
};

struct hwmon_device {
	const char *name;
	const char *label;
	struct device dev;
	const struct hwmon_chip_info *chip;
	struct list_head tzdata;
	struct attribute_group group;
	const struct attribute_group **groups;
};

struct hwmon_device_attribute {
	struct device_attribute dev_attr;
	const struct hwmon_ops *ops;
	enum hwmon_sensor_types type;
	u32 attr;
	int index;
	char name[32];
};

struct hwmon_ops {
	umode_t visible;
	umode_t (*is_visible)(const void *, enum hwmon_sensor_types, u32, int);
	int (*read)(struct device *, enum hwmon_sensor_types, u32, int, long int *);
	int (*read_string)(struct device *, enum hwmon_sensor_types, u32, int, const char **);
	int (*write)(struct device *, enum hwmon_sensor_types, u32, int, long int);
};

struct hwmon_thermal_data {
	struct list_head node;
	struct device *dev;
	int index;
	struct thermal_zone_device *tzd;
};

struct hwmon_type_attr_list {
	const u32 *attrs;
	size_t n_attrs;
};

struct hwrng {
	const char *name;
	int (*init)(struct hwrng *);
	void (*cleanup)(struct hwrng *);
	int (*data_present)(struct hwrng *, int);
	int (*data_read)(struct hwrng *, u32 *);
	int (*read)(struct hwrng *, void *, size_t, bool);
	long unsigned int priv;
	short unsigned int quality;
	struct list_head list;
	struct kref ref;
	struct completion cleanup_done;
	struct completion dying;
};

struct hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
};

struct hwtstamp_provider_desc {
	int index;
	enum hwtstamp_provider_qualifier qualifier;
};

struct hwtstamp_provider {
	struct callback_head callback_head;
	enum hwtstamp_source source;
	struct phy_device *phydev;
	struct hwtstamp_provider_desc desc;
};

struct hybla {
	bool hybla_en;
	u32 snd_cwnd_cents;
	u32 rho;
	u32 rho2;
	u32 rho_3ls;
	u32 rho2_7ls;
	u32 minrtt_us;
};

struct x86_hyper_init {
	void (*init_platform)(void);
	void (*guest_late_init)(void);
	bool (*x2apic_available)(void);
	bool (*msi_ext_dest_id)(void);
	void (*init_mem_mapping)(void);
	void (*init_after_bootmem)(void);
};

struct x86_hyper_runtime {
	void (*pin_vcpu)(int);
	void (*sev_es_hcall_prepare)(struct ghcb *, struct pt_regs *);
	bool (*sev_es_hcall_finish)(struct ghcb *, struct pt_regs *);
	bool (*is_private_mmio)(u64);
};

struct hypervisor_x86 {
	const char *name;
	uint32_t (*detect)(void);
	enum x86_hypervisor_type type;
	struct x86_hyper_init init;
	struct x86_hyper_runtime runtime;
	bool ignore_nopv;
};

struct i2c_acpi_handler_data {
	struct acpi_connection_info info;
	struct i2c_adapter *adapter;
};

struct i2c_acpi_irq_context {
	int irq;
	bool wake_capable;
};

struct i2c_acpi_lookup {
	struct i2c_board_info *info;
	acpi_handle adapter_handle;
	acpi_handle device_handle;
	acpi_handle search_handle;
	int n;
	int index;
	u32 speed;
	u32 min_speed;
	u32 force_speed;
};

struct intel_dsi;

struct i2c_adapter_lookup {
	u16 target_addr;
	struct intel_dsi *intel_dsi;
	acpi_handle dev_handle;
};

struct i2c_adapter_quirks {
	u64 flags;
	int max_num_msgs;
	u16 max_write_len;
	u16 max_read_len;
	u16 max_comb_1st_msg_len;
	u16 max_comb_2nd_msg_len;
};

struct i2c_algo_bit_data {
	void *data;
	void (*setsda)(void *, int);
	void (*setscl)(void *, int);
	int (*getsda)(void *);
	int (*getscl)(void *);
	int (*pre_xfer)(struct i2c_adapter *);
	void (*post_xfer)(struct i2c_adapter *);
	int udelay;
	int timeout;
	bool can_do_atomic;
};

struct i2c_msg;

union i2c_smbus_data;

struct i2c_algorithm {
	union {
		int (*xfer)(struct i2c_adapter *, struct i2c_msg *, int);
		int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int);
	};
	union {
		int (*xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int);
		int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int);
	};
	int (*smbus_xfer)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	int (*smbus_xfer_atomic)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	u32 (*functionality)(struct i2c_adapter *);
};

struct i2c_board_info {
	char type[20];
	short unsigned int flags;
	short unsigned int addr;
	const char *dev_name;
	void *platform_data;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	const struct software_node *swnode;
	const struct resource *resources;
	unsigned int num_resources;
	int irq;
};

struct pinctrl;

struct pinctrl_state;

struct i2c_bus_recovery_info {
	int (*recover_bus)(struct i2c_adapter *);
	int (*get_scl)(struct i2c_adapter *);
	void (*set_scl)(struct i2c_adapter *, int);
	int (*get_sda)(struct i2c_adapter *);
	void (*set_sda)(struct i2c_adapter *, int);
	int (*get_bus_free)(struct i2c_adapter *);
	void (*prepare_recovery)(struct i2c_adapter *);
	void (*unprepare_recovery)(struct i2c_adapter *);
	struct gpio_desc *scl_gpiod;
	struct gpio_desc *sda_gpiod;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_gpio;
};

struct i2c_client {
	short unsigned int flags;
	short unsigned int addr;
	char name[20];
	struct i2c_adapter *adapter;
	struct device dev;
	int init_irq;
	int irq;
	struct list_head detected;
	void *devres_group_id;
	struct dentry *debugfs;
};

struct i2c_cmd_arg {
	unsigned int cmd;
	void *arg;
};

struct i2c_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct i2c_device_identity {
	u16 manufacturer_id;
	u16 part_id;
	u8 die_revision;
};

struct i2c_devinfo {
	struct list_head list;
	int busnum;
	struct i2c_board_info board_info;
};

struct i2c_lock_operations {
	void (*lock_bus)(struct i2c_adapter *, unsigned int);
	int (*trylock_bus)(struct i2c_adapter *, unsigned int);
	void (*unlock_bus)(struct i2c_adapter *, unsigned int);
};

struct i2c_msg {
	__u16 addr;
	__u16 flags;
	__u16 len;
	__u8 *buf;
};

struct i2c_smbus_alert {
	struct work_struct alert;
	struct i2c_client *ara;
};

struct i2c_smbus_alert_setup {
	int irq;
};

union i2c_smbus_data {
	__u8 byte;
	__u16 word;
	__u8 block[34];
};

struct i2c_timings {
	u32 bus_freq_hz;
	u32 scl_rise_ns;
	u32 scl_fall_ns;
	u32 scl_int_delay_ns;
	u32 sda_fall_ns;
	u32 sda_hold_ns;
	u32 digital_filter_width_ns;
	u32 analog_filter_cutoff_freq_hz;
};

struct i801_priv {
	struct i2c_adapter adapter;
	long unsigned int smba;
	unsigned char original_hstcfg;
	unsigned char original_hstcnt;
	unsigned char original_slvcmd;
	struct pci_dev *pci_dev;
	unsigned int features;
	struct completion done;
	u8 status;
	u8 cmd;
	bool is_read;
	int count;
	int len;
	u8 *data;
	struct platform_device *tco_pdev;
	bool acpi_reserved;
};

struct i8042_port {
	struct serio *serio;
	int irq;
	bool exists;
	bool driver_bound;
	signed char mux;
};

struct i915_audio_component {
	struct drm_audio_component base;
	int aud_sample_rate[9];
};

struct i915_capture_list {
	struct i915_vma_resource *vma_res;
	struct i915_capture_list *next;
};

struct i915_color_plane_view {
	u32 offset;
	unsigned int x;
	unsigned int y;
	unsigned int mapping_stride;
	unsigned int scanout_stride;
};

struct i915_context_engines_bond {
	struct i915_user_extension base;
	struct i915_engine_class_instance master;
	__u16 virtual_index;
	__u16 num_bonds;
	__u64 flags;
	__u64 mbz64[4];
	struct i915_engine_class_instance engines[0];
};

struct i915_context_engines_load_balance {
	struct i915_user_extension base;
	__u16 engine_index;
	__u16 num_siblings;
	__u32 flags;
	__u64 mbz64;
	struct i915_engine_class_instance engines[0];
};

struct i915_context_engines_parallel_submit {
	struct i915_user_extension base;
	__u16 engine_index;
	__u16 width;
	__u16 num_siblings;
	__u16 mbz16;
	__u64 flags;
	__u64 mbz64[3];
	struct i915_engine_class_instance engines[0];
};

struct i915_context_param_engines {
	__u64 extensions;
	struct i915_engine_class_instance engines[0];
};

struct i915_debugfs_files {
	const char *name;
	const struct file_operations *fops;
};

struct i915_sched_node;

struct i915_dependency {
	struct i915_sched_node *signaler;
	struct i915_sched_node *waiter;
	struct list_head signal_link;
	struct list_head wait_link;
	struct list_head dfs_link;
	long unsigned int flags;
};

struct i915_deps {
	struct dma_fence *single;
	struct dma_fence **fences;
	unsigned int num_deps;
	unsigned int fences_size;
	gfp_t gfp;
};

struct i915_dpt {
	struct i915_address_space vm;
	struct drm_i915_gem_object *obj;
	struct i915_vma *vma;
	void *iomem;
};

struct i915_drm_client {
	struct kref kref;
	spinlock_t ctx_lock;
	struct list_head ctx_list;
	spinlock_t objects_lock;
	struct list_head objects_list;
	atomic64_t past_runtime[5];
};

struct i915_gem_ww_ctx {
	struct ww_acquire_ctx ctx;
	struct list_head obj_list;
	struct drm_i915_gem_object *contended;
	bool intr;
};

struct reloc_cache {
	struct drm_mm_node node;
	long unsigned int vaddr;
	long unsigned int page;
	unsigned int graphics_ver;
	bool use_64bit_reloc: 1;
	bool has_llc: 1;
	bool has_fence: 1;
	bool needs_unfenced: 1;
};

struct intel_gt_buffer_pool_node;

struct i915_execbuffer {
	struct drm_i915_private *i915;
	struct drm_file *file;
	struct drm_i915_gem_execbuffer2 *args;
	struct drm_i915_gem_exec_object2 *exec;
	struct eb_vma *vma;
	struct intel_gt *gt;
	struct intel_context *context;
	struct i915_gem_context *gem_context;
	intel_wakeref_t wakeref;
	intel_wakeref_t wakeref_gt0;
	struct i915_request *requests[9];
	struct eb_vma *batches[9];
	struct i915_vma *trampoline;
	struct dma_fence *composite_fence;
	unsigned int buffer_count;
	unsigned int num_batches;
	struct list_head unbound;
	struct list_head relocs;
	struct i915_gem_ww_ctx ww;
	struct reloc_cache reloc_cache;
	u64 invalid_flags;
	u64 batch_len[9];
	u32 batch_start_offset;
	u32 batch_flags;
	struct intel_gt_buffer_pool_node *batch_pool;
	int lut_size;
	struct hlist_head *buckets;
	struct eb_fence *fences;
	long unsigned int num_fences;
	struct i915_capture_list *capture_lists[9];
};

struct i915_ext_attribute {
	struct device_attribute attr;
	long unsigned int val;
};

struct i915_ggtt;

struct i915_fence_reg {
	struct list_head link;
	struct i915_ggtt *ggtt;
	struct i915_vma *vma;
	atomic_t pin_count;
	struct i915_active active;
	int id;
	bool dirty;
	u32 start;
	u32 size;
	u32 tiling;
	u32 stride;
};

struct i915_gem_apply_to_region_ops;

struct i915_gem_apply_to_region {
	const struct i915_gem_apply_to_region_ops *ops;
	struct i915_gem_ww_ctx *ww;
	u32 interruptible: 1;
};

struct i915_gem_apply_to_region_ops {
	int (*process_obj)(struct i915_gem_apply_to_region *, struct drm_i915_gem_object *);
};

struct i915_sched_attr {
	int priority;
};

struct i915_gem_engines;

struct i915_gem_context {
	struct drm_i915_private *i915;
	struct drm_i915_file_private *file_priv;
	struct i915_gem_engines *engines;
	struct mutex engines_mutex;
	struct drm_syncobj *syncobj;
	struct i915_address_space *vm;
	struct pid *pid;
	struct list_head link;
	struct i915_drm_client *client;
	struct list_head client_link;
	struct kref ref;
	struct work_struct release_work;
	struct callback_head rcu;
	long unsigned int user_flags;
	long unsigned int flags;
	bool uses_protected_content;
	intel_wakeref_t pxp_wakeref;
	struct mutex mutex;
	struct i915_sched_attr sched;
	atomic_t guilty_count;
	atomic_t active_count;
	long unsigned int hang_timestamp[2];
	u8 remap_slice;
	struct xarray handles_vma;
	struct mutex lut_mutex;
	char name[24];
	struct {
		spinlock_t lock;
		struct list_head engines;
	} stale;
};

struct i915_gem_context_coredump {
	char comm[16];
	u64 total_runtime;
	u64 avg_runtime;
	pid_t pid;
	int active;
	int guilty;
	struct i915_sched_attr sched_attr;
	u32 hwsp_seqno;
};

struct i915_gem_context_param_context_image {
	struct i915_engine_class_instance engine;
	__u32 flags;
	__u32 size;
	__u32 mbz;
	__u64 image;
};

struct i915_gem_engines {
	union {
		struct list_head link;
		struct callback_head rcu;
	};
	struct i915_sw_fence fence;
	struct i915_gem_context *ctx;
	unsigned int num_engines;
	struct intel_context *engines[0];
};

struct i915_gem_engines_iter {
	unsigned int idx;
	const struct i915_gem_engines *engines;
};

struct i915_gem_proto_engine;

struct i915_gem_proto_context {
	struct drm_i915_file_private *fpriv;
	struct i915_address_space *vm;
	long unsigned int user_flags;
	struct i915_sched_attr sched;
	int num_user_engines;
	struct i915_gem_proto_engine *user_engines;
	struct intel_sseu legacy_rcs_sseu;
	bool single_timeline;
	bool uses_protected_content;
	intel_wakeref_t pxp_wakeref;
};

struct i915_gem_proto_engine {
	enum i915_gem_engine_type type;
	struct intel_engine_cs *engine;
	unsigned int num_siblings;
	unsigned int width;
	struct intel_engine_cs **siblings;
	struct intel_sseu sseu;
};

struct i915_gem_ttm_pm_apply {
	struct i915_gem_apply_to_region base;
	bool allow_gpu: 1;
	bool backup_pinned: 1;
};

struct io_mapping {
	resource_size_t base;
	long unsigned int size;
	pgprot_t prot;
	void *iomem;
};

struct i915_ggtt {
	struct i915_address_space vm;
	struct io_mapping iomap;
	struct resource gmadr;
	resource_size_t mappable_end;
	void *gsm;
	void (*invalidate)(struct i915_ggtt *);
	struct i915_ppgtt *alias;
	bool do_idle_maps;
	int mtrr;
	u32 bit_6_swizzle_x;
	u32 bit_6_swizzle_y;
	u32 pin_bias;
	unsigned int num_fences;
	struct i915_fence_reg *fence_regs;
	struct list_head fence_list;
	struct list_head userfault_list;
	struct mutex error_mutex;
	struct drm_mm_node error_capture;
	struct drm_mm_node uc_fw;
	struct list_head gt_list;
};

struct intel_gt_definition;

struct intel_device_info {
	enum intel_platform platform;
	unsigned int dma_mask_size;
	const struct intel_gt_definition *extra_gt_list;
	u8 gt;
	intel_engine_mask_t platform_engine_mask;
	u32 memory_regions;
	u8 is_mobile: 1;
	u8 require_force_probe: 1;
	u8 is_dgfx: 1;
	u8 has_64bit_reloc: 1;
	u8 has_64k_pages: 1;
	u8 gpu_reset_clobbers_display: 1;
	u8 has_reset_engine: 1;
	u8 has_3d_pipeline: 1;
	u8 has_flat_ccs: 1;
	u8 has_global_mocs: 1;
	u8 has_gmd_id: 1;
	u8 has_gt_uc: 1;
	u8 has_heci_pxp: 1;
	u8 has_heci_gscfi: 1;
	u8 has_guc_deprivilege: 1;
	u8 has_guc_tlb_invalidation: 1;
	u8 has_l3_ccs_read: 1;
	u8 has_l3_dpf: 1;
	u8 has_llc: 1;
	u8 has_logical_ring_contexts: 1;
	u8 has_logical_ring_elsq: 1;
	u8 has_media_ratio_mode: 1;
	u8 has_mslice_steering: 1;
	u8 has_oa_bpc_reporting: 1;
	u8 has_oa_slice_contrib_limits: 1;
	u8 has_oam: 1;
	u8 has_one_eu_per_fuse_bit: 1;
	u8 has_pxp: 1;
	u8 has_rc6: 1;
	u8 has_rc6p: 1;
	u8 has_rps: 1;
	u8 has_runtime_pm: 1;
	u8 has_snoop: 1;
	u8 has_coherent_ggtt: 1;
	u8 tuning_thread_rr_after_dep: 1;
	u8 unfenced_needs_alignment: 1;
	u8 hws_needs_physical: 1;
	const struct intel_runtime_info __runtime;
	u32 cachelevel_to_pat[4];
	u32 max_pat_index;
};

struct intel_gt_coredump;

struct intel_display_snapshot;

struct i915_gpu_coredump {
	struct kref ref;
	ktime_t time;
	ktime_t boottime;
	ktime_t uptime;
	long unsigned int capture;
	struct drm_i915_private *i915;
	struct intel_gt_coredump *gt;
	char error_msg[128];
	bool simulated;
	bool wakelock;
	bool suspended;
	int iommu;
	u32 reset_count;
	u32 suspend_count;
	struct intel_device_info device_info;
	struct intel_runtime_info runtime_info;
	struct intel_driver_caps driver_caps;
	struct i915_params params;
	struct scatterlist *sgl;
	struct scatterlist *fit;
	struct intel_display_snapshot *display_snapshot;
};

struct i915_gsc_proxy_component_ops;

struct i915_gsc_proxy_component {
	struct device *mei_dev;
	const struct i915_gsc_proxy_component_ops *ops;
};

struct i915_gsc_proxy_component_ops {
	struct module *owner;
	int (*send)(struct device *, const void *, size_t);
	int (*recv)(struct device *, void *, size_t);
};

struct intel_partial_info {
	u64 offset;
	unsigned int size;
} __attribute__((packed));

struct intel_remapped_plane_info {
	u32 offset: 31;
	u32 linear: 1;
	union {
		struct {
			u16 width;
			u16 height;
			u16 src_stride;
			u16 dst_stride;
		};
		u32 size;
	};
};

struct intel_rotation_info {
	struct intel_remapped_plane_info plane[2];
};

struct intel_remapped_info {
	struct intel_remapped_plane_info plane[4];
	u32 plane_alignment;
};

struct i915_gtt_view {
	enum i915_gtt_view_type type;
	union {
		struct intel_partial_info partial;
		struct intel_rotation_info rotated;
		struct intel_remapped_info remapped;
	};
};

struct i915_hdcp_ops;

struct i915_hdcp_arbiter {
	struct device *hdcp_dev;
	const struct i915_hdcp_ops *ops;
	struct mutex mutex;
};

struct i915_hdcp_ops {
	struct module *owner;
	int (*initiate_hdcp2_session)(struct device *, struct hdcp_port_data *, struct hdcp2_ake_init *);
	int (*verify_receiver_cert_prepare_km)(struct device *, struct hdcp_port_data *, struct hdcp2_ake_send_cert *, bool *, struct hdcp2_ake_no_stored_km *, size_t *);
	int (*verify_hprime)(struct device *, struct hdcp_port_data *, struct hdcp2_ake_send_hprime *);
	int (*store_pairing_info)(struct device *, struct hdcp_port_data *, struct hdcp2_ake_send_pairing_info *);
	int (*initiate_locality_check)(struct device *, struct hdcp_port_data *, struct hdcp2_lc_init *);
	int (*verify_lprime)(struct device *, struct hdcp_port_data *, struct hdcp2_lc_send_lprime *);
	int (*get_session_key)(struct device *, struct hdcp_port_data *, struct hdcp2_ske_send_eks *);
	int (*repeater_check_flow_prepare_ack)(struct device *, struct hdcp_port_data *, struct hdcp2_rep_send_receiverid_list *, struct hdcp2_rep_send_ack *);
	int (*verify_mprime)(struct device *, struct hdcp_port_data *, struct hdcp2_rep_stream_ready *);
	int (*enable_hdcp_authentication)(struct device *, struct hdcp_port_data *);
	int (*close_hdcp_session)(struct device *, struct hdcp_port_data *);
};

struct i915_hwmon {
	struct hwm_drvdata ddat;
	struct hwm_drvdata ddat_gt[2];
	struct mutex hwmon_lock;
	struct hwm_reg rg;
	int scl_shift_power;
	int scl_shift_energy;
	int scl_shift_time;
};

struct i915_irq_regs {
	i915_reg_t imr;
	i915_reg_t ier;
	i915_reg_t iir;
};

struct i915_lut_handle {
	struct list_head obj_link;
	struct i915_gem_context *ctx;
	u32 handle;
};

struct i915_mmap_offset {
	struct drm_vma_offset_node vma_node;
	struct drm_i915_gem_object *obj;
	enum i915_mmap_type mmap_type;
	struct rb_node offset;
};

struct i915_oa_reg;

struct i915_oa_config {
	struct i915_perf *perf;
	char uuid[37];
	int id;
	const struct i915_oa_reg *mux_regs;
	u32 mux_regs_len;
	const struct i915_oa_reg *b_counter_regs;
	u32 b_counter_regs_len;
	const struct i915_oa_reg *flex_regs;
	u32 flex_regs_len;
	struct attribute_group sysfs_metric;
	struct attribute *attrs[2];
	struct kobj_attribute sysfs_metric_id;
	struct kref ref;
	struct callback_head rcu;
};

struct i915_oa_config_bo {
	struct llist_node node;
	struct i915_oa_config *oa_config;
	struct i915_vma *vma;
};

struct i915_oa_format {
	u32 format;
	int size;
	int type;
	enum report_header header;
};

struct i915_oa_reg {
	i915_reg_t addr;
	u32 value;
};

struct i915_page_table {
	struct drm_i915_gem_object *base;
	union {
		atomic_t used;
		struct i915_page_table *stash;
	};
	bool is_compact;
};

struct i915_page_directory {
	struct i915_page_table pt;
	spinlock_t lock;
	void **entry;
};

struct i915_perf_regs {
	u32 base;
	i915_reg_t oa_head_ptr;
	i915_reg_t oa_tail_ptr;
	i915_reg_t oa_buffer;
	i915_reg_t oa_ctx_ctrl;
	i915_reg_t oa_ctrl;
	i915_reg_t oa_debug;
	i915_reg_t oa_status;
	u32 oa_ctrl_counter_format_shift;
};

struct i915_perf_group {
	struct i915_perf_stream *exclusive_stream;
	u32 num_engines;
	struct i915_perf_regs regs;
	enum oa_type type;
};

struct i915_perf_gt {
	struct mutex lock;
	struct intel_sseu sseu;
	u32 num_perf_groups;
	struct i915_perf_group *group;
};

struct i915_perf_stream_ops;

struct i915_perf_stream {
	struct i915_perf *perf;
	struct intel_uncore *uncore;
	struct intel_engine_cs *engine;
	struct mutex lock;
	u32 sample_flags;
	int sample_size;
	struct i915_gem_context *ctx;
	bool enabled;
	bool hold_preemption;
	const struct i915_perf_stream_ops *ops;
	struct i915_oa_config *oa_config;
	struct llist_head oa_config_bos;
	struct intel_context *pinned_ctx;
	u32 specific_ctx_id;
	u32 specific_ctx_id_mask;
	struct hrtimer poll_check_timer;
	wait_queue_head_t poll_wq;
	bool pollin;
	bool periodic;
	int period_exponent;
	struct {
		const struct i915_oa_format *format;
		struct i915_vma *vma;
		u8 *vaddr;
		u32 last_ctx_id;
		spinlock_t ptr_lock;
		u32 head;
		u32 tail;
	} oa_buffer;
	struct i915_vma *noa_wait;
	u64 poll_oa_period;
};

struct i915_perf_stream_ops {
	void (*enable)(struct i915_perf_stream *);
	void (*disable)(struct i915_perf_stream *);
	void (*poll_wait)(struct i915_perf_stream *, struct file *, poll_table *);
	int (*wait_unlocked)(struct i915_perf_stream *);
	int (*read)(struct i915_perf_stream *, char *, size_t, size_t *);
	void (*destroy)(struct i915_perf_stream *);
};

struct i915_power_domain_list {
	const enum intel_display_power_domain *list;
	u8 count;
};

struct i915_power_well_desc;

struct i915_power_well {
	const struct i915_power_well_desc *desc;
	struct intel_power_domain_mask domains;
	int count;
	bool hw_enabled;
	u8 instance_idx;
};

struct i915_power_well_ops;

struct i915_power_well_instance_list;

struct i915_power_well_desc {
	const struct i915_power_well_ops *ops;
	const struct i915_power_well_instance_list *instances;
	u16 irq_pipe_mask: 4;
	u16 always_on: 1;
	u16 fixed_enable_delay: 1;
	u16 has_vga: 1;
	u16 has_fuses: 1;
	u16 is_tc_tbt: 1;
	u16 enable_timeout;
};

struct i915_power_well_desc_list {
	const struct i915_power_well_desc *list;
	u8 count;
};

struct i915_power_well_instance {
	const char *name;
	const struct i915_power_domain_list *domain_list;
	enum i915_power_well_id id;
	union {
		struct {
			u8 idx;
		} vlv;
		struct {
			enum dpio_phy phy;
		} bxt;
		struct {
			u8 idx;
		} hsw;
		struct {
			u8 aux_ch;
		} xelpdp;
	};
};

struct i915_power_well_instance_list {
	const struct i915_power_well_instance *list;
	u8 count;
};

struct i915_power_well_regs;

struct i915_power_well_ops {
	const struct i915_power_well_regs *regs;
	void (*sync_hw)(struct intel_display *, struct i915_power_well *);
	void (*enable)(struct intel_display *, struct i915_power_well *);
	void (*disable)(struct intel_display *, struct i915_power_well *);
	bool (*is_enabled)(struct intel_display *, struct i915_power_well *);
};

struct i915_power_well_regs {
	i915_reg_t bios;
	i915_reg_t driver;
	i915_reg_t kvmr;
	i915_reg_t debug;
};

struct i915_priolist {
	struct list_head requests;
	struct rb_node node;
	int priority;
};

struct i915_pxp_component_ops;

struct i915_pxp_component {
	struct device *tee_dev;
	const struct i915_pxp_component_ops *ops;
	struct mutex mutex;
};

struct i915_pxp_component_ops {
	struct module *owner;
	int (*send)(struct device *, const void *, size_t, long unsigned int);
	int (*recv)(struct device *, void *, size_t, long unsigned int);
	ssize_t (*gsc_command)(struct device *, u8, u32, struct scatterlist *, size_t, struct scatterlist *);
};

struct i915_range {
	u32 start;
	u32 end;
};

struct i915_refct_sgt_ops;

struct i915_refct_sgt {
	struct kref kref;
	struct sg_table table;
	size_t size;
	const struct i915_refct_sgt_ops *ops;
};

struct i915_refct_sgt_ops {
	void (*release)(struct kref *);
};

struct i915_request_duration_cb {
	struct dma_fence_cb cb;
	ktime_t emitted;
};

struct i915_sched_node {
	struct list_head signalers_list;
	struct list_head waiters_list;
	struct list_head link;
	struct i915_sched_attr attr;
	unsigned int flags;
	intel_engine_mask_t semaphores;
};

struct i915_request_watchdog {
	struct llist_node link;
	struct hrtimer timer;
};

struct i915_request {
	struct dma_fence fence;
	spinlock_t lock;
	struct drm_i915_private *i915;
	struct intel_engine_cs *engine;
	struct intel_context *context;
	struct intel_ring *ring;
	struct intel_timeline *timeline;
	struct list_head signal_link;
	struct llist_node signal_node;
	long unsigned int rcustate;
	struct pin_cookie cookie;
	struct i915_sw_fence submit;
	union {
		wait_queue_entry_t submitq;
		struct i915_sw_dma_fence_cb dmaq;
		struct i915_request_duration_cb duration;
	};
	struct llist_head execute_cb;
	struct i915_sw_fence semaphore;
	struct irq_work submit_work;
	struct i915_sched_node sched;
	struct i915_dependency dep;
	intel_engine_mask_t execution_mask;
	const u32 *hwsp_seqno;
	u32 head;
	u32 infix;
	u32 postfix;
	u32 tail;
	u32 wa_tail;
	u32 reserved_space;
	struct i915_vma_resource *batch_res;
	struct i915_capture_list *capture_list;
	long unsigned int emitted_jiffies;
	struct list_head link;
	struct i915_request_watchdog watchdog;
	struct list_head guc_fence_link;
	u8 guc_prio;
	wait_queue_entry_t hucq;
};

struct i915_request_coredump {
	long unsigned int flags;
	pid_t pid;
	u32 context;
	u32 seqno;
	u32 head;
	u32 tail;
	struct i915_sched_attr sched_attr;
};

struct i915_sched_engine {
	struct kref ref;
	spinlock_t lock;
	struct list_head requests;
	struct list_head hold;
	struct tasklet_struct tasklet;
	struct i915_priolist default_priolist;
	int queue_priority_hint;
	struct rb_root_cached queue;
	bool no_priolist;
	void *private_data;
	void (*destroy)(struct kref *);
	bool (*disabled)(struct i915_sched_engine *);
	void (*kick_backend)(const struct i915_request *, int);
	void (*bump_inflight_request_prio)(struct i915_request *, int);
	void (*retire_inflight_request_prio)(struct i915_request *);
	void (*schedule)(struct i915_request *, const struct i915_sched_attr *);
};

struct i915_str_attribute {
	struct device_attribute attr;
	const char *str;
};

struct i915_sw_dma_fence_cb_timer {
	struct i915_sw_dma_fence_cb base;
	struct dma_fence *dma;
	struct timer_list timer;
	struct irq_work work;
	struct callback_head rcu;
};

struct i915_syncmap {
	u64 prefix;
	unsigned int height;
	unsigned int bitmap;
	struct i915_syncmap *parent;
	union {
		struct {
			struct {} __empty_seqno;
			u32 seqno[0];
		};
		struct {
			struct {} __empty_child;
			struct i915_syncmap *child[0];
		};
	};
};

struct i915_ttm_buddy_manager {
	struct ttm_resource_manager manager;
	struct drm_buddy mm;
	struct list_head reserved;
	struct mutex lock;
	long unsigned int visible_size;
	long unsigned int visible_avail;
	long unsigned int visible_reserved;
	u64 default_page_size;
};

struct ttm_bus_placement {
	void *addr;
	phys_addr_t offset;
	bool is_iomem;
	enum ttm_caching caching;
};

struct dmem_cgroup_pool_state;

struct ttm_lru_item {
	struct list_head link;
	enum ttm_lru_item_type type;
};

struct ttm_resource {
	long unsigned int start;
	size_t size;
	uint32_t mem_type;
	uint32_t placement;
	struct ttm_bus_placement bus;
	struct ttm_buffer_object *bo;
	struct dmem_cgroup_pool_state *css;
	struct ttm_lru_item lru;
};

struct i915_ttm_buddy_resource {
	struct ttm_resource base;
	struct list_head blocks;
	long unsigned int flags;
	long unsigned int used_visible_size;
	struct drm_buddy *mm;
};

struct ttm_kmap_iter_ops;

struct ttm_kmap_iter {
	const struct ttm_kmap_iter_ops *ops;
};

struct ttm_kmap_iter_tt {
	struct ttm_kmap_iter base;
	struct ttm_tt *tt;
	pgprot_t prot;
};

struct ttm_kmap_iter_iomap {
	struct ttm_kmap_iter base;
	struct io_mapping *iomap;
	struct sg_table *st;
	resource_size_t start;
	struct {
		struct scatterlist *sg;
		long unsigned int i;
		long unsigned int end;
		long unsigned int offs;
	} cache;
};

struct i915_ttm_memcpy_arg {
	union {
		struct ttm_kmap_iter_tt tt;
		struct ttm_kmap_iter_iomap io;
	} _dst_iter;
	union {
		struct ttm_kmap_iter_tt tt;
		struct ttm_kmap_iter_iomap io;
	} _src_iter;
	struct ttm_kmap_iter *dst_iter;
	struct ttm_kmap_iter *src_iter;
	long unsigned int num_pages;
	bool clear;
	struct i915_refct_sgt *src_rsgt;
	struct i915_refct_sgt *dst_rsgt;
};

struct i915_ttm_memcpy_work {
	struct dma_fence fence;
	struct work_struct work;
	spinlock_t lock;
	struct irq_work irq_work;
	struct dma_fence_cb cb;
	struct i915_ttm_memcpy_arg arg;
	struct drm_i915_private *i915;
	struct drm_i915_gem_object *obj;
	bool memcpy_allowed;
};

struct ttm_tt {
	struct page **pages;
	uint32_t page_flags;
	uint32_t num_pages;
	struct sg_table *sg;
	dma_addr_t *dma_address;
	struct file *swap_storage;
	enum ttm_caching caching;
};

struct i915_ttm_tt {
	struct ttm_tt ttm;
	struct device *dev;
	struct i915_refct_sgt cached_rsgt;
	bool is_shmem;
	struct file *filp;
};

struct i915_vm_pt_stash {
	struct i915_page_table *pt[2];
	int pt_sz;
};

struct i915_vma {
	struct drm_mm_node node;
	struct i915_address_space *vm;
	const struct i915_vma_ops *ops;
	struct drm_i915_gem_object *obj;
	struct sg_table *pages;
	void *iomap;
	void *private;
	struct i915_fence_reg *fence;
	u64 size;
	struct i915_page_sizes page_sizes;
	struct i915_mmap_offset *mmo;
	u32 guard;
	u32 fence_size;
	u32 fence_alignment;
	u32 display_alignment;
	atomic_t open_count;
	atomic_t flags;
	struct i915_active active;
	atomic_t pages_count;
	bool vm_ddestroy;
	struct i915_gtt_view gtt_view;
	struct list_head vm_link;
	struct list_head obj_link;
	struct rb_node obj_node;
	struct list_head evict_link;
	struct list_head closed_link;
	struct i915_vma_resource *resource;
};

struct i915_vma_bindinfo {
	struct sg_table *pages;
	struct i915_page_sizes page_sizes;
	struct i915_refct_sgt *pages_rsgt;
	bool readonly: 1;
	bool lmem: 1;
};

struct i915_vma_compress {
	struct folio_batch pool;
	struct z_stream_s zstream;
	void *tmp;
};

struct i915_vma_coredump {
	struct i915_vma_coredump *next;
	char name[20];
	u64 gtt_offset;
	u64 gtt_size;
	u32 gtt_page_sizes;
	int unused;
	struct list_head page_list;
};

struct i915_vma_resource {
	struct dma_fence unbind_fence;
	spinlock_t lock;
	refcount_t hold_count;
	struct work_struct work;
	struct i915_sw_fence chain;
	struct rb_node rb;
	u64 __subtree_last;
	struct i915_address_space *vm;
	intel_wakeref_t wakeref;
	struct i915_vma_bindinfo bi;
	struct intel_memory_region *mr;
	const struct i915_vma_ops *ops;
	void *private;
	u64 start;
	u64 node_size;
	u64 vma_size;
	u32 guard;
	u32 page_sizes_gtt;
	u32 bound_flags;
	bool allocated: 1;
	bool immediate_unbind: 1;
	bool needs_wakeref: 1;
	bool skip_pte_rewrite: 1;
	u32 *tlb;
};

struct i915_vma_work {
	struct dma_fence_work base;
	struct i915_address_space *vm;
	struct i915_vm_pt_stash stash;
	struct i915_vma_resource *vma_res;
	struct drm_i915_gem_object *obj;
	struct i915_sw_dma_fence_cb cb;
	unsigned int pat_index;
	unsigned int flags;
};

struct i915_wa {
	union {
		i915_reg_t reg;
		i915_mcr_reg_t mcr_reg;
	};
	u32 clr;
	u32 set;
	u32 read;
	u32 masked_reg: 1;
	u32 is_mcr: 1;
};

struct ia_constants {
	unsigned int min_gpu_freq;
	unsigned int max_gpu_freq;
	unsigned int min_ring_freq;
	unsigned int max_ia_freq;
};

struct iattr {
	unsigned int ia_valid;
	umode_t ia_mode;
	union {
		kuid_t ia_uid;
		vfsuid_t ia_vfsuid;
	};
	union {
		kgid_t ia_gid;
		vfsgid_t ia_vfsgid;
	};
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file *ia_file;
};

struct ib_pd;

struct ib_uobject;

struct ib_gid_attr;

struct ib_ah {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	const struct ib_gid_attr *sgid_attr;
	enum rdma_ah_attr_type type;
};

struct ib_ah_attr {
	u16 dlid;
	u8 src_path_bits;
};

struct ib_core_device {
	struct device dev;
	possible_net_t rdma_net;
	struct kobject *ports_kobj;
	struct list_head port_list;
	struct ib_device *owner;
};

struct ib_counters {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

struct ib_counters_read_attr {
	u64 *counters_buff;
	u32 ncounters;
	u32 flags;
};

struct ib_ucq_object;

struct ib_cq;

typedef void (*ib_comp_handler)(struct ib_cq *, void *);

struct irq_poll;

typedef int irq_poll_fn(struct irq_poll *, int);

struct irq_poll {
	struct list_head list;
	long unsigned int state;
	int weight;
	irq_poll_fn *poll;
};

struct rdma_restrack_entry {
	bool valid;
	u8 no_track: 1;
	struct kref kref;
	struct completion comp;
	struct task_struct *task;
	const char *kern_name;
	enum rdma_restrack_type type;
	bool user;
	u32 id;
};

struct ib_event;

struct ib_wc;

struct ib_cq {
	struct ib_device *device;
	struct ib_ucq_object *uobject;
	ib_comp_handler comp_handler;
	void (*event_handler)(struct ib_event *, void *);
	void *cq_context;
	int cqe;
	unsigned int cqe_used;
	atomic_t usecnt;
	enum ib_poll_context poll_ctx;
	struct ib_wc *wc;
	struct list_head pool_entry;
	union {
		struct irq_poll iop;
		struct work_struct work;
	};
	struct workqueue_struct *comp_wq;
	struct dim *dim;
	ktime_t timestamp;
	u8 interrupt: 1;
	u8 shared: 1;
	unsigned int comp_vector;
	struct rdma_restrack_entry res;
};

struct ib_cq_caps {
	u16 max_cq_moderation_count;
	u16 max_cq_moderation_period;
};

struct ib_cq_init_attr {
	unsigned int cqe;
	u32 comp_vector;
	u32 flags;
};

struct ib_cqe {
	void (*done)(struct ib_cq *, struct ib_wc *);
};

struct uverbs_attr_bundle;

struct iw_cm_id;

struct iw_cm_conn_param;

struct ib_uverbs_file;

struct ib_qp;

struct ib_send_wr;

struct ib_recv_wr;

struct ib_srq;

struct ib_grh;

struct ib_mad;

struct ib_device_attr;

struct ib_udata;

struct ib_device_modify;

struct ib_port_attr;

struct ib_port_modify;

struct ib_port_immutable;

struct rdma_netdev_alloc_params;

union ib_gid;

struct ib_ucontext;

struct rdma_user_mmap_entry;

struct rdma_ah_init_attr;

struct rdma_ah_attr;

struct ib_srq_init_attr;

struct ib_srq_attr;

struct ib_qp_init_attr;

struct ib_qp_attr;

struct ib_mr;

struct ib_sge;

struct ib_mr_status;

struct ib_mw;

struct ib_xrcd;

struct ib_flow;

struct ib_flow_attr;

struct ib_flow_action;

struct ifla_vf_info;

struct ifla_vf_stats;

struct ifla_vf_guid;

struct ib_wq;

struct ib_wq_init_attr;

struct ib_wq_attr;

struct ib_rwq_ind_table;

struct ib_rwq_ind_table_init_attr;

struct ib_dm;

struct ib_dm_alloc_attr;

struct ib_dm_mr_attr;

struct rdma_hw_stats;

struct rdma_cm_id;

struct rdma_counter;

struct ib_device_ops {
	struct module *owner;
	enum rdma_driver_id driver_id;
	u32 uverbs_abi_ver;
	unsigned int uverbs_no_driver_id_binding: 1;
	const struct attribute_group *device_group;
	const struct attribute_group **port_groups;
	int (*post_send)(struct ib_qp *, const struct ib_send_wr *, const struct ib_send_wr **);
	int (*post_recv)(struct ib_qp *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	void (*drain_rq)(struct ib_qp *);
	void (*drain_sq)(struct ib_qp *);
	int (*poll_cq)(struct ib_cq *, int, struct ib_wc *);
	int (*peek_cq)(struct ib_cq *, int);
	int (*req_notify_cq)(struct ib_cq *, enum ib_cq_notify_flags);
	int (*post_srq_recv)(struct ib_srq *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	int (*process_mad)(struct ib_device *, int, u32, const struct ib_wc *, const struct ib_grh *, const struct ib_mad *, struct ib_mad *, size_t *, u16 *);
	int (*query_device)(struct ib_device *, struct ib_device_attr *, struct ib_udata *);
	int (*modify_device)(struct ib_device *, int, struct ib_device_modify *);
	void (*get_dev_fw_str)(struct ib_device *, char *);
	const struct cpumask * (*get_vector_affinity)(struct ib_device *, int);
	int (*query_port)(struct ib_device *, u32, struct ib_port_attr *);
	int (*modify_port)(struct ib_device *, u32, int, struct ib_port_modify *);
	int (*get_port_immutable)(struct ib_device *, u32, struct ib_port_immutable *);
	enum rdma_link_layer (*get_link_layer)(struct ib_device *, u32);
	struct net_device * (*get_netdev)(struct ib_device *, u32);
	struct net_device * (*alloc_rdma_netdev)(struct ib_device *, u32, enum rdma_netdev_t, const char *, unsigned char, void (*)(struct net_device *));
	int (*rdma_netdev_get_params)(struct ib_device *, u32, enum rdma_netdev_t, struct rdma_netdev_alloc_params *);
	int (*query_gid)(struct ib_device *, u32, int, union ib_gid *);
	int (*add_gid)(const struct ib_gid_attr *, void **);
	int (*del_gid)(const struct ib_gid_attr *, void **);
	int (*query_pkey)(struct ib_device *, u32, u16, u16 *);
	int (*alloc_ucontext)(struct ib_ucontext *, struct ib_udata *);
	void (*dealloc_ucontext)(struct ib_ucontext *);
	int (*mmap)(struct ib_ucontext *, struct vm_area_struct *);
	void (*mmap_free)(struct rdma_user_mmap_entry *);
	void (*disassociate_ucontext)(struct ib_ucontext *);
	int (*alloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*dealloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*create_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*create_user_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*modify_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*query_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*destroy_ah)(struct ib_ah *, u32);
	int (*create_srq)(struct ib_srq *, struct ib_srq_init_attr *, struct ib_udata *);
	int (*modify_srq)(struct ib_srq *, struct ib_srq_attr *, enum ib_srq_attr_mask, struct ib_udata *);
	int (*query_srq)(struct ib_srq *, struct ib_srq_attr *);
	int (*destroy_srq)(struct ib_srq *, struct ib_udata *);
	int (*create_qp)(struct ib_qp *, struct ib_qp_init_attr *, struct ib_udata *);
	int (*modify_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_udata *);
	int (*query_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_qp_init_attr *);
	int (*destroy_qp)(struct ib_qp *, struct ib_udata *);
	int (*create_cq)(struct ib_cq *, const struct ib_cq_init_attr *, struct uverbs_attr_bundle *);
	int (*modify_cq)(struct ib_cq *, u16, u16);
	int (*destroy_cq)(struct ib_cq *, struct ib_udata *);
	int (*resize_cq)(struct ib_cq *, int, struct ib_udata *);
	struct ib_mr * (*get_dma_mr)(struct ib_pd *, int);
	struct ib_mr * (*reg_user_mr)(struct ib_pd *, u64, u64, u64, int, struct ib_udata *);
	struct ib_mr * (*reg_user_mr_dmabuf)(struct ib_pd *, u64, u64, u64, int, int, struct uverbs_attr_bundle *);
	struct ib_mr * (*rereg_user_mr)(struct ib_mr *, int, u64, u64, u64, int, struct ib_pd *, struct ib_udata *);
	int (*dereg_mr)(struct ib_mr *, struct ib_udata *);
	struct ib_mr * (*alloc_mr)(struct ib_pd *, enum ib_mr_type, u32);
	struct ib_mr * (*alloc_mr_integrity)(struct ib_pd *, u32, u32);
	int (*advise_mr)(struct ib_pd *, enum ib_uverbs_advise_mr_advice, u32, struct ib_sge *, u32, struct uverbs_attr_bundle *);
	int (*map_mr_sg)(struct ib_mr *, struct scatterlist *, int, unsigned int *);
	int (*check_mr_status)(struct ib_mr *, u32, struct ib_mr_status *);
	int (*alloc_mw)(struct ib_mw *, struct ib_udata *);
	int (*dealloc_mw)(struct ib_mw *);
	int (*attach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*detach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*alloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	int (*dealloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	struct ib_flow * (*create_flow)(struct ib_qp *, struct ib_flow_attr *, struct ib_udata *);
	int (*destroy_flow)(struct ib_flow *);
	int (*destroy_flow_action)(struct ib_flow_action *);
	int (*set_vf_link_state)(struct ib_device *, int, u32, int);
	int (*get_vf_config)(struct ib_device *, int, u32, struct ifla_vf_info *);
	int (*get_vf_stats)(struct ib_device *, int, u32, struct ifla_vf_stats *);
	int (*get_vf_guid)(struct ib_device *, int, u32, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*set_vf_guid)(struct ib_device *, int, u32, u64, int);
	struct ib_wq * (*create_wq)(struct ib_pd *, struct ib_wq_init_attr *, struct ib_udata *);
	int (*destroy_wq)(struct ib_wq *, struct ib_udata *);
	int (*modify_wq)(struct ib_wq *, struct ib_wq_attr *, u32, struct ib_udata *);
	int (*create_rwq_ind_table)(struct ib_rwq_ind_table *, struct ib_rwq_ind_table_init_attr *, struct ib_udata *);
	int (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *);
	struct ib_dm * (*alloc_dm)(struct ib_device *, struct ib_ucontext *, struct ib_dm_alloc_attr *, struct uverbs_attr_bundle *);
	int (*dealloc_dm)(struct ib_dm *, struct uverbs_attr_bundle *);
	struct ib_mr * (*reg_dm_mr)(struct ib_pd *, struct ib_dm *, struct ib_dm_mr_attr *, struct uverbs_attr_bundle *);
	int (*create_counters)(struct ib_counters *, struct uverbs_attr_bundle *);
	int (*destroy_counters)(struct ib_counters *);
	int (*read_counters)(struct ib_counters *, struct ib_counters_read_attr *, struct uverbs_attr_bundle *);
	int (*map_mr_sg_pi)(struct ib_mr *, struct scatterlist *, int, unsigned int *, struct scatterlist *, int, unsigned int *);
	struct rdma_hw_stats * (*alloc_hw_device_stats)(struct ib_device *);
	struct rdma_hw_stats * (*alloc_hw_port_stats)(struct ib_device *, u32);
	int (*get_hw_stats)(struct ib_device *, struct rdma_hw_stats *, u32, int);
	int (*modify_hw_stat)(struct ib_device *, u32, unsigned int, bool);
	int (*fill_res_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_mr_entry_raw)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_cq_entry)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_cq_entry_raw)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_qp_entry)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_qp_entry_raw)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_cm_id_entry)(struct sk_buff *, struct rdma_cm_id *);
	int (*fill_res_srq_entry)(struct sk_buff *, struct ib_srq *);
	int (*fill_res_srq_entry_raw)(struct sk_buff *, struct ib_srq *);
	int (*enable_driver)(struct ib_device *);
	void (*dealloc_driver)(struct ib_device *);
	void (*iw_add_ref)(struct ib_qp *);
	void (*iw_rem_ref)(struct ib_qp *);
	struct ib_qp * (*iw_get_qp)(struct ib_device *, int);
	int (*iw_connect)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_accept)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_reject)(struct iw_cm_id *, const void *, u8);
	int (*iw_create_listen)(struct iw_cm_id *, int);
	int (*iw_destroy_listen)(struct iw_cm_id *);
	int (*counter_bind_qp)(struct rdma_counter *, struct ib_qp *);
	int (*counter_unbind_qp)(struct ib_qp *);
	int (*counter_dealloc)(struct rdma_counter *);
	struct rdma_hw_stats * (*counter_alloc_stats)(struct rdma_counter *);
	int (*counter_update_stats)(struct rdma_counter *);
	int (*fill_stat_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*query_ucontext)(struct ib_ucontext *, struct uverbs_attr_bundle *);
	int (*get_numa_node)(struct ib_device *);
	struct ib_device * (*add_sub_dev)(struct ib_device *, enum rdma_nl_dev_type, const char *);
	void (*del_sub_dev)(struct ib_device *);
	void (*ufile_hw_cleanup)(struct ib_uverbs_file *);
	void (*report_port_event)(struct ib_device *, struct net_device *, long unsigned int);
	size_t size_ib_ah;
	size_t size_ib_counters;
	size_t size_ib_cq;
	size_t size_ib_mw;
	size_t size_ib_pd;
	size_t size_ib_qp;
	size_t size_ib_rwq_ind_table;
	size_t size_ib_srq;
	size_t size_ib_ucontext;
	size_t size_ib_xrcd;
};

struct ib_odp_caps {
	uint64_t general_caps;
	struct {
		uint32_t rc_odp_caps;
		uint32_t uc_odp_caps;
		uint32_t ud_odp_caps;
		uint32_t xrc_odp_caps;
	} per_transport_caps;
};

struct ib_rss_caps {
	u32 supported_qpts;
	u32 max_rwq_indirection_tables;
	u32 max_rwq_indirection_table_size;
};

struct ib_tm_caps {
	u32 max_rndv_hdr_size;
	u32 max_num_tags;
	u32 flags;
	u32 max_ops;
	u32 max_sge;
};

struct ib_device_attr {
	u64 fw_ver;
	__be64 sys_image_guid;
	u64 max_mr_size;
	u64 page_size_cap;
	u32 vendor_id;
	u32 vendor_part_id;
	u32 hw_ver;
	int max_qp;
	int max_qp_wr;
	u64 device_cap_flags;
	u64 kernel_cap_flags;
	int max_send_sge;
	int max_recv_sge;
	int max_sge_rd;
	int max_cq;
	int max_cqe;
	int max_mr;
	int max_pd;
	int max_qp_rd_atom;
	int max_ee_rd_atom;
	int max_res_rd_atom;
	int max_qp_init_rd_atom;
	int max_ee_init_rd_atom;
	enum ib_atomic_cap atomic_cap;
	enum ib_atomic_cap masked_atomic_cap;
	int max_ee;
	int max_rdd;
	int max_mw;
	int max_raw_ipv6_qp;
	int max_raw_ethy_qp;
	int max_mcast_grp;
	int max_mcast_qp_attach;
	int max_total_mcast_qp_attach;
	int max_ah;
	int max_srq;
	int max_srq_wr;
	int max_srq_sge;
	unsigned int max_fast_reg_page_list_len;
	unsigned int max_pi_fast_reg_page_list_len;
	u16 max_pkeys;
	u8 local_ca_ack_delay;
	int sig_prot_cap;
	int sig_guard_cap;
	struct ib_odp_caps odp_caps;
	uint64_t timestamp_mask;
	uint64_t hca_core_clock;
	struct ib_rss_caps rss_caps;
	u32 max_wq_type_rq;
	u32 raw_packet_caps;
	struct ib_tm_caps tm_caps;
	struct ib_cq_caps cq_caps;
	u64 max_dm_size;
	u32 max_sgl_rd;
};

struct hw_stats_device_data;

struct rdmacg_device {
	struct list_head dev_node;
	struct list_head rpools;
	char *name;
};

struct rdma_restrack_root;

struct uapi_definition;

struct ib_port_data;

struct rdma_link_ops;

struct ib_device {
	struct device *dma_device;
	struct ib_device_ops ops;
	char name[64];
	struct callback_head callback_head;
	struct list_head event_handler_list;
	struct rw_semaphore event_handler_rwsem;
	spinlock_t qp_open_list_lock;
	struct rw_semaphore client_data_rwsem;
	struct xarray client_data;
	struct mutex unregistration_lock;
	rwlock_t cache_lock;
	struct ib_port_data *port_data;
	int num_comp_vectors;
	union {
		struct device dev;
		struct ib_core_device coredev;
	};
	const struct attribute_group *groups[4];
	u8 hw_stats_attr_index;
	u64 uverbs_cmd_mask;
	char node_desc[64];
	__be64 node_guid;
	u32 local_dma_lkey;
	u16 is_switch: 1;
	u16 kverbs_provider: 1;
	u16 use_cq_dim: 1;
	u8 node_type;
	u32 phys_port_cnt;
	struct ib_device_attr attrs;
	struct hw_stats_device_data *hw_stats_data;
	struct rdmacg_device cg_device;
	u32 index;
	spinlock_t cq_pools_lock;
	struct list_head cq_pools[3];
	struct rdma_restrack_root *res;
	const struct uapi_definition *driver_def;
	refcount_t refcount;
	struct completion unreg_completion;
	struct work_struct unregistration_work;
	const struct rdma_link_ops *link_ops;
	struct mutex compat_devs_mutex;
	struct xarray compat_devs;
	char iw_ifname[16];
	u32 iw_driver_flags;
	u32 lag_flags;
	struct mutex subdev_lock;
	struct list_head subdev_list_head;
	enum rdma_nl_dev_type type;
	struct ib_device *parent;
	struct list_head subdev_list;
	enum rdma_nl_name_assign_type name_assign_type;
};

struct ib_device_modify {
	u64 sys_image_guid;
	char node_desc[64];
};

struct ib_dm {
	struct ib_device *device;
	u32 length;
	u32 flags;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

struct ib_dm_alloc_attr {
	u64 length;
	u32 alignment;
	u32 flags;
};

struct ib_dm_mr_attr {
	u64 length;
	u64 offset;
	u32 access_flags;
};

struct ib_event {
	struct ib_device *device;
	union {
		struct ib_cq *cq;
		struct ib_qp *qp;
		struct ib_srq *srq;
		struct ib_wq *wq;
		u32 port_num;
	} element;
	enum ib_event_type event;
};

struct ib_flow {
	struct ib_qp *qp;
	struct ib_device *device;
	struct ib_uobject *uobject;
};

struct ib_flow_action {
	struct ib_device *device;
	struct ib_uobject *uobject;
	enum ib_flow_action_type type;
	atomic_t usecnt;
};

struct ib_flow_eth_filter {
	u8 dst_mac[6];
	u8 src_mac[6];
	__be16 ether_type;
	__be16 vlan_tag;
};

struct ib_flow_spec_eth {
	u32 type;
	u16 size;
	struct ib_flow_eth_filter val;
	struct ib_flow_eth_filter mask;
};

struct ib_flow_ib_filter {
	__be16 dlid;
	__u8 sl;
};

struct ib_flow_spec_ib {
	u32 type;
	u16 size;
	struct ib_flow_ib_filter val;
	struct ib_flow_ib_filter mask;
};

struct ib_flow_ipv4_filter {
	__be32 src_ip;
	__be32 dst_ip;
	u8 proto;
	u8 tos;
	u8 ttl;
	u8 flags;
};

struct ib_flow_spec_ipv4 {
	u32 type;
	u16 size;
	struct ib_flow_ipv4_filter val;
	struct ib_flow_ipv4_filter mask;
};

struct ib_flow_tcp_udp_filter {
	__be16 dst_port;
	__be16 src_port;
};

struct ib_flow_spec_tcp_udp {
	u32 type;
	u16 size;
	struct ib_flow_tcp_udp_filter val;
	struct ib_flow_tcp_udp_filter mask;
};

struct ib_flow_ipv6_filter {
	u8 src_ip[16];
	u8 dst_ip[16];
	__be32 flow_label;
	u8 next_hdr;
	u8 traffic_class;
	u8 hop_limit;
} __attribute__((packed));

struct ib_flow_spec_ipv6 {
	u32 type;
	u16 size;
	struct ib_flow_ipv6_filter val;
	struct ib_flow_ipv6_filter mask;
};

struct ib_flow_tunnel_filter {
	__be32 tunnel_id;
};

struct ib_flow_spec_tunnel {
	u32 type;
	u16 size;
	struct ib_flow_tunnel_filter val;
	struct ib_flow_tunnel_filter mask;
};

struct ib_flow_esp_filter {
	__be32 spi;
	__be32 seq;
};

struct ib_flow_spec_esp {
	u32 type;
	u16 size;
	struct ib_flow_esp_filter val;
	struct ib_flow_esp_filter mask;
};

struct ib_flow_gre_filter {
	__be16 c_ks_res0_ver;
	__be16 protocol;
	__be32 key;
};

struct ib_flow_spec_gre {
	u32 type;
	u16 size;
	struct ib_flow_gre_filter val;
	struct ib_flow_gre_filter mask;
};

struct ib_flow_mpls_filter {
	__be32 tag;
};

struct ib_flow_spec_mpls {
	u32 type;
	u16 size;
	struct ib_flow_mpls_filter val;
	struct ib_flow_mpls_filter mask;
};

struct ib_flow_spec_action_tag {
	enum ib_flow_spec_type type;
	u16 size;
	u32 tag_id;
};

struct ib_flow_spec_action_drop {
	enum ib_flow_spec_type type;
	u16 size;
};

struct ib_flow_spec_action_handle {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_flow_action *act;
};

struct ib_flow_spec_action_count {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_counters *counters;
};

union ib_flow_spec {
	struct {
		u32 type;
		u16 size;
	};
	struct ib_flow_spec_eth eth;
	struct ib_flow_spec_ib ib;
	struct ib_flow_spec_ipv4 ipv4;
	struct ib_flow_spec_tcp_udp tcp_udp;
	struct ib_flow_spec_ipv6 ipv6;
	struct ib_flow_spec_tunnel tunnel;
	struct ib_flow_spec_esp esp;
	struct ib_flow_spec_gre gre;
	struct ib_flow_spec_mpls mpls;
	struct ib_flow_spec_action_tag flow_tag;
	struct ib_flow_spec_action_drop drop;
	struct ib_flow_spec_action_handle action;
	struct ib_flow_spec_action_count flow_count;
};

struct ib_flow_attr {
	enum ib_flow_attr_type type;
	u16 size;
	u16 priority;
	u32 flags;
	u8 num_of_specs;
	u32 port;
	union ib_flow_spec flows[0];
};

union ib_gid {
	u8 raw[16];
	struct {
		__be64 subnet_prefix;
		__be64 interface_id;
	} global;
};

struct ib_gid_attr {
	struct net_device *ndev;
	struct ib_device *device;
	union ib_gid gid;
	enum ib_gid_type gid_type;
	u16 index;
	u32 port_num;
};

struct ib_global_route {
	const struct ib_gid_attr *sgid_attr;
	union ib_gid dgid;
	u32 flow_label;
	u8 sgid_index;
	u8 hop_limit;
	u8 traffic_class;
};

struct ib_grh {
	__be32 version_tclass_flow;
	__be16 paylen;
	u8 next_hdr;
	u8 hop_limit;
	union ib_gid sgid;
	union ib_gid dgid;
};

struct ib_mad_hdr {
	u8 base_version;
	u8 mgmt_class;
	u8 class_version;
	u8 method;
	__be16 status;
	__be16 class_specific;
	__be64 tid;
	__be16 attr_id;
	__be16 resv;
	__be32 attr_mod;
};

struct ib_mad {
	struct ib_mad_hdr mad_hdr;
	u8 data[232];
};

struct ib_sig_attrs;

struct ib_mr {
	struct ib_device *device;
	struct ib_pd *pd;
	u32 lkey;
	u32 rkey;
	u64 iova;
	u64 length;
	unsigned int page_size;
	enum ib_mr_type type;
	bool need_inval;
	union {
		struct ib_uobject *uobject;
		struct list_head qp_entry;
	};
	struct ib_dm *dm;
	struct ib_sig_attrs *sig_attrs;
	struct rdma_restrack_entry res;
};

struct ib_sig_err {
	enum ib_sig_err_type err_type;
	u32 expected;
	u32 actual;
	u64 sig_err_offset;
	u32 key;
};

struct ib_mr_status {
	u32 fail_status;
	struct ib_sig_err sig_err;
};

struct ib_mw {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	u32 rkey;
	enum ib_mw_type type;
};

struct ib_pd {
	u32 local_dma_lkey;
	u32 flags;
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 unsafe_global_rkey;
	struct ib_mr *__internal_mr;
	struct rdma_restrack_entry res;
};

struct ib_port_attr {
	u64 subnet_prefix;
	enum ib_port_state state;
	enum ib_mtu max_mtu;
	enum ib_mtu active_mtu;
	u32 phys_mtu;
	int gid_tbl_len;
	unsigned int ip_gids: 1;
	u32 port_cap_flags;
	u32 max_msg_sz;
	u32 bad_pkey_cntr;
	u32 qkey_viol_cntr;
	u16 pkey_tbl_len;
	u32 sm_lid;
	u32 lid;
	u8 lmc;
	u8 max_vl_num;
	u8 sm_sl;
	u8 subnet_timeout;
	u8 init_type_reply;
	u8 active_width;
	u16 active_speed;
	u8 phys_state;
	u16 port_cap_flags2;
};

struct ib_pkey_cache;

struct ib_gid_table;

struct ib_port_cache {
	u64 subnet_prefix;
	struct ib_pkey_cache *pkey;
	struct ib_gid_table *gid;
	u8 lmc;
	enum ib_port_state port_state;
	enum ib_port_state last_port_state;
};

struct ib_port_immutable {
	int pkey_tbl_len;
	int gid_tbl_len;
	u32 core_cap_flags;
	u32 max_mad_size;
};

struct rdma_counter_mode {
	enum rdma_nl_counter_mode mode;
	enum rdma_nl_counter_mask mask;
	struct auto_mode_param param;
};

struct rdma_port_counter {
	struct rdma_counter_mode mode;
	struct rdma_hw_stats *hstats;
	unsigned int num_counters;
	struct mutex lock;
};

struct ib_port;

struct ib_port_data {
	struct ib_device *ib_dev;
	struct ib_port_immutable immutable;
	spinlock_t pkey_list_lock;
	spinlock_t netdev_lock;
	struct list_head pkey_list;
	struct ib_port_cache cache;
	struct net_device *netdev;
	netdevice_tracker netdev_tracker;
	struct hlist_node ndev_hash_link;
	struct rdma_port_counter port_counter;
	struct ib_port *sysfs;
};

struct ib_port_modify {
	u32 set_port_cap_mask;
	u32 clr_port_cap_mask;
	u8 init_type;
};

struct ib_qp_security;

struct ib_port_pkey {
	enum port_pkey_state state;
	u16 pkey_index;
	u32 port_num;
	struct list_head qp_list;
	struct list_head to_error_list;
	struct ib_qp_security *sec;
};

struct ib_ports_pkeys {
	struct ib_port_pkey main;
	struct ib_port_pkey alt;
};

struct ib_uqp_object;

struct ib_qp {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	spinlock_t mr_lock;
	int mrs_used;
	struct list_head rdma_mrs;
	struct list_head sig_mrs;
	struct ib_srq *srq;
	struct completion srq_completion;
	struct ib_xrcd *xrcd;
	struct list_head xrcd_list;
	atomic_t usecnt;
	struct list_head open_list;
	struct ib_qp *real_qp;
	struct ib_uqp_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void (*registered_event_handler)(struct ib_event *, void *);
	void *qp_context;
	const struct ib_gid_attr *av_sgid_attr;
	const struct ib_gid_attr *alt_path_sgid_attr;
	u32 qp_num;
	u32 max_write_sge;
	u32 max_read_sge;
	enum ib_qp_type qp_type;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	struct ib_qp_security *qp_sec;
	u32 port;
	bool integrity_en;
	struct rdma_restrack_entry res;
	struct rdma_counter *counter;
};

struct ib_qp_cap {
	u32 max_send_wr;
	u32 max_recv_wr;
	u32 max_send_sge;
	u32 max_recv_sge;
	u32 max_inline_data;
	u32 max_rdma_ctxs;
};

struct roce_ah_attr {
	u8 dmac[6];
};

struct opa_ah_attr {
	u32 dlid;
	u8 src_path_bits;
	bool make_grd;
};

struct rdma_ah_attr {
	struct ib_global_route grh;
	u8 sl;
	u8 static_rate;
	u32 port_num;
	u8 ah_flags;
	enum rdma_ah_attr_type type;
	union {
		struct ib_ah_attr ib;
		struct roce_ah_attr roce;
		struct opa_ah_attr opa;
	};
};

struct ib_qp_attr {
	enum ib_qp_state qp_state;
	enum ib_qp_state cur_qp_state;
	enum ib_mtu path_mtu;
	enum ib_mig_state path_mig_state;
	u32 qkey;
	u32 rq_psn;
	u32 sq_psn;
	u32 dest_qp_num;
	int qp_access_flags;
	struct ib_qp_cap cap;
	struct rdma_ah_attr ah_attr;
	struct rdma_ah_attr alt_ah_attr;
	u16 pkey_index;
	u16 alt_pkey_index;
	u8 en_sqd_async_notify;
	u8 sq_draining;
	u8 max_rd_atomic;
	u8 max_dest_rd_atomic;
	u8 min_rnr_timer;
	u32 port_num;
	u8 timeout;
	u8 retry_cnt;
	u8 rnr_retry;
	u32 alt_port_num;
	u8 alt_timeout;
	u32 rate_limit;
	struct net_device *xmit_slave;
};

struct ib_qp_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct ib_qp_cap cap;
	enum ib_sig_type sq_sig_type;
	enum ib_qp_type qp_type;
	u32 create_flags;
	u32 port_num;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	u32 source_qpn;
};

struct ib_qp_security {
	struct ib_qp *qp;
	struct ib_device *dev;
	struct mutex mutex;
	struct ib_ports_pkeys *ports_pkeys;
	struct list_head shared_qp_list;
	void *security;
	bool destroying;
	atomic_t error_list_count;
	struct completion error_complete;
	int error_comps_pending;
};

struct rdma_cgroup;

struct ib_rdmacg_object {
	struct rdma_cgroup *cg;
};

struct ib_recv_wr {
	struct ib_recv_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
};

struct ib_rwq_ind_table {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 ind_tbl_num;
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

struct ib_rwq_ind_table_init_attr {
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

struct ib_send_wr {
	struct ib_send_wr *next;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
	enum ib_wr_opcode opcode;
	int send_flags;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
};

struct ib_sge {
	u64 addr;
	u32 length;
	u32 lkey;
};

struct ib_t10_dif_domain {
	enum ib_t10_dif_bg_type bg_type;
	u16 pi_interval;
	u16 bg;
	u16 app_tag;
	u32 ref_tag;
	bool ref_remap;
	bool app_escape;
	bool ref_escape;
	u16 apptag_check_mask;
};

struct ib_sig_domain {
	enum ib_signature_type sig_type;
	union {
		struct ib_t10_dif_domain dif;
	} sig;
};

struct ib_sig_attrs {
	u8 check_mask;
	struct ib_sig_domain mem;
	struct ib_sig_domain wire;
	int meta_length;
};

struct ib_usrq_object;

struct ib_srq {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_usrq_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	enum ib_srq_type srq_type;
	atomic_t usecnt;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
				u32 srq_num;
			} xrc;
		};
	} ext;
	struct rdma_restrack_entry res;
};

struct ib_srq_attr {
	u32 max_wr;
	u32 max_sge;
	u32 srq_limit;
};

struct ib_srq_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	struct ib_srq_attr attr;
	enum ib_srq_type srq_type;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
			} xrc;
			struct {
				u32 max_num_tags;
			} tag_matching;
		};
	} ext;
};

struct ib_ucontext {
	struct ib_device *device;
	struct ib_uverbs_file *ufile;
	struct ib_rdmacg_object cg_obj;
	struct rdma_restrack_entry res;
	struct xarray mmap_xa;
};

struct ib_udata {
	const void *inbuf;
	void *outbuf;
	size_t inlen;
	size_t outlen;
};

struct uverbs_api_object;

struct ib_uobject {
	u64 user_handle;
	struct ib_uverbs_file *ufile;
	struct ib_ucontext *context;
	void *object;
	struct list_head list;
	struct ib_rdmacg_object cg_obj;
	int id;
	struct kref ref;
	atomic_t usecnt;
	struct callback_head rcu;
	const struct uverbs_api_object *uapi_object;
};

struct ib_wc {
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	enum ib_wc_status status;
	enum ib_wc_opcode opcode;
	u32 vendor_err;
	u32 byte_len;
	struct ib_qp *qp;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
	u32 src_qp;
	u32 slid;
	int wc_flags;
	u16 pkey_index;
	u8 sl;
	u8 dlid_path_bits;
	u32 port_num;
	u8 smac[6];
	u16 vlan_id;
	u8 network_hdr_type;
};

struct ib_uwq_object;

struct ib_wq {
	struct ib_device *device;
	struct ib_uwq_object *uobject;
	void *wq_context;
	void (*event_handler)(struct ib_event *, void *);
	struct ib_pd *pd;
	struct ib_cq *cq;
	u32 wq_num;
	enum ib_wq_state state;
	enum ib_wq_type wq_type;
	atomic_t usecnt;
};

struct ib_wq_attr {
	enum ib_wq_state wq_state;
	enum ib_wq_state curr_wq_state;
	u32 flags;
	u32 flags_mask;
};

struct ib_wq_init_attr {
	void *wq_context;
	enum ib_wq_type wq_type;
	u32 max_wr;
	u32 max_sge;
	struct ib_cq *cq;
	void (*event_handler)(struct ib_event *, void *);
	u32 create_flags;
};

struct ib_xrcd {
	struct ib_device *device;
	atomic_t usecnt;
	struct inode *inode;
	struct rw_semaphore tgt_qps_rwsem;
	struct xarray tgt_qps;
};

union ibs_fetch_ctl {
	__u64 val;
	struct {
		__u64 fetch_maxcnt: 16;
		__u64 fetch_cnt: 16;
		__u64 fetch_lat: 16;
		__u64 fetch_en: 1;
		__u64 fetch_val: 1;
		__u64 fetch_comp: 1;
		__u64 ic_miss: 1;
		__u64 phy_addr_valid: 1;
		__u64 l1tlb_pgsz: 2;
		__u64 l1tlb_miss: 1;
		__u64 l2tlb_miss: 1;
		__u64 rand_en: 1;
		__u64 fetch_l2_miss: 1;
		__u64 l3_miss_only: 1;
		__u64 fetch_oc_miss: 1;
		__u64 fetch_l3_miss: 1;
		__u64 reserved: 2;
	};
};

union ibs_op_ctl {
	__u64 val;
	struct {
		__u64 opmaxcnt: 16;
		__u64 l3_miss_only: 1;
		__u64 op_en: 1;
		__u64 op_val: 1;
		__u64 cnt_ctl: 1;
		__u64 opmaxcnt_ext: 7;
		__u64 reserved0: 5;
		__u64 opcurcnt: 27;
		__u64 reserved1: 5;
	};
};

union ibs_op_data {
	__u64 val;
	struct {
		__u64 comp_to_ret_ctr: 16;
		__u64 tag_to_ret_ctr: 16;
		__u64 reserved1: 2;
		__u64 op_return: 1;
		__u64 op_brn_taken: 1;
		__u64 op_brn_misp: 1;
		__u64 op_brn_ret: 1;
		__u64 op_rip_invalid: 1;
		__u64 op_brn_fuse: 1;
		__u64 op_microcode: 1;
		__u64 reserved2: 23;
	};
};

union ibs_op_data2 {
	__u64 val;
	struct {
		__u64 data_src_lo: 3;
		__u64 reserved0: 1;
		__u64 rmt_node: 1;
		__u64 cache_hit_st: 1;
		__u64 data_src_hi: 2;
		__u64 reserved1: 56;
	};
};

union ibs_op_data3 {
	__u64 val;
	struct {
		__u64 ld_op: 1;
		__u64 st_op: 1;
		__u64 dc_l1tlb_miss: 1;
		__u64 dc_l2tlb_miss: 1;
		__u64 dc_l1tlb_hit_2m: 1;
		__u64 dc_l1tlb_hit_1g: 1;
		__u64 dc_l2tlb_hit_2m: 1;
		__u64 dc_miss: 1;
		__u64 dc_mis_acc: 1;
		__u64 reserved: 4;
		__u64 dc_wc_mem_acc: 1;
		__u64 dc_uc_mem_acc: 1;
		__u64 dc_locked_op: 1;
		__u64 dc_miss_no_mab_alloc: 1;
		__u64 dc_lin_addr_valid: 1;
		__u64 dc_phy_addr_valid: 1;
		__u64 dc_l2_tlb_hit_1g: 1;
		__u64 l2_miss: 1;
		__u64 sw_pf: 1;
		__u64 op_mem_width: 4;
		__u64 op_dc_miss_open_mem_reqs: 6;
		__u64 dc_miss_lat: 16;
		__u64 tlb_refill_lat: 16;
	};
};

struct ibx_audio_regs {
	i915_reg_t hdmiw_hdmiedid;
	i915_reg_t aud_config;
	i915_reg_t aud_cntl_st;
	i915_reg_t aud_cntrl_st2;
};

struct ic_device {
	struct ic_device *next;
	struct net_device *dev;
	short unsigned int flags;
	short int able;
	__be32 xid;
};

struct skl_wrpll_params {
	u32 dco_fraction;
	u32 dco_integer;
	u32 qdiv_ratio;
	u32 qdiv_mode;
	u32 kdiv;
	u32 pdiv;
	u32 central_freq;
};

struct icl_combo_pll_params {
	int clock;
	struct skl_wrpll_params wrpll;
};

struct icl_ddi_buf_trans {
	u8 dw2_swing_sel;
	u8 dw7_n_scalar;
	u8 dw4_cursor_coeff;
	u8 dw4_post_cursor_2;
	u8 dw4_post_cursor_1;
};

struct icl_mg_phy_ddi_buf_trans {
	u8 cri_txdeemph_override_11_6;
	u8 cri_txdeemph_override_5_0;
	u8 cri_txdeemph_override_17_12;
};

struct icl_port_dpll {
	struct intel_shared_dpll *pll;
	struct intel_dpll_hw_state hw_state;
};

struct icl_procmon {
	const char *name;
	u32 dw1;
	u32 dw9;
	u32 dw10;
};

struct iclkip_params {
	u32 iclk_virtual_root_freq;
	u32 iclk_pi_range;
	u32 divsel;
	u32 phaseinc;
	u32 auxdiv;
	u32 phasedir;
	u32 desired_divisor;
};

struct icmp6_err {
	int err;
	int fatal;
};

struct icmp6_filter {
	__u32 data[8];
};

struct icmpv6_echo {
	__be16 identifier;
	__be16 sequence;
};

struct icmpv6_nd_advt {
	__u32 reserved: 5;
	__u32 override: 1;
	__u32 solicited: 1;
	__u32 router: 1;
	__u32 reserved2: 24;
};

struct icmpv6_nd_ra {
	__u8 hop_limit;
	__u8 reserved: 3;
	__u8 router_pref: 2;
	__u8 home_agent: 1;
	__u8 other: 1;
	__u8 managed: 1;
	__be16 rt_lifetime;
};

struct icmp6hdr {
	__u8 icmp6_type;
	__u8 icmp6_code;
	__sum16 icmp6_cksum;
	union {
		__be32 un_data32[1];
		__be16 un_data16[2];
		__u8 un_data8[4];
		struct icmpv6_echo u_echo;
		struct icmpv6_nd_advt u_nd_advt;
		struct icmpv6_nd_ra u_nd_ra;
	} icmp6_dataun;
};

struct icmphdr {
	__u8 type;
	__u8 code;
	__sum16 checksum;
	union {
		struct {
			__be16 id;
			__be16 sequence;
		} echo;
		__be32 gateway;
		struct {
			__be16 __unused;
			__be16 mtu;
		} frag;
		__u8 reserved[4];
	} un;
};

struct ip_options_rcu {
	struct callback_head rcu;
	struct ip_options opt;
};

struct ip_options_data {
	struct ip_options_rcu opt;
	char data[40];
};

struct icmp_bxm {
	struct sk_buff *skb;
	int offset;
	int data_len;
	struct {
		struct icmphdr icmph;
		__be32 times[3];
	} data;
	int head_len;
	struct ip_options_data replyopts;
};

struct icmp_control {
	enum skb_drop_reason (*handler)(struct sk_buff *);
	short int error;
};

struct icmp_err {
	int errno;
	unsigned int fatal: 1;
};

struct icmp_ext_echo_ctype3_hdr {
	__be16 afi;
	__u8 addrlen;
	__u8 reserved;
};

struct icmp_extobj_hdr {
	__be16 length;
	__u8 class_num;
	__u8 class_type;
};

struct icmp_ext_echo_iio {
	struct icmp_extobj_hdr extobj_hdr;
	union {
		char name[16];
		__be32 ifindex;
		struct {
			struct icmp_ext_echo_ctype3_hdr ctype3_hdr;
			union {
				__be32 ipv4_addr;
				struct in6_addr ipv6_addr;
			} ip_addr;
		} addr;
	} ident;
};

struct icmp_ext_hdr {
	__u8 reserved1: 4;
	__u8 version: 4;
	__u8 reserved2;
	__sum16 checksum;
};

struct icmp_filter {
	__u32 data;
};

struct icmp_mib {
	long unsigned int mibs[30];
};

struct icmpmsg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6_mib {
	long unsigned int mibs[7];
};

struct icmpv6_mib_device {
	atomic_long_t mibs[7];
};

struct icmpv6_msg {
	struct sk_buff *skb;
	int offset;
	uint8_t type;
};

struct icmpv6msg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6msg_mib_device {
	atomic_long_t mibs[512];
};

struct id_bitmap {
	long unsigned int map[4];
};

struct id_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	union {
		__u32 ruid;
		__u32 rgid;
	} r;
	union {
		__u32 euid;
		__u32 egid;
	} e;
};

struct ida_bitmap {
	long unsigned int bitmap[16];
};

struct idempotent {
	const void *cookie;
	struct hlist_node entry;
	struct completion complete;
	int ret;
};

struct idle_timer {
	struct hrtimer timer;
	int done;
};

struct idletimer_tg {
	struct list_head entry;
	struct alarm alarm;
	struct timer_list timer;
	struct work_struct work;
	struct kobject *kobj;
	struct device_attribute attr;
	unsigned int refcnt;
	u8 timer_type;
};

struct idletimer_tg_info {
	__u32 timeout;
	char label[28];
	struct idletimer_tg *timer;
};

struct idletimer_tg_info_v1 {
	__u32 timeout;
	char label[28];
	__u8 send_nl_msg;
	__u8 timer_type;
	struct idletimer_tg *timer;
};

struct idmap_legacy_upcalldata;

struct idmap {
	struct rpc_pipe_dir_object idmap_pdo;
	struct rpc_pipe *idmap_pipe;
	struct idmap_legacy_upcalldata *idmap_upcall_data;
	struct mutex idmap_mutex;
	struct user_namespace *user_ns;
};

struct idmap_key {
	bool map_up;
	u32 id;
	u32 count;
};

struct idmap_msg {
	__u8 im_type;
	__u8 im_conv;
	char im_name[128];
	__u32 im_id;
	__u8 im_status;
};

struct idmap_legacy_upcalldata {
	struct rpc_pipe_msg pipe_msg;
	struct idmap_msg idmap_msg;
	struct key *authkey;
	struct idmap *idmap;
};

struct idt_data {
	unsigned int vector;
	unsigned int segment;
	struct idt_bits bits;
	const void *addr;
};

struct ieee802154_addr {
	u8 mode;
	__le16 pan_id;
	union {
		__le16 short_addr;
		__le64 extended_addr;
	};
};

struct ieee802154_pan_device {
	__le16 pan_id;
	u8 mode;
	__le16 short_addr;
	__le64 extended_addr;
	struct list_head node;
};

struct ieee_ets {
	__u8 willing;
	__u8 ets_cap;
	__u8 cbs;
	__u8 tc_tx_bw[8];
	__u8 tc_rx_bw[8];
	__u8 tc_tsa[8];
	__u8 prio_tc[8];
	__u8 tc_reco_bw[8];
	__u8 tc_reco_tsa[8];
	__u8 reco_prio_tc[8];
};

struct ieee_maxrate {
	__u64 tc_maxrate[8];
};

struct ieee_pfc {
	__u8 pfc_cap;
	__u8 pfc_en;
	__u8 mbc;
	__u16 delay;
	__u64 requests[8];
	__u64 indications[8];
};

struct ieee_qcn {
	__u8 rpg_enable[8];
	__u32 rppp_max_rps[8];
	__u32 rpg_time_reset[8];
	__u32 rpg_byte_reset[8];
	__u32 rpg_threshold[8];
	__u32 rpg_max_rate[8];
	__u32 rpg_ai_rate[8];
	__u32 rpg_hai_rate[8];
	__u32 rpg_gd[8];
	__u32 rpg_min_dec_fac[8];
	__u32 rpg_min_rate[8];
	__u32 cndd_state_machine[8];
};

struct ieee_qcn_stats {
	__u64 rppp_rp_centiseconds[8];
	__u32 rppp_created_rps[8];
};

struct if6_iter_state {
	struct seq_net_private p;
	int bucket;
	int offset;
};

struct if_dqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
};

struct if_dqinfo {
	__u64 dqi_bgrace;
	__u64 dqi_igrace;
	__u32 dqi_flags;
	__u32 dqi_valid;
};

struct if_nextdqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
	__u32 dqb_id;
};

struct if_phonet_autoconf {
	uint8_t device;
};

struct if_phonet_req {
	char ifr_phonet_name[16];
	union {
		struct if_phonet_autoconf ifru_phonet_autoconf;
	} ifr_ifru;
};

struct if_set {
	if_mask ifs_bits[8];
};

struct if_settings {
	unsigned int type;
	unsigned int size;
	union {
		raw_hdlc_proto *raw_hdlc;
		cisco_proto *cisco;
		fr_proto *fr;
		fr_proto_pvc *fr_pvc;
		fr_proto_pvc_info *fr_pvc_info;
		x25_hdlc_proto *x25;
		sync_serial_settings *sync;
		te1_settings *te1;
	} ifs_ifsu;
};

struct if_stats_msg {
	__u8 family;
	__u8 pad1;
	__u16 pad2;
	__u32 ifindex;
	__u32 filter_mask;
};

struct ifa6_config {
	const struct in6_addr *pfx;
	unsigned int plen;
	u8 ifa_proto;
	const struct in6_addr *peer_pfx;
	u32 rt_priority;
	u32 ifa_flags;
	u32 preferred_lft;
	u32 valid_lft;
	u16 scope;
};

struct ifa_cacheinfo {
	__u32 ifa_prefered;
	__u32 ifa_valid;
	__u32 cstamp;
	__u32 tstamp;
};

struct ifacaddr6 {
	struct in6_addr aca_addr;
	struct fib6_info *aca_rt;
	struct ifacaddr6 *aca_next;
	struct hlist_node aca_addr_lst;
	int aca_users;
	refcount_t aca_refcnt;
	long unsigned int aca_cstamp;
	long unsigned int aca_tstamp;
	struct callback_head rcu;
};

struct ifaddrlblmsg {
	__u8 ifal_family;
	__u8 __ifal_reserved;
	__u8 ifal_prefixlen;
	__u8 ifal_flags;
	__u32 ifal_index;
	__u32 ifal_seq;
};

struct ifaddrmsg {
	__u8 ifa_family;
	__u8 ifa_prefixlen;
	__u8 ifa_flags;
	__u8 ifa_scope;
	__u32 ifa_index;
};

struct ifbond {
	__s32 bond_mode;
	__s32 num_slaves;
	__s32 miimon;
};

typedef struct ifbond ifbond;

struct ifreq;

struct ifconf {
	int ifc_len;
	union {
		char *ifcu_buf;
		struct ifreq *ifcu_req;
	} ifc_ifcu;
};

struct ifeheadr {
	__be16 metalen;
	u8 tlv_data[0];
};

struct ifinfomsg {
	unsigned char ifi_family;
	unsigned char __ifi_pad;
	short unsigned int ifi_type;
	int ifi_index;
	unsigned int ifi_flags;
	unsigned int ifi_change;
};

struct ifla_cacheinfo {
	__u32 max_reasm_len;
	__u32 tstamp;
	__u32 reachable_time;
	__u32 retrans_time;
};

struct ifla_vf_broadcast {
	__u8 broadcast[32];
};

struct ifla_vf_guid {
	__u32 vf;
	__u64 guid;
};

struct ifla_vf_info {
	__u32 vf;
	__u8 mac[32];
	__u32 vlan;
	__u32 qos;
	__u32 spoofchk;
	__u32 linkstate;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
	__u32 rss_query_en;
	__u32 trusted;
	__be16 vlan_proto;
};

struct ifla_vf_link_state {
	__u32 vf;
	__u32 link_state;
};

struct ifla_vf_mac {
	__u32 vf;
	__u8 mac[32];
};

struct ifla_vf_rate {
	__u32 vf;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
};

struct ifla_vf_rss_query_en {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_spoofchk {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 broadcast;
	__u64 multicast;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct ifla_vf_trust {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_tx_rate {
	__u32 vf;
	__u32 rate;
};

struct ifla_vf_vlan {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
};

struct ifla_vf_vlan_info {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
	__be16 vlan_proto;
};

struct ifla_vxlan_port_range {
	__be16 low;
	__be16 high;
};

struct ifmap {
	long unsigned int mem_start;
	long unsigned int mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct inet6_dev;

struct ip6_sf_list;

struct ifmcaddr6 {
	struct in6_addr mca_addr;
	struct inet6_dev *idev;
	struct ifmcaddr6 *next;
	struct ip6_sf_list *mca_sources;
	struct ip6_sf_list *mca_tomb;
	unsigned int mca_sfmode;
	unsigned char mca_crcount;
	long unsigned int mca_sfcount[2];
	struct delayed_work mca_work;
	unsigned int mca_flags;
	int mca_users;
	refcount_t mca_refcnt;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
	struct callback_head rcu;
};

struct ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		int ifru_ivalue;
		int ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		void *ifru_data;
		struct if_settings ifru_settings;
	} ifr_ifru;
};

struct ifslave {
	__s32 slave_id;
	char slave_name[16];
	__s8 link;
	__s8 state;
	__u32 link_failure_count;
};

typedef struct ifslave ifslave;

struct igmp6_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct igmp6_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
	struct ifmcaddr6 *im;
};

struct in_device;

struct igmp_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *in_dev;
};

struct ip_mc_list;

struct igmp_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *idev;
	struct ip_mc_list *im;
};

struct igmphdr {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
};

struct igmpmsg {
	__u32 unused1;
	__u32 unused2;
	unsigned char im_msgtype;
	unsigned char im_mbz;
	unsigned char im_vif;
	unsigned char im_vif_hi;
	struct in_addr im_src;
	struct in_addr im_dst;
};

struct igmpv3_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	__be32 grec_mca;
	__be32 grec_src[0];
};

struct igmpv3_query {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
	__u8 qrv: 3;
	__u8 suppress: 1;
	__u8 resv: 4;
	__u8 qqic;
	__be16 nsrcs;
	__be32 srcs[0];
};

struct igmpv3_report {
	__u8 type;
	__u8 resv1;
	__sum16 csum;
	__be16 resv2;
	__be16 ngrec;
	struct igmpv3_grec grec[0];
};

struct ila_locator {
	union {
		__u8 v8[8];
		__be16 v16[4];
		__be32 v32[2];
		__be64 v64;
	};
};

struct ila_identifier {
	union {
		struct {
			u8 __space: 4;
			u8 csum_neutral: 1;
			u8 type: 3;
			u8 __space2[7];
		};
		__u8 v8[8];
		__be16 v16[4];
		__be32 v32[2];
		__be64 v64;
	};
};

struct ila_addr {
	union {
		struct in6_addr addr;
		struct {
			struct ila_locator loc;
			struct ila_identifier ident;
		};
	};
};

struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhlist_head *list;
	struct rhashtable_walker walker;
	unsigned int slot;
	unsigned int skip;
	bool end_of_table;
};

struct ila_dump_iter {
	struct rhashtable_iter rhiter;
	int skip;
};

struct ila_params {
	struct ila_locator locator;
	struct ila_locator locator_match;
	__wsum csum_diff;
	u8 csum_mode;
	u8 ident_type;
};

struct ila_lwt {
	struct ila_params p;
	struct dst_cache dst_cache;
	u32 connected: 1;
	u32 lwt_output: 1;
};

struct ila_xlat_params {
	struct ila_params ip;
	int ifindex;
};

struct ila_map {
	struct ila_xlat_params xp;
	struct rhash_head node;
	struct ila_map *next;
	struct callback_head rcu;
};

struct ila_net {
	struct {
		struct rhashtable rhash_table;
		spinlock_t *locks;
		unsigned int locks_mask;
		bool hooks_registered;
	} xlat;
};

struct ilk_wm_maximums {
	u16 pri;
	u16 spr;
	u16 cur;
	u16 fbc;
};

struct illinois {
	u64 sum_rtt;
	u16 cnt_rtt;
	u32 base_rtt;
	u32 max_rtt;
	u32 end_seq;
	u32 alpha;
	u32 beta;
	u16 acked;
	u8 rtt_above;
	u8 rtt_low;
};

struct ima_algo_desc {
	struct crypto_shash *tfm;
	enum hash_algo algo;
};

struct ima_digest_data_hdr {
	u8 algo;
	u8 length;
	union {
		struct {
			u8 unused;
			u8 type;
		} sha1;
		struct {
			u8 type;
			u8 algo;
		} ng;
		u8 data[2];
	} xattr;
};

struct ima_digest_data {
	union {
		struct {
			u8 algo;
			u8 length;
			union {
				struct {
					u8 unused;
					u8 type;
				} sha1;
				struct {
					u8 type;
					u8 algo;
				} ng;
				u8 data[2];
			} xattr;
		};
		struct ima_digest_data_hdr hdr;
	};
	u8 digest[0];
};

struct modsig;

struct ima_iint_cache;

struct ima_event_data {
	struct ima_iint_cache *iint;
	struct file *file;
	const unsigned char *filename;
	struct evm_ima_xattr_data *xattr_value;
	int xattr_len;
	const struct modsig *modsig;
	const char *violation;
	const void *buf;
	int buf_len;
};

struct ima_field_data {
	u8 *data;
	u32 len;
};

struct ima_file_id {
	__u8 hash_type;
	__u8 hash_algorithm;
	__u8 hash[64];
};

struct ima_h_table {
	atomic_long_t len;
	atomic_long_t violations;
	struct hlist_head queue[1024];
};

struct integrity_inode_attributes {
	u64 version;
	long unsigned int ino;
	dev_t dev;
};

struct ima_iint_cache {
	struct mutex mutex;
	struct integrity_inode_attributes real_inode;
	long unsigned int flags;
	long unsigned int measured_pcrs;
	long unsigned int atomic_flags;
	enum integrity_status ima_file_status: 4;
	enum integrity_status ima_mmap_status: 4;
	enum integrity_status ima_bprm_status: 4;
	enum integrity_status ima_read_status: 4;
	enum integrity_status ima_creds_status: 4;
	struct ima_digest_data *ima_hash;
};

struct ima_kexec_hdr {
	u16 version;
	u16 _reserved0;
	u32 _reserved1;
	u64 buffer_size;
	u64 count;
};

struct ima_key_entry {
	struct list_head list;
	void *payload;
	size_t payload_len;
	char *keyring_name;
};

struct ima_max_digest_data {
	struct ima_digest_data_hdr hdr;
	u8 digest[64];
};

struct ima_template_entry;

struct ima_queue_entry {
	struct hlist_node hnext;
	struct list_head later;
	struct ima_template_entry *entry;
};

struct ima_rule_opt_list;

struct ima_template_desc;

struct ima_rule_entry {
	struct list_head list;
	int action;
	unsigned int flags;
	enum ima_hooks func;
	int mask;
	long unsigned int fsmagic;
	uuid_t fsuuid;
	kuid_t uid;
	kgid_t gid;
	kuid_t fowner;
	kgid_t fgroup;
	bool (*uid_op)(kuid_t, kuid_t);
	bool (*gid_op)(kgid_t, kgid_t);
	bool (*fowner_op)(vfsuid_t, kuid_t);
	bool (*fgroup_op)(vfsgid_t, kgid_t);
	int pcr;
	unsigned int allowed_algos;
	struct {
		void *rule;
		char *args_p;
		int type;
	} lsm[6];
	char *fsname;
	struct ima_rule_opt_list *keyrings;
	struct ima_rule_opt_list *label;
	struct ima_template_desc *template;
};

struct ima_rule_opt_list {
	size_t count;
	char *items[0];
};

struct ima_setup_data {
	__u64 addr;
	__u64 size;
};

struct ima_template_field;

struct ima_template_desc {
	struct list_head list;
	char *name;
	char *fmt;
	int num_fields;
	const struct ima_template_field **fields;
};

struct tpm_digest;

struct ima_template_entry {
	int pcr;
	struct tpm_digest *digests;
	struct ima_template_desc *template_desc;
	u32 template_data_len;
	struct ima_field_data template_data[0];
};

struct ima_template_field {
	const char field_id[16];
	int (*field_init)(struct ima_event_data *, struct ima_field_data *);
	void (*field_show)(struct seq_file *, enum ima_show_type, struct ima_field_data *);
};

struct imc_uncore_pci_dev {
	__u32 pci_id;
	struct pci_driver *driver;
};

struct in6_flowlabel_req {
	struct in6_addr flr_dst;
	__be32 flr_label;
	__u8 flr_action;
	__u8 flr_share;
	__u16 flr_flags;
	__u16 flr_expires;
	__u16 flr_linger;
	__u32 __flr_pad;
};

struct in6_ifreq {
	struct in6_addr ifr6_addr;
	__u32 ifr6_prefixlen;
	int ifr6_ifindex;
};

struct in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	__u32 rtmsg_type;
	__u16 rtmsg_dst_len;
	__u16 rtmsg_src_len;
	__u32 rtmsg_metric;
	long unsigned int rtmsg_info;
	__u32 rtmsg_flags;
	int rtmsg_ifindex;
};

struct in6_validator_info {
	struct in6_addr i6vi_addr;
	struct inet6_dev *i6vi_dev;
	struct netlink_ext_ack *extack;
};

struct in_ctrl_info {
	__u8 Last_NHRP_CIE_code;
	__u8 Last_Q2931_cause_value;
	__u8 eg_MPC_ATM_addr[20];
	__be32 tag;
	__be32 in_dst_ip;
	__u16 holding_time;
	__u32 request_id;
};

struct in_cache_entry {
	struct in_cache_entry *next;
	struct in_cache_entry *prev;
	time64_t time;
	time64_t reply_wait;
	time64_t hold_down;
	uint32_t packets_fwded;
	uint16_t entry_state;
	uint32_t retry_time;
	uint32_t refresh_time;
	uint32_t count;
	struct atm_vcc *shortcut;
	uint8_t MPS_ctrl_ATM_addr[20];
	struct in_ctrl_info ctrl_info;
	refcount_t use;
};

typedef struct in_cache_entry in_cache_entry;

struct in_cache_ops {
	in_cache_entry * (*add_entry)(__be32, struct mpoa_client *);
	in_cache_entry * (*get)(__be32, struct mpoa_client *);
	in_cache_entry * (*get_with_mask)(__be32, struct mpoa_client *, __be32);
	in_cache_entry * (*get_by_vcc)(struct atm_vcc *, struct mpoa_client *);
	void (*put)(in_cache_entry *);
	void (*remove_entry)(in_cache_entry *, struct mpoa_client *);
	int (*cache_hit)(in_cache_entry *, struct mpoa_client *);
	void (*clear_count)(struct mpoa_client *);
	void (*check_resolving)(struct mpoa_client *);
	void (*refresh)(struct mpoa_client *);
	void (*destroy_cache)(struct mpoa_client *);
};

typedef struct in_ctrl_info in_ctrl_info;

struct ipv4_devconf {
	void *sysctl;
	int data[33];
	long unsigned int state[1];
};

struct in_ifaddr;

struct neigh_parms;

struct in_device {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	refcount_t refcnt;
	int dead;
	struct in_ifaddr *ifa_list;
	struct ip_mc_list *mc_list;
	struct ip_mc_list **mc_hash;
	int mc_count;
	spinlock_t mc_tomb_lock;
	struct ip_mc_list *mc_tomb;
	long unsigned int mr_v1_seen;
	long unsigned int mr_v2_seen;
	long unsigned int mr_maxdelay;
	long unsigned int mr_qi;
	long unsigned int mr_qri;
	unsigned char mr_qrv;
	unsigned char mr_gq_running;
	u32 mr_ifc_count;
	struct timer_list mr_gq_timer;
	struct timer_list mr_ifc_timer;
	struct neigh_parms *arp_parms;
	struct ipv4_devconf cnf;
	struct callback_head callback_head;
};

struct in_ifaddr {
	struct hlist_node addr_lst;
	struct in_ifaddr *ifa_next;
	struct in_device *ifa_dev;
	struct callback_head callback_head;
	__be32 ifa_local;
	__be32 ifa_address;
	__be32 ifa_mask;
	__u32 ifa_rt_priority;
	__be32 ifa_broadcast;
	unsigned char ifa_scope;
	unsigned char ifa_prefixlen;
	unsigned char ifa_proto;
	__u32 ifa_flags;
	char ifa_label[16];
	__u32 ifa_valid_lft;
	__u32 ifa_preferred_lft;
	long unsigned int ifa_cstamp;
	long unsigned int ifa_tstamp;
};

struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst;
	struct in_addr ipi_addr;
};

struct in_validator_info {
	__be32 ivi_addr;
	struct in_device *ivi_dev;
	struct netlink_ext_ack *extack;
};

struct ipv6_stable_secret {
	bool initialized;
	struct in6_addr secret;
};

struct ipv6_devconf {
	__u8 __cacheline_group_begin__ipv6_devconf_read_txrx[0];
	__s32 disable_ipv6;
	__s32 hop_limit;
	__s32 mtu6;
	__s32 forwarding;
	__s32 disable_policy;
	__s32 proxy_ndp;
	__u8 __cacheline_group_end__ipv6_devconf_read_txrx[0];
	__s32 accept_ra;
	__s32 accept_redirects;
	__s32 autoconf;
	__s32 dad_transmits;
	__s32 rtr_solicits;
	__s32 rtr_solicit_interval;
	__s32 rtr_solicit_max_interval;
	__s32 rtr_solicit_delay;
	__s32 force_mld_version;
	__s32 mldv1_unsolicited_report_interval;
	__s32 mldv2_unsolicited_report_interval;
	__s32 use_tempaddr;
	__s32 temp_valid_lft;
	__s32 temp_prefered_lft;
	__s32 regen_min_advance;
	__s32 regen_max_retry;
	__s32 max_desync_factor;
	__s32 max_addresses;
	__s32 accept_ra_defrtr;
	__u32 ra_defrtr_metric;
	__s32 accept_ra_min_hop_limit;
	__s32 accept_ra_min_lft;
	__s32 accept_ra_pinfo;
	__s32 ignore_routes_with_linkdown;
	__s32 accept_ra_rtr_pref;
	__s32 rtr_probe_interval;
	__s32 accept_ra_rt_info_min_plen;
	__s32 accept_ra_rt_info_max_plen;
	__s32 accept_source_route;
	__s32 accept_ra_from_local;
	__s32 optimistic_dad;
	__s32 use_optimistic;
	atomic_t mc_forwarding;
	__s32 drop_unicast_in_l2_multicast;
	__s32 accept_dad;
	__s32 force_tllao;
	__s32 ndisc_notify;
	__s32 suppress_frag_ndisc;
	__s32 accept_ra_mtu;
	__s32 drop_unsolicited_na;
	__s32 accept_untracked_na;
	struct ipv6_stable_secret stable_secret;
	__s32 use_oif_addrs_only;
	__s32 keep_addr_on_down;
	__s32 seg6_enabled;
	__s32 seg6_require_hmac;
	__u32 enhanced_dad;
	__u32 addr_gen_mode;
	__s32 ndisc_tclass;
	__s32 rpl_seg_enabled;
	__u32 ioam6_id;
	__u32 ioam6_id_wide;
	__u8 ioam6_enabled;
	__u8 ndisc_evict_nocarrier;
	__u8 ra_honor_pio_life;
	__u8 ra_honor_pio_pflag;
	struct ctl_table_header *sysctl_header;
};

struct ipstats_mib;

struct ipv6_devstat {
	struct proc_dir_entry *proc_dir_entry;
	struct ipstats_mib *ipv6;
	struct icmpv6_mib_device *icmpv6dev;
	struct icmpv6msg_mib_device *icmpv6msgdev;
};

struct inet6_dev {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head addr_list;
	struct ifmcaddr6 *mc_list;
	struct ifmcaddr6 *mc_tomb;
	unsigned char mc_qrv;
	unsigned char mc_gq_running;
	unsigned char mc_ifc_count;
	unsigned char mc_dad_count;
	long unsigned int mc_v1_seen;
	long unsigned int mc_qi;
	long unsigned int mc_qri;
	long unsigned int mc_maxdelay;
	struct delayed_work mc_gq_work;
	struct delayed_work mc_ifc_work;
	struct delayed_work mc_dad_work;
	struct delayed_work mc_query_work;
	struct delayed_work mc_report_work;
	struct sk_buff_head mc_query_queue;
	struct sk_buff_head mc_report_queue;
	spinlock_t mc_query_lock;
	spinlock_t mc_report_lock;
	struct mutex mc_lock;
	struct ifacaddr6 *ac_list;
	rwlock_t lock;
	refcount_t refcnt;
	__u32 if_flags;
	int dead;
	u32 desync_factor;
	struct list_head tempaddr_list;
	struct in6_addr token;
	struct neigh_parms *nd_parms;
	struct ipv6_devconf cnf;
	struct ipv6_devstat stats;
	struct timer_list rs_timer;
	__s32 rs_interval;
	__u8 rs_probes;
	long unsigned int tstamp;
	struct callback_head rcu;
	unsigned int ra_mtu;
};

struct inet6_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
	enum addr_type_t type;
	bool force_rt_scope_universe;
};

struct inet6_ifaddr {
	struct in6_addr addr;
	__u32 prefix_len;
	__u32 rt_priority;
	__u32 valid_lft;
	__u32 prefered_lft;
	refcount_t refcnt;
	spinlock_t lock;
	int state;
	__u32 flags;
	__u8 dad_probes;
	__u8 stable_privacy_retry;
	__u16 scope;
	__u64 dad_nonce;
	long unsigned int cstamp;
	long unsigned int tstamp;
	struct delayed_work dad_work;
	struct inet6_dev *idev;
	struct fib6_info *rt;
	struct hlist_node addr_lst;
	struct list_head if_list;
	struct list_head if_list_aux;
	struct list_head tmp_list;
	struct inet6_ifaddr *ifpub;
	int regen_count;
	bool tokenized;
	u8 ifa_proto;
	struct callback_head rcu;
	struct in6_addr peer_addr;
};

struct inet6_protocol {
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	unsigned int flags;
	u32 secret;
};

union inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

struct inet_bind2_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	short unsigned int addr_type;
	struct in6_addr v6_rcv_saddr;
	struct hlist_node node;
	struct hlist_node bhash_node;
	struct hlist_head owners;
};

struct inet_bind_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct in6_addr fast_v6_rcv_saddr;
	__be32 fast_rcv_saddr;
	short unsigned int fast_sk_family;
	bool fast_ipv6_only;
	struct hlist_node node;
	struct hlist_head bhash2;
};

struct inet_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct inet_connection_sock_af_ops {
	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
	void (*send_check)(struct sock *, struct sk_buff *);
	int (*rebuild_header)(struct sock *);
	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
	int (*conn_request)(struct sock *, struct sk_buff *);
	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
	u16 net_header_len;
	u16 sockaddr_len;
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
	void (*mtu_reduced)(struct sock *);
};

struct inet_diag_bc_op {
	unsigned char code;
	unsigned char yes;
	short unsigned int no;
};

struct inet_diag_dump_data {
	struct nlattr *req_nlas[4];
	struct bpf_sk_storage_diag *bpf_stg_diag;
};

struct inet_diag_entry {
	const __be32 *saddr;
	const __be32 *daddr;
	u16 sport;
	u16 dport;
	u16 family;
	u16 userlocks;
	u32 ifindex;
	u32 mark;
	u64 cgroup_id;
};

struct inet_diag_req_v2;

struct inet_diag_msg;

struct inet_diag_handler {
	struct module *owner;
	void (*dump)(struct sk_buff *, struct netlink_callback *, const struct inet_diag_req_v2 *);
	int (*dump_one)(struct netlink_callback *, const struct inet_diag_req_v2 *);
	void (*idiag_get_info)(struct sock *, struct inet_diag_msg *, void *);
	int (*idiag_get_aux)(struct sock *, bool, struct sk_buff *);
	size_t (*idiag_get_aux_size)(struct sock *, bool);
	int (*destroy)(struct sk_buff *, const struct inet_diag_req_v2 *);
	__u16 idiag_type;
	__u16 idiag_info_size;
};

struct inet_diag_hostcond {
	__u8 family;
	__u8 prefix_len;
	int port;
	__be32 addr[0];
};

struct inet_diag_markcond {
	__u32 mark;
	__u32 mask;
};

struct inet_diag_meminfo {
	__u32 idiag_rmem;
	__u32 idiag_wmem;
	__u32 idiag_fmem;
	__u32 idiag_tmem;
};

struct inet_diag_sockid {
	__be16 idiag_sport;
	__be16 idiag_dport;
	__be32 idiag_src[4];
	__be32 idiag_dst[4];
	__u32 idiag_if;
	__u32 idiag_cookie[2];
};

struct inet_diag_msg {
	__u8 idiag_family;
	__u8 idiag_state;
	__u8 idiag_timer;
	__u8 idiag_retrans;
	struct inet_diag_sockid id;
	__u32 idiag_expires;
	__u32 idiag_rqueue;
	__u32 idiag_wqueue;
	__u32 idiag_uid;
	__u32 idiag_inode;
};

struct inet_diag_req {
	__u8 idiag_family;
	__u8 idiag_src_len;
	__u8 idiag_dst_len;
	__u8 idiag_ext;
	struct inet_diag_sockid id;
	__u32 idiag_states;
	__u32 idiag_dbs;
};

struct inet_diag_req_raw {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u8 idiag_ext;
	__u8 sdiag_raw_protocol;
	__u32 idiag_states;
	struct inet_diag_sockid id;
};

struct inet_diag_req_v2 {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u8 idiag_ext;
	__u8 pad;
	__u32 idiag_states;
	struct inet_diag_sockid id;
};

struct inet_diag_sockopt {
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 unused: 5;
};

struct inet_ehash_bucket {
	struct hlist_nulls_head chain;
};

struct inet_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
};

struct inet_frags {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue *, const void *);
	void (*destructor)(struct inet_frag_queue *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct inet_listen_hashbucket;

struct inet_hashinfo {
	struct inet_ehash_bucket *ehash;
	spinlock_t *ehash_locks;
	unsigned int ehash_mask;
	unsigned int ehash_locks_mask;
	struct kmem_cache *bind_bucket_cachep;
	struct inet_bind_hashbucket *bhash;
	struct kmem_cache *bind2_bucket_cachep;
	struct inet_bind_hashbucket *bhash2;
	unsigned int bhash_size;
	unsigned int lhash2_mask;
	struct inet_listen_hashbucket *lhash2;
	bool pernet;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct inet_listen_hashbucket {
	spinlock_t lock;
	struct hlist_nulls_head nulls_head;
};

struct ipv4_addr_key {
	__be32 addr;
	int vif;
};

struct inetpeer_addr {
	union {
		struct ipv4_addr_key a4;
		struct in6_addr a6;
		u32 key[4];
	};
	__u16 family;
};

struct inet_peer {
	struct rb_node rb_node;
	struct inetpeer_addr daddr;
	u32 metrics[17];
	u32 rate_tokens;
	u32 n_redirects;
	long unsigned int rate_last;
	union {
		struct {
			atomic_t rid;
		};
		struct callback_head rcu;
	};
	__u32 dtime;
	refcount_t refcnt;
};

struct inet_protosw {
	struct list_head list;
	short unsigned int type;
	short unsigned int protocol;
	struct proto *prot;
	const struct proto_ops *ops;
	unsigned char flags;
};

struct inet_timewait_death_row {
	refcount_t tw_refcount;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct inet_hashinfo *hashinfo;
	int sysctl_max_tw_buckets;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct inet_timewait_sock {
	struct sock_common __tw_common;
	__u32 tw_mark;
	unsigned char tw_substate;
	unsigned char tw_rcv_wscale;
	__be16 tw_sport;
	unsigned int tw_transparent: 1;
	unsigned int tw_flowlabel: 20;
	unsigned int tw_usec_ts: 1;
	unsigned int tw_pad: 2;
	unsigned int tw_tos: 8;
	u32 tw_txhash;
	u32 tw_priority;
	u32 tw_entry_stamp;
	struct timer_list tw_timer;
	struct inet_bind_bucket *tw_tb;
	struct inet_bind2_bucket *tw_tb2;
};

struct inflate_state {
	inflate_mode mode;
	int last;
	int wrap;
	int havedict;
	int flags;
	unsigned int dmax;
	long unsigned int check;
	long unsigned int total;
	unsigned int wbits;
	unsigned int wsize;
	unsigned int whave;
	unsigned int write;
	unsigned char *window;
	long unsigned int hold;
	unsigned int bits;
	unsigned int length;
	unsigned int offset;
	unsigned int extra;
	const code *lencode;
	const code *distcode;
	unsigned int lenbits;
	unsigned int distbits;
	unsigned int ncode;
	unsigned int nlen;
	unsigned int ndist;
	unsigned int have;
	code *next;
	short unsigned int lens[320];
	short unsigned int work[288];
	code codes[2048];
};

struct inflate_workspace {
	struct inflate_state inflate_state;
	unsigned char working_window[32768];
};

struct ingress_sched_data {
	struct tcf_block *block;
	struct tcf_block_ext_info block_info;
	struct mini_Qdisc_pair miniqp;
};

struct x86_mapping_info;

struct init_pgtable_data {
	struct x86_mapping_info *info;
	pgd_t *level4p;
};

struct init_sequence {
	int (*init_func)(void);
	void (*exit_func)(void);
};

struct inode_defrag {
	struct rb_node rb_node;
	u64 ino;
	u64 transid;
	u64 root;
	u32 extent_thresh;
};

struct inode_fs_paths {
	struct btrfs_path *btrfs_path;
	struct btrfs_root *fs_root;
	struct btrfs_data_container *fspath;
};

struct mnt_idmap;

struct kstat;

struct offset_ctx;

struct inode_operations {
	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
	int (*permission)(struct mnt_idmap *, struct inode *, int);
	struct posix_acl * (*get_inode_acl)(struct inode *, int, bool);
	int (*readlink)(struct dentry *, char *, int);
	int (*create)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t, bool);
	int (*link)(struct dentry *, struct inode *, struct dentry *);
	int (*unlink)(struct inode *, struct dentry *);
	int (*symlink)(struct mnt_idmap *, struct inode *, struct dentry *, const char *);
	int (*mkdir)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t);
	int (*rmdir)(struct inode *, struct dentry *);
	int (*mknod)(struct mnt_idmap *, struct inode *, struct dentry *, umode_t, dev_t);
	int (*rename)(struct mnt_idmap *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
	int (*setattr)(struct mnt_idmap *, struct dentry *, struct iattr *);
	int (*getattr)(struct mnt_idmap *, const struct path *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode *, int);
	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
	int (*tmpfile)(struct mnt_idmap *, struct inode *, struct file *, umode_t);
	struct posix_acl * (*get_acl)(struct mnt_idmap *, struct dentry *, int);
	int (*set_acl)(struct mnt_idmap *, struct dentry *, struct posix_acl *, int);
	int (*fileattr_set)(struct mnt_idmap *, struct dentry *, struct fileattr *);
	int (*fileattr_get)(struct dentry *, struct fileattr *);
	struct offset_ctx * (*get_offset_ctx)(struct inode *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct inode_switch_wbs_context {
	struct rcu_work work;
	struct bdi_writeback *new_wb;
	struct inode *inodes[0];
};

struct inodes_stat_t {
	long int nr_inodes;
	long int nr_unused;
	long int dummy[5];
};

struct inotify_event {
	__s32 wd;
	__u32 mask;
	__u32 cookie;
	__u32 len;
	char name[0];
};

struct inotify_event_info {
	struct fsnotify_event fse;
	u32 mask;
	int wd;
	u32 sync_cookie;
	int name_len;
	char name[0];
};

struct inotify_inode_mark {
	struct fsnotify_mark fsn_mark;
	int wd;
};

struct input_absinfo {
	__s32 value;
	__s32 minimum;
	__s32 maximum;
	__s32 fuzz;
	__s32 flat;
	__s32 resolution;
};

struct input_id {
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
};

struct input_dev_poller;

struct input_mt;

struct input_dev {
	const char *name;
	const char *phys;
	const char *uniq;
	struct input_id id;
	long unsigned int propbit[1];
	long unsigned int evbit[1];
	long unsigned int keybit[12];
	long unsigned int relbit[1];
	long unsigned int absbit[1];
	long unsigned int mscbit[1];
	long unsigned int ledbit[1];
	long unsigned int sndbit[1];
	long unsigned int ffbit[2];
	long unsigned int swbit[1];
	unsigned int hint_events_per_packet;
	unsigned int keycodemax;
	unsigned int keycodesize;
	void *keycode;
	int (*setkeycode)(struct input_dev *, const struct input_keymap_entry *, unsigned int *);
	int (*getkeycode)(struct input_dev *, struct input_keymap_entry *);
	struct ff_device *ff;
	struct input_dev_poller *poller;
	unsigned int repeat_key;
	struct timer_list timer;
	int rep[2];
	struct input_mt *mt;
	struct input_absinfo *absinfo;
	long unsigned int key[12];
	long unsigned int led[1];
	long unsigned int snd[1];
	long unsigned int sw[1];
	int (*open)(struct input_dev *);
	void (*close)(struct input_dev *);
	int (*flush)(struct input_dev *, struct file *);
	int (*event)(struct input_dev *, unsigned int, unsigned int, int);
	struct input_handle *grab;
	spinlock_t event_lock;
	struct mutex mutex;
	unsigned int users;
	bool going_away;
	struct device dev;
	struct list_head h_list;
	struct list_head node;
	unsigned int num_vals;
	unsigned int max_vals;
	struct input_value *vals;
	bool devres_managed;
	ktime_t timestamp[3];
	bool inhibited;
};

struct input_dev_poller {
	void (*poll)(struct input_dev *);
	unsigned int poll_interval;
	unsigned int poll_interval_max;
	unsigned int poll_interval_min;
	struct input_dev *input;
	struct delayed_work work;
};

struct input_device_id {
	kernel_ulong_t flags;
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
	kernel_ulong_t evbit[1];
	kernel_ulong_t keybit[12];
	kernel_ulong_t relbit[1];
	kernel_ulong_t absbit[1];
	kernel_ulong_t mscbit[1];
	kernel_ulong_t ledbit[1];
	kernel_ulong_t sndbit[1];
	kernel_ulong_t ffbit[2];
	kernel_ulong_t swbit[1];
	kernel_ulong_t propbit[1];
	kernel_ulong_t driver_info;
};

struct input_devres {
	struct input_dev *input;
};

struct input_handler {
	void *private;
	void (*event)(struct input_handle *, unsigned int, unsigned int, int);
	unsigned int (*events)(struct input_handle *, struct input_value *, unsigned int);
	bool (*filter)(struct input_handle *, unsigned int, unsigned int, int);
	bool (*match)(struct input_handler *, struct input_dev *);
	int (*connect)(struct input_handler *, struct input_dev *, const struct input_device_id *);
	void (*disconnect)(struct input_handle *);
	void (*start)(struct input_handle *);
	bool passive_observer;
	bool legacy_minors;
	int minor;
	const char *name;
	const struct input_device_id *id_table;
	struct list_head h_list;
	struct list_head node;
};

struct led_pattern;

struct led_trigger;

struct led_hw_trigger_type;

struct led_classdev {
	const char *name;
	unsigned int brightness;
	unsigned int max_brightness;
	unsigned int color;
	int flags;
	long unsigned int work_flags;
	void (*brightness_set)(struct led_classdev *, enum led_brightness);
	int (*brightness_set_blocking)(struct led_classdev *, enum led_brightness);
	enum led_brightness (*brightness_get)(struct led_classdev *);
	int (*blink_set)(struct led_classdev *, long unsigned int *, long unsigned int *);
	int (*pattern_set)(struct led_classdev *, struct led_pattern *, u32, int);
	int (*pattern_clear)(struct led_classdev *);
	struct device *dev;
	const struct attribute_group **groups;
	struct list_head node;
	const char *default_trigger;
	long unsigned int blink_delay_on;
	long unsigned int blink_delay_off;
	struct timer_list blink_timer;
	int blink_brightness;
	int new_blink_brightness;
	void (*flash_resume)(struct led_classdev *);
	struct workqueue_struct *wq;
	struct work_struct set_brightness_work;
	int delayed_set_value;
	long unsigned int delayed_delay_on;
	long unsigned int delayed_delay_off;
	struct rw_semaphore trigger_lock;
	struct led_trigger *trigger;
	struct list_head trig_list;
	void *trigger_data;
	bool activated;
	struct led_hw_trigger_type *trigger_type;
	const char *hw_control_trigger;
	int (*hw_control_is_supported)(struct led_classdev *, long unsigned int);
	int (*hw_control_set)(struct led_classdev *, long unsigned int);
	int (*hw_control_get)(struct led_classdev *, long unsigned int *);
	struct device * (*hw_control_get_device)(struct led_classdev *);
	struct mutex led_access;
};

struct input_led {
	struct led_classdev cdev;
	struct input_handle *handle;
	unsigned int code;
};

struct input_leds {
	struct input_handle handle;
	unsigned int num_leds;
	struct input_led leds[0];
};

struct input_mask {
	__u32 type;
	__u32 codes_size;
	__u64 codes_ptr;
};

struct input_mt_slot {
	int abs[14];
	unsigned int frame;
	unsigned int key;
};

struct input_mt {
	int trkid;
	int num_slots;
	int slot;
	unsigned int flags;
	unsigned int frame;
	int *red;
	struct input_mt_slot slots[0];
};

struct input_res {
	u16 w;
	u16 h;
};

struct input_seq_state {
	short unsigned int pos;
	bool mutex_acquired;
	int input_devices_state;
};

struct input_value {
	__u16 type;
	__u16 code;
	__s32 value;
};

struct insert_entries {
	struct i915_address_space *vm;
	struct i915_vma_resource *vma_res;
	unsigned int pat_index;
	u32 flags;
};

struct insert_page {
	struct i915_address_space *vm;
	dma_addr_t addr;
	u64 offset;
	unsigned int pat_index;
};

struct insert_pte_data {
	u64 offset;
};

struct insn_field {
	union {
		insn_value_t value;
		insn_byte_t bytes[4];
	};
	unsigned char got;
	unsigned char nbytes;
};

struct insn {
	struct insn_field prefixes;
	struct insn_field rex_prefix;
	struct insn_field vex_prefix;
	struct insn_field opcode;
	struct insn_field modrm;
	struct insn_field sib;
	struct insn_field displacement;
	union {
		struct insn_field immediate;
		struct insn_field moffset1;
		struct insn_field immediate1;
	};
	union {
		struct insn_field moffset2;
		struct insn_field immediate2;
	};
	int emulate_prefix_size;
	insn_attr_t attr;
	unsigned char opnd_bytes;
	unsigned char addr_bytes;
	unsigned char length;
	unsigned char x86_64;
	const insn_byte_t *kaddr;
	const insn_byte_t *end_kaddr;
	const insn_byte_t *next_byte;
};

union intcapxt {
	u64 capxt;
	struct {
		u64 reserved_0: 2;
		u64 dest_mode_logical: 1;
		u64 reserved_1: 5;
		u64 destid_0_23: 24;
		u64 vector: 8;
		u64 reserved_2: 16;
		u64 destid_24_31: 8;
	};
};

struct intel_agp_driver_description {
	unsigned int chip_id;
	char *name;
	const struct agp_bridge_driver *driver;
};

struct intel_dp_tunnel_inherited_state;

struct intel_atomic_state {
	struct drm_atomic_state base;
	intel_wakeref_t wakeref;
	struct __intel_global_objs_state *global_objs;
	int num_global_objs;
	bool internal;
	bool dpll_set;
	bool modeset;
	struct intel_shared_dpll_state shared_dpll[9];
	struct intel_dp_tunnel_inherited_state *inherited_dp_tunnels;
	bool skip_intermediate_wm;
	bool rps_interactive;
	struct work_struct cleanup_work;
};

struct intel_crtc_state;

struct intel_audio_funcs {
	void (*audio_codec_enable)(struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*audio_codec_disable)(struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*audio_codec_get_config)(struct intel_encoder *, struct intel_crtc_state *);
};

struct intel_bios_encoder_data {
	struct intel_display *display;
	struct child_device_config child;
	struct dsc_compression_parameters_entry *dsc;
	struct list_head node;
};

struct intel_breadcrumbs {
	struct kref ref;
	atomic_t active;
	spinlock_t signalers_lock;
	struct list_head signalers;
	struct llist_head signaled_requests;
	atomic_t signaler_active;
	spinlock_t irq_lock;
	struct irq_work irq_work;
	unsigned int irq_enabled;
	intel_wakeref_t irq_armed;
	intel_engine_mask_t engine_mask;
	struct intel_engine_cs *irq_engine;
	bool (*irq_enable)(struct intel_breadcrumbs *);
	void (*irq_disable)(struct intel_breadcrumbs *);
};

struct intel_global_commit;

struct intel_global_state {
	struct intel_global_obj *obj;
	struct intel_atomic_state *state;
	struct intel_global_commit *commit;
	struct kref ref;
	bool changed;
	bool serialized;
};

struct intel_dbuf_bw {
	unsigned int max_bw[4];
	u8 active_planes[4];
};

struct intel_bw_state {
	struct intel_global_state base;
	struct intel_dbuf_bw dbuf_bw[4];
	u8 pipe_sagv_reject;
	u8 active_pipes;
	u16 qgv_point_peakbw;
	u16 qgv_points_mask;
	bool force_check_qgv;
	int min_cdclk[4];
	unsigned int data_rate[4];
	u8 num_active_planes[4];
};

struct intel_cdclk_funcs {
	void (*get_cdclk)(struct intel_display *, struct intel_cdclk_config *);
	void (*set_cdclk)(struct intel_display *, const struct intel_cdclk_config *, enum pipe);
	int (*modeset_calc_cdclk)(struct intel_atomic_state *);
	u8 (*calc_voltage_level)(int);
};

struct intel_cdclk_state {
	struct intel_global_state base;
	struct intel_cdclk_config logical;
	struct intel_cdclk_config actual;
	int bw_min_cdclk;
	int min_cdclk[4];
	u8 min_voltage_level[4];
	enum pipe pipe;
	int force_min_cdclk;
	u8 active_pipes;
	bool disable_pipes;
};

struct intel_cdclk_vals {
	u32 cdclk;
	u16 refclk;
	u16 waveform;
	u8 ratio;
};

struct intel_crtc;

struct intel_dsb;

struct intel_color_funcs {
	int (*color_check)(struct intel_atomic_state *, struct intel_crtc *);
	void (*color_commit_noarm)(struct intel_dsb *, const struct intel_crtc_state *);
	void (*color_commit_arm)(struct intel_dsb *, const struct intel_crtc_state *);
	void (*color_post_update)(const struct intel_crtc_state *);
	void (*load_luts)(const struct intel_crtc_state *);
	void (*read_luts)(struct intel_crtc_state *);
	bool (*lut_equal)(const struct intel_crtc_state *, const struct drm_property_blob *, const struct drm_property_blob *, bool);
	void (*read_csc)(struct intel_crtc_state *);
	void (*get_config)(struct intel_crtc_state *);
};

struct pwm_state {
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
	bool usage_power;
};

struct intel_pps_delays {
	u16 power_up;
	u16 backlight_on;
	u16 backlight_off;
	u16 power_down;
	u16 power_cycle;
};

struct intel_vbt_panel_data {
	struct drm_display_mode *lfp_vbt_mode;
	struct drm_display_mode *sdvo_lvds_vbt_mode;
	int panel_type;
	unsigned int lvds_dither: 1;
	unsigned int bios_lvds_val;
	bool vrr;
	u8 seamless_drrs_min_refresh_rate;
	enum drrs_type drrs_type;
	struct {
		int max_link_rate;
		int rate;
		int lanes;
		int preemphasis;
		int vswing;
		int bpp;
		struct intel_pps_delays pps;
		u8 drrs_msa_timing_delay;
		bool low_vswing;
		bool hobl;
		bool dsc_disable;
	} edp;
	struct {
		bool enable;
		bool full_link;
		bool require_aux_wakeup;
		int idle_frames;
		int tp1_wakeup_time_us;
		int tp2_tp3_wakeup_time_us;
		int psr2_tp2_tp3_wakeup_time_us;
	} psr;
	struct {
		u16 pwm_freq_hz;
		u16 brightness_precision_bits;
		u16 hdr_dpcd_refresh_timeout;
		bool present;
		bool active_low_pwm;
		u8 min_brightness;
		s8 controller;
		enum intel_backlight_type type;
	} backlight;
	struct {
		u16 panel_id;
		struct mipi_config *config;
		struct mipi_pps_data *pps;
		u16 bl_ports;
		u16 cabc_ports;
		u8 seq_version;
		u32 size;
		u8 *data;
		const u8 *sequence[12];
		u8 *deassert_seq;
		enum drm_panel_orientation orientation;
	} dsi;
};

struct pwm_device;

struct intel_panel_bl_funcs;

struct intel_connector;

struct intel_panel {
	const struct drm_edid *fixed_edid;
	struct list_head fixed_modes;
	struct {
		bool present;
		u32 level;
		u32 min;
		u32 max;
		bool enabled;
		bool combination_mode;
		bool active_low_pwm;
		bool alternate_pwm_increment;
		u32 pwm_level_min;
		u32 pwm_level_max;
		bool pwm_enabled;
		bool util_pin_active_low;
		u8 controller;
		struct pwm_device *pwm;
		struct pwm_state pwm_state;
		union {
			struct {
				struct drm_edp_backlight_info info;
			} vesa;
			struct {
				bool sdr_uses_aux;
				bool supports_2084_decode;
				bool supports_2020_gamut;
				bool supports_segmented_backlight;
				bool supports_sdp_colorimetry;
				bool supports_tone_mapping;
			} intel_cap;
		} edp;
		struct backlight_device *device;
		const struct intel_panel_bl_funcs *funcs;
		const struct intel_panel_bl_funcs *pwm_funcs;
		void (*power)(struct intel_connector *, bool);
	} backlight;
	struct intel_vbt_panel_data vbt;
};

struct intel_hdcp_shim;

struct intel_hdcp {
	const struct intel_hdcp_shim *shim;
	struct mutex mutex;
	u64 value;
	struct delayed_work check_work;
	struct work_struct prop_work;
	bool hdcp_encrypted;
	bool hdcp2_supported;
	bool hdcp2_encrypted;
	u8 content_type;
	bool is_paired;
	bool is_repeater;
	u32 seq_num_v;
	u32 seq_num_m;
	wait_queue_head_t cp_irq_queue;
	atomic_t cp_irq_count;
	int cp_irq_count_cached;
	enum transcoder cpu_transcoder;
	enum transcoder stream_transcoder;
};

struct intel_dp;

struct intel_connector {
	struct drm_connector base;
	struct intel_encoder *encoder;
	u32 acpi_device_id;
	bool (*get_hw_state)(struct intel_connector *);
	void (*sync_state)(struct intel_connector *, const struct intel_crtc_state *);
	struct intel_panel panel;
	const struct drm_edid *detect_edid;
	int hotplug_retries;
	u8 polled;
	struct drm_dp_mst_port *port;
	struct intel_dp *mst_port;
	int force_joined_pipes;
	struct {
		struct drm_dp_aux *dsc_decompression_aux;
		u8 dsc_dpcd[16];
		u8 fec_capability;
		u8 dsc_hblank_expansion_quirk: 1;
		u8 dsc_decompression_enabled: 1;
	} dp;
	struct work_struct modeset_retry_work;
	struct intel_hdcp hdcp;
};

struct intel_context_ops {
	long unsigned int flags;
	int (*alloc)(struct intel_context *);
	void (*revoke)(struct intel_context *, struct i915_request *, unsigned int);
	void (*close)(struct intel_context *);
	int (*pre_pin)(struct intel_context *, struct i915_gem_ww_ctx *, void **);
	int (*pin)(struct intel_context *, void *);
	void (*unpin)(struct intel_context *);
	void (*post_unpin)(struct intel_context *);
	void (*cancel_request)(struct intel_context *, struct i915_request *);
	void (*enter)(struct intel_context *);
	void (*exit)(struct intel_context *);
	void (*sched_disable)(struct intel_context *);
	void (*update_stats)(struct intel_context *);
	void (*reset)(struct intel_context *);
	void (*destroy)(struct kref *);
	struct intel_context * (*create_virtual)(struct intel_engine_cs **, unsigned int, long unsigned int);
	struct intel_context * (*create_parallel)(struct intel_engine_cs **, unsigned int, unsigned int);
	struct intel_engine_cs * (*get_sibling)(struct intel_engine_cs *, unsigned int);
};

struct intel_ddi_buf_trans;

struct intel_encoder {
	struct drm_encoder base;
	enum intel_output_type type;
	enum port port;
	u16 cloneable;
	u8 pipe_mask;
	struct delayed_work link_check_work;
	void (*link_check)(struct intel_encoder *);
	enum intel_hotplug_state (*hotplug)(struct intel_encoder *, struct intel_connector *);
	enum intel_output_type (*compute_output_type)(struct intel_encoder *, struct intel_crtc_state *, struct drm_connector_state *);
	int (*compute_config)(struct intel_encoder *, struct intel_crtc_state *, struct drm_connector_state *);
	int (*compute_config_late)(struct intel_encoder *, struct intel_crtc_state *, struct drm_connector_state *);
	void (*pre_pll_enable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*pre_enable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*enable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*disable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*post_disable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*post_pll_disable)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*update_pipe)(struct intel_atomic_state *, struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*audio_enable)(struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	void (*audio_disable)(struct intel_encoder *, const struct intel_crtc_state *, const struct drm_connector_state *);
	bool (*get_hw_state)(struct intel_encoder *, enum pipe *);
	void (*get_config)(struct intel_encoder *, struct intel_crtc_state *);
	void (*sync_state)(struct intel_encoder *, const struct intel_crtc_state *);
	bool (*initial_fastset_check)(struct intel_encoder *, struct intel_crtc_state *);
	void (*get_power_domains)(struct intel_encoder *, struct intel_crtc_state *);
	void (*suspend)(struct intel_encoder *);
	void (*suspend_complete)(struct intel_encoder *);
	void (*shutdown)(struct intel_encoder *);
	void (*shutdown_complete)(struct intel_encoder *);
	void (*enable_clock)(struct intel_encoder *, const struct intel_crtc_state *);
	void (*disable_clock)(struct intel_encoder *);
	bool (*is_clock_enabled)(struct intel_encoder *);
	enum icl_port_dpll_id (*port_pll_type)(struct intel_encoder *, const struct intel_crtc_state *);
	const struct intel_ddi_buf_trans * (*get_buf_trans)(struct intel_encoder *, const struct intel_crtc_state *, int *);
	void (*set_signal_levels)(struct intel_encoder *, const struct intel_crtc_state *);
	enum hpd_pin hpd_pin;
	enum intel_display_power_domain power_domain;
	const struct intel_bios_encoder_data *devdata;
};

struct intel_crt {
	struct intel_encoder base;
	bool force_hotplug_required;
	i915_reg_t adpa_reg;
};

struct intel_display_power_domain_set {
	struct intel_power_domain_mask mask;
};

struct intel_wm_level {
	bool enable;
	u32 pri_val;
	u32 spr_val;
	u32 cur_val;
	u32 fbc_val;
};

struct intel_pipe_wm {
	struct intel_wm_level wm[5];
	bool fbc_wm_enabled;
	bool pipe_enabled;
	bool sprites_enabled;
	bool sprites_scaled;
};

struct vlv_wm_state {
	struct g4x_pipe_wm wm[3];
	struct g4x_sr_wm sr[3];
	u8 num_levels;
	bool cxsr;
};

struct intel_link_m_n {
	u32 tu;
	u32 data_m;
	u32 data_n;
	u32 link_m;
	u32 link_n;
};

struct intel_pipe_crc {
	spinlock_t lock;
	int skipped;
	enum intel_pipe_crc_source source;
};

struct intel_crtc {
	struct drm_crtc base;
	enum pipe pipe;
	bool active;
	u8 plane_ids_mask;
	u8 mode_flags;
	u16 vmax_vblank_start;
	struct intel_display_power_domain_set enabled_power_domains;
	struct intel_display_power_domain_set hw_readout_power_domains;
	struct intel_overlay *overlay;
	struct intel_crtc_state *config;
	struct drm_pending_vblank_event *flip_done_event;
	struct drm_pending_vblank_event *dsb_event;
	bool cpu_fifo_underrun_disabled;
	bool pch_fifo_underrun_disabled;
	struct {
		union {
			struct intel_pipe_wm ilk;
			struct vlv_wm_state vlv;
			struct g4x_wm_state g4x;
		} active;
	} wm;
	struct {
		struct mutex mutex;
		struct delayed_work work;
		enum drrs_refresh_rate refresh_rate;
		unsigned int frontbuffer_bits;
		unsigned int busy_frontbuffer_bits;
		enum transcoder cpu_transcoder;
		struct intel_link_m_n m_n;
		struct intel_link_m_n m2_n2;
	} drrs;
	int scanline_offset;
	struct {
		unsigned int start_vbl_count;
		ktime_t start_vbl_time;
		int min_vbl;
		int max_vbl;
		int scanline_start;
	} debug;
	int num_scalers;
	struct pm_qos_request vblank_pm_qos;
	struct intel_pipe_crc pipe_crc;
	bool block_dc_for_vblank;
};

struct intel_scaler {
	u32 mode;
	bool in_use;
};

struct intel_crtc_scaler_state {
	struct intel_scaler scalers[2];
	unsigned int scaler_users;
	int scaler_id;
};

struct intel_csc_matrix {
	u16 coeff[9];
	u16 preoff[3];
	u16 postoff[3];
};

struct skl_wm_level {
	u16 min_ddb_alloc;
	u16 blocks;
	u8 lines;
	bool enable;
	bool ignore_lines;
	bool auto_min_alloc_wm_enable;
	bool can_sagv;
};

struct skl_plane_wm {
	struct skl_wm_level wm[8];
	struct skl_wm_level uv_wm[8];
	struct skl_wm_level trans_wm;
	struct {
		struct skl_wm_level wm0;
		struct skl_wm_level trans_wm;
	} sagv;
	bool is_planar;
};

struct skl_pipe_wm {
	struct skl_plane_wm planes[8];
	bool use_sagv_wm;
};

struct skl_ddb_entry {
	u16 start;
	u16 end;
};

struct vlv_fifo_state {
	u16 plane[8];
};

struct intel_crtc_wm_state {
	union {
		struct {
			struct intel_pipe_wm intermediate;
			struct intel_pipe_wm optimal;
		} ilk;
		struct {
			struct skl_pipe_wm raw;
			struct skl_pipe_wm optimal;
			struct skl_ddb_entry ddb;
			struct skl_ddb_entry plane_ddb[8];
			struct skl_ddb_entry plane_ddb_y[8];
			u16 plane_min_ddb[8];
			u16 plane_interim_ddb[8];
		} skl;
		struct {
			struct g4x_pipe_wm raw[3];
			struct vlv_wm_state intermediate;
			struct vlv_wm_state optimal;
			struct vlv_fifo_state fifo_state;
		} vlv;
		struct {
			struct g4x_pipe_wm raw[3];
			struct g4x_wm_state intermediate;
			struct g4x_wm_state optimal;
		} g4x;
	};
	bool need_postvbl_update;
};

struct intel_crtc_state {
	struct drm_crtc_state uapi;
	struct {
		bool active;
		bool enable;
		struct drm_property_blob *degamma_lut;
		struct drm_property_blob *gamma_lut;
		struct drm_property_blob *ctm;
		struct drm_display_mode mode;
		struct drm_display_mode pipe_mode;
		struct drm_display_mode adjusted_mode;
		enum drm_scaling_filter scaling_filter;
	} hw;
	struct drm_property_blob *pre_csc_lut;
	struct drm_property_blob *post_csc_lut;
	struct intel_csc_matrix csc;
	struct intel_csc_matrix output_csc;
	long unsigned int quirks;
	unsigned int fb_bits;
	bool update_pipe;
	bool update_m_n;
	bool update_lrr;
	bool disable_cxsr;
	bool update_wm_pre;
	bool update_wm_post;
	bool fifo_changed;
	bool preload_luts;
	bool inherited;
	bool do_async_flip;
	struct drm_rect pipe_src;
	unsigned int pixel_rate;
	bool has_pch_encoder;
	bool has_infoframe;
	enum transcoder cpu_transcoder;
	bool limited_color_range;
	unsigned int output_types;
	bool has_hdmi_sink;
	bool has_audio;
	bool dither;
	bool dither_force_disable;
	bool clock_set;
	bool sdvo_tv_clock;
	bool bw_constrained;
	struct dpll dpll;
	struct intel_shared_dpll *shared_dpll;
	struct intel_dpll_hw_state dpll_hw_state;
	struct icl_port_dpll icl_port_dplls[2];
	struct {
		u32 ctrl;
		u32 div;
	} dsi_pll;
	int max_link_bpp_x16;
	int pipe_bpp;
	struct intel_link_m_n dp_m_n;
	struct intel_link_m_n dp_m2_n2;
	bool has_drrs;
	bool has_psr;
	bool has_sel_update;
	bool enable_psr2_sel_fetch;
	bool enable_psr2_su_region_et;
	bool req_psr2_sdp_prior_scanline;
	bool has_panel_replay;
	bool wm_level_disabled;
	u32 dc3co_exitline;
	u16 su_y_granularity;
	int port_clock;
	unsigned int pixel_multiplier;
	u8 mode_flags;
	u8 lane_count;
	u8 lane_lat_optim_mask;
	u8 min_voltage_level;
	struct {
		u32 control;
		u32 pgm_ratios;
		u32 lvds_border_bits;
	} gmch_pfit;
	struct {
		struct drm_rect dst;
		bool enabled;
		bool force_thru;
	} pch_pfit;
	int fdi_lanes;
	struct intel_link_m_n fdi_m_n;
	bool ips_enabled;
	bool crc_enabled;
	bool double_wide;
	struct intel_crtc_scaler_state scaler_state;
	enum pipe hsw_workaround_pipe;
	struct intel_crtc_wm_state wm;
	int min_cdclk[8];
	u32 data_rate[8];
	u32 data_rate_y[8];
	u64 rel_data_rate[8];
	u64 rel_data_rate_y[8];
	u32 gamma_mode;
	union {
		u32 csc_mode;
		u32 cgm_mode;
	};
	u8 enabled_planes;
	u8 active_planes;
	u8 scaled_planes;
	u8 nv12_planes;
	u8 c8_planes;
	u8 update_planes;
	u8 async_flip_planes;
	u8 framestart_delay;
	u8 msa_timing_delay;
	struct {
		u32 enable;
		u32 gcp;
		union hdmi_infoframe avi;
		union hdmi_infoframe spd;
		union hdmi_infoframe hdmi;
		union hdmi_infoframe drm;
		struct drm_dp_vsc_sdp vsc;
		struct drm_dp_as_sdp as_sdp;
	} infoframes;
	u8 eld[128];
	bool hdmi_scrambling;
	bool hdmi_high_tmds_clock_ratio;
	enum intel_output_format output_format;
	enum intel_output_format sink_format;
	bool gamma_enable;
	bool csc_enable;
	bool wgc_enable;
	u8 joiner_pipes;
	struct {
		bool compression_enable;
		int num_streams;
		u16 compressed_bpp_x16;
		u8 slice_count;
		struct drm_dsc_config config;
	} dsc;
	struct drm_dp_tunnel_ref dp_tunnel_ref;
	u16 linetime;
	u16 ips_linetime;
	bool enhanced_framing;
	bool fec_enable;
	bool sdp_split_enable;
	enum transcoder master_transcoder;
	u8 sync_mode_slaves_mask;
	enum transcoder mst_master_transcoder;
	struct intel_dsb *dsb_color_vblank;
	struct intel_dsb *dsb_commit;
	bool use_dsb;
	u32 psr2_man_track_ctl;
	u32 pipe_srcsz_early_tpt;
	struct drm_rect psr2_su_area;
	struct {
		bool enable;
		bool in_range;
		u8 pipeline_full;
		u16 flipline;
		u16 vmin;
		u16 vmax;
		u16 guardband;
		u32 vsync_end;
		u32 vsync_start;
	} vrr;
	struct {
		bool enable;
		u64 cmrr_n;
		u64 cmrr_m;
	} cmrr;
	struct {
		bool enable;
		u8 link_count;
		u8 pixel_overlap;
	} splitter;
	struct drm_vblank_work vblank_work;
	bool has_lobf;
};

struct intel_css_header {
	u32 module_type;
	u32 header_len;
	u32 header_ver;
	u32 module_id;
	u32 module_vendor;
	u32 date;
	u32 size;
	u32 key_size;
	u32 modulus_size;
	u32 exponent_size;
	u32 reserved1[12];
	u32 version;
	u32 reserved2[8];
	u32 kernel_header_info;
};

struct intel_dbuf_state {
	struct intel_global_state base;
	struct skl_ddb_entry ddb[4];
	unsigned int weight[4];
	u8 slices[4];
	u8 enabled_slices;
	u8 active_pipes;
	u8 mdclk_cdclk_ratio;
	bool joined_mbus;
};

union intel_ddi_buf_trans_entry;

struct intel_ddi_buf_trans {
	const union intel_ddi_buf_trans_entry *entries;
	u8 num_entries;
	u8 hdmi_default_entry;
};

struct tgl_dkl_phy_ddi_buf_trans {
	u8 vswing;
	u8 preshoot;
	u8 de_emphasis;
};

union intel_ddi_buf_trans_entry {
	struct hsw_ddi_buf_trans hsw;
	struct bxt_ddi_buf_trans bxt;
	struct icl_ddi_buf_trans icl;
	struct icl_mg_phy_ddi_buf_trans mg;
	struct tgl_dkl_phy_ddi_buf_trans dkl;
	struct dg2_snps_phy_buf_trans snps;
};

struct intel_ddi_port_domains {
	enum port port_start;
	enum port port_end;
	enum aux_ch aux_ch_start;
	enum aux_ch aux_ch_end;
	enum intel_display_power_domain ddi_lanes;
	enum intel_display_power_domain ddi_io;
	enum intel_display_power_domain aux_io;
	enum intel_display_power_domain aux_legacy_usbc;
	enum intel_display_power_domain aux_tbt;
};

struct intel_digital_connector_state {
	struct drm_connector_state base;
	enum hdmi_force_audio force_audio;
	int broadcast_rgb;
};

struct intel_dp_link_config {
	u8 link_rate_idx: 6;
	u8 lane_count_exp: 2;
};

struct intel_pps {
	int panel_power_up_delay;
	int panel_power_down_delay;
	int panel_power_cycle_delay;
	int backlight_on_delay;
	int backlight_off_delay;
	struct delayed_work panel_vdd_work;
	bool want_panel_vdd;
	bool initializing;
	long unsigned int last_power_on;
	long unsigned int last_backlight_off;
	ktime_t panel_power_off_time;
	intel_wakeref_t vdd_wakeref;
	union {
		enum pipe vlv_pps_pipe;
		int pps_idx;
	};
	enum pipe vlv_active_pipe;
	bool bxt_pps_reset;
	struct intel_pps_delays pps_delays;
	struct intel_pps_delays bios_pps_delays;
};

struct intel_dp_compliance_data {
	long unsigned int edid;
	u8 video_pattern;
	u16 hdisplay;
	u16 vdisplay;
	u8 bpc;
	struct drm_dp_phy_test_params phytest;
};

struct intel_dp_compliance {
	long unsigned int test_type;
	struct intel_dp_compliance_data test_data;
	bool test_active;
	int test_link_rate;
	u8 test_lane_count;
};

struct intel_dp_pcon_frl {
	bool is_trained;
	int trained_rate_gbps;
};

struct intel_psr {
	struct mutex lock;
	u32 debug;
	bool sink_support;
	bool source_support;
	bool enabled;
	bool paused;
	enum pipe pipe;
	enum transcoder transcoder;
	bool active;
	struct work_struct work;
	unsigned int busy_frontbuffer_bits;
	bool sink_psr2_support;
	bool link_standby;
	bool sel_update_enabled;
	bool psr2_sel_fetch_enabled;
	bool psr2_sel_fetch_cff_enabled;
	bool su_region_et_enabled;
	bool req_psr2_sdp_prior_scanline;
	u8 sink_sync_latency;
	ktime_t last_entry_attempt;
	ktime_t last_exit;
	bool sink_not_reliable;
	bool irq_aux_error;
	u16 su_w_granularity;
	u16 su_y_granularity;
	bool source_panel_replay_support;
	bool sink_panel_replay_support;
	bool sink_panel_replay_su_support;
	bool panel_replay_enabled;
	u32 dc3co_exitline;
	u32 dc3co_exit_delay;
	struct delayed_work dc3co_work;
	u8 entry_setup_frames;
	bool link_ok;
};

struct intel_dp_mst_encoder;

struct intel_dp {
	i915_reg_t output_reg;
	u32 DP;
	int link_rate;
	u8 lane_count;
	u8 sink_count;
	bool link_trained;
	bool needs_modeset_retry;
	bool use_max_params;
	u8 dpcd[15];
	u8 psr_dpcd[2];
	u8 pr_dpcd;
	u8 downstream_ports[16];
	u8 edp_dpcd[3];
	u8 lttpr_common_caps[8];
	u8 lttpr_phy_caps[24];
	u8 pcon_dsc_dpcd[13];
	int num_source_rates;
	const int *source_rates;
	int num_sink_rates;
	int sink_rates[8];
	bool use_rate_select;
	int max_sink_lane_count;
	int num_common_rates;
	int common_rates[8];
	struct {
		int num_configs;
		struct intel_dp_link_config configs[24];
		int max_lane_count;
		int max_rate;
		int mst_probed_lane_count;
		int mst_probed_rate;
		int force_lane_count;
		int force_rate;
		bool retrain_disabled;
		int seq_train_failures;
		int force_train_failure;
		bool force_retrain;
	} link;
	bool reset_link_params;
	int mso_link_count;
	int mso_pixel_overlap;
	struct drm_dp_desc desc;
	struct drm_dp_aux aux;
	u32 aux_busy_last_status;
	u8 train_set[4];
	struct intel_pps pps;
	bool is_mst;
	int active_mst_links;
	enum drm_dp_mst_mode mst_detect;
	struct intel_connector *attached_connector;
	bool as_sdp_supported;
	struct drm_dp_tunnel *tunnel;
	bool tunnel_suspended: 1;
	struct intel_dp_mst_encoder *mst_encoders[4];
	struct drm_dp_mst_topology_mgr mst_mgr;
	u32 (*get_aux_clock_divider)(struct intel_dp *, int);
	u32 (*get_aux_send_ctl)(struct intel_dp *, int, u32);
	i915_reg_t (*aux_ch_ctl_reg)(struct intel_dp *);
	i915_reg_t (*aux_ch_data_reg)(struct intel_dp *, int);
	void (*prepare_link_retrain)(struct intel_dp *, const struct intel_crtc_state *);
	void (*set_link_train)(struct intel_dp *, const struct intel_crtc_state *, u8);
	void (*set_idle_link_train)(struct intel_dp *, const struct intel_crtc_state *);
	u8 (*preemph_max)(struct intel_dp *);
	u8 (*voltage_max)(struct intel_dp *, const struct intel_crtc_state *);
	struct intel_dp_compliance compliance;
	struct {
		int min_tmds_clock;
		int max_tmds_clock;
		int max_dotclock;
		int pcon_max_frl_bw;
		u8 max_bpc;
		bool ycbcr_444_to_420;
		bool ycbcr420_passthrough;
		bool rgb_to_ycbcr;
	} dfp;
	struct pm_qos_request pm_qos;
	bool force_dsc_en;
	int force_dsc_output_format;
	bool force_dsc_fractional_bpp_en;
	int force_dsc_bpc;
	bool hobl_failed;
	bool hobl_active;
	struct intel_dp_pcon_frl frl;
	struct intel_psr psr;
	long unsigned int last_oui_write;
	bool oui_valid;
	bool colorimetry_support;
	struct {
		u8 io_wake_lines;
		u8 fast_wake_lines;
		u8 check_entry_lines;
		u8 aux_less_wake_lines;
		u8 silence_period_sym_clocks;
		u8 lfps_half_cycle_num_of_syms;
	} alpm_parameters;
	u8 alpm_dpcd;
	struct {
		long unsigned int mask;
	} quirks;
};

struct cec_notifier;

struct intel_hdmi {
	i915_reg_t hdmi_reg;
	struct {
		enum drm_dp_dual_mode_type type;
		int max_tmds_clock;
	} dp_dual_mode;
	struct intel_connector *attached_connector;
	struct cec_notifier *cec_notifier;
};

struct intel_lspcon {
	bool active;
	bool hdr_supported;
	enum drm_lspcon_mode mode;
	enum lspcon_vendor vendor;
};

struct intel_tc_port;

struct intel_digital_port {
	struct intel_encoder base;
	struct intel_dp dp;
	struct intel_hdmi hdmi;
	struct intel_lspcon lspcon;
	enum irqreturn (*hpd_pulse)(struct intel_digital_port *, bool);
	bool lane_reversal;
	bool ddi_a_4_lanes;
	bool release_cl2_override;
	u8 max_lanes;
	enum aux_ch aux_ch;
	enum intel_display_power_domain ddi_io_power_domain;
	intel_wakeref_t ddi_io_wakeref;
	intel_wakeref_t aux_wakeref;
	struct intel_tc_port *tc;
	struct mutex hdcp_mutex;
	unsigned int num_hdcp_streams;
	bool hdcp_auth_status;
	struct hdcp_port_data hdcp_port_data;
	bool hdcp_mst_type1_capable;
	void (*write_infoframe)(struct intel_encoder *, const struct intel_crtc_state *, unsigned int, const void *, ssize_t);
	void (*read_infoframe)(struct intel_encoder *, const struct intel_crtc_state *, unsigned int, void *, ssize_t);
	void (*set_infoframes)(struct intel_encoder *, bool, const struct intel_crtc_state *, const struct drm_connector_state *);
	u32 (*infoframes_enabled)(struct intel_encoder *, const struct intel_crtc_state *);
	bool (*connected)(struct intel_encoder *);
	void (*lock)(struct intel_digital_port *);
	void (*unlock)(struct intel_digital_port *);
};

struct intel_display_device_info {
	const struct intel_display_runtime_info __runtime_defaults;
	u8 abox_mask;
	struct {
		u16 size;
		u8 slice_mask;
	} dbuf;
	u8 cursor_needs_physical: 1;
	u8 has_cdclk_crawl: 1;
	u8 has_cdclk_squash: 1;
	u8 has_ddi: 1;
	u8 has_dp_mst: 1;
	u8 has_dsb: 1;
	u8 has_fpga_dbg: 1;
	u8 has_gmch: 1;
	u8 has_hotplug: 1;
	u8 has_hti: 1;
	u8 has_ipc: 1;
	u8 has_overlay: 1;
	u8 has_psr: 1;
	u8 has_psr_hw_tracking: 1;
	u8 overlay_needs_physical: 1;
	u8 supports_tv: 1;
	u32 mmio_offset;
	u32 pipe_offsets[7];
	u32 trans_offsets[7];
	u32 cursor_offsets[4];
	struct {
		u32 degamma_lut_size;
		u32 gamma_lut_size;
		u32 degamma_lut_tests;
		u32 gamma_lut_tests;
	} color;
};

struct intel_initial_plane_config;

struct intel_display_funcs {
	bool (*get_pipe_config)(struct intel_crtc *, struct intel_crtc_state *);
	void (*get_initial_plane_config)(struct intel_crtc *, struct intel_initial_plane_config *);
	bool (*fixup_initial_plane_config)(struct intel_crtc *, const struct intel_initial_plane_config *);
	void (*crtc_enable)(struct intel_atomic_state *, struct intel_crtc *);
	void (*crtc_disable)(struct intel_atomic_state *, struct intel_crtc *);
	void (*commit_modeset_enables)(struct intel_atomic_state *);
};

struct intel_overlay_snapshot;

struct intel_dmc_snapshot;

struct intel_display_snapshot {
	struct intel_display *display;
	struct intel_display_device_info info;
	struct intel_display_runtime_info runtime_info;
	struct intel_display_params params;
	struct intel_overlay_snapshot *overlay;
	struct intel_dmc_snapshot *dmc;
};

struct intel_dkl_phy_reg {
	u32 reg: 24;
	u32 bank_idx: 4;
};

struct intel_dmc {
	struct intel_display *display;
	struct work_struct work;
	const char *fw_path;
	u32 max_fw_size;
	u32 version;
	struct dmc_fw_info dmc_info[5];
};

struct intel_dmc_header_base {
	u32 signature;
	u8 header_len;
	u8 header_ver;
	u16 dmcc_ver;
	u32 project;
	u32 fw_size;
	u32 fw_version;
};

struct intel_dmc_header_v1 {
	struct intel_dmc_header_base base;
	u32 mmio_count;
	u32 mmioaddr[8];
	u32 mmiodata[8];
	char dfile[32];
	u32 reserved1[2];
};

struct intel_dmc_header_v3 {
	struct intel_dmc_header_base base;
	u32 start_mmioaddr;
	u32 reserved[9];
	char dfile[32];
	u32 mmio_count;
	u32 mmioaddr[20];
	u32 mmiodata[20];
};

struct intel_dmc_snapshot {
	bool initialized;
	bool loaded;
	u32 version;
};

struct intel_dmc_wl_range {
	u32 start;
	u32 end;
};

struct intel_dmi_quirk {
	void (*hook)(struct intel_display *);
	const struct dmi_system_id (*dmi_id_list)[0];
};

struct intel_dp_mst_encoder {
	struct intel_encoder base;
	enum pipe pipe;
	struct intel_digital_port *primary;
	struct intel_connector *connector;
};

struct intel_dpcd_quirk {
	int device;
	int subsystem_vendor;
	int subsystem_device;
	u8 sink_oui[3];
	u8 sink_device_id[6];
	void (*hook)(struct intel_dp *);
};

struct intel_dpll_funcs {
	int (*crtc_compute_clock)(struct intel_atomic_state *, struct intel_crtc *);
	int (*crtc_get_shared_dpll)(struct intel_atomic_state *, struct intel_crtc *);
};

struct intel_dpll_mgr {
	const struct dpll_info *dpll_info;
	int (*compute_dplls)(struct intel_atomic_state *, struct intel_crtc *, struct intel_encoder *);
	int (*get_dplls)(struct intel_atomic_state *, struct intel_crtc *, struct intel_encoder *);
	void (*put_dplls)(struct intel_atomic_state *, struct intel_crtc *);
	void (*update_active_dpll)(struct intel_atomic_state *, struct intel_crtc *, struct intel_encoder *);
	void (*update_ref_clks)(struct drm_i915_private *);
	void (*dump_hw_state)(struct drm_printer *, const struct intel_dpll_hw_state *);
	bool (*compare_hw_state)(const struct intel_dpll_hw_state *, const struct intel_dpll_hw_state *);
};

struct intel_dsb_buffer {
	u32 *cmd_buf;
	struct i915_vma *vma;
	size_t buf_size;
};

struct intel_dsb {
	enum intel_dsb_id id;
	struct intel_dsb_buffer dsb_buf;
	struct intel_crtc *crtc;
	unsigned int size;
	unsigned int free_pos;
	u32 ins[2];
	unsigned int ins_start_offset;
	u32 chicken;
	int hw_dewake_scanline;
};

struct intel_dsi_host;

struct intel_dsi {
	struct intel_encoder base;
	struct intel_dsi_host *dsi_hosts[9];
	intel_wakeref_t io_wakeref[9];
	struct gpio_desc *gpio_panel;
	struct gpio_desc *gpio_backlight;
	struct intel_connector *attached_connector;
	union {
		u16 ports;
		u16 phys;
	};
	int channel;
	u16 operation_mode;
	unsigned int lane_count;
	int i2c_bus_num;
	enum mipi_dsi_pixel_format pixel_format;
	int video_mode;
	u8 eotp_pkt;
	u8 clock_stop;
	u8 escape_clk_div;
	u8 dual_link;
	bool bgr_enabled;
	u8 pixel_overlap;
	u32 bw_timer;
	u32 dphy_reg;
	u32 dphy_data_lane_reg;
	u32 video_frmt_cfg_bits;
	u16 lp_byte_clk;
	u16 hs_tx_timeout;
	u16 lp_rx_timeout;
	u16 turn_arnd_val;
	u16 rst_timer_val;
	u16 hs_to_lp_count;
	u16 clk_lp_to_hs_count;
	u16 clk_hs_to_lp_count;
	u16 init_count;
	u32 pclk;
	u16 burst_mode_ratio;
	u16 backlight_off_delay;
	u16 backlight_on_delay;
	u16 panel_on_delay;
	u16 panel_off_delay;
	u16 panel_pwr_cycle_delay;
	ktime_t panel_power_off_time;
};

struct mipi_dsi_host_ops;

struct mipi_dsi_host {
	struct device *dev;
	const struct mipi_dsi_host_ops *ops;
	struct list_head list;
};

struct mipi_dsi_device;

struct intel_dsi_host {
	struct mipi_dsi_host base;
	struct intel_dsi *intel_dsi;
	enum port port;
	struct mipi_dsi_device *device;
};

struct intel_dvo_dev_ops;

struct intel_dvo_device {
	const char *name;
	int type;
	enum port port;
	u32 gpio;
	int target_addr;
	const struct intel_dvo_dev_ops *dev_ops;
	void *dev_priv;
	struct i2c_adapter *i2c_bus;
};

struct intel_dvo {
	struct intel_encoder base;
	struct intel_dvo_device dev;
	struct intel_connector *attached_connector;
};

struct intel_dvo_dev_ops {
	bool (*init)(struct intel_dvo_device *, struct i2c_adapter *);
	void (*dpms)(struct intel_dvo_device *, bool);
	enum drm_mode_status (*mode_valid)(struct intel_dvo_device *, struct drm_display_mode *);
	void (*mode_set)(struct intel_dvo_device *, const struct drm_display_mode *, const struct drm_display_mode *);
	enum drm_connector_status (*detect)(struct intel_dvo_device *);
	bool (*get_hw_state)(struct intel_dvo_device *);
	void (*destroy)(struct intel_dvo_device *);
	void (*dump_regs)(struct intel_dvo_device *);
};

struct intel_early_ops {
	resource_size_t (*stolen_size)(int, int, int);
	resource_size_t (*stolen_base)(int, int, int, resource_size_t);
};

struct intel_engine_capture_vma {
	struct intel_engine_capture_vma *next;
	struct i915_vma_resource *vma_res;
	char name[16];
	bool lockdep_cookie;
};

struct intel_instdone {
	u32 instdone;
	u32 slice_common;
	u32 slice_common_extra[2];
	u32 sampler[128];
	u32 row[128];
	u32 geom_svg[128];
};

struct intel_guc_state_capture;

struct intel_engine_coredump {
	const struct intel_engine_cs *engine;
	bool hung;
	bool simulated;
	u32 reset_count;
	u32 rq_head;
	u32 rq_post;
	u32 rq_tail;
	u32 ccid;
	u32 start;
	u32 tail;
	u32 head;
	u32 ctl;
	u32 mode;
	u32 hws;
	u32 ipeir;
	u32 ipehr;
	u32 esr;
	u32 bbstate;
	u32 instpm;
	u32 instps;
	u64 bbaddr;
	u64 acthd;
	u32 fault_reg;
	u64 faddr;
	u32 rc_psmi;
	u32 nopid;
	u32 excc;
	u32 cmd_cctl;
	u32 cscmdop;
	u32 ctx_sr_ctl;
	u32 dma_faddr_hi;
	u32 dma_faddr_lo;
	struct intel_instdone instdone;
	struct intel_guc_state_capture *guc_capture;
	struct __guc_capture_parsed_output *guc_capture_node;
	struct i915_gem_context_coredump context;
	struct i915_vma_coredump *vma;
	struct i915_request_coredump execlist[2];
	unsigned int num_ports;
	struct {
		u32 gfx_mode;
		union {
			u64 pdp[4];
			u32 pp_dir_base;
		};
	} vm_info;
	struct intel_engine_coredump *next;
};

struct intel_excl_states {
	enum intel_excl_state_type state[64];
	bool sched_started;
};

struct intel_excl_cntrs {
	raw_spinlock_t lock;
	struct intel_excl_states states[2];
	union {
		u16 has_exclusive[2];
		u32 exclusive_present;
	};
	int refcnt;
	unsigned int core_id;
};

struct intel_fb_view {
	struct i915_gtt_view gtt;
	struct i915_color_plane_view color_plane[4];
};

struct intel_plane;

struct intel_fbc_state {
	struct intel_plane *plane;
	unsigned int cfb_stride;
	unsigned int cfb_size;
	unsigned int fence_y_offset;
	u16 override_cfb_stride;
	u16 interval;
	s8 fence_id;
};

struct intel_fbc_funcs;

struct intel_fbc {
	struct intel_display *display;
	const struct intel_fbc_funcs *funcs;
	struct mutex lock;
	unsigned int busy_bits;
	struct drm_mm_node compressed_fb;
	struct drm_mm_node compressed_llb;
	enum intel_fbc_id id;
	u8 limit;
	bool false_color;
	bool active;
	bool activated;
	bool flip_pending;
	bool underrun_detected;
	struct work_struct underrun_work;
	struct intel_fbc_state state;
	const char *no_fbc_reason;
};

struct intel_fbc_funcs {
	void (*activate)(struct intel_fbc *);
	void (*deactivate)(struct intel_fbc *);
	bool (*is_active)(struct intel_fbc *);
	bool (*is_compressing)(struct intel_fbc *);
	void (*nuke)(struct intel_fbc *);
	void (*program_cfb)(struct intel_fbc *);
	void (*set_false_color)(struct intel_fbc *, bool);
};

struct intel_framebuffer;

struct intel_fbdev {
	struct drm_fb_helper helper;
	struct intel_framebuffer *fb;
	struct i915_vma *vma;
	long unsigned int vma_flags;
	int preferred_bpp;
	bool hpd_suspended: 1;
	bool hpd_waiting: 1;
	struct mutex hpd_lock;
};

struct intel_fdi_funcs {
	void (*fdi_link_train)(struct intel_crtc *, const struct intel_crtc_state *);
};

struct intel_forcewake_range {
	u32 start;
	u32 end;
	enum forcewake_domains domains;
};

struct intel_framebuffer {
	struct drm_framebuffer base;
	struct intel_frontbuffer *frontbuffer;
	struct intel_fb_view normal_view;
	union {
		struct intel_fb_view rotated_view;
		struct intel_fb_view remapped_view;
	};
	struct i915_address_space *dpt_vm;
	unsigned int min_alignment;
};

struct intel_frontbuffer {
	struct kref ref;
	atomic_t bits;
	struct i915_active write;
	struct drm_gem_object *obj;
	struct callback_head rcu;
	struct work_struct flush_work;
};

struct intel_fw_info {
	u8 reserved1;
	u8 dmc_id;
	char stepping;
	char substepping;
	u32 offset;
	u32 reserved2;
};

struct intel_global_commit {
	struct kref ref;
	struct completion done;
};

struct intel_global_state_funcs {
	struct intel_global_state * (*atomic_duplicate_state)(struct intel_global_obj *);
	void (*atomic_destroy_state)(struct intel_global_obj *, struct intel_global_state *);
};

struct intel_gmbus {
	struct i2c_adapter adapter;
	u32 force_bit;
	u32 reg0;
	i915_reg_t gpio_reg;
	struct i2c_algo_bit_data bit_algo;
	struct intel_display *display;
};

struct mei_aux_device;

struct intel_gsc_intf {
	struct mei_aux_device *adev;
	struct drm_i915_gem_object *gem_obj;
	int irq;
	unsigned int id;
};

struct intel_gsc {
	struct intel_gsc_intf intf[2];
};

struct intel_gsc_bpdt_entry {
	u32 type;
	u32 sub_partition_offset;
	u32 sub_partition_size;
};

struct intel_gsc_version {
	u16 major;
	u16 minor;
	u16 hotfix;
	u16 build;
};

struct intel_gsc_bpdt_header {
	u32 signature;
	u16 descriptor_count;
	u8 version;
	u8 configuration;
	u32 crc32;
	u32 build_version;
	struct intel_gsc_version tool_version;
};

struct intel_gsc_cpd_entry {
	u8 name[12];
	u32 offset;
	u32 length;
	u8 reserved[4];
};

struct intel_gsc_cpd_header_v2 {
	u32 header_marker;
	u32 num_of_entries;
	u8 header_version;
	u8 entry_version;
	u8 header_length;
	u8 flags;
	u32 partition_name;
	u32 crc32;
};

struct intel_gsc_heci_non_priv_pkt {
	u64 addr_in;
	u32 size_in;
	u64 addr_out;
	u32 size_out;
	struct i915_vma *heci_pkt_vma;
	struct i915_vma *bb_vma;
};

struct intel_gsc_partition {
	u32 offset;
	u32 size;
};

struct intel_gsc_layout_pointers {
	u8 rom_bypass_vector[16];
	u16 size;
	u8 flags;
	u8 reserved;
	u32 crc32;
	struct intel_gsc_partition datap;
	struct intel_gsc_partition boot1;
	struct intel_gsc_partition boot2;
	struct intel_gsc_partition boot3;
	struct intel_gsc_partition boot4;
	struct intel_gsc_partition boot5;
	struct intel_gsc_partition temp_pages;
};

struct intel_gsc_manifest_header {
	u32 header_type;
	u32 header_length;
	u32 header_version;
	u32 flags;
	u32 vendor;
	u32 date;
	u32 size;
	u32 header_id;
	u32 internal_data;
	struct intel_gsc_version fw_version;
	u32 security_version;
	struct intel_gsc_version meu_kit_version;
	u32 meu_manifest_version;
	u8 general_data[4];
	u8 reserved3[56];
	u32 modulus_size;
	u32 exponent_size;
};

struct intel_gsc_mkhi_header {
	u8 group_id;
	u8 command;
	u8 reserved;
	u8 result;
};

struct intel_uc_fw_ver {
	u32 major;
	u32 minor;
	u32 patch;
	u32 build;
};

struct intel_uc_fw_file {
	const char *path;
	struct intel_uc_fw_ver ver;
};

struct intel_uc_fw {
	enum intel_uc_fw_type type;
	union {
		const enum intel_uc_fw_status status;
		enum intel_uc_fw_status __status;
	};
	struct intel_uc_fw_file file_wanted;
	struct intel_uc_fw_file file_selected;
	bool user_overridden;
	size_t size;
	struct drm_i915_gem_object *obj;
	bool needs_ggtt_mapping;
	struct i915_vma_resource vma_res;
	struct i915_vma *rsa_data;
	u32 rsa_size;
	u32 ucode_size;
	u32 private_data_size;
	u32 dma_start_offset;
	bool has_gsc_headers;
};

struct intel_gsc_uc {
	struct intel_uc_fw fw;
	struct intel_uc_fw_ver release;
	u32 security_version;
	struct i915_vma *local;
	void *local_vaddr;
	struct intel_context *ce;
	struct workqueue_struct *wq;
	struct work_struct work;
	u32 gsc_work_actions;
	struct {
		struct i915_gsc_proxy_component *component;
		bool component_added;
		struct i915_vma *vma;
		void *to_gsc;
		void *to_csme;
		struct mutex mutex;
	} proxy;
};

struct intel_guc_log {
	u32 level;
	struct {
		s32 bytes;
		s32 units;
		s32 count;
		u32 flag;
	} sizes[3];
	bool sizes_initialised;
	struct i915_vma *vma;
	void *buf_addr;
	struct {
		bool buf_in_use;
		bool started;
		struct work_struct flush_work;
		struct rchan *channel;
		struct mutex lock;
		u32 full_count;
	} relay;
	struct {
		u32 sampled_overflow;
		u32 overflow;
		u32 flush;
	} stats[3];
};

struct intel_guc_ct_buffer {
	spinlock_t lock;
	struct guc_ct_buffer_desc *desc;
	u32 *cmds;
	u32 size;
	u32 resv_space;
	u32 tail;
	u32 head;
	atomic_t space;
	bool broken;
};

struct intel_guc_ct {
	struct i915_vma *vma;
	bool enabled;
	struct {
		struct intel_guc_ct_buffer send;
		struct intel_guc_ct_buffer recv;
	} ctbs;
	struct tasklet_struct receive_tasklet;
	wait_queue_head_t wq;
	struct {
		u16 last_fence;
		spinlock_t lock;
		struct list_head pending;
		struct list_head incoming;
		struct work_struct worker;
	} requests;
	ktime_t stall_time;
};

struct slpc_shared_data;

struct intel_guc_slpc {
	struct i915_vma *vma;
	struct slpc_shared_data *vaddr;
	bool supported;
	bool selected;
	bool min_is_rpmax;
	u32 min_freq;
	u32 rp0_freq;
	u32 rp1_freq;
	u32 boost_freq;
	u32 min_freq_softlimit;
	u32 max_freq_softlimit;
	bool ignore_eff_freq;
	u32 media_ratio_mode;
	struct mutex lock;
	struct work_struct boost_work;
	atomic_t num_waiters;
	u32 num_boosts;
};

struct intel_guc {
	struct intel_uc_fw fw;
	struct intel_guc_log log;
	struct intel_guc_ct ct;
	struct intel_guc_slpc slpc;
	struct intel_guc_state_capture *capture;
	struct dentry *dbgfs_node;
	struct i915_sched_engine *sched_engine;
	struct i915_request *stalled_request;
	enum {
		STALL_NONE = 0,
		STALL_REGISTER_CONTEXT = 1,
		STALL_MOVE_LRC_TAIL = 2,
		STALL_ADD_REQUEST = 3,
	} submission_stall_reason;
	spinlock_t irq_lock;
	unsigned int msg_enabled_mask;
	atomic_t outstanding_submission_g2h;
	struct xarray tlb_lookup;
	u32 serial_slot;
	u32 next_seqno;
	struct {
		bool enabled;
		void (*reset)(struct intel_guc *);
		void (*enable)(struct intel_guc *);
		void (*disable)(struct intel_guc *);
	} interrupts;
	struct {
		spinlock_t lock;
		struct ida guc_ids;
		int num_guc_ids;
		long unsigned int *guc_ids_bitmap;
		struct list_head guc_id_list;
		unsigned int guc_ids_in_use;
		struct list_head destroyed_contexts;
		struct work_struct destroyed_worker;
		struct work_struct reset_fail_worker;
		intel_engine_mask_t reset_fail_mask;
		unsigned int sched_disable_delay_ms;
		unsigned int sched_disable_gucid_threshold;
	} submission_state;
	bool submission_supported;
	bool submission_selected;
	bool submission_initialized;
	struct intel_uc_fw_ver submission_version;
	bool rc_supported;
	bool rc_selected;
	struct i915_vma *ads_vma;
	struct iosys_map ads_map;
	u32 ads_regset_size;
	u32 ads_regset_count[27];
	struct guc_mmio_reg *ads_regset;
	u32 ads_golden_ctxt_size;
	u32 ads_waklv_size;
	u32 ads_capture_size;
	struct i915_vma *lrc_desc_pool_v69;
	void *lrc_desc_pool_vaddr_v69;
	struct xarray context_lookup;
	u32 params[14];
	struct {
		u32 base;
		unsigned int count;
		enum forcewake_domains fw_domains;
	} send_regs;
	i915_reg_t notify_reg;
	u32 mmio_msg;
	struct mutex send_mutex;
	struct {
		spinlock_t lock;
		u64 gt_stamp;
		long unsigned int ping_delay;
		struct delayed_work work;
		u32 shift;
		long unsigned int last_stat_jiffies;
	} timestamp;
	struct work_struct dead_guc_worker;
	long unsigned int last_dead_guc_jiffies;
};

struct intel_huc {
	struct intel_uc_fw fw;
	struct {
		i915_reg_t reg;
		u32 mask;
		u32 value;
	} status[2];
	struct {
		struct i915_sw_fence fence;
		struct hrtimer timer;
		struct notifier_block nb;
		enum intel_huc_delayed_load_status status;
	} delayed_load;
	struct i915_vma *heci_pkt;
	bool loaded_via_gsc;
};

struct intel_uc_ops;

struct intel_uc {
	const struct intel_uc_ops *ops;
	struct intel_gsc_uc gsc;
	struct intel_guc guc;
	struct intel_huc huc;
	struct drm_i915_gem_object *load_err_log;
	bool reset_in_progress;
	bool fw_table_invalid;
};

struct intel_wopcm {
	u32 size;
	struct {
		u32 base;
		u32 size;
	} guc;
};

struct seqcount_mutex {
	seqcount_t seqcount;
};

typedef struct seqcount_mutex seqcount_mutex_t;

struct intel_gt_timelines {
	spinlock_t lock;
	struct list_head active_list;
};

struct intel_gt_requests {
	struct delayed_work retire_work;
};

struct srcu_data;

struct srcu_usage;

struct srcu_struct {
	unsigned int srcu_idx;
	struct srcu_data *sda;
	struct lockdep_map dep_map;
	struct srcu_usage *srcu_sup;
};

struct intel_reset {
	long unsigned int flags;
	struct mutex mutex;
	wait_queue_head_t queue;
	struct srcu_struct backoff_srcu;
};

struct intel_llc {};

struct intel_rc6 {
	i915_reg_t res_reg[4];
	u64 prev_hw_residency[4];
	u64 cur_residency[4];
	u32 ctl_enable;
	u32 bios_rc_state;
	struct drm_i915_gem_object *pctx;
	bool supported: 1;
	bool enabled: 1;
	bool manual: 1;
	bool wakeref: 1;
	bool bios_state_captured: 1;
};

struct intel_rps_ei {
	ktime_t ktime;
	u32 render_c0;
	u32 media_c0;
};

struct intel_ips {
	u64 last_count1;
	long unsigned int last_time1;
	long unsigned int chipset_power;
	u64 last_count2;
	u64 last_time2;
	long unsigned int gfx_power;
	u8 corr;
	int c;
	int m;
};

struct intel_rps {
	struct mutex lock;
	struct timer_list timer;
	struct work_struct work;
	long unsigned int flags;
	ktime_t pm_timestamp;
	u32 pm_interval;
	u32 pm_iir;
	u32 pm_intrmsk_mbz;
	u32 pm_events;
	u8 cur_freq;
	u8 last_freq;
	u8 min_freq_softlimit;
	u8 max_freq_softlimit;
	u8 max_freq;
	u8 min_freq;
	u8 boost_freq;
	u8 idle_freq;
	u8 efficient_freq;
	u8 rp1_freq;
	u8 rp0_freq;
	u16 gpll_ref_freq;
	int last_adj;
	struct {
		struct mutex mutex;
		enum {
			LOW_POWER = 0,
			BETWEEN = 1,
			HIGH_POWER = 2,
		} mode;
		unsigned int interactive;
		u8 up_threshold;
		u8 down_threshold;
	} power;
	atomic_t num_waiters;
	unsigned int boosts;
	struct intel_rps_ei ei;
	struct intel_ips ips;
};

struct intel_gt_buffer_pool {
	spinlock_t lock;
	struct list_head cache_list[4];
	struct delayed_work work;
};

struct intel_migrate {
	struct intel_context *context;
};

struct sseu_dev_info {
	u8 slice_mask;
	intel_sseu_ss_mask_t subslice_mask;
	intel_sseu_ss_mask_t geometry_subslice_mask;
	intel_sseu_ss_mask_t compute_subslice_mask;
	union {
		u16 hsw[24];
		u16 xehp[64];
	} eu_mask;
	u16 eu_total;
	u8 eu_per_subslice;
	u8 min_eu_in_pool;
	u8 subslice_7eu[3];
	u8 has_slice_pg: 1;
	u8 has_subslice_pg: 1;
	u8 has_eu_pg: 1;
	u8 has_xehp_dss: 1;
	u8 max_slices;
	u8 max_subslices;
	u8 max_eus_per_subslice;
};

struct intel_hwconfig {
	u32 size;
	void *ptr;
};

struct intel_gt_info {
	unsigned int id;
	intel_engine_mask_t engine_mask;
	u32 l3bank_mask;
	u8 num_engines;
	u8 sfc_mask;
	u8 vdbox_sfc_access;
	struct sseu_dev_info sseu;
	long unsigned int mslice_mask;
	struct intel_hwconfig hwconfig;
};

struct intel_mmio_range;

struct intel_gt {
	struct drm_i915_private *i915;
	const char *name;
	enum intel_gt_type type;
	struct intel_uncore *uncore;
	struct i915_ggtt *ggtt;
	struct intel_uc uc;
	struct intel_gsc gsc;
	struct intel_wopcm wopcm;
	struct {
		struct mutex invalidate_lock;
		seqcount_mutex_t seqno;
	} tlb;
	struct i915_wa_list wa_list;
	struct intel_gt_timelines timelines;
	struct intel_gt_requests requests;
	struct {
		struct llist_head list;
		struct work_struct work;
	} watchdog;
	struct intel_wakeref wakeref;
	atomic_t user_wakeref;
	struct list_head closed_vma;
	spinlock_t closed_lock;
	ktime_t last_init_time;
	struct intel_reset reset;
	intel_wakeref_t awake;
	u32 clock_frequency;
	u32 clock_period_ns;
	struct intel_llc llc;
	struct intel_rc6 rc6;
	struct intel_rps rps;
	spinlock_t *irq_lock;
	u32 gt_imr;
	u32 pm_ier;
	u32 pm_imr;
	u32 pm_guc_events;
	struct {
		bool active;
		seqcount_mutex_t lock;
		ktime_t total;
		ktime_t start;
	} stats;
	struct intel_engine_cs *engine[27];
	struct intel_engine_cs *engine_class[54];
	enum intel_submission_method submission_method;
	struct {
		intel_engine_mask_t cslices;
	} ccs;
	struct i915_address_space *vm;
	struct intel_gt_buffer_pool buffer_pool;
	struct i915_vma *scratch;
	struct intel_migrate migrate;
	const struct intel_mmio_range *steering_table[7];
	struct {
		u8 groupid;
		u8 instanceid;
	} default_steering;
	spinlock_t mcr_lock;
	phys_addr_t phys_addr;
	struct intel_gt_info info;
	struct {
		u8 uc_index;
		u8 wb_index;
	} mocs;
	struct kobject sysfs_gt;
	struct gt_defaults defaults;
	struct kobject *sysfs_defaults;
	struct work_struct wedge;
	struct i915_perf_gt perf;
	struct list_head ggtt_link;
};

struct intel_gt_bool_throttle_attr {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	i915_reg_t (*reg32)(struct intel_gt *);
	u32 mask;
};

struct intel_gt_buffer_pool_node {
	struct i915_active active;
	struct drm_i915_gem_object *obj;
	struct list_head link;
	union {
		struct intel_gt_buffer_pool *pool;
		struct intel_gt_buffer_pool_node *free;
		struct callback_head rcu;
	};
	long unsigned int age;
	enum i915_map_type type;
	u32 pinned;
};

struct intel_uc_coredump;

struct intel_gt_coredump {
	const struct intel_gt *_gt;
	bool awake;
	bool simulated;
	struct intel_gt_info info;
	u32 eir;
	u32 pgtbl_er;
	u32 ier;
	u32 gtier[6];
	u32 ngtier;
	u32 forcewake;
	u32 error;
	u32 err_int;
	u32 fault_data0;
	u32 fault_data1;
	u32 done_reg;
	u32 gac_eco;
	u32 gam_ecochk;
	u32 gab_ctl;
	u32 gfx_mode;
	u32 gtt_cache;
	u32 aux_err;
	u32 gam_done;
	u32 clock_frequency;
	u32 clock_period_ns;
	u32 derrmr;
	u32 sfc_done[4];
	u32 nfence;
	u64 fence[32];
	struct intel_engine_coredump *engine;
	struct intel_uc_coredump *uc;
	struct intel_gt_coredump *next;
};

struct intel_gt_debugfs_file {
	const char *name;
	const struct file_operations *fops;
	bool (*eval)(void *);
};

struct intel_gt_definition {
	enum intel_gt_type type;
	char *name;
	u32 mapping_base;
	u32 gsi_offset;
	intel_engine_mask_t engine_mask;
};

struct intel_gtt_driver {
	unsigned int gen: 8;
	unsigned int is_g33: 1;
	unsigned int is_pineview: 1;
	unsigned int is_ironlake: 1;
	unsigned int has_pgtbl_enable: 1;
	unsigned int dma_mask_size: 8;
	int (*setup)(void);
	void (*cleanup)(void);
	void (*write_entry)(dma_addr_t, unsigned int, unsigned int);
	bool (*check_flags)(unsigned int);
	void (*chipset_flush)(void);
};

struct intel_gtt_driver_description {
	unsigned int gmch_chip_id;
	char *name;
	const struct intel_gtt_driver *gtt_driver;
};

struct intel_guc_state_capture {
	const struct __guc_mmio_reg_descr_group *reglists;
	struct __guc_mmio_reg_descr_group *extlists;
	struct __guc_capture_ads_cache ads_cache[96];
	void *ads_null_cache;
	struct list_head cachelist;
	int max_mmio_per_node;
	struct list_head outlist;
};

struct intel_guc_tlb_wait {
	struct wait_queue_head wq;
	bool busy;
};

struct intel_hdcp_gsc_message {
	struct i915_vma *vma;
	void *hdcp_cmd_in;
	void *hdcp_cmd_out;
};

struct intel_hdcp_shim {
	int (*write_an_aksv)(struct intel_digital_port *, u8 *);
	int (*read_bksv)(struct intel_digital_port *, u8 *);
	int (*read_bstatus)(struct intel_digital_port *, u8 *);
	int (*repeater_present)(struct intel_digital_port *, bool *);
	int (*read_ri_prime)(struct intel_digital_port *, u8 *);
	int (*read_ksv_ready)(struct intel_digital_port *, bool *);
	int (*read_ksv_fifo)(struct intel_digital_port *, int, u8 *);
	int (*read_v_prime_part)(struct intel_digital_port *, int, u32 *);
	int (*toggle_signalling)(struct intel_digital_port *, enum transcoder, bool);
	int (*stream_encryption)(struct intel_connector *, bool);
	bool (*check_link)(struct intel_digital_port *, struct intel_connector *);
	int (*hdcp_get_capability)(struct intel_digital_port *, bool *);
	enum hdcp_wired_protocol protocol;
	int (*hdcp_2_2_get_capability)(struct intel_connector *, bool *);
	int (*write_2_2_msg)(struct intel_connector *, void *, size_t);
	int (*read_2_2_msg)(struct intel_connector *, u8, void *, size_t);
	int (*config_stream_type)(struct intel_connector *, bool, u8);
	int (*stream_2_2_encryption)(struct intel_connector *, bool);
	int (*check_2_2_link)(struct intel_digital_port *, struct intel_connector *);
	int (*get_remote_hdcp_capability)(struct intel_connector *, bool *, bool *);
};

struct intel_hdmi_lpe_audio_port_pdata {
	u8 eld[128];
	int port;
	int pipe;
	int ls_clock;
	bool dp_output;
};

struct intel_hdmi_lpe_audio_pdata {
	struct intel_hdmi_lpe_audio_port_pdata port[3];
	int num_ports;
	int num_pipes;
	void (*notify_audio_lpe)(struct platform_device *, int);
	spinlock_t lpe_audio_slock;
};

struct intel_hotplug_funcs {
	void (*hpd_irq_setup)(struct drm_i915_private *);
	void (*hpd_enable_detection)(struct intel_encoder *);
};

struct intel_initial_plane_config {
	struct intel_framebuffer *fb;
	struct intel_memory_region *mem;
	resource_size_t phys_base;
	struct i915_vma *vma;
	unsigned int tiling;
	int size;
	u32 base;
	u8 rotation;
};

struct iommu_flush {
	void (*flush_context)(struct intel_iommu *, u16, u16, u8, u64);
	void (*flush_iotlb)(struct intel_iommu *, u16, u64, unsigned int, u64);
};

struct root_entry;

struct page_req_dsc;

struct q_inval;

struct iommu_pmu;

struct intel_iommu {
	void *reg;
	u64 reg_phys;
	u64 reg_size;
	u64 cap;
	u64 ecap;
	u64 vccap;
	u64 ecmdcap[4];
	u32 gcmd;
	raw_spinlock_t register_lock;
	int seq_id;
	int agaw;
	int msagaw;
	unsigned int irq;
	unsigned int pr_irq;
	unsigned int perf_irq;
	u16 segment;
	unsigned char name[16];
	long unsigned int *domain_ids;
	long unsigned int *copied_tables;
	spinlock_t lock;
	struct root_entry *root_entry;
	struct iommu_flush flush;
	struct page_req_dsc *prq;
	unsigned char prq_name[16];
	long unsigned int prq_seq_number;
	struct completion prq_complete;
	struct iopf_queue *iopf_queue;
	unsigned char iopfq_name[16];
	struct mutex iopf_lock;
	struct q_inval *qi;
	u32 iommu_state[4];
	struct rb_root device_rbtree;
	spinlock_t device_rbtree_lock;
	struct iommu_device iommu;
	int node;
	u32 flags;
	struct dmar_drhd_unit *drhd;
	void *perf_statistic;
	struct iommu_pmu *pmu;
};

struct intel_limit {
	struct {
		int min;
		int max;
	} dot;
	struct {
		int min;
		int max;
	} vco;
	struct {
		int min;
		int max;
	} n;
	struct {
		int min;
		int max;
	} m;
	struct {
		int min;
		int max;
	} m1;
	struct {
		int min;
		int max;
	} m2;
	struct {
		int min;
		int max;
	} p;
	struct {
		int min;
		int max;
	} p1;
	struct {
		int dot_limit;
		int p2_slow;
		int p2_fast;
	} p2;
};

struct intel_link_bw_limits {
	u8 force_fec_pipes;
	u8 bpp_limit_reached_pipes;
	int max_bpp_x16[4];
};

struct intel_lvds_pps {
	struct intel_pps_delays delays;
	int divider;
	int port;
	bool powerdown_on_reset;
};

struct intel_lvds_encoder {
	struct intel_encoder base;
	bool is_dual_link;
	i915_reg_t reg;
	u32 a3_power;
	struct intel_lvds_pps init_pps;
	u32 init_lvds_val;
	struct intel_connector *attached_connector;
};

struct intel_memory_region_ops;

struct intel_memory_region {
	struct drm_i915_private *i915;
	const struct intel_memory_region_ops *ops;
	struct io_mapping iomap;
	struct resource region;
	struct resource io;
	resource_size_t min_page_size;
	resource_size_t total;
	u16 type;
	u16 instance;
	enum intel_region_id id;
	char name[16];
	char uabi_name[16];
	bool private;
	struct {
		struct mutex lock;
		struct list_head list;
	} objects;
	bool is_range_manager;
	void *region_private;
};

struct intel_memory_region_ops {
	int (*init)(struct intel_memory_region *);
	int (*release)(struct intel_memory_region *);
	int (*init_object)(struct intel_memory_region *, struct drm_i915_gem_object *, resource_size_t, resource_size_t, resource_size_t, unsigned int);
};

struct intel_mmio_range {
	u32 start;
	u32 end;
};

struct intel_modifier_desc {
	u64 modifier;
	struct {
		u8 from;
		u8 until;
	} display_ver;
	const struct drm_format_info *formats;
	int format_count;
	u8 plane_caps;
	struct {
		u8 cc_planes: 3;
		u8 packed_aux_planes: 4;
		char: 1;
		u8 planar_aux_planes: 4;
	} ccs;
};

struct opregion_header;

struct opregion_acpi;

struct opregion_swsci;

struct opregion_asle;

struct opregion_asle_ext;

struct intel_opregion {
	struct intel_display *display;
	struct opregion_header *header;
	struct opregion_acpi *acpi;
	struct opregion_swsci *swsci;
	u32 swsci_gbda_sub_functions;
	u32 swsci_sbcb_sub_functions;
	struct opregion_asle *asle;
	struct opregion_asle_ext *asle_ext;
	void *rvda;
	const void *vbt;
	u32 vbt_size;
	struct work_struct asle_work;
	struct notifier_block acpi_notifier;
};

struct overlay_registers;

struct intel_overlay {
	struct intel_display *display;
	struct intel_context *context;
	struct intel_crtc *crtc;
	struct i915_vma *vma;
	struct i915_vma *old_vma;
	struct intel_frontbuffer *frontbuffer;
	bool active;
	bool pfit_active;
	u32 pfit_vscale_ratio;
	u32 color_key: 24;
	u32 color_key_enabled: 1;
	u32 brightness;
	u32 contrast;
	u32 saturation;
	u32 old_xscale;
	u32 old_yscale;
	struct drm_i915_gem_object *reg_bo;
	struct overlay_registers *regs;
	u32 flip_addr;
	struct i915_active last_flip;
	void (*flip_complete)(struct intel_overlay *);
};

struct overlay_registers {
	u32 OBUF_0Y;
	u32 OBUF_1Y;
	u32 OBUF_0U;
	u32 OBUF_0V;
	u32 OBUF_1U;
	u32 OBUF_1V;
	u32 OSTRIDE;
	u32 YRGB_VPH;
	u32 UV_VPH;
	u32 HORZ_PH;
	u32 INIT_PHS;
	u32 DWINPOS;
	u32 DWINSZ;
	u32 SWIDTH;
	u32 SWIDTHSW;
	u32 SHEIGHT;
	u32 YRGBSCALE;
	u32 UVSCALE;
	u32 OCLRC0;
	u32 OCLRC1;
	u32 DCLRKV;
	u32 DCLRKM;
	u32 SCLRKVH;
	u32 SCLRKVL;
	u32 SCLRKEN;
	u32 OCONFIG;
	u32 OCMD;
	u32 RESERVED1;
	u32 OSTART_0Y;
	u32 OSTART_1Y;
	u32 OSTART_0U;
	u32 OSTART_0V;
	u32 OSTART_1U;
	u32 OSTART_1V;
	u32 OTILEOFF_0Y;
	u32 OTILEOFF_1Y;
	u32 OTILEOFF_0U;
	u32 OTILEOFF_0V;
	u32 OTILEOFF_1U;
	u32 OTILEOFF_1V;
	u32 FASTHSCALE;
	u32 UVSCALEV;
	u32 RESERVEDC[86];
	u16 Y_VCOEFS[51];
	u16 RESERVEDD[77];
	u16 Y_HCOEFS[85];
	u16 RESERVEDE[171];
	u16 UV_VCOEFS[51];
	u16 RESERVEDF[77];
	u16 UV_HCOEFS[51];
	u16 RESERVEDG[77];
};

struct intel_overlay_snapshot {
	struct overlay_registers regs;
	long unsigned int base;
	u32 dovsta;
	u32 isr;
};

struct intel_package_header {
	u8 header_len;
	u8 header_ver;
	u8 reserved[10];
	u32 num_entries;
};

struct intel_panel_bl_funcs {
	int (*setup)(struct intel_connector *, enum pipe);
	u32 (*get)(struct intel_connector *, enum pipe);
	void (*set)(const struct drm_connector_state *, u32);
	void (*disable)(const struct drm_connector_state *, u32);
	void (*enable)(const struct intel_crtc_state *, const struct drm_connector_state *, u32);
	u32 (*hz_to_pwm)(struct intel_connector *, u32);
};

struct intel_plane_state;

struct intel_plane {
	struct drm_plane base;
	enum i9xx_plane_id i9xx_plane;
	enum plane_id id;
	enum pipe pipe;
	bool need_async_flip_toggle_wa;
	u32 frontbuffer_bit;
	struct {
		u32 base;
		u32 cntl;
		u32 size;
	} cursor;
	struct intel_fbc *fbc;
	int (*min_width)(const struct drm_framebuffer *, int, unsigned int);
	int (*max_width)(const struct drm_framebuffer *, int, unsigned int);
	int (*max_height)(const struct drm_framebuffer *, int, unsigned int);
	unsigned int (*min_alignment)(struct intel_plane *, const struct drm_framebuffer *, int);
	unsigned int (*max_stride)(struct intel_plane *, u32, u64, unsigned int);
	void (*update_noarm)(struct intel_dsb *, struct intel_plane *, const struct intel_crtc_state *, const struct intel_plane_state *);
	void (*update_arm)(struct intel_dsb *, struct intel_plane *, const struct intel_crtc_state *, const struct intel_plane_state *);
	void (*disable_arm)(struct intel_dsb *, struct intel_plane *, const struct intel_crtc_state *);
	bool (*get_hw_state)(struct intel_plane *, enum pipe *);
	int (*check_plane)(struct intel_crtc_state *, struct intel_plane_state *);
	int (*min_cdclk)(const struct intel_crtc_state *, const struct intel_plane_state *);
	void (*async_flip)(struct intel_dsb *, struct intel_plane *, const struct intel_crtc_state *, const struct intel_plane_state *, bool);
	void (*enable_flip_done)(struct intel_plane *);
	void (*disable_flip_done)(struct intel_plane *);
};

struct intel_plane_state {
	struct drm_plane_state uapi;
	struct {
		struct drm_crtc *crtc;
		struct drm_framebuffer *fb;
		u16 alpha;
		u16 pixel_blend_mode;
		unsigned int rotation;
		enum drm_color_encoding color_encoding;
		enum drm_color_range color_range;
		enum drm_scaling_filter scaling_filter;
	} hw;
	struct i915_vma *ggtt_vma;
	struct i915_vma *dpt_vma;
	long unsigned int flags;
	struct intel_fb_view view;
	u32 phys_dma_addr;
	struct drm_vblank_work unpin_work;
	bool decrypt;
	bool force_black;
	u32 ctl;
	u32 color_ctl;
	u32 cus_ctl;
	int scaler_id;
	struct intel_plane *planar_linked_plane;
	u32 planar_slave;
	struct drm_intel_sprite_colorkey ckey;
	struct drm_rect psr2_sel_fetch_area;
	u64 ccval;
	const char *no_fbc_reason;
};

struct pmdemand_params {
	u16 qclk_gv_bw;
	u8 voltage_index;
	u8 qclk_gv_index;
	u8 active_pipes;
	u8 active_dbufs;
	u8 active_phys;
	u8 plls;
	u16 cdclk_freq_mhz;
	u16 ddiclk_max;
	u8 scalers;
};

struct intel_pmdemand_state {
	struct intel_global_state base;
	int ddi_clocks[4];
	u16 active_combo_phys_mask;
	struct pmdemand_params params;
};

struct intel_psf_gv_point {
	u8 clk;
};

struct intel_pxp {
	struct intel_gt *ctrl_gt;
	bool platform_cfg_is_bad;
	u32 kcr_base;
	struct gsccs_session_resources gsccs_res;
	struct i915_pxp_component *pxp_component;
	struct device_link *dev_link;
	bool pxp_component_added;
	struct intel_context *ce;
	struct mutex arb_mutex;
	bool arb_is_valid;
	u32 key_instance;
	struct mutex tee_mutex;
	struct {
		struct drm_i915_gem_object *obj;
		void *vaddr;
	} stream_cmd;
	bool hw_state_invalidated;
	bool irq_enabled;
	struct completion termination;
	struct work_struct session_work;
	u32 session_events;
};

struct intel_qgv_point {
	u16 dclk;
	u16 t_rp;
	u16 t_rdpre;
	u16 t_rc;
	u16 t_ras;
	u16 t_rcd;
};

struct intel_qgv_info {
	struct intel_qgv_point points[8];
	struct intel_psf_gv_point psf_points[3];
	u8 num_points;
	u8 num_psf_points;
	u8 t_bl;
	u8 max_numchannels;
	u8 channel_width;
	u8 deinterleave;
};

struct intel_quirk {
	int device;
	int subsystem_vendor;
	int subsystem_device;
	void (*hook)(struct intel_display *);
};

struct intel_renderstate_rodata;

struct intel_renderstate {
	struct i915_gem_ww_ctx ww;
	const struct intel_renderstate_rodata *rodata;
	struct i915_vma *vma;
	u32 batch_offset;
	u32 batch_size;
	u32 aux_offset;
	u32 aux_size;
};

struct intel_renderstate_rodata {
	const u32 *reloc;
	const u32 *batch;
	const u32 batch_items;
};

struct intel_ring {
	struct kref ref;
	struct i915_vma *vma;
	void *vaddr;
	atomic_t pin_count;
	u32 head;
	u32 tail;
	u32 emit;
	u32 space;
	u32 size;
	u32 wrap;
	u32 effective_size;
};

struct intel_rng_hw {
	struct pci_dev *dev;
	void *mem;
	u8 bios_cntl_off;
	u8 bios_cntl_val;
	u8 fwh_dec_en1_off;
	u8 fwh_dec_en1_val;
};

struct intel_rom {
	struct pci_dev *pdev;
	void *oprom;
	struct intel_uncore *uncore;
	loff_t offset;
	size_t size;
	u32 (*read32)(struct intel_rom *, loff_t);
	u16 (*read16)(struct intel_rom *, loff_t);
	void (*read_block)(struct intel_rom *, void *, loff_t, size_t);
	void (*free)(struct intel_rom *);
};

struct intel_rps_freq_caps {
	u8 rp0_freq;
	u8 rp1_freq;
	u8 min_freq;
};

struct intel_sa_info {
	u16 displayrtids;
	u8 deburst;
	u8 deprogbwlimit;
	u8 derating;
};

struct intel_sdvo;

struct intel_sdvo_ddc {
	struct i2c_adapter ddc;
	struct intel_sdvo *sdvo;
	u8 ddc_bus;
};

struct intel_sdvo_caps {
	u8 vendor_id;
	u8 device_id;
	u8 device_rev_id;
	u8 sdvo_version_major;
	u8 sdvo_version_minor;
	unsigned int sdvo_num_inputs: 2;
	unsigned int smooth_scaling: 1;
	unsigned int sharp_scaling: 1;
	unsigned int up_scaling: 1;
	unsigned int down_scaling: 1;
	unsigned int stall_support: 1;
	unsigned int pad: 1;
	u16 output_flags;
};

struct intel_sdvo {
	struct intel_encoder base;
	struct i2c_adapter *i2c;
	u8 target_addr;
	struct intel_sdvo_ddc ddc[3];
	i915_reg_t sdvo_reg;
	struct intel_sdvo_caps caps;
	u8 colorimetry_cap;
	int pixel_clock_min;
	int pixel_clock_max;
	u16 hotplug_active;
	u8 dtd_sdvo_flags;
};

struct intel_sdvo_connector {
	struct intel_connector base;
	u16 output_flag;
	u8 tv_format_supported[19];
	int format_supported_num;
	struct drm_property *tv_format;
	struct drm_property *left;
	struct drm_property *right;
	struct drm_property *top;
	struct drm_property *bottom;
	struct drm_property *hpos;
	struct drm_property *vpos;
	struct drm_property *contrast;
	struct drm_property *saturation;
	struct drm_property *hue;
	struct drm_property *sharpness;
	struct drm_property *flicker_filter;
	struct drm_property *flicker_filter_adaptive;
	struct drm_property *flicker_filter_2d;
	struct drm_property *tv_chroma_filter;
	struct drm_property *tv_luma_filter;
	struct drm_property *dot_crawl;
	struct drm_property *brightness;
	u32 max_hscan;
	u32 max_vscan;
	bool is_hdmi;
};

struct intel_sdvo_connector_state {
	struct intel_digital_connector_state base;
	struct {
		unsigned int overscan_h;
		unsigned int overscan_v;
		unsigned int hpos;
		unsigned int vpos;
		unsigned int sharpness;
		unsigned int flicker_filter;
		unsigned int flicker_filter_2d;
		unsigned int flicker_filter_adaptive;
		unsigned int chroma_filter;
		unsigned int luma_filter;
		unsigned int dot_crawl;
	} tv;
};

struct intel_sdvo_dtd {
	struct {
		u16 clock;
		u8 h_active;
		u8 h_blank;
		u8 h_high;
		u8 v_active;
		u8 v_blank;
		u8 v_high;
	} part1;
	struct {
		u8 h_sync_off;
		u8 h_sync_width;
		u8 v_sync_off_width;
		u8 sync_off_width_high;
		u8 dtd_flags;
		u8 sdvo_flags;
		u8 v_sync_off_high;
		u8 reserved;
	} part2;
};

struct intel_sdvo_encode {
	u8 dvi_rev;
	u8 hdmi_rev;
};

struct intel_sdvo_enhancements_reply {
	unsigned int flicker_filter: 1;
	unsigned int flicker_filter_adaptive: 1;
	unsigned int flicker_filter_2d: 1;
	unsigned int saturation: 1;
	unsigned int hue: 1;
	unsigned int brightness: 1;
	unsigned int contrast: 1;
	unsigned int overscan_h: 1;
	unsigned int overscan_v: 1;
	unsigned int hpos: 1;
	unsigned int vpos: 1;
	unsigned int sharpness: 1;
	unsigned int dot_crawl: 1;
	unsigned int dither: 1;
	unsigned int tv_chroma_filter: 1;
	unsigned int tv_luma_filter: 1;
} __attribute__((packed));

struct intel_sdvo_get_trained_inputs_response {
	unsigned int input0_trained: 1;
	unsigned int input1_trained: 1;
	unsigned int pad: 6;
} __attribute__((packed));

struct intel_sdvo_in_out_map {
	u16 in0;
	u16 in1;
};

struct intel_sdvo_pixel_clock_range {
	u16 min;
	u16 max;
};

struct intel_sdvo_preferred_input_timing_args {
	u16 clock;
	u16 width;
	u16 height;
	u8 interlace: 1;
	u8 scaled: 1;
	u8 pad: 6;
} __attribute__((packed));

struct intel_sdvo_sdtv_resolution_request {
	unsigned int ntsc_m: 1;
	unsigned int ntsc_j: 1;
	unsigned int ntsc_443: 1;
	unsigned int pal_b: 1;
	unsigned int pal_d: 1;
	unsigned int pal_g: 1;
	unsigned int pal_h: 1;
	unsigned int pal_i: 1;
	unsigned int pal_m: 1;
	unsigned int pal_n: 1;
	unsigned int pal_nc: 1;
	unsigned int pal_60: 1;
	unsigned int secam_b: 1;
	unsigned int secam_d: 1;
	unsigned int secam_g: 1;
	unsigned int secam_k: 1;
	unsigned int secam_k1: 1;
	unsigned int secam_l: 1;
	unsigned int secam_60: 1;
	unsigned int pad: 5;
} __attribute__((packed));

struct intel_sdvo_set_target_input_args {
	unsigned int target_1: 1;
	unsigned int pad: 7;
} __attribute__((packed));

struct intel_sdvo_tv_format {
	unsigned int ntsc_m: 1;
	unsigned int ntsc_j: 1;
	unsigned int ntsc_443: 1;
	unsigned int pal_b: 1;
	unsigned int pal_d: 1;
	unsigned int pal_g: 1;
	unsigned int pal_h: 1;
	unsigned int pal_i: 1;
	unsigned int pal_m: 1;
	unsigned int pal_n: 1;
	unsigned int pal_nc: 1;
	unsigned int pal_60: 1;
	unsigned int secam_b: 1;
	unsigned int secam_d: 1;
	unsigned int secam_g: 1;
	unsigned int secam_k: 1;
	unsigned int secam_k1: 1;
	unsigned int secam_l: 1;
	unsigned int secam_60: 1;
	unsigned int hdtv_std_smpte_240m_1080i_59: 1;
	unsigned int hdtv_std_smpte_240m_1080i_60: 1;
	unsigned int hdtv_std_smpte_260m_1080i_59: 1;
	unsigned int hdtv_std_smpte_260m_1080i_60: 1;
	unsigned int hdtv_std_smpte_274m_1080i_50: 1;
	unsigned int hdtv_std_smpte_274m_1080i_59: 1;
	unsigned int hdtv_std_smpte_274m_1080i_60: 1;
	unsigned int hdtv_std_smpte_274m_1080p_23: 1;
	unsigned int hdtv_std_smpte_274m_1080p_24: 1;
	unsigned int hdtv_std_smpte_274m_1080p_25: 1;
	unsigned int hdtv_std_smpte_274m_1080p_29: 1;
	unsigned int hdtv_std_smpte_274m_1080p_30: 1;
	unsigned int hdtv_std_smpte_274m_1080p_50: 1;
	unsigned int hdtv_std_smpte_274m_1080p_59: 1;
	unsigned int hdtv_std_smpte_274m_1080p_60: 1;
	unsigned int hdtv_std_smpte_295m_1080i_50: 1;
	unsigned int hdtv_std_smpte_295m_1080p_50: 1;
	unsigned int hdtv_std_smpte_296m_720p_59: 1;
	unsigned int hdtv_std_smpte_296m_720p_60: 1;
	unsigned int hdtv_std_smpte_296m_720p_50: 1;
	unsigned int hdtv_std_smpte_293m_480p_59: 1;
	unsigned int hdtv_std_smpte_170m_480i_59: 1;
	unsigned int hdtv_std_iturbt601_576i_50: 1;
	unsigned int hdtv_std_iturbt601_576p_50: 1;
	unsigned int hdtv_std_eia_7702a_480i_60: 1;
	unsigned int hdtv_std_eia_7702a_480p_60: 1;
	unsigned int pad: 3;
} __attribute__((packed));

struct intel_shared_dpll_funcs {
	void (*enable)(struct drm_i915_private *, struct intel_shared_dpll *, const struct intel_dpll_hw_state *);
	void (*disable)(struct drm_i915_private *, struct intel_shared_dpll *);
	bool (*get_hw_state)(struct drm_i915_private *, struct intel_shared_dpll *, struct intel_dpll_hw_state *);
	int (*get_freq)(struct drm_i915_private *, const struct intel_shared_dpll *, const struct intel_dpll_hw_state *);
};

struct intel_shared_regs {
	struct er_account regs[7];
	int refcnt;
	unsigned int core_id;
};

struct intel_tc_phy_ops {
	enum intel_display_power_domain (*cold_off_domain)(struct intel_tc_port *);
	u32 (*hpd_live_status)(struct intel_tc_port *);
	bool (*is_ready)(struct intel_tc_port *);
	bool (*is_owned)(struct intel_tc_port *);
	void (*get_hw_state)(struct intel_tc_port *);
	bool (*connect)(struct intel_tc_port *, int);
	void (*disconnect)(struct intel_tc_port *);
	void (*init)(struct intel_tc_port *);
};

struct intel_tc_port {
	struct intel_digital_port *dig_port;
	const struct intel_tc_phy_ops *phy_ops;
	struct mutex lock;
	intel_wakeref_t lock_wakeref;
	struct delayed_work disconnect_phy_work;
	struct delayed_work link_reset_work;
	int link_refcount;
	bool legacy_port: 1;
	const char *port_name;
	enum tc_port_mode mode;
	enum tc_port_mode init_mode;
	enum phy_fia phy_fia;
	u8 phy_fia_idx;
};

struct intel_timeline {
	u64 fence_context;
	u32 seqno;
	struct mutex mutex;
	atomic_t pin_count;
	atomic_t active_count;
	void *hwsp_map;
	const u32 *hwsp_seqno;
	struct i915_vma *hwsp_ggtt;
	u32 hwsp_offset;
	bool has_initial_breadcrumb;
	struct list_head requests;
	struct i915_active_fence last_request;
	struct i915_active active;
	struct intel_timeline *retire;
	struct i915_syncmap *sync;
	struct list_head link;
	struct intel_gt *gt;
	struct list_head engine_link;
	struct kref kref;
	struct callback_head rcu;
};

struct intel_tv {
	struct intel_encoder base;
	int type;
};

struct intel_tv_connector_state {
	struct drm_connector_state base;
	struct {
		u16 top;
		u16 bottom;
	} margins;
	bool bypass_vfilter;
};

struct intel_uc_coredump {
	struct intel_uc_fw guc_fw;
	struct intel_uc_fw huc_fw;
	struct guc_info guc;
};

struct intel_uc_ops {
	int (*sanitize)(struct intel_uc *);
	void (*init_fw)(struct intel_uc *);
	void (*fini_fw)(struct intel_uc *);
	int (*init)(struct intel_uc *);
	void (*fini)(struct intel_uc *);
	int (*init_hw)(struct intel_uc *);
	void (*fini_hw)(struct intel_uc *);
	void (*resume_mappings)(struct intel_uc *);
};

struct intel_uncore_extra_reg {
	raw_spinlock_t lock;
	u64 config;
	u64 config1;
	u64 config2;
	atomic_t ref;
};

struct intel_uncore_pmu;

struct intel_uncore_box {
	int dieid;
	int n_active;
	int n_events;
	int cpu;
	long unsigned int flags;
	atomic_t refcnt;
	struct perf_event *events[10];
	struct perf_event *event_list[10];
	struct event_constraint *event_constraint[10];
	long unsigned int active_mask[1];
	u64 tags[10];
	struct pci_dev *pci_dev;
	struct intel_uncore_pmu *pmu;
	u64 hrtimer_duration;
	struct hrtimer hrtimer;
	struct list_head list;
	struct list_head active_list;
	void *io_addr;
	struct intel_uncore_extra_reg shared_regs[0];
};

struct intel_uncore_discovery_type {
	struct rb_node node;
	enum uncore_access_type access_type;
	struct rb_root units;
	u16 type;
	u8 num_counters;
	u8 counter_width;
	u8 ctl_offset;
	u8 ctr_offset;
	u16 num_units;
};

struct intel_uncore_discovery_unit {
	struct rb_node node;
	unsigned int pmu_idx;
	unsigned int id;
	unsigned int die;
	u64 addr;
};

struct intel_uncore_forcewake_domain {
	struct intel_uncore *uncore;
	enum forcewake_domain_id id;
	enum forcewake_domains mask;
	unsigned int wake_count;
	bool active;
	struct hrtimer timer;
	u32 *reg_set;
	u32 *reg_ack;
};

struct intel_uncore_fw_get {
	void (*force_wake_get)(struct intel_uncore *, enum forcewake_domains);
};

struct intel_uncore_init_fun {
	void (*cpu_init)(void);
	int (*pci_init)(void);
	void (*mmio_init)(void);
	bool use_discovery;
	int *uncore_units_ignore;
};

struct intel_uncore_ops {
	void (*init_box)(struct intel_uncore_box *);
	void (*exit_box)(struct intel_uncore_box *);
	void (*disable_box)(struct intel_uncore_box *);
	void (*enable_box)(struct intel_uncore_box *);
	void (*disable_event)(struct intel_uncore_box *, struct perf_event *);
	void (*enable_event)(struct intel_uncore_box *, struct perf_event *);
	u64 (*read_counter)(struct intel_uncore_box *, struct perf_event *);
	int (*hw_config)(struct intel_uncore_box *, struct perf_event *);
	struct event_constraint * (*get_constraint)(struct intel_uncore_box *, struct perf_event *);
	void (*put_constraint)(struct intel_uncore_box *, struct perf_event *);
};

struct intel_uncore_type;

struct intel_uncore_pmu {
	struct pmu pmu;
	char name[32];
	int pmu_idx;
	bool registered;
	atomic_t activeboxes;
	cpumask_t cpu_mask;
	struct intel_uncore_type *type;
	struct intel_uncore_box **boxes;
};

struct uncore_iio_topology;

struct uncore_upi_topology;

struct intel_uncore_topology {
	int pmu_idx;
	union {
		void *untyped;
		struct uncore_iio_topology *iio;
		struct uncore_upi_topology *upi;
	};
};

struct uncore_event_desc;

struct intel_uncore_type {
	const char *name;
	int num_counters;
	int num_boxes;
	int perf_ctr_bits;
	int fixed_ctr_bits;
	int num_freerunning_types;
	int type_id;
	unsigned int perf_ctr;
	unsigned int event_ctl;
	unsigned int event_mask;
	unsigned int event_mask_ext;
	unsigned int fixed_ctr;
	unsigned int fixed_ctl;
	unsigned int box_ctl;
	union {
		unsigned int msr_offset;
		unsigned int mmio_offset;
	};
	unsigned int mmio_map_size;
	unsigned int num_shared_regs: 8;
	unsigned int single_fixed: 1;
	unsigned int pair_ctr_ctl: 1;
	union {
		u64 *msr_offsets;
		u64 *pci_offsets;
		u64 *mmio_offsets;
	};
	struct event_constraint unconstrainted;
	struct event_constraint *constraints;
	struct intel_uncore_pmu *pmus;
	struct intel_uncore_ops *ops;
	struct uncore_event_desc *event_descs;
	struct freerunning_counters *freerunning;
	const struct attribute_group *attr_groups[4];
	const struct attribute_group **attr_update;
	struct pmu *pmu;
	struct rb_root *boxes;
	struct intel_uncore_topology **topology;
	int (*get_topology)(struct intel_uncore_type *);
	void (*set_mapping)(struct intel_uncore_type *);
	void (*cleanup_mapping)(struct intel_uncore_type *);
	void (*cleanup_extra_boxes)(struct intel_uncore_type *);
};

struct intel_vblank_evade_ctx {
	struct intel_crtc *crtc;
	int min;
	int max;
	int vblank_start;
	bool need_vlv_dsi_wa;
};

struct intel_wakeref_lockclass {
	struct lock_class_key mutex;
	struct lock_class_key work;
};

struct intel_wakeref_ops {
	int (*get)(struct intel_wakeref *);
	int (*put)(struct intel_wakeref *);
};

struct intel_watermark_params {
	u16 fifo_size;
	u16 max_wm;
	u8 default_wm;
	u8 guard_size;
	u8 cacheline_size;
};

struct intel_wedge_me {
	struct delayed_work work;
	struct intel_gt *gt;
	const char *name;
};

struct intel_wm_config {
	unsigned int num_pipes_active;
	bool sprites_enabled;
	bool sprites_scaled;
};

struct intel_wm_funcs {
	void (*update_wm)(struct drm_i915_private *);
	int (*compute_watermarks)(struct intel_atomic_state *, struct intel_crtc *);
	void (*initial_watermarks)(struct intel_atomic_state *, struct intel_crtc *);
	void (*atomic_update_watermarks)(struct intel_atomic_state *, struct intel_crtc *);
	void (*optimize_watermarks)(struct intel_atomic_state *, struct intel_crtc *);
	int (*compute_global_watermarks)(struct intel_atomic_state *);
	void (*get_hw_state)(struct drm_i915_private *);
};

union intel_x86_pebs_dse {
	u64 val;
	struct {
		unsigned int ld_dse: 4;
		unsigned int ld_stlb_miss: 1;
		unsigned int ld_locked: 1;
		unsigned int ld_data_blk: 1;
		unsigned int ld_addr_blk: 1;
		unsigned int ld_reserved: 24;
	};
	struct {
		unsigned int st_l1d_hit: 1;
		unsigned int st_reserved1: 3;
		unsigned int st_stlb_miss: 1;
		unsigned int st_locked: 1;
		unsigned int st_reserved2: 26;
	};
	struct {
		unsigned int st_lat_dse: 4;
		unsigned int st_lat_stlb_miss: 1;
		unsigned int st_lat_locked: 1;
		unsigned int ld_reserved3: 26;
	};
	struct {
		unsigned int mtl_dse: 5;
		unsigned int mtl_locked: 1;
		unsigned int mtl_stlb_miss: 1;
		unsigned int mtl_fwd_blk: 1;
		unsigned int ld_reserved4: 24;
	};
	struct {
		unsigned int lnc_dse: 8;
		unsigned int ld_reserved5: 2;
		unsigned int lnc_stlb_miss: 1;
		unsigned int lnc_locked: 1;
		unsigned int lnc_data_blk: 1;
		unsigned int lnc_addr_blk: 1;
		unsigned int ld_reserved6: 18;
	};
};

struct internal_container {
	struct klist_node node;
	struct attribute_container *cont;
	struct device classdev;
};

struct vport;

struct internal_dev {
	struct vport *vport;
};

struct internal_state {
	int dummy;
};

struct interval {
	uint32_t first;
	uint32_t last;
};

struct interval_tree_span_iter {
	struct interval_tree_node *nodes[2];
	long unsigned int first_index;
	long unsigned int last_index;
	union {
		long unsigned int start_hole;
		long unsigned int start_used;
	};
	union {
		long unsigned int last_hole;
		long unsigned int last_used;
	};
	int is_hole;
};

struct interval_tree_double_span_iter {
	struct rb_root_cached *itrees[2];
	struct interval_tree_span_iter spans[2];
	union {
		long unsigned int start_hole;
		long unsigned int start_used;
	};
	union {
		long unsigned int last_hole;
		long unsigned int last_used;
	};
	int is_used;
};

struct io {
	long unsigned int error_bits;
	atomic_t count;
	struct dm_io_client *client;
	io_notify_fn callback;
	void *context;
	void *vma_invalidate_address;
	long unsigned int vma_invalidate_size;
	long: 64;
};

struct io_accept {
	struct file *file;
	struct sockaddr *addr;
	int *addr_len;
	int flags;
	int iou_flags;
	u32 file_slot;
	long unsigned int nofile;
};

struct io_alloc_cache {
	void **entries;
	unsigned int nr_cached;
	unsigned int max_cached;
	unsigned int elem_size;
	unsigned int init_clear;
};

struct io_apic {
	unsigned int index;
	unsigned int unused[3];
	unsigned int data;
	unsigned int unused2[11];
	unsigned int eoi;
};

struct ubuf_info;

struct msghdr {
	void *msg_name;
	int msg_namelen;
	int msg_inq;
	struct iov_iter msg_iter;
	union {
		void *msg_control;
		void *msg_control_user;
	};
	bool msg_control_is_user: 1;
	bool msg_get_inq: 1;
	unsigned int msg_flags;
	__kernel_size_t msg_controllen;
	struct kiocb *msg_iocb;
	struct ubuf_info *msg_ubuf;
	int (*sg_from_iter)(struct sk_buff *, struct iov_iter *, size_t);
};

struct io_async_msghdr {
	struct iovec *free_iov;
	int free_iov_nr;
	union {
		struct {
			int namelen;
			struct iovec fast_iov;
			__kernel_size_t controllen;
			__kernel_size_t payloadlen;
			struct sockaddr *uaddr;
			struct msghdr msg;
			struct __kernel_sockaddr_storage addr;
		};
		struct {
			int namelen;
			struct iovec fast_iov;
			__kernel_size_t controllen;
			__kernel_size_t payloadlen;
			struct sockaddr *uaddr;
			struct msghdr msg;
			struct __kernel_sockaddr_storage addr;
		} clear;
	};
};

struct iov_iter_state {
	size_t iov_offset;
	size_t count;
	long unsigned int nr_segs;
};

struct wait_page_queue {
	struct folio *folio;
	int bit_nr;
	wait_queue_entry_t wait;
};

struct uio_meta {
	uio_meta_flags_t flags;
	u16 app_tag;
	u64 seed;
	struct iov_iter iter;
};

struct io_meta_state {
	u32 seed;
	struct iov_iter_state iter_meta;
};

struct io_async_rw {
	size_t bytes_done;
	struct iovec *free_iovec;
	union {
		struct {
			struct iov_iter iter;
			struct iov_iter_state iter_state;
			struct iovec fast_iov;
			int free_iov_nr;
			union {
				struct wait_page_queue wpq;
				struct {
					struct uio_meta meta;
					struct io_meta_state meta_state;
				};
			};
		};
		struct {
			struct iov_iter iter;
			struct iov_iter_state iter_state;
			struct iovec fast_iov;
			int free_iov_nr;
			union {
				struct wait_page_queue wpq;
				struct {
					struct uio_meta meta;
					struct io_meta_state meta_state;
				};
			};
		} clear;
	};
};

struct io_bind {
	struct file *file;
	int addr_len;
};

struct io_bitmap {
	u64 sequence;
	refcount_t refcnt;
	unsigned int max;
	long unsigned int bitmap[1024];
};

struct io_btrfs_cmd {
	struct btrfs_uring_priv *priv;
};

struct io_buffer {
	struct list_head list;
	__u64 addr;
	__u32 len;
	__u16 bid;
	__u16 bgid;
};

struct io_mapped_region {
	struct page **pages;
	void *ptr;
	unsigned int nr_pages;
	unsigned int flags;
};

struct io_uring_buf_ring;

struct io_buffer_list {
	union {
		struct list_head buf_list;
		struct io_uring_buf_ring *buf_ring;
	};
	__u16 bgid;
	__u16 buf_nr_pages;
	__u16 nr_entries;
	__u16 head;
	__u16 mask;
	__u16 flags;
	struct io_mapped_region region;
};

struct io_cancel {
	struct file *file;
	u64 addr;
	u32 flags;
	s32 fd;
	u8 opcode;
};

struct io_ring_ctx;

struct io_cancel_data {
	struct io_ring_ctx *ctx;
	union {
		u64 data;
		struct file *file;
	};
	u8 opcode;
	u32 flags;
	int seq;
};

struct io_wq_work;

typedef bool work_cancel_fn(struct io_wq_work *, void *);

struct io_cb_cancel_data {
	work_cancel_fn *fn;
	void *data;
	int nr_running;
	int nr_pending;
	bool cancel_all;
};

struct io_close {
	struct file *file;
	int fd;
	u32 file_slot;
};

struct io_cmd_data {
	struct file *file;
	__u8 data[56];
};

struct io_kiocb;

struct io_cold_def {
	const char *name;
	void (*cleanup)(struct io_kiocb *);
	void (*fail)(struct io_kiocb *);
};

struct io_comp_batch {
	struct rq_list req_list;
	bool need_ts;
	void (*complete)(struct io_comp_batch *);
};

struct io_connect {
	struct file *file;
	struct sockaddr *addr;
	int addr_len;
	bool in_progress;
	bool seen_econnaborted;
};

struct io_context {
	atomic_long_t refcount;
	atomic_t active_ref;
	short unsigned int ioprio;
};

struct io_cq {
	struct request_queue *q;
	struct io_context *ioc;
	union {
		struct list_head q_node;
		struct kmem_cache *__rcu_icq_cache;
	};
	union {
		struct hlist_node ioc_node;
		struct callback_head __rcu_head;
	};
	unsigned int flags;
};

struct io_cqe {
	__u64 user_data;
	__s32 res;
	union {
		__u32 flags;
		int fd;
	};
};

struct io_cqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 overflow;
	__u32 cqes;
	__u32 flags;
	__u32 resv1;
	__u64 user_addr;
};

struct io_defer_entry {
	struct list_head list;
	struct io_kiocb *req;
	u32 seq;
};

struct io_epoll {
	struct file *file;
	int epfd;
	int op;
	int fd;
	struct epoll_event event;
};

struct io_err_c {
	struct dm_dev *dev;
	sector_t start;
};

struct io_ev_fd {
	struct eventfd_ctx *cq_ev_fd;
	unsigned int eventfd_async;
	unsigned int last_cq_tail;
	refcount_t refs;
	atomic_t ops;
	struct callback_head rcu;
};

struct io_fadvise {
	struct file *file;
	u64 offset;
	u64 len;
	u32 advice;
};

struct io_rsrc_node;

struct io_rsrc_data {
	unsigned int nr;
	struct io_rsrc_node **nodes;
};

struct io_file_table {
	struct io_rsrc_data data;
	long unsigned int *bitmap;
	unsigned int alloc_hint;
};

struct io_fixed_install {
	struct file *file;
	unsigned int o_flags;
};

struct io_ftrunc {
	struct file *file;
	loff_t len;
};

struct io_futex {
	struct file *file;
	union {
		u32 *uaddr;
		struct futex_waitv *uwaitv;
	};
	long unsigned int futex_val;
	long unsigned int futex_mask;
	long unsigned int futexv_owned;
	u32 futex_flags;
	unsigned int futex_nr;
	bool futexv_unqueued;
};

struct io_futex_data {
	struct futex_q q;
	struct io_kiocb *req;
};

struct io_hash_bucket {
	struct hlist_head list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_hash_table {
	struct io_hash_bucket *hbs;
	unsigned int hash_bits;
};

struct io_imu_folio_data {
	unsigned int nr_pages_head;
	unsigned int nr_pages_mid;
	unsigned int folio_shift;
	unsigned int nr_folios;
};

struct io_uring_sqe;

struct io_issue_def {
	unsigned int needs_file: 1;
	unsigned int plug: 1;
	unsigned int hash_reg_file: 1;
	unsigned int unbound_nonreg_file: 1;
	unsigned int pollin: 1;
	unsigned int pollout: 1;
	unsigned int poll_exclusive: 1;
	unsigned int buffer_select: 1;
	unsigned int audit_skip: 1;
	unsigned int ioprio: 1;
	unsigned int iopoll: 1;
	unsigned int iopoll_queue: 1;
	unsigned int vectored: 1;
	short unsigned int async_size;
	int (*issue)(struct io_kiocb *, unsigned int);
	int (*prep)(struct io_kiocb *, const struct io_uring_sqe *);
};

struct io_wq_work_node {
	struct io_wq_work_node *next;
};

struct io_tw_state;

typedef void (*io_req_tw_func_t)(struct io_kiocb *, struct io_tw_state *);

struct io_task_work {
	struct llist_node node;
	io_req_tw_func_t func;
};

struct io_wq_work {
	struct io_wq_work_node list;
	atomic_t flags;
	int cancel_seq;
};

struct io_uring_task;

struct io_kiocb {
	union {
		struct file *file;
		struct io_cmd_data cmd;
	};
	u8 opcode;
	u8 iopoll_completed;
	u16 buf_index;
	unsigned int nr_tw;
	io_req_flags_t flags;
	struct io_cqe cqe;
	struct io_ring_ctx *ctx;
	struct io_uring_task *tctx;
	union {
		struct io_buffer *kbuf;
		struct io_buffer_list *buf_list;
		struct io_rsrc_node *buf_node;
	};
	union {
		struct io_wq_work_node comp_list;
		__poll_t apoll_events;
	};
	struct io_rsrc_node *file_node;
	atomic_t refs;
	bool cancel_seq_set;
	struct io_task_work io_task_work;
	union {
		struct hlist_node hash_node;
		u64 iopoll_start;
	};
	struct async_poll *apoll;
	void *async_data;
	atomic_t poll_refs;
	struct io_kiocb *link;
	const struct cred *creds;
	struct io_wq_work work;
	struct {
		u64 extra1;
		u64 extra2;
	} big_cqe;
};

struct io_link {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_listen {
	struct file *file;
	int backlog;
};

struct io_madvise {
	struct file *file;
	u64 addr;
	u64 len;
	u32 advice;
};

struct io_mapped_ubuf {
	u64 ubuf;
	unsigned int len;
	unsigned int nr_bvecs;
	unsigned int folio_shift;
	refcount_t refs;
	long unsigned int acct_pages;
	struct bio_vec bvec[0];
};

struct io_mkdir {
	struct file *file;
	int dfd;
	umode_t mode;
	struct filename *filename;
};

struct io_msg {
	struct file *file;
	struct file *src_file;
	struct callback_head tw;
	u64 user_data;
	u32 len;
	u32 cmd;
	u32 src_fd;
	union {
		u32 dst_fd;
		u32 cqe_flags;
	};
	u32 flags;
};

struct io_napi_entry {
	unsigned int napi_id;
	struct list_head list;
	long unsigned int timeout;
	struct hlist_node node;
	struct callback_head rcu;
};

struct io_nop {
	struct file *file;
	int result;
	int fd;
	int buffer;
	unsigned int flags;
};

struct ubuf_info_ops;

struct ubuf_info {
	const struct ubuf_info_ops *ops;
	refcount_t refcnt;
	u8 flags;
};

struct io_notif_data {
	struct file *file;
	struct ubuf_info uarg;
	struct io_notif_data *next;
	struct io_notif_data *head;
	unsigned int account_pages;
	bool zc_report;
	bool zc_used;
	bool zc_copied;
};

struct io_open {
	struct file *file;
	int dfd;
	u32 file_slot;
	struct filename *filename;
	struct open_how how;
	long unsigned int nofile;
};

struct io_uring_cqe {
	__u64 user_data;
	__s32 res;
	__u32 flags;
	__u64 big_cqe[0];
};

struct io_overflow_cqe {
	struct list_head list;
	struct io_uring_cqe cqe;
};

struct io_pagetable {
	struct rw_semaphore domains_rwsem;
	struct xarray domains;
	struct xarray access_list;
	unsigned int next_domain_id;
	struct rw_semaphore iova_rwsem;
	struct rb_root_cached area_itree;
	struct rb_root_cached allowed_itree;
	struct rb_root_cached reserved_itree;
	u8 disable_large_pages;
	long unsigned int iova_alignment;
};

struct io_pgtable_init_fns {
	struct io_pgtable * (*alloc)(struct io_pgtable_cfg *, void *);
	void (*free)(struct io_pgtable *);
	u32 caps;
};

struct io_poll_table {
	struct poll_table_struct pt;
	struct io_kiocb *req;
	int nr_entries;
	int error;
	bool owning;
	__poll_t result_mask;
};

struct io_poll_update {
	struct file *file;
	u64 old_user_data;
	u64 new_user_data;
	__poll_t events;
	bool update_events;
	bool update_user_data;
};

struct io_provide_buf {
	struct file *file;
	__u64 addr;
	__u32 len;
	__u32 bgid;
	__u32 nbufs;
	__u16 bid;
};

struct io_uring_recvmsg_out {
	__u32 namelen;
	__u32 controllen;
	__u32 payloadlen;
	__u32 flags;
};

struct io_recvmsg_multishot_hdr {
	struct io_uring_recvmsg_out msg;
	struct __kernel_sockaddr_storage addr;
};

struct io_rename {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_restriction {
	long unsigned int register_op[1];
	long unsigned int sqe_op[1];
	u8 sqe_flags_allowed;
	u8 sqe_flags_required;
	bool registered;
};

struct io_wq_work_list {
	struct io_wq_work_node *first;
	struct io_wq_work_node *last;
};

struct io_submit_link {
	struct io_kiocb *head;
	struct io_kiocb *last;
};

struct io_submit_state {
	struct io_wq_work_node free_list;
	struct io_wq_work_list compl_reqs;
	struct io_submit_link link;
	bool plug_started;
	bool need_plug;
	bool cq_flush;
	short unsigned int submit_nr;
	struct blk_plug plug;
};

struct io_rings;

struct io_sq_data;

struct io_wq_hash;

struct io_ring_ctx {
	struct {
		unsigned int flags;
		unsigned int drain_next: 1;
		unsigned int restricted: 1;
		unsigned int off_timeout_used: 1;
		unsigned int drain_active: 1;
		unsigned int has_evfd: 1;
		unsigned int task_complete: 1;
		unsigned int lockless_cq: 1;
		unsigned int syscall_iopoll: 1;
		unsigned int poll_activated: 1;
		unsigned int drain_disabled: 1;
		unsigned int compat: 1;
		unsigned int iowq_limits_set: 1;
		struct task_struct *submitter_task;
		struct io_rings *rings;
		struct percpu_ref refs;
		clockid_t clockid;
		enum tk_offsets clock_offset;
		enum task_work_notify_mode notify_method;
		unsigned int sq_thread_idle;
		long: 64;
	};
	struct {
		struct mutex uring_lock;
		u32 *sq_array;
		struct io_uring_sqe *sq_sqes;
		unsigned int cached_sq_head;
		unsigned int sq_entries;
		atomic_t cancel_seq;
		bool poll_multi_queue;
		struct io_wq_work_list iopoll_list;
		struct io_file_table file_table;
		struct io_rsrc_data buf_table;
		struct io_submit_state submit_state;
		struct xarray io_bl_xa;
		struct io_hash_table cancel_table;
		struct io_alloc_cache apoll_cache;
		struct io_alloc_cache netmsg_cache;
		struct io_alloc_cache rw_cache;
		struct io_alloc_cache uring_cache;
		struct hlist_head cancelable_uring_cmd;
		u64 hybrid_poll_time;
	};
	struct {
		struct io_uring_cqe *cqe_cached;
		struct io_uring_cqe *cqe_sentinel;
		unsigned int cached_cq_tail;
		unsigned int cq_entries;
		struct io_ev_fd *io_ev_fd;
		unsigned int cq_extra;
		void *cq_wait_arg;
		size_t cq_wait_size;
		long: 64;
	};
	struct {
		struct llist_head work_llist;
		struct llist_head retry_llist;
		long unsigned int check_cq;
		atomic_t cq_wait_nr;
		atomic_t cq_timeouts;
		struct wait_queue_head cq_wait;
		long: 64;
	};
	struct {
		raw_spinlock_t timeout_lock;
		struct list_head timeout_list;
		struct list_head ltimeout_list;
		unsigned int cq_last_tm_flush;
		long: 64;
		long: 64;
	};
	spinlock_t completion_lock;
	struct list_head io_buffers_comp;
	struct list_head cq_overflow_list;
	struct hlist_head waitid_list;
	struct hlist_head futex_list;
	struct io_alloc_cache futex_cache;
	const struct cred *sq_creds;
	struct io_sq_data *sq_data;
	struct wait_queue_head sqo_sq_wait;
	struct list_head sqd_list;
	unsigned int file_alloc_start;
	unsigned int file_alloc_end;
	struct list_head io_buffers_cache;
	struct wait_queue_head poll_wq;
	struct io_restriction restrictions;
	u32 pers_next;
	struct xarray personalities;
	struct io_wq_hash *hash_map;
	struct user_struct *user;
	struct mm_struct *mm_account;
	struct llist_head fallback_llist;
	struct delayed_work fallback_work;
	struct work_struct exit_work;
	struct list_head tctx_list;
	struct completion ref_comp;
	u32 iowq_limits[2];
	struct callback_head poll_wq_task_work;
	struct list_head defer_list;
	struct io_alloc_cache msg_cache;
	spinlock_t msg_lock;
	struct list_head napi_list;
	spinlock_t napi_lock;
	ktime_t napi_busy_poll_dt;
	bool napi_prefer_busy_poll;
	u8 napi_track_mode;
	struct hlist_head napi_ht[16];
	unsigned int evfd_last_cq_tail;
	struct mutex mmap_lock;
	struct io_mapped_region sq_region;
	struct io_mapped_region ring_region;
	struct io_mapped_region param_region;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_ring_ctx_rings {
	struct io_rings *rings;
	struct io_uring_sqe *sq_sqes;
	struct io_mapped_region sq_region;
	struct io_mapped_region ring_region;
};

struct io_uring {
	u32 head;
	u32 tail;
};

struct io_rings {
	struct io_uring sq;
	struct io_uring cq;
	u32 sq_ring_mask;
	u32 cq_ring_mask;
	u32 sq_ring_entries;
	u32 cq_ring_entries;
	u32 sq_dropped;
	atomic_t sq_flags;
	u32 cq_flags;
	u32 cq_overflow;
	long: 64;
	long: 64;
	struct io_uring_cqe cqes[0];
};

struct io_rsrc_node {
	unsigned char type;
	int refs;
	u64 tag;
	union {
		long unsigned int file_ptr;
		struct io_mapped_ubuf *buf;
	};
};

struct io_rsrc_update {
	struct file *file;
	u64 arg;
	u32 nr_args;
	u32 offset;
};

struct io_rw {
	struct kiocb kiocb;
	u64 addr;
	u32 len;
	rwf_t flags;
};

struct io_shutdown {
	struct file *file;
	int how;
};

struct io_socket {
	struct file *file;
	int domain;
	int type;
	int protocol;
	int flags;
	u32 file_slot;
	long unsigned int nofile;
};

struct io_splice {
	struct file *file_out;
	loff_t off_out;
	loff_t off_in;
	u64 len;
	int splice_fd_in;
	unsigned int flags;
	struct io_rsrc_node *rsrc_node;
};

struct io_sq_data {
	refcount_t refs;
	atomic_t park_pending;
	struct mutex lock;
	struct list_head ctx_list;
	struct task_struct *thread;
	struct wait_queue_head wait;
	unsigned int sq_thread_idle;
	int sq_cpu;
	pid_t task_pid;
	pid_t task_tgid;
	u64 work_time;
	long unsigned int state;
	struct completion exited;
};

struct io_sqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 flags;
	__u32 dropped;
	__u32 array;
	__u32 resv1;
	__u64 user_addr;
};

struct user_msghdr;

struct io_sr_msg {
	struct file *file;
	union {
		struct compat_msghdr *umsg_compat;
		struct user_msghdr *umsg;
		void *buf;
	};
	int len;
	unsigned int done_io;
	unsigned int msg_flags;
	unsigned int nr_multishot_loops;
	u16 flags;
	u16 buf_group;
	u16 buf_index;
	bool retry;
	bool imported;
	void *msg_control;
	struct io_kiocb *notif;
};

struct statx;

struct io_statx {
	struct file *file;
	int dfd;
	unsigned int mask;
	unsigned int flags;
	struct filename *filename;
	struct statx *buffer;
};

struct io_sync {
	struct file *file;
	loff_t len;
	loff_t off;
	int flags;
	int mode;
};

struct io_task_cancel {
	struct io_uring_task *tctx;
	bool all;
};

struct io_tctx_exit {
	struct callback_head task_work;
	struct completion completion;
	struct io_ring_ctx *ctx;
};

struct io_tctx_node {
	struct list_head ctx_node;
	struct task_struct *task;
	struct io_ring_ctx *ctx;
};

struct io_timeout {
	struct file *file;
	u32 off;
	u32 target_seq;
	u32 repeats;
	struct list_head list;
	struct io_kiocb *head;
	struct io_kiocb *prev;
};

struct io_timeout_data {
	struct io_kiocb *req;
	struct hrtimer timer;
	struct timespec64 ts;
	enum hrtimer_mode mode;
	u32 flags;
};

struct io_timeout_rem {
	struct file *file;
	u64 addr;
	struct timespec64 ts;
	u32 flags;
	bool ltimeout;
};

struct io_tlb_area {
	long unsigned int used;
	unsigned int index;
	spinlock_t lock;
};

struct io_tlb_slot;

struct io_tlb_pool {
	phys_addr_t start;
	phys_addr_t end;
	void *vaddr;
	long unsigned int nslabs;
	bool late_alloc;
	unsigned int nareas;
	unsigned int area_nslabs;
	struct io_tlb_area *areas;
	struct io_tlb_slot *slots;
};

struct io_tlb_mem {
	struct io_tlb_pool defpool;
	long unsigned int nslabs;
	struct dentry *debugfs;
	bool force_bounce;
	bool for_alloc;
	atomic_long_t total_used;
	atomic_long_t used_hiwater;
	atomic_long_t transient_nslabs;
};

struct io_tlb_slot {
	phys_addr_t orig_addr;
	size_t alloc_size;
	short unsigned int list;
	short unsigned int pad_slots;
};

struct io_tw_state {};

struct io_unlink {
	struct file *file;
	int dfd;
	int flags;
	struct filename *filename;
};

struct io_uring_attr_pi {
	__u16 flags;
	__u16 app_tag;
	__u32 len;
	__u64 addr;
	__u64 seed;
	__u64 rsvd;
};

struct io_uring_buf {
	__u64 addr;
	__u32 len;
	__u16 bid;
	__u16 resv;
};

struct io_uring_buf_reg {
	__u64 ring_addr;
	__u32 ring_entries;
	__u16 bgid;
	__u16 flags;
	__u64 resv[3];
};

struct io_uring_buf_ring {
	union {
		struct {
			__u64 resv1;
			__u32 resv2;
			__u16 resv3;
			__u16 tail;
		};
		struct {
			struct {} __empty_bufs;
			struct io_uring_buf bufs[0];
		};
	};
};

struct io_uring_buf_status {
	__u32 buf_group;
	__u32 head;
	__u32 resv[8];
};

struct io_uring_clock_register {
	__u32 clockid;
	__u32 __resv[3];
};

struct io_uring_clone_buffers {
	__u32 src_fd;
	__u32 flags;
	__u32 src_off;
	__u32 dst_off;
	__u32 nr;
	__u32 pad[3];
};

struct io_uring_cmd {
	struct file *file;
	const struct io_uring_sqe *sqe;
	void (*task_work_cb)(struct io_uring_cmd *, unsigned int);
	u32 cmd_op;
	u32 flags;
	u8 pdu[32];
};

struct io_uring_sqe {
	__u8 opcode;
	__u8 flags;
	__u16 ioprio;
	__s32 fd;
	union {
		__u64 off;
		__u64 addr2;
		struct {
			__u32 cmd_op;
			__u32 __pad1;
		};
	};
	union {
		__u64 addr;
		__u64 splice_off_in;
		struct {
			__u32 level;
			__u32 optname;
		};
	};
	__u32 len;
	union {
		__kernel_rwf_t rw_flags;
		__u32 fsync_flags;
		__u16 poll_events;
		__u32 poll32_events;
		__u32 sync_range_flags;
		__u32 msg_flags;
		__u32 timeout_flags;
		__u32 accept_flags;
		__u32 cancel_flags;
		__u32 open_flags;
		__u32 statx_flags;
		__u32 fadvise_advice;
		__u32 splice_flags;
		__u32 rename_flags;
		__u32 unlink_flags;
		__u32 hardlink_flags;
		__u32 xattr_flags;
		__u32 msg_ring_flags;
		__u32 uring_cmd_flags;
		__u32 waitid_flags;
		__u32 futex_flags;
		__u32 install_fd_flags;
		__u32 nop_flags;
	};
	__u64 user_data;
	union {
		__u16 buf_index;
		__u16 buf_group;
	};
	__u16 personality;
	union {
		__s32 splice_fd_in;
		__u32 file_index;
		__u32 optlen;
		struct {
			__u16 addr_len;
			__u16 __pad3[1];
		};
	};
	union {
		struct {
			__u64 addr3;
			__u64 __pad2[1];
		};
		struct {
			__u64 attr_ptr;
			__u64 attr_type_mask;
		};
		__u64 optval;
		__u8 cmd[0];
	};
};

struct io_uring_cmd_data {
	void *op_data;
	struct io_uring_sqe sqes[2];
};

struct io_uring_file_index_range {
	__u32 off;
	__u32 len;
	__u64 resv;
};

struct io_uring_getevents_arg {
	__u64 sigmask;
	__u32 sigmask_sz;
	__u32 min_wait_usec;
	__u64 ts;
};

struct io_uring_mem_region_reg {
	__u64 region_uptr;
	__u64 flags;
	__u64 __resv[2];
};

struct io_uring_napi {
	__u32 busy_poll_to;
	__u8 prefer_busy_poll;
	__u8 opcode;
	__u8 pad[2];
	__u32 op_param;
	__u32 resv;
};

struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u32 sq_thread_cpu;
	__u32 sq_thread_idle;
	__u32 features;
	__u32 wq_fd;
	__u32 resv[3];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

struct io_uring_probe_op {
	__u8 op;
	__u8 resv;
	__u16 flags;
	__u32 resv2;
};

struct io_uring_probe {
	__u8 last_op;
	__u8 ops_len;
	__u16 resv;
	__u32 resv2[3];
	struct io_uring_probe_op ops[0];
};

struct io_uring_reg_wait {
	struct __kernel_timespec ts;
	__u32 min_wait_usec;
	__u32 flags;
	__u64 sigmask;
	__u32 sigmask_sz;
	__u32 pad[3];
	__u64 pad2[2];
};

struct io_uring_region_desc {
	__u64 user_addr;
	__u64 size;
	__u32 flags;
	__u32 id;
	__u64 mmap_offset;
	__u64 __resv[4];
};

struct io_uring_restriction {
	__u16 opcode;
	union {
		__u8 register_op;
		__u8 sqe_op;
		__u8 sqe_flags;
	};
	__u8 resv;
	__u32 resv2[3];
};

struct io_uring_rsrc_register {
	__u32 nr;
	__u32 flags;
	__u64 resv2;
	__u64 data;
	__u64 tags;
};

struct io_uring_rsrc_update {
	__u32 offset;
	__u32 resv;
	__u64 data;
};

struct io_uring_rsrc_update2 {
	__u32 offset;
	__u32 resv;
	__u64 data;
	__u64 tags;
	__u32 nr;
	__u32 resv2;
};

struct io_uring_sync_cancel_reg {
	__u64 addr;
	__s32 fd;
	__u32 flags;
	struct __kernel_timespec timeout;
	__u8 opcode;
	__u8 pad[7];
	__u64 pad2[3];
};

struct io_wq;

struct io_uring_task {
	int cached_refs;
	const struct io_ring_ctx *last;
	struct task_struct *task;
	struct io_wq *io_wq;
	struct file *registered_rings[16];
	struct xarray xa;
	struct wait_queue_head wait;
	atomic_t in_cancel;
	atomic_t inflight_tracked;
	struct percpu_counter inflight;
	long: 64;
	struct {
		struct llist_head task_list;
		struct callback_head task_work;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
};

struct io_wait_queue {
	struct wait_queue_entry wq;
	struct io_ring_ctx *ctx;
	unsigned int cq_tail;
	unsigned int cq_min_tail;
	unsigned int nr_timeouts;
	int hit_timeout;
	ktime_t min_timeout;
	ktime_t timeout;
	struct hrtimer t;
	ktime_t napi_busy_poll_dt;
	bool napi_prefer_busy_poll;
};

struct waitid_info {
	pid_t pid;
	uid_t uid;
	int status;
	int cause;
};

struct io_waitid {
	struct file *file;
	int which;
	pid_t upid;
	int options;
	atomic_t refs;
	struct wait_queue_head *head;
	struct siginfo *infop;
	struct waitid_info info;
};

struct rusage;

struct wait_opts {
	enum pid_type wo_type;
	int wo_flags;
	struct pid *wo_pid;
	struct waitid_info *wo_info;
	int wo_stat;
	struct rusage *wo_rusage;
	wait_queue_entry_t child_wait;
	int notask_error;
};

struct io_waitid_async {
	struct io_kiocb *req;
	struct wait_opts wo;
};

struct io_window_t {
	u_int InUse;
	u_int Config;
	struct resource *res;
};

typedef struct io_window_t io_window_t;

struct io_worker {
	refcount_t ref;
	int create_index;
	long unsigned int flags;
	struct hlist_nulls_node nulls_node;
	struct list_head all_list;
	struct task_struct *task;
	struct io_wq *wq;
	struct io_wq_work *cur_work;
	raw_spinlock_t lock;
	struct completion ref_done;
	long unsigned int create_state;
	struct callback_head create_work;
	int init_retries;
	union {
		struct callback_head rcu;
		struct delayed_work work;
	};
};

typedef struct io_wq_work *free_work_fn(struct io_wq_work *);

typedef void io_wq_work_fn(struct io_wq_work *);

struct io_wq_acct {
	unsigned int nr_workers;
	unsigned int max_workers;
	int index;
	atomic_t nr_running;
	raw_spinlock_t lock;
	struct io_wq_work_list work_list;
	long unsigned int flags;
};

struct io_wq {
	long unsigned int state;
	free_work_fn *free_work;
	io_wq_work_fn *do_work;
	struct io_wq_hash *hash;
	atomic_t worker_refs;
	struct completion worker_done;
	struct hlist_node cpuhp_node;
	struct task_struct *task;
	struct io_wq_acct acct[2];
	raw_spinlock_t lock;
	struct hlist_nulls_head free_list;
	struct list_head all_list;
	struct wait_queue_entry wait;
	struct io_wq_work *hash_tail[64];
	cpumask_var_t cpu_mask;
};

struct io_wq_data {
	struct io_wq_hash *hash;
	struct task_struct *task;
	io_wq_work_fn *do_work;
	free_work_fn *free_work;
};

struct io_wq_hash {
	refcount_t refs;
	long unsigned int map;
	struct wait_queue_head wait;
};

struct xattr_name;

struct kernel_xattr_ctx {
	union {
		const void *cvalue;
		void *value;
	};
	void *kvalue;
	size_t size;
	struct xattr_name *kname;
	unsigned int flags;
};

struct io_xattr {
	struct file *file;
	struct kernel_xattr_ctx ctx;
	struct filename *filename;
};

struct ioam6_hdr {
	__u8 opt_type;
	__u8 opt_len;
	char: 8;
	__u8 type;
};

struct ioam6_lwt_freq {
	u32 k;
	u32 n;
};

struct ipv6_opt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
};

struct ioam6_trace_hdr {
	__be16 namespace_id;
	char: 2;
	__u8 overflow: 1;
	__u8 nodelen: 5;
	__u8 remlen: 7;
	union {
		__be32 type_be32;
		struct {
			__u32 bit7: 1;
			__u32 bit6: 1;
			__u32 bit5: 1;
			__u32 bit4: 1;
			__u32 bit3: 1;
			__u32 bit2: 1;
			__u32 bit1: 1;
			__u32 bit0: 1;
			__u32 bit15: 1;
			__u32 bit14: 1;
			__u32 bit13: 1;
			__u32 bit12: 1;
			__u32 bit11: 1;
			__u32 bit10: 1;
			__u32 bit9: 1;
			__u32 bit8: 1;
			__u32 bit23: 1;
			__u32 bit22: 1;
			__u32 bit21: 1;
			__u32 bit20: 1;
			__u32 bit19: 1;
			__u32 bit18: 1;
			__u32 bit17: 1;
			__u32 bit16: 1;
		} type;
	};
	__u8 data[0];
};

struct ioam6_lwt_encap {
	struct ipv6_opt_hdr eh;
	u8 pad[2];
	struct ioam6_hdr ioamh;
	struct ioam6_trace_hdr traceh;
};

struct ioam6_lwt {
	struct dst_cache cache;
	struct ioam6_lwt_freq freq;
	atomic_t pkt_cnt;
	u8 mode;
	bool has_tunsrc;
	struct in6_addr tunsrc;
	struct in6_addr tundst;
	struct ioam6_lwt_encap tuninfo;
};

struct ioam6_schema;

struct ioam6_namespace {
	struct rhash_head head;
	struct callback_head rcu;
	struct ioam6_schema *schema;
	__be16 id;
	__be32 data;
	__be64 data_wide;
};

struct ioam6_pernet_data {
	struct mutex lock;
	struct rhashtable namespaces;
	struct rhashtable schemas;
};

struct ioam6_schema {
	struct rhash_head head;
	struct callback_head rcu;
	struct ioam6_namespace *ns;
	u32 id;
	int len;
	__be32 hdr;
	u8 data[0];
};

struct mpc_ioapic {
	unsigned char type;
	unsigned char apicid;
	unsigned char apicver;
	unsigned char flags;
	unsigned int apicaddr;
};

struct mp_ioapic_gsi {
	u32 gsi_base;
	u32 gsi_end;
};

struct irq_domain_ops;

struct ioapic_domain_cfg {
	enum ioapic_domain_type type;
	const struct irq_domain_ops *ops;
	struct device_node *dev;
};

struct ioapic {
	int nr_registers;
	struct IO_APIC_route_entry *saved_registers;
	struct mpc_ioapic mp_config;
	struct mp_ioapic_gsi gsi_config;
	struct ioapic_domain_cfg irqdomain_cfg;
	struct irq_domain *irqdomain;
	struct resource *iomem_res;
};

struct ioapic_alloc_info {
	int pin;
	int node;
	u32 is_level: 1;
	u32 active_low: 1;
	u32 valid: 1;
};

struct ioc_params {
	u32 qos[6];
	u64 i_lcoefs[6];
	u64 lcoefs[6];
	u32 too_fast_vrate_pct;
	u32 too_slow_vrate_pct;
};

struct ioc_margins {
	s64 min;
	s64 low;
	s64 target;
};

struct ioc_pcpu_stat;

struct ioc {
	struct rq_qos rqos;
	bool enabled;
	struct ioc_params params;
	struct ioc_margins margins;
	u32 period_us;
	u32 timer_slack_ns;
	u64 vrate_min;
	u64 vrate_max;
	spinlock_t lock;
	struct timer_list timer;
	struct list_head active_iocgs;
	struct ioc_pcpu_stat *pcpu_stat;
	enum ioc_running running;
	atomic64_t vtime_rate;
	u64 vtime_base_rate;
	s64 vtime_err;
	seqcount_spinlock_t period_seqcount;
	u64 period_at;
	u64 period_at_vtime;
	atomic64_t cur_period;
	int busy_level;
	bool weights_updated;
	atomic_t hweight_gen;
	u64 dfgv_period_at;
	u64 dfgv_period_rem;
	u64 dfgv_usage_us_sum;
	u64 autop_too_fast_at;
	u64 autop_too_slow_at;
	int autop_idx;
	bool user_qos_params: 1;
	bool user_cost_model: 1;
};

struct ioc_cgrp {
	struct blkcg_policy_data cpd;
	unsigned int dfl_weight;
};

struct iocg_stat {
	u64 usage_us;
	u64 wait_us;
	u64 indebt_us;
	u64 indelay_us;
};

struct iocg_pcpu_stat;

struct ioc_gq {
	struct blkg_policy_data pd;
	struct ioc *ioc;
	u32 cfg_weight;
	u32 weight;
	u32 active;
	u32 inuse;
	u32 last_inuse;
	s64 saved_margin;
	sector_t cursor;
	atomic64_t vtime;
	atomic64_t done_vtime;
	u64 abs_vdebt;
	u64 delay;
	u64 delay_at;
	atomic64_t active_period;
	struct list_head active_list;
	u64 child_active_sum;
	u64 child_inuse_sum;
	u64 child_adjusted_sum;
	int hweight_gen;
	u32 hweight_active;
	u32 hweight_inuse;
	u32 hweight_donating;
	u32 hweight_after_donation;
	struct list_head walk_list;
	struct list_head surplus_list;
	struct wait_queue_head waitq;
	struct hrtimer waitq_timer;
	u64 activated_at;
	struct iocg_pcpu_stat *pcpu_stat;
	struct iocg_stat stat;
	struct iocg_stat last_stat;
	u64 last_stat_abs_vusage;
	u64 usage_delta_us;
	u64 wait_since;
	u64 indebt_since;
	u64 indelay_since;
	int level;
	struct ioc_gq *ancestors[0];
};

struct ioc_missed {
	local_t nr_met;
	local_t nr_missed;
	u32 last_met;
	u32 last_missed;
};

struct ioc_now {
	u64 now_ns;
	u64 now;
	u64 vnow;
};

struct ioc_pcpu_stat {
	struct ioc_missed missed[2];
	local64_t rq_wait_ns;
	u64 last_rq_wait_ns;
};

struct iocb {
	__u64 aio_data;
	__u32 aio_key;
	__kernel_rwf_t aio_rw_flags;
	__u16 aio_lio_opcode;
	__s16 aio_reqprio;
	__u32 aio_fildes;
	__u64 aio_buf;
	__u64 aio_nbytes;
	__s64 aio_offset;
	__u64 aio_reserved2;
	__u32 aio_flags;
	__u32 aio_resfd;
};

struct iocg_pcpu_stat {
	local64_t abs_vusage;
};

struct iocg_wait {
	struct wait_queue_entry wait;
	struct bio *bio;
	u64 abs_cost;
	bool committed;
};

struct iocg_wake_ctx {
	struct ioc_gq *iocg;
	u32 hw_inuse;
	s64 vbudget;
};

struct ioctl_sick_map {
	unsigned int sick_mask;
	unsigned int ioctl_mask;
};

struct percentile_stats {
	u64 total;
	u64 missed;
};

struct latency_stat {
	union {
		struct percentile_stats ps;
		struct blk_rq_stat rqs;
	};
};

struct rq_wait {
	wait_queue_head_t wait;
	atomic_t inflight;
};

struct iolatency_grp {
	struct blkg_policy_data pd;
	struct latency_stat *stats;
	struct latency_stat cur_stat;
	struct blk_iolatency *blkiolat;
	unsigned int max_depth;
	struct rq_wait rq_wait;
	atomic64_t window_start;
	atomic_t scale_cookie;
	u64 min_lat_nsec;
	u64 cur_win_nsec;
	u64 lat_avg;
	u64 nr_samples;
	bool ssd;
	struct child_latency_info child_lat;
};

struct iomap_folio_ops;

struct iomap {
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	struct block_device *bdev;
	struct dax_device *dax_dev;
	void *inline_data;
	void *private;
	const struct iomap_folio_ops *folio_ops;
	u64 validity_cookie;
};

struct iomap_dio_ops;

struct iomap_dio {
	struct kiocb *iocb;
	const struct iomap_dio_ops *dops;
	loff_t i_size;
	loff_t size;
	atomic_t ref;
	unsigned int flags;
	int error;
	size_t done_before;
	bool wait_for_completion;
	union {
		struct {
			struct iov_iter *iter;
			struct task_struct *waiter;
		} submit;
		struct {
			struct work_struct work;
		} aio;
	};
};

struct iomap_iter;

struct iomap_dio_ops {
	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
	void (*submit_io)(const struct iomap_iter *, struct bio *, loff_t);
	struct bio_set *bio_set;
};

struct iomap_folio_ops {
	struct folio * (*get_folio)(struct iomap_iter *, loff_t, unsigned int);
	void (*put_folio)(struct inode *, loff_t, unsigned int, struct folio *);
	bool (*iomap_valid)(struct inode *, const struct iomap *);
};

struct iomap_folio_state {
	spinlock_t state_lock;
	unsigned int read_bytes_pending;
	atomic_t write_bytes_pending;
	long unsigned int state[0];
};

struct iomap_ioend {
	struct list_head io_list;
	u16 io_type;
	u16 io_flags;
	struct inode *io_inode;
	size_t io_size;
	loff_t io_offset;
	sector_t io_sector;
	struct bio io_bio;
};

struct iomap_iter {
	struct inode *inode;
	loff_t pos;
	u64 len;
	s64 processed;
	unsigned int flags;
	struct iomap iomap;
	struct iomap srcmap;
	void *private;
};

struct iomap_ops {
	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap *, struct iomap *);
	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap *);
};

struct iomap_readpage_ctx {
	struct folio *cur_folio;
	bool cur_folio_in_bio;
	struct bio *bio;
	struct readahead_control *rac;
};

struct iomap_swapfile_info {
	struct iomap iomap;
	struct swap_info_struct *sis;
	uint64_t lowest_ppage;
	uint64_t highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
	struct file *file;
};

struct iomap_writepage_ctx;

struct iomap_writeback_ops {
	int (*map_blocks)(struct iomap_writepage_ctx *, struct inode *, loff_t, unsigned int);
	int (*prepare_ioend)(struct iomap_ioend *, int);
	void (*discard_folio)(struct folio *, loff_t);
};

struct iomap_writepage_ctx {
	struct iomap iomap;
	struct iomap_ioend *ioend;
	const struct iomap_writeback_ops *ops;
	u32 nr_folios;
};

struct iommu_attach_handle {
	struct iommu_domain *domain;
};

struct iommu_cmd {
	u32 data[4];
};

struct iommu_destroy {
	__u32 size;
	__u32 id;
};

struct protection_domain;

struct iommu_dev_data {
	struct mutex mutex;
	spinlock_t dte_lock;
	struct list_head list;
	struct llist_node dev_data_list;
	struct protection_domain *domain;
	struct gcr3_tbl_info gcr3_info;
	struct device *dev;
	u16 devid;
	u32 max_pasids;
	u32 flags;
	int ats_qdep;
	u8 ats_enabled: 1;
	u8 pri_enabled: 1;
	u8 pasid_enabled: 1;
	u8 pri_tlp: 1;
	u8 ppr: 1;
	bool use_vapic;
	bool defer_attach;
	struct ratelimit_state rs;
};

struct iova_bitmap;

struct iommu_dirty_bitmap {
	struct iova_bitmap *bitmap;
	struct iommu_iotlb_gather *gather;
};

struct iommu_dirty_ops {
	int (*set_dirty_tracking)(struct iommu_domain *, bool);
	int (*read_and_clear_dirty)(struct iommu_domain *, long unsigned int, size_t, long unsigned int, struct iommu_dirty_bitmap *);
};

struct iova {
	struct rb_node node;
	long unsigned int pfn_hi;
	long unsigned int pfn_lo;
};

struct iova_rcache;

struct iova_domain {
	spinlock_t iova_rbtree_lock;
	struct rb_root rbroot;
	struct rb_node *cached_node;
	struct rb_node *cached32_node;
	long unsigned int granule;
	long unsigned int start_pfn;
	long unsigned int dma_32bit_pfn;
	long unsigned int max32_alloc_size;
	struct iova anchor;
	struct iova_rcache *rcaches;
	struct hlist_node cpuhp_dead;
};

struct iommu_dma_options {
	enum iommu_dma_queue_type qt;
	size_t fq_size;
	unsigned int fq_timeout;
};

struct iova_fq;

struct iommu_dma_cookie {
	enum iommu_dma_cookie_type type;
	union {
		struct {
			struct iova_domain iovad;
			union {
				struct iova_fq *single_fq;
				struct iova_fq *percpu_fq;
			};
			atomic64_t fq_flush_start_cnt;
			atomic64_t fq_flush_finish_cnt;
			struct timer_list fq_timer;
			atomic_t fq_timer_on;
		};
		dma_addr_t msi_iova;
	};
	struct list_head msi_page_list;
	struct iommu_domain *fq_domain;
	struct iommu_dma_options options;
	struct mutex mutex;
};

struct iommu_dma_msi_page {
	struct list_head list;
	dma_addr_t iova;
	phys_addr_t phys;
};

struct iommu_domain_info {
	struct intel_iommu *iommu;
	unsigned int refcnt;
	u16 did;
};

struct iommu_user_data_array;

struct iommu_domain_ops {
	int (*attach_dev)(struct iommu_domain *, struct device *);
	int (*set_dev_pasid)(struct iommu_domain *, struct device *, ioasid_t, struct iommu_domain *);
	int (*map_pages)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, size_t, int, gfp_t, size_t *);
	size_t (*unmap_pages)(struct iommu_domain *, long unsigned int, size_t, size_t, struct iommu_iotlb_gather *);
	void (*flush_iotlb_all)(struct iommu_domain *);
	int (*iotlb_sync_map)(struct iommu_domain *, long unsigned int, size_t);
	void (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *);
	int (*cache_invalidate_user)(struct iommu_domain *, struct iommu_user_data_array *);
	phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t);
	bool (*enforce_cache_coherency)(struct iommu_domain *);
	int (*set_pgtable_quirks)(struct iommu_domain *, long unsigned int);
	void (*free)(struct iommu_domain *);
};

struct iommu_fault_page_request {
	u32 flags;
	u32 pasid;
	u32 grpid;
	u32 perm;
	u64 addr;
	u64 private_data[2];
};

struct iommu_fault {
	u32 type;
	struct iommu_fault_page_request prm;
};

struct iommu_fault_alloc {
	__u32 size;
	__u32 flags;
	__u32 out_fault_id;
	__u32 out_fault_fd;
};

struct iommu_fault_param {
	struct mutex lock;
	refcount_t users;
	struct callback_head rcu;
	struct device *dev;
	struct iopf_queue *queue;
	struct list_head queue_list;
	struct list_head partial;
	struct list_head faults;
};

struct iommu_flush_ops {
	void (*tlb_flush_all)(void *);
	void (*tlb_flush_walk)(long unsigned int, size_t, size_t, void *);
	void (*tlb_add_page)(struct iommu_iotlb_gather *, long unsigned int, size_t, void *);
};

struct iommu_fwspec {
	struct fwnode_handle *iommu_fwnode;
	u32 flags;
	unsigned int num_ids;
	u32 ids[0];
};

struct iommu_group {
	struct kobject kobj;
	struct kobject *devices_kobj;
	struct list_head devices;
	struct xarray pasid_array;
	struct mutex mutex;
	void *iommu_data;
	void (*iommu_data_release)(void *);
	char *name;
	int id;
	struct iommu_domain *default_domain;
	struct iommu_domain *blocking_domain;
	struct iommu_domain *domain;
	struct list_head entry;
	unsigned int owner_cnt;
	void *owner;
};

struct iommu_group_attribute {
	struct attribute attr;
	ssize_t (*show)(struct iommu_group *, char *);
	ssize_t (*store)(struct iommu_group *, const char *, size_t);
};

struct iommu_hw_info {
	__u32 size;
	__u32 flags;
	__u32 dev_id;
	__u32 data_len;
	__u64 data_uptr;
	__u32 out_data_type;
	__u32 __reserved;
	__u64 out_capabilities;
};

struct iommu_hw_info_vtd {
	__u32 flags;
	__u32 __reserved;
	__u64 cap_reg;
	__u64 ecap_reg;
};

struct iommu_hwpt_alloc {
	__u32 size;
	__u32 flags;
	__u32 dev_id;
	__u32 pt_id;
	__u32 out_hwpt_id;
	__u32 __reserved;
	__u32 data_type;
	__u32 data_len;
	__u64 data_uptr;
	__u32 fault_id;
	__u32 __reserved2;
};

struct iommu_hwpt_get_dirty_bitmap {
	__u32 size;
	__u32 hwpt_id;
	__u32 flags;
	__u32 __reserved;
	__u64 iova;
	__u64 length;
	__u64 page_size;
	__u64 data;
};

struct iommu_hwpt_invalidate {
	__u32 size;
	__u32 hwpt_id;
	__u64 data_uptr;
	__u32 data_type;
	__u32 entry_len;
	__u32 entry_num;
	__u32 __reserved;
};

struct iommu_hwpt_page_response {
	__u32 cookie;
	__u32 code;
};

struct iommu_hwpt_pgfault {
	__u32 flags;
	__u32 dev_id;
	__u32 pasid;
	__u32 grpid;
	__u32 perm;
	__u32 __reserved;
	__u64 addr;
	__u32 length;
	__u32 cookie;
};

struct iommu_hwpt_set_dirty_tracking {
	__u32 size;
	__u32 flags;
	__u32 hwpt_id;
	__u32 __reserved;
};

struct iommu_hwpt_vtd_s1_invalidate {
	__u64 addr;
	__u64 npages;
	__u32 flags;
	__u32 __reserved;
};

struct iommu_ioas_alloc {
	__u32 size;
	__u32 flags;
	__u32 out_ioas_id;
};

struct iommu_ioas_allow_iovas {
	__u32 size;
	__u32 ioas_id;
	__u32 num_iovas;
	__u32 __reserved;
	__u64 allowed_iovas;
};

struct iommu_ioas_change_process {
	__u32 size;
	__u32 __reserved;
};

struct iommu_ioas_copy {
	__u32 size;
	__u32 flags;
	__u32 dst_ioas_id;
	__u32 src_ioas_id;
	__u64 length;
	__u64 dst_iova;
	__u64 src_iova;
};

struct iommu_ioas_iova_ranges {
	__u32 size;
	__u32 ioas_id;
	__u32 num_iovas;
	__u32 __reserved;
	__u64 allowed_iovas;
	__u64 out_iova_alignment;
};

struct iommu_ioas_map {
	__u32 size;
	__u32 flags;
	__u32 ioas_id;
	__u32 __reserved;
	__u64 user_va;
	__u64 length;
	__u64 iova;
};

struct iommu_ioas_map_file {
	__u32 size;
	__u32 flags;
	__u32 ioas_id;
	__s32 fd;
	__u64 start;
	__u64 length;
	__u64 iova;
};

struct iommu_ioas_unmap {
	__u32 size;
	__u32 ioas_id;
	__u64 iova;
	__u64 length;
};

struct iommu_iotlb_gather {
	long unsigned int start;
	long unsigned int end;
	size_t pgsize;
	struct list_head freelist;
	bool queued;
};

struct iommu_iova_range {
	__u64 start;
	__u64 last;
};

struct iommu_mm_data {
	u32 pasid;
	struct list_head sva_domains;
};

struct iommu_user_data;

struct of_phandle_args;

struct iopf_fault;

struct iommu_page_response;

struct iommufd_viommu;

struct iommufd_ctx;

struct iommu_ops {
	bool (*capable)(struct device *, enum iommu_cap);
	void * (*hw_info)(struct device *, u32 *, u32 *);
	struct iommu_domain * (*domain_alloc)(unsigned int);
	struct iommu_domain * (*domain_alloc_paging_flags)(struct device *, u32, const struct iommu_user_data *);
	struct iommu_domain * (*domain_alloc_paging)(struct device *);
	struct iommu_domain * (*domain_alloc_sva)(struct device *, struct mm_struct *);
	struct iommu_domain * (*domain_alloc_nested)(struct device *, struct iommu_domain *, u32, const struct iommu_user_data *);
	struct iommu_device * (*probe_device)(struct device *);
	void (*release_device)(struct device *);
	void (*probe_finalize)(struct device *);
	struct iommu_group * (*device_group)(struct device *);
	void (*get_resv_regions)(struct device *, struct list_head *);
	int (*of_xlate)(struct device *, const struct of_phandle_args *);
	bool (*is_attach_deferred)(struct device *);
	int (*dev_enable_feat)(struct device *, enum iommu_dev_features);
	int (*dev_disable_feat)(struct device *, enum iommu_dev_features);
	void (*page_response)(struct device *, struct iopf_fault *, struct iommu_page_response *);
	int (*def_domain_type)(struct device *);
	struct iommufd_viommu * (*viommu_alloc)(struct device *, struct iommu_domain *, struct iommufd_ctx *, unsigned int);
	const struct iommu_domain_ops *default_domain_ops;
	long unsigned int pgsize_bitmap;
	struct module *owner;
	struct iommu_domain *identity_domain;
	struct iommu_domain *blocked_domain;
	struct iommu_domain *release_domain;
	struct iommu_domain *default_domain;
	u8 user_pasid_table: 1;
};

struct iommu_option {
	__u32 size;
	__u32 option_id;
	__u16 op;
	__u16 __reserved;
	__u32 object_id;
	__u64 val64;
};

struct iommu_page_response {
	u32 pasid;
	u32 grpid;
	u32 code;
};

struct iommu_pmu {
	struct intel_iommu *iommu;
	u32 num_cntr;
	u32 num_eg;
	u32 cntr_width;
	u32 cntr_stride;
	u32 filter;
	void *base;
	void *cfg_reg;
	void *cntr_reg;
	void *overflow;
	u64 *evcap;
	u32 **cntr_evcap;
	struct pmu pmu;
	long unsigned int used_mask[1];
	struct perf_event *event_list[64];
	unsigned char irq_name[16];
};

struct iommu_resv_region {
	struct list_head list;
	phys_addr_t start;
	size_t length;
	int prot;
	enum iommu_resv_type type;
	void (*free)(struct device *, struct iommu_resv_region *);
};

struct iommu_sva {
	struct iommu_attach_handle handle;
	struct device *dev;
	refcount_t users;
};

struct iommu_user_data {
	unsigned int type;
	void *uptr;
	size_t len;
};

struct iommu_user_data_array {
	unsigned int type;
	void *uptr;
	size_t entry_len;
	u32 entry_num;
};

struct iommu_vdevice_alloc {
	__u32 size;
	__u32 viommu_id;
	__u32 dev_id;
	__u32 out_vdevice_id;
	__u64 virt_id;
};

struct iommu_vfio_ioas {
	__u32 size;
	__u32 ioas_id;
	__u16 op;
	__u16 __reserved;
};

struct iommu_viommu_alloc {
	__u32 size;
	__u32 flags;
	__u32 type;
	__u32 dev_id;
	__u32 hwpt_id;
	__u32 out_viommu_id;
};

struct iommufd_object {
	refcount_t shortterm_users;
	refcount_t users;
	enum iommufd_object_type type;
	unsigned int id;
};

struct iommufd_ioas;

struct iommufd_access_ops;

struct iommufd_access {
	struct iommufd_object obj;
	struct iommufd_ctx *ictx;
	struct iommufd_ioas *ioas;
	struct iommufd_ioas *ioas_unpin;
	struct mutex ioas_lock;
	const struct iommufd_access_ops *ops;
	void *data;
	long unsigned int iova_alignment;
	u32 iopt_access_list_id;
};

struct iommufd_access_ops {
	u8 needs_pin_pages: 1;
	void (*unmap)(void *, long unsigned int, long unsigned int);
};

struct iommufd_device;

struct iommufd_attach_handle {
	struct iommu_attach_handle handle;
	struct iommufd_device *idev;
};

struct iommufd_ctx {
	struct file *file;
	struct xarray objects;
	struct xarray groups;
	wait_queue_head_t destroy_wait;
	struct rw_semaphore ioas_creation_lock;
	u8 account_mode;
	u8 no_iommu_mode;
	struct iommufd_ioas *vfio_ioas;
};

struct iommufd_group;

struct iommufd_device {
	struct iommufd_object obj;
	struct iommufd_ctx *ictx;
	struct iommufd_group *igroup;
	struct list_head group_item;
	struct device *dev;
	bool enforce_cache_coherency;
	struct mutex iopf_lock;
	unsigned int iopf_enabled;
};

struct iommufd_fault {
	struct iommufd_object obj;
	struct iommufd_ctx *ictx;
	struct file *filep;
	spinlock_t lock;
	struct list_head deliver;
	struct mutex mutex;
	struct xarray response;
	struct wait_queue_head wait_queue;
};

struct iommufd_hw_pagetable;

struct iommufd_group {
	struct kref ref;
	struct mutex lock;
	struct iommufd_ctx *ictx;
	struct iommu_group *group;
	struct iommufd_hw_pagetable *hwpt;
	struct list_head device_list;
	phys_addr_t sw_msi_start;
};

struct iommufd_hw_pagetable {
	struct iommufd_object obj;
	struct iommu_domain *domain;
	struct iommufd_fault *fault;
};

struct iommufd_hwpt_paging;

struct iommufd_hwpt_nested {
	struct iommufd_hw_pagetable common;
	struct iommufd_hwpt_paging *parent;
	struct iommufd_viommu *viommu;
};

struct iommufd_hwpt_paging {
	struct iommufd_hw_pagetable common;
	struct iommufd_ioas *ioas;
	bool auto_domain: 1;
	bool enforce_cache_coherency: 1;
	bool msi_cookie: 1;
	bool nest_parent: 1;
	struct list_head hwpt_item;
};

struct iommufd_ioas {
	struct iommufd_object obj;
	struct io_pagetable iopt;
	struct mutex mutex;
	struct list_head hwpt_list;
};

struct iommufd_ucmd;

struct iommufd_ioctl_op {
	unsigned int size;
	unsigned int min_size;
	unsigned int ioctl_num;
	int (*execute)(struct iommufd_ucmd *);
};

struct iommufd_object_ops {
	void (*destroy)(struct iommufd_object *);
	void (*abort)(struct iommufd_object *);
};

struct iommufd_ucmd {
	struct iommufd_ctx *ictx;
	void *ubuffer;
	u32 user_size;
	void *cmd;
};

struct iommufd_vdevice {
	struct iommufd_object obj;
	struct iommufd_ctx *ictx;
	struct iommufd_viommu *viommu;
	struct device *dev;
	u64 id;
};

struct iommufd_viommu_ops;

struct iommufd_viommu {
	struct iommufd_object obj;
	struct iommufd_ctx *ictx;
	struct iommu_device *iommu_dev;
	struct iommufd_hwpt_paging *hwpt;
	const struct iommufd_viommu_ops *ops;
	struct xarray vdevs;
	unsigned int type;
};

struct iommufd_viommu_ops {
	void (*destroy)(struct iommufd_viommu *);
	struct iommu_domain * (*alloc_domain_nested)(struct iommufd_viommu *, u32, const struct iommu_user_data *);
	int (*cache_invalidate)(struct iommufd_viommu *, struct iommu_user_data_array *);
};

struct iopf_fault {
	struct iommu_fault fault;
	struct list_head list;
};

struct iopf_group {
	struct iopf_fault last_fault;
	struct list_head faults;
	size_t fault_count;
	struct list_head pending_node;
	struct work_struct work;
	struct iommu_attach_handle *attach_handle;
	struct iommu_fault_param *fault_param;
	struct list_head node;
	u32 cookie;
};

struct iopf_queue {
	struct workqueue_struct *wq;
	struct list_head devices;
	struct mutex lock;
};

struct ioprio_blkcg {
	struct blkcg_policy_data cpd;
	enum prio_policy prio_policy;
};

struct iopt_allowed {
	struct interval_tree_node node;
};

struct iopt_pages;

struct iopt_area {
	struct interval_tree_node node;
	struct interval_tree_node pages_node;
	struct io_pagetable *iopt;
	struct iopt_pages *pages;
	struct iommu_domain *storage_domain;
	unsigned int page_offset;
	int iommu_prot;
	bool prevent_access: 1;
	unsigned int num_accesses;
};

struct iopt_area_contig_iter {
	long unsigned int cur_iova;
	long unsigned int last_iova;
	struct iopt_area *area;
};

struct iopt_pages {
	struct kref kref;
	struct mutex mutex;
	size_t npages;
	size_t npinned;
	size_t last_npinned;
	struct task_struct *source_task;
	struct mm_struct *source_mm;
	struct user_struct *source_user;
	enum iopt_address_type type;
	union {
		void *uptr;
		struct {
			struct file *file;
			long unsigned int start;
		};
	};
	bool writable: 1;
	u8 account_mode;
	struct xarray pinned_pfns;
	struct rb_root_cached access_itree;
	struct rb_root_cached domains_itree;
};

struct iopt_pages_access {
	struct interval_tree_node node;
	unsigned int users;
};

struct iopt_pages_list {
	struct iopt_pages *pages;
	struct iopt_area *area;
	struct list_head next;
	long unsigned int start_byte;
	long unsigned int length;
};

struct iopt_reserved {
	struct interval_tree_node node;
	void *owner;
};

struct ioremap_desc {
	unsigned int flags;
};

struct iova_bitmap_map {
	long unsigned int iova;
	long unsigned int length;
	long unsigned int pgshift;
	long unsigned int pgoff;
	long unsigned int npages;
	struct page **pages;
};

struct iova_bitmap {
	struct iova_bitmap_map mapped;
	u8 *bitmap;
	long unsigned int mapped_base_index;
	long unsigned int mapped_total_index;
	long unsigned int iova;
	size_t length;
};

struct iova_bitmap_fn_arg {
	long unsigned int flags;
	struct io_pagetable *iopt;
	struct iommu_domain *domain;
	struct iommu_dirty_bitmap *dirty;
};

struct iova_magazine;

struct iova_cpu_rcache {
	spinlock_t lock;
	struct iova_magazine *loaded;
	struct iova_magazine *prev;
};

struct iova_fq_entry {
	long unsigned int iova_pfn;
	long unsigned int pages;
	struct list_head freelist;
	u64 counter;
};

struct iova_fq {
	spinlock_t lock;
	unsigned int head;
	unsigned int tail;
	unsigned int mod_mask;
	struct iova_fq_entry entries[0];
};

struct iova_magazine {
	union {
		long unsigned int size;
		struct iova_magazine *next;
	};
	long unsigned int pfns[127];
};

struct iova_rcache {
	spinlock_t lock;
	unsigned int depot_size;
	struct iova_magazine *depot;
	struct iova_cpu_rcache *cpu_rcaches;
	struct iova_domain *iovad;
	struct delayed_work work;
};

struct ip6_flowlabel {
	struct ip6_flowlabel *next;
	__be32 label;
	atomic_t users;
	struct in6_addr dst;
	struct ipv6_txoptions *opt;
	long unsigned int linger;
	struct callback_head rcu;
	u8 share;
	union {
		struct pid *pid;
		kuid_t uid;
	} owner;
	long unsigned int lastuse;
	long unsigned int expires;
	struct net *fl_net;
};

struct ip6_frag_state {
	u8 *prevhdr;
	unsigned int hlen;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	int hroom;
	int troom;
	__be32 frag_id;
	u8 nexthdr;
};

struct ipv6hdr;

struct ip6_fraglist_iter {
	struct ipv6hdr *tmp_hdr;
	struct sk_buff *frag;
	int offset;
	unsigned int hlen;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_mh {
	__u8 ip6mh_proto;
	__u8 ip6mh_hdrlen;
	__u8 ip6mh_type;
	__u8 ip6mh_reserved;
	__u16 ip6mh_cksum;
	__u8 data[0];
};

struct sockaddr_in6 {
	short unsigned int sin6_family;
	__be16 sin6_port;
	__be32 sin6_flowinfo;
	struct in6_addr sin6_addr;
	__u32 sin6_scope_id;
};

struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;
	__u32 ip6m_mtu;
};

struct ip6_ra_chain {
	struct ip6_ra_chain *next;
	struct sock *sk;
	int sel;
	void (*destructor)(struct sock *);
};

struct ip6_rt_info {
	struct in6_addr daddr;
	struct in6_addr saddr;
	u_int32_t mark;
};

struct ip6_sf_list {
	struct ip6_sf_list *sf_next;
	struct in6_addr sf_addr;
	long unsigned int sf_count[2];
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
	struct callback_head rcu;
};

struct ip6_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	struct in6_addr sl_addr[0];
};

struct ip_tunnel_encap {
	u16 type;
	u16 flags;
	__be16 sport;
	__be16 dport;
};

struct ip6_tnl {
	struct ip6_tnl *next;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct net *net;
	struct __ip6_tnl_parm parms;
	struct flowi fl;
	struct dst_cache dst_cache;
	struct gro_cells gro_cells;
	int err_count;
	long unsigned int err_time;
	__u32 i_seqno;
	atomic_t o_seqno;
	int hlen;
	int tun_hlen;
	int encap_hlen;
	struct ip_tunnel_encap encap;
	int mlink;
};

struct ip6_tnl_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
};

struct ip6_tnl_net {
	struct net_device *fb_tnl_dev;
	struct ip6_tnl *tnls_r_l[32];
	struct ip6_tnl *tnls_wc[1];
	struct ip6_tnl **tnls[2];
	struct ip6_tnl *collect_md_tun;
};

struct ip6_tnl_parm {
	char name[16];
	int link;
	__u8 proto;
	__u8 encap_limit;
	__u8 hop_limit;
	__be32 flowinfo;
	__u32 flags;
	struct in6_addr laddr;
	struct in6_addr raddr;
};

struct ip6_tnl_parm2 {
	char name[16];
	int link;
	__u8 proto;
	__u8 encap_limit;
	__u8 hop_limit;
	__be32 flowinfo;
	__u32 flags;
	struct in6_addr laddr;
	struct in6_addr raddr;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
};

struct ip6addrlbl_entry {
	struct in6_addr prefix;
	int prefixlen;
	int ifindex;
	int addrtype;
	u32 label;
	struct hlist_node list;
	struct callback_head rcu;
};

struct ip6addrlbl_init_table {
	const struct in6_addr *prefix;
	int prefixlen;
	u32 label;
};

struct ip6fl_iter_state {
	struct seq_net_private p;
	struct pid_namespace *pid_ns;
	int bucket;
};

struct ip6gre_net {
	struct ip6_tnl *tunnels[128];
	struct ip6_tnl *collect_md_tun;
	struct ip6_tnl *collect_md_tun_erspan;
	struct net_device *fb_tunnel_dev;
};

struct mr_table;

struct ip6mr_result {
	struct mr_table *mrt;
};

struct ip6rd_flowi {
	struct flowi6 fl6;
	struct in6_addr gateway;
};

struct ip6t_HL_info {
	__u8 mode;
	__u8 hop_limit;
};

struct ip6t_ah {
	__u32 spis[2];
	__u32 hdrlen;
	__u8 hdrres;
	__u8 invflags;
};

struct ip6t_ip6 {
	struct in6_addr src;
	struct in6_addr dst;
	struct in6_addr smsk;
	struct in6_addr dmsk;
	char iniface[16];
	char outiface[16];
	unsigned char iniface_mask[16];
	unsigned char outiface_mask[16];
	__u16 proto;
	__u8 tos;
	__u8 flags;
	__u8 invflags;
};

struct ip6t_entry {
	struct ip6t_ip6 ipv6;
	unsigned int nfcache;
	__u16 target_offset;
	__u16 next_offset;
	unsigned int comefrom;
	struct xt_counters counters;
	unsigned char elems[0];
};

struct ip6t_error {
	struct ip6t_entry entry;
	struct xt_error_target target;
};

struct ip6t_frag {
	__u32 ids[2];
	__u32 hdrlen;
	__u8 flags;
	__u8 invflags;
};

struct ip6t_get_entries {
	char name[32];
	unsigned int size;
	struct ip6t_entry entrytable[0];
};

struct ip6t_getinfo {
	char name[32];
	unsigned int valid_hooks;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_entries;
	unsigned int size;
};

struct ip6t_hl_info {
	__u8 mode;
	__u8 hop_limit;
};

struct ip6t_icmp {
	__u8 type;
	__u8 code[2];
	__u8 invflags;
};

struct ip6t_ipv6header_info {
	__u8 matchflags;
	__u8 invflags;
	__u8 modeflag;
};

struct ip6t_mh {
	__u8 types[2];
	__u8 invflags;
};

struct ip6t_npt_tginfo {
	union nf_inet_addr src_pfx;
	union nf_inet_addr dst_pfx;
	__u8 src_pfx_len;
	__u8 dst_pfx_len;
	__sum16 adjustment;
};

struct ip6t_opts {
	__u32 hdrlen;
	__u8 flags;
	__u8 invflags;
	__u16 opts[16];
	__u8 optsnr;
};

struct ip6t_reject_info {
	__u32 with;
};

struct ip6t_replace {
	char name[32];
	unsigned int valid_hooks;
	unsigned int num_entries;
	unsigned int size;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_counters;
	struct xt_counters *counters;
	struct ip6t_entry entries[0];
};

struct ip6t_rt {
	__u32 rt_type;
	__u32 segsleft[2];
	__u32 hdrlen;
	__u8 flags;
	__u8 invflags;
	struct in6_addr addrs[16];
	__u8 addrnr;
};

struct ip6t_srh {
	__u8 next_hdr;
	__u8 hdr_len;
	__u8 segs_left;
	__u8 last_entry;
	__u16 tag;
	__u16 mt_flags;
	__u16 mt_invflags;
};

struct ip6t_srh1 {
	__u8 next_hdr;
	__u8 hdr_len;
	__u8 segs_left;
	__u8 last_entry;
	__u16 tag;
	struct in6_addr psid_addr;
	struct in6_addr nsid_addr;
	struct in6_addr lsid_addr;
	struct in6_addr psid_msk;
	struct in6_addr nsid_msk;
	struct in6_addr lsid_msk;
	__u16 mt_flags;
	__u16 mt_invflags;
};

struct ip6t_standard {
	struct ip6t_entry entry;
	struct xt_standard_target target;
};

struct ip6table_nat_pernet {
	struct nf_hook_ops *nf_nat_ops;
};

struct ip_auth_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__be16 reserved;
	__be32 spi;
	__be32 seq_no;
	__u8 auth_data[0];
};

struct ip_beet_phdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 padlen;
	__u8 reserved;
};

struct ip_comp_hdr {
	__u8 nexthdr;
	__u8 flags;
	__be16 cpi;
};

struct ip_conntrack_stat {
	unsigned int found;
	unsigned int invalid;
	unsigned int insert;
	unsigned int insert_failed;
	unsigned int clash_resolve;
	unsigned int drop;
	unsigned int early_drop;
	unsigned int error;
	unsigned int expect_new;
	unsigned int expect_create;
	unsigned int expect_delete;
	unsigned int search_restart;
	unsigned int chaintoolong;
};

struct ip_ct_sctp {
	enum sctp_conntrack state;
	__be32 vtag[2];
	u8 init[2];
	u8 last_dir;
	u8 flags;
};

struct ip_ct_tcp_state {
	u_int32_t td_end;
	u_int32_t td_maxend;
	u_int32_t td_maxwin;
	u_int32_t td_maxack;
	u_int8_t td_scale;
	u_int8_t flags;
};

struct ip_ct_tcp {
	struct ip_ct_tcp_state seen[2];
	u_int8_t state;
	u_int8_t last_dir;
	u_int8_t retrans;
	u_int8_t last_index;
	u_int32_t last_seq;
	u_int32_t last_ack;
	u_int32_t last_end;
	u_int16_t last_win;
	u_int8_t last_wscale;
	u_int8_t last_flags;
};

struct ip_esp_hdr {
	__be32 spi;
	__be32 seq_no;
	__u8 enc_data[0];
};

struct ip_frag_state {
	bool DF;
	unsigned int hlen;
	unsigned int ll_rs;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	__be16 not_last_frag;
};

struct ip_fraglist_iter {
	struct sk_buff *frag;
	struct iphdr *iph;
	int offset;
	unsigned int hlen;
};

struct unix_domain;

struct ip_map {
	struct cache_head h;
	char m_class[8];
	struct in6_addr m_addr;
	struct unix_domain *m_client;
	struct callback_head m_rcu;
};

struct ip_sf_list;

struct ip_mc_list {
	struct in_device *interface;
	__be32 multiaddr;
	unsigned int sfmode;
	struct ip_sf_list *sources;
	struct ip_sf_list *tomb;
	long unsigned int sfcount[2];
	union {
		struct ip_mc_list *next;
		struct ip_mc_list *next_rcu;
	};
	struct ip_mc_list *next_hash;
	struct timer_list timer;
	int users;
	refcount_t refcnt;
	spinlock_t lock;
	char tm_running;
	char reporter;
	char unsolicit_count;
	char loaded;
	unsigned char gsquery;
	unsigned char crcount;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
	struct callback_head rcu;
};

struct ip_mreqn {
	struct in_addr imr_multiaddr;
	struct in_addr imr_address;
	int imr_ifindex;
};

struct ip_sf_socklist;

struct ip_mc_socklist {
	struct ip_mc_socklist *next_rcu;
	struct ip_mreqn multi;
	unsigned int sfmode;
	struct ip_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ip_mreq_source {
	__be32 imr_multiaddr;
	__be32 imr_interface;
	__be32 imr_sourceaddr;
};

struct ip_msfilter {
	__be32 imsf_multiaddr;
	__be32 imsf_interface;
	__u32 imsf_fmode;
	__u32 imsf_numsrc;
	union {
		__be32 imsf_slist[1];
		struct {
			struct {} __empty_imsf_slist_flex;
			__be32 imsf_slist_flex[0];
		};
	};
};

struct ip_ra_chain {
	struct ip_ra_chain *next;
	struct sock *sk;
	union {
		void (*destructor)(struct sock *);
		struct sock *saved_sk;
	};
	struct callback_head rcu;
};

struct kvec {
	void *iov_base;
	size_t iov_len;
};

struct ip_reply_arg {
	struct kvec iov[1];
	int flags;
	__wsum csum;
	int csumoffset;
	int bound_dev_if;
	u8 tos;
	kuid_t uid;
};

struct ip_rt_acct {
	__u32 o_bytes;
	__u32 o_packets;
	__u32 i_bytes;
	__u32 i_packets;
};

struct ip_rt_info {
	__be32 daddr;
	__be32 saddr;
	u_int8_t tos;
	u_int32_t mark;
};

struct ip_set_type;

struct ip_set_type_variant;

struct ip_set {
	struct callback_head rcu;
	char name[32];
	spinlock_t lock;
	u32 ref;
	u32 ref_netlink;
	struct ip_set_type *type;
	const struct ip_set_type_variant *variant;
	u8 family;
	u8 revision;
	u8 extensions;
	u8 flags;
	u32 timeout;
	u32 elements;
	size_t ext_size;
	size_t dsize;
	size_t offset[4];
	void *data;
};

struct ip_set_adt_opt {
	u8 family;
	u8 dim;
	u8 flags;
	u32 cmdflags;
	struct ip_set_ext ext;
};

struct ip_set_comment_rcu;

struct ip_set_comment {
	struct ip_set_comment_rcu *c;
};

struct ip_set_comment_rcu {
	struct callback_head rcu;
	char str[0];
};

struct ip_set_counter {
	atomic64_t bytes;
	atomic64_t packets;
};

struct ip_set_ext_type {
	void (*destroy)(struct ip_set *, void *);
	enum ip_set_extension type;
	enum ipset_cadt_flags flag;
	u8 len;
	u8 align;
};

union ip_set_name_index {
	char name[32];
	ip_set_id_t index;
};

struct ip_set_net {
	struct ip_set **ip_set_list;
	ip_set_id_t ip_set_max;
	bool is_deleted;
	bool is_destroyed;
};

struct ip_set_region {
	spinlock_t lock;
	size_t ext_size;
	u32 elements;
};

struct ip_set_req_get_set {
	unsigned int op;
	unsigned int version;
	union ip_set_name_index set;
};

struct ip_set_req_get_set_family {
	unsigned int op;
	unsigned int version;
	unsigned int family;
	union ip_set_name_index set;
};

struct ip_set_req_version {
	unsigned int op;
	unsigned int version;
};

struct netlink_range_validation;

struct netlink_range_validation_signed;

struct nla_policy {
	u8 type;
	u8 validation_type;
	u16 len;
	union {
		u16 strict_start_type;
		const u32 bitfield32_valid;
		const u32 mask;
		const char *reject_message;
		const struct nla_policy *nested_policy;
		const struct netlink_range_validation *range;
		const struct netlink_range_validation_signed *range_signed;
		struct {
			s16 min;
			s16 max;
		};
		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
	};
};

struct ip_set_type {
	struct list_head list;
	char name[32];
	u8 protocol;
	u8 dimension;
	u8 family;
	u8 revision_min;
	u8 revision_max;
	u8 create_flags[10];
	u16 features;
	int (*create)(struct net *, struct ip_set *, struct nlattr **, u32);
	const struct nla_policy create_policy[27];
	const struct nla_policy adt_policy[31];
	struct module *me;
};

typedef int (*ipset_adtfn)(struct ip_set *, void *, const struct ip_set_ext *, struct ip_set_ext *, u32);

struct xt_action_param;

struct ip_set_type_variant {
	int (*kadt)(struct ip_set *, const struct sk_buff *, const struct xt_action_param *, enum ipset_adt, struct ip_set_adt_opt *);
	int (*uadt)(struct ip_set *, struct nlattr **, enum ipset_adt, u32 *, u32, bool);
	ipset_adtfn adt[3];
	int (*resize)(struct ip_set *, bool);
	void (*destroy)(struct ip_set *);
	void (*flush)(struct ip_set *);
	void (*expire)(struct ip_set *);
	int (*head)(struct ip_set *, struct sk_buff *);
	int (*list)(const struct ip_set *, struct sk_buff *, struct netlink_callback *);
	void (*uref)(struct ip_set *, struct netlink_callback *, bool);
	bool (*same_set)(const struct ip_set *, const struct ip_set *);
	void (*cancel_gc)(struct ip_set *);
	bool region_lock;
};

struct ip_sf_list {
	struct ip_sf_list *sf_next;
	long unsigned int sf_count[2];
	__be32 sf_inaddr;
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ip_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	__be32 sl_addr[0];
};

struct ip_tunnel_parm_kern {
	char name[16];
	long unsigned int i_flags[1];
	long unsigned int o_flags[1];
	__be32 i_key;
	__be32 o_key;
	int link;
	struct iphdr iph;
};

struct ip_tunnel_6rd_parm {
	struct in6_addr prefix;
	__be32 relay_prefix;
	u16 prefixlen;
	u16 relay_prefixlen;
};

struct ip_tunnel_prl_entry;

struct ip_tunnel {
	struct ip_tunnel *next;
	struct hlist_node hash_node;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct net *net;
	long unsigned int err_time;
	int err_count;
	u32 i_seqno;
	atomic_t o_seqno;
	int tun_hlen;
	u32 index;
	u8 erspan_ver;
	u8 dir;
	u16 hwid;
	struct dst_cache dst_cache;
	struct ip_tunnel_parm_kern parms;
	int mlink;
	int encap_hlen;
	int hlen;
	struct ip_tunnel_encap encap;
	struct ip_tunnel_6rd_parm ip6rd;
	struct ip_tunnel_prl_entry *prl;
	unsigned int prl_count;
	unsigned int ip_tnl_net_id;
	struct gro_cells gro_cells;
	__u32 fwmark;
	bool collect_md;
	bool ignore_df;
};

struct ip_tunnel_6rd {
	struct in6_addr prefix;
	__be32 relay_prefix;
	__u16 prefixlen;
	__u16 relay_prefixlen;
};

struct ip_tunnel_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
	int (*err_handler)(struct sk_buff *, u32);
};

struct ip_tunnel_info {
	struct ip_tunnel_key key;
	struct ip_tunnel_encap encap;
	struct dst_cache dst_cache;
	u8 options_len;
	u8 mode;
};

struct rtnl_link_ops;

struct ip_tunnel_net {
	struct net_device *fb_tunnel_dev;
	struct rtnl_link_ops *rtnl_link_ops;
	struct hlist_head tunnels[128];
	struct ip_tunnel *collect_md_tun;
	int type;
};

struct ip_tunnel_parm {
	char name[16];
	int link;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	struct iphdr iph;
};

struct ip_tunnel_prl {
	__be32 addr;
	__u16 flags;
	__u16 __reserved;
	__u32 datalen;
	__u32 __reserved2;
};

struct ip_tunnel_prl_entry {
	struct ip_tunnel_prl_entry *next;
	__be32 addr;
	u16 flags;
	struct callback_head callback_head;
};

struct ipc64_perm {
	__kernel_key_t key;
	__kernel_uid32_t uid;
	__kernel_gid32_t gid;
	__kernel_uid32_t cuid;
	__kernel_gid32_t cgid;
	__kernel_mode_t mode;
	unsigned char __pad1[0];
	short unsigned int seq;
	short unsigned int __pad2;
	__kernel_ulong_t __unused1;
	__kernel_ulong_t __unused2;
};

struct ipc_ids {
	int in_use;
	short unsigned int seq;
	struct rw_semaphore rwsem;
	struct idr ipcs_idr;
	int max_idx;
	int last_idx;
	struct rhashtable key_ht;
};

struct ipc_namespace {
	struct ipc_ids ids[3];
	int sem_ctls[4];
	int used_sems;
	unsigned int msg_ctlmax;
	unsigned int msg_ctlmnb;
	unsigned int msg_ctlmni;
	struct percpu_counter percpu_msg_bytes;
	struct percpu_counter percpu_msg_hdrs;
	size_t shm_ctlmax;
	size_t shm_ctlall;
	long unsigned int shm_tot;
	int shm_ctlmni;
	int shm_rmid_forced;
	struct notifier_block ipcns_nb;
	struct vfsmount *mq_mnt;
	unsigned int mq_queues_count;
	unsigned int mq_queues_max;
	unsigned int mq_msg_max;
	unsigned int mq_msgsize_max;
	unsigned int mq_msg_default;
	unsigned int mq_msgsize_default;
	struct ctl_table_set mq_set;
	struct ctl_table_header *mq_sysctls;
	struct ctl_table_set ipc_set;
	struct ctl_table_header *ipc_sysctls;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct llist_node mnt_llist;
	struct ns_common ns;
};

struct ipc_params;

struct kern_ipc_perm;

struct ipc_ops {
	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
	int (*associate)(struct kern_ipc_perm *, int);
	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
};

struct ipc_params {
	key_t key;
	int flg;
	union {
		size_t size;
		int nsems;
	} u;
};

struct ipc_perm {
	__kernel_key_t key;
	__kernel_uid_t uid;
	__kernel_gid_t gid;
	__kernel_uid_t cuid;
	__kernel_gid_t cgid;
	__kernel_mode_t mode;
	short unsigned int seq;
};

struct ipc_proc_iface {
	const char *path;
	const char *header;
	int ids;
	int (*show)(struct seq_file *, void *);
};

struct ipc_proc_iter {
	struct ipc_namespace *ns;
	struct pid_namespace *pid_ns;
	struct ipc_proc_iface *iface;
};

struct sockcm_cookie {
	u64 transmit_time;
	u32 mark;
	u32 tsflags;
	u32 ts_opt_id;
	u32 priority;
};

struct ipcm6_cookie {
	struct sockcm_cookie sockc;
	__s16 hlimit;
	__s16 tclass;
	__u16 gso_size;
	__s8 dontfrag;
	struct ipv6_txoptions *opt;
};

struct ipcm_cookie {
	struct sockcm_cookie sockc;
	__be32 addr;
	int oif;
	struct ip_options_rcu *opt;
	__u8 protocol;
	__u8 ttl;
	__s16 tos;
	__u16 gso_size;
};

struct ipcomp_data {
	u16 threshold;
	struct crypto_comp **tfms;
};

struct ipcomp_tfms {
	struct list_head list;
	struct crypto_comp **tfms;
	int users;
};

struct ipfrag_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	};
	struct sk_buff *next_frag;
	int frag_run_len;
	int ip_defrag_offset;
};

struct ipmr_result {
	struct mr_table *mrt;
};

struct ipq {
	struct inet_frag_queue q;
	u8 ecn;
	u16 max_df_size;
	int iif;
	unsigned int rid;
	struct inet_peer *peer;
};

struct ipstats_mib {
	u64 mibs[38];
	struct u64_stats_sync syncp;
};

struct ipt_ECN_info {
	__u8 operation;
	__u8 ip_ect;
	union {
		struct {
			__u8 ece: 1;
			__u8 cwr: 1;
		} tcp;
	} proto;
};

struct ipt_TTL_info {
	__u8 mode;
	__u8 ttl;
};

struct ipt_ah {
	__u32 spis[2];
	__u8 invflags;
};

struct ipt_ip {
	struct in_addr src;
	struct in_addr dst;
	struct in_addr smsk;
	struct in_addr dmsk;
	char iniface[16];
	char outiface[16];
	unsigned char iniface_mask[16];
	unsigned char outiface_mask[16];
	__u16 proto;
	__u8 flags;
	__u8 invflags;
};

struct ipt_entry {
	struct ipt_ip ip;
	unsigned int nfcache;
	__u16 target_offset;
	__u16 next_offset;
	unsigned int comefrom;
	struct xt_counters counters;
	unsigned char elems[0];
};

struct ipt_error {
	struct ipt_entry entry;
	struct xt_error_target target;
};

struct ipt_get_entries {
	char name[32];
	unsigned int size;
	struct ipt_entry entrytable[0];
};

struct ipt_getinfo {
	char name[32];
	unsigned int valid_hooks;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_entries;
	unsigned int size;
};

struct ipt_icmp {
	__u8 type;
	__u8 code[2];
	__u8 invflags;
};

struct ipt_reject_info {
	enum ipt_reject_with with;
};

struct ipt_replace {
	char name[32];
	unsigned int valid_hooks;
	unsigned int num_entries;
	unsigned int size;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int num_counters;
	struct xt_counters *counters;
	struct ipt_entry entries[0];
};

struct ipt_standard {
	struct ipt_entry entry;
	struct xt_standard_target target;
};

struct ipt_ttl_info {
	__u8 mode;
	__u8 ttl;
};

struct iptable_nat_pernet {
	struct nf_hook_ops *nf_nat_ops;
};

struct ipv6_ac_socklist {
	struct in6_addr acl_addr;
	int acl_ifindex;
	struct ipv6_ac_socklist *acl_next;
};

struct udp_table;

struct ipv6_bpf_stub {
	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
	struct sock * (*udp6_lib_lookup)(const struct net *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
	int (*ipv6_setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*ipv6_getsockopt)(struct sock *, int, int, sockptr_t, sockptr_t);
	int (*ipv6_dev_get_saddr)(struct net *, const struct net_device *, const struct in6_addr *, unsigned int, struct in6_addr *);
};

struct ipv6_destopt_hao {
	__u8 type;
	__u8 length;
	struct in6_addr addr;
} __attribute__((packed));

struct ipv6_fl_socklist {
	struct ipv6_fl_socklist *next;
	struct ip6_flowlabel *fl;
	struct callback_head rcu;
};

struct ipv6_mc_socklist {
	struct in6_addr addr;
	int ifindex;
	unsigned int sfmode;
	struct ipv6_mc_socklist *next;
	struct ip6_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;
	int ipv6mr_ifindex;
};

struct ipv6_params {
	__s32 disable_ipv6;
	__s32 autoconf;
};

struct ipv6_route_iter {
	struct seq_net_private p;
	struct fib6_walker w;
	loff_t skip;
	struct fib6_table *tbl;
	int sernum;
};

struct ipv6_rpl_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u32 cmpre: 4;
	__u32 cmpri: 4;
	__u32 reserved: 4;
	__u32 pad: 4;
	__u32 reserved1: 16;
	union {
		struct {
			struct {} __empty_addr;
			struct in6_addr addr[0];
		};
		struct {
			struct {} __empty_data;
			__u8 data[0];
		};
	} segments;
};

struct ipv6_rt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
};

struct ipv6_saddr_dst {
	const struct in6_addr *addr;
	int ifindex;
	int scope;
	int label;
	unsigned int prefs;
};

struct ipv6_saddr_score {
	int rule;
	int addr_type;
	struct inet6_ifaddr *ifa;
	long unsigned int scorebits[1];
	int scopedist;
	int matchlen;
};

struct ipv6_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u8 first_segment;
	__u8 flags;
	__u16 tag;
	struct in6_addr segments[0];
};

struct ipv6_stub {
	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net *, const struct sock *, struct flowi6 *, const struct in6_addr *);
	int (*ipv6_route_input)(struct sk_buff *);
	struct fib6_table * (*fib6_get_table)(struct net *, u32);
	int (*fib6_lookup)(struct net *, int, struct flowi6 *, struct fib6_result *, int);
	int (*fib6_table_lookup)(struct net *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
	void (*fib6_select_path)(const struct net *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
	int (*fib6_nh_init)(struct net *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
	void (*fib6_nh_release)(struct fib6_nh *);
	void (*fib6_nh_release_dsts)(struct fib6_nh *);
	void (*fib6_update_sernum)(struct net *, struct fib6_info *);
	int (*ip6_del_rt)(struct net *, struct fib6_info *, bool);
	void (*fib6_rt_update)(struct net *, struct fib6_info *, struct nl_info *);
	void (*udpv6_encap_enable)(void);
	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
	void (*xfrm6_local_rxpmtu)(struct sk_buff *, u32);
	int (*xfrm6_udp_encap_rcv)(struct sock *, struct sk_buff *);
	struct sk_buff * (*xfrm6_gro_udp_encap_rcv)(struct sock *, struct list_head *, struct sk_buff *);
	int (*xfrm6_rcv_encap)(struct sk_buff *, int, __be32, int);
	struct neigh_table *nd_tbl;
	int (*ipv6_fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	struct net_device * (*ipv6_dev_find)(struct net *, const struct in6_addr *, struct net_device *);
	int (*ip6_xmit)(const struct sock *, struct sk_buff *, struct flowi6 *, __u32, struct ipv6_txoptions *, int, u32);
};

struct ipv6_txoptions {
	refcount_t refcnt;
	int tot_len;
	__u16 opt_flen;
	__u16 opt_nflen;
	struct ipv6_opt_hdr *hopopt;
	struct ipv6_opt_hdr *dst0opt;
	struct ipv6_rt_hdr *srcrt;
	struct ipv6_opt_hdr *dst1opt;
	struct callback_head rcu;
};

struct ipv6_tel_txoption {
	struct ipv6_txoptions ops;
	__u8 dst_opt[8];
};

struct ipv6_tlv_tnl_enc_lim {
	__u8 type;
	__u8 length;
	__u8 encap_limit;
};

struct ipv6hdr {
	__u8 priority: 4;
	__u8 version: 4;
	__u8 flow_lbl[3];
	__be16 payload_len;
	__u8 nexthdr;
	__u8 hop_limit;
	union {
		struct {
			struct in6_addr saddr;
			struct in6_addr daddr;
		};
		struct {
			struct in6_addr saddr;
			struct in6_addr daddr;
		} addrs;
	};
};

struct ipvl_dev;

struct ipvl_addr {
	struct ipvl_dev *master;
	union {
		struct in6_addr ip6;
		struct in_addr ip4;
	} ipu;
	struct hlist_node hlnode;
	struct list_head anode;
	ipvl_hdr_type atype;
	struct callback_head rcu;
};

struct ipvl_port;

struct ipvl_pcpu_stats;

struct ipvl_dev {
	struct net_device *dev;
	struct list_head pnode;
	struct ipvl_port *port;
	struct net_device *phy_dev;
	struct list_head addrs;
	struct ipvl_pcpu_stats *pcpu_stats;
	long unsigned int mac_filters[4];
	netdev_features_t sfeatures;
	u32 msg_enable;
	spinlock_t addrs_lock;
};

struct ipvl_pcpu_stats {
	u64_stats_t rx_pkts;
	u64_stats_t rx_bytes;
	u64_stats_t rx_mcast;
	u64_stats_t tx_pkts;
	u64_stats_t tx_bytes;
	struct u64_stats_sync syncp;
	u32 rx_errs;
	u32 tx_drps;
};

struct ipvl_port {
	struct net_device *dev;
	possible_net_t pnet;
	struct hlist_head hlhead[256];
	struct list_head ipvlans;
	u16 mode;
	u16 flags;
	u16 dev_id_start;
	struct work_struct wq;
	struct sk_buff_head backlog;
	int count;
	struct ida ida;
	netdevice_tracker dev_tracker;
};

struct ipvl_skb_cb {
	bool tx_pkt;
};

struct ipvlan_netns {
	unsigned int ipvl_nf_hook_refcnt;
};

struct tap_queue;

struct tap_dev {
	struct net_device *dev;
	u16 flags;
	struct tap_queue *taps[256];
	struct list_head queue_list;
	int numvtaps;
	int numqueues;
	netdev_features_t tap_features;
	int minor;
	void (*update_features)(struct tap_dev *, netdev_features_t);
	void (*count_tx_dropped)(struct tap_dev *);
	void (*count_rx_dropped)(struct tap_dev *);
};

struct ipvtap_dev {
	struct ipvl_dev vlan;
	struct tap_dev tap;
};

struct irq_affinity {
	unsigned int pre_vectors;
	unsigned int post_vectors;
	unsigned int nr_sets;
	unsigned int set_size[4];
	void (*calc_sets)(struct irq_affinity *, unsigned int);
	void *priv;
};

struct irq_affinity_desc {
	struct cpumask mask;
	unsigned int is_managed: 1;
};

struct irq_affinity_devres {
	unsigned int count;
	unsigned int irq[0];
};

struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
	void (*release)(struct kref *);
};

struct uv_alloc_info {
	int limit;
	int blade;
	long unsigned int offset;
	char *name;
};

struct msi_desc;

struct irq_alloc_info {
	enum irq_alloc_type type;
	u32 flags;
	u32 devid;
	irq_hw_number_t hwirq;
	const struct cpumask *mask;
	struct msi_desc *desc;
	void *data;
	union {
		struct ioapic_alloc_info ioapic;
		struct uv_alloc_info uv;
	};
};

typedef struct irq_alloc_info msi_alloc_info_t;

struct irq_data;

struct msi_msg;

struct irq_chip {
	const char *name;
	unsigned int (*irq_startup)(struct irq_data *);
	void (*irq_shutdown)(struct irq_data *);
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_ack)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	void (*irq_mask_ack)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_eoi)(struct irq_data *);
	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
	int (*irq_retrigger)(struct irq_data *);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	void (*irq_bus_lock)(struct irq_data *);
	void (*irq_bus_sync_unlock)(struct irq_data *);
	void (*irq_suspend)(struct irq_data *);
	void (*irq_resume)(struct irq_data *);
	void (*irq_pm_shutdown)(struct irq_data *);
	void (*irq_calc_mask)(struct irq_data *);
	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
	int (*irq_request_resources)(struct irq_data *);
	void (*irq_release_resources)(struct irq_data *);
	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
	void (*ipi_send_single)(struct irq_data *, unsigned int);
	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
	int (*irq_nmi_setup)(struct irq_data *);
	void (*irq_nmi_teardown)(struct irq_data *);
	long unsigned int flags;
};

struct irq_chip_regs {
	long unsigned int enable;
	long unsigned int disable;
	long unsigned int mask;
	long unsigned int ack;
	long unsigned int eoi;
	long unsigned int type;
};

struct irq_desc;

typedef void (*irq_flow_handler_t)(struct irq_desc *);

struct irq_chip_type {
	struct irq_chip chip;
	struct irq_chip_regs regs;
	irq_flow_handler_t handler;
	u32 type;
	u32 mask_cache_priv;
	u32 *mask_cache;
};

struct irq_chip_generic {
	raw_spinlock_t lock;
	void *reg_base;
	u32 (*reg_readl)(void *);
	void (*reg_writel)(u32, void *);
	void (*suspend)(struct irq_chip_generic *);
	void (*resume)(struct irq_chip_generic *);
	unsigned int irq_base;
	unsigned int irq_cnt;
	u32 mask_cache;
	u32 wake_enabled;
	u32 wake_active;
	unsigned int num_ct;
	void *private;
	long unsigned int installed;
	long unsigned int unused;
	struct irq_domain *domain;
	struct list_head list;
	struct irq_chip_type chip_types[0];
};

struct irq_common_data {
	unsigned int state_use_accessors;
	unsigned int node;
	void *handler_data;
	struct msi_desc *msi_desc;
	cpumask_var_t affinity;
	cpumask_var_t effective_affinity;
};

struct irq_data {
	u32 mask;
	unsigned int irq;
	irq_hw_number_t hwirq;
	struct irq_common_data *common;
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct irq_data *parent_data;
	void *chip_data;
};

struct irqstat;

struct irqaction;

struct irq_desc {
	struct irq_common_data irq_common_data;
	struct irq_data irq_data;
	struct irqstat *kstat_irqs;
	irq_flow_handler_t handle_irq;
	struct irqaction *action;
	unsigned int status_use_accessors;
	unsigned int core_internal_state__do_not_mess_with_it;
	unsigned int depth;
	unsigned int wake_depth;
	unsigned int tot_count;
	unsigned int irq_count;
	long unsigned int last_unhandled;
	unsigned int irqs_unhandled;
	atomic_t threads_handled;
	int threads_handled_last;
	raw_spinlock_t lock;
	struct cpumask *percpu_enabled;
	const struct cpumask *percpu_affinity;
	const struct cpumask *affinity_hint;
	struct irq_affinity_notify *affinity_notify;
	cpumask_var_t pending_mask;
	long unsigned int threads_oneshot;
	atomic_t threads_active;
	wait_queue_head_t wait_for_threads;
	unsigned int nr_actions;
	unsigned int no_suspend_depth;
	unsigned int cond_suspend_depth;
	unsigned int force_resume_depth;
	struct proc_dir_entry *dir;
	struct callback_head rcu;
	struct kobject kobj;
	struct mutex request_mutex;
	int parent_irq;
	struct module *owner;
	const char *name;
	struct hlist_node resend_node;
	long: 64;
	long: 64;
	long: 64;
};

typedef struct irq_desc *vector_irq_t[256];

struct irq_desc_devres {
	unsigned int from;
	unsigned int cnt;
};

struct irq_devres {
	unsigned int irq;
	void *dev_id;
};

struct irq_domain_chip_generic;

struct msi_parent_ops;

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;
	struct mutex mutex;
	struct irq_domain *root;
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
	struct device *dev;
	struct device *pm_dev;
	struct irq_domain *parent;
	const struct msi_parent_ops *msi_parent_ops;
	void (*exit)(struct irq_domain *);
	irq_hw_number_t hwirq_max;
	unsigned int revmap_size;
	struct xarray revmap_tree;
	struct irq_data *revmap[0];
};

struct irq_domain_chip_generic {
	unsigned int irqs_per_chip;
	unsigned int num_chips;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	void (*exit)(struct irq_chip_generic *);
	struct irq_chip_generic *gc[0];
};

struct irq_domain_chip_generic_info {
	const char *name;
	irq_flow_handler_t handler;
	unsigned int irqs_per_chip;
	unsigned int num_ct;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	int (*init)(struct irq_chip_generic *);
	void (*exit)(struct irq_chip_generic *);
};

struct irq_domain_info {
	struct fwnode_handle *fwnode;
	unsigned int domain_flags;
	unsigned int size;
	irq_hw_number_t hwirq_max;
	int direct_max;
	unsigned int hwirq_base;
	unsigned int virq_base;
	enum irq_domain_bus_token bus_token;
	const char *name_suffix;
	const struct irq_domain_ops *ops;
	void *host_data;
	struct irq_domain *parent;
	struct irq_domain_chip_generic_info *dgc_info;
	int (*init)(struct irq_domain *);
	void (*exit)(struct irq_domain *);
};

struct irq_fwspec;

struct irq_domain_ops {
	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
	void (*unmap)(struct irq_domain *, unsigned int);
	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);
	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
	void (*free)(struct irq_domain *, unsigned int, unsigned int);
	int (*activate)(struct irq_domain *, struct irq_data *, bool);
	void (*deactivate)(struct irq_domain *, struct irq_data *);
	int (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);
};

struct irq_fwspec {
	struct fwnode_handle *fwnode;
	int param_count;
	u32 param[16];
};

struct irq_glue {
	struct irq_affinity_notify notify;
	struct cpu_rmap *rmap;
	u16 index;
};

struct irq_info {
	u8 bus;
	u8 devfn;
	struct {
		u8 link;
		u16 bitmap;
	} __attribute__((packed)) irq[4];
	u8 slot;
	u8 rfu;
};

struct irq_info___2 {
	struct hlist_node node;
	int irq;
	spinlock_t lock;
	struct list_head *head;
};

struct irq_matrix {
	unsigned int matrix_bits;
	unsigned int alloc_start;
	unsigned int alloc_end;
	unsigned int alloc_size;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int systembits_inalloc;
	unsigned int total_allocated;
	unsigned int online_maps;
	struct cpumap *maps;
	long unsigned int *system_map;
	long unsigned int scratch_map[0];
};

struct irq_override_cmp {
	const struct dmi_system_id *system;
	unsigned char irq;
	unsigned char triggering;
	unsigned char polarity;
	unsigned char shareable;
	bool override;
};

struct irq_pin_list {
	struct list_head list;
	int apic;
	int pin;
};

struct irq_remap_table {
	raw_spinlock_t lock;
	unsigned int min_index;
	u32 *table;
};

struct irq_router {
	char *name;
	u16 vendor;
	u16 device;
	int (*get)(struct pci_dev *, struct pci_dev *, int);
	int (*set)(struct pci_dev *, struct pci_dev *, int, int);
	int (*lvl)(struct pci_dev *, struct pci_dev *, int, int);
};

struct irq_router_handler {
	u16 vendor;
	int (*probe)(struct irq_router *, struct pci_dev *, u16);
};

struct irq_routing_table {
	u32 signature;
	u16 version;
	u16 size;
	u8 rtr_bus;
	u8 rtr_devfn;
	u16 exclusive_irqs;
	u16 rtr_vendor;
	u16 rtr_device;
	u32 miniport_data;
	u8 rfu[11];
	u8 checksum;
	struct irq_info slots[0];
};

struct irq_stack {
	char stack[16384];
};

struct irqaction {
	irq_handler_t handler;
	void *dev_id;
	void *percpu_dev_id;
	struct irqaction *next;
	irq_handler_t thread_fn;
	struct task_struct *thread;
	struct irqaction *secondary;
	unsigned int irq;
	unsigned int flags;
	long unsigned int thread_flags;
	long unsigned int thread_mask;
	const char *name;
	struct proc_dir_entry *dir;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct irqchip_fwid {
	struct fwnode_handle fwnode;
	unsigned int type;
	char *name;
	phys_addr_t *pa;
};

struct irqentry_state {
	union {
		bool exit_rcu;
		bool lockdep;
	};
};

typedef struct irqentry_state irqentry_state_t;

struct irqstat {
	unsigned int cnt;
};

struct irt_routing_table {
	u32 signature;
	u8 size;
	u8 used;
	u16 exclusive_irqs;
	struct irq_info slots[0];
};

struct iso_directory_record {
	__u8 length[1];
	__u8 ext_attr_length[1];
	__u8 extent[8];
	__u8 size[8];
	__u8 date[7];
	__u8 flags[1];
	__u8 file_unit_size[1];
	__u8 interleave[1];
	__u8 volume_sequence_number[4];
	__u8 name_len[1];
	char name[0];
};

struct iso_inode_info {
	long unsigned int i_iget5_block;
	long unsigned int i_iget5_offset;
	unsigned int i_first_extent;
	unsigned char i_file_format;
	unsigned char i_format_parm[3];
	long unsigned int i_next_section_block;
	long unsigned int i_next_section_offset;
	off_t i_section_size;
	struct inode vfs_inode;
};

struct iso_primary_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 unused1[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 unused3[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 opt_type_l_path_table[4];
	__u8 type_m_path_table[4];
	__u8 opt_type_m_path_table[4];
	__u8 root_directory_record[34];
	char volume_set_id[128];
	char publisher_id[128];
	char preparer_id[128];
	char application_id[128];
	char copyright_file_id[37];
	char abstract_file_id[37];
	char bibliographic_file_id[37];
	__u8 creation_date[17];
	__u8 modification_date[17];
	__u8 expiration_date[17];
	__u8 effective_date[17];
	__u8 file_structure_version[1];
	__u8 unused4[1];
	__u8 application_data[512];
	__u8 unused5[653];
};

struct iso_supplementary_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 flags[1];
	char system_id[32];
	char volume_id[32];
	__u8 unused2[8];
	__u8 volume_space_size[8];
	__u8 escape[32];
	__u8 volume_set_size[4];
	__u8 volume_sequence_number[4];
	__u8 logical_block_size[4];
	__u8 path_table_size[8];
	__u8 type_l_path_table[4];
	__u8 opt_type_l_path_table[4];
	__u8 type_m_path_table[4];
	__u8 opt_type_m_path_table[4];
	__u8 root_directory_record[34];
	char volume_set_id[128];
	char publisher_id[128];
	char preparer_id[128];
	char application_id[128];
	char copyright_file_id[37];
	char abstract_file_id[37];
	char bibliographic_file_id[37];
	__u8 creation_date[17];
	__u8 modification_date[17];
	__u8 expiration_date[17];
	__u8 effective_date[17];
	__u8 file_structure_version[1];
	__u8 unused4[1];
	__u8 application_data[512];
	__u8 unused5[653];
};

struct iso_volume_descriptor {
	__u8 type[1];
	char id[5];
	__u8 version[1];
	__u8 data[2041];
};

struct isoch_data {
	u32 maxbw;
	u32 n;
	u32 y;
	u32 l;
	u32 rq;
	struct agp_3_5_dev *dev;
};

struct isofs_fid {
	u32 block;
	u16 offset;
	u16 parent_offset;
	u32 generation;
	u32 parent_block;
	u32 parent_generation;
};

struct isofs_iget5_callback_data {
	long unsigned int block;
	long unsigned int offset;
};

struct isofs_options {
	unsigned int rock: 1;
	unsigned int joliet: 1;
	unsigned int cruft: 1;
	unsigned int hide: 1;
	unsigned int showassoc: 1;
	unsigned int nocompress: 1;
	unsigned int overriderockperm: 1;
	unsigned int uid_set: 1;
	unsigned int gid_set: 1;
	unsigned char map;
	unsigned char check;
	unsigned int blocksize;
	umode_t fmode;
	umode_t dmode;
	kgid_t gid;
	kuid_t uid;
	char *iocharset;
	s32 session;
	s32 sbsector;
};

struct nls_table;

struct isofs_sb_info {
	long unsigned int s_ninodes;
	long unsigned int s_nzones;
	long unsigned int s_firstdatazone;
	long unsigned int s_log_zone_size;
	long unsigned int s_max_size;
	int s_rock_offset;
	s32 s_sbsector;
	unsigned char s_joliet_level;
	unsigned char s_mapping;
	unsigned char s_check;
	unsigned char s_session;
	unsigned int s_high_sierra: 1;
	unsigned int s_rock: 2;
	unsigned int s_cruft: 1;
	unsigned int s_nocompress: 1;
	unsigned int s_hide: 1;
	unsigned int s_showassoc: 1;
	unsigned int s_overriderockperm: 1;
	unsigned int s_uid_set: 1;
	unsigned int s_gid_set: 1;
	umode_t s_fmode;
	umode_t s_dmode;
	kgid_t s_gid;
	kuid_t s_uid;
	struct nls_table *s_nls_iocharset;
};

struct itco_wdt_platform_data {
	char name[32];
	unsigned int version;
	bool no_reboot_use_pmc;
};

struct iter_state {
	struct seq_net_private p;
	unsigned int bucket;
};

struct itimerspec64 {
	struct timespec64 it_interval;
	struct timespec64 it_value;
};

struct ivch_priv {
	bool quiet;
	u16 width;
	u16 height;
	u16 reg_backup[24];
};

struct ivhd_dte_flags {
	struct list_head list;
	u16 segid;
	u16 devid_first;
	u16 devid_last;
	long: 64;
	struct dev_table_entry dte;
};

struct ivhd_entry {
	u8 type;
	u16 devid;
	u8 flags;
	union {
		struct {
			u32 ext;
			u32 hidh;
		};
		struct {
			u32 ext;
			u32 hidh;
		} ext_hid;
	};
	u64 cid;
	u8 uidf;
	u8 uidl;
	u8 uid;
} __attribute__((packed));

struct ivhd_header {
	u8 type;
	u8 flags;
	u16 length;
	u16 devid;
	u16 cap_ptr;
	u64 mmio_phys;
	u16 pci_seg;
	u16 info;
	u32 efr_attr;
	u64 efr_reg;
	u64 efr_reg2;
};

struct ivmd_header {
	u8 type;
	u8 flags;
	u16 length;
	u16 devid;
	u16 aux;
	u16 pci_seg;
	u8 resv[6];
	u64 range_start;
	u64 range_length;
};

struct ivrs_quirk_entry {
	u8 id;
	u32 devid;
};

struct iw_node_attr {
	struct kobj_attribute kobj_attr;
	int nid;
};

struct transaction_s;

typedef struct transaction_s transaction_t;

struct jbd2_inode {
	transaction_t *i_transaction;
	transaction_t *i_next_transaction;
	struct list_head i_list;
	struct inode *i_vfs_inode;
	long unsigned int i_flags;
	loff_t i_dirty_start;
	loff_t i_dirty_end;
};

struct jbd2_journal_block_tail {
	__be32 t_checksum;
};

typedef struct journal_s journal_t;

struct jbd2_journal_handle {
	union {
		transaction_t *h_transaction;
		journal_t *h_journal;
	};
	handle_t *h_rsv_handle;
	int h_total_credits;
	int h_revoke_credits;
	int h_revoke_credits_requested;
	int h_ref;
	int h_err;
	unsigned int h_sync: 1;
	unsigned int h_jdata: 1;
	unsigned int h_reserved: 1;
	unsigned int h_aborted: 1;
	unsigned int h_type: 8;
	unsigned int h_line_no: 16;
	long unsigned int h_start_jiffies;
	unsigned int h_requested_credits;
	unsigned int saved_alloc_context;
};

struct journal_header_s {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
};

typedef struct journal_header_s journal_header_t;

struct jbd2_journal_revoke_header_s {
	journal_header_t r_header;
	__be32 r_count;
};

typedef struct jbd2_journal_revoke_header_s jbd2_journal_revoke_header_t;

struct jbd2_revoke_record_s {
	struct list_head hash;
	tid_t sequence;
	long long unsigned int blocknr;
};

struct jbd2_revoke_table_s {
	int hash_size;
	int hash_shift;
	struct list_head *hash_table;
};

struct transaction_stats_s;

struct jbd2_stats_proc_session {
	journal_t *journal;
	struct transaction_stats_s *stats;
	int start;
	int max;
};

struct jit_context {
	int cleanup_addr;
	int tail_call_direct_label;
	int tail_call_indirect_label;
};

struct rand_data;

struct shash_desc;

struct jitterentropy {
	spinlock_t jent_lock;
	struct rand_data *entropy_collector;
	struct crypto_shash *tfm;
	struct shash_desc *sdesc;
};

struct join_entry {
	u32 token;
	u32 remote_nonce;
	u32 local_nonce;
	u8 join_id;
	u8 local_id;
	u8 backup;
	u8 valid;
};

struct journal_block_tag3_s {
	__be32 t_blocknr;
	__be32 t_flags;
	__be32 t_blocknr_high;
	__be32 t_checksum;
};

typedef struct journal_block_tag3_s journal_block_tag3_t;

struct journal_block_tag_s {
	__be32 t_blocknr;
	__be16 t_checksum;
	__be16 t_flags;
	__be32 t_blocknr_high;
};

typedef struct journal_block_tag_s journal_block_tag_t;

struct journal_head {
	struct buffer_head *b_bh;
	spinlock_t b_state_lock;
	int b_jcount;
	unsigned int b_jlist;
	unsigned int b_modified;
	char *b_frozen_data;
	char *b_committed_data;
	transaction_t *b_transaction;
	transaction_t *b_next_transaction;
	struct journal_head *b_tnext;
	struct journal_head *b_tprev;
	transaction_t *b_cp_transaction;
	struct journal_head *b_cpnext;
	struct journal_head *b_cpprev;
	struct jbd2_buffer_trigger_type *b_triggers;
	struct jbd2_buffer_trigger_type *b_frozen_triggers;
};

struct transaction_run_stats_s {
	long unsigned int rs_wait;
	long unsigned int rs_request_delay;
	long unsigned int rs_running;
	long unsigned int rs_locked;
	long unsigned int rs_flushing;
	long unsigned int rs_logging;
	__u32 rs_handle_count;
	__u32 rs_blocks;
	__u32 rs_blocks_logged;
};

struct transaction_stats_s {
	long unsigned int ts_tid;
	long unsigned int ts_requested;
	struct transaction_run_stats_s run;
};

struct journal_superblock_s;

typedef struct journal_superblock_s journal_superblock_t;

struct journal_s {
	long unsigned int j_flags;
	int j_errno;
	struct mutex j_abort_mutex;
	struct buffer_head *j_sb_buffer;
	journal_superblock_t *j_superblock;
	rwlock_t j_state_lock;
	int j_barrier_count;
	struct mutex j_barrier;
	transaction_t *j_running_transaction;
	transaction_t *j_committing_transaction;
	transaction_t *j_checkpoint_transactions;
	wait_queue_head_t j_wait_transaction_locked;
	wait_queue_head_t j_wait_done_commit;
	wait_queue_head_t j_wait_commit;
	wait_queue_head_t j_wait_updates;
	wait_queue_head_t j_wait_reserved;
	wait_queue_head_t j_fc_wait;
	struct mutex j_checkpoint_mutex;
	struct buffer_head *j_chkpt_bhs[64];
	struct shrinker *j_shrinker;
	struct percpu_counter j_checkpoint_jh_count;
	transaction_t *j_shrink_transaction;
	long unsigned int j_head;
	long unsigned int j_tail;
	long unsigned int j_free;
	long unsigned int j_first;
	long unsigned int j_last;
	long unsigned int j_fc_first;
	long unsigned int j_fc_off;
	long unsigned int j_fc_last;
	struct block_device *j_dev;
	int j_blocksize;
	long long unsigned int j_blk_offset;
	char j_devname[56];
	struct block_device *j_fs_dev;
	errseq_t j_fs_dev_wb_err;
	unsigned int j_total_len;
	atomic_t j_reserved_credits;
	spinlock_t j_list_lock;
	struct inode *j_inode;
	tid_t j_tail_sequence;
	tid_t j_transaction_sequence;
	tid_t j_commit_sequence;
	tid_t j_commit_request;
	__u8 j_uuid[16];
	struct task_struct *j_task;
	int j_max_transaction_buffers;
	int j_revoke_records_per_block;
	int j_transaction_overhead_buffers;
	long unsigned int j_commit_interval;
	struct timer_list j_commit_timer;
	spinlock_t j_revoke_lock;
	struct jbd2_revoke_table_s *j_revoke;
	struct jbd2_revoke_table_s *j_revoke_table[2];
	struct buffer_head **j_wbuf;
	struct buffer_head **j_fc_wbuf;
	int j_wbufsize;
	int j_fc_wbufsize;
	pid_t j_last_sync_writer;
	u64 j_average_commit_time;
	u32 j_min_batch_time;
	u32 j_max_batch_time;
	void (*j_commit_callback)(journal_t *, transaction_t *);
	int (*j_submit_inode_data_buffers)(struct jbd2_inode *);
	int (*j_finish_inode_data_buffers)(struct jbd2_inode *);
	spinlock_t j_history_lock;
	struct proc_dir_entry *j_proc_entry;
	struct transaction_stats_s j_stats;
	unsigned int j_failed_commit;
	void *j_private;
	__u32 j_csum_seed;
	void (*j_fc_cleanup_callback)(struct journal_s *, int, tid_t);
	int (*j_fc_replay_callback)(struct journal_s *, struct buffer_head *, enum passtype, int, tid_t);
	int (*j_bmap)(struct journal_s *, sector_t *);
};

struct journal_superblock_s {
	journal_header_t s_header;
	__be32 s_blocksize;
	__be32 s_maxlen;
	__be32 s_first;
	__be32 s_sequence;
	__be32 s_start;
	__be32 s_errno;
	__be32 s_feature_compat;
	__be32 s_feature_incompat;
	__be32 s_feature_ro_compat;
	__u8 s_uuid[16];
	__be32 s_nr_users;
	__be32 s_dynsuper;
	__be32 s_max_transaction;
	__be32 s_max_trans_data;
	__u8 s_checksum_type;
	__u8 s_padding2[3];
	__be32 s_num_fc_blks;
	__be32 s_head;
	__u32 s_padding[40];
	__be32 s_checksum;
	__u8 s_users[768];
};

struct jump_entry {
	s32 code;
	s32 target;
	long int key;
};

struct jump_label_patch {
	const void *code;
	int size;
};

struct k_itimer;

struct k_clock {
	int (*clock_getres)(const clockid_t, struct timespec64 *);
	int (*clock_set)(const clockid_t, const struct timespec64 *);
	int (*clock_get_timespec)(const clockid_t, struct timespec64 *);
	ktime_t (*clock_get_ktime)(const clockid_t);
	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
	int (*timer_create)(struct k_itimer *);
	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
	int (*timer_del)(struct k_itimer *);
	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
	void (*timer_rearm)(struct k_itimer *);
	s64 (*timer_forward)(struct k_itimer *, ktime_t);
	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
	int (*timer_try_to_cancel)(struct k_itimer *);
	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
	void (*timer_wait_running)(struct k_itimer *);
};

struct kernel_siginfo {
	struct {
		int si_signo;
		int si_errno;
		int si_code;
		union __sifields _sifields;
	};
};

struct sigqueue {
	struct list_head list;
	int flags;
	kernel_siginfo_t info;
	struct ucounts *ucounts;
};

struct signal_struct;

struct k_itimer {
	struct hlist_node list;
	struct hlist_node ignored_list;
	struct hlist_node t_hash;
	spinlock_t it_lock;
	const struct k_clock *kclock;
	clockid_t it_clock;
	timer_t it_id;
	int it_status;
	bool it_sig_periodic;
	s64 it_overrun;
	s64 it_overrun_last;
	unsigned int it_signal_seq;
	unsigned int it_sigqueue_seq;
	int it_sigev_notify;
	enum pid_type it_pid_type;
	ktime_t it_interval;
	struct signal_struct *it_signal;
	union {
		struct pid *it_pid;
		struct task_struct *it_process;
	};
	struct sigqueue sigq;
	rcuref_t rcuref;
	union {
		struct {
			struct hrtimer timer;
		} real;
		struct cpu_timer cpu;
		struct {
			struct alarm alarmtimer;
		} alarm;
	} it;
	struct callback_head rcu;
};

struct mpc_parameters {
	__u16 mpc_p1;
	__u16 mpc_p2;
	__u8 mpc_p3[8];
	__u16 mpc_p4;
	__u16 mpc_p5;
	__u16 mpc_p6;
};

struct k_message {
	__u16 type;
	__be32 ip_mask;
	__u8 MPS_ctrl[20];
	union {
		in_ctrl_info in_info;
		eg_ctrl_info eg_info;
		struct mpc_parameters params;
	} content;
	struct atm_qos qos;
};

typedef void __signalfn_t(int);

typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t(void);

typedef __restorefn_t *__sigrestore_t;

struct sigaction {
	__sighandler_t sa_handler;
	long unsigned int sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
};

struct k_sonet_stats {
	atomic_t section_bip;
	atomic_t line_bip;
	atomic_t path_bip;
	atomic_t line_febe;
	atomic_t path_febe;
	atomic_t corr_hcs;
	atomic_t uncorr_hcs;
	atomic_t tx_cells;
	atomic_t rx_cells;
};

struct kallsym_iter {
	loff_t pos;
	loff_t pos_mod_end;
	loff_t pos_ftrace_mod_end;
	loff_t pos_bpf_end;
	long unsigned int value;
	unsigned int nameoff;
	char type;
	char name[512];
	char module_name[56];
	int exported;
	int show_value;
};

struct karatsuba_ctx {
	struct karatsuba_ctx *next;
	mpi_ptr_t tspace;
	mpi_size_t tspace_size;
	mpi_ptr_t tp;
	mpi_size_t tp_size;
};

struct kaslr_memory_region {
	long unsigned int *base;
	long unsigned int *end;
	long unsigned int size_tb;
};

struct led_trigger {
	const char *name;
	int (*activate)(struct led_classdev *);
	void (*deactivate)(struct led_classdev *);
	enum led_brightness brightness;
	struct led_hw_trigger_type *trigger_type;
	spinlock_t leddev_list_lock;
	struct list_head led_cdevs;
	struct list_head next_trig;
	const struct attribute_group **groups;
};

struct kbd_led_trigger {
	struct led_trigger trigger;
	unsigned int mask;
};

struct kbd_repeat {
	int delay;
	int period;
};

struct kbd_struct {
	unsigned char lockstate;
	unsigned char slockstate;
	unsigned char ledmode: 1;
	unsigned char ledflagstate: 4;
	char: 3;
	unsigned char default_ledflagstate: 4;
	unsigned char kbdmode: 3;
	int: 1;
	unsigned char modeflags: 5;
};

struct kbdiacr {
	unsigned char diacr;
	unsigned char base;
	unsigned char result;
};

struct kbdiacrs {
	unsigned int kb_cnt;
	struct kbdiacr kbdiacr[256];
};

struct kbdiacruc {
	unsigned int diacr;
	unsigned int base;
	unsigned int result;
};

struct kbdiacrsuc {
	unsigned int kb_cnt;
	struct kbdiacruc kbdiacruc[256];
};

struct kbentry {
	unsigned char kb_table;
	unsigned char kb_index;
	short unsigned int kb_value;
};

struct kbkeycode {
	unsigned int scancode;
	unsigned int keycode;
};

struct kbsentry {
	unsigned char kb_func;
	unsigned char kb_string[512];
};

struct kcmp_epoll_slot {
	__u32 efd;
	__u32 tfd;
	__u32 toff;
};

typedef void (*dm_kcopyd_notify_fn)(int, long unsigned int, void *);

struct kcopyd_job {
	struct dm_kcopyd_client *kc;
	struct list_head list;
	unsigned int flags;
	int read_err;
	long unsigned int write_err;
	enum req_op op;
	struct dm_io_region source;
	unsigned int num_dests;
	struct dm_io_region dests[8];
	struct page_list *pages;
	dm_kcopyd_notify_fn fn;
	void *context;
	struct mutex lock;
	atomic_t sub_jobs;
	sector_t progress;
	sector_t write_offset;
	struct kcopyd_job *master_job;
};

struct kcore_list {
	struct list_head list;
	long unsigned int addr;
	size_t size;
	int type;
};

struct kcsan_scoped_access {};

struct tcp6_ao_context {
	struct in6_addr saddr;
	struct in6_addr daddr;
	__be16 sport;
	__be16 dport;
	__be32 sisn;
	__be32 disn;
};

struct kdf_input_block {
	u8 counter;
	u8 label[6];
	struct tcp6_ao_context ctx;
	__be16 outlen;
} __attribute__((packed));

struct tcp4_ao_context {
	__be32 saddr;
	__be32 daddr;
	__be16 sport;
	__be16 dport;
	__be32 sisn;
	__be32 disn;
};

struct kdf_input_block___2 {
	u8 counter;
	u8 label[6];
	struct tcp4_ao_context ctx;
	__be16 outlen;
} __attribute__((packed));

struct kern_ipc_perm {
	spinlock_t lock;
	bool deleted;
	int id;
	key_t key;
	kuid_t uid;
	kgid_t gid;
	kuid_t cuid;
	kgid_t cgid;
	umode_t mode;
	long unsigned int seq;
	void *security;
	struct rhash_head khtnode;
	struct callback_head rcu;
	refcount_t refcount;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kernel_clone_args {
	u64 flags;
	int *pidfd;
	int *child_tid;
	int *parent_tid;
	const char *name;
	int exit_signal;
	u32 kthread: 1;
	u32 io_thread: 1;
	u32 user_worker: 1;
	u32 no_files: 1;
	long unsigned int stack;
	long unsigned int stack_size;
	long unsigned int tls;
	pid_t *set_tid;
	size_t set_tid_size;
	int cgroup;
	int idle;
	int (*fn)(void *);
	void *fn_arg;
	struct cgroup *cgrp;
	struct css_set *cset;
	unsigned int kill_seq;
};

struct kernel_cpustat {
	u64 cpustat[10];
};

struct kernel_ethtool_ringparam {
	u32 rx_buf_len;
	u8 tcp_data_split;
	u8 tx_push;
	u8 rx_push;
	u32 cqe_size;
	u32 tx_push_buf_len;
	u32 tx_push_buf_max_len;
	u32 hds_thresh;
	u32 hds_thresh_max;
};

struct kernel_ethtool_ts_info {
	u32 cmd;
	u32 so_timestamping;
	int phc_index;
	enum hwtstamp_provider_qualifier phc_qualifier;
	enum hwtstamp_tx_types tx_types;
	enum hwtstamp_rx_filters rx_filters;
};

struct kernel_hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
	struct ifreq *ifr;
	bool copied_to_user;
	enum hwtstamp_source source;
	enum hwtstamp_provider_qualifier qualifier;
};

struct kernel_param_ops;

struct kparam_string;

struct kparam_array;

struct kernel_param {
	const char *name;
	struct module *mod;
	const struct kernel_param_ops *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array *arr;
	};
};

struct kernel_param_ops {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param *);
	int (*get)(char *, const struct kernel_param *);
	void (*free)(void *);
};

struct kernel_pkey_params {
	struct key *key;
	const char *encoding;
	const char *hash_algo;
	char *info;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	enum kernel_pkey_operation op: 8;
};

struct kernel_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
};

struct kernel_stat {
	long unsigned int irqs_sum;
	unsigned int softirqs[10];
};

struct kernel_symbol {
	int value_offset;
	int name_offset;
	int namespace_offset;
};

struct kernel_vm86_regs {
	struct pt_regs pt;
	short unsigned int es;
	short unsigned int __esh;
	short unsigned int ds;
	short unsigned int __dsh;
	short unsigned int fs;
	short unsigned int __fsh;
	short unsigned int gs;
	short unsigned int __gsh;
};

struct kernfs_open_node;

struct kernfs_elem_attr {
	const struct kernfs_ops *ops;
	struct kernfs_open_node *open;
	loff_t size;
	struct kernfs_node *notify_next;
};

struct kernfs_elem_dir {
	long unsigned int subdirs;
	struct rb_root children;
	struct kernfs_root *root;
	long unsigned int rev;
};

struct kernfs_elem_symlink {
	struct kernfs_node *target_kn;
};

struct kernfs_global_locks {
	struct mutex open_file_mutex[1024];
};

struct simple_xattrs {
	struct rb_root rb_root;
	rwlock_t lock;
};

struct kernfs_iattrs {
	kuid_t ia_uid;
	kgid_t ia_gid;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct simple_xattrs xattrs;
	atomic_t nr_user_xattrs;
	atomic_t user_xattr_size;
};

struct kernfs_node {
	atomic_t count;
	atomic_t active;
	struct kernfs_node *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	short unsigned int flags;
	umode_t mode;
	union {
		struct kernfs_elem_dir dir;
		struct kernfs_elem_symlink symlink;
		struct kernfs_elem_attr attr;
	};
	u64 id;
	void *priv;
	struct kernfs_iattrs *iattr;
	struct callback_head rcu;
};

struct kernfs_open_file {
	struct kernfs_node *kn;
	struct file *file;
	struct seq_file *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct *vm_ops;
};

struct kernfs_open_node {
	struct callback_head callback_head;
	atomic_t event;
	wait_queue_head_t poll;
	struct list_head files;
	unsigned int nr_mmapped;
	unsigned int nr_to_release;
};

struct kernfs_ops {
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
	loff_t (*llseek)(struct kernfs_open_file *, loff_t, int);
};

struct kernfs_syscall_ops;

struct kernfs_root {
	struct kernfs_node *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_id_lowbits;
	u32 id_highbits;
	struct kernfs_syscall_ops *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
	struct rw_semaphore kernfs_rwsem;
	struct rw_semaphore kernfs_iattr_rwsem;
	struct rw_semaphore kernfs_supers_rwsem;
	struct callback_head rcu;
};

struct kernfs_super_info {
	struct super_block *sb;
	struct kernfs_root *root;
	const void *ns;
	struct list_head node;
};

struct kernfs_syscall_ops {
	int (*show_options)(struct seq_file *, struct kernfs_root *);
	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node *);
	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
};

struct kexec_load_limit {
	struct mutex mutex;
	int limit;
};

struct kexec_segment {
	union {
		void *buf;
		void *kbuf;
	};
	size_t bufsz;
	long unsigned int mem;
	size_t memsz;
};

struct key_type;

struct key_tag;

struct keyring_index_key {
	long unsigned int hash;
	union {
		struct {
			u16 desc_len;
			char desc[6];
		};
		long unsigned int x;
	};
	struct key_type *type;
	struct key_tag *domain_tag;
	const char *description;
};

union key_payload {
	void *rcu_data0;
	void *data[4];
};

struct key_user;

struct key_restriction;

struct key {
	refcount_t usage;
	key_serial_t serial;
	union {
		struct list_head graveyard_link;
		struct rb_node serial_node;
	};
	struct rw_semaphore sem;
	struct key_user *user;
	void *security;
	union {
		time64_t expiry;
		time64_t revoked_at;
	};
	time64_t last_used_at;
	kuid_t uid;
	kgid_t gid;
	key_perm_t perm;
	short unsigned int quotalen;
	short unsigned int datalen;
	short int state;
	long unsigned int flags;
	union {
		struct keyring_index_key index_key;
		struct {
			long unsigned int hash;
			long unsigned int len_desc;
			struct key_type *type;
			struct key_tag *domain_tag;
			char *description;
		};
	};
	union {
		union key_payload payload;
		struct {
			struct list_head name_link;
			struct assoc_array keys;
		};
	};
	struct key_restriction *restrict_link;
};

struct key_entry {
	int type;
	u32 code;
	union {
		u16 keycode;
		struct {
			u8 code;
			u8 value;
		} sw;
	};
};

struct key_match_data {
	bool (*cmp)(const struct key *, const struct key_match_data *);
	const void *raw_data;
	void *preparsed;
	unsigned int lookup_type;
};

struct key_preparsed_payload {
	const char *orig_description;
	char *description;
	union key_payload payload;
	const void *data;
	size_t datalen;
	size_t quotalen;
	time64_t expiry;
};

typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);

struct key_restriction {
	key_restrict_link_func_t check;
	struct key *key;
	struct key_type *keytype;
};

struct key_tag {
	struct callback_head rcu;
	refcount_t usage;
	bool removed;
};

typedef int (*request_key_actor_t)(struct key *, void *);

struct key_type {
	const char *name;
	size_t def_datalen;
	unsigned int flags;
	int (*vet_description)(const char *);
	int (*preparse)(struct key_preparsed_payload *);
	void (*free_preparse)(struct key_preparsed_payload *);
	int (*instantiate)(struct key *, struct key_preparsed_payload *);
	int (*update)(struct key *, struct key_preparsed_payload *);
	int (*match_preparse)(struct key_match_data *);
	void (*match_free)(struct key_match_data *);
	void (*revoke)(struct key *);
	void (*destroy)(struct key *);
	void (*describe)(const struct key *, struct seq_file *);
	long int (*read)(const struct key *, char *, size_t);
	request_key_actor_t request_key;
	struct key_restriction * (*lookup_restriction)(const char *);
	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
	struct list_head link;
	struct lock_class_key lock_class;
};

struct key_user {
	struct rb_node node;
	struct mutex cons_lock;
	spinlock_t lock;
	refcount_t usage;
	atomic_t nkeys;
	atomic_t nikeys;
	kuid_t uid;
	int qnkeys;
	int qnbytes;
};

struct key_vector {
	t_key key;
	unsigned char pos;
	unsigned char bits;
	unsigned char slen;
	union {
		struct hlist_head leaf;
		struct {
			struct {} __empty_tnode;
			struct key_vector *tnode[0];
		};
	};
};

struct keyboard_notifier_param {
	struct vc_data *vc;
	int down;
	int shift;
	int ledstate;
	unsigned int value;
};

struct keyctl_dh_params {
	union {
		__s32 private;
		__s32 priv;
	};
	__s32 prime;
	__s32 base;
};

struct keyctl_kdf_params {
	char *hashname;
	char *otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct keyctl_pkey_params {
	__s32 key_id;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	__u32 __spare[7];
};

struct keyctl_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
	__u32 __spare[10];
};

struct keyring_read_iterator_context {
	size_t buflen;
	size_t count;
	key_serial_t *buffer;
};

struct __key_reference_with_attributes;

typedef struct __key_reference_with_attributes *key_ref_t;

struct keyring_search_context {
	struct keyring_index_key index_key;
	const struct cred *cred;
	struct key_match_data match_data;
	unsigned int flags;
	int (*iterator)(const void *, void *);
	int skipped_ret;
	bool possessed;
	key_ref_t result;
	time64_t now;
};

struct kfence_track {
	pid_t pid;
	int cpu;
	u64 ts_nsec;
	int num_stack_entries;
	long unsigned int stack_entries[64];
};

struct slabobj_ext {
	struct obj_cgroup *objcg;
};

struct kfence_metadata {
	struct list_head list;
	struct callback_head callback_head;
	raw_spinlock_t lock;
	enum kfence_object_state state;
	long unsigned int addr;
	size_t size;
	struct kmem_cache *cache;
	long unsigned int unprotected_page;
	struct kfence_track alloc_track;
	struct kfence_track free_track;
	u32 alloc_stack_hash;
	struct slabobj_ext obj_exts;
};

struct rcu_gp_oldstate {
	long unsigned int rgos_norm;
	long unsigned int rgos_exp;
};

struct kfree_rcu_cpu;

struct kfree_rcu_cpu_work {
	struct rcu_work rcu_work;
	struct callback_head *head_free;
	struct rcu_gp_oldstate head_free_gp_snap;
	struct list_head bulk_head_free[2];
	struct kfree_rcu_cpu *krcp;
};

struct kfree_rcu_cpu {
	struct callback_head *head;
	long unsigned int head_gp_snap;
	atomic_t head_count;
	struct list_head bulk_head[2];
	atomic_t bulk_count[2];
	struct kfree_rcu_cpu_work krw_arr[2];
	raw_spinlock_t lock;
	struct delayed_work monitor_work;
	bool initialized;
	struct delayed_work page_cache_work;
	atomic_t backoff_page_cache_fill;
	atomic_t work_in_progress;
	struct hrtimer hrtimer;
	struct llist_head bkvcache;
	int nr_bkv_objs;
};

struct kgetbmap {
	__s64 bmv_offset;
	__s64 bmv_block;
	__s64 bmv_length;
	__s32 bmv_oflags;
};

struct kimage_arch {
	pgd_t *pgd;
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;
};

struct kimage {
	kimage_entry_t head;
	kimage_entry_t *entry;
	kimage_entry_t *last_entry;
	long unsigned int start;
	struct page *control_code_page;
	struct page *swap_page;
	void *vmcoreinfo_data_copy;
	long unsigned int nr_segments;
	struct kexec_segment segment[16];
	struct list_head control_pages;
	struct list_head dest_pages;
	struct list_head unusable_pages;
	long unsigned int control_page;
	unsigned int type: 1;
	unsigned int preserve_context: 1;
	unsigned int file_mode: 1;
	unsigned int hotplug_support: 1;
	struct kimage_arch arch;
	int hp_action;
	int elfcorehdr_index;
	bool elfcorehdr_updated;
	void *elf_headers;
	long unsigned int elf_headers_sz;
	long unsigned int elf_load_addr;
};

struct kioctx_cpu;

struct kioctx {
	struct percpu_ref users;
	atomic_t dead;
	struct percpu_ref reqs;
	long unsigned int user_id;
	struct kioctx_cpu *cpu;
	unsigned int req_batch;
	unsigned int max_reqs;
	unsigned int nr_events;
	long unsigned int mmap_base;
	long unsigned int mmap_size;
	struct folio **ring_folios;
	long int nr_pages;
	struct rcu_work free_rwork;
	struct ctx_rq_wait *rq_wait;
	long: 64;
	long: 64;
	long: 64;
	struct {
		atomic_t reqs_available;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t ctx_lock;
		struct list_head active_reqs;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex ring_lock;
		wait_queue_head_t wait;
		long: 64;
	};
	struct {
		unsigned int tail;
		unsigned int completed_events;
		spinlock_t completion_lock;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct folio *internal_folios[8];
	struct file *aio_ring_file;
	unsigned int id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kioctx_cpu {
	unsigned int reqs_available;
};

struct kioctx_table {
	struct callback_head rcu;
	unsigned int nr;
	struct kioctx *table[0];
};

struct klist_waiter {
	struct list_head list;
	struct klist_node *node;
	struct task_struct *process;
	int woken;
};

struct km_event {
	union {
		u32 hard;
		u32 proto;
		u32 byid;
		u32 aevent;
		u32 type;
	} data;
	u32 seq;
	u32 portid;
	u32 event;
	struct net *net;
};

struct kmalloc_info_struct {
	const char *name[19];
	unsigned int size;
};

struct kmalloced_param {
	struct list_head list;
	char val[0];
};

struct kmap_ctrl {};

typedef struct kmem_cache *kmem_buckets[14];

struct kmem_cache_order_objects {
	unsigned int x;
};

struct kmem_cache_cpu;

struct kmem_cache_node;

struct kmem_cache {
	struct kmem_cache_cpu *cpu_slab;
	slab_flags_t flags;
	long unsigned int min_partial;
	unsigned int size;
	unsigned int object_size;
	struct reciprocal_value reciprocal_size;
	unsigned int offset;
	unsigned int cpu_partial;
	unsigned int cpu_partial_slabs;
	struct kmem_cache_order_objects oo;
	struct kmem_cache_order_objects min;
	gfp_t allocflags;
	int refcount;
	void (*ctor)(void *);
	unsigned int inuse;
	unsigned int align;
	unsigned int red_left_pad;
	const char *name;
	struct list_head list;
	struct kobject kobj;
	long unsigned int random;
	unsigned int remote_node_defrag_ratio;
	unsigned int *random_seq;
	unsigned int useroffset;
	unsigned int usersize;
	struct kmem_cache_node *node[64];
};

struct kmem_cache_args {
	unsigned int align;
	unsigned int useroffset;
	unsigned int usersize;
	unsigned int freeptr_offset;
	bool use_freeptr_offset;
	void (*ctor)(void *);
};

struct kmem_cache_cpu {
	union {
		struct {
			void **freelist;
			long unsigned int tid;
		};
		freelist_aba_t freelist_tid;
	};
	struct slab *slab;
	struct slab *partial;
	local_lock_t lock;
};

union kmem_cache_iter_priv {
	struct bpf_iter_kmem_cache it;
	struct bpf_iter_kmem_cache_kern kit;
};

struct kmem_cache_node {
	spinlock_t list_lock;
	long unsigned int nr_partial;
	struct list_head partial;
	atomic_long_t nr_slabs;
	atomic_long_t total_objects;
	struct list_head full;
};

struct kmem_obj_info {
	void *kp_ptr;
	struct slab *kp_slab;
	void *kp_objp;
	long unsigned int kp_data_offset;
	struct kmem_cache *kp_slab_cache;
	void *kp_ret;
	void *kp_stack[16];
	void *kp_free_stack[16];
};

struct kmsg_dump_detail {
	enum kmsg_dump_reason reason;
	const char *description;
};

struct kmsg_dump_iter {
	u64 cur_seq;
	u64 next_seq;
};

struct kobj_engine {
	struct kobject base;
	struct intel_engine_cs *engine;
};

struct probe;

struct kobj_map {
	struct probe *probes[255];
	struct mutex *lock;
};

struct kobj_ns_type_operations {
	enum kobj_ns_type type;
	bool (*current_may_mount)(void);
	void * (*grab_current_ns)(void);
	const void * (*netlink_ns)(struct sock *);
	const void * (*initial_ns)(void);
	void (*drop_ns)(void *);
};

struct kobj_uevent_env {
	char *argv[3];
	char *envp[64];
	int envp_idx;
	char buf[2048];
	int buflen;
};

struct kparam_array {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops *ops;
	void *elem;
};

struct kparam_string {
	unsigned int maxlen;
	char *string;
};

struct kpp_request;

struct kpp_alg {
	int (*set_secret)(struct crypto_kpp *, const void *, unsigned int);
	int (*generate_public_key)(struct kpp_request *);
	int (*compute_shared_secret)(struct kpp_request *);
	unsigned int (*max_size)(struct crypto_kpp *);
	int (*init)(struct crypto_kpp *);
	void (*exit)(struct crypto_kpp *);
	struct crypto_alg base;
};

struct kpp_instance {
	void (*free)(struct kpp_instance *);
	union {
		struct {
			char head[48];
			struct crypto_instance base;
		} s;
		struct kpp_alg alg;
	};
};

struct kpp_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	void *__ctx[0];
};

struct kpp_secret {
	short unsigned int type;
	short unsigned int len;
};

typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);

typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);

struct kprobe {
	struct hlist_node hlist;
	struct list_head list;
	long unsigned int nmissed;
	kprobe_opcode_t *addr;
	const char *symbol_name;
	unsigned int offset;
	kprobe_pre_handler_t pre_handler;
	kprobe_post_handler_t post_handler;
	kprobe_opcode_t opcode;
	struct arch_specific_insn ainsn;
	u32 flags;
};

struct kprobe_blacklist_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
};

struct prev_kprobe {
	struct kprobe *kp;
	long unsigned int status;
	long unsigned int old_flags;
	long unsigned int saved_flags;
};

struct kprobe_ctlblk {
	long unsigned int kprobe_status;
	long unsigned int kprobe_old_flags;
	long unsigned int kprobe_saved_flags;
	struct prev_kprobe prev_kprobe;
};

struct kprobe_insn_cache {
	struct mutex mutex;
	void * (*alloc)(void);
	void (*free)(void *);
	const char *sym;
	struct list_head pages;
	size_t insn_size;
	int nr_garbage;
};

struct kprobe_insn_page {
	struct list_head list;
	kprobe_opcode_t *insns;
	struct kprobe_insn_cache *cache;
	int nused;
	int ngarbage;
	char slot_used[0];
};

struct kprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int ip;
};

struct krb5_ctx {
	int initiate;
	u32 enctype;
	u32 flags;
	const struct gss_krb5_enctype *gk5e;
	struct crypto_sync_skcipher *enc;
	struct crypto_sync_skcipher *seq;
	struct crypto_sync_skcipher *acceptor_enc;
	struct crypto_sync_skcipher *initiator_enc;
	struct crypto_sync_skcipher *acceptor_enc_aux;
	struct crypto_sync_skcipher *initiator_enc_aux;
	struct crypto_ahash *acceptor_sign;
	struct crypto_ahash *initiator_sign;
	struct crypto_ahash *initiator_integ;
	struct crypto_ahash *acceptor_integ;
	u8 Ksess[32];
	u8 cksum[32];
	atomic_t seq_send;
	atomic64_t seq_send64;
	time64_t endtime;
	struct xdr_netobj mech_used;
};

struct kretprobe_instance;

typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);

struct rethook;

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
	int nmissed;
	size_t data_size;
	struct rethook *rh;
};

struct kretprobe_blackpoint {
	const char *name;
	void *addr;
};

struct rethook_node {
	struct callback_head rcu;
	struct llist_node llist;
	struct rethook *rethook;
	long unsigned int ret_addr;
	long unsigned int frame;
};

struct kretprobe_instance {
	struct rethook_node node;
	char data[0];
};

struct kretprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int func;
	long unsigned int ret_ip;
};

struct kset_uevent_ops;

struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
};

struct kset_uevent_ops {
	int (* const filter)(const struct kobject *);
	const char * (* const name)(const struct kobject *);
	int (* const uevent)(const struct kobject *, struct kobj_uevent_env *);
};

struct ksignal {
	struct k_sigaction ka;
	kernel_siginfo_t info;
	int sig;
};

struct kstat {
	u32 result_mask;
	umode_t mode;
	unsigned int nlink;
	uint32_t blksize;
	u64 attributes;
	u64 attributes_mask;
	u64 ino;
	dev_t dev;
	dev_t rdev;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	struct timespec64 btime;
	u64 blocks;
	u64 mnt_id;
	u64 change_cookie;
	u64 subvol;
	u32 dio_mem_align;
	u32 dio_offset_align;
	u32 dio_read_offset_align;
	u32 atomic_write_unit_min;
	u32 atomic_write_unit_max;
	u32 atomic_write_segments_max;
};

struct kstatfs {
	long int f_type;
	long int f_bsize;
	u64 f_blocks;
	u64 f_bfree;
	u64 f_bavail;
	u64 f_files;
	u64 f_ffree;
	__kernel_fsid_t f_fsid;
	long int f_namelen;
	long int f_frsize;
	long int f_flags;
	long int f_spare[4];
};

struct statmount {
	__u32 size;
	__u32 mnt_opts;
	__u64 mask;
	__u32 sb_dev_major;
	__u32 sb_dev_minor;
	__u64 sb_magic;
	__u32 sb_flags;
	__u32 fs_type;
	__u64 mnt_id;
	__u64 mnt_parent_id;
	__u32 mnt_id_old;
	__u32 mnt_parent_id_old;
	__u64 mnt_attr;
	__u64 mnt_propagation;
	__u64 mnt_peer_group;
	__u64 mnt_master;
	__u64 propagate_from;
	__u32 mnt_root;
	__u32 mnt_point;
	__u64 mnt_ns_id;
	__u32 fs_subtype;
	__u32 sb_source;
	__u32 opt_num;
	__u32 opt_array;
	__u32 opt_sec_num;
	__u32 opt_sec_array;
	__u64 __spare2[46];
	char str[0];
};

struct seq_file {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	loff_t index;
	loff_t read_pos;
	struct mutex lock;
	const struct seq_operations *op;
	int poll_event;
	const struct file *file;
	void *private;
};

struct kstatmount {
	struct statmount *buf;
	size_t bufsize;
	struct vfsmount *mnt;
	u64 mask;
	struct path root;
	struct statmount sm;
	struct seq_file seq;
};

struct ktermios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct kthread {
	long unsigned int flags;
	unsigned int cpu;
	unsigned int node;
	int started;
	int result;
	int (*threadfn)(void *);
	void *data;
	struct completion parked;
	struct completion exited;
	struct cgroup_subsys_state *blkcg_css;
	char *full_name;
	struct task_struct *task;
	struct list_head hotplug_node;
	struct cpumask *preferred_affinity;
};

struct kthread_create_info {
	char *full_name;
	int (*threadfn)(void *);
	void *data;
	int node;
	struct task_struct *result;
	struct completion *done;
	struct list_head list;
};

struct kthread_delayed_work {
	struct kthread_work work;
	struct timer_list timer;
};

struct kthread_flush_work {
	struct kthread_work work;
	struct completion done;
};

struct kthread_worker {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct *task;
	struct kthread_work *current_work;
};

struct kvfree_rcu_bulk_data {
	struct list_head list;
	struct rcu_gp_oldstate gp_snap;
	long unsigned int nr_records;
	void *records[0];
};

struct kvm_memslots {
	u64 generation;
	atomic_long_t last_used_slot;
	struct rb_root_cached hva_tree;
	struct rb_root gfn_tree;
	struct hlist_head id_hash[128];
	int node_idx;
};

struct kvm_vm_stat_generic {
	u64 remote_tlb_flush;
	u64 remote_tlb_flush_requests;
};

struct kvm_vm_stat {
	struct kvm_vm_stat_generic generic;
	u64 mmu_shadow_zapped;
	u64 mmu_pte_write;
	u64 mmu_pde_zapped;
	u64 mmu_flooded;
	u64 mmu_recycled;
	u64 mmu_cache_miss;
	u64 mmu_unsync;
	union {
		struct {
			atomic64_t pages_4k;
			atomic64_t pages_2m;
			atomic64_t pages_1g;
		};
		atomic64_t pages[3];
	};
	u64 nx_lpage_splits;
	u64 max_mmu_page_hash_collisions;
	u64 max_mmu_rmap_size;
};

struct kvm_pic;

struct kvm_ioapic;

struct kvm_pit;

struct kvm_xen_hvm_config {
	__u32 flags;
	__u32 msr;
	__u64 blob_addr_32;
	__u64 blob_addr_64;
	__u8 blob_size_32;
	__u8 blob_size_64;
	__u8 pad2[30];
};

struct ms_hyperv_tsc_page {
	volatile u32 tsc_sequence;
	u32 reserved1;
	volatile u64 tsc_scale;
	volatile s64 tsc_offset;
};

struct kvm_hv_syndbg {
	struct {
		u64 control;
		u64 status;
		u64 send_page;
		u64 recv_page;
		u64 pending_page;
	} control;
	u64 options;
};

struct kvm_hv {
	struct mutex hv_lock;
	u64 hv_guest_os_id;
	u64 hv_hypercall;
	u64 hv_tsc_page;
	enum hv_tsc_page_status hv_tsc_page_status;
	u64 hv_crash_param[5];
	u64 hv_crash_ctl;
	struct ms_hyperv_tsc_page tsc_ref;
	struct idr conn_to_evt;
	u64 hv_reenlightenment_control;
	u64 hv_tsc_emulation_control;
	u64 hv_tsc_emulation_status;
	u64 hv_invtsc_control;
	atomic_t num_mismatched_vp_indexes;
	unsigned int synic_auto_eoi_used;
	struct kvm_hv_syndbg hv_syndbg;
	bool xsaves_xsavec_checked;
};

struct once {
	atomic_t state;
	struct mutex lock;
};

struct kvm_mmu_memory_cache {
	gfp_t gfp_zero;
	gfp_t gfp_custom;
	u64 init_value;
	struct kmem_cache *kmem_cache;
	int capacity;
	int nobjs;
	void **objects;
};

struct kvm_apic_map;

struct kvm_x86_msr_filter;

struct kvm_x86_pmu_event_filter;

struct vhost_task;

struct kvm_arch {
	long unsigned int n_used_mmu_pages;
	long unsigned int n_requested_mmu_pages;
	long unsigned int n_max_mmu_pages;
	unsigned int indirect_shadow_pages;
	u8 mmu_valid_gen;
	u8 vm_type;
	bool has_private_mem;
	bool has_protected_state;
	bool pre_fault_allowed;
	struct hlist_head mmu_page_hash[4096];
	struct list_head active_mmu_pages;
	struct list_head possible_nx_huge_pages;
	spinlock_t mmu_unsync_pages_lock;
	u64 shadow_mmio_value;
	struct iommu_domain *iommu_domain;
	bool iommu_noncoherent;
	atomic_t noncoherent_dma_count;
	atomic_t assigned_device_count;
	struct kvm_pic *vpic;
	struct kvm_ioapic *vioapic;
	struct kvm_pit *vpit;
	atomic_t vapics_in_nmi_mode;
	struct mutex apic_map_lock;
	struct kvm_apic_map *apic_map;
	atomic_t apic_map_dirty;
	bool apic_access_memslot_enabled;
	bool apic_access_memslot_inhibited;
	struct rw_semaphore apicv_update_lock;
	long unsigned int apicv_inhibit_reasons;
	gpa_t wall_clock;
	bool mwait_in_guest;
	bool hlt_in_guest;
	bool pause_in_guest;
	bool cstate_in_guest;
	long unsigned int irq_sources_bitmap;
	s64 kvmclock_offset;
	raw_spinlock_t tsc_write_lock;
	u64 last_tsc_nsec;
	u64 last_tsc_write;
	u32 last_tsc_khz;
	u64 last_tsc_offset;
	u64 cur_tsc_nsec;
	u64 cur_tsc_write;
	u64 cur_tsc_offset;
	u64 cur_tsc_generation;
	int nr_vcpus_matched_tsc;
	u32 default_tsc_khz;
	bool user_set_tsc;
	u64 apic_bus_cycle_ns;
	seqcount_raw_spinlock_t pvclock_sc;
	bool use_master_clock;
	u64 master_kernel_ns;
	u64 master_cycle_now;
	struct delayed_work kvmclock_update_work;
	struct delayed_work kvmclock_sync_work;
	struct kvm_xen_hvm_config xen_hvm_config;
	struct hlist_head mask_notifier_list;
	struct kvm_hv hyperv;
	bool backwards_tsc_observed;
	bool boot_vcpu_runs_old_kvmclock;
	u32 bsp_vcpu_id;
	u64 disabled_quirks;
	enum kvm_irqchip_mode irqchip_mode;
	u8 nr_reserved_ioapic_pins;
	bool disabled_lapic_found;
	bool x2apic_format;
	bool x2apic_broadcast_quirk_disabled;
	bool guest_can_read_msr_platform_info;
	bool exception_payload_enabled;
	bool triple_fault_event;
	bool bus_lock_detection_enabled;
	bool enable_pmu;
	u32 notify_window;
	u32 notify_vmexit_flags;
	bool exit_on_emulation_error;
	u32 user_space_msr_mask;
	struct kvm_x86_msr_filter *msr_filter;
	u32 hypercall_exit_enabled;
	bool sgx_provisioning_allowed;
	struct kvm_x86_pmu_event_filter *pmu_event_filter;
	struct vhost_task *nx_huge_page_recovery_thread;
	u64 nx_huge_page_last;
	struct once nx_once;
	atomic64_t tdp_mmu_pages;
	struct list_head tdp_mmu_roots;
	spinlock_t tdp_mmu_pages_lock;
	bool shadow_root_allocated;
	u32 max_vcpu_ids;
	bool disable_nx_huge_pages;
	struct kvm_mmu_memory_cache split_shadow_page_cache;
	struct kvm_mmu_memory_cache split_page_header_cache;
	struct kvm_mmu_memory_cache split_desc_cache;
	gfn_t gfn_direct_bits;
};

struct kvm_io_bus;

struct kvm_coalesced_mmio_ring;

struct kvm_irq_routing_table;

struct kvm_stat_data;

struct kvm {
	rwlock_t mmu_lock;
	struct mutex slots_lock;
	struct mutex slots_arch_lock;
	struct mm_struct *mm;
	long unsigned int nr_memslot_pages;
	struct kvm_memslots __memslots[4];
	struct kvm_memslots *memslots[2];
	struct xarray vcpu_array;
	atomic_t nr_memslots_dirty_logging;
	spinlock_t mn_invalidate_lock;
	long unsigned int mn_active_invalidate_count;
	struct rcuwait mn_memslots_update_rcuwait;
	spinlock_t gpc_lock;
	struct list_head gpc_list;
	atomic_t online_vcpus;
	int max_vcpus;
	int created_vcpus;
	int last_boosted_vcpu;
	struct list_head vm_list;
	struct mutex lock;
	struct kvm_io_bus *buses[5];
	struct {
		spinlock_t lock;
		struct list_head items;
		struct list_head resampler_list;
		struct mutex resampler_lock;
	} irqfds;
	struct list_head ioeventfds;
	struct kvm_vm_stat stat;
	struct kvm_arch arch;
	refcount_t users_count;
	struct kvm_coalesced_mmio_ring *coalesced_mmio_ring;
	spinlock_t ring_lock;
	struct list_head coalesced_zones;
	struct mutex irq_lock;
	struct kvm_irq_routing_table *irq_routing;
	struct hlist_head irq_ack_notifier_list;
	struct mmu_notifier mmu_notifier;
	long unsigned int mmu_invalidate_seq;
	long int mmu_invalidate_in_progress;
	gfn_t mmu_invalidate_range_start;
	gfn_t mmu_invalidate_range_end;
	struct list_head devices;
	u64 manual_dirty_log_protect;
	struct dentry *debugfs_dentry;
	struct kvm_stat_data **debugfs_stat_data;
	struct srcu_struct srcu;
	struct srcu_struct irq_srcu;
	pid_t userspace_pid;
	bool override_halt_poll_ns;
	unsigned int max_halt_poll_ns;
	u32 dirty_ring_size;
	bool dirty_ring_with_bitmap;
	bool vm_bugged;
	bool vm_dead;
	struct notifier_block pm_notifier;
	char stats_id[48];
};

struct kvm_lapic;

struct kvm_apic_map {
	struct callback_head rcu;
	enum kvm_apic_logical_mode logical_mode;
	u32 max_apic_id;
	union {
		struct kvm_lapic *xapic_flat_map[8];
		struct kvm_lapic *xapic_cluster_map[64];
	};
	struct kvm_lapic *phys_map[0];
};

struct kvm_rmap_head;

struct kvm_lpage_info;

struct kvm_arch_memory_slot {
	struct kvm_rmap_head *rmap[3];
	struct kvm_lpage_info *lpage_info[2];
	short unsigned int *gfn_write_track;
};

struct kvm_clock_pairing {
	__s64 sec;
	__s64 nsec;
	__u64 tsc;
	__u32 flags;
	__u32 pad[9];
};

struct kvm_coalesced_mmio {
	__u64 phys_addr;
	__u32 len;
	union {
		__u32 pad;
		__u32 pio;
	};
	__u8 data[8];
};

struct kvm_coalesced_mmio_ring {
	__u32 first;
	__u32 last;
	struct kvm_coalesced_mmio coalesced_mmio[0];
};

union kvm_mmu_page_role {
	u32 word;
	struct {
		unsigned int level: 4;
		unsigned int has_4_byte_gpte: 1;
		unsigned int quadrant: 2;
		unsigned int direct: 1;
		unsigned int access: 3;
		unsigned int invalid: 1;
		unsigned int efer_nx: 1;
		unsigned int cr0_wp: 1;
		unsigned int smep_andnot_wp: 1;
		unsigned int smap_andnot_wp: 1;
		unsigned int ad_disabled: 1;
		unsigned int guest_mode: 1;
		unsigned int passthrough: 1;
		unsigned int is_mirror: 1;
		char: 4;
		unsigned int smm: 8;
	};
};

union kvm_mmu_extended_role {
	u32 word;
	struct {
		unsigned int valid: 1;
		unsigned int execonly: 1;
		unsigned int cr4_pse: 1;
		unsigned int cr4_pke: 1;
		unsigned int cr4_smap: 1;
		unsigned int cr4_smep: 1;
		unsigned int cr4_la57: 1;
		unsigned int efer_lma: 1;
	};
};

union kvm_cpu_role {
	u64 as_u64;
	struct {
		union kvm_mmu_page_role base;
		union kvm_mmu_extended_role ext;
	};
};

struct kvm_cpuid_entry2 {
	__u32 function;
	__u32 index;
	__u32 flags;
	__u32 eax;
	__u32 ebx;
	__u32 ecx;
	__u32 edx;
	__u32 padding[3];
};

struct kvm_debug_exit_arch {
	__u32 exception;
	__u32 pad;
	__u64 pc;
	__u64 dr6;
	__u64 dr7;
};

struct kvm_dirty_gfn {
	__u32 flags;
	__u32 slot;
	__u64 offset;
};

struct kvm_dirty_ring {
	u32 dirty_index;
	u32 reset_index;
	u32 size;
	u32 soft_limit;
	struct kvm_dirty_gfn *dirty_gfns;
	int index;
};

struct kvm_dtable {
	__u64 base;
	__u16 limit;
	__u16 padding[3];
};

struct kvm_enc_region {
	__u64 addr;
	__u64 size;
};

struct kvm_hyperv_exit {
	__u32 type;
	__u32 pad1;
	union {
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 evt_page;
			__u64 msg_page;
		} synic;
		struct {
			__u64 input;
			__u64 result;
			__u64 params[2];
		} hcall;
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 status;
			__u64 send_page;
			__u64 recv_page;
			__u64 pending_page;
		} syndbg;
	} u;
};

struct kvm_io_device;

struct kvm_io_range {
	gpa_t addr;
	int len;
	struct kvm_io_device *dev;
};

struct kvm_io_bus {
	int dev_count;
	int ioeventfd_count;
	struct kvm_io_range range[0];
};

struct kvm_irq_routing_table {
	int chip[72];
	u32 nr_rt_entries;
	struct hlist_head map[0];
};

struct kvm_lpage_info {
	int disallow_lpage;
};

struct kvm_memory_slot {
	struct hlist_node id_node[2];
	struct interval_tree_node hva_node[2];
	struct rb_node gfn_node[2];
	gfn_t base_gfn;
	long unsigned int npages;
	long unsigned int *dirty_bitmap;
	struct kvm_arch_memory_slot arch;
	long unsigned int userspace_addr;
	u32 flags;
	short int id;
	u16 as_id;
};

struct kvm_mmio_fragment {
	gpa_t gpa;
	void *data;
	unsigned int len;
};

struct kvm_page_fault;

struct x86_exception;

struct kvm_mmu_page;

struct kvm_mmu_root_info {
	gpa_t pgd;
	hpa_t hpa;
};

struct rsvd_bits_validate {
	u64 rsvd_bits_mask[10];
	u64 bad_mt_xwr;
};

struct kvm_vcpu;

struct kvm_mmu {
	long unsigned int (*get_guest_pgd)(struct kvm_vcpu *);
	u64 (*get_pdptr)(struct kvm_vcpu *, int);
	int (*page_fault)(struct kvm_vcpu *, struct kvm_page_fault *);
	void (*inject_page_fault)(struct kvm_vcpu *, struct x86_exception *);
	gpa_t (*gva_to_gpa)(struct kvm_vcpu *, struct kvm_mmu *, gpa_t, u64, struct x86_exception *);
	int (*sync_spte)(struct kvm_vcpu *, struct kvm_mmu_page *, int);
	struct kvm_mmu_root_info root;
	hpa_t mirror_root_hpa;
	union kvm_cpu_role cpu_role;
	union kvm_mmu_page_role root_role;
	u32 pkru_mask;
	struct kvm_mmu_root_info prev_roots[3];
	u8 permissions[16];
	u64 *pae_root;
	u64 *pml4_root;
	u64 *pml5_root;
	struct rsvd_bits_validate shadow_zero_check;
	struct rsvd_bits_validate guest_rsvd_check;
	u64 pdptrs[4];
};

struct kvm_mtrr {
	u64 var[16];
	u64 fixed_64k;
	u64 fixed_16k[2];
	u64 fixed_4k[8];
	u64 deftype;
};

struct kvm_vmx_nested_state_hdr {
	__u64 vmxon_pa;
	__u64 vmcs12_pa;
	struct {
		__u16 flags;
	} smm;
	__u16 pad;
	__u32 flags;
	__u64 preemption_timer_deadline;
};

struct kvm_svm_nested_state_hdr {
	__u64 vmcb_pa;
};

struct kvm_vmx_nested_state_data {
	__u8 vmcs12[4096];
	__u8 shadow_vmcs12[4096];
};

struct kvm_svm_nested_state_data {
	__u8 vmcb12[4096];
};

struct kvm_nested_state {
	__u16 flags;
	__u16 format;
	__u32 size;
	union {
		struct kvm_vmx_nested_state_hdr vmx;
		struct kvm_svm_nested_state_hdr svm;
		__u8 pad[120];
	} hdr;
	union {
		struct {
			struct {} __empty_vmx;
			struct kvm_vmx_nested_state_data vmx[0];
		};
		struct {
			struct {} __empty_svm;
			struct kvm_svm_nested_state_data svm[0];
		};
	} data;
};

struct kvm_pio_request {
	long unsigned int linear_rip;
	long unsigned int count;
	int in;
	int port;
	int size;
};

struct kvm_pmc {
	enum pmc_type type;
	u8 idx;
	bool is_paused;
	bool intr;
	u64 counter;
	u64 emulated_counter;
	u64 eventsel;
	struct perf_event *perf_event;
	struct kvm_vcpu *vcpu;
	u64 current_config;
};

struct kvm_pmu {
	u8 version;
	unsigned int nr_arch_gp_counters;
	unsigned int nr_arch_fixed_counters;
	unsigned int available_event_types;
	u64 fixed_ctr_ctrl;
	u64 fixed_ctr_ctrl_rsvd;
	u64 global_ctrl;
	u64 global_status;
	u64 counter_bitmask[2];
	u64 global_ctrl_rsvd;
	u64 global_status_rsvd;
	u64 reserved_bits;
	u64 raw_event_mask;
	struct kvm_pmc gp_counters[8];
	struct kvm_pmc fixed_counters[3];
	union {
		long unsigned int reprogram_pmi[1];
		atomic64_t __reprogram_pmi;
	};
	long unsigned int all_valid_pmc_idx[1];
	long unsigned int pmc_in_use[1];
	u64 ds_area;
	u64 pebs_enable;
	u64 pebs_enable_rsvd;
	u64 pebs_data_cfg;
	u64 pebs_data_cfg_rsvd;
	u64 host_cross_mapped_mask;
	bool need_cleanup;
	u8 event_count;
};

struct ptp_pin_desc;

struct ptp_system_timestamp;

struct system_device_crosststamp;

struct ptp_clock_request;

struct ptp_clock_info {
	struct module *owner;
	char name[32];
	s32 max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int n_pins;
	int pps;
	struct ptp_pin_desc *pin_config;
	int (*adjfine)(struct ptp_clock_info *, long int);
	int (*adjphase)(struct ptp_clock_info *, s32);
	s32 (*getmaxphase)(struct ptp_clock_info *);
	int (*adjtime)(struct ptp_clock_info *, s64);
	int (*gettime64)(struct ptp_clock_info *, struct timespec64 *);
	int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*settime64)(struct ptp_clock_info *, const struct timespec64 *);
	int (*getcycles64)(struct ptp_clock_info *, struct timespec64 *);
	int (*getcyclesx64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosscycles)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int);
	int (*verify)(struct ptp_clock_info *, unsigned int, enum ptp_pin_function, unsigned int);
	long int (*do_aux_work)(struct ptp_clock_info *);
};

struct ptp_clock;

struct kvm_ptp_clock {
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info caps;
};

struct kvm_queued_exception {
	bool pending;
	bool injected;
	bool has_error_code;
	u8 vector;
	u32 error_code;
	long unsigned int payload;
	bool has_payload;
};

struct kvm_queued_interrupt {
	bool injected;
	bool soft;
	u8 nr;
};

struct kvm_regs {
	__u64 rax;
	__u64 rbx;
	__u64 rcx;
	__u64 rdx;
	__u64 rsi;
	__u64 rdi;
	__u64 rsp;
	__u64 rbp;
	__u64 r8;
	__u64 r9;
	__u64 r10;
	__u64 r11;
	__u64 r12;
	__u64 r13;
	__u64 r14;
	__u64 r15;
	__u64 rip;
	__u64 rflags;
};

struct kvm_rmap_head {
	long unsigned int val;
};

struct kvm_xen_exit {
	__u32 type;
	union {
		struct {
			__u32 longmode;
			__u32 cpl;
			__u64 input;
			__u64 result;
			__u64 params[6];
		} hcall;
	} u;
};

struct kvm_segment {
	__u64 base;
	__u32 limit;
	__u16 selector;
	__u8 type;
	__u8 present;
	__u8 dpl;
	__u8 db;
	__u8 s;
	__u8 l;
	__u8 g;
	__u8 avl;
	__u8 unusable;
	__u8 padding;
};

struct kvm_sregs {
	struct kvm_segment cs;
	struct kvm_segment ds;
	struct kvm_segment es;
	struct kvm_segment fs;
	struct kvm_segment gs;
	struct kvm_segment ss;
	struct kvm_segment tr;
	struct kvm_segment ldt;
	struct kvm_dtable gdt;
	struct kvm_dtable idt;
	__u64 cr0;
	__u64 cr2;
	__u64 cr3;
	__u64 cr4;
	__u64 cr8;
	__u64 efer;
	__u64 apic_base;
	__u64 interrupt_bitmap[4];
};

struct kvm_vcpu_events {
	struct {
		__u8 injected;
		__u8 nr;
		__u8 has_error_code;
		__u8 pending;
		__u32 error_code;
	} exception;
	struct {
		__u8 injected;
		__u8 nr;
		__u8 soft;
		__u8 shadow;
	} interrupt;
	struct {
		__u8 injected;
		__u8 pending;
		__u8 masked;
		__u8 pad;
	} nmi;
	__u32 sipi_vector;
	__u32 flags;
	struct {
		__u8 smm;
		__u8 pending;
		__u8 smm_inside_nmi;
		__u8 latched_init;
	} smi;
	struct {
		__u8 pending;
	} triple_fault;
	__u8 reserved[26];
	__u8 exception_has_payload;
	__u64 exception_payload;
};

struct kvm_sync_regs {
	struct kvm_regs regs;
	struct kvm_sregs sregs;
	struct kvm_vcpu_events events;
};

struct kvm_run {
	__u8 request_interrupt_window;
	__u8 immediate_exit__unsafe;
	__u8 padding1[6];
	__u32 exit_reason;
	__u8 ready_for_interrupt_injection;
	__u8 if_flag;
	__u16 flags;
	__u64 cr8;
	__u64 apic_base;
	union {
		struct {
			__u64 hardware_exit_reason;
		} hw;
		struct {
			__u64 hardware_entry_failure_reason;
			__u32 cpu;
		} fail_entry;
		struct {
			__u32 exception;
			__u32 error_code;
		} ex;
		struct {
			__u8 direction;
			__u8 size;
			__u16 port;
			__u32 count;
			__u64 data_offset;
		} io;
		struct {
			struct kvm_debug_exit_arch arch;
		} debug;
		struct {
			__u64 phys_addr;
			__u8 data[8];
			__u32 len;
			__u8 is_write;
		} mmio;
		struct {
			__u64 phys_addr;
			__u8 data[8];
			__u32 len;
			__u8 is_write;
		} iocsr_io;
		struct {
			__u64 nr;
			__u64 args[6];
			__u64 ret;
			union {
				__u64 flags;
			};
		} hypercall;
		struct {
			__u64 rip;
			__u32 is_write;
			__u32 pad;
		} tpr_access;
		struct {
			__u8 icptcode;
			__u16 ipa;
			__u32 ipb;
		} s390_sieic;
		__u64 s390_reset_flags;
		struct {
			__u64 trans_exc_code;
			__u32 pgm_code;
		} s390_ucontrol;
		struct {
			__u32 dcrn;
			__u32 data;
			__u8 is_write;
		} dcr;
		struct {
			__u32 suberror;
			__u32 ndata;
			__u64 data[16];
		} internal;
		struct {
			__u32 suberror;
			__u32 ndata;
			__u64 flags;
			union {
				struct {
					__u8 insn_size;
					__u8 insn_bytes[15];
				};
			};
		} emulation_failure;
		struct {
			__u64 gprs[32];
		} osi;
		struct {
			__u64 nr;
			__u64 ret;
			__u64 args[9];
		} papr_hcall;
		struct {
			__u16 subchannel_id;
			__u16 subchannel_nr;
			__u32 io_int_parm;
			__u32 io_int_word;
			__u32 ipb;
			__u8 dequeued;
		} s390_tsch;
		struct {
			__u32 epr;
		} epr;
		struct {
			__u32 type;
			__u32 ndata;
			union {
				__u64 data[16];
			};
		} system_event;
		struct {
			__u64 addr;
			__u8 ar;
			__u8 reserved;
			__u8 fc;
			__u8 sel1;
			__u16 sel2;
		} s390_stsi;
		struct {
			__u8 vector;
		} eoi;
		struct kvm_hyperv_exit hyperv;
		struct {
			__u64 esr_iss;
			__u64 fault_ipa;
		} arm_nisv;
		struct {
			__u8 error;
			__u8 pad[7];
			__u32 reason;
			__u32 index;
			__u64 data;
		} msr;
		struct kvm_xen_exit xen;
		struct {
			long unsigned int extension_id;
			long unsigned int function_id;
			long unsigned int args[6];
			long unsigned int ret[2];
		} riscv_sbi;
		struct {
			long unsigned int csr_num;
			long unsigned int new_value;
			long unsigned int write_mask;
			long unsigned int ret_value;
		} riscv_csr;
		struct {
			__u32 flags;
		} notify;
		struct {
			__u64 flags;
			__u64 gpa;
			__u64 size;
		} memory_fault;
		char padding[256];
	};
	__u64 kvm_valid_regs;
	__u64 kvm_dirty_regs;
	union {
		struct kvm_sync_regs regs;
		char padding[2048];
	} s;
};

struct kvm_stat_data {
	struct kvm *kvm;
	const struct _kvm_stats_desc *desc;
	enum kvm_stat_kind kind;
};

struct kvm_steal_time {
	__u64 steal;
	__u32 version;
	__u32 flags;
	__u8 preempted;
	__u8 u8_pad[3];
	__u32 pad[11];
};

struct kvm_task_sleep_head {
	raw_spinlock_t lock;
	struct hlist_head list;
};

struct kvm_task_sleep_node {
	struct hlist_node link;
	struct swait_queue_head wq;
	u32 token;
	int cpu;
};

struct preempt_ops;

struct preempt_notifier {
	struct hlist_node link;
	struct preempt_ops *ops;
};

struct x86_emulate_ctxt;

struct pvclock_vcpu_time_info {
	u32 version;
	u32 pad0;
	u64 tsc_timestamp;
	u64 system_time;
	u32 tsc_to_system_mul;
	s8 tsc_shift;
	u8 flags;
	u8 pad[2];
};

struct kvm_vcpu_hv;

struct kvm_vcpu_arch {
	long unsigned int regs[17];
	u32 regs_avail;
	u32 regs_dirty;
	long unsigned int cr0;
	long unsigned int cr0_guest_owned_bits;
	long unsigned int cr2;
	long unsigned int cr3;
	long unsigned int cr4;
	long unsigned int cr4_guest_owned_bits;
	long unsigned int cr4_guest_rsvd_bits;
	long unsigned int cr8;
	u32 host_pkru;
	u32 pkru;
	u32 hflags;
	u64 efer;
	u64 host_debugctl;
	u64 apic_base;
	struct kvm_lapic *apic;
	bool load_eoi_exitmap_pending;
	long unsigned int ioapic_handled_vectors[4];
	long unsigned int apic_attention;
	int32_t apic_arb_prio;
	int mp_state;
	u64 ia32_misc_enable_msr;
	u64 smbase;
	u64 smi_count;
	bool at_instruction_boundary;
	bool tpr_access_reporting;
	bool xfd_no_write_intercept;
	u64 ia32_xss;
	u64 microcode_version;
	u64 arch_capabilities;
	u64 perf_capabilities;
	struct kvm_mmu *mmu;
	struct kvm_mmu root_mmu;
	struct kvm_mmu guest_mmu;
	struct kvm_mmu nested_mmu;
	struct kvm_mmu *walk_mmu;
	struct kvm_mmu_memory_cache mmu_pte_list_desc_cache;
	struct kvm_mmu_memory_cache mmu_shadow_page_cache;
	struct kvm_mmu_memory_cache mmu_shadowed_info_cache;
	struct kvm_mmu_memory_cache mmu_page_header_cache;
	struct kvm_mmu_memory_cache mmu_external_spt_cache;
	struct fpu_guest guest_fpu;
	u64 xcr0;
	u64 guest_supported_xcr0;
	struct kvm_pio_request pio;
	void *pio_data;
	void *sev_pio_data;
	unsigned int sev_pio_count;
	u8 event_exit_inst_len;
	bool exception_from_userspace;
	struct kvm_queued_exception exception;
	struct kvm_queued_exception exception_vmexit;
	struct kvm_queued_interrupt interrupt;
	int halt_request;
	int cpuid_nent;
	struct kvm_cpuid_entry2 *cpuid_entries;
	bool is_amd_compatible;
	u32 cpu_caps[28];
	u64 reserved_gpa_bits;
	int maxphyaddr;
	struct x86_emulate_ctxt *emulate_ctxt;
	bool emulate_regs_need_sync_to_vcpu;
	bool emulate_regs_need_sync_from_vcpu;
	int (*complete_userspace_io)(struct kvm_vcpu *);
	gpa_t time;
	struct pvclock_vcpu_time_info hv_clock;
	unsigned int hw_tsc_khz;
	struct gfn_to_pfn_cache pv_time;
	bool pvclock_set_guest_stopped_request;
	struct {
		u8 preempted;
		u64 msr_val;
		u64 last_steal;
		struct gfn_to_hva_cache cache;
	} st;
	u64 l1_tsc_offset;
	u64 tsc_offset;
	u64 last_guest_tsc;
	u64 last_host_tsc;
	u64 tsc_offset_adjustment;
	u64 this_tsc_nsec;
	u64 this_tsc_write;
	u64 this_tsc_generation;
	bool tsc_catchup;
	bool tsc_always_catchup;
	s8 virtual_tsc_shift;
	u32 virtual_tsc_mult;
	u32 virtual_tsc_khz;
	s64 ia32_tsc_adjust_msr;
	u64 msr_ia32_power_ctl;
	u64 l1_tsc_scaling_ratio;
	u64 tsc_scaling_ratio;
	atomic_t nmi_queued;
	unsigned int nmi_pending;
	bool nmi_injected;
	bool smi_pending;
	u8 handling_intr_from_guest;
	struct kvm_mtrr mtrr_state;
	u64 pat;
	unsigned int switch_db_regs;
	long unsigned int db[4];
	long unsigned int dr6;
	long unsigned int dr7;
	long unsigned int eff_db[4];
	long unsigned int guest_debug_dr7;
	u64 msr_platform_info;
	u64 msr_misc_features_enables;
	u64 mcg_cap;
	u64 mcg_status;
	u64 mcg_ctl;
	u64 mcg_ext_ctl;
	u64 *mce_banks;
	u64 *mci_ctl2_banks;
	u64 mmio_gva;
	unsigned int mmio_access;
	gfn_t mmio_gfn;
	u64 mmio_gen;
	struct kvm_pmu pmu;
	long unsigned int singlestep_rip;
	bool hyperv_enabled;
	struct kvm_vcpu_hv *hyperv;
	cpumask_var_t wbinvd_dirty_mask;
	long unsigned int last_retry_eip;
	long unsigned int last_retry_addr;
	struct {
		bool halted;
		gfn_t gfns[64];
		struct gfn_to_hva_cache data;
		u64 msr_en_val;
		u64 msr_int_val;
		u16 vec;
		u32 id;
		bool send_user_only;
		u32 host_apf_flags;
		bool delivery_as_pf_vmexit;
		bool pageready_pending;
	} apf;
	struct {
		u64 length;
		u64 status;
	} osvw;
	struct {
		u64 msr_val;
		struct gfn_to_hva_cache data;
	} pv_eoi;
	u64 msr_kvm_poll_control;
	struct {
		bool pv_unhalted;
	} pv;
	int pending_ioapic_eoi;
	int pending_external_vector;
	bool preempted_in_kernel;
	bool l1tf_flush_l1d;
	int last_vmentry_cpu;
	u64 msr_hwcr;
	struct {
		u32 features;
		bool enforce;
	} pv_cpuid;
	bool guest_state_protected;
	bool pdptrs_from_userspace;
};

struct kvm_vcpu_stat_generic {
	u64 halt_successful_poll;
	u64 halt_attempted_poll;
	u64 halt_poll_invalid;
	u64 halt_wakeup;
	u64 halt_poll_success_ns;
	u64 halt_poll_fail_ns;
	u64 halt_wait_ns;
	u64 halt_poll_success_hist[32];
	u64 halt_poll_fail_hist[32];
	u64 halt_wait_hist[32];
	u64 blocking;
};

struct kvm_vcpu_stat {
	struct kvm_vcpu_stat_generic generic;
	u64 pf_taken;
	u64 pf_fixed;
	u64 pf_emulate;
	u64 pf_spurious;
	u64 pf_fast;
	u64 pf_mmio_spte_created;
	u64 pf_guest;
	u64 tlb_flush;
	u64 invlpg;
	u64 exits;
	u64 io_exits;
	u64 mmio_exits;
	u64 signal_exits;
	u64 irq_window_exits;
	u64 nmi_window_exits;
	u64 l1d_flush;
	u64 halt_exits;
	u64 request_irq_exits;
	u64 irq_exits;
	u64 host_state_reload;
	u64 fpu_reload;
	u64 insn_emulation;
	u64 insn_emulation_fail;
	u64 hypercalls;
	u64 irq_injections;
	u64 nmi_injections;
	u64 req_event;
	u64 nested_run;
	u64 directed_yield_attempted;
	u64 directed_yield_successful;
	u64 preemption_reported;
	u64 preemption_other;
	u64 guest_mode;
	u64 notify_window_exits;
};

struct kvm_vcpu {
	struct kvm *kvm;
	struct preempt_notifier preempt_notifier;
	int cpu;
	int vcpu_id;
	int vcpu_idx;
	int ____srcu_idx;
	int mode;
	u64 requests;
	long unsigned int guest_debug;
	struct mutex mutex;
	struct kvm_run *run;
	struct rcuwait wait;
	struct pid *pid;
	rwlock_t pid_lock;
	int sigset_active;
	sigset_t sigset;
	unsigned int halt_poll_ns;
	bool valid_wakeup;
	int mmio_needed;
	int mmio_read_completed;
	int mmio_is_write;
	int mmio_cur_fragment;
	int mmio_nr_fragments;
	struct kvm_mmio_fragment mmio_fragments[2];
	struct {
		u32 queued;
		struct list_head queue;
		struct list_head done;
		spinlock_t lock;
	} async_pf;
	struct {
		bool in_spin_loop;
		bool dy_eligible;
	} spin_loop;
	bool wants_to_run;
	bool preempted;
	bool ready;
	bool scheduled_out;
	struct kvm_vcpu_arch arch;
	struct kvm_vcpu_stat stat;
	char stats_id[48];
	struct kvm_dirty_ring dirty_ring;
	struct kvm_memory_slot *last_used_slot;
	u64 last_used_slot_gen;
};

struct kvm_vcpu_hv_synic {
	u64 version;
	u64 control;
	u64 msg_page;
	u64 evt_page;
	atomic64_t sint[16];
	atomic_t sint_to_gsi[16];
	long unsigned int auto_eoi_bitmap[4];
	long unsigned int vec_bitmap[4];
	bool active;
	bool dont_zero_synic_pages;
};

struct kvm_vcpu_hv_stimer {
	struct hrtimer timer;
	int index;
	union hv_stimer_config config;
	u64 count;
	u64 exp_time;
	struct hv_message msg;
	bool msg_pending;
};

struct kvm_vcpu_hv_tlb_flush_fifo {
	spinlock_t write_lock;
	struct {
		union {
			struct __kfifo kfifo;
			u64 *type;
			const u64 *const_type;
			char (*rectype)[0];
			u64 *ptr;
			const u64 *ptr_const;
		};
		u64 buf[16];
	} entries;
};

struct kvm_vcpu_hv {
	struct kvm_vcpu *vcpu;
	u32 vp_index;
	u64 hv_vapic;
	s64 runtime_offset;
	struct kvm_vcpu_hv_synic synic;
	struct kvm_hyperv_exit exit;
	struct kvm_vcpu_hv_stimer stimer[4];
	long unsigned int stimer_pending_bitmap[1];
	bool enforce_cpuid;
	struct {
		u32 features_eax;
		u32 features_ebx;
		u32 features_edx;
		u32 enlightenments_eax;
		u32 enlightenments_ebx;
		u32 syndbg_cap_eax;
		u32 nested_eax;
		u32 nested_ebx;
	} cpuid_cache;
	struct kvm_vcpu_hv_tlb_flush_fifo tlb_flush_fifo[2];
	u64 sparse_banks[64];
	struct hv_vp_assist_page vp_assist_page;
	struct {
		u64 pa_page_gpa;
		u64 vm_id;
		u32 vp_id;
	} nested;
};

struct kvm_vcpu_pv_apf_data {
	__u32 flags;
	__u32 token;
	__u8 pad[56];
};

struct msr_bitmap_range {
	u32 flags;
	u32 nmsrs;
	u32 base;
	long unsigned int *bitmap;
};

struct kvm_x86_msr_filter {
	u8 count;
	bool default_allow: 1;
	struct msr_bitmap_range ranges[16];
};

struct kvm_x86_nested_ops {
	void (*leave_nested)(struct kvm_vcpu *);
	bool (*is_exception_vmexit)(struct kvm_vcpu *, u8, u32);
	int (*check_events)(struct kvm_vcpu *);
	bool (*has_events)(struct kvm_vcpu *, bool);
	void (*triple_fault)(struct kvm_vcpu *);
	int (*get_state)(struct kvm_vcpu *, struct kvm_nested_state *, unsigned int);
	int (*set_state)(struct kvm_vcpu *, struct kvm_nested_state *, struct kvm_nested_state *);
	bool (*get_nested_state_pages)(struct kvm_vcpu *);
	int (*write_log_dirty)(struct kvm_vcpu *, gpa_t);
	int (*enable_evmcs)(struct kvm_vcpu *, uint16_t *);
	uint16_t (*get_evmcs_version)(struct kvm_vcpu *);
	void (*hv_inject_synthetic_vmexit_post_tlb_flush)(struct kvm_vcpu *);
};

typedef void cpu_emergency_virt_cb(void);

struct x86_instruction_info;

union kvm_smram;

struct msr_data;

struct kvm_x86_ops {
	const char *name;
	int (*check_processor_compatibility)(void);
	int (*enable_virtualization_cpu)(void);
	void (*disable_virtualization_cpu)(void);
	cpu_emergency_virt_cb *emergency_disable_virtualization_cpu;
	void (*hardware_unsetup)(void);
	bool (*has_emulated_msr)(struct kvm *, u32);
	void (*vcpu_after_set_cpuid)(struct kvm_vcpu *);
	unsigned int vm_size;
	int (*vm_init)(struct kvm *);
	void (*vm_destroy)(struct kvm *);
	int (*vcpu_precreate)(struct kvm *);
	int (*vcpu_create)(struct kvm_vcpu *);
	void (*vcpu_free)(struct kvm_vcpu *);
	void (*vcpu_reset)(struct kvm_vcpu *, bool);
	void (*prepare_switch_to_guest)(struct kvm_vcpu *);
	void (*vcpu_load)(struct kvm_vcpu *, int);
	void (*vcpu_put)(struct kvm_vcpu *);
	void (*update_exception_bitmap)(struct kvm_vcpu *);
	int (*get_msr)(struct kvm_vcpu *, struct msr_data *);
	int (*set_msr)(struct kvm_vcpu *, struct msr_data *);
	u64 (*get_segment_base)(struct kvm_vcpu *, int);
	void (*get_segment)(struct kvm_vcpu *, struct kvm_segment *, int);
	int (*get_cpl)(struct kvm_vcpu *);
	int (*get_cpl_no_cache)(struct kvm_vcpu *);
	void (*set_segment)(struct kvm_vcpu *, struct kvm_segment *, int);
	void (*get_cs_db_l_bits)(struct kvm_vcpu *, int *, int *);
	bool (*is_valid_cr0)(struct kvm_vcpu *, long unsigned int);
	void (*set_cr0)(struct kvm_vcpu *, long unsigned int);
	void (*post_set_cr3)(struct kvm_vcpu *, long unsigned int);
	bool (*is_valid_cr4)(struct kvm_vcpu *, long unsigned int);
	void (*set_cr4)(struct kvm_vcpu *, long unsigned int);
	int (*set_efer)(struct kvm_vcpu *, u64);
	void (*get_idt)(struct kvm_vcpu *, struct desc_ptr *);
	void (*set_idt)(struct kvm_vcpu *, struct desc_ptr *);
	void (*get_gdt)(struct kvm_vcpu *, struct desc_ptr *);
	void (*set_gdt)(struct kvm_vcpu *, struct desc_ptr *);
	void (*sync_dirty_debug_regs)(struct kvm_vcpu *);
	void (*set_dr6)(struct kvm_vcpu *, long unsigned int);
	void (*set_dr7)(struct kvm_vcpu *, long unsigned int);
	void (*cache_reg)(struct kvm_vcpu *, enum kvm_reg);
	long unsigned int (*get_rflags)(struct kvm_vcpu *);
	void (*set_rflags)(struct kvm_vcpu *, long unsigned int);
	bool (*get_if_flag)(struct kvm_vcpu *);
	void (*flush_tlb_all)(struct kvm_vcpu *);
	void (*flush_tlb_current)(struct kvm_vcpu *);
	void (*flush_tlb_gva)(struct kvm_vcpu *, gva_t);
	void (*flush_tlb_guest)(struct kvm_vcpu *);
	int (*vcpu_pre_run)(struct kvm_vcpu *);
	enum exit_fastpath_completion (*vcpu_run)(struct kvm_vcpu *, bool);
	int (*handle_exit)(struct kvm_vcpu *, enum exit_fastpath_completion);
	int (*skip_emulated_instruction)(struct kvm_vcpu *);
	void (*update_emulated_instruction)(struct kvm_vcpu *);
	void (*set_interrupt_shadow)(struct kvm_vcpu *, int);
	u32 (*get_interrupt_shadow)(struct kvm_vcpu *);
	void (*patch_hypercall)(struct kvm_vcpu *, unsigned char *);
	void (*inject_irq)(struct kvm_vcpu *, bool);
	void (*inject_nmi)(struct kvm_vcpu *);
	void (*inject_exception)(struct kvm_vcpu *);
	void (*cancel_injection)(struct kvm_vcpu *);
	int (*interrupt_allowed)(struct kvm_vcpu *, bool);
	int (*nmi_allowed)(struct kvm_vcpu *, bool);
	bool (*get_nmi_mask)(struct kvm_vcpu *);
	void (*set_nmi_mask)(struct kvm_vcpu *, bool);
	bool (*is_vnmi_pending)(struct kvm_vcpu *);
	bool (*set_vnmi_pending)(struct kvm_vcpu *);
	void (*enable_nmi_window)(struct kvm_vcpu *);
	void (*enable_irq_window)(struct kvm_vcpu *);
	void (*update_cr8_intercept)(struct kvm_vcpu *, int, int);
	const bool x2apic_icr_is_split;
	const long unsigned int required_apicv_inhibits;
	bool allow_apicv_in_x2apic_without_x2apic_virtualization;
	void (*refresh_apicv_exec_ctrl)(struct kvm_vcpu *);
	void (*hwapic_isr_update)(struct kvm_vcpu *, int);
	void (*load_eoi_exitmap)(struct kvm_vcpu *, u64 *);
	void (*set_virtual_apic_mode)(struct kvm_vcpu *);
	void (*set_apic_access_page_addr)(struct kvm_vcpu *);
	void (*deliver_interrupt)(struct kvm_lapic *, int, int, int);
	int (*sync_pir_to_irr)(struct kvm_vcpu *);
	int (*set_tss_addr)(struct kvm *, unsigned int);
	int (*set_identity_map_addr)(struct kvm *, u64);
	u8 (*get_mt_mask)(struct kvm_vcpu *, gfn_t, bool);
	void (*load_mmu_pgd)(struct kvm_vcpu *, hpa_t, int);
	int (*link_external_spt)(struct kvm *, gfn_t, enum pg_level, void *);
	int (*set_external_spte)(struct kvm *, gfn_t, enum pg_level, kvm_pfn_t);
	int (*free_external_spt)(struct kvm *, gfn_t, enum pg_level, void *);
	int (*remove_external_spte)(struct kvm *, gfn_t, enum pg_level, kvm_pfn_t);
	bool (*has_wbinvd_exit)(void);
	u64 (*get_l2_tsc_offset)(struct kvm_vcpu *);
	u64 (*get_l2_tsc_multiplier)(struct kvm_vcpu *);
	void (*write_tsc_offset)(struct kvm_vcpu *);
	void (*write_tsc_multiplier)(struct kvm_vcpu *);
	void (*get_exit_info)(struct kvm_vcpu *, u32 *, u64 *, u64 *, u32 *, u32 *);
	void (*get_entry_info)(struct kvm_vcpu *, u32 *, u32 *);
	int (*check_intercept)(struct kvm_vcpu *, struct x86_instruction_info *, enum x86_intercept_stage, struct x86_exception *);
	void (*handle_exit_irqoff)(struct kvm_vcpu *);
	int cpu_dirty_log_size;
	void (*update_cpu_dirty_logging)(struct kvm_vcpu *);
	const struct kvm_x86_nested_ops *nested_ops;
	void (*vcpu_blocking)(struct kvm_vcpu *);
	void (*vcpu_unblocking)(struct kvm_vcpu *);
	int (*pi_update_irte)(struct kvm *, unsigned int, uint32_t, bool);
	void (*pi_start_assignment)(struct kvm *);
	void (*apicv_pre_state_restore)(struct kvm_vcpu *);
	void (*apicv_post_state_restore)(struct kvm_vcpu *);
	bool (*dy_apicv_has_pending_interrupt)(struct kvm_vcpu *);
	int (*set_hv_timer)(struct kvm_vcpu *, u64, bool *);
	void (*cancel_hv_timer)(struct kvm_vcpu *);
	void (*setup_mce)(struct kvm_vcpu *);
	int (*smi_allowed)(struct kvm_vcpu *, bool);
	int (*enter_smm)(struct kvm_vcpu *, union kvm_smram *);
	int (*leave_smm)(struct kvm_vcpu *, const union kvm_smram *);
	void (*enable_smi_window)(struct kvm_vcpu *);
	int (*dev_get_attr)(u32, u64, u64 *);
	int (*mem_enc_ioctl)(struct kvm *, void *);
	int (*mem_enc_register_region)(struct kvm *, struct kvm_enc_region *);
	int (*mem_enc_unregister_region)(struct kvm *, struct kvm_enc_region *);
	int (*vm_copy_enc_context_from)(struct kvm *, unsigned int);
	int (*vm_move_enc_context_from)(struct kvm *, unsigned int);
	void (*guest_memory_reclaimed)(struct kvm *);
	int (*get_feature_msr)(u32, u64 *);
	int (*check_emulate_instruction)(struct kvm_vcpu *, int, void *, int);
	bool (*apic_init_signal_blocked)(struct kvm_vcpu *);
	int (*enable_l2_tlb_flush)(struct kvm_vcpu *);
	void (*migrate_timers)(struct kvm_vcpu *);
	void (*msr_filter_changed)(struct kvm_vcpu *);
	int (*complete_emulated_msr)(struct kvm_vcpu *, int);
	void (*vcpu_deliver_sipi_vector)(struct kvm_vcpu *, u8);
	long unsigned int (*vcpu_get_apicv_inhibit_reasons)(struct kvm_vcpu *);
	gva_t (*get_untagged_addr)(struct kvm_vcpu *, gva_t, unsigned int);
	void * (*alloc_apic_backing_page)(struct kvm_vcpu *);
	int (*gmem_prepare)(struct kvm *, kvm_pfn_t, gfn_t, int);
	void (*gmem_invalidate)(kvm_pfn_t, kvm_pfn_t);
	int (*private_max_mapping_level)(struct kvm *, kvm_pfn_t);
};

struct kvm_x86_pmu_event_filter {
	__u32 action;
	__u32 nevents;
	__u32 fixed_counter_bitmap;
	__u32 flags;
	__u32 nr_includes;
	__u32 nr_excludes;
	__u64 *includes;
	__u64 *excludes;
	__u64 events[0];
};

struct kyber_cpu_latency {
	atomic_t buckets[48];
};

struct kyber_ctx_queue {
	spinlock_t lock;
	struct list_head rq_list[4];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbq_wait {
	struct sbitmap_queue *sbq;
	struct wait_queue_entry wait;
};

struct kyber_hctx_data {
	spinlock_t lock;
	struct list_head rqs[4];
	unsigned int cur_domain;
	unsigned int batching;
	struct kyber_ctx_queue *kcqs;
	struct sbitmap kcq_map[4];
	struct sbq_wait domain_wait[4];
	struct sbq_wait_state *domain_ws[4];
	atomic_t wait_index[4];
};

struct kyber_queue_data {
	struct request_queue *q;
	dev_t dev;
	struct sbitmap_queue domain_tokens[4];
	unsigned int async_depth;
	struct kyber_cpu_latency *cpu_latency;
	struct timer_list timer;
	unsigned int latency_buckets[48];
	long unsigned int latency_timeout[3];
	int domain_p99[3];
	u64 latency_targets[3];
};

union l1_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 8;
		unsigned int assoc: 8;
		unsigned int size_in_kb: 8;
	};
	unsigned int val;
};

union l2_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 4;
		unsigned int assoc: 4;
		unsigned int size_in_kb: 16;
	};
	unsigned int val;
};

struct l2tp_data {
	u32 tid;
	u32 sid;
	u8 type;
	u8 version;
};

struct l2tp_session;

struct l2tp_eth {
	struct l2tp_session *session;
};

struct l2tp_eth_sess {
	struct net_device *dev;
};

struct l2tp_ip6_net {
	rwlock_t l2tp_ip6_lock;
	struct hlist_head l2tp_ip6_table;
	struct hlist_head l2tp_ip6_bind_table;
};

struct l2tp_ip6_sock {
	struct inet_sock inet;
	u32 conn_id;
	u32 peer_conn_id;
	struct ipv6_pinfo inet6;
};

struct l2tp_ip_net {
	rwlock_t l2tp_ip_lock;
	struct hlist_head l2tp_ip_table;
	struct hlist_head l2tp_ip_bind_table;
};

struct l2tp_ip_sock {
	struct inet_sock inet;
	u32 conn_id;
	u32 peer_conn_id;
};

struct l2tp_net {
	spinlock_t l2tp_tunnel_idr_lock;
	struct idr l2tp_tunnel_idr;
	spinlock_t l2tp_session_idr_lock;
	struct idr l2tp_v2_session_idr;
	struct idr l2tp_v3_session_idr;
	struct hlist_head l2tp_v3_session_htable[16];
};

struct l2tp_nl_cb_data {
	long unsigned int tkey;
	long unsigned int skey;
};

struct l2tp_tunnel;

struct l2tp_session_cfg;

struct l2tp_nl_cmd_ops {
	int (*session_create)(struct net *, struct l2tp_tunnel *, u32, u32, struct l2tp_session_cfg *);
	void (*session_delete)(struct l2tp_session *);
};

struct l2tp_stats {
	atomic_long_t tx_packets;
	atomic_long_t tx_bytes;
	atomic_long_t tx_errors;
	atomic_long_t rx_packets;
	atomic_long_t rx_bytes;
	atomic_long_t rx_seq_discards;
	atomic_long_t rx_oos_packets;
	atomic_long_t rx_errors;
	atomic_long_t rx_cookie_discards;
	atomic_long_t rx_invalid;
};

struct l2tp_session_coll_list;

struct l2tp_session {
	int magic;
	long int dead;
	struct callback_head rcu;
	struct l2tp_tunnel *tunnel;
	u32 session_id;
	u32 peer_session_id;
	u8 cookie[8];
	int cookie_len;
	u8 peer_cookie[8];
	int peer_cookie_len;
	u16 l2specific_type;
	u16 hdr_len;
	u32 nr;
	u32 ns;
	struct sk_buff_head reorder_q;
	u32 nr_max;
	u32 nr_window_size;
	u32 nr_oos;
	int nr_oos_count;
	int nr_oos_count_max;
	struct list_head list;
	refcount_t ref_count;
	struct hlist_node hlist;
	long unsigned int hlist_key;
	struct l2tp_session_coll_list *coll_list;
	struct list_head clist;
	char name[32];
	char ifname[16];
	unsigned int recv_seq: 1;
	unsigned int send_seq: 1;
	unsigned int lns_mode: 1;
	int reorder_timeout;
	int reorder_skip;
	enum l2tp_pwtype pwtype;
	struct l2tp_stats stats;
	struct work_struct del_work;
	void (*recv_skb)(struct l2tp_session *, struct sk_buff *, int);
	void (*session_close)(struct l2tp_session *);
	void (*show)(struct seq_file *, void *);
	u8 priv[0];
};

struct l2tp_session_cfg {
	enum l2tp_pwtype pw_type;
	unsigned int recv_seq: 1;
	unsigned int send_seq: 1;
	unsigned int lns_mode: 1;
	u16 l2specific_type;
	u8 cookie[8];
	int cookie_len;
	u8 peer_cookie[8];
	int peer_cookie_len;
	int reorder_timeout;
	char *ifname;
};

struct l2tp_session_coll_list {
	spinlock_t lock;
	struct list_head list;
	refcount_t ref_count;
};

struct l2tp_skb_cb {
	u32 ns;
	u16 has_seq;
	u16 length;
	long unsigned int expires;
};

struct l2tp_tunnel {
	long unsigned int dead;
	struct callback_head rcu;
	spinlock_t list_lock;
	bool acpt_newsess;
	struct list_head session_list;
	u32 tunnel_id;
	u32 peer_tunnel_id;
	int version;
	char name[20];
	enum l2tp_encap_type encap;
	struct l2tp_stats stats;
	struct net *l2tp_net;
	refcount_t ref_count;
	struct sock *sock;
	int fd;
	struct work_struct del_work;
};

struct l2tp_tunnel_cfg {
	enum l2tp_encap_type encap;
	struct in_addr local_ip;
	struct in_addr peer_ip;
	struct in6_addr *local_ip6;
	struct in6_addr *peer_ip6;
	u16 local_udp_port;
	u16 peer_udp_port;
	unsigned int use_udp_checksums: 1;
	unsigned int udp6_zero_tx_checksums: 1;
	unsigned int udp6_zero_rx_checksums: 1;
};

union l2tp_val {
	__be16 val16[2];
	__be32 val32;
};

union l3_cache {
	struct {
		unsigned int line_size: 8;
		unsigned int lines_per_tag: 4;
		unsigned int assoc: 4;
		unsigned int res: 2;
		unsigned int size_encoded: 14;
	};
	unsigned int val;
};

typedef int (*lookup_by_table_id_t)(struct net *, u32);

struct l3mdev_handler {
	lookup_by_table_id_t dev_lookup;
};

struct l3mdev_ops {
	u32 (*l3mdev_fib_table)(const struct net_device *);
	struct sk_buff * (*l3mdev_l3_rcv)(struct net_device *, struct sk_buff *, u16);
	struct sk_buff * (*l3mdev_l3_out)(struct net_device *, struct sock *, struct sk_buff *, u16);
	struct dst_entry * (*l3mdev_link_scope_lookup)(const struct net_device *, struct flowi6 *);
};

struct lane2_ops {
	int (*resolve)(struct net_device *, const u8 *, int, u8 **, u32 *);
	int (*associate_req)(struct net_device *, const u8 *, const u8 *, u32);
	void (*associate_indicator)(struct net_device *, const u8 *, const u8 *, u32);
};

struct lapb_frame {
	short unsigned int type;
	short unsigned int nr;
	short unsigned int ns;
	unsigned char cr;
	unsigned char pf;
	unsigned char control[2];
};

struct lapb_register_struct;

struct lapb_cb {
	struct list_head node;
	struct net_device *dev;
	unsigned int mode;
	unsigned char state;
	short unsigned int vs;
	short unsigned int vr;
	short unsigned int va;
	unsigned char condition;
	short unsigned int n2;
	short unsigned int n2count;
	short unsigned int t1;
	short unsigned int t2;
	struct timer_list t1timer;
	struct timer_list t2timer;
	bool t1timer_running;
	bool t2timer_running;
	struct sk_buff_head write_queue;
	struct sk_buff_head ack_queue;
	unsigned char window;
	const struct lapb_register_struct *callbacks;
	struct lapb_frame frmr_data;
	unsigned char frmr_type;
	spinlock_t lock;
	refcount_t refcnt;
};

struct lapb_parms_struct {
	unsigned int t1;
	unsigned int t1timer;
	unsigned int t2;
	unsigned int t2timer;
	unsigned int n2;
	unsigned int n2count;
	unsigned int window;
	unsigned int state;
	unsigned int mode;
};

struct lapb_register_struct {
	void (*connect_confirmation)(struct net_device *, int);
	void (*connect_indication)(struct net_device *, int);
	void (*disconnect_confirmation)(struct net_device *, int);
	void (*disconnect_indication)(struct net_device *, int);
	int (*data_indication)(struct net_device *, struct sk_buff *);
	void (*data_transmit)(struct net_device *, struct sk_buff *);
};

struct latch_tree_ops {
	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
	int (*comp)(void *, struct latch_tree_node *);
};

struct latch_tree_root {
	seqcount_latch_t seq;
	struct rb_root tree[2];
};

struct latched_seq {
	seqcount_latch_t latch;
	u64 val[2];
};

struct sched_domain;

struct lb_env {
	struct sched_domain *sd;
	struct rq *src_rq;
	int src_cpu;
	int dst_cpu;
	struct rq *dst_rq;
	struct cpumask *dst_grpmask;
	int new_dst_cpu;
	enum cpu_idle_type idle;
	long int imbalance;
	struct cpumask *cpus;
	unsigned int flags;
	unsigned int loop;
	unsigned int loop_break;
	unsigned int loop_max;
	enum fbq_type fbq_type;
	enum migration_type migration_type;
	struct list_head tasks;
};

struct ld_semaphore {
	atomic_long_t count;
	raw_spinlock_t wait_lock;
	unsigned int wait_readers;
	struct list_head read_wait;
	struct list_head write_wait;
};

struct ldsem_waiter {
	struct list_head list;
	struct task_struct *task;
};

struct ldt_struct {
	struct desc_struct *entries;
	unsigned int nr_entries;
	int slot;
};

struct ldttss_desc {
	u16 limit0;
	u16 base0;
	u16 base1: 8;
	u16 type: 5;
	u16 dpl: 2;
	u16 p: 1;
	u16 limit1: 4;
	u16 zero0: 3;
	u16 g: 1;
	u16 base2: 8;
	u32 base3;
	u32 zero1;
};

typedef struct ldttss_desc ldt_desc;

typedef struct ldttss_desc tss_desc;

struct lease_manager_operations {
	bool (*lm_break)(struct file_lease *);
	int (*lm_change)(struct file_lease *, int, struct list_head *);
	void (*lm_setup)(struct file_lease *, void **);
	bool (*lm_breaker_owns_lease)(struct file_lease *);
};

struct lec_priv;

struct lec_arp_table {
	struct hlist_node next;
	unsigned char atm_addr[20];
	unsigned char mac_addr[6];
	int is_rdesc;
	struct atm_vcc *vcc;
	struct atm_vcc *recv_vcc;
	void (*old_push)(struct atm_vcc *, struct sk_buff *);
	void (*old_recv_push)(struct atm_vcc *, struct sk_buff *);
	long unsigned int last_used;
	long unsigned int timestamp;
	unsigned char no_tries;
	unsigned char status;
	short unsigned int flags;
	short unsigned int packets_flooded;
	long unsigned int flush_tran_id;
	struct timer_list timer;
	struct lec_priv *priv;
	u8 *tlvs;
	u32 sizeoftlvs;
	struct sk_buff_head tx_wait;
	refcount_t usage;
};

struct lec_priv {
	short unsigned int lecid;
	struct hlist_head lec_arp_empty_ones;
	struct hlist_head lec_arp_tables[16];
	struct hlist_head lec_no_forward;
	struct hlist_head mcast_fwds;
	spinlock_t lec_arp_lock;
	struct atm_vcc *mcast_vcc;
	struct atm_vcc *lecd;
	struct delayed_work lec_arp_work;
	unsigned int maximum_unknown_frame_count;
	long unsigned int max_unknown_frame_time;
	long unsigned int vcc_timeout_period;
	short unsigned int max_retry_count;
	long unsigned int aging_time;
	long unsigned int forward_delay_time;
	int topology_change;
	long unsigned int arp_response_time;
	long unsigned int flush_timeout;
	long unsigned int path_switching_delay;
	u8 *tlvs;
	u32 sizeoftlvs;
	int lane_version;
	int itfnum;
	struct lane2_ops *lane2_ops;
	int is_proxy;
};

struct lec_state {
	long unsigned int flags;
	struct lec_priv *locked;
	struct hlist_node *node;
	struct net_device *dev;
	int itf;
	int arp_table;
	int misc_table;
};

struct lec_vcc_priv {
	void (*old_pop)(struct atm_vcc *, struct sk_buff *);
	int xoff;
};

struct lecdatahdr_8023 {
	__be16 le_header;
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_type;
};

struct mc_subled;

struct led_classdev_mc {
	struct led_classdev led_cdev;
	unsigned int num_colors;
	struct mc_subled *subled_info;
};

struct led_hw_trigger_type {
	int dummy;
};

struct led_init_data {
	struct fwnode_handle *fwnode;
	const char *default_label;
	const char *devicename;
	bool devname_mandatory;
};

struct led_lookup_data {
	struct list_head list;
	const char *provider;
	const char *dev_id;
	const char *con_id;
};

struct led_pattern {
	u32 delta_t;
	int brightness;
};

struct led_properties {
	u32 color;
	bool color_present;
	const char *function;
	u32 func_enum;
	bool func_enum_present;
	const char *label;
};

struct legacy_fs_context {
	char *legacy_data;
	size_t data_size;
	enum legacy_fs_param param_type;
};

struct legacy_pic {
	int nr_legacy_irqs;
	struct irq_chip *chip;
	void (*mask)(unsigned int);
	void (*unmask)(unsigned int);
	void (*mask_all)(void);
	void (*restore_mask)(void);
	void (*init)(int);
	int (*probe)(void);
	int (*irq_pending)(unsigned int);
	void (*make_irq)(unsigned int);
};

struct legacy_ring {
	struct intel_gt *gt;
	u8 class;
	u8 instance;
};

struct lifebook_data {
	struct input_dev *dev2;
	char phys[32];
};

struct limit_names {
	const char *name;
	const char *unit;
};

struct linear_c {
	struct dm_dev *dev;
	sector_t start;
};

struct linger {
	int l_onoff;
	int l_linger;
};

struct link_config_limits {
	int min_rate;
	int max_rate;
	int min_lane_count;
	int max_lane_count;
	struct {
		int min_bpp;
		int max_bpp;
	} pipe;
	struct {
		int min_bpp_x16;
		int max_bpp_x16;
	} link;
};

struct link_mode_info {
	int speed;
	u8 lanes;
	u8 duplex;
};

struct linked_page {
	struct linked_page *next;
	char data[4088];
};

struct linked_reg {
	u8 frameno;
	union {
		u8 spi;
		u8 regno;
	};
	bool is_reg;
};

struct linked_regs {
	int cnt;
	struct linked_reg entries[6];
};

struct linkinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
};

struct linkmodes_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
	bool peer_empty;
};

struct linkstate_reply_data {
	struct ethnl_reply_data base;
	int link;
	int sqi;
	int sqi_max;
	struct ethtool_link_ext_stats link_stats;
	bool link_ext_state_provided;
	struct ethtool_link_ext_state_info ethtool_link_ext_state_info;
};

struct linux_binprm;

struct linux_binfmt {
	struct list_head lh;
	struct module *module;
	int (*load_binary)(struct linux_binprm *);
	int (*load_shlib)(struct file *);
	int (*core_dump)(struct coredump_params *);
	long unsigned int min_coredump;
};

struct rlimit {
	__kernel_ulong_t rlim_cur;
	__kernel_ulong_t rlim_max;
};

struct linux_binprm {
	struct vm_area_struct *vma;
	long unsigned int vma_pages;
	long unsigned int argmin;
	struct mm_struct *mm;
	long unsigned int p;
	unsigned int have_execfd: 1;
	unsigned int execfd_creds: 1;
	unsigned int secureexec: 1;
	unsigned int point_of_no_return: 1;
	unsigned int comm_from_dentry: 1;
	unsigned int is_check: 1;
	struct file *executable;
	struct file *interpreter;
	struct file *file;
	struct cred *cred;
	int unsafe;
	unsigned int per_clear;
	int argc;
	int envc;
	const char *filename;
	const char *interp;
	const char *fdpath;
	unsigned int interp_flags;
	int execfd;
	long unsigned int loader;
	long unsigned int exec;
	struct rlimit rlim_stack;
	char buf[256];
};

struct linux_binprm__safe_trusted {
	struct file *file;
};

struct linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_off;
	short unsigned int d_reclen;
	char d_name[0];
};

struct linux_dirent64 {
	u64 d_ino;
	s64 d_off;
	short unsigned int d_reclen;
	unsigned char d_type;
	char d_name[0];
};

struct linux_efi_initrd {
	long unsigned int base;
	long unsigned int size;
};

struct linux_efi_memreserve {
	int size;
	atomic_t count;
	phys_addr_t next;
	struct {
		phys_addr_t base;
		phys_addr_t size;
	} entry[0];
};

struct linux_efi_random_seed {
	u32 size;
	u8 bits[0];
};

struct linux_efi_tpm_eventlog {
	u32 size;
	u32 final_events_preboot_size;
	u8 version;
	u8 log[0];
};

struct linux_mib {
	long unsigned int mibs[133];
};

struct linux_tls_mib {
	long unsigned int mibs[18];
};

struct linux_xfrm_mib {
	long unsigned int mibs[33];
};

struct list_lru_node;

struct list_lru {
	struct list_lru_node *node;
	struct list_head list;
	int shrinker_id;
	bool memcg_aware;
	struct xarray xa;
};

struct list_lru_one {
	struct list_head list;
	long int nr_items;
	spinlock_t lock;
};

struct list_lru_memcg {
	struct callback_head rcu;
	struct list_lru_one node[0];
};

struct list_lru_node {
	struct list_lru_one lru;
	atomic_long_t nr_items;
	long: 64;
	long: 64;
	long: 64;
};

struct list_set {
	u32 size;
	struct timer_list gc;
	struct ip_set *set;
	struct net *net;
	struct list_head members;
};

struct listener {
	struct list_head list;
	pid_t pid;
	char valid;
};

struct listener_list {
	struct rw_semaphore sem;
	struct list_head list;
};

struct listeners {
	struct callback_head rcu;
	long unsigned int masks[0];
};

struct llc_addr {
	unsigned char lsap;
	unsigned char mac[6];
};

struct llc_conn_state_trans;

struct llc_conn_state {
	u8 current_state;
	const struct llc_conn_state_trans **transitions;
};

struct llc_conn_state_ev {
	u8 type;
	u8 prim;
	u8 prim_type;
	u8 reason;
	u8 status;
	u8 ind_prim;
	u8 cfm_prim;
};

typedef int (*llc_conn_ev_t)(struct sock *, struct sk_buff *);

typedef int (*llc_conn_ev_qfyr_t)(struct sock *, struct sk_buff *);

typedef int (*llc_conn_action_t)(struct sock *, struct sk_buff *);

struct llc_conn_state_trans {
	llc_conn_ev_t ev;
	u8 next_state;
	const llc_conn_ev_qfyr_t *ev_qualifiers;
	const llc_conn_action_t *ev_actions;
};

struct llc_frmr_info {
	u16 rej_pdu_ctrl;
	u8 curr_ssv;
	u8 curr_rsv;
	u8 ind_bits;
} __attribute__((packed));

struct llc_pdu_sn {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
	u8 ctrl_2;
};

struct llc_pdu_un {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
};

struct llc_pktinfo {
	int lpi_ifindex;
	unsigned char lpi_sap;
	unsigned char lpi_mac[6];
};

struct llc_sap {
	unsigned char state;
	unsigned char p_bit;
	unsigned char f_bit;
	refcount_t refcnt;
	int (*rcv_func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	struct llc_addr laddr;
	struct list_head node;
	spinlock_t sk_lock;
	int sk_count;
	struct hlist_nulls_head sk_laddr_hash[64];
	struct hlist_head sk_dev_hash[64];
	struct callback_head rcu;
};

struct llc_sap_state_trans;

struct llc_sap_state {
	u8 curr_state;
	const struct llc_sap_state_trans **transitions;
};

struct llc_sap_state_ev {
	u8 prim;
	u8 prim_type;
	u8 type;
	u8 reason;
	u8 ind_cfm_flag;
	struct llc_addr saddr;
	struct llc_addr daddr;
};

typedef int (*llc_sap_ev_t)(struct llc_sap *, struct sk_buff *);

typedef int (*llc_sap_action_t)(struct llc_sap *, struct sk_buff *);

struct llc_sap_state_trans {
	llc_sap_ev_t ev;
	u8 next_state;
	const llc_sap_action_t *ev_actions;
};

struct llc_snap_hdr {
	__u8 dsap;
	__u8 ssap;
	__u8 ui;
	__u8 org[3];
	__u8 type[2];
};

struct llc_snap_hdr___2 {
	u8 dsap;
	u8 ssap;
	u8 ctrl;
	u8 oui[3];
	__be16 ethertype;
};

struct sockaddr_llc {
	__kernel_sa_family_t sllc_family;
	__kernel_sa_family_t sllc_arphrd;
	unsigned char sllc_test;
	unsigned char sllc_xid;
	unsigned char sllc_ua;
	unsigned char sllc_sap;
	unsigned char sllc_mac[6];
	unsigned char __pad[2];
};

struct llc_timer {
	struct timer_list timer;
	long unsigned int expire;
};

struct llc_sock {
	struct sock sk;
	struct sockaddr_llc addr;
	u8 state;
	struct llc_sap *sap;
	struct llc_addr laddr;
	struct llc_addr daddr;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u32 copied_seq;
	u8 retry_count;
	u8 ack_must_be_send;
	u8 first_pdu_Ns;
	u8 npta;
	struct llc_timer ack_timer;
	struct llc_timer pf_cycle_timer;
	struct llc_timer rej_sent_timer;
	struct llc_timer busy_state_timer;
	u8 vS;
	u8 vR;
	u32 n2;
	u32 n1;
	u8 k;
	u8 rw;
	u8 p_flag;
	u8 f_flag;
	u8 s_flag;
	u8 data_flag;
	u8 remote_busy_flag;
	u8 cause_flag;
	struct sk_buff_head pdu_unack_q;
	u16 link;
	u8 X;
	u8 ack_pf;
	u8 failed_data_req;
	u8 dec_step;
	u8 inc_cntr;
	u8 dec_cntr;
	u8 connect_step;
	u8 last_nr;
	u32 rx_pdu_hdr;
	u32 cmsg_flags;
	struct hlist_node dev_hash_node;
};

struct llc_xid_info {
	u8 fmt_id;
	u8 type;
	u8 rw;
};

struct load_info {
	const char *name;
	struct module *mod;
	Elf64_Ehdr *hdr;
	long unsigned int len;
	Elf64_Shdr *sechdrs;
	char *secstrings;
	char *strtab;
	long unsigned int symoffs;
	long unsigned int stroffs;
	long unsigned int init_typeoffs;
	long unsigned int core_typeoffs;
	bool sig_ok;
	long unsigned int mod_kallsyms_init_off;
	struct {
		unsigned int sym;
		unsigned int str;
		unsigned int mod;
		unsigned int vers;
		unsigned int info;
		unsigned int pcpu;
		unsigned int vers_ext_crc;
		unsigned int vers_ext_name;
	} index;
};

struct location;

struct loc_track {
	long unsigned int max;
	long unsigned int count;
	struct location *loc;
	loff_t idx;
};

struct local_event {
	local_lock_t lock;
	__u32 count;
};

struct local_ports {
	u32 range;
	bool warned;
};

struct location {
	depot_stack_handle_t handle;
	long unsigned int count;
	long unsigned int addr;
	long unsigned int waste;
	long long int sum_time;
	long int min_time;
	long int max_time;
	long int min_pid;
	long int max_pid;
	long unsigned int cpus[1];
	nodemask_t nodes;
};

struct lock_history {
	struct dm_buffer_cache *cache;
	bool write;
	unsigned int previous;
	unsigned int no_previous;
};

struct lock_manager {
	struct list_head list;
	bool block_opens;
};

struct lock_manager_operations {
	void *lm_mod_owner;
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock *);
	int (*lm_grant)(struct file_lock *, int);
	bool (*lm_lock_expirable)(struct file_lock *);
	void (*lm_expire_lock)(void);
};

struct lockd_net {
	unsigned int nlmsvc_users;
	long unsigned int next_gc;
	long unsigned int nrhosts;
	struct delayed_work grace_period_end;
	struct lock_manager lockd_manager;
	struct list_head nsm_handles;
};

struct locks_iterator {
	int li_cpu;
	loff_t li_pos;
};

struct log_header_core {
	uint32_t magic;
	uint32_t version;
	uint64_t nr_regions;
};

struct log_header_disk;

struct log_c {
	struct dm_target *ti;
	int touched_dirtied;
	int touched_cleaned;
	int flush_failed;
	uint32_t region_size;
	unsigned int region_count;
	region_t sync_count;
	unsigned int bitset_uint32_count;
	uint32_t *clean_bits;
	uint32_t *sync_bits;
	uint32_t *recovering_bits;
	int sync_search;
	enum sync sync;
	struct dm_io_request io_req;
	int log_dev_failed;
	int log_dev_flush_failed;
	struct dm_dev *log_dev;
	struct log_header_core header;
	struct dm_io_region header_location;
	struct log_header_disk *disk_header;
};

struct log_header_disk {
	__le32 magic;
	__le32 version;
	__le64 nr_regions;
};

struct logic_pio_host_ops {
	u32 (*in)(void *, long unsigned int, size_t);
	void (*out)(void *, long unsigned int, u32, size_t);
	u32 (*ins)(void *, long unsigned int, void *, size_t, unsigned int);
	void (*outs)(void *, long unsigned int, const void *, size_t, unsigned int);
};

struct logic_pio_hwaddr {
	struct list_head list;
	const struct fwnode_handle *fwnode;
	resource_size_t hw_start;
	resource_size_t io_start;
	resource_size_t size;
	long unsigned int flags;
	void *hostdata;
	const struct logic_pio_host_ops *ops;
};

struct lookup_args {
	int offset;
	const struct in6_addr *addr;
};

struct loop_cmd {
	struct list_head list_entry;
	bool use_aio;
	atomic_t ref;
	long int ret;
	struct kiocb iocb;
	struct bio_vec *bvec;
	struct cgroup_subsys_state *blkcg_css;
	struct cgroup_subsys_state *memcg_css;
};

struct loop_info64 {
	__u64 lo_device;
	__u64 lo_inode;
	__u64 lo_rdevice;
	__u64 lo_offset;
	__u64 lo_sizelimit;
	__u32 lo_number;
	__u32 lo_encrypt_type;
	__u32 lo_encrypt_key_size;
	__u32 lo_flags;
	__u8 lo_file_name[64];
	__u8 lo_crypt_name[64];
	__u8 lo_encrypt_key[32];
	__u64 lo_init[2];
};

struct loop_config {
	__u32 fd;
	__u32 block_size;
	struct loop_info64 info;
	__u64 __reserved[8];
};

struct loop_device {
	int lo_number;
	loff_t lo_offset;
	loff_t lo_sizelimit;
	int lo_flags;
	char lo_file_name[64];
	struct file *lo_backing_file;
	struct block_device *lo_device;
	gfp_t old_gfp_mask;
	spinlock_t lo_lock;
	int lo_state;
	spinlock_t lo_work_lock;
	struct workqueue_struct *workqueue;
	struct work_struct rootcg_work;
	struct list_head rootcg_cmd_list;
	struct list_head idle_worker_list;
	struct rb_root worker_tree;
	struct timer_list timer;
	bool sysfs_inited;
	struct request_queue *lo_queue;
	struct blk_mq_tag_set tag_set;
	struct gendisk *lo_disk;
	struct mutex lo_mutex;
	bool idr_visible;
};

struct loop_info {
	int lo_number;
	__kernel_old_dev_t lo_device;
	long unsigned int lo_inode;
	__kernel_old_dev_t lo_rdevice;
	int lo_offset;
	int lo_encrypt_type;
	int lo_encrypt_key_size;
	int lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	long unsigned int lo_init[2];
	char reserved[4];
};

struct loop_worker {
	struct rb_node rb_node;
	struct work_struct work;
	struct list_head cmd_list;
	struct list_head idle_list;
	struct loop_device *lo;
	struct cgroup_subsys_state *blkcg_css;
	long unsigned int last_ran_at;
};

union lower_chunk {
	union lower_chunk *next;
	long unsigned int data[256];
};

struct lowpan_802154_cb {
	u16 d_tag;
	unsigned int d_size;
	u8 d_offset;
};

struct lowpan_802154_dev {
	struct net_device *wdev;
	u16 fragment_tag;
};

struct lowpan_iphc_ctx_ops;

struct lowpan_iphc_ctx {
	u8 id;
	struct in6_addr pfx;
	u8 plen;
	long unsigned int flags;
};

struct lowpan_iphc_ctx_table {
	spinlock_t lock;
	const struct lowpan_iphc_ctx_ops *ops;
	struct lowpan_iphc_ctx table[16];
};

struct lowpan_dev {
	enum lowpan_lltypes lltype;
	struct dentry *iface_debugfs;
	struct lowpan_iphc_ctx_table ctx;
	u8 priv[0];
};

struct lowpan_nhc {
	const char *name;
	u8 nexthdr;
	size_t nexthdrlen;
	u8 id;
	u8 idmask;
	int (*uncompress)(struct sk_buff *, size_t);
	int (*compress)(struct sk_buff *, u8 **);
};

struct lp {
	u32 flag;
	u32 sowd;
	u32 owd_min;
	u32 owd_max;
	u32 owd_max_rsv;
	u32 remote_hz;
	u32 remote_ref_time;
	u32 local_ref_time;
	u32 last_drop;
	u32 inference;
};

struct lpi_constraints {
	acpi_handle handle;
	int min_dstate;
};

struct lpi_device_constraint {
	int uid;
	int min_dstate;
	int function_states;
};

struct lpi_device_constraint_amd {
	char *name;
	int enabled;
	int function_states;
	int min_dstate;
};

struct lpi_device_info {
	char *name;
	int enabled;
	union acpi_object *package;
};

struct lpit_residency_info {
	struct acpi_generic_address gaddr;
	u64 frequency;
	void *iomem_addr;
};

struct lpm_trie_node;

struct lpm_trie {
	struct bpf_map map;
	struct lpm_trie_node *root;
	struct bpf_mem_alloc ma;
	size_t n_entries;
	size_t max_prefixlen;
	size_t data_size;
	raw_spinlock_t lock;
};

struct lpm_trie_node {
	struct lpm_trie_node *child[2];
	u32 prefixlen;
	u32 flags;
	u8 data[0];
};

struct lpss8250_board;

struct lpss8250 {
	struct dw8250_port_data data;
	struct lpss8250_board *board;
	struct dw_dma_chip dma_chip;
	struct dw_dma_slave dma_param;
	u8 dma_maxburst;
};

struct lpss8250_board {
	long unsigned int freq;
	unsigned int base_baud;
	int (*setup)(struct lpss8250 *, struct uart_port *);
	void (*exit)(struct lpss8250 *);
};

struct lri {
	i915_reg_t reg;
	u32 value;
};

struct lru_iter {
	struct lru *lru;
	struct list_head list;
	struct lru_entry *stop;
	struct lru_entry *e;
};

struct zswap_lruvec_state {};

struct pglist_data;

struct lruvec {
	struct list_head lists[5];
	spinlock_t lru_lock;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	atomic_long_t nonresident_age;
	long unsigned int refaults[2];
	long unsigned int flags;
	struct pglist_data *pgdat;
	struct zswap_lruvec_state zswap_lruvec_state;
};

struct lruvec_stats {
	long int state[31];
	long int state_local[31];
	long int state_pending[31];
};

struct lruvec_stats_percpu {
	long int state[31];
	long int state_prev[31];
};

struct skcipher_alg_common {
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
	unsigned int chunksize;
	unsigned int statesize;
	struct crypto_alg base;
};

struct lskcipher_alg {
	int (*setkey)(struct crypto_lskcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct crypto_lskcipher *, const u8 *, u8 *, unsigned int, u8 *, u32);
	int (*decrypt)(struct crypto_lskcipher *, const u8 *, u8 *, unsigned int, u8 *, u32);
	int (*init)(struct crypto_lskcipher *);
	void (*exit)(struct crypto_lskcipher *);
	struct skcipher_alg_common co;
};

struct lskcipher_instance {
	void (*free)(struct lskcipher_instance *);
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct lskcipher_alg alg;
	};
};

struct lsm_blob_sizes {
	int lbs_cred;
	int lbs_file;
	int lbs_ib;
	int lbs_inode;
	int lbs_sock;
	int lbs_superblock;
	int lbs_ipc;
	int lbs_key;
	int lbs_msg_msg;
	int lbs_perf_event;
	int lbs_task;
	int lbs_xattr_count;
	int lbs_tun_dev;
	int lbs_bdev;
};

struct lsm_context {
	char *context;
	u32 len;
	int id;
};

struct lsm_ctx {
	__u64 id;
	__u64 flags;
	__u64 len;
	__u64 ctx_len;
	__u8 ctx[0];
};

struct lsm_ibendport_audit {
	const char *dev_name;
	u8 port;
};

struct lsm_ibpkey_audit {
	u64 subnet_prefix;
	u16 pkey;
};

struct lsm_id {
	const char *name;
	u64 id;
};

struct lsm_info {
	const char *name;
	enum lsm_order order;
	long unsigned int flags;
	int *enabled;
	int (*init)(void);
	struct lsm_blob_sizes *blobs;
};

struct lsm_ioctlop_audit {
	struct path path;
	u16 cmd;
};

struct lsm_network_audit {
	int netif;
	const struct sock *sk;
	u16 family;
	__be16 dport;
	__be16 sport;
	union {
		struct {
			__be32 daddr;
			__be32 saddr;
		} v4;
		struct {
			struct in6_addr daddr;
			struct in6_addr saddr;
		} v6;
	} fam;
};

struct security_hook_list;

struct lsm_static_call {
	struct static_call_key *key;
	void *trampoline;
	struct security_hook_list *hl;
	struct static_key_false *active;
};

struct lsm_static_calls_table {
	struct lsm_static_call binder_set_context_mgr[3];
	struct lsm_static_call binder_transaction[3];
	struct lsm_static_call binder_transfer_binder[3];
	struct lsm_static_call binder_transfer_file[3];
	struct lsm_static_call ptrace_access_check[3];
	struct lsm_static_call ptrace_traceme[3];
	struct lsm_static_call capget[3];
	struct lsm_static_call capset[3];
	struct lsm_static_call capable[3];
	struct lsm_static_call quotactl[3];
	struct lsm_static_call quota_on[3];
	struct lsm_static_call syslog[3];
	struct lsm_static_call settime[3];
	struct lsm_static_call vm_enough_memory[3];
	struct lsm_static_call bprm_creds_for_exec[3];
	struct lsm_static_call bprm_creds_from_file[3];
	struct lsm_static_call bprm_check_security[3];
	struct lsm_static_call bprm_committing_creds[3];
	struct lsm_static_call bprm_committed_creds[3];
	struct lsm_static_call fs_context_submount[3];
	struct lsm_static_call fs_context_dup[3];
	struct lsm_static_call fs_context_parse_param[3];
	struct lsm_static_call sb_alloc_security[3];
	struct lsm_static_call sb_delete[3];
	struct lsm_static_call sb_free_security[3];
	struct lsm_static_call sb_free_mnt_opts[3];
	struct lsm_static_call sb_eat_lsm_opts[3];
	struct lsm_static_call sb_mnt_opts_compat[3];
	struct lsm_static_call sb_remount[3];
	struct lsm_static_call sb_kern_mount[3];
	struct lsm_static_call sb_show_options[3];
	struct lsm_static_call sb_statfs[3];
	struct lsm_static_call sb_mount[3];
	struct lsm_static_call sb_umount[3];
	struct lsm_static_call sb_pivotroot[3];
	struct lsm_static_call sb_set_mnt_opts[3];
	struct lsm_static_call sb_clone_mnt_opts[3];
	struct lsm_static_call move_mount[3];
	struct lsm_static_call dentry_init_security[3];
	struct lsm_static_call dentry_create_files_as[3];
	struct lsm_static_call path_unlink[3];
	struct lsm_static_call path_mkdir[3];
	struct lsm_static_call path_rmdir[3];
	struct lsm_static_call path_mknod[3];
	struct lsm_static_call path_post_mknod[3];
	struct lsm_static_call path_truncate[3];
	struct lsm_static_call path_symlink[3];
	struct lsm_static_call path_link[3];
	struct lsm_static_call path_rename[3];
	struct lsm_static_call path_chmod[3];
	struct lsm_static_call path_chown[3];
	struct lsm_static_call path_chroot[3];
	struct lsm_static_call path_notify[3];
	struct lsm_static_call inode_alloc_security[3];
	struct lsm_static_call inode_free_security[3];
	struct lsm_static_call inode_free_security_rcu[3];
	struct lsm_static_call inode_init_security[3];
	struct lsm_static_call inode_init_security_anon[3];
	struct lsm_static_call inode_create[3];
	struct lsm_static_call inode_post_create_tmpfile[3];
	struct lsm_static_call inode_link[3];
	struct lsm_static_call inode_unlink[3];
	struct lsm_static_call inode_symlink[3];
	struct lsm_static_call inode_mkdir[3];
	struct lsm_static_call inode_rmdir[3];
	struct lsm_static_call inode_mknod[3];
	struct lsm_static_call inode_rename[3];
	struct lsm_static_call inode_readlink[3];
	struct lsm_static_call inode_follow_link[3];
	struct lsm_static_call inode_permission[3];
	struct lsm_static_call inode_setattr[3];
	struct lsm_static_call inode_post_setattr[3];
	struct lsm_static_call inode_getattr[3];
	struct lsm_static_call inode_xattr_skipcap[3];
	struct lsm_static_call inode_setxattr[3];
	struct lsm_static_call inode_post_setxattr[3];
	struct lsm_static_call inode_getxattr[3];
	struct lsm_static_call inode_listxattr[3];
	struct lsm_static_call inode_removexattr[3];
	struct lsm_static_call inode_post_removexattr[3];
	struct lsm_static_call inode_set_acl[3];
	struct lsm_static_call inode_post_set_acl[3];
	struct lsm_static_call inode_get_acl[3];
	struct lsm_static_call inode_remove_acl[3];
	struct lsm_static_call inode_post_remove_acl[3];
	struct lsm_static_call inode_need_killpriv[3];
	struct lsm_static_call inode_killpriv[3];
	struct lsm_static_call inode_getsecurity[3];
	struct lsm_static_call inode_setsecurity[3];
	struct lsm_static_call inode_listsecurity[3];
	struct lsm_static_call inode_getlsmprop[3];
	struct lsm_static_call inode_copy_up[3];
	struct lsm_static_call inode_copy_up_xattr[3];
	struct lsm_static_call inode_setintegrity[3];
	struct lsm_static_call kernfs_init_security[3];
	struct lsm_static_call file_permission[3];
	struct lsm_static_call file_alloc_security[3];
	struct lsm_static_call file_release[3];
	struct lsm_static_call file_free_security[3];
	struct lsm_static_call file_ioctl[3];
	struct lsm_static_call file_ioctl_compat[3];
	struct lsm_static_call mmap_addr[3];
	struct lsm_static_call mmap_file[3];
	struct lsm_static_call file_mprotect[3];
	struct lsm_static_call file_lock[3];
	struct lsm_static_call file_fcntl[3];
	struct lsm_static_call file_set_fowner[3];
	struct lsm_static_call file_send_sigiotask[3];
	struct lsm_static_call file_receive[3];
	struct lsm_static_call file_open[3];
	struct lsm_static_call file_post_open[3];
	struct lsm_static_call file_truncate[3];
	struct lsm_static_call task_alloc[3];
	struct lsm_static_call task_free[3];
	struct lsm_static_call cred_alloc_blank[3];
	struct lsm_static_call cred_free[3];
	struct lsm_static_call cred_prepare[3];
	struct lsm_static_call cred_transfer[3];
	struct lsm_static_call cred_getsecid[3];
	struct lsm_static_call cred_getlsmprop[3];
	struct lsm_static_call kernel_act_as[3];
	struct lsm_static_call kernel_create_files_as[3];
	struct lsm_static_call kernel_module_request[3];
	struct lsm_static_call kernel_load_data[3];
	struct lsm_static_call kernel_post_load_data[3];
	struct lsm_static_call kernel_read_file[3];
	struct lsm_static_call kernel_post_read_file[3];
	struct lsm_static_call task_fix_setuid[3];
	struct lsm_static_call task_fix_setgid[3];
	struct lsm_static_call task_fix_setgroups[3];
	struct lsm_static_call task_setpgid[3];
	struct lsm_static_call task_getpgid[3];
	struct lsm_static_call task_getsid[3];
	struct lsm_static_call current_getlsmprop_subj[3];
	struct lsm_static_call task_getlsmprop_obj[3];
	struct lsm_static_call task_setnice[3];
	struct lsm_static_call task_setioprio[3];
	struct lsm_static_call task_getioprio[3];
	struct lsm_static_call task_prlimit[3];
	struct lsm_static_call task_setrlimit[3];
	struct lsm_static_call task_setscheduler[3];
	struct lsm_static_call task_getscheduler[3];
	struct lsm_static_call task_movememory[3];
	struct lsm_static_call task_kill[3];
	struct lsm_static_call task_prctl[3];
	struct lsm_static_call task_to_inode[3];
	struct lsm_static_call userns_create[3];
	struct lsm_static_call ipc_permission[3];
	struct lsm_static_call ipc_getlsmprop[3];
	struct lsm_static_call msg_msg_alloc_security[3];
	struct lsm_static_call msg_msg_free_security[3];
	struct lsm_static_call msg_queue_alloc_security[3];
	struct lsm_static_call msg_queue_free_security[3];
	struct lsm_static_call msg_queue_associate[3];
	struct lsm_static_call msg_queue_msgctl[3];
	struct lsm_static_call msg_queue_msgsnd[3];
	struct lsm_static_call msg_queue_msgrcv[3];
	struct lsm_static_call shm_alloc_security[3];
	struct lsm_static_call shm_free_security[3];
	struct lsm_static_call shm_associate[3];
	struct lsm_static_call shm_shmctl[3];
	struct lsm_static_call shm_shmat[3];
	struct lsm_static_call sem_alloc_security[3];
	struct lsm_static_call sem_free_security[3];
	struct lsm_static_call sem_associate[3];
	struct lsm_static_call sem_semctl[3];
	struct lsm_static_call sem_semop[3];
	struct lsm_static_call netlink_send[3];
	struct lsm_static_call d_instantiate[3];
	struct lsm_static_call getselfattr[3];
	struct lsm_static_call setselfattr[3];
	struct lsm_static_call getprocattr[3];
	struct lsm_static_call setprocattr[3];
	struct lsm_static_call ismaclabel[3];
	struct lsm_static_call secid_to_secctx[3];
	struct lsm_static_call lsmprop_to_secctx[3];
	struct lsm_static_call secctx_to_secid[3];
	struct lsm_static_call release_secctx[3];
	struct lsm_static_call inode_invalidate_secctx[3];
	struct lsm_static_call inode_notifysecctx[3];
	struct lsm_static_call inode_setsecctx[3];
	struct lsm_static_call inode_getsecctx[3];
	struct lsm_static_call unix_stream_connect[3];
	struct lsm_static_call unix_may_send[3];
	struct lsm_static_call socket_create[3];
	struct lsm_static_call socket_post_create[3];
	struct lsm_static_call socket_socketpair[3];
	struct lsm_static_call socket_bind[3];
	struct lsm_static_call socket_connect[3];
	struct lsm_static_call socket_listen[3];
	struct lsm_static_call socket_accept[3];
	struct lsm_static_call socket_sendmsg[3];
	struct lsm_static_call socket_recvmsg[3];
	struct lsm_static_call socket_getsockname[3];
	struct lsm_static_call socket_getpeername[3];
	struct lsm_static_call socket_getsockopt[3];
	struct lsm_static_call socket_setsockopt[3];
	struct lsm_static_call socket_shutdown[3];
	struct lsm_static_call socket_sock_rcv_skb[3];
	struct lsm_static_call socket_getpeersec_stream[3];
	struct lsm_static_call socket_getpeersec_dgram[3];
	struct lsm_static_call sk_alloc_security[3];
	struct lsm_static_call sk_free_security[3];
	struct lsm_static_call sk_clone_security[3];
	struct lsm_static_call sk_getsecid[3];
	struct lsm_static_call sock_graft[3];
	struct lsm_static_call inet_conn_request[3];
	struct lsm_static_call inet_csk_clone[3];
	struct lsm_static_call inet_conn_established[3];
	struct lsm_static_call secmark_relabel_packet[3];
	struct lsm_static_call secmark_refcount_inc[3];
	struct lsm_static_call secmark_refcount_dec[3];
	struct lsm_static_call req_classify_flow[3];
	struct lsm_static_call tun_dev_alloc_security[3];
	struct lsm_static_call tun_dev_create[3];
	struct lsm_static_call tun_dev_attach_queue[3];
	struct lsm_static_call tun_dev_attach[3];
	struct lsm_static_call tun_dev_open[3];
	struct lsm_static_call sctp_assoc_request[3];
	struct lsm_static_call sctp_bind_connect[3];
	struct lsm_static_call sctp_sk_clone[3];
	struct lsm_static_call sctp_assoc_established[3];
	struct lsm_static_call mptcp_add_subflow[3];
	struct lsm_static_call key_alloc[3];
	struct lsm_static_call key_permission[3];
	struct lsm_static_call key_getsecurity[3];
	struct lsm_static_call key_post_create_or_update[3];
	struct lsm_static_call audit_rule_init[3];
	struct lsm_static_call audit_rule_known[3];
	struct lsm_static_call audit_rule_match[3];
	struct lsm_static_call audit_rule_free[3];
	struct lsm_static_call bpf[3];
	struct lsm_static_call bpf_map[3];
	struct lsm_static_call bpf_prog[3];
	struct lsm_static_call bpf_map_create[3];
	struct lsm_static_call bpf_map_free[3];
	struct lsm_static_call bpf_prog_load[3];
	struct lsm_static_call bpf_prog_free[3];
	struct lsm_static_call bpf_token_create[3];
	struct lsm_static_call bpf_token_free[3];
	struct lsm_static_call bpf_token_cmd[3];
	struct lsm_static_call bpf_token_capable[3];
	struct lsm_static_call locked_down[3];
	struct lsm_static_call perf_event_open[3];
	struct lsm_static_call perf_event_alloc[3];
	struct lsm_static_call perf_event_read[3];
	struct lsm_static_call perf_event_write[3];
	struct lsm_static_call uring_override_creds[3];
	struct lsm_static_call uring_sqpoll[3];
	struct lsm_static_call uring_cmd[3];
	struct lsm_static_call initramfs_populated[3];
	struct lsm_static_call bdev_alloc_security[3];
	struct lsm_static_call bdev_free_security[3];
	struct lsm_static_call bdev_setintegrity[3];
};

struct lwq {
	spinlock_t lock;
	struct llist_node *ready;
	struct llist_head new;
};

struct lwq_node {
	struct llist_node node;
};

struct lwtunnel_encap_ops {
	int (*build_state)(struct net *, struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
	void (*destroy_state)(struct lwtunnel_state *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*input)(struct sk_buff *);
	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
	int (*get_encap_size)(struct lwtunnel_state *);
	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
	int (*xmit)(struct sk_buff *);
	struct module *owner;
};

struct lwtunnel_state {
	__u16 type;
	__u16 flags;
	__u16 headroom;
	atomic_t refcnt;
	int (*orig_output)(struct net *, struct sock *, struct sk_buff *);
	int (*orig_input)(struct sk_buff *);
	struct callback_head rcu;
	__u8 data[0];
};

struct lzma2_dec {
	enum lzma2_seq sequence;
	enum lzma2_seq next_sequence;
	uint32_t uncompressed;
	uint32_t compressed;
	bool need_dict_reset;
	bool need_props;
};

struct lzma_len_dec {
	uint16_t choice;
	uint16_t choice2;
	uint16_t low[128];
	uint16_t mid[128];
	uint16_t high[256];
};

struct lzma_dec {
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
	enum lzma_state state;
	uint32_t len;
	uint32_t lc;
	uint32_t literal_pos_mask;
	uint32_t pos_mask;
	uint16_t is_match[192];
	uint16_t is_rep[12];
	uint16_t is_rep0[12];
	uint16_t is_rep1[12];
	uint16_t is_rep2[12];
	uint16_t is_rep0_long[192];
	uint16_t dist_slot[256];
	uint16_t dist_special[114];
	uint16_t dist_align[16];
	struct lzma_len_dec match_len_dec;
	struct lzma_len_dec rep_len_dec;
	uint16_t literal[12288];
};

struct lzma_header {
	uint8_t pos;
	uint32_t dict_size;
	uint64_t dst_size;
} __attribute__((packed));

struct lzo_ctx {
	void *lzo_comp_mem;
};

struct lzorle_ctx {
	void *lzorle_comp_mem;
};

struct ma_topiary {
	struct maple_enode *head;
	struct maple_enode *tail;
	struct maple_tree *mtree;
};

struct maple_node;

struct ma_wr_state {
	struct ma_state *mas;
	struct maple_node *node;
	long unsigned int r_min;
	long unsigned int r_max;
	enum maple_type type;
	unsigned char offset_end;
	long unsigned int *pivots;
	long unsigned int end_piv;
	void **slots;
	void *entry;
	void *content;
};

typedef struct mac_addr mac_addr;

struct machine_ops {
	void (*restart)(char *);
	void (*halt)(void);
	void (*power_off)(void);
	void (*shutdown)(void);
	void (*crash_shutdown)(struct pt_regs *);
	void (*emergency_restart)(void);
};

struct macsec_info {
	sci_t sci;
};

struct macvlan_port;

struct vlan_pcpu_stats;

struct netpoll;

struct macvlan_dev {
	struct net_device *dev;
	struct list_head list;
	struct hlist_node hlist;
	struct macvlan_port *port;
	struct net_device *lowerdev;
	netdevice_tracker dev_tracker;
	void *accel_priv;
	struct vlan_pcpu_stats *pcpu_stats;
	long unsigned int mc_filter[4];
	netdev_features_t set_features;
	enum macvlan_mode mode;
	u16 flags;
	unsigned int macaddr_count;
	u32 bc_queue_len_req;
	struct netpoll *netpoll;
};

struct macvlan_port {
	struct net_device *dev;
	struct hlist_head vlan_hash[256];
	struct list_head vlans;
	struct sk_buff_head bc_queue;
	struct work_struct bc_work;
	u32 bc_queue_len_used;
	int bc_cutoff;
	u32 flags;
	int count;
	struct hlist_head vlan_source_hash[256];
	long unsigned int bc_filter[4];
	long unsigned int mc_filter[4];
	unsigned char perm_addr[6];
};

struct macvlan_skb_cb {
	const struct macvlan_dev *src;
};

struct macvlan_source_entry {
	struct hlist_node hlist;
	struct macvlan_dev *vlan;
	unsigned char addr[8];
	struct callback_head rcu;
};

struct macvtap_dev {
	struct macvlan_dev vlan;
	struct tap_dev tap;
};

struct mmu_gather;

struct madvise_walk_private {
	struct mmu_gather *tlb;
	bool pageout;
};

struct mafield {
	const char *prefix;
	int field;
};

struct major_info {
	struct callback_head rcu;
	dev_t major;
	struct idr minor_idr;
	spinlock_t minor_lock;
	const char *device_name;
	struct list_head next;
};

struct map_attribute {
	struct attribute attr;
	ssize_t (*show)(struct efi_runtime_map_entry *, char *);
};

struct map_files_info {
	long unsigned int start;
	long unsigned int end;
	fmode_t mode;
};

struct map_info___2 {
	struct map_info___2 *next;
	struct mm_struct *mm;
	long unsigned int vaddr;
};

struct map_iter {
	void *key;
	bool done;
};

struct map_range {
	long unsigned int start;
	long unsigned int end;
	unsigned int page_size_mask;
};

struct maple_alloc {
	long unsigned int total;
	unsigned char node_count;
	unsigned int request_count;
	struct maple_alloc *slot[30];
};

struct maple_pnode;

struct maple_metadata {
	unsigned char end;
	unsigned char gap;
};

struct maple_arange_64 {
	struct maple_pnode *parent;
	long unsigned int pivot[9];
	void *slot[10];
	long unsigned int gap[10];
	struct maple_metadata meta;
};

struct maple_big_node {
	long unsigned int pivot[33];
	union {
		struct maple_enode *slot[34];
		struct {
			long unsigned int padding[21];
			long unsigned int gap[21];
		};
	};
	unsigned char b_end;
	enum maple_type type;
};

struct maple_range_64 {
	struct maple_pnode *parent;
	long unsigned int pivot[15];
	union {
		void *slot[16];
		struct {
			void *pad[15];
			struct maple_metadata meta;
		};
	};
};

struct maple_node {
	union {
		struct {
			struct maple_pnode *parent;
			void *slot[31];
		};
		struct {
			void *pad;
			struct callback_head rcu;
			struct maple_enode *piv_parent;
			unsigned char parent_slot;
			enum maple_type type;
			unsigned char slot_len;
			unsigned int ma_flags;
		};
		struct maple_range_64 mr64;
		struct maple_arange_64 ma64;
		struct maple_alloc alloc;
	};
};

struct maple_subtree_state {
	struct ma_state *orig_l;
	struct ma_state *orig_r;
	struct ma_state *l;
	struct ma_state *m;
	struct ma_state *r;
	struct ma_topiary *free;
	struct ma_topiary *destroy;
	struct maple_big_node *bn;
};

struct maple_topiary {
	struct maple_pnode *parent;
	struct maple_enode *next;
};

struct mapped_device {
	struct mutex suspend_lock;
	struct mutex table_devices_lock;
	struct list_head table_devices;
	void *map;
	long unsigned int flags;
	struct mutex type_lock;
	enum dm_queue_mode type;
	int numa_node_id;
	struct request_queue *queue;
	atomic_t holders;
	atomic_t open_count;
	struct dm_target *immutable_target;
	struct target_type *immutable_target_type;
	char name[16];
	struct gendisk *disk;
	struct dax_device *dax_dev;
	wait_queue_head_t wait;
	long unsigned int *pending_io;
	struct hd_geometry geometry;
	struct workqueue_struct *wq;
	struct work_struct work;
	spinlock_t deferred_lock;
	struct bio_list deferred;
	struct work_struct requeue_work;
	struct dm_io *requeue_list;
	void *interface_ptr;
	wait_queue_head_t eventq;
	atomic_t event_nr;
	atomic_t uevent_seq;
	struct list_head uevent_list;
	spinlock_t uevent_lock;
	bool init_tio_pdu: 1;
	struct blk_mq_tag_set *tag_set;
	struct dm_stats stats;
	unsigned int internal_suspend_count;
	int swap_bios;
	struct semaphore swap_bios_semaphore;
	struct mutex swap_bios_lock;
	struct dm_md_mempools *mempools;
	struct dm_kobject_holder kobj_holder;
	struct srcu_struct io_barrier;
	struct dm_ima_measurements ima;
};

struct mapping_node {
	struct {
		struct rb_node rb_node;
		u64 bytenr;
	};
	void *data;
};

struct mapping_tree {
	struct rb_root rb_root;
	spinlock_t lock;
};

struct mask_array_stats;

struct sw_flow_mask;

struct mask_array {
	struct callback_head rcu;
	int count;
	int max;
	struct mask_array_stats *masks_usage_stats;
	u64 *masks_usage_zero_cntr;
	struct sw_flow_mask *masks[0];
};

struct mask_array_stats {
	struct u64_stats_sync syncp;
	u64 usage_cntrs[0];
};

struct mask_cache_entry;

struct mask_cache {
	struct callback_head rcu;
	u32 cache_size;
	struct mask_cache_entry *mask_cache;
};

struct mask_cache_entry {
	u32 skb_hash;
	u32 mask_index;
};

struct mask_count {
	int index;
	u64 counter;
};

struct masq_dev_work {
	struct work_struct work;
	struct net *net;
	netns_tracker ns_tracker;
	union nf_inet_addr addr;
	int ifindex;
	int (*iter)(struct nf_conn *, void *);
};

struct match_token {
	int token;
	const char *pattern;
};

struct math_emu_info {
	long int ___orig_eip;
	struct pt_regs *regs;
};

struct mb_cache {
	struct hlist_bl_head *c_hash;
	int c_bucket_bits;
	long unsigned int c_max_entries;
	spinlock_t c_list_lock;
	struct list_head c_list;
	long unsigned int c_entry_count;
	struct shrinker *c_shrink;
	struct work_struct c_shrink_work;
};

struct mb_cache_entry {
	struct list_head e_list;
	struct hlist_bl_node e_hash_list;
	atomic_t e_refcnt;
	u32 e_key;
	long unsigned int e_flags;
	u64 e_value;
};

struct mbox_controller;

struct mbox_client;

struct mbox_chan {
	struct mbox_controller *mbox;
	unsigned int txdone_method;
	struct mbox_client *cl;
	struct completion tx_complete;
	void *active_req;
	unsigned int msg_count;
	unsigned int msg_free;
	void *msg_data[20];
	spinlock_t lock;
	void *con_priv;
};

struct mbox_chan_ops {
	int (*send_data)(struct mbox_chan *, void *);
	int (*flush)(struct mbox_chan *, long unsigned int);
	int (*startup)(struct mbox_chan *);
	void (*shutdown)(struct mbox_chan *);
	bool (*last_tx_done)(struct mbox_chan *);
	bool (*peek_data)(struct mbox_chan *);
};

struct mbox_client {
	struct device *dev;
	bool tx_block;
	long unsigned int tx_tout;
	bool knows_txdone;
	void (*rx_callback)(struct mbox_client *, void *);
	void (*tx_prepare)(struct mbox_client *, void *);
	void (*tx_done)(struct mbox_client *, void *, int);
};

struct mbox_controller {
	struct device *dev;
	const struct mbox_chan_ops *ops;
	struct mbox_chan *chans;
	int num_chans;
	bool txdone_irq;
	bool txdone_poll;
	unsigned int txpoll_period;
	struct mbox_chan * (*of_xlate)(struct mbox_controller *, const struct of_phandle_args *);
	struct hrtimer poll_hrt;
	spinlock_t poll_hrt_lock;
	struct list_head node;
};

struct mc146818_get_time_callback_param {
	struct rtc_time *time;
	unsigned char ctrl;
	unsigned char century;
};

struct mc_subled {
	unsigned int color_index;
	unsigned int brightness;
	unsigned int intensity;
	unsigned int channel;
};

struct mca_config {
	__u64 lmce_disabled: 1;
	__u64 disabled: 1;
	__u64 ser: 1;
	__u64 recovery: 1;
	__u64 bios_cmci_threshold: 1;
	__u64 initialized: 1;
	__u64 __reserved: 58;
	bool dont_log_ce;
	bool cmci_disabled;
	bool ignore_ce;
	bool print_all;
	int monarch_timeout;
	int panic_timeout;
	u32 rip_msr;
	s8 bootlog;
};

struct storm_bank {
	u64 history;
	u64 timestamp;
	bool in_storm_mode;
	bool poll_only;
};

struct mca_storm_desc {
	struct storm_bank banks[64];
	u8 stormy_bank_count;
	bool poll_mode;
};

struct mce {
	__u64 status;
	__u64 misc;
	__u64 addr;
	__u64 mcgstatus;
	__u64 ip;
	__u64 tsc;
	__u64 time;
	__u8 cpuvendor;
	__u8 inject_flags;
	__u8 severity;
	__u8 pad;
	__u32 cpuid;
	__u8 cs;
	__u8 bank;
	__u8 cpu;
	__u8 finished;
	__u32 extcpu;
	__u32 socketid;
	__u32 apicid;
	__u64 mcgcap;
	__u64 synd;
	__u64 ipid;
	__u64 ppin;
	__u32 microcode;
	__u64 kflags;
};

struct mce_bank {
	u64 ctl;
	__u64 init: 1;
	__u64 lsb_in_status: 1;
	__u64 __reserved_1: 62;
};

struct mce_bank_dev {
	struct device_attribute attr;
	char attrname[16];
	u8 bank;
};

union vendor_info {
	struct {
		u64 synd1;
		u64 synd2;
	} amd;
};

struct mce_hw_err {
	struct mce m;
	union vendor_info vendor;
};

struct mce_evt_llist {
	struct llist_node llnode;
	struct mce_hw_err err;
};

struct mce_vendor_flags {
	__u64 overflow_recov: 1;
	__u64 succor: 1;
	__u64 smca: 1;
	__u64 zen_ifu_quirk: 1;
	__u64 amd_threshold: 1;
	__u64 p5: 1;
	__u64 winchip: 1;
	__u64 snb_ifu_quirk: 1;
	__u64 skx_repmov_quirk: 1;
	__u64 __reserved_0: 55;
};

struct mcs_spinlock {
	struct mcs_spinlock *next;
	int locked;
	int count;
};

struct md5_state {
	u32 hash[4];
	u32 block[16];
	u64 byte_count;
};

struct md_bitmap_stats {
	u64 events_cleared;
	int behind_writes;
	bool behind_wait;
	long unsigned int missing_pages;
	long unsigned int file_pages;
	long unsigned int sync_size;
	long unsigned int pages;
	struct file *file;
};

struct md_rdev;

struct md_cluster_operations {
	int (*join)(struct mddev *, int);
	int (*leave)(struct mddev *);
	int (*slot_number)(struct mddev *);
	int (*resync_info_update)(struct mddev *, sector_t, sector_t);
	int (*resync_start_notify)(struct mddev *);
	int (*resync_status_get)(struct mddev *);
	void (*resync_info_get)(struct mddev *, sector_t *, sector_t *);
	int (*metadata_update_start)(struct mddev *);
	int (*metadata_update_finish)(struct mddev *);
	void (*metadata_update_cancel)(struct mddev *);
	int (*resync_start)(struct mddev *);
	int (*resync_finish)(struct mddev *);
	int (*area_resyncing)(struct mddev *, int, sector_t, sector_t);
	int (*add_new_disk)(struct mddev *, struct md_rdev *);
	void (*add_new_disk_cancel)(struct mddev *);
	int (*new_disk_ack)(struct mddev *, bool);
	int (*remove_disk)(struct mddev *, struct md_rdev *);
	void (*load_bitmaps)(struct mddev *, int);
	int (*gather_bitmaps)(struct md_rdev *);
	int (*resize_bitmaps)(struct mddev *, sector_t, sector_t);
	int (*lock_all_bitmaps)(struct mddev *);
	void (*unlock_all_bitmaps)(struct mddev *);
	void (*update_size)(struct mddev *, sector_t);
};

struct md_io_clone {
	struct mddev *mddev;
	struct bio *orig_bio;
	long unsigned int start_time;
	sector_t offset;
	long unsigned int sectors;
	struct bio bio_clone;
};

struct md_labels {
	struct ovs_key_ct_labels value;
	struct ovs_key_ct_labels mask;
};

struct md_mark {
	u32 value;
	u32 mask;
};

struct md_personality {
	char *name;
	int level;
	struct list_head list;
	struct module *owner;
	bool (*make_request)(struct mddev *, struct bio *);
	int (*run)(struct mddev *);
	int (*start)(struct mddev *);
	void (*free)(struct mddev *, void *);
	void (*status)(struct seq_file *, struct mddev *);
	void (*error_handler)(struct mddev *, struct md_rdev *);
	int (*hot_add_disk)(struct mddev *, struct md_rdev *);
	int (*hot_remove_disk)(struct mddev *, struct md_rdev *);
	int (*spare_active)(struct mddev *);
	sector_t (*sync_request)(struct mddev *, sector_t, sector_t, int *);
	int (*resize)(struct mddev *, sector_t);
	sector_t (*size)(struct mddev *, sector_t, int);
	int (*check_reshape)(struct mddev *);
	int (*start_reshape)(struct mddev *);
	void (*finish_reshape)(struct mddev *);
	void (*update_reshape_pos)(struct mddev *);
	void (*prepare_suspend)(struct mddev *);
	void (*quiesce)(struct mddev *, int);
	void * (*takeover)(struct mddev *);
	int (*change_consistency_policy)(struct mddev *, const char *);
	void (*bitmap_sector)(struct mddev *, sector_t *, long unsigned int *);
};

struct serial_in_rdev;

struct md_rdev {
	struct list_head same_set;
	sector_t sectors;
	struct mddev *mddev;
	int last_events;
	struct block_device *meta_bdev;
	struct block_device *bdev;
	struct file *bdev_file;
	struct page *sb_page;
	struct page *bb_page;
	int sb_loaded;
	__u64 sb_events;
	sector_t data_offset;
	sector_t new_data_offset;
	sector_t sb_start;
	int sb_size;
	int preferred_minor;
	struct kobject kobj;
	long unsigned int flags;
	wait_queue_head_t blocked_wait;
	int desc_nr;
	int raid_disk;
	int new_raid_disk;
	int saved_raid_disk;
	union {
		sector_t recovery_offset;
		sector_t journal_tail;
	};
	atomic_t nr_pending;
	atomic_t read_errors;
	time64_t last_read_error;
	atomic_t corrected_errors;
	struct serial_in_rdev *serial;
	struct kernfs_node *sysfs_state;
	struct kernfs_node *sysfs_unack_badblocks;
	struct kernfs_node *sysfs_badblocks;
	struct badblocks badblocks;
	struct {
		short int offset;
		unsigned int size;
		sector_t sector;
	} ppl;
};

struct md_setup_args {
	int minor;
	int partitioned;
	int level;
	int chunk;
	char *device_names;
};

struct md_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct mddev *, char *);
	ssize_t (*store)(struct mddev *, const char *, size_t);
};

struct md_thread {
	void (*run)(struct md_thread *);
	struct mddev *mddev;
	wait_queue_head_t wqueue;
	long unsigned int flags;
	struct task_struct *tsk;
	long unsigned int timeout;
	void *private;
};

struct md_cluster_info;

struct mddev {
	void *private;
	struct md_personality *pers;
	dev_t unit;
	int md_minor;
	struct list_head disks;
	long unsigned int flags;
	long unsigned int sb_flags;
	int suspended;
	struct mutex suspend_mutex;
	struct percpu_ref active_io;
	int ro;
	int sysfs_active;
	struct gendisk *gendisk;
	struct kobject kobj;
	int hold_active;
	int major_version;
	int minor_version;
	int patch_version;
	int persistent;
	int external;
	char metadata_type[17];
	int chunk_sectors;
	time64_t ctime;
	time64_t utime;
	int level;
	int layout;
	char clevel[16];
	int raid_disks;
	int max_disks;
	sector_t dev_sectors;
	sector_t array_sectors;
	int external_size;
	__u64 events;
	int can_decrease_events;
	char uuid[16];
	sector_t reshape_position;
	int delta_disks;
	int new_level;
	int new_layout;
	int new_chunk_sectors;
	int reshape_backwards;
	struct md_thread *thread;
	struct md_thread *sync_thread;
	enum sync_action last_sync_action;
	sector_t curr_resync;
	sector_t curr_resync_completed;
	long unsigned int resync_mark;
	sector_t resync_mark_cnt;
	sector_t curr_mark_cnt;
	sector_t resync_max_sectors;
	atomic64_t resync_mismatches;
	sector_t suspend_lo;
	sector_t suspend_hi;
	int sync_speed_min;
	int sync_speed_max;
	int parallel_resync;
	int ok_start_degraded;
	long unsigned int recovery;
	int recovery_disabled;
	int in_sync;
	struct mutex open_mutex;
	struct mutex reconfig_mutex;
	atomic_t active;
	atomic_t openers;
	int changed;
	int degraded;
	atomic_t recovery_active;
	wait_queue_head_t recovery_wait;
	sector_t recovery_cp;
	sector_t resync_min;
	sector_t resync_max;
	struct kernfs_node *sysfs_state;
	struct kernfs_node *sysfs_action;
	struct kernfs_node *sysfs_completed;
	struct kernfs_node *sysfs_degraded;
	struct kernfs_node *sysfs_level;
	struct work_struct del_work;
	struct work_struct sync_work;
	spinlock_t lock;
	wait_queue_head_t sb_wait;
	atomic_t pending_writes;
	unsigned int safemode;
	unsigned int safemode_delay;
	struct timer_list safemode_timer;
	struct percpu_ref writes_pending;
	int sync_checkers;
	void *bitmap;
	struct bitmap_operations *bitmap_ops;
	struct {
		struct file *file;
		loff_t offset;
		long unsigned int space;
		loff_t default_offset;
		long unsigned int default_space;
		struct mutex mutex;
		long unsigned int chunksize;
		long unsigned int daemon_sleep;
		long unsigned int max_write_behind;
		int external;
		int nodes;
		char cluster_name[64];
	} bitmap_info;
	atomic_t max_corr_read_errors;
	struct list_head all_mddevs;
	const struct attribute_group *to_remove;
	struct bio_set bio_set;
	struct bio_set sync_set;
	struct bio_set io_clone_set;
	struct work_struct event_work;
	mempool_t *serial_info_pool;
	void (*sync_super)(struct mddev *, struct md_rdev *);
	struct md_cluster_info *cluster_info;
	unsigned int good_device_nr;
	unsigned int noio_flag;
	struct list_head deleting;
	atomic_t sync_seq;
	bool has_superblocks: 1;
	bool fail_last_dev: 1;
	bool serialize_policy: 1;
};

struct mdio_board_info {
	const char *bus_id;
	char modalias[32];
	int mdio_addr;
	const void *platform_data;
};

struct mdio_board_entry {
	struct list_head list;
	struct mdio_board_info board_info;
};

struct mdio_bus_stat_attr {
	int addr;
	unsigned int field_offset;
};

struct mdio_bus_stats {
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t writes;
	u64_stats_t reads;
	struct u64_stats_sync syncp;
};

struct reset_control;

struct mdio_device {
	struct device dev;
	struct mii_bus *bus;
	char modalias[32];
	int (*bus_match)(struct device *, const struct device_driver *);
	void (*device_free)(struct mdio_device *);
	void (*device_remove)(struct mdio_device *);
	int addr;
	int flags;
	int reset_state;
	struct gpio_desc *reset_gpio;
	struct reset_control *reset_ctrl;
	unsigned int reset_assert_delay;
	unsigned int reset_deassert_delay;
};

struct mdio_driver_common {
	struct device_driver driver;
	int flags;
};

struct mdio_driver {
	struct mdio_driver_common mdiodrv;
	int (*probe)(struct mdio_device *);
	void (*remove)(struct mdio_device *);
	void (*shutdown)(struct mdio_device *);
};

struct mdiobus_devres {
	struct mii_bus *mii;
};

struct mdp_device_descriptor_s {
	__u32 number;
	__u32 major;
	__u32 minor;
	__u32 raid_disk;
	__u32 state;
	__u32 reserved[27];
};

typedef struct mdp_device_descriptor_s mdp_disk_t;

struct mdp_superblock_1 {
	__le32 magic;
	__le32 major_version;
	__le32 feature_map;
	__le32 pad0;
	__u8 set_uuid[16];
	char set_name[32];
	__le64 ctime;
	__le32 level;
	__le32 layout;
	__le64 size;
	__le32 chunksize;
	__le32 raid_disks;
	union {
		__le32 bitmap_offset;
		struct {
			__le16 offset;
			__le16 size;
		} ppl;
	};
	__le32 new_level;
	__le64 reshape_position;
	__le32 delta_disks;
	__le32 new_layout;
	__le32 new_chunk;
	__le32 new_offset;
	__le64 data_offset;
	__le64 data_size;
	__le64 super_offset;
	union {
		__le64 recovery_offset;
		__le64 journal_tail;
	};
	__le32 dev_number;
	__le32 cnt_corrected_read;
	__u8 device_uuid[16];
	__u8 devflags;
	__u8 bblog_shift;
	__le16 bblog_size;
	__le32 bblog_offset;
	__le64 utime;
	__le64 events;
	__le64 resync_offset;
	__le32 sb_csum;
	__le32 max_dev;
	__u8 pad3[32];
	__le16 dev_roles[0];
};

struct mdp_superblock_s {
	__u32 md_magic;
	__u32 major_version;
	__u32 minor_version;
	__u32 patch_version;
	__u32 gvalid_words;
	__u32 set_uuid0;
	__u32 ctime;
	__u32 level;
	__u32 size;
	__u32 nr_disks;
	__u32 raid_disks;
	__u32 md_minor;
	__u32 not_persistent;
	__u32 set_uuid1;
	__u32 set_uuid2;
	__u32 set_uuid3;
	__u32 gstate_creserved[16];
	__u32 utime;
	__u32 state;
	__u32 active_disks;
	__u32 working_disks;
	__u32 failed_disks;
	__u32 spare_disks;
	__u32 sb_csum;
	__u32 events_lo;
	__u32 events_hi;
	__u32 cp_events_lo;
	__u32 cp_events_hi;
	__u32 recovery_cp;
	__u64 reshape_position;
	__u32 new_level;
	__u32 delta_disks;
	__u32 new_layout;
	__u32 new_chunk;
	__u32 gstate_sreserved[14];
	__u32 layout;
	__u32 chunk_size;
	__u32 root_pv;
	__u32 root_block;
	__u32 pstate_reserved[60];
	mdp_disk_t disks[27];
	__u32 reserved[0];
	mdp_disk_t this_disk;
};

typedef struct mdp_superblock_s mdp_super_t;

struct mdu_array_info_s {
	int major_version;
	int minor_version;
	int patch_version;
	unsigned int ctime;
	int level;
	int size;
	int nr_disks;
	int raid_disks;
	int md_minor;
	int not_persistent;
	unsigned int utime;
	int state;
	int active_disks;
	int working_disks;
	int failed_disks;
	int spare_disks;
	int layout;
	int chunk_size;
};

typedef struct mdu_array_info_s mdu_array_info_t;

struct mdu_bitmap_file_s {
	char pathname[4096];
};

typedef struct mdu_bitmap_file_s mdu_bitmap_file_t;

struct mdu_disk_info_s {
	int number;
	int major;
	int minor;
	int raid_disk;
	int state;
};

typedef struct mdu_disk_info_s mdu_disk_info_t;

struct mdu_version_s {
	int major;
	int minor;
	int patchlevel;
};

typedef struct mdu_version_s mdu_version_t;

struct measure_breadcrumb {
	struct i915_request rq;
	struct intel_ring ring;
	u32 cs[2048];
};

struct mei_aux_device {
	struct auxiliary_device aux_dev;
	int irq;
	struct resource bar;
	struct resource ext_op_mem;
	bool slow_firmware;
};

struct mei_bus_message {
	u8 hbm_cmd;
	u8 data[0];
};

struct mei_fw_status {
	int count;
	u32 status[6];
};

struct mei_cfg {
	const struct mei_fw_status fw_status;
	bool (*quirk_probe)(const struct pci_dev *);
	const char *kind;
	size_t dma_size[3];
	u32 fw_ver_supported: 1;
	u32 hw_trc_supported: 1;
};

struct mei_dma_data {
	u8 buffer_id;
	void *vaddr;
	dma_addr_t daddr;
	size_t size;
};

struct mei_device;

struct mei_me_client;

struct mei_cl_device;

struct mei_cl {
	struct list_head link;
	struct mei_device *dev;
	enum file_state state;
	wait_queue_head_t tx_wait;
	wait_queue_head_t rx_wait;
	wait_queue_head_t wait;
	wait_queue_head_t ev_wait;
	struct fasync_struct *ev_async;
	int status;
	struct mei_me_client *me_cl;
	const struct file *fp;
	u8 host_client_id;
	struct list_head vtag_map;
	u8 tx_flow_ctrl_creds;
	u8 rx_flow_ctrl_creds;
	u8 timer_count;
	u8 notify_en;
	u8 notify_ev;
	u8 tx_cb_queued;
	enum mei_file_transaction_states writing_state;
	struct list_head rd_pending;
	spinlock_t rd_completed_lock;
	struct list_head rd_completed;
	struct mei_dma_data dma;
	u8 dma_mapped;
	struct mei_cl_device *cldev;
};

struct mei_msg_data {
	size_t size;
	unsigned char *data;
};

struct mei_ext_hdr;

struct mei_cl_cb {
	struct list_head list;
	struct mei_cl *cl;
	enum mei_cb_file_ops fop_type;
	struct mei_msg_data buf;
	size_t buf_idx;
	u8 vtag;
	const struct file *fp;
	int status;
	u32 internal: 1;
	u32 blocking: 1;
	struct mei_ext_hdr *ext_hdr;
};

typedef void (*mei_cldev_cb_t)(struct mei_cl_device *);

struct mei_cl_device {
	struct list_head bus_list;
	struct mei_device *bus;
	struct device dev;
	struct mei_me_client *me_cl;
	struct mei_cl *cl;
	char name[32];
	struct work_struct rx_work;
	mei_cldev_cb_t rx_cb;
	struct work_struct notif_work;
	mei_cldev_cb_t notif_cb;
	unsigned int do_match: 1;
	unsigned int is_added: 1;
	void *priv_data;
};

struct mei_cl_device_id {
	char name[32];
	uuid_le uuid;
	__u8 version;
	kernel_ulong_t driver_info;
};

struct mei_cl_driver {
	struct device_driver driver;
	const char *name;
	const struct mei_cl_device_id *id_table;
	int (*probe)(struct mei_cl_device *, const struct mei_cl_device_id *);
	void (*remove)(struct mei_cl_device *);
};

struct mei_cl_vtag {
	struct list_head list;
	const struct file *fp;
	u8 vtag;
	u8 pending_read: 1;
};

struct mei_client {
	__u32 max_msg_length;
	__u8 protocol_version;
	__u8 reserved[3];
};

struct mei_connect_client_data {
	union {
		uuid_le in_client_uuid;
		struct mei_client out_client_properties;
	};
};

struct mei_connect_client_vtag {
	uuid_le in_client_uuid;
	__u8 vtag;
	__u8 reserved[3];
};

struct mei_connect_client_data_vtag {
	union {
		struct mei_connect_client_vtag connect;
		struct mei_client out_client_properties;
	};
};

struct mei_dev_timeouts {
	long unsigned int hw_ready;
	int connect;
	long unsigned int cl_connect;
	int client_init;
	long unsigned int pgi;
	unsigned int d0i3;
	long unsigned int hbm;
	long unsigned int mkhi_recv;
};

struct mei_dma_dscr {
	void *vaddr;
	dma_addr_t daddr;
	size_t size;
};

struct mei_fw_version {
	u8 platform;
	u8 major;
	u16 minor;
	u16 buildno;
	u16 hotfix;
};

struct mei_hw_ops;

struct mei_device {
	struct device *dev;
	struct cdev cdev;
	int minor;
	struct list_head write_list;
	struct list_head write_waiting_list;
	struct list_head ctrl_wr_list;
	struct list_head ctrl_rd_list;
	u8 tx_queue_limit;
	struct list_head file_list;
	long int open_handle_count;
	struct mutex device_lock;
	struct delayed_work timer_work;
	bool recvd_hw_ready;
	wait_queue_head_t wait_hw_ready;
	wait_queue_head_t wait_pg;
	wait_queue_head_t wait_hbm_start;
	long unsigned int reset_count;
	enum mei_dev_state dev_state;
	enum mei_hbm_state hbm_state;
	enum mei_dev_pxp_mode pxp_mode;
	u16 init_clients_timer;
	enum mei_pg_event pg_event;
	struct dev_pm_domain pg_domain;
	unsigned char rd_msg_buf[512];
	u32 rd_msg_hdr[512];
	int rd_msg_hdr_count;
	bool hbuf_is_ready;
	struct mei_dma_dscr dr_dscr[3];
	struct hbm_version version;
	unsigned int hbm_f_pg_supported: 1;
	unsigned int hbm_f_dc_supported: 1;
	unsigned int hbm_f_dot_supported: 1;
	unsigned int hbm_f_ev_supported: 1;
	unsigned int hbm_f_fa_supported: 1;
	unsigned int hbm_f_ie_supported: 1;
	unsigned int hbm_f_os_supported: 1;
	unsigned int hbm_f_dr_supported: 1;
	unsigned int hbm_f_vt_supported: 1;
	unsigned int hbm_f_cap_supported: 1;
	unsigned int hbm_f_cd_supported: 1;
	unsigned int hbm_f_gsc_supported: 1;
	struct mei_fw_version fw_ver[3];
	unsigned int fw_f_fw_ver_supported: 1;
	unsigned int fw_ver_received: 1;
	struct rw_semaphore me_clients_rwsem;
	struct list_head me_clients;
	long unsigned int me_clients_map[4];
	long unsigned int host_clients_map[4];
	bool allow_fixed_address;
	bool override_fixed_address;
	struct mei_dev_timeouts timeouts;
	struct work_struct reset_work;
	struct work_struct bus_rescan_work;
	struct list_head device_list;
	struct mutex cl_bus_lock;
	const char *kind;
	struct dentry *dbgfs_dir;
	struct mei_fw_status saved_fw_status;
	enum mei_dev_state saved_dev_state;
	bool saved_fw_status_flag;
	enum mei_dev_reset_to_pxp gsc_reset_to_pxp;
	const struct mei_hw_ops *ops;
	char hw[0];
};

struct mei_ext_hdr {
	u8 type;
	u8 length;
};

struct mei_ext_hdr_gsc_f2h {
	struct mei_ext_hdr hdr;
	u8 client_id;
	u8 reserved;
	u32 fence_id;
	u32 written;
};

struct mei_gsc_sgl {
	u32 low;
	u32 high;
	u32 length;
};

struct mei_ext_hdr_gsc_h2f {
	struct mei_ext_hdr hdr;
	u8 client_id;
	u8 addr_type;
	u32 fence_id;
	u8 input_address_count;
	u8 output_address_count;
	u8 reserved[2];
	struct mei_gsc_sgl sgl[0];
};

struct mei_ext_hdr_vtag {
	struct mei_ext_hdr hdr;
	u8 vtag;
	u8 reserved;
};

struct mei_ext_meta_hdr {
	u8 count;
	u8 size;
	u8 reserved[2];
	u8 hdrs[0];
};

struct mei_fixup {
	const uuid_le uuid;
	void (*hook)(struct mei_cl_device *);
};

struct mei_hbm_cl_cmd {
	u8 hbm_cmd;
	u8 me_addr;
	u8 host_addr;
	u8 data;
};

struct mei_hw_ops {
	bool (*host_is_ready)(struct mei_device *);
	bool (*hw_is_ready)(struct mei_device *);
	int (*hw_reset)(struct mei_device *, bool);
	int (*hw_start)(struct mei_device *);
	int (*hw_config)(struct mei_device *);
	int (*fw_status)(struct mei_device *, struct mei_fw_status *);
	int (*trc_status)(struct mei_device *, u32 *);
	enum mei_pg_state (*pg_state)(struct mei_device *);
	bool (*pg_in_transition)(struct mei_device *);
	bool (*pg_is_enabled)(struct mei_device *);
	void (*intr_clear)(struct mei_device *);
	void (*intr_enable)(struct mei_device *);
	void (*intr_disable)(struct mei_device *);
	void (*synchronize_irq)(struct mei_device *);
	int (*hbuf_free_slots)(struct mei_device *);
	bool (*hbuf_is_ready)(struct mei_device *);
	u32 (*hbuf_depth)(const struct mei_device *);
	int (*write)(struct mei_device *, const void *, size_t, const void *, size_t);
	int (*rdbuf_full_slots)(struct mei_device *);
	u32 (*read_hdr)(const struct mei_device *);
	int (*read)(struct mei_device *, unsigned char *, long unsigned int);
};

struct mei_me_client {
	struct list_head list;
	struct kref refcnt;
	struct mei_client_properties props;
	u8 client_id;
	u8 tx_flow_ctrl_creds;
	u8 connect_count;
	u8 bus_added;
};

struct mei_me_hw {
	const struct mei_cfg *cfg;
	void *mem_addr;
	int irq;
	enum mei_pg_state pg_state;
	bool d0i3_supported;
	u8 hbuf_depth;
	int (*read_fws)(const struct mei_device *, int, u32 *);
	struct task_struct *polling_thread;
	wait_queue_head_t wait_active;
	bool is_active;
};

struct mei_msg_hdr {
	u32 me_addr: 8;
	u32 host_addr: 8;
	u32 length: 9;
	u32 reserved: 3;
	u32 extended: 1;
	u32 dma_ring: 1;
	u32 internal: 1;
	u32 msg_complete: 1;
	u32 extension[0];
};

struct mei_nfc_cmd {
	u8 command;
	u8 status;
	u16 req_id;
	u32 reserved;
	u16 data_size;
	u8 sub_command;
	u8 data[0];
} __attribute__((packed));

struct mei_nfc_if_version {
	u8 radio_version_sw[3];
	u8 reserved[3];
	u8 radio_version_hw[3];
	u8 i2c_addr;
	u8 fw_ivn;
	u8 vendor_id;
	u8 radio_type;
};

struct mei_nfc_reply {
	u8 command;
	u8 status;
	u16 req_id;
	u32 reserved;
	u16 data_size;
	u8 sub_command;
	u8 reply_status;
	u8 data[0];
};

struct mei_os_ver {
	__le16 build;
	__le16 reserved1;
	u8 os_type;
	u8 major;
	u8 minor;
	u8 reserved2;
};

struct mem_cgroup_id {
	int id;
	refcount_t ref;
};

struct vmpressure {
	long unsigned int scanned;
	long unsigned int reclaimed;
	long unsigned int tree_scanned;
	long unsigned int tree_reclaimed;
	spinlock_t sr_lock;
	struct list_head events;
	struct mutex events_lock;
	struct work_struct work;
};

struct wb_domain {
	spinlock_t lock;
	struct fprop_global completions;
	struct timer_list period_timer;
	long unsigned int period_time;
	long unsigned int dirty_limit_tstamp;
	long unsigned int dirty_limit;
};

struct wb_completion {
	atomic_t cnt;
	wait_queue_head_t *waitq;
};

struct memcg_cgwb_frn {
	u64 bdi_id;
	int memcg_id;
	u64 at;
	struct wb_completion done;
};

struct memcg_vmstats;

struct memcg_vmstats_percpu;

struct mem_cgroup_per_node;

struct mem_cgroup {
	struct cgroup_subsys_state css;
	struct mem_cgroup_id id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct page_counter memory;
	union {
		struct page_counter swap;
		struct page_counter memsw;
	};
	struct list_head memory_peaks;
	struct list_head swap_peaks;
	spinlock_t peaks_lock;
	struct work_struct high_work;
	struct vmpressure vmpressure;
	bool oom_group;
	int swappiness;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	struct cgroup_file swap_events_file;
	struct memcg_vmstats *vmstats;
	atomic_long_t memory_events[9];
	atomic_long_t memory_events_local[9];
	long unsigned int socket_pressure;
	int kmemcg_id;
	struct obj_cgroup *objcg;
	struct obj_cgroup *orig_objcg;
	struct list_head objcg_list;
	struct memcg_vmstats_percpu *vmstats_percpu;
	struct list_head cgwb_list;
	struct wb_domain cgwb_domain;
	struct memcg_cgwb_frn cgwb_frn[4];
	struct mem_cgroup_per_node *nodeinfo[0];
	long: 64;
	long: 64;
	long: 64;
};

struct mem_cgroup_reclaim_iter {
	struct mem_cgroup *position;
	atomic_t generation;
};

struct shrinker_info;

struct mem_cgroup_per_node {
	struct mem_cgroup *memcg;
	struct lruvec_stats_percpu *lruvec_stats_percpu;
	struct lruvec_stats *lruvec_stats;
	struct shrinker_info *shrinker_info;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad1_;
	struct lruvec lruvec;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad2_;
	long unsigned int lru_zone_size[20];
	struct mem_cgroup_reclaim_iter iter;
	long: 64;
	long: 64;
};

typedef struct pglist_data pg_data_t;

struct mem_cgroup_reclaim_cookie {
	pg_data_t *pgdat;
	int generation;
};

struct quota_format_type;

struct mem_dqinfo {
	struct quota_format_type *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	long unsigned int dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
};

struct mem_extent {
	struct list_head hook;
	long unsigned int start;
	long unsigned int end;
};

struct mem_section_usage;

struct page_ext;

struct mem_section {
	long unsigned int section_mem_map;
	struct mem_section_usage *usage;
	struct page_ext *page_ext;
	long unsigned int pad;
};

struct mem_section_usage {
	struct callback_head rcu;
	long unsigned int subsection_map[1];
	long unsigned int pageblock_flags[0];
};

struct mem_size_stats {
	long unsigned int resident;
	long unsigned int shared_clean;
	long unsigned int shared_dirty;
	long unsigned int private_clean;
	long unsigned int private_dirty;
	long unsigned int referenced;
	long unsigned int anonymous;
	long unsigned int lazyfree;
	long unsigned int anonymous_thp;
	long unsigned int shmem_thp;
	long unsigned int file_thp;
	long unsigned int swap;
	long unsigned int shared_hugetlb;
	long unsigned int private_hugetlb;
	long unsigned int ksm;
	u64 pss;
	u64 pss_anon;
	u64 pss_file;
	u64 pss_shmem;
	u64 pss_dirty;
	u64 pss_locked;
	u64 swap_pss;
};

struct mem_zone_bm_rtree {
	struct list_head list;
	struct list_head nodes;
	struct list_head leaves;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	struct rtree_node *rtree;
	int levels;
	unsigned int blocks;
};

struct memblock_region;

struct memblock_type {
	long unsigned int cnt;
	long unsigned int max;
	phys_addr_t total_size;
	struct memblock_region *regions;
	char *name;
};

struct memblock {
	bool bottom_up;
	phys_addr_t current_limit;
	struct memblock_type memory;
	struct memblock_type reserved;
};

struct memblock_region {
	phys_addr_t base;
	phys_addr_t size;
	enum memblock_flags flags;
	int nid;
};

struct membuf {
	void *p;
	size_t left;
};

struct memcg_stock_pcp {
	local_lock_t stock_lock;
	struct mem_cgroup *cached;
	unsigned int nr_pages;
	struct obj_cgroup *cached_objcg;
	struct pglist_data *cached_pgdat;
	unsigned int nr_bytes;
	int nr_slab_reclaimable_b;
	int nr_slab_unreclaimable_b;
	struct work_struct work;
	long unsigned int flags;
};

struct memcg_vmstats {
	long int state[38];
	long unsigned int events[17];
	long int state_local[38];
	long unsigned int events_local[17];
	long int state_pending[38];
	long unsigned int events_pending[17];
	atomic64_t stats_updates;
};

struct memcg_vmstats_percpu {
	unsigned int stats_updates;
	struct memcg_vmstats_percpu *parent;
	struct memcg_vmstats *vmstats;
	long int state[38];
	long unsigned int events[17];
	long int state_prev[38];
	long unsigned int events_prev[17];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct memdev {
	const char *name;
	const struct file_operations *fops;
	fmode_t fmode;
	umode_t mode;
};

struct memmap_attribute {
	struct attribute attr;
	ssize_t (*show)(struct firmware_map_entry *, char *);
};

struct memory_bitmap {
	struct list_head zones;
	struct linked_page *p_list;
	struct bm_position cur;
};

struct memory_group;

struct memory_block {
	long unsigned int start_section_nr;
	long unsigned int state;
	int online_type;
	int nid;
	struct zone *zone;
	struct device dev;
	struct vmem_altmap *altmap;
	struct memory_group *group;
	struct list_head group_next;
};

struct memory_dev_type {
	struct list_head tier_sibling;
	struct list_head list;
	int adistance;
	nodemask_t nodes;
	struct kref kref;
};

struct memory_group {
	int nid;
	struct list_head memory_blocks;
	long unsigned int present_kernel_pages;
	long unsigned int present_movable_pages;
	bool is_dynamic;
	union {
		struct {
			long unsigned int max_pages;
		} s;
		struct {
			long unsigned int unit_pages;
		} d;
	};
};

struct memory_notify {
	long unsigned int altmap_start_pfn;
	long unsigned int altmap_nr_pages;
	long unsigned int start_pfn;
	long unsigned int nr_pages;
	int status_change_nid_normal;
	int status_change_nid;
};

struct memory_stat {
	const char *name;
	unsigned int idx;
};

struct memory_tier {
	struct list_head list;
	struct list_head memory_types;
	int adistance_start;
	struct device dev;
	nodemask_t lower_tier_mask;
};

struct mempolicy {
	atomic_t refcnt;
	short unsigned int mode;
	short unsigned int flags;
	nodemask_t nodes;
	int home_node;
	union {
		nodemask_t cpuset_mems_allowed;
		nodemask_t user_nodemask;
	} w;
};

struct mempolicy_operations {
	int (*create)(struct mempolicy *, const nodemask_t *);
	void (*rebind)(struct mempolicy *, const nodemask_t *);
};

struct memtype {
	u64 start;
	u64 end;
	u64 subtree_max_end;
	enum page_cache_mode type;
	struct rb_node rb;
};

struct menu_device {
	int needs_update;
	int tick_wakeup;
	u64 next_timer_ns;
	unsigned int bucket;
	unsigned int correction_factor[6];
	unsigned int intervals[8];
	int interval_ptr;
};

struct tcf_meta_val {
	__u16 kind;
	__u8 shift;
	__u8 op;
};

struct meta_value {
	struct tcf_meta_val hdr;
	long unsigned int val;
	unsigned int len;
};

struct meta_match {
	struct meta_value lvalue;
	struct meta_value rvalue;
};

struct meta_obj {
	long unsigned int value;
	unsigned int len;
};

struct tcf_pkt_info;

struct meta_ops {
	void (*get)(struct sk_buff *, struct tcf_pkt_info *, struct meta_value *, struct meta_obj *, int *);
};

struct meta_tlvhdr {
	__be16 type;
	__be16 len;
};

struct meta_type_ops {
	void (*destroy)(struct meta_value *);
	int (*compare)(struct meta_obj *, struct meta_obj *);
	int (*change)(struct meta_value *, struct nlattr *);
	void (*apply_extras)(struct meta_value *, struct meta_obj *);
	int (*dump)(struct sk_buff *, struct meta_value *, int);
};

struct xfrm_md_info {
	u32 if_id;
	int link;
	struct dst_entry *dst_orig;
};

struct metadata_dst {
	struct dst_entry dst;
	enum metadata_type type;
	union {
		struct ip_tunnel_info tun_info;
		struct hw_port_info port_info;
		struct macsec_info macsec_info;
		struct xfrm_md_info xfrm_info;
	} u;
};

struct mf6cctl {
	struct sockaddr_in6 mf6cc_origin;
	struct sockaddr_in6 mf6cc_mcastgrp;
	mifi_t mf6cc_parent;
	struct if_set mf6cc_ifset;
};

struct mr_mfc {
	struct rhlist_head mnode;
	short unsigned int mfc_parent;
	int mfc_flags;
	union {
		struct {
			long unsigned int expires;
			struct sk_buff_head unresolved;
		} unres;
		struct {
			long unsigned int last_assert;
			int minvif;
			int maxvif;
			atomic_long_t bytes;
			atomic_long_t pkt;
			atomic_long_t wrong_if;
			long unsigned int lastuse;
			unsigned char ttls[32];
			refcount_t refcount;
		} res;
	} mfc_un;
	struct list_head list;
	struct callback_head rcu;
	void (*free)(struct callback_head *);
};

struct mfc6_cache_cmp_arg {
	struct in6_addr mf6c_mcastgrp;
	struct in6_addr mf6c_origin;
};

struct mfc6_cache {
	struct mr_mfc _c;
	union {
		struct {
			struct in6_addr mf6c_mcastgrp;
			struct in6_addr mf6c_origin;
		};
		struct mfc6_cache_cmp_arg cmparg;
	};
};

struct mfc_cache_cmp_arg {
	__be32 mfc_mcastgrp;
	__be32 mfc_origin;
};

struct mfc_cache {
	struct mr_mfc _c;
	union {
		struct {
			__be32 mfc_mcastgrp;
			__be32 mfc_origin;
		};
		struct mfc_cache_cmp_arg cmparg;
	};
};

struct mfc_entry_notifier_info {
	struct fib_notifier_info info;
	struct mr_mfc *mfc;
	u32 tb_id;
};

struct mfcctl {
	struct in_addr mfcc_origin;
	struct in_addr mfcc_mcastgrp;
	vifi_t mfcc_parent;
	unsigned char mfcc_ttls[32];
	unsigned int mfcc_pkt_cnt;
	unsigned int mfcc_byte_cnt;
	unsigned int mfcc_wrong_if;
	int mfcc_expire;
};

struct mhp_params {
	struct vmem_altmap *altmap;
	pgprot_t pgprot;
	struct dev_pagemap *pgmap;
};

struct microcode_header_amd {
	u32 data_code;
	u32 patch_id;
	u16 mc_patch_data_id;
	u8 mc_patch_data_len;
	u8 init_flag;
	u32 mc_patch_data_checksum;
	u32 nb_dev_id;
	u32 sb_dev_id;
	u16 processor_rev_id;
	u8 nb_rev_id;
	u8 sb_rev_id;
	u8 bios_api_rev;
	u8 reserved1[3];
	u32 match_reg[8];
};

struct microcode_amd {
	struct microcode_header_amd hdr;
	unsigned int mpb[0];
};

struct microcode_header_intel {
	unsigned int hdrver;
	unsigned int rev;
	unsigned int date;
	unsigned int sig;
	unsigned int cksum;
	unsigned int ldrver;
	unsigned int pf;
	unsigned int datasize;
	unsigned int totalsize;
	unsigned int metasize;
	unsigned int min_req_ver;
	unsigned int reserved;
};

struct microcode_intel {
	struct microcode_header_intel hdr;
	unsigned int bits[0];
};

struct microcode_ops {
	enum ucode_state (*request_microcode_fw)(int, struct device *);
	void (*microcode_fini_cpu)(int);
	enum ucode_state (*apply_microcode)(int);
	int (*collect_cpu_info)(int, struct cpu_signature *);
	void (*finalize_late_load)(int);
	unsigned int nmi_safe: 1;
	unsigned int use_nmi: 1;
};

struct mid8250_board;

struct mid8250 {
	int line;
	int dma_index;
	struct pci_dev *dma_dev;
	struct uart_8250_dma dma;
	struct mid8250_board *board;
	struct hsu_dma_chip dma_chip;
};

struct mid8250_board {
	long unsigned int freq;
	unsigned int base_baud;
	unsigned int bar;
	int (*setup)(struct mid8250 *, struct uart_port *);
	void (*exit)(struct mid8250 *);
};

struct mif6ctl {
	mifi_t mif6c_mifi;
	unsigned char mif6c_flags;
	unsigned char vifc_threshold;
	__u16 mif6c_pifi;
	unsigned int vifc_rate_limit;
};

struct migrate_pages_stats {
	int nr_succeeded;
	int nr_failed_pages;
	int nr_thp_succeeded;
	int nr_thp_failed;
	int nr_thp_split;
	int nr_split;
};

struct migrate_struct {
	ext4_lblk_t first_block;
	ext4_lblk_t last_block;
	ext4_lblk_t curr_block;
	ext4_fsblk_t first_pblock;
	ext4_fsblk_t last_pblock;
};

struct set_affinity_pending;

struct migration_arg {
	struct task_struct *task;
	int dest_cpu;
	struct set_affinity_pending *pending;
};

struct migration_mpol {
	struct mempolicy *pol;
	long unsigned int ilx;
};

struct migration_target_control {
	int nid;
	nodemask_t *nmask;
	gfp_t gfp_mask;
	enum migrate_reason reason;
};

struct phy_package_shared;

struct mii_bus {
	struct module *owner;
	const char *name;
	char id[61];
	void *priv;
	int (*read)(struct mii_bus *, int, int);
	int (*write)(struct mii_bus *, int, int, u16);
	int (*read_c45)(struct mii_bus *, int, int, int);
	int (*write_c45)(struct mii_bus *, int, int, int, u16);
	int (*reset)(struct mii_bus *);
	struct mdio_bus_stats stats[32];
	struct mutex mdio_lock;
	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED = 2,
		MDIOBUS_UNREGISTERED = 3,
		MDIOBUS_RELEASED = 4,
	} state;
	struct device dev;
	struct mdio_device *mdio_map[32];
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
	int irq[32];
	int reset_delay_us;
	int reset_post_delay_us;
	struct gpio_desc *reset_gpiod;
	struct mutex shared_lock;
	struct phy_package_shared *shared[32];
};

struct mii_ioctl_data {
	__u16 phy_id;
	__u16 reg_num;
	__u16 val_in;
	__u16 val_out;
};

struct mii_timestamper {
	bool (*rxtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	void (*txtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	int (*hwtstamp)(struct mii_timestamper *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
	void (*link_state)(struct mii_timestamper *, struct phy_device *);
	int (*ts_info)(struct mii_timestamper *, struct kernel_ethtool_ts_info *);
	struct device *device;
};

struct min_heap_callbacks {
	bool (*less)(const void *, const void *, void *);
	void (*swp)(void *, void *, void *);
};

struct min_heap_char {
	size_t nr;
	size_t size;
	char *data;
	char preallocated[0];
};

typedef struct min_heap_char min_heap_char;

struct min_max_quirk {
	const char * const *pnp_ids;
	struct {
		u32 min;
		u32 max;
	} board_id;
	u32 x_min;
	u32 x_max;
	u32 y_min;
	u32 y_max;
};

struct minimode {
	short int w;
	short int h;
	short int r;
	short int rb;
};

struct mip6_report_rate_limiter {
	spinlock_t lock;
	ktime_t stamp;
	int iif;
	struct in6_addr src;
	struct in6_addr dst;
};

struct mipi_dsi_device {
	struct mipi_dsi_host *host;
	struct device dev;
	bool attached;
	char name[20];
	unsigned int channel;
	unsigned int lanes;
	enum mipi_dsi_pixel_format format;
	long unsigned int mode_flags;
	long unsigned int hs_rate;
	long unsigned int lp_rate;
	struct drm_dsc_config *dsc;
};

struct mipi_dsi_device_info {
	char type[20];
	u32 channel;
	struct device_node *node;
};

struct mipi_dsi_driver {
	struct device_driver driver;
	int (*probe)(struct mipi_dsi_device *);
	void (*remove)(struct mipi_dsi_device *);
	void (*shutdown)(struct mipi_dsi_device *);
};

struct mipi_dsi_msg;

struct mipi_dsi_host_ops {
	int (*attach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	int (*detach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	ssize_t (*transfer)(struct mipi_dsi_host *, const struct mipi_dsi_msg *);
};

struct mipi_dsi_msg {
	u8 channel;
	u8 type;
	u16 flags;
	size_t tx_len;
	const void *tx_buf;
	size_t rx_len;
	void *rx_buf;
};

struct mipi_dsi_multi_context {
	struct mipi_dsi_device *dsi;
	int accum_err;
};

struct mipi_dsi_packet {
	size_t size;
	u8 header[4];
	size_t payload_length;
	const u8 *payload;
};

struct mirror_set;

struct mirror {
	struct mirror_set *ms;
	atomic_t error_count;
	long unsigned int error_type;
	struct dm_dev *dev;
	sector_t offset;
};

struct mirror_set {
	struct dm_target *ti;
	struct list_head list;
	uint64_t features;
	spinlock_t lock;
	struct bio_list reads;
	struct bio_list writes;
	struct bio_list failures;
	struct bio_list holds;
	struct dm_region_hash *rh;
	struct dm_kcopyd_client *kcopyd_client;
	struct dm_io_client *io_client;
	region_t nr_regions;
	int in_sync;
	int log_failure;
	int leg_failure;
	atomic_t suspend;
	atomic_t default_mirror;
	struct workqueue_struct *kmirrord_wq;
	struct work_struct kmirrord_work;
	struct timer_list timer;
	long unsigned int timer_pending;
	struct work_struct trigger_event;
	unsigned int nr_mirrors;
	struct mirror mirror[0];
};

struct misc_res {
	u64 max;
	atomic64_t watermark;
	atomic64_t usage;
	atomic64_t events;
	atomic64_t events_local;
};

struct misc_cg {
	struct cgroup_subsys_state css;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	struct misc_res res[0];
};

struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

struct mkhi_fw_ver_block {
	u16 minor;
	u8 major;
	u8 platform;
	u16 buildno;
	u16 hotfix;
};

struct mkhi_fw_ver {
	struct mkhi_fw_ver_block ver[3];
};

struct mkhi_rule_id {
	__le16 rule_type;
	u8 feature_id;
	u8 reserved;
};

struct mkhi_fwcaps {
	struct mkhi_rule_id id;
	u8 len;
	u8 data[0];
} __attribute__((packed));

struct mkhi_msg_hdr {
	u8 group_id;
	u8 command;
	u8 reserved;
	u8 result;
};

struct mkhi_gfx_mem_ready {
	struct mkhi_msg_hdr hdr;
	u32 flags;
};

struct mkhi_msg {
	struct mkhi_msg_hdr hdr;
	u8 data[0];
};

struct ml_effect_state {
	struct ff_effect *effect;
	long unsigned int flags;
	int count;
	long unsigned int play_at;
	long unsigned int stop_at;
	long unsigned int adj_at;
};

struct ml_device {
	void *private;
	struct ml_effect_state states[16];
	int gain;
	struct timer_list timer;
	struct input_dev *dev;
	int (*play_effect)(struct input_dev *, void *, struct ff_effect *);
};

struct mld2_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	struct in6_addr grec_mca;
	struct in6_addr grec_src[0];
};

struct mld2_query {
	struct icmp6hdr mld2q_hdr;
	struct in6_addr mld2q_mca;
	__u8 mld2q_qrv: 3;
	__u8 mld2q_suppress: 1;
	__u8 mld2q_resv2: 4;
	__u8 mld2q_qqic;
	__be16 mld2q_nsrcs;
	struct in6_addr mld2q_srcs[0];
};

struct mld2_report {
	struct icmp6hdr mld2r_hdr;
	struct mld2_grec mld2r_grec[0];
};

struct mld_msg {
	struct icmp6hdr mld_hdr;
	struct in6_addr mld_mca;
};

struct mlock_fbatch {
	local_lock_t lock;
	struct folio_batch fbatch;
};

struct mm_cid {
	u64 time;
	int cid;
	int recent_cid;
};

struct mm_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_mm_state state;
	struct ethtool_mm_stats stats;
};

struct xol_area;

struct uprobes_state {
	struct xol_area *xol_area;
};

struct mmu_notifier_subscriptions;

struct mm_struct {
	struct {
		struct {
			atomic_t mm_count;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
			long: 64;
		};
		struct maple_tree mm_mt;
		long unsigned int mmap_base;
		long unsigned int mmap_legacy_base;
		long unsigned int task_size;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		struct mm_cid *pcpu_cid;
		long unsigned int mm_cid_next_scan;
		unsigned int nr_cpus_allowed;
		atomic_t max_nr_cid;
		raw_spinlock_t cpus_allowed_lock;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_lock;
		struct list_head mmlist;
		seqcount_t mm_lock_seq;
		long unsigned int hiwater_rss;
		long unsigned int hiwater_vm;
		long unsigned int total_vm;
		long unsigned int locked_vm;
		atomic64_t pinned_vm;
		long unsigned int data_vm;
		long unsigned int exec_vm;
		long unsigned int stack_vm;
		long unsigned int def_flags;
		seqcount_t write_protect_seq;
		spinlock_t arg_lock;
		long unsigned int start_code;
		long unsigned int end_code;
		long unsigned int start_data;
		long unsigned int end_data;
		long unsigned int start_brk;
		long unsigned int brk;
		long unsigned int start_stack;
		long unsigned int arg_start;
		long unsigned int arg_end;
		long unsigned int env_start;
		long unsigned int env_end;
		long unsigned int saved_auxv[50];
		struct percpu_counter rss_stat[4];
		struct linux_binfmt *binfmt;
		mm_context_t context;
		long unsigned int flags;
		spinlock_t ioctx_lock;
		struct kioctx_table *ioctx_table;
		struct task_struct *owner;
		struct user_namespace *user_ns;
		struct file *exe_file;
		struct mmu_notifier_subscriptions *notifier_subscriptions;
		atomic_t tlb_flush_pending;
		atomic_t tlb_flush_batched;
		struct uprobes_state uprobes_state;
		atomic_long_t hugetlb_usage;
		struct work_struct async_put_work;
		struct iommu_mm_data *iommu_mm;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	long unsigned int cpu_bitmap[0];
};

struct mm_struct__safe_rcu_or_null {
	struct file *exe_file;
};

struct mm_walk_ops;

struct mm_walk {
	const struct mm_walk_ops *ops;
	struct mm_struct *mm;
	pgd_t *pgd;
	struct vm_area_struct *vma;
	enum page_walk_action action;
	bool no_vma;
	void *private;
};

struct mm_walk_ops {
	int (*pgd_entry)(pgd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*p4d_entry)(p4d_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_hole)(long unsigned int, long unsigned int, int, struct mm_walk *);
	int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
	int (*test_walk)(long unsigned int, long unsigned int, struct mm_walk *);
	int (*pre_vma)(long unsigned int, long unsigned int, struct mm_walk *);
	void (*post_vma)(struct mm_walk *);
	int (*install_pte)(long unsigned int, long unsigned int, pte_t *, struct mm_walk *);
	enum page_walk_lock walk_lock;
};

struct vma_munmap_struct {
	struct vma_iterator *vmi;
	struct vm_area_struct *vma;
	struct vm_area_struct *prev;
	struct vm_area_struct *next;
	struct list_head *uf;
	long unsigned int start;
	long unsigned int end;
	long unsigned int unmap_start;
	long unsigned int unmap_end;
	int vma_count;
	bool unlock;
	bool clear_ptes;
	long unsigned int nr_pages;
	long unsigned int locked_vm;
	long unsigned int nr_accounted;
	long unsigned int exec_vm;
	long unsigned int stack_vm;
	long unsigned int data_vm;
};

struct mmap_state {
	struct mm_struct *mm;
	struct vma_iterator *vmi;
	long unsigned int addr;
	long unsigned int end;
	long unsigned int pgoff;
	long unsigned int pglen;
	long unsigned int flags;
	struct file *file;
	long unsigned int charged;
	bool retry_merge;
	struct vm_area_struct *prev;
	struct vm_area_struct *next;
	struct vma_munmap_struct vms;
	struct ma_state mas_detach;
	struct maple_tree mt_detach;
};

struct mmap_unlock_irq_work {
	struct irq_work irq_work;
	struct mm_struct *mm;
};

struct mminit_pfnnid_cache {
	long unsigned int last_start;
	long unsigned int last_end;
	int last_nid;
};

struct mmp_struct {
	__le32 mmp_magic;
	__le32 mmp_seq;
	__le64 mmp_time;
	char mmp_nodename[64];
	char mmp_bdevname[32];
	__le16 mmp_check_interval;
	__le16 mmp_pad1;
	__le32 mmp_pad2[226];
	__le32 mmp_checksum;
};

struct mmpin {
	struct user_struct *user;
	unsigned int num_pg;
};

struct user_msghdr {
	void *msg_name;
	int msg_namelen;
	struct iovec *msg_iov;
	__kernel_size_t msg_iovlen;
	void *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
};

struct mmsghdr {
	struct user_msghdr msg_hdr;
	unsigned int msg_len;
};

struct encoded_page;

struct mmu_gather_batch {
	struct mmu_gather_batch *next;
	unsigned int nr;
	unsigned int max;
	struct encoded_page *encoded_pages[0];
};

struct mmu_table_batch;

struct mmu_gather {
	struct mm_struct *mm;
	struct mmu_table_batch *batch;
	long unsigned int start;
	long unsigned int end;
	unsigned int fullmm: 1;
	unsigned int need_flush_all: 1;
	unsigned int freed_tables: 1;
	unsigned int delayed_rmap: 1;
	unsigned int cleared_ptes: 1;
	unsigned int cleared_pmds: 1;
	unsigned int cleared_puds: 1;
	unsigned int cleared_p4ds: 1;
	unsigned int vma_exec: 1;
	unsigned int vma_huge: 1;
	unsigned int vma_pfn: 1;
	unsigned int batch_count;
	struct mmu_gather_batch *active;
	struct mmu_gather_batch local;
	struct page *__pages[8];
};

struct mmu_notifier_range;

struct mmu_interval_notifier_ops {
	bool (*invalidate)(struct mmu_interval_notifier *, const struct mmu_notifier_range *, long unsigned int);
};

struct mmu_notifier_ops {
	void (*release)(struct mmu_notifier *, struct mm_struct *);
	int (*clear_flush_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*clear_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*test_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int);
	int (*invalidate_range_start)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range_end)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*arch_invalidate_secondary_tlbs)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	struct mmu_notifier * (*alloc_notifier)(struct mm_struct *);
	void (*free_notifier)(struct mmu_notifier *);
};

struct mmu_notifier_range {
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int flags;
	enum mmu_notifier_event event;
	void *owner;
};

struct mmu_notifier_subscriptions {
	struct hlist_head list;
	bool has_itree;
	spinlock_t lock;
	long unsigned int invalidate_seq;
	long unsigned int active_invalidate_ranges;
	struct rb_root_cached itree;
	wait_queue_head_t wq;
	struct hlist_head deferred_list;
};

struct mmu_table_batch {
	struct callback_head rcu;
	unsigned int nr;
	void *tables[0];
};

struct mnt_id_req {
	__u32 size;
	__u32 spare;
	__u64 mnt_id;
	__u64 param;
	__u64 mnt_ns_id;
};

struct uid_gid_extent {
	u32 first;
	u32 lower_first;
	u32 count;
};

struct uid_gid_map {
	union {
		struct {
			struct uid_gid_extent extent[5];
			u32 nr_extents;
		};
		struct {
			struct uid_gid_extent *forward;
			struct uid_gid_extent *reverse;
		};
	};
};

struct mnt_idmap {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	refcount_t count;
};

struct mount;

struct mnt_namespace {
	struct ns_common ns;
	struct mount *root;
	struct {
		struct rb_root mounts;
		struct rb_node *mnt_last_node;
		struct rb_node *mnt_first_node;
	};
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	u64 seq;
	union {
		wait_queue_head_t poll;
		struct callback_head mnt_ns_rcu;
	};
	u64 event;
	unsigned int nr_mounts;
	unsigned int pending_mounts;
	struct rb_node mnt_ns_tree_node;
	struct list_head mnt_ns_list;
	refcount_t passive;
};

struct mnt_ns_info {
	__u32 size;
	__u32 nr_mounts;
	__u64 mnt_ns_id;
};

struct mnt_pcp {
	int mnt_count;
	int mnt_writers;
};

struct orc_entry;

struct mod_arch_specific {
	unsigned int num_orcs;
	int *orc_unwind_ip;
	struct orc_entry *orc_unwind;
};

struct mod_initfree {
	struct llist_node node;
	void *init_text;
	void *init_data;
	void *init_rodata;
};

struct mod_kallsyms {
	Elf64_Sym *symtab;
	unsigned int num_symtab;
	char *strtab;
	char *typetab;
};

struct mod_tree_node {
	struct module *mod;
	struct latch_tree_node node;
};

struct mod_tree_root {
	struct latch_tree_root root;
	long unsigned int addr_min;
	long unsigned int addr_max;
};

struct module_param_attrs;

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct module_memory {
	void *base;
	void *rw_copy;
	bool is_rox;
	unsigned int size;
	struct mod_tree_node mtn;
};

struct module_attribute;

struct module_sect_attrs;

struct module_notes_attrs;

struct trace_event_call;

struct trace_eval_map;

struct static_call_site;

struct module {
	enum module_state state;
	struct list_head list;
	char name[56];
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject *holders_dir;
	const struct kernel_symbol *syms;
	const u32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const u32 *gpl_crcs;
	bool using_gplonly_symbols;
	bool async_probe_requested;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)(void);
	struct module_memory mem[7];
	struct mod_arch_specific arch;
	long unsigned int taints;
	unsigned int num_bugs;
	struct list_head bug_list;
	struct bug_entry *bug_table;
	struct mod_kallsyms *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	void *percpu;
	unsigned int percpu_size;
	void *noinstr_text_start;
	unsigned int noinstr_text_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int btf_data_size;
	unsigned int btf_base_data_size;
	void *btf_data;
	void *btf_base_data;
	struct jump_entry *jump_entries;
	unsigned int num_jump_entries;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	void *kprobes_text_start;
	unsigned int kprobes_text_size;
	long unsigned int *kprobe_blacklist;
	unsigned int num_kprobe_blacklist;
	int num_static_call_sites;
	struct static_call_site *static_call_sites;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)(void);
	atomic_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct module_attribute {
	struct attribute attr;
	ssize_t (*show)(const struct module_attribute *, struct module_kobject *, char *);
	ssize_t (*store)(const struct module_attribute *, struct module_kobject *, const char *, size_t);
	void (*setup)(struct module *, const char *);
	int (*test)(struct module *);
	void (*free)(struct module *);
};

struct module_notes_attrs {
	struct attribute_group grp;
	struct bin_attribute attrs[0];
};

struct param_attribute {
	struct module_attribute mattr;
	const struct kernel_param *param;
};

struct module_param_attrs {
	unsigned int num;
	struct attribute_group grp;
	struct param_attribute attrs[0];
};

struct module_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_module_power_mode_params power;
};

struct module_sect_attrs {
	struct attribute_group grp;
	struct bin_attribute attrs[0];
};

struct module_string {
	struct list_head next;
	struct module *module;
	char *str;
};

struct module_use {
	struct list_head source_list;
	struct list_head target_list;
	struct module *source;
	struct module *target;
};

struct module_version_attribute {
	struct module_attribute mattr;
	const char *module_name;
	const char *version;
};

struct vfsmount {
	struct dentry *mnt_root;
	struct super_block *mnt_sb;
	int mnt_flags;
	struct mnt_idmap *mnt_idmap;
};

struct mountpoint;

struct mount {
	struct hlist_node mnt_hash;
	struct mount *mnt_parent;
	struct dentry *mnt_mountpoint;
	struct vfsmount mnt;
	union {
		struct rb_node mnt_node;
		struct callback_head mnt_rcu;
		struct llist_node mnt_llist;
	};
	struct mnt_pcp *mnt_pcp;
	struct list_head mnt_mounts;
	struct list_head mnt_child;
	struct list_head mnt_instance;
	const char *mnt_devname;
	struct list_head mnt_list;
	struct list_head mnt_expire;
	struct list_head mnt_share;
	struct list_head mnt_slave_list;
	struct list_head mnt_slave;
	struct mount *mnt_master;
	struct mnt_namespace *mnt_ns;
	struct mountpoint *mnt_mp;
	union {
		struct hlist_node mnt_mp_list;
		struct hlist_node mnt_umount;
	};
	struct list_head mnt_umounting;
	struct fsnotify_mark_connector *mnt_fsnotify_marks;
	__u32 mnt_fsnotify_mask;
	int mnt_id;
	u64 mnt_id_unique;
	int mnt_group_id;
	int mnt_expiry_mark;
	struct hlist_head mnt_pins;
	struct hlist_head mnt_stuck_children;
};

struct mount_attr {
	__u64 attr_set;
	__u64 attr_clr;
	__u64 propagation;
	__u64 userns_fd;
};

struct mount_kattr {
	unsigned int attr_set;
	unsigned int attr_clr;
	unsigned int propagation;
	unsigned int lookup_flags;
	bool recurse;
	struct user_namespace *mnt_userns;
	struct mnt_idmap *mnt_idmap;
};

struct mount_opts {
	int token;
	int mount_opt;
	int flags;
};

struct mountpoint {
	struct hlist_node m_hash;
	struct dentry *m_dentry;
	struct hlist_head m_list;
	int m_count;
};

struct mountres {
	int errno;
	struct nfs_fh *fh;
	unsigned int *auth_count;
	rpc_authflavor_t *auth_flavors;
};

struct movable_operations {
	bool (*isolate_page)(struct page *, isolate_mode_t);
	int (*migrate_page)(struct page *, struct page *, enum migrate_mode);
	void (*putback_page)(struct page *);
};

struct move_extent {
	__u32 reserved;
	__u32 donor_fd;
	__u64 orig_start;
	__u64 donor_start;
	__u64 len;
	__u64 moved_len;
};

struct mp_chip_data {
	struct list_head irq_2_pin;
	struct IO_APIC_route_entry entry;
	bool is_level;
	bool active_low;
	bool isa_irq;
	u32 count;
};

struct mpage_da_data {
	struct inode *inode;
	struct writeback_control *wbc;
	unsigned int can_map: 1;
	long unsigned int first_page;
	long unsigned int next_page;
	long unsigned int last_page;
	struct ext4_map_blocks map;
	struct ext4_io_submit io_submit;
	unsigned int do_map: 1;
	unsigned int scanned_until_end: 1;
	unsigned int journalled_more_data: 1;
};

struct mpage_data {
	struct bio *bio;
	sector_t last_block_in_bio;
	get_block_t *get_block;
};

struct mpage_readpage_args {
	struct bio *bio;
	struct folio *folio;
	unsigned int nr_pages;
	bool is_readahead;
	sector_t last_block_in_bio;
	struct buffer_head map_bh;
	long unsigned int first_logical_block;
	get_block_t *get_block;
};

struct mpc_bus {
	unsigned char type;
	unsigned char busid;
	unsigned char bustype[6];
};

struct mpc_cpu {
	unsigned char type;
	unsigned char apicid;
	unsigned char apicver;
	unsigned char cpuflag;
	unsigned int cpufeature;
	unsigned int featureflag;
	unsigned int reserved[2];
};

struct mpc_intsrc {
	unsigned char type;
	unsigned char irqtype;
	short unsigned int irqflag;
	unsigned char srcbus;
	unsigned char srcbusirq;
	unsigned char dstapic;
	unsigned char dstirq;
};

struct mpc_lintsrc {
	unsigned char type;
	unsigned char irqtype;
	short unsigned int irqflag;
	unsigned char srcbusid;
	unsigned char srcbusirq;
	unsigned char destapic;
	unsigned char destapiclint;
};

struct mpc_table {
	char signature[4];
	short unsigned int length;
	char spec;
	char checksum;
	char oem[8];
	char productid[12];
	unsigned int oemptr;
	short unsigned int oemsize;
	short unsigned int oemcount;
	unsigned int lapic;
	unsigned int reserved;
};

struct mpf_intel {
	char signature[4];
	unsigned int physptr;
	unsigned char length;
	unsigned char specification;
	unsigned char checksum;
	unsigned char feature1;
	unsigned char feature2;
	unsigned char feature3;
	unsigned char feature4;
	unsigned char feature5;
};

struct mpls_label {
	__be32 entry;
};

struct mpls_shim_hdr {
	__be32 label_stack_entry;
};

struct rtnl_link_stats64;

struct net_device_stats;

struct ndmsg;

struct netdev_bpf;

struct net_device_path_ctx;

struct net_device_path;

struct skb_shared_hwtstamps;

struct net_device_ops {
	int (*ndo_init)(struct net_device *);
	void (*ndo_uninit)(struct net_device *);
	int (*ndo_open)(struct net_device *);
	int (*ndo_stop)(struct net_device *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
	void (*ndo_change_rx_flags)(struct net_device *, int);
	void (*ndo_set_rx_mode)(struct net_device *);
	int (*ndo_set_mac_address)(struct net_device *, void *);
	int (*ndo_validate_addr)(struct net_device *);
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_eth_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_siocbond)(struct net_device *, struct ifreq *, int);
	int (*ndo_siocwandev)(struct net_device *, struct if_settings *);
	int (*ndo_siocdevprivate)(struct net_device *, struct ifreq *, void *, int);
	int (*ndo_set_config)(struct net_device *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device *, int);
	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device *, unsigned int);
	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
	void (*ndo_poll_controller)(struct net_device *);
	int (*ndo_netpoll_setup)(struct net_device *);
	void (*ndo_netpoll_cleanup)(struct net_device *);
	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
	int (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device *, struct net_device *);
	struct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);
	struct net_device * (*ndo_sk_get_lower_dev)(struct net_device *, struct sock *);
	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
	int (*ndo_set_features)(struct net_device *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, bool *, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, bool *, struct netlink_ext_ack *);
	int (*ndo_fdb_del_bulk)(struct nlmsghdr *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_mdb_add)(struct net_device *, struct nlattr **, u16, struct netlink_ext_ack *);
	int (*ndo_mdb_del)(struct net_device *, struct nlattr **, struct netlink_ext_ack *);
	int (*ndo_mdb_del_bulk)(struct net_device *, struct nlattr **, struct netlink_ext_ack *);
	int (*ndo_mdb_dump)(struct net_device *, struct sk_buff *, struct netlink_callback *);
	int (*ndo_mdb_get)(struct net_device *, struct nlattr **, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device *, bool);
	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
	void (*ndo_dfwd_del_station)(struct net_device *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
	int (*ndo_get_iflink)(const struct net_device *);
	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
	void (*ndo_set_rx_headroom)(struct net_device *, int);
	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
	struct net_device * (*ndo_xdp_get_xmit_slave)(struct net_device *, struct xdp_buff *);
	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
	int (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm_kern *, int);
	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
	int (*ndo_fill_forward_path)(struct net_device_path_ctx *, struct net_device_path *);
	ktime_t (*ndo_get_tstamp)(struct net_device *, const struct skb_shared_hwtstamps *, bool);
	int (*ndo_hwtstamp_get)(struct net_device *, struct kernel_hwtstamp_config *);
	int (*ndo_hwtstamp_set)(struct net_device *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
};

struct mpoa_client {
	struct mpoa_client *next;
	struct net_device *dev;
	int dev_num;
	struct atm_vcc *mpoad_vcc;
	uint8_t mps_ctrl_addr[20];
	uint8_t our_ctrl_addr[20];
	rwlock_t ingress_lock;
	const struct in_cache_ops *in_ops;
	in_cache_entry *in_cache;
	rwlock_t egress_lock;
	const struct eg_cache_ops *eg_ops;
	eg_cache_entry *eg_cache;
	uint8_t *mps_macs;
	int number_of_mps_macs;
	struct mpc_parameters parameters;
	const struct net_device_ops *old_ops;
	struct net_device_ops new_ops;
};

struct mptcp_addr_info {
	u8 id;
	sa_family_t family;
	__be16 port;
	union {
		struct in_addr addr;
		struct in6_addr addr6;
	};
};

struct mptcp_data_frag {
	struct list_head list;
	u64 data_seq;
	u16 data_len;
	u16 offset;
	u16 overhead;
	u16 already_sent;
	struct page *page;
};

struct mptcp_delegated_action {
	struct napi_struct napi;
	struct list_head head;
};

struct mptcp_diag_ctx {
	long int s_slot;
	long int s_num;
	unsigned int l_slot;
	unsigned int l_num;
};

struct mptcp_ext {
	union {
		u64 data_ack;
		u32 data_ack32;
	};
	u64 data_seq;
	u32 subflow_seq;
	u16 data_len;
	__sum16 csum;
	u8 use_map: 1;
	u8 dsn64: 1;
	u8 data_fin: 1;
	u8 use_ack: 1;
	u8 ack64: 1;
	u8 mpc_map: 1;
	u8 frozen: 1;
	u8 reset_transient: 1;
	u8 reset_reason: 4;
	u8 csum_reqd: 1;
	u8 infinite_map: 1;
};

struct mptcp_info {
	__u8 mptcpi_subflows;
	__u8 mptcpi_add_addr_signal;
	__u8 mptcpi_add_addr_accepted;
	__u8 mptcpi_subflows_max;
	__u8 mptcpi_add_addr_signal_max;
	__u8 mptcpi_add_addr_accepted_max;
	__u32 mptcpi_flags;
	__u32 mptcpi_token;
	__u64 mptcpi_write_seq;
	__u64 mptcpi_snd_una;
	__u64 mptcpi_rcv_nxt;
	__u8 mptcpi_local_addr_used;
	__u8 mptcpi_local_addr_max;
	__u8 mptcpi_csum_enabled;
	__u32 mptcpi_retransmits;
	__u64 mptcpi_bytes_retrans;
	__u64 mptcpi_bytes_sent;
	__u64 mptcpi_bytes_received;
	__u64 mptcpi_bytes_acked;
	__u8 mptcpi_subflows_total;
	__u8 reserved[3];
	__u32 mptcpi_last_data_sent;
	__u32 mptcpi_last_data_recv;
	__u32 mptcpi_last_ack_recv;
};

struct mptcp_full_info {
	__u32 size_tcpinfo_kernel;
	__u32 size_tcpinfo_user;
	__u32 size_sfinfo_kernel;
	__u32 size_sfinfo_user;
	__u32 num_subflows;
	__u32 size_arrays_user;
	__u64 subflow_info;
	__u64 tcp_info;
	struct mptcp_info mptcp_info;
};

struct mptcp_mib {
	long unsigned int mibs[71];
};

struct mptcp_rm_list {
	u8 ids[8];
	u8 nr;
};

struct mptcp_options_received {
	u64 sndr_key;
	u64 rcvr_key;
	u64 data_ack;
	u64 data_seq;
	u32 subflow_seq;
	u16 data_len;
	__sum16 csum;
	union {
		struct {
			u16 suboptions;
			u16 use_map: 1;
			u16 dsn64: 1;
			u16 data_fin: 1;
			u16 use_ack: 1;
			u16 ack64: 1;
			u16 mpc_map: 1;
			u16 reset_reason: 4;
			u16 reset_transient: 1;
			u16 echo: 1;
			u16 backup: 1;
			u16 deny_join_id0: 1;
			u16 __unused: 2;
		};
		struct {
			u16 suboptions;
			u16 use_map: 1;
			u16 dsn64: 1;
			u16 data_fin: 1;
			u16 use_ack: 1;
			u16 ack64: 1;
			u16 mpc_map: 1;
			u16 reset_reason: 4;
			u16 reset_transient: 1;
			u16 echo: 1;
			u16 backup: 1;
			u16 deny_join_id0: 1;
			u16 __unused: 2;
		} status;
	};
	u8 join_id;
	u32 token;
	u32 nonce;
	u64 thmac;
	u8 hmac[20];
	struct mptcp_addr_info addr;
	struct mptcp_rm_list rm_list;
	u64 ahmac;
	u64 fail_seq;
};

struct mptcp_out_options {
	u16 suboptions;
	struct mptcp_rm_list rm_list;
	u8 join_id;
	u8 backup;
	u8 reset_reason: 4;
	u8 reset_transient: 1;
	u8 csum_reqd: 1;
	u8 allow_join_id0: 1;
	union {
		struct {
			u64 sndr_key;
			u64 rcvr_key;
			u64 data_seq;
			u32 subflow_seq;
			u16 data_len;
			__sum16 csum;
		};
		struct {
			struct mptcp_addr_info addr;
			u64 ahmac;
		};
		struct {
			struct mptcp_ext ext_copy;
			u64 fail_seq;
		};
		struct {
			u32 nonce;
			u32 token;
			u64 thmac;
			u8 hmac[20];
		};
	};
};

struct mptcp_pernet {
	struct ctl_table_header *ctl_table_hdr;
	unsigned int add_addr_timeout;
	unsigned int blackhole_timeout;
	unsigned int close_timeout;
	unsigned int stale_loss_cnt;
	atomic_t active_disable_times;
	u8 syn_retrans_before_tcp_fallback;
	long unsigned int active_disable_stamp;
	u8 mptcp_enabled;
	u8 checksum_enabled;
	u8 allow_join_initial_addr_port;
	u8 pm_type;
	char scheduler[16];
};

struct mptcp_sock;

struct mptcp_pm_add_entry {
	struct list_head list;
	struct mptcp_addr_info addr;
	u8 retrans_times;
	struct timer_list add_timer;
	struct mptcp_sock *sock;
};

struct mptcp_pm_addr_entry {
	struct list_head list;
	struct mptcp_addr_info addr;
	u8 flags;
	int ifindex;
	struct socket *lsk;
};

struct mptcp_pm_data {
	struct mptcp_addr_info local;
	struct mptcp_addr_info remote;
	struct list_head anno_list;
	struct list_head userspace_pm_local_addr_list;
	spinlock_t lock;
	u8 addr_signal;
	bool server_side;
	bool work_pending;
	bool accept_addr;
	bool accept_subflow;
	bool remote_deny_join_id0;
	u8 add_addr_signaled;
	u8 add_addr_accepted;
	u8 local_addr_used;
	u8 pm_type;
	u8 subflows;
	u8 status;
	long unsigned int id_avail_bitmap[4];
	struct mptcp_rm_list rm_list_tx;
	struct mptcp_rm_list rm_list_rx;
};

struct mptcp_pm_local {
	struct mptcp_addr_info addr;
	u8 flags;
	int ifindex;
};

struct mptcp_subflow_context;

struct mptcp_sched_data {
	bool reinject;
	u8 subflows;
	struct mptcp_subflow_context *contexts[8];
};

struct mptcp_sched_ops {
	int (*get_subflow)(struct mptcp_sock *, struct mptcp_sched_data *);
	char name[16];
	struct module *owner;
	struct list_head list;
	void (*init)(struct mptcp_sock *);
	void (*release)(struct mptcp_sock *);
};

struct mptcp_sendmsg_info {
	int mss_now;
	int size_goal;
	u16 limit;
	u16 sent;
	unsigned int flags;
	bool data_lock_held;
};

struct mptcp_skb_cb {
	u64 map_seq;
	u64 end_seq;
	u32 offset;
	u8 has_rxtstamp: 1;
};

struct mptcp_sock {
	struct inet_connection_sock sk;
	u64 local_key;
	u64 remote_key;
	u64 write_seq;
	u64 bytes_sent;
	u64 snd_nxt;
	u64 bytes_received;
	u64 ack_seq;
	atomic64_t rcv_wnd_sent;
	u64 rcv_data_fin_seq;
	u64 bytes_retrans;
	u64 bytes_consumed;
	int rmem_fwd_alloc;
	int snd_burst;
	int old_wspace;
	u64 recovery_snd_nxt;
	u64 bytes_acked;
	u64 snd_una;
	u64 wnd_end;
	u32 last_data_sent;
	u32 last_data_recv;
	u32 last_ack_recv;
	long unsigned int timer_ival;
	u32 token;
	int rmem_released;
	long unsigned int flags;
	long unsigned int cb_flags;
	bool recovery;
	bool can_ack;
	bool fully_established;
	bool rcv_data_fin;
	bool snd_data_fin_enable;
	bool rcv_fastclose;
	bool use_64bit_ack;
	bool csum_enabled;
	bool allow_infinite_fallback;
	u8 pending_state;
	u8 mpc_endpoint_id;
	u8 recvmsg_inq: 1;
	u8 cork: 1;
	u8 nodelay: 1;
	u8 fastopening: 1;
	u8 in_accept_queue: 1;
	u8 free_first: 1;
	u8 rcvspace_init: 1;
	u32 notsent_lowat;
	int keepalive_cnt;
	int keepalive_idle;
	int keepalive_intvl;
	struct work_struct work;
	struct sk_buff *ooo_last_skb;
	struct rb_root out_of_order_queue;
	struct sk_buff_head receive_queue;
	struct list_head conn_list;
	struct list_head rtx_queue;
	struct mptcp_data_frag *first_pending;
	struct list_head join_list;
	struct sock *first;
	struct mptcp_pm_data pm;
	struct mptcp_sched_ops *sched;
	struct {
		u32 space;
		u32 copied;
		u64 time;
		u64 rtt_us;
	} rcvq_space;
	u8 scaling_ratio;
	u32 subflow_id;
	u32 setsockopt_seq;
	char ca_name[16];
};

struct sockaddr_in {
	__kernel_sa_family_t sin_family;
	__be16 sin_port;
	struct in_addr sin_addr;
	unsigned char __pad[8];
};

struct mptcp_subflow_addrs {
	union {
		__kernel_sa_family_t sa_family;
		struct sockaddr sa_local;
		struct sockaddr_in sin_local;
		struct sockaddr_in6 sin6_local;
		struct __kernel_sockaddr_storage ss_local;
	};
	union {
		struct sockaddr sa_remote;
		struct sockaddr_in sin_remote;
		struct sockaddr_in6 sin6_remote;
		struct __kernel_sockaddr_storage ss_remote;
	};
};

struct mptcp_subflow_context {
	struct list_head node;
	union {
		struct {
			long unsigned int avg_pacing_rate;
			u64 local_key;
			u64 remote_key;
			u64 idsn;
			u64 map_seq;
			u32 snd_isn;
			u32 token;
			u32 rel_write_seq;
			u32 map_subflow_seq;
			u32 ssn_offset;
			u32 map_data_len;
			__wsum map_data_csum;
			u32 map_csum_len;
			u32 request_mptcp: 1;
			u32 request_join: 1;
			u32 request_bkup: 1;
			u32 mp_capable: 1;
			u32 mp_join: 1;
			u32 pm_notified: 1;
			u32 conn_finished: 1;
			u32 map_valid: 1;
			u32 map_csum_reqd: 1;
			u32 map_data_fin: 1;
			u32 mpc_map: 1;
			u32 backup: 1;
			u32 send_mp_prio: 1;
			u32 send_mp_fail: 1;
			u32 send_fastclose: 1;
			u32 send_infinite_map: 1;
			u32 remote_key_valid: 1;
			u32 disposable: 1;
			u32 stale: 1;
			u32 valid_csum_seen: 1;
			u32 is_mptfo: 1;
			u32 close_event_done: 1;
			u32 mpc_drop: 1;
			u32 __unused: 9;
			bool data_avail;
			bool scheduled;
			bool pm_listener;
			bool fully_established;
			u32 remote_nonce;
			u64 thmac;
			u32 local_nonce;
			u32 remote_token;
			union {
				u8 hmac[20];
				u64 iasn;
			};
			s16 local_id;
			u8 remote_id;
			u8 reset_seen: 1;
			u8 reset_transient: 1;
			u8 reset_reason: 4;
			u8 stale_count;
			u32 subflow_id;
			long int delegated_status;
			long unsigned int fail_tout;
		};
		struct {
			long unsigned int avg_pacing_rate;
			u64 local_key;
			u64 remote_key;
			u64 idsn;
			u64 map_seq;
			u32 snd_isn;
			u32 token;
			u32 rel_write_seq;
			u32 map_subflow_seq;
			u32 ssn_offset;
			u32 map_data_len;
			__wsum map_data_csum;
			u32 map_csum_len;
			u32 request_mptcp: 1;
			u32 request_join: 1;
			u32 request_bkup: 1;
			u32 mp_capable: 1;
			u32 mp_join: 1;
			u32 pm_notified: 1;
			u32 conn_finished: 1;
			u32 map_valid: 1;
			u32 map_csum_reqd: 1;
			u32 map_data_fin: 1;
			u32 mpc_map: 1;
			u32 backup: 1;
			u32 send_mp_prio: 1;
			u32 send_mp_fail: 1;
			u32 send_fastclose: 1;
			u32 send_infinite_map: 1;
			u32 remote_key_valid: 1;
			u32 disposable: 1;
			u32 stale: 1;
			u32 valid_csum_seen: 1;
			u32 is_mptfo: 1;
			u32 close_event_done: 1;
			u32 mpc_drop: 1;
			u32 __unused: 9;
			bool data_avail;
			bool scheduled;
			bool pm_listener;
			bool fully_established;
			u32 remote_nonce;
			u64 thmac;
			u32 local_nonce;
			u32 remote_token;
			union {
				u8 hmac[20];
				u64 iasn;
			};
			s16 local_id;
			u8 remote_id;
			u8 reset_seen: 1;
			u8 reset_transient: 1;
			u8 reset_reason: 4;
			u8 stale_count;
			u32 subflow_id;
			long int delegated_status;
			long unsigned int fail_tout;
		} reset;
	};
	struct list_head delegated_node;
	u32 setsockopt_seq;
	u32 stale_rcv_tstamp;
	int cached_sndbuf;
	struct sock *tcp_sock;
	struct sock *conn;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	void (*tcp_state_change)(struct sock *);
	void (*tcp_error_report)(struct sock *);
	struct callback_head rcu;
};

struct mptcp_subflow_data {
	__u32 size_subflow_data;
	__u32 num_subflows;
	__u32 size_kernel;
	__u32 size_user;
};

struct mptcp_subflow_info {
	__u32 id;
	struct mptcp_subflow_addrs addrs;
};

struct tcp_request_sock_ops;

struct tcp_request_sock {
	struct inet_request_sock req;
	const struct tcp_request_sock_ops *af_specific;
	u64 snt_synack;
	bool tfo_listener;
	bool is_mptcp;
	bool req_usec_ts;
	bool drop_req;
	u32 txhash;
	u32 rcv_isn;
	u32 snt_isn;
	u32 ts_off;
	u32 last_oow_ack_time;
	u32 rcv_nxt;
	u8 syn_tos;
	u8 ao_keyid;
	u8 ao_rcv_next;
	bool used_tcp_ao;
};

struct mptcp_subflow_request_sock {
	struct tcp_request_sock sk;
	u16 mp_capable: 1;
	u16 mp_join: 1;
	u16 backup: 1;
	u16 request_bkup: 1;
	u16 csum_reqd: 1;
	u16 allow_join_id0: 1;
	u8 local_id;
	u8 remote_id;
	u64 local_key;
	u64 idsn;
	u32 token;
	u32 ssn_offset;
	u64 thmac;
	u32 local_nonce;
	u32 remote_nonce;
	struct mptcp_sock *msk;
	struct hlist_nulls_node token_node;
};

struct mq_inflight {
	struct block_device *part;
	unsigned int inflight[2];
};

struct mq_sched {
	struct Qdisc **qdiscs;
};

struct mqprio_sched {
	struct Qdisc **qdiscs;
	u16 mode;
	u16 shaper;
	int hw_offload;
	u32 flags;
	u64 min_rate[16];
	u64 max_rate[16];
	u32 fp[16];
};

struct mqueue_fs_context {
	struct ipc_namespace *ipc_ns;
	bool newns;
};

struct sigevent {
	sigval_t sigev_value;
	int sigev_signo;
	int sigev_notify;
	union {
		int _pad[12];
		int _tid;
		struct {
			void (*_function)(sigval_t);
			void *_attribute;
		} _sigev_thread;
	} _sigev_un;
};

struct posix_msg_tree_node;

struct mqueue_inode_info {
	spinlock_t lock;
	struct inode vfs_inode;
	wait_queue_head_t wait_q;
	struct rb_root msg_tree;
	struct rb_node *msg_tree_rightmost;
	struct posix_msg_tree_node *node_cache;
	struct mq_attr attr;
	struct sigevent notify;
	struct pid *notify_owner;
	u32 notify_self_exec_id;
	struct user_namespace *notify_user_ns;
	struct ucounts *ucounts;
	struct sock *notify_sock;
	struct sk_buff *notify_cookie;
	struct ext_wait_queue e_wait_q[2];
	long unsigned int qsize;
};

struct mr_mfc_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	struct list_head *cache;
	spinlock_t *lock;
};

struct mr_table_ops {
	const struct rhashtable_params *rht_params;
	void *cmparg_any;
};

struct vif_device {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	long unsigned int bytes_in;
	long unsigned int bytes_out;
	long unsigned int pkt_in;
	long unsigned int pkt_out;
	long unsigned int rate_limit;
	unsigned char threshold;
	short unsigned int flags;
	int link;
	struct netdev_phys_item_id dev_parent_id;
	__be32 local;
	__be32 remote;
};

struct rhltable {
	struct rhashtable ht;
};

struct mr_table {
	struct list_head list;
	possible_net_t net;
	struct mr_table_ops ops;
	u32 id;
	struct sock *mroute_sk;
	struct timer_list ipmr_expire_timer;
	struct list_head mfc_unres_queue;
	struct vif_device vif_table[32];
	struct rhltable mfc_hash;
	struct list_head mfc_cache_list;
	int maxvif;
	atomic_t cache_resolve_queue_len;
	bool mroute_do_assert;
	bool mroute_do_pim;
	bool mroute_do_wrvifwhole;
	int mroute_reg_vif_num;
};

struct mr_vif_iter {
	struct seq_net_private p;
	struct mr_table *mrt;
	int ct;
};

struct mrt6msg {
	__u8 im6_mbz;
	__u8 im6_msgtype;
	__u16 im6_mif;
	__u32 im6_pad;
	struct in6_addr im6_src;
	struct in6_addr im6_dst;
};

struct ms_hyperv_info {
	u32 features;
	u32 priv_high;
	u32 misc_features;
	u32 hints;
	u32 nested_features;
	u32 max_vp_index;
	u32 max_lp_index;
	u8 vtl;
	union {
		u32 isolation_config_a;
		struct {
			u32 paravisor_present: 1;
			u32 reserved_a1: 31;
		};
	};
	union {
		u32 isolation_config_b;
		struct {
			u32 cvm_type: 4;
			u32 reserved_b1: 1;
			u32 shared_gpa_boundary_active: 1;
			u32 shared_gpa_boundary_bits: 6;
			u32 reserved_b2: 20;
		};
	};
	u64 shared_gpa_boundary;
};

struct msdos_dir_entry {
	__u8 name[11];
	__u8 attr;
	__u8 lcase;
	__u8 ctime_cs;
	__le16 ctime;
	__le16 cdate;
	__le16 adate;
	__le16 starthi;
	__le16 time;
	__le16 date;
	__le16 start;
	__le32 size;
};

struct msdos_dir_slot {
	__u8 id;
	__u8 name0_4[10];
	__u8 attr;
	__u8 reserved;
	__u8 alias_checksum;
	__u8 name5_10[12];
	__le16 start;
	__u8 name11_12[4];
};

struct msdos_inode_info {
	spinlock_t cache_lru_lock;
	struct list_head cache_lru;
	int nr_caches;
	unsigned int cache_valid_id;
	loff_t mmu_private;
	int i_start;
	int i_logstart;
	int i_attrs;
	loff_t i_pos;
	struct hlist_node i_fat_hash;
	struct hlist_node i_dir_hash;
	struct rw_semaphore truncate_lock;
	struct timespec64 i_crtime;
	struct inode vfs_inode;
};

struct msdos_partition {
	u8 boot_ind;
	u8 head;
	u8 sector;
	u8 cyl;
	u8 sys_ind;
	u8 end_head;
	u8 end_sector;
	u8 end_cyl;
	__le32 start_sect;
	__le32 nr_sects;
};

struct msdos_sb_info {
	short unsigned int sec_per_clus;
	short unsigned int cluster_bits;
	unsigned int cluster_size;
	unsigned char fats;
	unsigned char fat_bits;
	short unsigned int fat_start;
	long unsigned int fat_length;
	long unsigned int dir_start;
	short unsigned int dir_entries;
	long unsigned int data_start;
	long unsigned int max_cluster;
	long unsigned int root_cluster;
	long unsigned int fsinfo_sector;
	struct mutex fat_lock;
	struct mutex nfs_build_inode_lock;
	struct mutex s_lock;
	unsigned int prev_free;
	unsigned int free_clusters;
	unsigned int free_clus_valid;
	struct fat_mount_options options;
	struct nls_table *nls_disk;
	struct nls_table *nls_io;
	const void *dir_ops;
	int dir_per_block;
	int dir_per_block_bits;
	unsigned int vol_id;
	int fatent_shift;
	const struct fatent_operations *fatent_ops;
	struct inode *fat_inode;
	struct inode *fsinfo_inode;
	struct ratelimit_state ratelimit;
	spinlock_t inode_hash_lock;
	struct hlist_head inode_hashtable[256];
	spinlock_t dir_hash_lock;
	struct hlist_head dir_hashtable[256];
	unsigned int dirty;
	struct callback_head rcu;
};

struct msg_msgseg;

struct msg_msg {
	struct list_head m_list;
	long int m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_msgseg {
	struct msg_msgseg *next;
};

struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;
	time64_t q_rtime;
	time64_t q_ctime;
	long unsigned int q_cbytes;
	long unsigned int q_qnum;
	long unsigned int q_qbytes;
	struct pid *q_lspid;
	struct pid *q_lrpid;
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
	long: 64;
	long: 64;
};

struct msg_receiver {
	struct list_head r_list;
	struct task_struct *r_tsk;
	int r_mode;
	long int r_msgtype;
	long int r_maxsize;
	struct msg_msg *r_msg;
};

struct msg_sender {
	struct list_head list;
	struct task_struct *tsk;
	size_t msgsz;
};

struct msgbuf {
	__kernel_long_t mtype;
	char mtext[1];
};

struct msginfo {
	int msgpool;
	int msgmap;
	int msgmax;
	int msgmnb;
	int msgmni;
	int msgssz;
	int msgtql;
	short unsigned int msgseg;
};

struct msi_ctrl {
	unsigned int domid;
	unsigned int first;
	unsigned int last;
	unsigned int nirqs;
};

struct x86_msi_addr_lo {
	union {
		struct {
			u32 reserved_0: 2;
			u32 dest_mode_logical: 1;
			u32 redirect_hint: 1;
			u32 reserved_1: 1;
			u32 virt_destid_8_14: 7;
			u32 destid_0_7: 8;
			u32 base_address: 12;
		};
		struct {
			u32 dmar_reserved_0: 2;
			u32 dmar_index_15: 1;
			u32 dmar_subhandle_valid: 1;
			u32 dmar_format: 1;
			u32 dmar_index_0_14: 15;
			u32 dmar_base_address: 12;
		};
	};
};

typedef struct x86_msi_addr_lo arch_msi_msg_addr_lo_t;

struct x86_msi_addr_hi {
	u32 reserved: 8;
	u32 destid_8_31: 24;
};

typedef struct x86_msi_addr_hi arch_msi_msg_addr_hi_t;

struct x86_msi_data {
	union {
		struct {
			u32 vector: 8;
			u32 delivery_mode: 3;
			u32 dest_mode_logical: 1;
			u32 reserved: 2;
			u32 active_low: 1;
			u32 is_level: 1;
		};
		u32 dmar_subhandle;
	};
};

typedef struct x86_msi_data arch_msi_msg_data_t;

struct msi_msg {
	union {
		u32 address_lo;
		arch_msi_msg_addr_lo_t arch_addr_lo;
	};
	union {
		u32 address_hi;
		arch_msi_msg_addr_hi_t arch_addr_hi;
	};
	union {
		u32 data;
		arch_msi_msg_data_t arch_data;
	};
};

struct pci_msi_desc {
	union {
		u32 msi_mask;
		u32 msix_ctrl;
	};
	struct {
		u8 is_msix: 1;
		u8 multiple: 3;
		u8 multi_cap: 3;
		u8 can_mask: 1;
		u8 is_64: 1;
		u8 is_virtual: 1;
		unsigned int default_irq;
	} msi_attrib;
	union {
		u8 mask_pos;
		void *mask_base;
	};
};

union msi_domain_cookie {
	u64 value;
	void *ptr;
	void *iobase;
};

union msi_instance_cookie {
	u64 value;
	void *ptr;
};

struct msi_desc_data {
	union msi_domain_cookie dcookie;
	union msi_instance_cookie icookie;
};

struct msi_desc {
	unsigned int irq;
	unsigned int nvec_used;
	struct device *dev;
	struct msi_msg msg;
	struct irq_affinity_desc *affinity;
	const void *iommu_cookie;
	struct device_attribute *sysfs_attrs;
	void (*write_msi_msg)(struct msi_desc *, void *);
	void *write_msi_msg_data;
	u16 msi_index;
	union {
		struct pci_msi_desc pci;
		struct msi_desc_data data;
	};
};

struct msi_dev_domain {
	struct xarray store;
	struct irq_domain *domain;
};

struct msi_device_data {
	long unsigned int properties;
	struct mutex mutex;
	struct msi_dev_domain __domains[1];
	long unsigned int __iter_idx;
};

struct msi_domain_ops;

struct msi_domain_info {
	u32 flags;
	enum irq_domain_bus_token bus_token;
	unsigned int hwsize;
	struct msi_domain_ops *ops;
	struct irq_chip *chip;
	void *chip_data;
	irq_flow_handler_t handler;
	void *handler_data;
	const char *handler_name;
	void *data;
};

struct msi_domain_ops {
	irq_hw_number_t (*get_hwirq)(struct msi_domain_info *, msi_alloc_info_t *);
	int (*msi_init)(struct irq_domain *, struct msi_domain_info *, unsigned int, irq_hw_number_t, msi_alloc_info_t *);
	void (*msi_free)(struct irq_domain *, struct msi_domain_info *, unsigned int);
	int (*msi_prepare)(struct irq_domain *, struct device *, int, msi_alloc_info_t *);
	void (*prepare_desc)(struct irq_domain *, msi_alloc_info_t *, struct msi_desc *);
	void (*set_desc)(msi_alloc_info_t *, struct msi_desc *);
	int (*domain_alloc_irqs)(struct irq_domain *, struct device *, int);
	void (*domain_free_irqs)(struct irq_domain *, struct device *);
	void (*msi_post_free)(struct irq_domain *, struct device *);
	int (*msi_translate)(struct irq_domain *, struct irq_fwspec *, irq_hw_number_t *, unsigned int *);
};

struct msi_domain_template {
	char name[48];
	struct irq_chip chip;
	struct msi_domain_ops ops;
	struct msi_domain_info info;
};

struct msi_map {
	int index;
	int virq;
};

struct msi_parent_ops {
	u32 supported_flags;
	u32 required_flags;
	u32 bus_select_token;
	u32 bus_select_mask;
	const char *prefix;
	bool (*init_dev_msi_info)(struct device *, struct irq_domain *, struct irq_domain *, struct msi_domain_info *);
};

struct msix_entry {
	u32 vector;
	u16 entry;
};

struct msqid64_ds {
	struct ipc64_perm msg_perm;
	long int msg_stime;
	long int msg_rtime;
	long int msg_ctime;
	long unsigned int msg_cbytes;
	long unsigned int msg_qnum;
	long unsigned int msg_qbytes;
	__kernel_pid_t msg_lspid;
	__kernel_pid_t msg_lrpid;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct msg;

struct msqid_ds {
	struct ipc_perm msg_perm;
	struct msg *msg_first;
	struct msg *msg_last;
	__kernel_old_time_t msg_stime;
	__kernel_old_time_t msg_rtime;
	__kernel_old_time_t msg_ctime;
	long unsigned int msg_lcbytes;
	long unsigned int msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	__kernel_ipc_pid_t msg_lspid;
	__kernel_ipc_pid_t msg_lrpid;
};

struct msr {
	union {
		struct {
			u32 l;
			u32 h;
		};
		u64 q;
	};
};

struct msr_data {
	bool host_initiated;
	u32 index;
	u64 data;
};

struct msr_enumeration {
	u32 msr_no;
	u32 feature;
};

struct msr_info {
	u32 msr_no;
	struct msr reg;
	struct msr *msrs;
	int err;
};

struct msr_info_completion {
	struct msr_info msr;
	struct completion done;
};

struct msr_regs_info {
	u32 *regs;
	int err;
};

struct mtl_gsc_ver_msg_in {
	struct intel_gsc_mtl_header header;
	struct intel_gsc_mkhi_header mkhi;
};

struct mtl_gsc_ver_msg_out {
	struct intel_gsc_mtl_header header;
	struct intel_gsc_mkhi_header mkhi;
	u16 proj_major;
	u16 compat_major;
	u16 compat_minor;
	u16 reserved[5];
};

struct pxp_cmd_header {
	u32 api_version;
	u32 command_id;
	union {
		u32 status;
		u32 stream_id;
	};
	u32 buffer_len;
};

struct pxp43_new_huc_auth_in {
	struct pxp_cmd_header header;
	u64 huc_base_address;
	u32 huc_size;
} __attribute__((packed));

struct mtl_huc_auth_msg_in {
	struct intel_gsc_mtl_header header;
	struct pxp43_new_huc_auth_in huc_in;
};

struct pxp43_huc_auth_out {
	struct pxp_cmd_header header;
};

struct mtl_huc_auth_msg_out {
	struct intel_gsc_mtl_header header;
	struct pxp43_huc_auth_out huc_out;
};

struct mtrr_cleanup_result {
	long unsigned int gran_sizek;
	long unsigned int chunk_sizek;
	long unsigned int lose_cover_sizek;
	unsigned int num_reg;
	int bad;
};

struct mtrr_gentry {
	__u64 base;
	__u32 size;
	__u32 regnum;
	__u32 type;
	__u32 _pad;
};

struct mtrr_ops {
	u32 var_regs;
	void (*set)(unsigned int, long unsigned int, long unsigned int, mtrr_type);
	void (*get)(unsigned int, long unsigned int *, long unsigned int *, mtrr_type *);
	int (*get_free_region)(long unsigned int, long unsigned int, int);
	int (*validate_add_page)(long unsigned int, long unsigned int, unsigned int);
	int (*have_wrcomb)(void);
};

struct mtrr_sentry {
	__u64 base;
	__u32 size;
	__u32 type;
};

struct mtrr_var_range {
	__u32 base_lo;
	__u32 base_hi;
	__u32 mask_lo;
	__u32 mask_hi;
};

struct mtrr_state_type {
	struct mtrr_var_range var_ranges[256];
	mtrr_type fixed_ranges[88];
	unsigned char enabled;
	bool have_fixed;
	mtrr_type def_type;
};

struct multi_stop_data {
	cpu_stop_fn_t fn;
	void *data;
	unsigned int num_threads;
	const struct cpumask *active_cpus;
	enum multi_stop_state state;
	atomic_t thread_ack;
};

struct multiprocess_signals {
	sigset_t signal;
	struct hlist_node node;
};

struct multiq_sched_data {
	u16 bands;
	u16 max_bands;
	u16 curband;
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct Qdisc **queues;
};

typedef struct mutex *class_mutex_t;

typedef class_mutex_t class_mutex_intr_t;

struct mutex_waiter {
	struct list_head list;
	struct task_struct *task;
	struct ww_acquire_ctx *ww_ctx;
};

struct mwait_cpu_dead {
	unsigned int control;
	unsigned int status;
};

struct n_tty_data {
	size_t read_head;
	size_t commit_head;
	size_t canon_head;
	size_t echo_head;
	size_t echo_commit;
	size_t echo_mark;
	long unsigned int char_map[4];
	long unsigned int overrun_time;
	unsigned int num_overrun;
	bool no_room;
	unsigned char lnext: 1;
	unsigned char erasing: 1;
	unsigned char raw: 1;
	unsigned char real_raw: 1;
	unsigned char icanon: 1;
	unsigned char push: 1;
	u8 read_buf[4096];
	long unsigned int read_flags[64];
	u8 echo_buf[4096];
	size_t read_tail;
	size_t line_start;
	size_t lookahead_count;
	unsigned int column;
	unsigned int canon_column;
	size_t echo_tail;
	struct mutex atomic_read_lock;
	struct mutex output_lock;
};

struct name_cache_entry {
	struct btrfs_lru_cache_entry entry;
	u64 parent_ino;
	u64 parent_gen;
	int ret;
	int need_later_update;
	int name_len;
	char name[0];
};

struct name_table {
	struct callback_head rcu;
	struct hlist_head services[1024];
	struct list_head node_scope;
	struct list_head cluster_scope;
	rwlock_t cluster_scope_lock;
	u32 local_publ_count;
	u32 rc_dests;
	u32 snd_nxt;
};

struct saved {
	struct path link;
	struct delayed_call done;
	const char *name;
	unsigned int seq;
};

struct nameidata {
	struct path path;
	struct qstr last;
	struct path root;
	struct inode *inode;
	unsigned int flags;
	unsigned int state;
	unsigned int seq;
	unsigned int next_seq;
	unsigned int m_seq;
	unsigned int r_seq;
	int last_type;
	unsigned int depth;
	int total_link_count;
	struct saved *stack;
	struct saved internal[2];
	struct filename *name;
	const char *pathname;
	struct nameidata *saved;
	unsigned int root_seq;
	int dfd;
	vfsuid_t dir_vfsuid;
	umode_t dir_mode;
};

struct napi_alloc_cache {
	local_lock_t bh_lock;
	struct page_frag_cache page;
	unsigned int skb_count;
	void *skb_cache[64];
};

struct napi_config {
	u64 gro_flush_timeout;
	u64 irq_suspend_timeout;
	u32 defer_hard_irqs;
	unsigned int napi_id;
};

struct napi_gro_cb {
	union {
		struct {
			void *frag0;
			unsigned int frag0_len;
		};
		struct {
			struct sk_buff *last;
			long unsigned int age;
		};
	};
	int data_offset;
	u16 flush;
	u16 count;
	u16 proto;
	u16 pad;
	union {
		struct {
			u16 gro_remcsum_start;
			u8 same_flow: 1;
			u8 encap_mark: 1;
			u8 csum_valid: 1;
			u8 csum_cnt: 3;
			u8 free: 2;
			u8 is_ipv6: 1;
			u8 is_fou: 1;
			u8 ip_fixedid: 1;
			u8 recursion_counter: 4;
			u8 is_flist: 1;
		};
		struct {
			u16 gro_remcsum_start;
			u8 same_flow: 1;
			u8 encap_mark: 1;
			u8 csum_valid: 1;
			u8 csum_cnt: 3;
			u8 free: 2;
			u8 is_ipv6: 1;
			u8 is_fou: 1;
			u8 ip_fixedid: 1;
			u8 recursion_counter: 4;
			u8 is_flist: 1;
		} zeroed;
	};
	__wsum csum;
	union {
		struct {
			u16 network_offset;
			u16 inner_network_offset;
		};
		u16 network_offsets[2];
	};
};

struct nat_keepalive {
	struct net *net;
	u16 family;
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__be16 encap_sport;
	__be16 encap_dport;
	__u32 smark;
};

struct nat_keepalive_work_ctx {
	time64_t next_run;
	time64_t now;
};

struct nf_nat_hooks_net {
	struct nf_hook_ops *nat_hook_ops;
	unsigned int users;
};

struct nat_net {
	struct nf_nat_hooks_net nat_proto_net[11];
};

struct nbcon_state {
	union {
		unsigned int atom;
		struct {
			unsigned int prio: 2;
			unsigned int req_prio: 2;
			unsigned int unsafe: 1;
			unsigned int unsafe_takeover: 1;
			unsigned int cpu: 24;
		};
	};
};

struct nbcon_write_context {
	struct nbcon_context ctxt;
	char *outbuf;
	unsigned int len;
	bool unsafe_takeover;
};

struct tcf_em_nbyte {
	__u16 off;
	__u16 len: 12;
	__u8 layer: 4;
};

struct nbyte_data {
	struct tcf_em_nbyte hdr;
	char pattern[0];
};

struct nd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	__u8 opt[0];
};

struct nd_opt_hdr {
	__u8 nd_opt_type;
	__u8 nd_opt_len;
};

struct nda_cacheinfo {
	__u32 ndm_confirmed;
	__u32 ndm_used;
	__u32 ndm_updated;
	__u32 ndm_refcnt;
};

struct ndisc_options;

struct prefix_info;

struct ndisc_ops {
	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
};

struct ndisc_options {
	struct nd_opt_hdr *nd_opt_array[15];
	struct nd_opt_hdr *nd_opts_ri;
	struct nd_opt_hdr *nd_opts_ri_end;
	struct nd_opt_hdr *nd_useropts;
	struct nd_opt_hdr *nd_useropts_end;
};

struct ndmsg {
	__u8 ndm_family;
	__u8 ndm_pad1;
	__u16 ndm_pad2;
	__s32 ndm_ifindex;
	__u16 ndm_state;
	__u8 ndm_flags;
	__u8 ndm_type;
};

struct ndo_fdb_dump_context {
	long unsigned int ifindex;
	long unsigned int fdb_idx;
};

struct ndt_config {
	__u16 ndtc_key_len;
	__u16 ndtc_entry_size;
	__u32 ndtc_entries;
	__u32 ndtc_last_flush;
	__u32 ndtc_last_rand;
	__u32 ndtc_hash_rnd;
	__u32 ndtc_hash_mask;
	__u32 ndtc_hash_chain_gc;
	__u32 ndtc_proxy_qlen;
};

struct ndt_stats {
	__u64 ndts_allocs;
	__u64 ndts_destroys;
	__u64 ndts_hash_grows;
	__u64 ndts_res_failed;
	__u64 ndts_lookups;
	__u64 ndts_hits;
	__u64 ndts_rcv_probes_mcast;
	__u64 ndts_rcv_probes_ucast;
	__u64 ndts_periodic_gc_runs;
	__u64 ndts_forced_gc_runs;
	__u64 ndts_table_fulls;
};

struct ndtmsg {
	__u8 ndtm_family;
	__u8 ndtm_pad1;
	__u16 ndtm_pad2;
};

struct nduseroptmsg {
	unsigned char nduseropt_family;
	unsigned char nduseropt_pad1;
	short unsigned int nduseropt_opts_len;
	int nduseropt_ifindex;
	__u8 nduseropt_icmp_type;
	__u8 nduseropt_icmp_code;
	short unsigned int nduseropt_pad2;
	unsigned int nduseropt_pad3;
};

struct neigh_dump_filter {
	int master_idx;
	int dev_idx;
};

struct neigh_hash_table {
	struct hlist_head *hash_heads;
	unsigned int hash_shift;
	__u32 hash_rnd[4];
	struct callback_head rcu;
};

struct neigh_ops {
	int family;
	void (*solicit)(struct neighbour *, struct sk_buff *);
	void (*error_report)(struct neighbour *, struct sk_buff *);
	int (*output)(struct neighbour *, struct sk_buff *);
	int (*connected_output)(struct neighbour *, struct sk_buff *);
};

struct neigh_parms {
	possible_net_t net;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head list;
	int (*neigh_setup)(struct neighbour *);
	struct neigh_table *tbl;
	void *sysctl_table;
	int dead;
	refcount_t refcnt;
	struct callback_head callback_head;
	int reachable_time;
	u32 qlen;
	int data[14];
	long unsigned int data_state[1];
};

struct neigh_statistics {
	long unsigned int allocs;
	long unsigned int destroys;
	long unsigned int hash_grows;
	long unsigned int res_failed;
	long unsigned int lookups;
	long unsigned int hits;
	long unsigned int rcv_probes_mcast;
	long unsigned int rcv_probes_ucast;
	long unsigned int periodic_gc_runs;
	long unsigned int forced_gc_runs;
	long unsigned int unres_discards;
	long unsigned int table_fulls;
};

struct neigh_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table neigh_vars[21];
};

struct pneigh_entry;

struct neigh_table {
	int family;
	unsigned int entry_size;
	unsigned int key_len;
	__be16 protocol;
	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
	bool (*key_eq)(const struct neighbour *, const void *);
	int (*constructor)(struct neighbour *);
	int (*pconstructor)(struct pneigh_entry *);
	void (*pdestructor)(struct pneigh_entry *);
	void (*proxy_redo)(struct sk_buff *);
	int (*is_multicast)(const void *);
	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
	char *id;
	struct neigh_parms parms;
	struct list_head parms_list;
	int gc_interval;
	int gc_thresh1;
	int gc_thresh2;
	int gc_thresh3;
	long unsigned int last_flush;
	struct delayed_work gc_work;
	struct delayed_work managed_work;
	struct timer_list proxy_timer;
	struct sk_buff_head proxy_queue;
	atomic_t entries;
	atomic_t gc_entries;
	struct list_head gc_list;
	struct list_head managed_list;
	rwlock_t lock;
	long unsigned int last_rand;
	struct neigh_statistics *stats;
	struct neigh_hash_table *nht;
	struct pneigh_entry **phash_buckets;
};

struct neighbour {
	struct hlist_node hash;
	struct hlist_node dev_list;
	struct neigh_table *tbl;
	struct neigh_parms *parms;
	long unsigned int confirmed;
	long unsigned int updated;
	rwlock_t lock;
	refcount_t refcnt;
	unsigned int arp_queue_len_bytes;
	struct sk_buff_head arp_queue;
	struct timer_list timer;
	long unsigned int used;
	atomic_t probes;
	u8 nud_state;
	u8 type;
	u8 dead;
	u8 protocol;
	u32 flags;
	seqlock_t ha_lock;
	long: 0;
	unsigned char ha[32];
	struct hh_cache hh;
	int (*output)(struct neighbour *, struct sk_buff *);
	const struct neigh_ops *ops;
	struct list_head gc_list;
	struct list_head managed_list;
	struct callback_head rcu;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u8 primary_key[0];
};

struct neighbour_cb {
	long unsigned int sched_next;
	unsigned int flags;
};

union nested_table {
	union nested_table *table;
	struct rhash_lock_head *bucket;
};

struct ref_tracker_dir {};

struct raw_notifier_head {
	struct notifier_block *head;
};

struct prot_inuse;

struct netns_core {
	struct ctl_table_header *sysctl_hdr;
	int sysctl_somaxconn;
	int sysctl_optmem_max;
	u8 sysctl_txrehash;
	u8 sysctl_tstamp_allow_data;
	struct prot_inuse *prot_inuse;
	struct cpumask *rps_default_mask;
};

struct tcp_mib;

struct udp_mib;

struct netns_mib {
	struct ipstats_mib *ip_statistics;
	struct ipstats_mib *ipv6_statistics;
	struct tcp_mib *tcp_statistics;
	struct linux_mib *net_statistics;
	struct udp_mib *udp_statistics;
	struct udp_mib *udp_stats_in6;
	struct linux_xfrm_mib *xfrm_statistics;
	struct linux_tls_mib *tls_statistics;
	struct mptcp_mib *mptcp_statistics;
	struct udp_mib *udplite_statistics;
	struct udp_mib *udplite_stats_in6;
	struct icmp_mib *icmp_statistics;
	struct icmpmsg_mib *icmpmsg_statistics;
	struct icmpv6_mib *icmpv6_statistics;
	struct icmpv6msg_mib *icmpv6msg_statistics;
	struct proc_dir_entry *proc_net_devsnmp6;
};

struct netns_packet {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct unix_table {
	spinlock_t *locks;
	struct hlist_head *buckets;
};

struct netns_unix {
	struct unix_table table;
	int sysctl_max_dgram_qlen;
	struct ctl_table_header *ctl;
};

struct netns_nexthop {
	struct rb_root rb_root;
	struct hlist_head *devhash;
	unsigned int seq;
	u32 last_id_allocated;
	struct blocking_notifier_head notifier_chain;
};

struct ping_group_range {
	seqlock_t lock;
	kgid_t range[2];
};

struct sysctl_fib_multipath_hash_seed {
	u32 user_seed;
	u32 mp_seed;
};

struct netns_ipv4 {
	__u8 __cacheline_group_begin__netns_ipv4_read_tx[0];
	u8 sysctl_tcp_early_retrans;
	u8 sysctl_tcp_tso_win_divisor;
	u8 sysctl_tcp_tso_rtt_log;
	u8 sysctl_tcp_autocorking;
	int sysctl_tcp_min_snd_mss;
	unsigned int sysctl_tcp_notsent_lowat;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_min_rtt_wlen;
	int sysctl_tcp_wmem[3];
	u8 sysctl_ip_fwd_use_pmtu;
	__u8 __cacheline_group_end__netns_ipv4_read_tx[0];
	__u8 __cacheline_group_begin__netns_ipv4_read_txrx[0];
	u8 sysctl_tcp_moderate_rcvbuf;
	__u8 __cacheline_group_end__netns_ipv4_read_txrx[0];
	__u8 __cacheline_group_begin__netns_ipv4_read_rx[0];
	u8 sysctl_ip_early_demux;
	u8 sysctl_tcp_early_demux;
	u8 sysctl_tcp_l3mdev_accept;
	int sysctl_tcp_reordering;
	int sysctl_tcp_rmem[3];
	__u8 __cacheline_group_end__netns_ipv4_read_rx[0];
	long: 64;
	struct inet_timewait_death_row tcp_death_row;
	struct udp_table *udp_table;
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain *ra_chain;
	struct mutex ra_mutex;
	struct fib_rules_ops *rules_ops;
	struct fib_table *fib_main;
	struct fib_table *fib_default;
	unsigned int fib_rules_require_fldissect;
	bool fib_has_custom_rules;
	bool fib_has_custom_local_routes;
	bool fib_offload_disabled;
	u8 sysctl_tcp_shrink_window;
	atomic_t fib_num_tclassid_users;
	struct hlist_head *fib_table_hash;
	struct sock *fibnl;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	u8 sysctl_icmp_echo_ignore_all;
	u8 sysctl_icmp_echo_enable_probe;
	u8 sysctl_icmp_echo_ignore_broadcasts;
	u8 sysctl_icmp_ignore_bogus_error_responses;
	u8 sysctl_icmp_errors_use_inbound_ifaddr;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	int sysctl_icmp_msgs_per_sec;
	int sysctl_icmp_msgs_burst;
	atomic_t icmp_global_credit;
	u32 icmp_global_stamp;
	u32 ip_rt_min_pmtu;
	int ip_rt_mtu_expires;
	int ip_rt_min_advmss;
	struct local_ports ip_local_ports;
	u8 sysctl_tcp_ecn;
	u8 sysctl_tcp_ecn_fallback;
	u8 sysctl_ip_default_ttl;
	u8 sysctl_ip_no_pmtu_disc;
	u8 sysctl_ip_fwd_update_priority;
	u8 sysctl_ip_nonlocal_bind;
	u8 sysctl_ip_autobind_reuse;
	u8 sysctl_ip_dynaddr;
	u8 sysctl_raw_l3mdev_accept;
	u8 sysctl_udp_early_demux;
	u8 sysctl_nexthop_compat_mode;
	u8 sysctl_fwmark_reflect;
	u8 sysctl_tcp_fwmark_accept;
	u8 sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_intvl;
	u8 sysctl_tcp_keepalive_probes;
	u8 sysctl_tcp_syn_retries;
	u8 sysctl_tcp_synack_retries;
	u8 sysctl_tcp_syncookies;
	u8 sysctl_tcp_migrate_req;
	u8 sysctl_tcp_comp_sack_nr;
	u8 sysctl_tcp_backlog_ack_defer;
	u8 sysctl_tcp_pingpong_thresh;
	u8 sysctl_tcp_retries1;
	u8 sysctl_tcp_retries2;
	u8 sysctl_tcp_orphan_retries;
	u8 sysctl_tcp_tw_reuse;
	unsigned int sysctl_tcp_tw_reuse_delay;
	int sysctl_tcp_fin_timeout;
	u8 sysctl_tcp_sack;
	u8 sysctl_tcp_window_scaling;
	u8 sysctl_tcp_timestamps;
	int sysctl_tcp_rto_min_us;
	u8 sysctl_tcp_recovery;
	u8 sysctl_tcp_thin_linear_timeouts;
	u8 sysctl_tcp_slow_start_after_idle;
	u8 sysctl_tcp_retrans_collapse;
	u8 sysctl_tcp_stdurg;
	u8 sysctl_tcp_rfc1337;
	u8 sysctl_tcp_abort_on_overflow;
	u8 sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_adv_win_scale;
	u8 sysctl_tcp_dsack;
	u8 sysctl_tcp_app_win;
	u8 sysctl_tcp_frto;
	u8 sysctl_tcp_nometrics_save;
	u8 sysctl_tcp_no_ssthresh_metrics_save;
	u8 sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_challenge_ack_limit;
	u8 sysctl_tcp_min_tso_segs;
	u8 sysctl_tcp_reflect_tos;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	unsigned int sysctl_tcp_child_ehash_entries;
	long unsigned int sysctl_tcp_comp_sack_delay_ns;
	long unsigned int sysctl_tcp_comp_sack_slack_ns;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops *tcp_congestion_control;
	struct tcp_fastopen_context *tcp_fastopen_ctx;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	long unsigned int tfo_active_disable_stamp;
	u32 tcp_challenge_timestamp;
	u32 tcp_challenge_count;
	u8 sysctl_tcp_plb_enabled;
	u8 sysctl_tcp_plb_idle_rehash_rounds;
	u8 sysctl_tcp_plb_rehash_rounds;
	u8 sysctl_tcp_plb_suspend_rto_sec;
	int sysctl_tcp_plb_cong_thresh;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	u8 sysctl_fib_notify_on_flag_change;
	u8 sysctl_tcp_syn_linear_timeouts;
	u8 sysctl_udp_l3mdev_accept;
	u8 sysctl_igmp_llm_reports;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	unsigned int sysctl_udp_child_hash_entries;
	long unsigned int *sysctl_local_reserved_ports;
	int sysctl_ip_prot_sock;
	struct list_head mr_tables;
	struct fib_rules_ops *mr_rules_ops;
	struct sysctl_fib_multipath_hash_seed sysctl_fib_multipath_hash_seed;
	u32 sysctl_fib_multipath_hash_fields;
	u8 sysctl_fib_multipath_use_neigh;
	u8 sysctl_fib_multipath_hash_policy;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	siphash_key_t ip_id_key;
	struct hlist_head *inet_addr_lst;
	struct delayed_work addr_chk_work;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_sysctl_ipv6 {
	struct ctl_table_header *hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *icmp_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *xfrm6_hdr;
	int flush_delay;
	int ip6_rt_max_size;
	int ip6_rt_gc_min_interval;
	int ip6_rt_gc_timeout;
	int ip6_rt_gc_interval;
	int ip6_rt_gc_elasticity;
	int ip6_rt_mtu_expires;
	int ip6_rt_min_advmss;
	u32 multipath_hash_fields;
	u8 multipath_hash_policy;
	u8 bindv6only;
	u8 flowlabel_consistency;
	u8 auto_flowlabels;
	int icmpv6_time;
	u8 icmpv6_echo_ignore_all;
	u8 icmpv6_echo_ignore_multicast;
	u8 icmpv6_echo_ignore_anycast;
	long unsigned int icmpv6_ratemask[4];
	long unsigned int *icmpv6_ratemask_ptr;
	u8 anycast_src_echo_reply;
	u8 ip_nonlocal_bind;
	u8 fwmark_reflect;
	u8 flowlabel_state_ranges;
	int idgen_retries;
	int idgen_delay;
	int flowlabel_reflect;
	int max_dst_opts_cnt;
	int max_hbh_opts_cnt;
	int max_dst_opts_len;
	int max_hbh_opts_len;
	int seg6_flowlabel;
	u32 ioam6_id;
	u64 ioam6_id_wide;
	u8 skip_notify_on_dev_down;
	u8 fib_notify_on_flag_change;
	u8 icmpv6_error_anycast_as_unicast;
};

struct rt6_statistics;

struct seg6_pernet_data;

struct netns_ipv6 {
	struct dst_ops ip6_dst_ops;
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	atomic_t ip6_rt_gc_expire;
	long unsigned int ip6_rt_last_gc;
	unsigned char flowlabel_has_excl;
	bool fib6_has_custom_rules;
	unsigned int fib6_rules_require_fldissect;
	unsigned int fib6_routes_require_src;
	struct rt6_info *ip6_prohibit_entry;
	struct rt6_info *ip6_blk_hole_entry;
	struct fib6_table *fib6_local_tbl;
	struct fib_rules_ops *fib6_rules_ops;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	struct hlist_head *inet6_addr_lst;
	spinlock_t addrconf_hash_lock;
	struct delayed_work addr_chk_work;
	struct list_head mr6_tables;
	struct fib_rules_ops *mr6_rules_ops;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	struct ioam6_pernet_data *ioam6_data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sctp_mib;

struct netns_sctp {
	struct sctp_mib *sctp_statistics;
	struct proc_dir_entry *proc_net_sctp;
	struct ctl_table_header *sysctl_header;
	struct sock *ctl_sock;
	struct sock *udp4_sock;
	struct sock *udp6_sock;
	int udp_port;
	int encap_port;
	struct list_head local_addr_list;
	struct list_head addr_waitq;
	struct timer_list addr_wq_timer;
	struct list_head auto_asconf_splist;
	spinlock_t addr_wq_lock;
	spinlock_t local_addr_lock;
	unsigned int rto_initial;
	unsigned int rto_min;
	unsigned int rto_max;
	int rto_alpha;
	int rto_beta;
	int max_burst;
	int cookie_preserve_enable;
	char *sctp_hmac_alg;
	unsigned int valid_cookie_life;
	unsigned int sack_timeout;
	unsigned int hb_interval;
	unsigned int probe_interval;
	int max_retrans_association;
	int max_retrans_path;
	int max_retrans_init;
	int pf_retrans;
	int ps_retrans;
	int pf_enable;
	int pf_expose;
	int sndbuf_policy;
	int rcvbuf_policy;
	int default_auto_asconf;
	int addip_enable;
	int addip_noauth;
	int prsctp_enable;
	int reconf_enable;
	int auth_enable;
	int intl_enable;
	int ecn_enable;
	int scope_policy;
	int rwnd_upd_shift;
	long unsigned int max_autoclose;
	int l3mdev_accept;
};

struct nf_logger;

struct nf_hook_entries;

struct netns_nf {
	struct proc_dir_entry *proc_netfilter;
	const struct nf_logger *nf_loggers[11];
	struct ctl_table_header *nf_log_dir_header;
	struct ctl_table_header *nf_lwtnl_dir_header;
	struct nf_hook_entries *hooks_ipv4[5];
	struct nf_hook_entries *hooks_ipv6[5];
	struct nf_hook_entries *hooks_arp[3];
	struct nf_hook_entries *hooks_bridge[5];
	unsigned int defrag_ipv4_users;
	unsigned int defrag_ipv6_users;
};

struct nf_generic_net {
	unsigned int timeout;
};

struct nf_tcp_net {
	unsigned int timeouts[14];
	u8 tcp_loose;
	u8 tcp_be_liberal;
	u8 tcp_max_retrans;
	u8 tcp_ignore_invalid_rst;
	unsigned int offload_timeout;
};

struct nf_udp_net {
	unsigned int timeouts[2];
	unsigned int offload_timeout;
};

struct nf_icmp_net {
	unsigned int timeout;
};

struct nf_dccp_net {
	u8 dccp_loose;
	unsigned int dccp_timeout[10];
};

struct nf_sctp_net {
	unsigned int timeouts[10];
};

struct nf_gre_net {
	struct list_head keymap_list;
	unsigned int timeouts[2];
};

struct nf_ip_net {
	struct nf_generic_net generic;
	struct nf_tcp_net tcp;
	struct nf_udp_net udp;
	struct nf_icmp_net icmp;
	struct nf_icmp_net icmpv6;
	struct nf_dccp_net dccp;
	struct nf_sctp_net sctp;
	struct nf_gre_net gre;
};

struct nf_ct_event_notifier;

struct netns_ct {
	bool ecache_dwork_pending;
	u8 sysctl_log_invalid;
	u8 sysctl_events;
	u8 sysctl_acct;
	u8 sysctl_tstamp;
	u8 sysctl_checksum;
	struct ip_conntrack_stat *stat;
	struct nf_ct_event_notifier *nf_conntrack_event_cb;
	struct nf_ip_net nf_ct_proto;
	atomic_t labels_used;
};

struct netns_nftables {
	u8 gencursor;
};

struct nf_flow_table_stat;

struct netns_ft {
	struct nf_flow_table_stat *stat;
};

struct netns_bpf {
	struct bpf_prog_array *run_array[2];
	struct bpf_prog *progs[2];
	struct list_head links[2];
};

struct xfrm_policy_hash {
	struct hlist_head *table;
	unsigned int hmask;
	u8 dbits4;
	u8 sbits4;
	u8 dbits6;
	u8 sbits6;
};

struct xfrm_policy_hthresh {
	struct work_struct work;
	seqlock_t lock;
	u8 lbits4;
	u8 rbits4;
	u8 lbits6;
	u8 rbits6;
};

struct netns_xfrm {
	struct list_head state_all;
	struct hlist_head *state_bydst;
	struct hlist_head *state_bysrc;
	struct hlist_head *state_byspi;
	struct hlist_head *state_byseq;
	struct hlist_head *state_cache_input;
	unsigned int state_hmask;
	unsigned int state_num;
	struct work_struct state_hash_work;
	struct list_head policy_all;
	struct hlist_head *policy_byidx;
	unsigned int policy_idx_hmask;
	unsigned int idx_generator;
	struct xfrm_policy_hash policy_bydst[3];
	unsigned int policy_count[6];
	struct work_struct policy_hash_work;
	struct xfrm_policy_hthresh policy_hthresh;
	struct list_head inexact_bins;
	struct sock *nlsk;
	struct sock *nlsk_stash;
	u32 sysctl_aevent_etime;
	u32 sysctl_aevent_rseqth;
	int sysctl_larval_drop;
	u32 sysctl_acq_expires;
	u8 policy_default[3];
	struct ctl_table_header *sysctl_hdr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dst_ops xfrm4_dst_ops;
	struct dst_ops xfrm6_dst_ops;
	spinlock_t xfrm_state_lock;
	seqcount_spinlock_t xfrm_state_hash_generation;
	seqcount_spinlock_t xfrm_policy_hash_generation;
	spinlock_t xfrm_policy_lock;
	struct mutex xfrm_cfg_mutex;
	struct delayed_work nat_keepalive_work;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_ipvs;

struct mpls_route;

struct netns_mpls {
	int ip_ttl_propagate;
	int default_ttl;
	size_t platform_labels;
	struct mpls_route **platform_label;
	struct ctl_table_header *ctl;
};

struct uevent_sock;

struct net_generic;

struct net {
	refcount_t passive;
	spinlock_t rules_mod_lock;
	unsigned int dev_base_seq;
	u32 ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node defer_free_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct idr netns_ids;
	struct ns_common ns;
	struct ref_tracker_dir refcnt_tracker;
	struct ref_tracker_dir notrefcnt_tracker;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	struct xarray dev_by_index;
	struct raw_notifier_head netdev_chain;
	u32 hash_mix;
	struct net_device *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	long: 64;
	long: 64;
	struct netns_ipv4 ipv4;
	struct netns_ipv6 ipv6;
	struct netns_sctp sctp;
	struct netns_nf nf;
	struct netns_ct ct;
	struct netns_nftables nft;
	struct netns_ft ft;
	struct net_generic *gen;
	struct netns_bpf bpf;
	long: 64;
	struct netns_xfrm xfrm;
	u64 net_cookie;
	struct netns_ipvs *ipvs;
	struct netns_mpls mpls;
	struct sock *diag_nlsk;
	long: 64;
};

struct rtable {
	struct dst_entry dst;
	int rt_genid;
	unsigned int rt_flags;
	__u16 rt_type;
	__u8 rt_is_input;
	__u8 rt_uses_gateway;
	int rt_iif;
	u8 rt_gw_family;
	union {
		__be32 rt_gw4;
		struct in6_addr rt_gw6;
	};
	u32 rt_mtu_locked: 1;
	u32 rt_pmtu: 31;
};

struct rt6_info {
	struct dst_entry dst;
	struct fib6_info *from;
	int sernum;
	struct rt6key rt6i_dst;
	struct rt6key rt6i_src;
	struct in6_addr rt6i_gateway;
	struct inet6_dev *rt6i_idev;
	u32 rt6i_flags;
	short unsigned int rt6i_nfheader_len;
};

struct net_bridge_vlan;

struct net_bridge_mcast {
	struct net_bridge *br;
	struct net_bridge_vlan *vlan;
	u32 multicast_last_member_count;
	u32 multicast_startup_query_count;
	u8 multicast_querier;
	u8 multicast_igmp_version;
	u8 multicast_router;
	u8 multicast_mld_version;
	long unsigned int multicast_last_member_interval;
	long unsigned int multicast_membership_interval;
	long unsigned int multicast_querier_interval;
	long unsigned int multicast_query_interval;
	long unsigned int multicast_query_response_interval;
	long unsigned int multicast_startup_query_interval;
	struct hlist_head ip4_mc_router_list;
	struct timer_list ip4_mc_router_timer;
	struct bridge_mcast_other_query ip4_other_query;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_querier ip4_querier;
	struct hlist_head ip6_mc_router_list;
	struct timer_list ip6_mc_router_timer;
	struct bridge_mcast_other_query ip6_other_query;
	struct bridge_mcast_own_query ip6_own_query;
	struct bridge_mcast_querier ip6_querier;
};

struct net_bridge_vlan_group;

struct net_bridge {
	spinlock_t lock;
	spinlock_t hash_lock;
	struct hlist_head frame_type_list;
	struct net_device *dev;
	long unsigned int options;
	__be16 vlan_proto;
	u16 default_pvid;
	struct net_bridge_vlan_group *vlgrp;
	struct rhashtable fdb_hash_tbl;
	struct list_head port_list;
	union {
		struct rtable fake_rtable;
		struct rt6_info fake_rt6_info;
	};
	u16 group_fwd_mask;
	u16 group_fwd_mask_required;
	bridge_id designated_root;
	bridge_id bridge_id;
	unsigned char topology_change;
	unsigned char topology_change_detected;
	u16 root_port;
	long unsigned int max_age;
	long unsigned int hello_time;
	long unsigned int forward_delay;
	long unsigned int ageing_time;
	long unsigned int bridge_max_age;
	long unsigned int bridge_hello_time;
	long unsigned int bridge_forward_delay;
	long unsigned int bridge_ageing_time;
	u32 root_path_cost;
	u8 group_addr[6];
	enum {
		BR_NO_STP = 0,
		BR_KERNEL_STP = 1,
		BR_USER_STP = 2,
	} stp_enabled;
	struct net_bridge_mcast multicast_ctx;
	struct bridge_mcast_stats *mcast_stats;
	u32 hash_max;
	spinlock_t multicast_lock;
	struct rhashtable mdb_hash_tbl;
	struct rhashtable sg_port_tbl;
	struct hlist_head mcast_gc_list;
	struct hlist_head mdb_list;
	struct work_struct mcast_gc_work;
	struct timer_list hello_timer;
	struct timer_list tcn_timer;
	struct timer_list topology_change_timer;
	struct delayed_work gc_work;
	struct kobject *ifobj;
	u32 auto_cnt;
	atomic_t fdb_n_learned;
	u32 fdb_max_learned;
	struct hlist_head fdb_list;
	struct hlist_head mrp_list;
	struct hlist_head mep_list;
};

union net_bridge_eht_addr {
	__be32 ip4;
	struct in6_addr ip6;
};

struct net_bridge_fdb_key {
	mac_addr addr;
	u16 vlan_id;
};

struct net_bridge_fdb_entry {
	struct rhash_head rhnode;
	struct net_bridge_port *dst;
	struct net_bridge_fdb_key key;
	struct hlist_node fdb_node;
	long unsigned int flags;
	long: 64;
	long: 64;
	long unsigned int updated;
	long unsigned int used;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct net_bridge_fdb_flush_desc {
	long unsigned int flags;
	long unsigned int flags_mask;
	int port_ifindex;
	u16 vlan_id;
};

struct net_bridge_port_group;

struct net_bridge_group_eht_host {
	struct rb_node rb_node;
	union net_bridge_eht_addr h_addr;
	struct hlist_head set_entries;
	unsigned int num_entries;
	unsigned char filter_mode;
	struct net_bridge_port_group *pg;
};

struct net_bridge_mcast_gc {
	struct hlist_node gc_node;
	void (*destroy)(struct net_bridge_mcast_gc *);
};

struct net_bridge_group_eht_set {
	struct rb_node rb_node;
	union net_bridge_eht_addr src_addr;
	struct rb_root entry_tree;
	struct timer_list timer;
	struct net_bridge_port_group *pg;
	struct net_bridge *br;
	struct net_bridge_mcast_gc mcast_gc;
};

struct net_bridge_group_eht_set_entry {
	struct rb_node rb_node;
	struct hlist_node host_list;
	union net_bridge_eht_addr h_addr;
	struct timer_list timer;
	struct net_bridge *br;
	struct net_bridge_group_eht_set *eht_set;
	struct net_bridge_group_eht_host *h_parent;
	struct net_bridge_mcast_gc mcast_gc;
};

struct net_bridge_group_src {
	struct hlist_node node;
	struct br_ip addr;
	struct net_bridge_port_group *pg;
	u8 flags;
	u8 src_query_rexmit_cnt;
	struct timer_list timer;
	struct net_bridge *br;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

struct net_bridge_mcast_port {
	struct net_bridge_port *port;
	struct net_bridge_vlan *vlan;
	struct bridge_mcast_own_query ip4_own_query;
	struct timer_list ip4_mc_router_timer;
	struct hlist_node ip4_rlist;
	struct bridge_mcast_own_query ip6_own_query;
	struct timer_list ip6_mc_router_timer;
	struct hlist_node ip6_rlist;
	unsigned char multicast_router;
	u32 mdb_n_entries;
	u32 mdb_max_entries;
};

struct net_bridge_mdb_entry {
	struct rhash_head rhnode;
	struct net_bridge *br;
	struct net_bridge_port_group *ports;
	struct br_ip addr;
	bool host_joined;
	struct timer_list timer;
	struct hlist_node mdb_node;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

struct net_bridge_port {
	struct net_bridge *br;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head list;
	long unsigned int flags;
	struct net_bridge_vlan_group *vlgrp;
	struct net_bridge_port *backup_port;
	u32 backup_nhid;
	u8 priority;
	u8 state;
	u16 port_no;
	unsigned char topology_change_ack;
	unsigned char config_pending;
	port_id port_id;
	port_id designated_port;
	bridge_id designated_root;
	bridge_id designated_bridge;
	u32 path_cost;
	u32 designated_cost;
	long unsigned int designated_age;
	struct timer_list forward_delay_timer;
	struct timer_list hold_timer;
	struct timer_list message_age_timer;
	struct kobject kobj;
	struct callback_head rcu;
	struct net_bridge_mcast_port multicast_ctx;
	struct bridge_mcast_stats *mcast_stats;
	u32 multicast_eht_hosts_limit;
	u32 multicast_eht_hosts_cnt;
	struct hlist_head mglist;
	char sysfs_name[16];
	struct netpoll *np;
	u16 group_fwd_mask;
	u16 backup_redirected_cnt;
	struct bridge_stp_xstats stp_xstats;
};

struct net_bridge_port_group_sg_key {
	struct net_bridge_port *port;
	struct br_ip addr;
};

struct net_bridge_port_group {
	struct net_bridge_port_group *next;
	struct net_bridge_port_group_sg_key key;
	unsigned char eth_addr[6];
	unsigned char flags;
	unsigned char filter_mode;
	unsigned char grp_query_rexmit_cnt;
	unsigned char rt_protocol;
	struct hlist_head src_list;
	unsigned int src_ents;
	struct timer_list timer;
	struct timer_list rexmit_timer;
	struct hlist_node mglist;
	struct rb_root eht_set_tree;
	struct rb_root eht_host_tree;
	struct rhash_head rhnode;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

struct pcpu_sw_netstats;

struct net_bridge_vlan {
	struct rhash_head vnode;
	struct rhash_head tnode;
	u16 vid;
	u16 flags;
	u16 priv_flags;
	u8 state;
	struct pcpu_sw_netstats *stats;
	union {
		struct net_bridge *br;
		struct net_bridge_port *port;
	};
	union {
		refcount_t refcnt;
		struct net_bridge_vlan *brvlan;
	};
	struct br_tunnel_info tinfo;
	union {
		struct net_bridge_mcast br_mcast_ctx;
		struct net_bridge_mcast_port port_mcast_ctx;
	};
	u16 msti;
	struct list_head vlist;
	struct callback_head rcu;
};

struct net_bridge_vlan_group {
	struct rhashtable vlan_hash;
	struct rhashtable tunnel_hash;
	struct list_head vlan_list;
	u16 num_vlans;
	u16 pvid;
	u8 pvid_state;
};

struct netdev_tc_txq {
	u16 count;
	u16 offset;
};

typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

struct net_device_stats {
	union {
		long unsigned int rx_packets;
		atomic_long_t __rx_packets;
	};
	union {
		long unsigned int tx_packets;
		atomic_long_t __tx_packets;
	};
	union {
		long unsigned int rx_bytes;
		atomic_long_t __rx_bytes;
	};
	union {
		long unsigned int tx_bytes;
		atomic_long_t __tx_bytes;
	};
	union {
		long unsigned int rx_errors;
		atomic_long_t __rx_errors;
	};
	union {
		long unsigned int tx_errors;
		atomic_long_t __tx_errors;
	};
	union {
		long unsigned int rx_dropped;
		atomic_long_t __rx_dropped;
	};
	union {
		long unsigned int tx_dropped;
		atomic_long_t __tx_dropped;
	};
	union {
		long unsigned int multicast;
		atomic_long_t __multicast;
	};
	union {
		long unsigned int collisions;
		atomic_long_t __collisions;
	};
	union {
		long unsigned int rx_length_errors;
		atomic_long_t __rx_length_errors;
	};
	union {
		long unsigned int rx_over_errors;
		atomic_long_t __rx_over_errors;
	};
	union {
		long unsigned int rx_crc_errors;
		atomic_long_t __rx_crc_errors;
	};
	union {
		long unsigned int rx_frame_errors;
		atomic_long_t __rx_frame_errors;
	};
	union {
		long unsigned int rx_fifo_errors;
		atomic_long_t __rx_fifo_errors;
	};
	union {
		long unsigned int rx_missed_errors;
		atomic_long_t __rx_missed_errors;
	};
	union {
		long unsigned int tx_aborted_errors;
		atomic_long_t __tx_aborted_errors;
	};
	union {
		long unsigned int tx_carrier_errors;
		atomic_long_t __tx_carrier_errors;
	};
	union {
		long unsigned int tx_fifo_errors;
		atomic_long_t __tx_fifo_errors;
	};
	union {
		long unsigned int tx_heartbeat_errors;
		atomic_long_t __tx_heartbeat_errors;
	};
	union {
		long unsigned int tx_window_errors;
		atomic_long_t __tx_window_errors;
	};
	union {
		long unsigned int rx_compressed;
		atomic_long_t __rx_compressed;
	};
	union {
		long unsigned int tx_compressed;
		atomic_long_t __tx_compressed;
	};
};

struct netdev_hw_addr_list {
	struct list_head list;
	int count;
	struct rb_root tree;
};

struct garp_port;

struct mrp_port;

struct sfp_bus;

struct xps_dev_maps;

struct pcpu_lstats;

struct pcpu_dstats;

struct netdev_rx_queue;

struct netpoll_info;

struct netdev_name_node;

struct xdp_metadata_ops;

struct xsk_tx_metadata_ops;

struct net_device_core_stats;

struct xfrmdev_ops;

struct vlan_info;

struct tipc_bearer;

struct wpan_dev;

struct xdp_dev_bulk_queue;

struct netdev_stat_ops;

struct netdev_queue_mgmt_ops;

struct netprio_map;

struct phy_link_topology;

struct udp_tunnel_nic_info;

struct udp_tunnel_nic;

struct netdev_config;

struct rtnl_hw_stats64;

struct net_device {
	__u8 __cacheline_group_begin__net_device_read_tx[0];
	union {
		struct {
			long unsigned int priv_flags: 32;
			long unsigned int lltx: 1;
		};
		struct {
			long unsigned int priv_flags: 32;
			long unsigned int lltx: 1;
		} priv_flags_fast;
	};
	const struct net_device_ops *netdev_ops;
	const struct header_ops *header_ops;
	struct netdev_queue *_tx;
	netdev_features_t gso_partial_features;
	unsigned int real_num_tx_queues;
	unsigned int gso_max_size;
	unsigned int gso_ipv4_max_size;
	u16 gso_max_segs;
	s16 num_tc;
	unsigned int mtu;
	short unsigned int needed_headroom;
	struct netdev_tc_txq tc_to_txq[16];
	struct xps_dev_maps *xps_maps[2];
	struct nf_hook_entries *nf_hooks_egress;
	struct bpf_mprog_entry *tcx_egress;
	__u8 __cacheline_group_end__net_device_read_tx[0];
	__u8 __cacheline_group_begin__net_device_read_txrx[0];
	union {
		struct pcpu_lstats *lstats;
		struct pcpu_sw_netstats *tstats;
		struct pcpu_dstats *dstats;
	};
	long unsigned int state;
	unsigned int flags;
	short unsigned int hard_header_len;
	netdev_features_t features;
	struct inet6_dev *ip6_ptr;
	__u8 __cacheline_group_end__net_device_read_txrx[0];
	__u8 __cacheline_group_begin__net_device_read_rx[0];
	struct bpf_prog *xdp_prog;
	struct list_head ptype_specific;
	int ifindex;
	unsigned int real_num_rx_queues;
	struct netdev_rx_queue *_rx;
	unsigned int gro_max_size;
	unsigned int gro_ipv4_max_size;
	rx_handler_func_t *rx_handler;
	void *rx_handler_data;
	possible_net_t nd_net;
	struct netpoll_info *npinfo;
	struct bpf_mprog_entry *tcx_ingress;
	__u8 __cacheline_group_end__net_device_read_rx[0];
	char name[16];
	struct netdev_name_node *name_node;
	struct dev_ifalias *ifalias;
	long unsigned int mem_end;
	long unsigned int mem_start;
	long unsigned int base_addr;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	xdp_features_t xdp_features;
	const struct xdp_metadata_ops *xdp_metadata_ops;
	const struct xsk_tx_metadata_ops *xsk_tx_metadata_ops;
	short unsigned int gflags;
	short unsigned int needed_tailroom;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	unsigned int min_mtu;
	unsigned int max_mtu;
	short unsigned int type;
	unsigned char min_header_len;
	unsigned char name_assign_type;
	int group;
	struct net_device_stats stats;
	struct net_device_core_stats *core_stats;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct ethtool_ops *ethtool_ops;
	const struct l3mdev_ops *l3mdev_ops;
	const struct ndisc_ops *ndisc_ops;
	const struct xfrmdev_ops *xfrmdev_ops;
	unsigned int operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	short unsigned int neigh_priv_len;
	short unsigned int dev_id;
	short unsigned int dev_port;
	int irq;
	u32 priv_len;
	spinlock_t addr_list_lock;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	struct kset *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	bool uc_promisc;
	struct in_device *ip_ptr;
	struct hlist_head fib_nh_head;
	struct vlan_info *vlan_info;
	struct tipc_bearer *tipc_ptr;
	void *atalk_ptr;
	struct wpan_dev *ieee802154_ptr;
	const unsigned char *dev_addr;
	unsigned int num_rx_queues;
	unsigned int xdp_zc_max_segs;
	struct netdev_queue *ingress_queue;
	struct nf_hook_entries *nf_hooks_ingress;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	unsigned int num_tx_queues;
	struct Qdisc *qdisc;
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	struct xdp_dev_bulk_queue *xdp_bulkq;
	struct hlist_head qdisc_hash[16];
	struct timer_list watchdog_timer;
	int watchdog_timeo;
	u32 proto_down_reason;
	struct list_head todo_list;
	int *pcpu_refcnt;
	struct ref_tracker_dir refcnt_tracker;
	struct list_head link_watch_list;
	u8 reg_state;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED = 0,
		RTNL_LINK_INITIALIZING = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device *);
	void *ml_priv;
	enum netdev_ml_priv_type ml_priv_type;
	enum netdev_stat_type pcpu_stat_type: 8;
	struct garp_port *garp_port;
	struct mrp_port *mrp_port;
	struct device dev;
	const struct attribute_group *sysfs_groups[4];
	const struct attribute_group *sysfs_rx_queue_group;
	const struct rtnl_link_ops *rtnl_link_ops;
	const struct netdev_stat_ops *stat_ops;
	const struct netdev_queue_mgmt_ops *queue_mgmt_ops;
	unsigned int tso_max_size;
	u16 tso_max_segs;
	const struct dcbnl_rtnl_ops *dcbnl_ops;
	u8 prio_tc_map[16];
	struct netprio_map *priomap;
	struct phy_link_topology *link_topo;
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key *qdisc_tx_busylock;
	bool proto_down;
	bool threaded;
	long unsigned int see_all_hwtstamp_requests: 1;
	long unsigned int change_proto_down: 1;
	long unsigned int netns_local: 1;
	long unsigned int fcoe_mtu: 1;
	struct list_head net_notifier_list;
	const struct udp_tunnel_nic_info *udp_tunnel_nic_info;
	struct udp_tunnel_nic *udp_tunnel_nic;
	struct netdev_config *cfg;
	struct netdev_config *cfg_pending;
	struct ethtool_netdev_state *ethtool;
	struct bpf_xdp_entity xdp_state[3];
	u8 dev_addr_shadow[32];
	netdevice_tracker linkwatch_dev_tracker;
	netdevice_tracker watchdog_dev_tracker;
	netdevice_tracker dev_registered_tracker;
	struct rtnl_hw_stats64 *offload_xstats_l3;
	struct devlink_port *devlink_port;
	struct hlist_head page_pools;
	struct dim_irq_moder *irq_moder;
	u64 max_pacing_offload_horizon;
	struct napi_config *napi_config;
	long unsigned int gro_flush_timeout;
	u32 napi_defer_hard_irqs;
	bool up;
	struct mutex lock;
	struct hlist_head neighbours[2];
	struct hwtstamp_provider *hwprov;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 priv[0];
};

struct net_device_core_stats {
	long unsigned int rx_dropped;
	long unsigned int tx_dropped;
	long unsigned int rx_nohandler;
	long unsigned int rx_otherhost_dropped;
};

struct net_device_devres {
	struct net_device *ndev;
};

struct net_device_path {
	enum net_device_path_type type;
	const struct net_device *dev;
	union {
		struct {
			u16 id;
			__be16 proto;
			u8 h_dest[6];
		} encap;
		struct {
			enum {
				DEV_PATH_BR_VLAN_KEEP = 0,
				DEV_PATH_BR_VLAN_TAG = 1,
				DEV_PATH_BR_VLAN_UNTAG = 2,
				DEV_PATH_BR_VLAN_UNTAG_HW = 3,
			} vlan_mode;
			u16 vlan_id;
			__be16 vlan_proto;
		} bridge;
		struct {
			int port;
			u16 proto;
		} dsa;
		struct {
			u8 wdma_idx;
			u8 queue;
			u16 wcid;
			u8 bss;
			u8 amsdu;
		} mtk_wdma;
	};
};

struct net_device_path_ctx {
	const struct net_device *dev;
	u8 daddr[6];
	int num_vlans;
	struct {
		u16 id;
		__be16 proto;
	} vlan[2];
};

struct net_device_path_stack {
	int num_paths;
	struct net_device_path path[5];
};

struct net_devmem_dmabuf_binding {
	struct dma_buf *dmabuf;
	struct dma_buf_attachment *attachment;
	struct sg_table *sgt;
	struct net_device *dev;
	struct gen_pool *chunk_pool;
	refcount_t ref;
	struct list_head list;
	struct xarray bound_rxqs;
	u32 id;
};

struct rtnl_link_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
	__u64 collisions;
	__u64 rx_length_errors;
	__u64 rx_over_errors;
	__u64 rx_crc_errors;
	__u64 rx_frame_errors;
	__u64 rx_fifo_errors;
	__u64 rx_missed_errors;
	__u64 tx_aborted_errors;
	__u64 tx_carrier_errors;
	__u64 tx_fifo_errors;
	__u64 tx_heartbeat_errors;
	__u64 tx_window_errors;
	__u64 rx_compressed;
	__u64 tx_compressed;
	__u64 rx_nohandler;
	__u64 rx_otherhost_dropped;
};

struct net_failover_info {
	struct net_device *primary_dev;
	struct net_device *standby_dev;
	struct rtnl_link_stats64 primary_stats;
	struct rtnl_link_stats64 standby_stats;
	struct rtnl_link_stats64 failover_stats;
	spinlock_t stats_lock;
};

struct net_fill_args {
	u32 portid;
	u32 seq;
	int flags;
	int cmd;
	int nsid;
	bool add_ref;
	int ref_nsid;
};

struct net_generic {
	union {
		struct {
			unsigned int len;
			struct callback_head rcu;
		} s;
		struct {
			struct {} __empty_ptr;
			void *ptr[0];
		};
	};
};

struct offload_callbacks {
	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sk_buff *, int);
};

struct packet_offload {
	__be16 type;
	u16 priority;
	struct offload_callbacks callbacks;
	struct list_head list;
};

struct net_offload {
	struct offload_callbacks callbacks;
	unsigned int flags;
	u32 secret;
};

struct net_protocol {
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, u32);
	unsigned int no_policy: 1;
	unsigned int icmp_strict_tag_validation: 1;
	u32 secret;
};

struct rps_sock_flow_table;

struct net_hotdata {
	struct packet_offload ip_packet_offload;
	struct net_offload tcpv4_offload;
	struct net_protocol tcp_protocol;
	struct net_offload udpv4_offload;
	struct net_protocol udp_protocol;
	struct packet_offload ipv6_packet_offload;
	struct net_offload tcpv6_offload;
	struct inet6_protocol tcpv6_protocol;
	struct inet6_protocol udpv6_protocol;
	struct net_offload udpv6_offload;
	struct list_head offload_base;
	struct list_head ptype_all;
	struct kmem_cache *skbuff_cache;
	struct kmem_cache *skbuff_fclone_cache;
	struct kmem_cache *skb_small_head_cache;
	struct rps_sock_flow_table *rps_sock_flow_table;
	u32 rps_cpu_mask;
	int gro_normal_batch;
	int netdev_budget;
	int netdev_budget_usecs;
	int tstamp_prequeue;
	int max_backlog;
	int dev_tx_weight;
	int dev_rx_weight;
	int sysctl_max_skb_frags;
	int sysctl_skb_defer_max;
	int sysctl_mem_pcpu_rsv;
};

struct net_iov {
	long unsigned int __unused_padding;
	long unsigned int pp_magic;
	struct page_pool *pp;
	struct dmabuf_genpool_chunk_owner *owner;
	long unsigned int dma_addr;
	atomic_long_t pp_ref_count;
};

struct net_packet_attrs {
	const unsigned char *src;
	const unsigned char *dst;
	u32 ip_src;
	u32 ip_dst;
	bool tcp;
	u16 sport;
	u16 dport;
	int timeout;
	int size;
	int max_size;
	u8 id;
	u16 queue_mapping;
};

struct net_proto_family {
	int family;
	int (*create)(struct net *, struct socket *, int, int);
	struct module *owner;
};

struct net_rate_estimator {
	struct gnet_stats_basic_sync *bstats;
	spinlock_t *stats_lock;
	bool running;
	struct gnet_stats_basic_sync *cpu_bstats;
	u8 ewma_log;
	u8 intvl_log;
	seqcount_t seq;
	u64 last_packets;
	u64 last_bytes;
	u64 avpps;
	u64 avbps;
	long unsigned int next_jiffies;
	struct timer_list timer;
	struct callback_head rcu;
};

struct net_test {
	char name[32];
	int (*fn)(struct net_device *);
};

struct net_test_priv {
	struct net_packet_attrs *packet;
	struct packet_type pt;
	struct completion comp;
	int double_vlan;
	int vlan_id;
	int ok;
};

struct netconfmsg {
	__u8 ncm_family;
};

struct netconsole_target_stats {
	u64_stats_t xmit_drop_count;
	u64_stats_t enomem_count;
	struct u64_stats_sync syncp;
};

struct netpoll {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	char dev_name[16];
	const char *name;
	union inet_addr local_ip;
	union inet_addr remote_ip;
	bool ipv6;
	u16 local_port;
	u16 remote_port;
	u8 remote_mac[6];
	struct sk_buff_head skb_pool;
};

struct netconsole_target {
	struct list_head list;
	struct netconsole_target_stats stats;
	bool enabled;
	bool extended;
	bool release;
	struct netpoll np;
};

struct netdev_adjacent {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	bool master;
	bool ignore;
	u16 ref_nr;
	void *private;
	struct list_head list;
	struct callback_head rcu;
};

struct netdev_bonding_info {
	ifslave slave;
	ifbond master;
};

struct netdev_bpf {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			struct bpf_offloaded_map *offmap;
		};
		struct {
			struct xsk_buff_pool *pool;
			u16 queue_id;
		} xsk;
	};
};

struct netdev_config {
	u32 hds_thresh;
	u8 hds_config;
};

struct netdev_hw_addr {
	struct list_head list;
	struct rb_node node;
	unsigned char addr[32];
	unsigned char type;
	bool global_use;
	int sync_cnt;
	int refcount;
	int synced;
	struct callback_head callback_head;
};

struct netdev_lag_lower_state_info {
	u8 link_up: 1;
	u8 tx_enabled: 1;
};

struct netdev_lag_upper_info {
	enum netdev_lag_tx_type tx_type;
	enum netdev_lag_hash hash_type;
};

struct netdev_name_node {
	struct hlist_node hlist;
	struct list_head list;
	struct net_device *dev;
	const char *name;
	struct callback_head rcu;
};

struct netdev_nested_priv {
	unsigned char flags;
	void *data;
};

struct netdev_net_notifier {
	struct list_head list;
	struct notifier_block *nb;
};

struct netdev_nl_dump_ctx {
	long unsigned int ifindex;
	unsigned int rxq_idx;
	unsigned int txq_idx;
	unsigned int napi_id;
};

struct netdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct netdev_notifier_bonding_info {
	struct netdev_notifier_info info;
	struct netdev_bonding_info bonding_info;
};

struct netdev_notifier_change_info {
	struct netdev_notifier_info info;
	unsigned int flags_changed;
};

struct netdev_notifier_changelowerstate_info {
	struct netdev_notifier_info info;
	void *lower_state_info;
};

struct netdev_notifier_changeupper_info {
	struct netdev_notifier_info info;
	struct net_device *upper_dev;
	bool master;
	bool linking;
	void *upper_info;
};

struct netdev_notifier_info_ext {
	struct netdev_notifier_info info;
	union {
		u32 mtu;
	} ext;
};

struct netdev_notifier_offload_xstats_rd;

struct netdev_notifier_offload_xstats_ru;

struct netdev_notifier_offload_xstats_info {
	struct netdev_notifier_info info;
	enum netdev_offload_xstats_type type;
	union {
		struct netdev_notifier_offload_xstats_rd *report_delta;
		struct netdev_notifier_offload_xstats_ru *report_used;
	};
};

struct rtnl_hw_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
};

struct netdev_notifier_offload_xstats_rd {
	struct rtnl_hw_stats64 stats;
	bool used;
};

struct netdev_notifier_offload_xstats_ru {
	bool used;
};

struct netdev_notifier_pre_changeaddr_info {
	struct netdev_notifier_info info;
	const unsigned char *dev_addr;
};

struct netdev_queue {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct Qdisc *qdisc;
	struct Qdisc *qdisc_sleeping;
	struct kobject kobj;
	long unsigned int tx_maxrate;
	atomic_long_t trans_timeout;
	struct net_device *sb_dev;
	long: 64;
	long: 64;
	struct dql dql;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	long unsigned int trans_start;
	long unsigned int state;
	struct napi_struct *napi;
	int numa_node;
	long: 64;
	long: 64;
	long: 64;
};

struct netdev_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_queue *, char *);
	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
};

struct netdev_queue_mgmt_ops {
	size_t ndo_queue_mem_size;
	int (*ndo_queue_mem_alloc)(struct net_device *, void *, int);
	void (*ndo_queue_mem_free)(struct net_device *, void *);
	int (*ndo_queue_start)(struct net_device *, void *, int);
	int (*ndo_queue_stop)(struct net_device *, void *, int);
};

struct netdev_queue_stats_rx {
	u64 bytes;
	u64 packets;
	u64 alloc_fail;
	u64 hw_drops;
	u64 hw_drop_overruns;
	u64 csum_unnecessary;
	u64 csum_none;
	u64 csum_bad;
	u64 hw_gro_packets;
	u64 hw_gro_bytes;
	u64 hw_gro_wire_packets;
	u64 hw_gro_wire_bytes;
	u64 hw_drop_ratelimits;
};

struct netdev_queue_stats_tx {
	u64 bytes;
	u64 packets;
	u64 hw_drops;
	u64 hw_drop_errors;
	u64 csum_none;
	u64 needs_csum;
	u64 hw_gso_packets;
	u64 hw_gso_bytes;
	u64 hw_gso_wire_packets;
	u64 hw_gso_wire_bytes;
	u64 hw_drop_ratelimits;
	u64 stop;
	u64 wake;
};

struct pp_memory_provider_params {
	void *mp_priv;
};

struct rps_map;

struct rps_dev_flow_table;

struct netdev_rx_queue {
	struct xdp_rxq_info xdp_rxq;
	struct rps_map *rps_map;
	struct rps_dev_flow_table *rps_flow_table;
	struct kobject kobj;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct napi_struct *napi;
	struct pp_memory_provider_params mp_params;
	long: 64;
	long: 64;
	long: 64;
};

struct netdev_stat_ops {
	void (*get_queue_stats_rx)(struct net_device *, int, struct netdev_queue_stats_rx *);
	void (*get_queue_stats_tx)(struct net_device *, int, struct netdev_queue_stats_tx *);
	void (*get_base_stats)(struct net_device *, struct netdev_queue_stats_rx *, struct netdev_queue_stats_tx *);
};

struct netdev_xmit {
	u16 recursion;
	u8 more;
	u8 skip_txqueue;
};

struct rnd_state {
	__u32 s1;
	__u32 s2;
	__u32 s3;
	__u32 s4;
};

struct prng {
	u64 seed;
	struct rnd_state prng_state;
};

struct tc_netem_slot {
	__s64 min_delay;
	__s64 max_delay;
	__s32 max_packets;
	__s32 max_bytes;
	__s64 dist_delay;
	__s64 dist_jitter;
};

struct slotstate {
	u64 slot_next;
	s32 packets_left;
	s32 bytes_left;
};

struct netem_sched_data {
	struct rb_root t_root;
	struct sk_buff *t_head;
	struct sk_buff *t_tail;
	u32 t_len;
	struct Qdisc *qdisc;
	struct qdisc_watchdog watchdog;
	s64 latency;
	s64 jitter;
	u32 loss;
	u32 ecn;
	u32 limit;
	u32 counter;
	u32 gap;
	u32 duplicate;
	u32 reorder;
	u32 corrupt;
	u64 rate;
	s32 packet_overhead;
	u32 cell_size;
	struct reciprocal_value cell_size_reciprocal;
	s32 cell_overhead;
	struct crndstate delay_cor;
	struct crndstate loss_cor;
	struct crndstate dup_cor;
	struct crndstate reorder_cor;
	struct crndstate corrupt_cor;
	struct prng prng;
	struct disttable *delay_dist;
	enum {
		CLG_RANDOM = 0,
		CLG_4_STATES = 1,
		CLG_GILB_ELL = 2,
	} loss_model;
	enum {
		TX_IN_GAP_PERIOD = 1,
		TX_IN_BURST_PERIOD = 2,
		LOST_IN_GAP_PERIOD = 3,
		LOST_IN_BURST_PERIOD = 4,
	} _4_state_model;
	enum {
		GOOD_STATE = 1,
		BAD_STATE = 2,
	} GE_state_model;
	struct clgstate clg;
	struct tc_netem_slot slot_config;
	struct slotstate slot;
	struct disttable *slot_dist;
};

struct netem_skb_cb {
	u64 time_to_send;
};

struct netevent_redirect {
	struct dst_entry *old;
	struct dst_entry *new;
	struct neighbour *neigh;
	const void *daddr;
};

typedef void (*netfs_io_terminated_t)(void *, ssize_t, bool);

struct netfs_io_subrequest;

struct netfs_cache_ops {
	void (*end_operation)(struct netfs_cache_resources *);
	int (*read)(struct netfs_cache_resources *, loff_t, struct iov_iter *, enum netfs_read_from_hole, netfs_io_terminated_t, void *);
	int (*write)(struct netfs_cache_resources *, loff_t, struct iov_iter *, netfs_io_terminated_t, void *);
	void (*issue_write)(struct netfs_io_subrequest *);
	void (*expand_readahead)(struct netfs_cache_resources *, long long unsigned int *, long long unsigned int *, long long unsigned int);
	enum netfs_io_source (*prepare_read)(struct netfs_io_subrequest *, long long unsigned int);
	void (*prepare_write_subreq)(struct netfs_io_subrequest *);
	int (*prepare_write)(struct netfs_cache_resources *, loff_t *, size_t *, size_t, loff_t, bool);
	enum netfs_io_source (*prepare_ondemand_read)(struct netfs_cache_resources *, loff_t, size_t *, loff_t, long unsigned int *, ino_t);
	int (*query_occupancy)(struct netfs_cache_resources *, loff_t, size_t, size_t, loff_t *, size_t *);
};

struct netfs_cache_resources {
	const struct netfs_cache_ops *ops;
	void *cache_priv;
	void *cache_priv2;
	unsigned int debug_id;
	unsigned int inval_counter;
};

struct netfs_group;

struct netfs_folio {
	struct netfs_group *netfs_group;
	unsigned int dirty_offset;
	unsigned int dirty_len;
};

struct netfs_group {
	refcount_t ref;
	void (*free)(struct netfs_group *);
};

struct netfs_request_ops;

struct netfs_inode {
	struct inode inode;
	const struct netfs_request_ops *ops;
	struct mutex wb_lock;
	loff_t remote_i_size;
	loff_t zero_point;
	atomic_t io_count;
	long unsigned int flags;
};

struct netfs_io_stream {
	struct netfs_io_subrequest *construct;
	size_t sreq_max_len;
	unsigned int sreq_max_segs;
	unsigned int submit_off;
	unsigned int submit_len;
	unsigned int submit_extendable_to;
	void (*prepare_write)(struct netfs_io_subrequest *);
	void (*issue_write)(struct netfs_io_subrequest *);
	struct list_head subrequests;
	struct netfs_io_subrequest *front;
	long long unsigned int collected_to;
	size_t transferred;
	enum netfs_io_source source;
	short unsigned int error;
	unsigned char stream_nr;
	bool avail;
	bool active;
	bool need_retry;
	bool failed;
};

struct rolling_buffer {
	struct folio_queue *head;
	struct folio_queue *tail;
	struct iov_iter iter;
	u8 next_head_slot;
	u8 first_tail_slot;
};

struct netfs_io_request {
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
	struct inode *inode;
	struct address_space *mapping;
	struct kiocb *iocb;
	struct netfs_cache_resources cache_resources;
	struct netfs_io_request *copy_to_cache;
	struct readahead_control *ractl;
	struct list_head proc_link;
	struct netfs_io_stream io_streams[2];
	struct netfs_group *group;
	struct rolling_buffer buffer;
	wait_queue_head_t waitq;
	void *netfs_priv;
	void *netfs_priv2;
	struct bio_vec *direct_bv;
	unsigned int direct_bv_count;
	unsigned int debug_id;
	unsigned int rsize;
	unsigned int wsize;
	atomic_t subreq_counter;
	unsigned int nr_group_rel;
	spinlock_t lock;
	long long unsigned int submitted;
	long long unsigned int len;
	size_t transferred;
	long int error;
	enum netfs_io_origin origin;
	bool direct_bv_unpin;
	long long unsigned int i_size;
	long long unsigned int start;
	atomic64_t issued_to;
	long long unsigned int collected_to;
	long long unsigned int cleaned_to;
	long long unsigned int abandon_to;
	long unsigned int no_unlock_folio;
	unsigned char front_folio_order;
	refcount_t ref;
	long unsigned int flags;
	const struct netfs_request_ops *netfs_ops;
	void (*cleanup)(struct netfs_io_request *);
};

struct netfs_io_subrequest {
	struct netfs_io_request *rreq;
	struct work_struct work;
	struct list_head rreq_link;
	struct iov_iter io_iter;
	long long unsigned int start;
	size_t len;
	size_t transferred;
	refcount_t ref;
	short int error;
	short unsigned int debug_index;
	unsigned int nr_segs;
	u8 retry_count;
	enum netfs_io_source source;
	unsigned char stream_nr;
	long unsigned int flags;
};

struct netfs_request_ops {
	mempool_t *request_pool;
	mempool_t *subrequest_pool;
	int (*init_request)(struct netfs_io_request *, struct file *);
	void (*free_request)(struct netfs_io_request *);
	void (*free_subrequest)(struct netfs_io_subrequest *);
	void (*expand_readahead)(struct netfs_io_request *);
	int (*prepare_read)(struct netfs_io_subrequest *);
	void (*issue_read)(struct netfs_io_subrequest *);
	bool (*is_still_valid)(struct netfs_io_request *);
	int (*check_write_begin)(struct file *, loff_t, unsigned int, struct folio **, void **);
	void (*done)(struct netfs_io_request *);
	void (*update_i_size)(struct inode *, loff_t);
	void (*post_modify)(struct inode *);
	void (*begin_writeback)(struct netfs_io_request *);
	void (*prepare_write)(struct netfs_io_subrequest *);
	void (*issue_write)(struct netfs_io_subrequest *);
	void (*retry_request)(struct netfs_io_request *, struct netfs_io_stream *);
	void (*invalidate_cache)(struct netfs_io_request *);
};

struct netlbl_af4list {
	__be32 addr;
	__be32 mask;
	u32 valid;
	struct list_head list;
};

struct netlbl_af6list {
	struct in6_addr addr;
	struct in6_addr mask;
	u32 valid;
	struct list_head list;
};

struct netlbl_audit {
	struct lsm_prop prop;
	kuid_t loginuid;
	unsigned int sessionid;
};

struct netlbl_calipso_doiwalk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

struct netlbl_lsm_secattr;

struct netlbl_calipso_ops {
	int (*doi_add)(struct calipso_doi *, struct netlbl_audit *);
	void (*doi_free)(struct calipso_doi *);
	int (*doi_remove)(u32, struct netlbl_audit *);
	struct calipso_doi * (*doi_getdef)(u32);
	void (*doi_putdef)(struct calipso_doi *);
	int (*doi_walk)(u32 *, int (*)(struct calipso_doi *, void *), void *);
	int (*sock_getattr)(struct sock *, struct netlbl_lsm_secattr *);
	int (*sock_setattr)(struct sock *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	void (*sock_delattr)(struct sock *);
	int (*req_setattr)(struct request_sock *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	void (*req_delattr)(struct request_sock *);
	int (*opt_getattr)(const unsigned char *, struct netlbl_lsm_secattr *);
	unsigned char * (*skbuff_optptr)(const struct sk_buff *);
	int (*skbuff_setattr)(struct sk_buff *, const struct calipso_doi *, const struct netlbl_lsm_secattr *);
	int (*skbuff_delattr)(struct sk_buff *);
	void (*cache_invalidate)(void);
	int (*cache_add)(const unsigned char *, const struct netlbl_lsm_secattr *);
};

struct netlbl_cipsov4_doiwalk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

struct netlbl_domaddr_map;

struct netlbl_dommap_def {
	u32 type;
	union {
		struct netlbl_domaddr_map *addrsel;
		struct cipso_v4_doi *cipso;
		struct calipso_doi *calipso;
	};
};

struct netlbl_dom_map {
	char *domain;
	struct netlbl_dommap_def def;
	u16 family;
	u32 valid;
	struct list_head list;
	struct callback_head rcu;
};

struct netlbl_domaddr4_map {
	struct netlbl_dommap_def def;
	struct netlbl_af4list list;
};

struct netlbl_domaddr6_map {
	struct netlbl_dommap_def def;
	struct netlbl_af6list list;
};

struct netlbl_domaddr_map {
	struct list_head list4;
	struct list_head list6;
};

struct netlbl_domhsh_tbl {
	struct list_head *tbl;
	u32 size;
};

struct netlbl_domhsh_walk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

struct netlbl_domhsh_walk_arg___2 {
	struct netlbl_audit *audit_info;
	u32 doi;
};

struct netlbl_lsm_cache {
	refcount_t refcount;
	void (*free)(const void *);
	void *data;
};

struct netlbl_lsm_catmap {
	u32 startbit;
	u64 bitmap[4];
	struct netlbl_lsm_catmap *next;
};

struct netlbl_lsm_secattr {
	u32 flags;
	u32 type;
	char *domain;
	struct netlbl_lsm_cache *cache;
	struct {
		struct {
			struct netlbl_lsm_catmap *cat;
			u32 lvl;
		} mls;
		u32 secid;
	} attr;
};

struct netlbl_unlhsh_addr4 {
	u32 secid;
	struct netlbl_af4list list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_addr6 {
	u32 secid;
	struct netlbl_af6list list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_iface {
	int ifindex;
	struct list_head addr4_list;
	struct list_head addr6_list;
	u32 valid;
	struct list_head list;
	struct callback_head rcu;
};

struct netlbl_unlhsh_tbl {
	struct list_head *tbl;
	u32 size;
};

struct netlbl_unlhsh_walk_arg {
	struct netlink_callback *nl_cb;
	struct sk_buff *skb;
	u32 seq;
};

struct netlink_broadcast_data {
	struct sock *exclude_sk;
	struct net *net;
	u32 portid;
	u32 group;
	int failure;
	int delivery_failure;
	int congested;
	int delivered;
	gfp_t allocation;
	struct sk_buff *skb;
	struct sk_buff *skb2;
	int (*tx_filter)(struct sock *, struct sk_buff *, void *);
	void *tx_data;
};

struct netlink_callback {
	struct sk_buff *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	int flags;
	bool strict_check;
	union {
		u8 ctx[48];
		long int args[6];
	};
};

struct netlink_compare_arg {
	possible_net_t pnet;
	u32 portid;
};

struct netlink_diag_msg {
	__u8 ndiag_family;
	__u8 ndiag_type;
	__u8 ndiag_protocol;
	__u8 ndiag_state;
	__u32 ndiag_portid;
	__u32 ndiag_dst_portid;
	__u32 ndiag_dst_group;
	__u32 ndiag_ino;
	__u32 ndiag_cookie[2];
};

struct netlink_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 ndiag_ino;
	__u32 ndiag_show;
	__u32 ndiag_cookie[2];
};

struct netlink_dump_control {
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	struct netlink_ext_ack *extack;
	void *data;
	struct module *module;
	u32 min_dump_alloc;
	int flags;
};

struct netlink_ext_ack {
	const char *_msg;
	const struct nlattr *bad_attr;
	const struct nla_policy *policy;
	const struct nlattr *miss_nest;
	u16 miss_type;
	u8 cookie[20];
	u8 cookie_len;
	char _msg_buf[80];
};

struct netlink_kernel_cfg {
	unsigned int groups;
	unsigned int flags;
	void (*input)(struct sk_buff *);
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	void (*release)(struct sock *, long unsigned int *);
};

struct netlink_notify {
	struct net *net;
	u32 portid;
	int protocol;
};

struct netlink_policy_dump_state {
	unsigned int policy_idx;
	unsigned int attr_idx;
	unsigned int n_alloc;
	struct {
		const struct nla_policy *policy;
		unsigned int maxtype;
	} policies[0];
};

struct netlink_range_validation {
	u64 min;
	u64 max;
};

struct netlink_range_validation_signed {
	s64 min;
	s64 max;
};

struct netlink_set_err_data {
	struct sock *exclude_sk;
	u32 portid;
	u32 group;
	int code;
};

struct scm_creds {
	u32 pid;
	kuid_t uid;
	kgid_t gid;
};

struct netlink_skb_parms {
	struct scm_creds creds;
	__u32 portid;
	__u32 dst_group;
	__u32 flags;
	struct sock *sk;
	bool nsid_is_set;
	int nsid;
};

struct netlink_sock {
	struct sock sk;
	long unsigned int flags;
	u32 portid;
	u32 dst_portid;
	u32 dst_group;
	u32 subscriptions;
	u32 ngroups;
	long unsigned int *groups;
	long unsigned int state;
	size_t max_recvmsg_len;
	wait_queue_head_t wait;
	bool bound;
	bool cb_running;
	int dump_done_errno;
	struct netlink_callback cb;
	struct mutex nl_cb_mutex;
	void (*netlink_rcv)(struct sk_buff *);
	int (*netlink_bind)(struct net *, int);
	void (*netlink_unbind)(struct net *, int);
	void (*netlink_release)(struct sock *, long unsigned int *);
	struct module *module;
	struct rhash_head node;
	struct callback_head rcu;
};

struct netlink_table {
	struct rhashtable hash;
	struct hlist_head mc_list;
	struct listeners *listeners;
	unsigned int flags;
	unsigned int groups;
	struct mutex *cb_mutex;
	struct module *module;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	void (*release)(struct sock *, long unsigned int *);
	int registered;
};

struct netlink_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct netlink_tap_net {
	struct list_head netlink_tap_all;
	struct mutex netlink_tap_lock;
};

struct netns_pfkey {
	struct hlist_head table;
	atomic_t socks_nr;
};

struct netpoll_info {
	refcount_t refcnt;
	struct semaphore dev_lock;
	struct sk_buff_head txq;
	struct delayed_work tx_work;
	struct netpoll *netpoll;
	struct callback_head rcu;
};

struct netprio_map {
	struct callback_head rcu;
	u32 priomap_len;
	u32 priomap[0];
};

struct netsfhdr {
	__be32 version;
	__be64 magic;
	u8 id;
} __attribute__((packed));

struct new_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};

struct nh_info;

struct nh_group;

struct nexthop {
	struct rb_node rb_node;
	struct list_head fi_list;
	struct list_head f6i_list;
	struct list_head fdb_list;
	struct list_head grp_list;
	struct net *net;
	u32 id;
	u8 protocol;
	u8 nh_flags;
	bool is_group;
	refcount_t refcnt;
	struct callback_head rcu;
	union {
		struct nh_info *nh_info;
		struct nh_group *nh_grp;
	};
};

struct nexthop_grp {
	__u32 id;
	__u8 weight;
	__u8 weight_high;
	__u16 resvd2;
};

struct nf_acct {
	atomic64_t pkts;
	atomic64_t bytes;
	long unsigned int flags;
	struct list_head head;
	refcount_t refcnt;
	char name[32];
	struct callback_head callback_head;
	char data[0];
};

struct nf_br_ops {
	int (*br_dev_xmit_hook)(struct sk_buff *);
};

struct nf_bridge_frag_data {
	char mac[14];
	bool vlan_present;
	u16 vlan_tci;
	__be16 vlan_proto;
};

struct nf_bridge_info {
	enum {
		BRNF_PROTO_UNCHANGED = 0,
		BRNF_PROTO_8021Q = 1,
		BRNF_PROTO_PPPOE = 2,
	} orig_proto: 8;
	u8 pkt_otherhost: 1;
	u8 in_prerouting: 1;
	u8 bridged_dnat: 1;
	u8 sabotage_in_done: 1;
	__u16 frag_max_size;
	int physinif;
	struct net_device *physoutdev;
	union {
		__be32 ipv4_daddr;
		struct in6_addr ipv6_daddr;
		char neigh_header[8];
	};
};

struct nf_conntrack {
	refcount_t use;
};

struct nf_conntrack_tuple_hash {
	struct hlist_nulls_node hnnode;
	struct nf_conntrack_tuple tuple;
};

struct nf_ct_dccp {
	u_int8_t role[2];
	u_int8_t state;
	u_int8_t last_pkt;
	u_int8_t last_dir;
	u_int64_t handshake_seq;
};

struct nf_ct_udp {
	long unsigned int stream_ts;
};

struct nf_ct_gre {
	unsigned int stream_timeout;
	unsigned int timeout;
};

union nf_conntrack_proto {
	struct nf_ct_dccp dccp;
	struct ip_ct_sctp sctp;
	struct ip_ct_tcp tcp;
	struct nf_ct_udp udp;
	struct nf_ct_gre gre;
	unsigned int tmpl_padto;
};

struct nf_ct_ext;

struct nf_conn {
	struct nf_conntrack ct_general;
	spinlock_t lock;
	u32 timeout;
	struct nf_conntrack_zone zone;
	struct nf_conntrack_tuple_hash tuplehash[2];
	long unsigned int status;
	possible_net_t ct_net;
	struct hlist_node nat_bysource;
	struct {} __nfct_init_offset;
	struct nf_conn *master;
	u_int32_t mark;
	u_int32_t secmark;
	struct nf_ct_ext *ext;
	union nf_conntrack_proto proto;
};

struct nf_conn___init {
	struct nf_conn ct;
};

struct nf_conn_counter {
	atomic64_t packets;
	atomic64_t bytes;
};

struct nf_conn_acct {
	struct nf_conn_counter counter[2];
};

struct nf_conn_act_ct_ext {
	int ifindex[2];
};

struct nf_conntrack_helper;

struct nf_conn_help {
	struct nf_conntrack_helper *helper;
	struct hlist_head expectations;
	u8 expecting[4];
	long: 0;
	char data[32];
};

struct nf_conn_labels {
	long unsigned int bits[2];
};

struct nf_nat_pptp {
	__be16 pns_call_id;
	__be16 pac_call_id;
};

union nf_conntrack_nat_help {
	struct nf_nat_pptp nat_pptp_info;
};

struct nf_conn_nat {
	union nf_conntrack_nat_help help;
	int masq_index;
};

struct nf_ct_seqadj {
	u32 correction_pos;
	s32 offset_before;
	s32 offset_after;
};

struct nf_conn_seqadj {
	struct nf_ct_seqadj seq[2];
};

struct nf_conn_synproxy {
	u32 isn;
	u32 its;
	u32 tsoff;
};

struct nf_conn_timeout {
	struct nf_ct_timeout *timeout;
};

struct nf_conn_tstamp {
	u_int64_t start;
	u_int64_t stop;
};

struct nf_conncount_data {
	unsigned int keylen;
	struct rb_root root[256];
	struct net *net;
	struct work_struct gc_work;
	long unsigned int pending_trees[4];
	unsigned int gc_tree;
};

struct nf_conncount_list {
	spinlock_t list_lock;
	u32 last_gc;
	struct list_head head;
	unsigned int count;
};

struct nf_conncount_rb {
	struct rb_node node;
	struct nf_conncount_list list;
	u32 key[5];
	struct callback_head callback_head;
};

struct nf_conncount_tuple {
	struct list_head node;
	struct nf_conntrack_tuple tuple;
	struct nf_conntrack_zone zone;
	int cpu;
	u32 jiffies32;
};

struct nf_conntrack_dccp_buf {
	struct dccp_hdr dh;
	struct dccp_hdr_ext ext;
	union {
		struct dccp_hdr_ack_bits ack;
		struct dccp_hdr_request req;
		struct dccp_hdr_response response;
		struct dccp_hdr_reset rst;
	} u;
};

struct nf_conntrack_ecache {
	long unsigned int cache;
	local64_t timestamp;
	u16 ctmask;
	u16 expmask;
	u32 missed;
	u32 portid;
};

struct nf_conntrack_tuple_mask {
	struct {
		union nf_inet_addr u3;
		union nf_conntrack_man_proto u;
	} src;
};

struct nf_conntrack_expect {
	struct hlist_node lnode;
	struct hlist_node hnode;
	struct nf_conntrack_tuple tuple;
	struct nf_conntrack_tuple_mask mask;
	refcount_t use;
	unsigned int flags;
	unsigned int class;
	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
	struct nf_conntrack_helper *helper;
	struct nf_conn *master;
	struct timer_list timeout;
	union nf_inet_addr saved_addr;
	union nf_conntrack_man_proto saved_proto;
	enum ip_conntrack_dir dir;
	struct callback_head rcu;
};

struct nf_conntrack_expect_policy {
	unsigned int max_expected;
	unsigned int timeout;
	char name[16];
};

struct nf_conntrack_helper {
	struct hlist_node hnode;
	char name[16];
	refcount_t refcnt;
	struct module *me;
	const struct nf_conntrack_expect_policy *expect_policy;
	struct nf_conntrack_tuple tuple;
	int (*help)(struct sk_buff *, unsigned int, struct nf_conn *, enum ip_conntrack_info);
	void (*destroy)(struct nf_conn *);
	int (*from_nlattr)(struct nlattr *, struct nf_conn *);
	int (*to_nlattr)(struct sk_buff *, const struct nf_conn *);
	unsigned int expect_class_max;
	unsigned int flags;
	unsigned int queue_num;
	u16 data_len;
	char nat_mod_name[16];
};

struct nf_conntrack_l4proto {
	u_int8_t l4proto;
	bool allow_clash;
	u16 nlattr_size;
	bool (*can_early_drop)(const struct nf_conn *);
	int (*to_nlattr)(struct sk_buff *, struct nlattr *, struct nf_conn *, bool);
	int (*from_nlattr)(struct nlattr **, struct nf_conn *);
	int (*tuple_to_nlattr)(struct sk_buff *, const struct nf_conntrack_tuple *);
	unsigned int (*nlattr_tuple_size)(void);
	int (*nlattr_to_tuple)(struct nlattr **, struct nf_conntrack_tuple *, u_int32_t);
	const struct nla_policy *nla_policy;
	struct {
		int (*nlattr_to_obj)(struct nlattr **, struct net *, void *);
		int (*obj_to_nlattr)(struct sk_buff *, const void *);
		u16 obj_size;
		u16 nlattr_max;
		const struct nla_policy *nla_policy;
	} ctnl_timeout;
	void (*print_conntrack)(struct seq_file *, struct nf_conn *);
};

struct nf_conntrack_nat_helper {
	struct list_head list;
	char mod_name[16];
	struct module *module;
};

struct nf_conntrack_net_ecache {
	struct delayed_work dwork;
	spinlock_t dying_lock;
	struct hlist_nulls_head dying_list;
};

struct nf_conntrack_net {
	atomic_t count;
	unsigned int expect_count;
	unsigned int users4;
	unsigned int users6;
	unsigned int users_bridge;
	struct ctl_table_header *sysctl_header;
	struct nf_conntrack_net_ecache ecache;
};

struct nf_ct_bridge_info {
	struct nf_hook_ops *ops;
	unsigned int ops_size;
	struct module *me;
};

struct nf_ct_event {
	struct nf_conn *ct;
	u32 portid;
	int report;
};

struct nf_exp_event;

struct nf_ct_event_notifier {
	int (*ct_event)(unsigned int, const struct nf_ct_event *);
	int (*exp_event)(unsigned int, const struct nf_exp_event *);
};

struct nf_ct_ext {
	u8 offset[10];
	u8 len;
	unsigned int gen_id;
	char data[0];
};

struct nf_ct_ftp_master {
	u_int32_t seq_aft_nl[4];
	u_int16_t seq_aft_nl_num[2];
	u_int16_t flags[2];
};

struct nf_ct_gre_keymap {
	struct list_head list;
	struct nf_conntrack_tuple tuple;
	struct callback_head rcu;
};

struct nf_ct_h323_master {
	__be16 sig_port[2];
	__be16 rtp_port[8];
	union {
		u_int32_t timeout;
		u_int16_t tpkt_len[2];
	};
};

struct nf_ct_helper_expectfn {
	struct list_head head;
	const char *name;
	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
};

struct nf_ct_hook {
	int (*update)(struct net *, struct sk_buff *);
	void (*destroy)(struct nf_conntrack *);
	bool (*get_tuple_skb)(struct nf_conntrack_tuple *, const struct sk_buff *);
	void (*attach)(struct sk_buff *, const struct sk_buff *);
	void (*set_closing)(struct nf_conntrack *);
	int (*confirm)(struct sk_buff *);
};

struct nf_ct_iter_data {
	struct net *net;
	void *data;
	u32 portid;
	int report;
};

struct nf_ct_pptp_master {
	enum pptp_ctrlsess_state sstate;
	enum pptp_ctrlcall_state cstate;
	__be16 pac_call_id;
	__be16 pns_call_id;
	struct nf_ct_gre_keymap *keymap[2];
};

struct nf_ct_sane_master {
	enum sane_state state;
};

struct nf_ct_sip_master {
	unsigned int register_cseq;
	unsigned int invite_cseq;
	__be16 forced_dport;
};

struct nf_ct_tcp_flags {
	__u8 flags;
	__u8 mask;
};

struct nf_ct_timeout_hooks {
	struct nf_ct_timeout * (*timeout_find_get)(struct net *, const char *);
	void (*timeout_put)(struct nf_ct_timeout *);
};

struct nf_defrag_hook {
	struct module *owner;
	int (*enable)(struct net *);
	void (*disable)(struct net *);
};

struct nf_exp_event {
	struct nf_conntrack_expect *exp;
	u32 portid;
	int report;
};

struct nf_flow_key {
	struct flow_dissector_key_meta meta;
	struct flow_dissector_key_control control;
	struct flow_dissector_key_control enc_control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_keyid enc_key_id;
	union {
		struct flow_dissector_key_ipv4_addrs enc_ipv4;
		struct flow_dissector_key_ipv6_addrs enc_ipv6;
	};
	struct flow_dissector_key_tcp tcp;
	struct flow_dissector_key_ports tp;
};

struct nf_flow_match {
	struct flow_dissector dissector;
	struct nf_flow_key key;
	struct nf_flow_key mask;
};

struct nf_flow_route {
	struct {
		struct dst_entry *dst;
		struct {
			u32 ifindex;
			struct {
				u16 id;
				__be16 proto;
			} encap[2];
			u8 num_encaps: 2;
			u8 ingress_vlans: 2;
		} in;
		struct {
			u32 ifindex;
			u32 hw_ifindex;
			u8 h_source[6];
			u8 h_dest[6];
		} out;
		enum flow_offload_xmit_type xmit_type;
	} tuple[2];
};

struct nf_flow_rule {
	struct nf_flow_match match;
	struct flow_rule *rule;
};

struct nf_flow_table_stat {
	unsigned int count_wq_add;
	unsigned int count_wq_del;
	unsigned int count_wq_stats;
};

struct nf_flowtable_type;

struct nf_flowtable {
	unsigned int flags;
	int priority;
	struct rhashtable rhashtable;
	struct list_head list;
	const struct nf_flowtable_type *type;
	struct delayed_work gc_work;
	struct flow_block flow_block;
	struct rw_semaphore flow_block_lock;
	possible_net_t net;
};

struct nf_flowtable_ctx {
	const struct net_device *in;
	u32 offset;
	u32 hdrsize;
};

struct nf_flowtable_type {
	struct list_head list;
	int family;
	int (*init)(struct nf_flowtable *);
	bool (*gc)(const struct flow_offload *);
	int (*setup)(struct nf_flowtable *, struct net_device *, enum flow_block_command);
	int (*action)(struct net *, struct flow_offload *, enum flow_offload_tuple_dir, struct nf_flow_rule *);
	void (*free)(struct nf_flowtable *);
	void (*get)(struct nf_flowtable *);
	void (*put)(struct nf_flowtable *);
	nf_hookfn *hook;
	struct module *owner;
};

struct nf_hook_entry {
	nf_hookfn *hook;
	void *priv;
};

struct nf_hook_entries {
	u16 num_hook_entries;
	struct nf_hook_entry hooks[0];
};

struct nf_hook_entries_rcu_head {
	struct callback_head head;
	void *allocation;
};

struct nf_hook_state {
	u8 hook;
	u8 pf;
	struct net_device *in;
	struct net_device *out;
	struct sock *sk;
	struct net *net;
	int (*okfn)(struct net *, struct sock *, struct sk_buff *);
};

struct nf_queue_entry;

struct nf_ipv6_ops {
	void (*route_input)(struct sk_buff *);
	int (*fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	int (*reroute)(struct sk_buff *, const struct nf_queue_entry *);
};

struct nf_log_buf {
	unsigned int count;
	char buf[1020];
};

struct nf_loginfo;

typedef void nf_logfn(struct net *, u_int8_t, unsigned int, const struct sk_buff *, const struct net_device *, const struct net_device *, const struct nf_loginfo *, const char *);

struct nf_logger {
	char *name;
	enum nf_log_type type;
	nf_logfn *logfn;
	struct module *me;
};

struct nf_loginfo {
	u_int8_t type;
	union {
		struct {
			u_int32_t copy_len;
			u_int16_t group;
			u_int16_t qthreshold;
			u_int16_t flags;
		} ulog;
		struct {
			u_int8_t level;
			u_int8_t logflags;
		} log;
	} u;
};

struct nf_mttg_trav {
	struct list_head *head;
	struct list_head *curr;
	uint8_t class;
};

struct nf_nat_hook {
	int (*parse_nat_setup)(struct nf_conn *, enum nf_nat_manip_type, const struct nlattr *);
	void (*decode_session)(struct sk_buff *, struct flowi *);
	void (*remove_nat_bysrc)(struct nf_conn *);
};

struct nf_nat_ipv4_range {
	unsigned int flags;
	__be32 min_ip;
	__be32 max_ip;
	union nf_conntrack_man_proto min;
	union nf_conntrack_man_proto max;
};

struct nf_nat_ipv4_multi_range_compat {
	unsigned int rangesize;
	struct nf_nat_ipv4_range range[1];
};

struct nf_nat_lookup_hook_priv {
	struct nf_hook_entries *entries;
	struct callback_head callback_head;
};

union pptp_ctrl_union;

struct nf_nat_pptp_hook {
	int (*outbound)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, unsigned int, struct PptpControlHeader *, union pptp_ctrl_union *);
	int (*inbound)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, unsigned int, struct PptpControlHeader *, union pptp_ctrl_union *);
	void (*exp_gre)(struct nf_conntrack_expect *, struct nf_conntrack_expect *);
	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
};

struct nf_nat_proto_clean {
	u8 l3proto;
	u8 l4proto;
};

struct nf_nat_range {
	unsigned int flags;
	union nf_inet_addr min_addr;
	union nf_inet_addr max_addr;
	union nf_conntrack_man_proto min_proto;
	union nf_conntrack_man_proto max_proto;
};

struct nf_nat_range2 {
	unsigned int flags;
	union nf_inet_addr min_addr;
	union nf_inet_addr max_addr;
	union nf_conntrack_man_proto min_proto;
	union nf_conntrack_man_proto max_proto;
	union nf_conntrack_man_proto base_proto;
};

struct nf_nat_sip_hooks {
	unsigned int (*msg)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *);
	void (*seq_adjust)(struct sk_buff *, unsigned int, s16);
	unsigned int (*expect)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, struct nf_conntrack_expect *, unsigned int, unsigned int);
	unsigned int (*sdp_addr)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, unsigned int, enum sdp_header_types, enum sdp_header_types, const union nf_inet_addr *);
	unsigned int (*sdp_port)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, unsigned int, unsigned int, u_int16_t);
	unsigned int (*sdp_session)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, unsigned int, const union nf_inet_addr *);
	unsigned int (*sdp_media)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, struct nf_conntrack_expect *, struct nf_conntrack_expect *, unsigned int, unsigned int, union nf_inet_addr *);
};

struct nf_osf_data {
	const char *genre;
	const char *version;
};

struct nf_osf_wc {
	__u32 wc;
	__u32 val;
};

struct nf_osf_opt {
	__u16 kind;
	__u16 length;
	struct nf_osf_wc wc;
};

struct nf_osf_user_finger {
	struct nf_osf_wc wss;
	__u8 ttl;
	__u8 df;
	__u16 ss;
	__u16 mss;
	__u16 opt_num;
	char genre[32];
	char version[32];
	char subtype[32];
	struct nf_osf_opt opt[40];
};

struct nf_osf_finger {
	struct callback_head callback_head;
	struct list_head finger_entry;
	struct nf_osf_user_finger finger;
};

struct nf_osf_hdr_ctx {
	bool df;
	u16 window;
	u16 totlen;
	const unsigned char *optp;
	unsigned int optsize;
};

struct nf_osf_info {
	char genre[32];
	__u32 len;
	__u32 flags;
	__u32 loglevel;
	__u32 ttl;
};

struct nf_queue_entry {
	struct list_head list;
	struct sk_buff *skb;
	unsigned int id;
	unsigned int hook_index;
	struct net_device *physin;
	struct net_device *physout;
	struct nf_hook_state state;
	u16 size;
};

struct nf_queue_handler {
	int (*outfn)(struct nf_queue_entry *, unsigned int);
	void (*nf_hook_drop)(struct net *);
};

struct nf_sockopt_ops {
	struct list_head list;
	u_int8_t pf;
	int set_optmin;
	int set_optmax;
	int (*set)(struct sock *, int, sockptr_t, unsigned int);
	int get_optmin;
	int get_optmax;
	int (*get)(struct sock *, int, void *, int *);
	struct module *owner;
};

struct nf_synproxy_info {
	__u8 options;
	__u8 wscale;
	__u16 mss;
};

struct nfacct_filter {
	u32 value;
	u32 mask;
};

struct nfct_h323_nat_hooks {
	int (*set_h245_addr)(struct sk_buff *, unsigned int, unsigned char **, int, H245_TransportAddress *, union nf_inet_addr *, __be16);
	int (*set_h225_addr)(struct sk_buff *, unsigned int, unsigned char **, int, TransportAddress *, union nf_inet_addr *, __be16);
	int (*set_sig_addr)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, unsigned int, unsigned char **, TransportAddress *, int);
	int (*set_ras_addr)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, unsigned int, unsigned char **, TransportAddress *, int);
	int (*nat_rtp_rtcp)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, unsigned int, unsigned char **, int, H245_TransportAddress *, __be16, __be16, struct nf_conntrack_expect *, struct nf_conntrack_expect *);
	int (*nat_t120)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, unsigned int, unsigned char **, int, H245_TransportAddress *, __be16, struct nf_conntrack_expect *);
	int (*nat_h245)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, unsigned int, unsigned char **, int, TransportAddress *, __be16, struct nf_conntrack_expect *);
	int (*nat_callforwarding)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, unsigned int, unsigned char **, int, TransportAddress *, __be16, struct nf_conntrack_expect *);
	int (*nat_q931)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, unsigned int, unsigned char **, TransportAddress *, int, __be16, struct nf_conntrack_expect *);
};

struct nfct_timeout_pernet {
	struct list_head nfct_timeout_list;
	struct list_head nfct_timeout_freelist;
};

struct nfgenmsg {
	__u8 nfgen_family;
	__u8 version;
	__be16 res_id;
};

struct nfnl_callback;

struct nfnetlink_subsystem {
	const char *name;
	__u8 subsys_id;
	__u8 cb_count;
	const struct nfnl_callback *cb;
	struct module *owner;
	int (*commit)(struct net *, struct sk_buff *);
	int (*abort)(struct net *, struct sk_buff *, enum nfnl_abort_action);
	bool (*valid_genid)(struct net *, u32);
};

struct nfnl_acct_net {
	struct list_head nfnl_acct_list;
};

struct nfnl_info;

struct nfnl_callback {
	int (*call)(struct sk_buff *, const struct nfnl_info *, const struct nlattr * const *);
	const struct nla_policy *policy;
	enum nfnl_callback_type type;
	__u16 attr_count;
};

struct nfnl_ct_hook {
	size_t (*build_size)(const struct nf_conn *);
	int (*build)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, u_int16_t, u_int16_t);
	int (*parse)(const struct nlattr *, struct nf_conn *);
	int (*attach_expect)(const struct nlattr *, struct nf_conn *, u32, u32);
	void (*seq_adjust)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, s32);
};

struct nfnl_cthelper {
	struct list_head list;
	struct nf_conntrack_helper helper;
};

struct nfnl_err {
	struct list_head head;
	struct nlmsghdr *nlh;
	int err;
	struct netlink_ext_ack extack;
};

struct nfnl_info {
	struct net *net;
	struct sock *sk;
	const struct nlmsghdr *nlh;
	const struct nfgenmsg *nfmsg;
	struct netlink_ext_ack *extack;
};

struct nfnl_log_net {
	spinlock_t instances_lock;
	struct hlist_head instance_table[16];
	atomic_t global_seq;
};

struct nfnl_net {
	struct sock *nfnl;
};

struct nfnl_queue_net {
	spinlock_t instances_lock;
	struct hlist_head instance_table[16];
};

struct nfqnl_instance {
	struct hlist_node hlist;
	struct callback_head rcu;
	u32 peer_portid;
	unsigned int queue_maxlen;
	unsigned int copy_range;
	unsigned int queue_dropped;
	unsigned int queue_user_dropped;
	u_int16_t queue_num;
	u_int8_t copy_mode;
	u_int32_t flags;
	long: 0;
	spinlock_t lock;
	unsigned int queue_total;
	unsigned int id_sequence;
	struct list_head queue_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nfqnl_msg_config_cmd {
	__u8 command;
	__u8 _pad;
	__be16 pf;
};

struct nfqnl_msg_config_params {
	__be32 copy_range;
	__u8 copy_mode;
} __attribute__((packed));

struct nfqnl_msg_packet_hdr {
	__be32 packet_id;
	__be16 hw_protocol;
	__u8 hook;
} __attribute__((packed));

struct nfqnl_msg_packet_hw {
	__be16 hw_addrlen;
	__u16 _pad;
	__u8 hw_addr[8];
};

struct nfqnl_msg_packet_timestamp {
	__be64 sec;
	__be64 usec;
};

struct nfqnl_msg_verdict_hdr {
	__be32 verdict;
	__be32 id;
};

struct nfs2_fh {
	char data[32];
};

struct nfs3_accessargs {
	struct nfs_fh *fh;
	__u32 access;
};

struct nfs_fattr;

struct nfs3_accessres {
	struct nfs_fattr *fattr;
	__u32 access;
};

struct nfs3_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
	enum nfs3_createmode createmode;
	__be32 verifier[2];
};

struct rpc_procinfo;

struct rpc_message {
	const struct rpc_procinfo *rpc_proc;
	void *rpc_argp;
	void *rpc_resp;
	const struct cred *rpc_cred;
};

struct nfs3_mkdirargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs3_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

struct nfs3_mknodargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	enum nfs3_ftype type;
	struct iattr *sattr;
	dev_t rdev;
};

struct nfs3_diropres {
	struct nfs_fattr *dir_attr;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs_fsid {
	uint64_t major;
	uint64_t minor;
};

struct nfs4_string;

struct nfs4_threshold;

struct nfs4_label;

struct nfs_fattr {
	unsigned int valid;
	umode_t mode;
	__u32 nlink;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	__u64 size;
	union {
		struct {
			__u32 blocksize;
			__u32 blocks;
		} nfs2;
		struct {
			__u64 used;
		} nfs3;
	} du;
	struct nfs_fsid fsid;
	__u64 fileid;
	__u64 mounted_on_fileid;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	__u64 change_attr;
	__u64 pre_change_attr;
	__u64 pre_size;
	struct timespec64 pre_mtime;
	struct timespec64 pre_ctime;
	long unsigned int time_start;
	long unsigned int gencount;
	struct nfs4_string *owner_name;
	struct nfs4_string *group_name;
	struct nfs4_threshold *mdsthreshold;
	struct nfs4_label *label;
};

struct nfs3_createdata {
	struct rpc_message msg;
	union {
		struct nfs3_createargs create;
		struct nfs3_mkdirargs mkdir;
		struct nfs3_symlinkargs symlink;
		struct nfs3_mknodargs mknod;
	} arg;
	struct nfs3_diropres res;
	struct nfs_fh fh;
	struct nfs_fattr fattr;
	struct nfs_fattr dir_attr;
};

struct nfs3_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs3_fh {
	short unsigned int size;
	unsigned char data[64];
};

struct nfs3_getaclargs {
	struct nfs_fh *fh;
	int mask;
	struct page **pages;
};

struct nfs3_getaclres {
	struct nfs_fattr *fattr;
	int mask;
	unsigned int acl_access_count;
	unsigned int acl_default_count;
	struct posix_acl *acl_access;
	struct posix_acl *acl_default;
};

struct nfs3_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs3_linkres {
	struct nfs_fattr *dir_attr;
	struct nfs_fattr *fattr;
};

struct nfs3_readdirargs {
	struct nfs_fh *fh;
	__u64 cookie;
	__be32 verf[2];
	bool plus;
	unsigned int count;
	struct page **pages;
};

struct nfs3_readdirres {
	struct nfs_fattr *dir_attr;
	__be32 *verf;
	bool plus;
};

struct nfs3_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs3_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
	unsigned int guard;
	struct timespec64 guardtime;
};

struct nfs3_setaclargs {
	struct inode *inode;
	int mask;
	struct posix_acl *acl_access;
	struct posix_acl *acl_default;
	size_t len;
	unsigned int npages;
	struct page **pages;
};

struct nfs4_sequence_args {
	struct nfs4_slot *sa_slot;
	u8 sa_cache_this: 1;
	u8 sa_privileged: 1;
};

struct nfs4_accessargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
	u32 access;
};

struct nfs4_sequence_res {
	struct nfs4_slot *sr_slot;
	long unsigned int sr_timestamp;
	int sr_status;
	u32 sr_status_flags;
	u32 sr_highest_slotid;
	u32 sr_target_highest_slotid;
};

struct nfs_server;

struct nfs4_accessres {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	u32 supported;
	u32 access;
};

struct nfs4_add_xprt_data {
	struct nfs_client *clp;
	const struct cred *cred;
};

struct nfs4_cached_acl {
	enum nfs4_acl_type type;
	int cached;
	size_t len;
	char data[0];
};

struct nfs4_call_sync_data {
	const struct nfs_server *seq_server;
	struct nfs4_sequence_args *seq_args;
	struct nfs4_sequence_res *seq_res;
};

struct nfs4_change_info {
	u32 atomic;
	u64 before;
	u64 after;
};

struct nfs4_channel_attrs {
	u32 max_rqst_sz;
	u32 max_resp_sz;
	u32 max_resp_sz_cached;
	u32 max_ops;
	u32 max_reqs;
};

struct nfs_seqid;

struct nfs4_layoutreturn_args;

struct nfs_closeargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
	fmode_t fmode;
	u32 share_access;
	const u32 *bitmask;
	u32 bitmask_store[3];
	struct nfs4_layoutreturn_args *lr_args;
};

struct nfs4_layoutreturn_res;

struct nfs_closeres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fattr *fattr;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
};

struct pnfs_layout_hdr;

struct pnfs_layout_range {
	u32 iomode;
	u64 offset;
	u64 length;
};

struct nfs4_xdr_opaque_data;

struct nfs4_layoutreturn_args {
	struct nfs4_sequence_args seq_args;
	struct pnfs_layout_hdr *layout;
	struct inode *inode;
	struct pnfs_layout_range range;
	nfs4_stateid stateid;
	__u32 layout_type;
	struct nfs4_xdr_opaque_data *ld_private;
};

struct nfs4_layoutreturn_res {
	struct nfs4_sequence_res seq_res;
	u32 lrs_present;
	nfs4_stateid stateid;
};

struct nfs4_xdr_opaque_ops;

struct nfs4_xdr_opaque_data {
	const struct nfs4_xdr_opaque_ops *ops;
	void *data;
};

struct nfs4_state;

struct nfs4_closedata {
	struct inode *inode;
	struct nfs4_state *state;
	struct nfs_closeargs arg;
	struct nfs_closeres res;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs_fattr fattr;
	long unsigned int timestamp;
};

struct nfs4_create_arg {
	struct nfs4_sequence_args seq_args;
	u32 ftype;
	union {
		struct {
			struct page **pages;
			unsigned int len;
		} symlink;
		struct {
			u32 specdata1;
			u32 specdata2;
		} device;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const struct iattr *attrs;
	const struct nfs_fh *dir_fh;
	const u32 *bitmask;
	const struct nfs4_label *label;
	umode_t umask;
};

struct nfs4_create_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	struct nfs4_change_info dir_cinfo;
};

struct nfs4_createdata {
	struct rpc_message msg;
	struct nfs4_create_arg arg;
	struct nfs4_create_res res;
	struct nfs_fh fh;
	struct nfs_fattr fattr;
};

struct nfs4_delegattr {
	struct timespec64 atime;
	struct timespec64 mtime;
	bool atime_set;
	bool mtime_set;
};

struct nfs4_delegreturnargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fhandle;
	const nfs4_stateid *stateid;
	const u32 *bitmask;
	u32 bitmask_store[3];
	struct nfs4_layoutreturn_args *lr_args;
	struct nfs4_delegattr *sattr_args;
};

struct nfs4_delegreturnres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
	bool sattr_res;
	int sattr_ret;
};

struct nfs4_delegreturndata {
	struct nfs4_delegreturnargs args;
	struct nfs4_delegreturnres res;
	struct nfs_fh fh;
	nfs4_stateid stateid;
	long unsigned int timestamp;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs4_delegattr sattr;
	struct nfs_fattr fattr;
	int rpc_status;
	struct inode *inode;
};

struct nfs4_exception {
	struct nfs4_state *state;
	struct inode *inode;
	nfs4_stateid *stateid;
	long int timeout;
	short unsigned int retrans;
	unsigned char task_is_privileged: 1;
	unsigned char delay: 1;
	unsigned char recovering: 1;
	unsigned char retry: 1;
	bool interruptible;
};

struct nfs4_string {
	unsigned int len;
	char *data;
};

struct nfs4_pathname {
	unsigned int ncomponents;
	struct nfs4_string components[512];
};

struct nfs4_fs_location {
	unsigned int nservers;
	struct nfs4_string servers[10];
	struct nfs4_pathname rootpath;
};

struct nfs4_fs_locations {
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
	struct nfs4_pathname fs_path;
	int nlocations;
	struct nfs4_fs_location locations[10];
};

struct nfs4_fs_locations_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct nfs_fh *fh;
	const struct qstr *name;
	struct page *page;
	const u32 *bitmask;
	clientid4 clientid;
	unsigned char migration: 1;
	unsigned char renew: 1;
};

struct nfs4_fs_locations_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_fs_locations *fs_locations;
	unsigned char migration: 1;
	unsigned char renew: 1;
};

struct nfs4_fsid_present_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	clientid4 clientid;
	unsigned char renew: 1;
};

struct nfs4_fsid_present_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fh *fh;
	unsigned char renew: 1;
};

struct nfs4_fsinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs_fsinfo;

struct nfs4_fsinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsinfo *fsinfo;
};

struct nfs4_get_lease_time_args {
	struct nfs4_sequence_args la_seq_args;
};

struct nfs4_get_lease_time_res;

struct nfs4_get_lease_time_data {
	struct nfs4_get_lease_time_args *args;
	struct nfs4_get_lease_time_res *res;
	struct nfs_client *clp;
};

struct nfs4_get_lease_time_res {
	struct nfs4_sequence_res lr_seq_res;
	struct nfs_fsinfo *lr_fsinfo;
};

struct nfs4_getattr_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_getattr_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
};

struct nfs4_label {
	uint32_t lfs;
	uint32_t pi;
	u32 lsmid;
	u32 len;
	char *label;
};

struct nfs4_layoutdriver_data {
	struct page **pages;
	__u32 pglen;
	__u32 len;
};

struct nfs_open_context;

struct nfs4_layoutget_args {
	struct nfs4_sequence_args seq_args;
	__u32 type;
	struct pnfs_layout_range range;
	__u64 minlength;
	__u32 maxcount;
	struct inode *inode;
	struct nfs_open_context *ctx;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data layout;
};

struct nfs4_layoutget_res {
	struct nfs4_sequence_res seq_res;
	int status;
	__u32 return_on_close;
	struct pnfs_layout_range range;
	__u32 type;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data *layoutp;
};

struct nfs4_layoutget {
	struct nfs4_layoutget_args args;
	struct nfs4_layoutget_res res;
	const struct cred *cred;
	struct pnfs_layout_hdr *lo;
	gfp_t gfp_flags;
};

struct nfs4_link_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_link_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs4_change_info cinfo;
	struct nfs_fattr *dir_attr;
};

struct nfs_seqid_counter {
	ktime_t create_time;
	u64 owner_id;
	int flags;
	u32 counter;
	spinlock_t lock;
	struct list_head list;
	struct rpc_wait_queue wait;
};

struct nfs4_lock_state {
	struct list_head ls_locks;
	struct nfs4_state *ls_state;
	long unsigned int ls_flags;
	struct nfs_seqid_counter ls_seqid;
	nfs4_stateid ls_stateid;
	refcount_t ls_count;
	fl_owner_t ls_owner;
};

struct nfs_lowner {
	__u64 clientid;
	__u64 id;
	dev_t s_dev;
};

struct nfs_lock_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *lock_seqid;
	nfs4_stateid lock_stateid;
	struct nfs_seqid *open_seqid;
	nfs4_stateid open_stateid;
	struct nfs_lowner lock_owner;
	unsigned char block: 1;
	unsigned char reclaim: 1;
	unsigned char new_lock: 1;
	unsigned char new_lock_owner: 1;
};

struct nfs_lock_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *lock_seqid;
	struct nfs_seqid *open_seqid;
};

struct nfs4_lockdata {
	struct nfs_lock_args arg;
	struct nfs_lock_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	struct file_lock fl;
	long unsigned int timestamp;
	int rpc_status;
	int cancelled;
	struct nfs_server *server;
};

struct nfs4_lookup_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_lookup_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
};

struct nfs4_lookup_root_arg {
	struct nfs4_sequence_args seq_args;
	const u32 *bitmask;
};

struct nfs4_lookupp_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_lookupp_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
};

struct nfs4_mig_recovery_ops {
	int (*get_locations)(struct nfs_server *, struct nfs_fh *, struct nfs4_fs_locations *, struct page *, const struct cred *);
	int (*fsid_present)(struct inode *, const struct cred *);
};

struct rpc_xprt;

struct rpc_call_ops;

struct nfs4_state_recovery_ops;

struct nfs4_state_maintenance_ops;

struct nfs4_minor_version_ops {
	u32 minor_version;
	unsigned int init_caps;
	int (*init_client)(struct nfs_client *);
	void (*shutdown_client)(struct nfs_client *);
	bool (*match_stateid)(const nfs4_stateid *, const nfs4_stateid *);
	int (*find_root_sec)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	void (*free_lock_state)(struct nfs_server *, struct nfs4_lock_state *);
	int (*test_and_free_expired)(struct nfs_server *, const nfs4_stateid *, const struct cred *);
	struct nfs_seqid * (*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);
	void (*session_trunk)(struct rpc_clnt *, struct rpc_xprt *, void *);
	const struct rpc_call_ops *call_sync_ops;
	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
	const struct nfs4_state_recovery_ops *nograce_recovery_ops;
	const struct nfs4_state_maintenance_ops *state_renewal_ops;
	const struct nfs4_mig_recovery_ops *mig_recovery_ops;
};

struct nfs_string {
	unsigned int len;
	const char *data;
};

struct nfs4_mount_data {
	int version;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct nfs_string client_addr;
	struct nfs_string mnt_path;
	struct nfs_string hostname;
	unsigned int host_addrlen;
	struct sockaddr *host_addr;
	int proto;
	int auth_flavourlen;
	int *auth_flavours;
};

struct nfs4_open_caps {
	u32 oa_share_access[1];
	u32 oa_share_deny[1];
	u32 oa_share_access_want[1];
	u32 oa_open_claim[1];
	u32 oa_createmode[1];
};

struct nfs4_open_createattrs {
	struct nfs4_label *label;
	struct iattr *sattr;
	const __u32 verf[2];
};

struct nfs4_open_delegation {
	__u32 open_delegation_type;
	union {
		struct {
			fmode_t type;
			__u32 do_recall;
			nfs4_stateid stateid;
			long unsigned int pagemod_limit;
		};
		struct {
			__u32 why_no_delegation;
			__u32 will_notify;
		};
	};
};

struct stateowner_id {
	__u64 create_time;
	__u64 uniquifier;
};

struct nfs_openargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct nfs_seqid *seqid;
	int open_flags;
	fmode_t fmode;
	u32 share_access;
	u32 access;
	__u64 clientid;
	struct stateowner_id id;
	union {
		struct {
			struct iattr *attrs;
			nfs4_verifier verifier;
		};
		nfs4_stateid delegation;
		__u32 delegation_type;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const u32 *bitmask;
	const u32 *open_bitmap;
	enum open_claim_type4 claim;
	enum createmode4 createmode;
	const struct nfs4_label *label;
	umode_t umask;
	struct nfs4_layoutget_args *lg_args;
};

struct nfs_openres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fh fh;
	struct nfs4_change_info cinfo;
	__u32 rflags;
	struct nfs_fattr *f_attr;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	__u32 attrset[3];
	struct nfs4_string *owner;
	struct nfs4_string *group_owner;
	struct nfs4_open_delegation delegation;
	__u32 access_request;
	__u32 access_supported;
	__u32 access_result;
	struct nfs4_layoutget_res *lg_res;
};

struct nfs_open_confirmargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	nfs4_stateid *stateid;
	struct nfs_seqid *seqid;
};

struct nfs_open_confirmres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs4_state_owner;

struct nfs4_opendata {
	struct kref kref;
	struct nfs_openargs o_arg;
	struct nfs_openres o_res;
	struct nfs_open_confirmargs c_arg;
	struct nfs_open_confirmres c_res;
	struct nfs4_string owner_name;
	struct nfs4_string group_name;
	struct nfs4_label *a_label;
	struct nfs_fattr f_attr;
	struct dentry *dir;
	struct dentry *dentry;
	struct nfs4_state_owner *owner;
	struct nfs4_state *state;
	struct iattr attrs;
	struct nfs4_layoutget *lgp;
	long unsigned int timestamp;
	bool rpc_done;
	bool file_created;
	bool is_recover;
	bool cancelled;
	int rpc_status;
};

struct nfs4_pathconf_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs_pathconf;

struct nfs4_pathconf_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_pathconf *pathconf;
};

struct nfs4_readdir_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	u64 cookie;
	nfs4_verifier verifier;
	u32 count;
	struct page **pages;
	unsigned int pgbase;
	const u32 *bitmask;
	bool plus;
};

struct nfs4_readdir_res {
	struct nfs4_sequence_res seq_res;
	nfs4_verifier verifier;
	unsigned int pgbase;
};

struct nfs4_readlink {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs4_readlink_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs4_renewdata {
	struct nfs_client *client;
	long unsigned int timestamp;
};

struct rpcsec_gss_info {
	struct rpcsec_gss_oid oid;
	u32 qop;
	u32 service;
};

struct nfs4_secinfo4 {
	u32 flavor;
	struct rpcsec_gss_info flavor_info;
};

struct nfs4_secinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
};

struct nfs4_secinfo_flavors {
	unsigned int num_flavors;
	struct nfs4_secinfo4 flavors[0];
};

struct nfs4_secinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_secinfo_flavors *flavors;
};

struct nfs4_server_caps_arg {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fhandle;
	const u32 *bitmask;
};

struct nfs4_server_caps_res {
	struct nfs4_sequence_res seq_res;
	u32 attr_bitmask[3];
	u32 exclcreat_bitmask[3];
	u32 acl_bitmask;
	u32 has_links;
	u32 has_symlinks;
	u32 fh_expire_type;
	u32 case_insensitive;
	u32 case_preserving;
	struct nfs4_open_caps open_caps;
};

struct nfs4_sessionid {
	unsigned char data[16];
};

struct nfs4_session;

struct nfs4_slot_table {
	struct nfs4_session *session;
	struct nfs4_slot *slots;
	long unsigned int used_slots[16];
	spinlock_t slot_tbl_lock;
	struct rpc_wait_queue slot_tbl_waitq;
	wait_queue_head_t slot_waitq;
	u32 max_slots;
	u32 max_slotid;
	u32 highest_used_slotid;
	u32 target_highest_slotid;
	u32 server_highest_slotid;
	s32 d_target_highest_slotid;
	s32 d2_target_highest_slotid;
	long unsigned int generation;
	struct completion complete;
	long unsigned int slot_tbl_state;
};

struct nfs4_session {
	struct nfs4_sessionid sess_id;
	u32 flags;
	long unsigned int session_state;
	u32 hash_alg;
	u32 ssv_len;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_slot_table fc_slot_table;
	struct nfs4_channel_attrs bc_attrs;
	struct nfs4_slot_table bc_slot_table;
	struct nfs_client *clp;
};

struct nfs4_setclientid {
	const nfs4_verifier *sc_verifier;
	u32 sc_prog;
	unsigned int sc_netid_len;
	char sc_netid[6];
	unsigned int sc_uaddr_len;
	char sc_uaddr[58];
	struct nfs_client *sc_clnt;
	struct rpc_cred *sc_cred;
};

struct nfs4_setclientid_res {
	u64 clientid;
	nfs4_verifier confirm;
};

struct nfs4_slot {
	struct nfs4_slot_table *table;
	struct nfs4_slot *next;
	long unsigned int generation;
	u32 slot_nr;
	u32 seq_nr;
	u32 seq_nr_last_acked;
	u32 seq_nr_highest_sent;
	unsigned int privileged: 1;
	unsigned int seq_done: 1;
};

struct nfs4_state {
	struct list_head open_states;
	struct list_head inode_states;
	struct list_head lock_states;
	struct nfs4_state_owner *owner;
	struct inode *inode;
	long unsigned int flags;
	spinlock_t state_lock;
	seqlock_t seqlock;
	nfs4_stateid stateid;
	nfs4_stateid open_stateid;
	unsigned int n_rdonly;
	unsigned int n_wronly;
	unsigned int n_rdwr;
	fmode_t state;
	refcount_t count;
	wait_queue_head_t waitq;
	struct callback_head callback_head;
};

struct nfs4_state_maintenance_ops {
	int (*sched_state_renewal)(struct nfs_client *, const struct cred *, unsigned int);
	const struct cred * (*get_state_renewal_cred)(struct nfs_client *);
	int (*renew_lease)(struct nfs_client *, const struct cred *);
};

struct nfs4_state_owner {
	struct nfs_server *so_server;
	struct list_head so_lru;
	long unsigned int so_expires;
	struct rb_node so_server_node;
	const struct cred *so_cred;
	spinlock_t so_lock;
	atomic_t so_count;
	long unsigned int so_flags;
	struct list_head so_states;
	struct nfs_seqid_counter so_seqid;
	struct mutex so_delegreturn_mutex;
};

struct nfs4_state_recovery_ops {
	int owner_flag_bit;
	int state_flag_bit;
	int (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);
	int (*recover_lock)(struct nfs4_state *, struct file_lock *);
	int (*establish_clid)(struct nfs_client *, const struct cred *);
	int (*reclaim_complete)(struct nfs_client *, const struct cred *);
	int (*detect_trunking)(struct nfs_client *, struct nfs_client **, const struct cred *);
};

struct nfs4_statfs_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs_fsstat;

struct nfs4_statfs_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsstat *fsstat;
};

struct nfs4_threshold {
	__u32 bm;
	__u32 l_type;
	__u64 rd_sz;
	__u64 wr_sz;
	__u64 rd_io_sz;
	__u64 wr_io_sz;
};

struct nfs_locku_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *seqid;
	nfs4_stateid stateid;
};

struct nfs_locku_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs_lock_context;

struct nfs4_unlockdata {
	struct nfs_locku_args arg;
	struct nfs_locku_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct file_lock fl;
	struct nfs_server *server;
	long unsigned int timestamp;
};

struct nfs4_xdr_opaque_ops {
	void (*encode)(struct xdr_stream *, const void *, const struct nfs4_xdr_opaque_data *);
	void (*free)(struct nfs4_xdr_opaque_data *);
};

struct nfs_access_entry {
	struct rb_node rb_node;
	struct list_head lru;
	kuid_t fsuid;
	kgid_t fsgid;
	struct group_info *group_info;
	u64 timestamp;
	__u32 mask;
	struct callback_head callback_head;
};

struct nfs_auth_info {
	unsigned int flavor_len;
	rpc_authflavor_t flavors[12];
};

struct nfs_cache_array_entry {
	u64 cookie;
	u64 ino;
	const char *name;
	unsigned int name_len;
	unsigned char d_type;
};

struct nfs_cache_array {
	u64 change_attr;
	u64 last_cookie;
	unsigned int size;
	unsigned char folio_full: 1;
	unsigned char folio_is_eof: 1;
	unsigned char cookies_are_ordered: 1;
	struct nfs_cache_array_entry array[0];
};

struct svc_serv;

struct nfs_callback_data {
	unsigned int users;
	struct svc_serv *serv;
};

struct xprtsec_parms {
	enum xprtsec_policies policy;
	key_serial_t cert_serial;
	key_serial_t privkey_serial;
};

struct nfs41_server_owner;

struct nfs41_server_scope;

struct nfs41_impl_id;

struct nfs_rpc_ops;

struct nfs_subversion;

struct nfs_client {
	refcount_t cl_count;
	atomic_t cl_mds_count;
	int cl_cons_state;
	long unsigned int cl_res_state;
	long unsigned int cl_flags;
	struct __kernel_sockaddr_storage cl_addr;
	size_t cl_addrlen;
	char *cl_hostname;
	char *cl_acceptor;
	struct list_head cl_share_link;
	struct list_head cl_superblocks;
	struct rpc_clnt *cl_rpcclient;
	const struct nfs_rpc_ops *rpc_ops;
	int cl_proto;
	struct nfs_subversion *cl_nfs_mod;
	u32 cl_minorversion;
	unsigned int cl_nconnect;
	unsigned int cl_max_connect;
	const char *cl_principal;
	struct xprtsec_parms cl_xprtsec;
	struct list_head cl_ds_clients;
	u64 cl_clientid;
	nfs4_verifier cl_confirm;
	long unsigned int cl_state;
	spinlock_t cl_lock;
	long unsigned int cl_lease_time;
	long unsigned int cl_last_renewal;
	struct delayed_work cl_renewd;
	struct rpc_wait_queue cl_rpcwaitq;
	struct idmap *cl_idmap;
	const char *cl_owner_id;
	u32 cl_cb_ident;
	const struct nfs4_minor_version_ops *cl_mvops;
	long unsigned int cl_mig_gen;
	struct nfs4_slot_table *cl_slot_tbl;
	u32 cl_seqid;
	u32 cl_exchange_flags;
	struct nfs4_session *cl_session;
	bool cl_preserve_clid;
	struct nfs41_server_owner *cl_serverowner;
	struct nfs41_server_scope *cl_serverscope;
	struct nfs41_impl_id *cl_implid;
	long unsigned int cl_sp4_flags;
	char cl_ipaddr[48];
	struct net *cl_net;
	struct list_head pending_cb_stateids;
	struct callback_head rcu;
};

struct rpc_timeout;

struct nfs_client_initdata {
	long unsigned int init_flags;
	const char *hostname;
	const struct __kernel_sockaddr_storage *addr;
	const char *nodename;
	const char *ip_addr;
	size_t addrlen;
	struct nfs_subversion *nfs_mod;
	int proto;
	u32 minorversion;
	unsigned int nconnect;
	unsigned int max_connect;
	struct net *net;
	const struct rpc_timeout *timeparms;
	const struct cred *cred;
	struct xprtsec_parms xprtsec;
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct nfs_clone_mount {
	struct super_block *sb;
	struct dentry *dentry;
	struct nfs_fattr *fattr;
	unsigned int inherited_bsize;
};

struct nfs_commit_data;

struct nfs_commit_info;

struct nfs_page;

struct nfs_commit_completion_ops {
	void (*completion)(struct nfs_commit_data *);
	void (*resched_write)(struct nfs_commit_info *, struct nfs_page *);
};

struct rpc_wait {
	struct list_head list;
	struct list_head links;
	struct list_head timer_list;
};

struct rpc_rqst;

struct rpc_task {
	atomic_t tk_count;
	int tk_status;
	struct list_head tk_task;
	void (*tk_callback)(struct rpc_task *);
	void (*tk_action)(struct rpc_task *);
	long unsigned int tk_timeout;
	long unsigned int tk_runstate;
	struct rpc_wait_queue *tk_waitqueue;
	union {
		struct work_struct tk_work;
		struct rpc_wait tk_wait;
	} u;
	struct rpc_message tk_msg;
	void *tk_calldata;
	const struct rpc_call_ops *tk_ops;
	struct rpc_clnt *tk_client;
	struct rpc_xprt *tk_xprt;
	struct rpc_cred *tk_op_cred;
	struct rpc_rqst *tk_rqstp;
	struct workqueue_struct *tk_workqueue;
	ktime_t tk_start;
	pid_t tk_owner;
	int tk_rpc_status;
	short unsigned int tk_flags;
	short unsigned int tk_timeouts;
	short unsigned int tk_pid;
	unsigned char tk_priority: 2;
	unsigned char tk_garb_retry: 2;
	unsigned char tk_cred_retry: 2;
};

struct nfs_write_verifier {
	char data[8];
};

struct nfs_writeverf {
	struct nfs_write_verifier verifier;
	enum nfs3_stable_how committed;
};

struct nfs_commitargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	__u64 offset;
	__u32 count;
	const u32 *bitmask;
};

struct nfs_commitres {
	struct nfs4_sequence_res seq_res;
	__u32 op_status;
	struct nfs_fattr *fattr;
	struct nfs_writeverf *verf;
	const struct nfs_server *server;
};

struct nfs_direct_req;

struct pnfs_layout_segment;

struct nfs_commit_data {
	struct rpc_task task;
	struct inode *inode;
	const struct cred *cred;
	struct nfs_fattr fattr;
	struct nfs_writeverf verf;
	struct list_head pages;
	struct list_head list;
	struct nfs_direct_req *dreq;
	struct nfs_commitargs args;
	struct nfs_commitres res;
	struct nfs_open_context *context;
	struct pnfs_layout_segment *lseg;
	struct nfs_client *ds_clp;
	int ds_commit_index;
	loff_t lwb;
	const struct rpc_call_ops *mds_ops;
	const struct nfs_commit_completion_ops *completion_ops;
	int (*commit_done_cb)(struct rpc_task *, struct nfs_commit_data *);
	long unsigned int flags;
};

struct nfs_mds_commit_info;

struct pnfs_ds_commit_info;

struct nfs_commit_info {
	struct inode *inode;
	struct nfs_mds_commit_info *mds;
	struct pnfs_ds_commit_info *ds;
	struct nfs_direct_req *dreq;
	const struct nfs_commit_completion_ops *completion_ops;
};

struct nfs_delegation {
	struct list_head super_list;
	const struct cred *cred;
	struct inode *inode;
	nfs4_stateid stateid;
	fmode_t type;
	long unsigned int pagemod_limit;
	__u64 change_attr;
	long unsigned int test_gen;
	long unsigned int flags;
	refcount_t refcount;
	spinlock_t lock;
	struct callback_head rcu;
};

struct nfs_mds_commit_info {
	atomic_t rpcs_out;
	atomic_long_t ncommit;
	struct list_head list;
};

struct pnfs_ds_commit_info {};

struct nfs_direct_req {
	struct kref kref;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct kiocb *iocb;
	struct inode *inode;
	atomic_t io_count;
	spinlock_t lock;
	loff_t io_start;
	ssize_t count;
	ssize_t max_count;
	ssize_t error;
	struct completion completion;
	struct nfs_mds_commit_info mds_cinfo;
	struct pnfs_ds_commit_info ds_cinfo;
	struct work_struct work;
	int flags;
};

struct nfs_entry {
	__u64 ino;
	__u64 cookie;
	const char *name;
	unsigned int len;
	int eof;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	unsigned char d_type;
	struct nfs_server *server;
};

struct nfsd_file;

struct nfs_file_localio {
	struct nfsd_file *ro_file;
	struct nfsd_file *rw_file;
	struct list_head list;
	void *nfs_uuid;
};

struct nfs_find_desc {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs_fs_context {
	bool internal;
	bool skip_reconfig_option_check;
	bool need_mount;
	bool sloppy;
	unsigned int flags;
	unsigned int rsize;
	unsigned int wsize;
	unsigned int timeo;
	unsigned int retrans;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namlen;
	unsigned int options;
	unsigned int bsize;
	struct nfs_auth_info auth_info;
	rpc_authflavor_t selected_flavor;
	struct xprtsec_parms xprtsec;
	char *client_address;
	unsigned int version;
	unsigned int minorversion;
	char *fscache_uniq;
	short unsigned int protofamily;
	short unsigned int mountfamily;
	bool has_sec_mnt_opts;
	int lock_status;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		u32 version;
		int port;
		short unsigned int protocol;
	} mount_server;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		char *export_path;
		int port;
		short unsigned int protocol;
		short unsigned int nconnect;
		short unsigned int max_connect;
		short unsigned int export_path_len;
	} nfs_server;
	struct nfs_fh *mntfh;
	struct nfs_server *server;
	struct nfs_subversion *nfs_mod;
	struct nfs_clone_mount clone_data;
};

struct nfs_fsinfo {
	struct nfs_fattr *fattr;
	__u32 rtmax;
	__u32 rtpref;
	__u32 rtmult;
	__u32 wtmax;
	__u32 wtpref;
	__u32 wtmult;
	__u32 dtpref;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	__u32 lease_time;
	__u32 nlayouttypes;
	__u32 layouttype[8];
	__u32 blksize;
	__u32 clone_blksize;
	enum nfs4_change_attr_type change_attr_type;
	__u32 xattr_support;
};

struct nfs_fsstat {
	struct nfs_fattr *fattr;
	__u64 tbytes;
	__u64 fbytes;
	__u64 abytes;
	__u64 tfiles;
	__u64 ffiles;
	__u64 afiles;
};

struct nfs_getaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_getaclres {
	struct nfs4_sequence_res seq_res;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	size_t acl_data_offset;
	int acl_flags;
	struct page *acl_scratch;
};

struct nfs_inode {
	__u64 fileid;
	struct nfs_fh fh;
	long unsigned int flags;
	long unsigned int cache_validity;
	long unsigned int read_cache_jiffies;
	long unsigned int attrtimeo;
	long unsigned int attrtimeo_timestamp;
	long unsigned int attr_gencount;
	struct rb_root access_cache;
	struct list_head access_cache_entry_lru;
	struct list_head access_cache_inode_lru;
	union {
		struct {
			long unsigned int cache_change_attribute;
			__be32 cookieverf[2];
			struct rw_semaphore rmdir_sem;
		};
		struct {
			atomic_long_t nrequests;
			atomic_long_t redirtied_pages;
			struct nfs_mds_commit_info commit_info;
			struct mutex commit_mutex;
		};
	};
	struct list_head open_files;
	struct {
		int cnt;
		struct {
			u64 start;
			u64 end;
		} gap[16];
	} *ooo;
	struct nfs4_cached_acl *nfs4_acl;
	struct list_head open_states;
	struct nfs_delegation *delegation;
	struct rw_semaphore rwsem;
	struct pnfs_layout_hdr *layout;
	__u64 write_io;
	__u64 read_io;
	union {
		struct inode vfs_inode;
	};
};

struct nfs_io_completion {
	void (*complete)(void *);
	void *data;
	struct kref refcount;
};

struct nfs_iostats {
	long long unsigned int bytes[8];
	long unsigned int events[27];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nfs_lock_context {
	refcount_t count;
	struct list_head list;
	struct nfs_open_context *open_context;
	fl_owner_t lockowner;
	atomic_t io_count;
	struct callback_head callback_head;
};

struct nfs_lockt_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_lowner lock_owner;
};

struct nfs_lockt_res {
	struct nfs4_sequence_res seq_res;
	struct file_lock *denied;
};

struct nfs_mount_data {
	int version;
	int fd;
	struct nfs2_fh old_root;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct sockaddr_in addr;
	char hostname[256];
	int namlen;
	unsigned int bsize;
	struct nfs3_fh root;
	int pseudoflavor;
	char context[257];
};

struct nfs_mount_request {
	struct __kernel_sockaddr_storage *sap;
	size_t salen;
	char *hostname;
	char *dirpath;
	u32 version;
	short unsigned int protocol;
	struct nfs_fh *fh;
	int noresvport;
	unsigned int *auth_flav_len;
	rpc_authflavor_t *auth_flavs;
	struct net *net;
};

struct rpc_program;

struct rpc_stat {
	const struct rpc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int netreconn;
	unsigned int rpccnt;
	unsigned int rpcretrans;
	unsigned int rpcauthrefresh;
	unsigned int rpcgarbage;
};

struct nfs_netns_client;

struct nfs_net {
	struct cache_detail *nfs_dns_resolve;
	struct rpc_pipe *bl_device_pipe;
	struct bl_dev_msg bl_mount_reply;
	wait_queue_head_t bl_wq;
	struct mutex bl_mutex;
	struct list_head nfs_client_list;
	struct list_head nfs_volume_list;
	struct idr cb_ident_idr;
	short unsigned int nfs_callback_tcpport;
	short unsigned int nfs_callback_tcpport6;
	int cb_users[1];
	struct nfs_netns_client *nfs_client;
	spinlock_t nfs_client_lock;
	ktime_t boot_time;
	struct rpc_stat rpcstats;
	struct proc_dir_entry *proc_nfsfs;
};

struct nfs_netns_client {
	struct kobject kobject;
	struct kobject nfs_net_kobj;
	struct net *net;
	const char *identifier;
};

struct nfs_open_context {
	struct nfs_lock_context lock_context;
	fl_owner_t flock_owner;
	struct dentry *dentry;
	const struct cred *cred;
	struct rpc_cred *ll_cred;
	struct nfs4_state *state;
	fmode_t mode;
	int error;
	long unsigned int flags;
	struct nfs4_threshold *mdsthreshold;
	struct list_head list;
	struct callback_head callback_head;
	struct nfs_file_localio nfl;
};

struct nfs_open_dir_context {
	struct list_head list;
	atomic_t cache_hits;
	atomic_t cache_misses;
	long unsigned int attr_gencount;
	__be32 verf[2];
	__u64 dir_cookie;
	__u64 last_cookie;
	long unsigned int page_index;
	unsigned int dtsize;
	bool force_clear;
	bool eof;
	struct callback_head callback_head;
};

struct nfs_page {
	struct list_head wb_list;
	union {
		struct page *wb_page;
		struct folio *wb_folio;
	};
	struct nfs_lock_context *wb_lock_context;
	long unsigned int wb_index;
	unsigned int wb_offset;
	unsigned int wb_pgbase;
	unsigned int wb_bytes;
	struct kref wb_kref;
	long unsigned int wb_flags;
	struct nfs_write_verifier wb_verf;
	struct nfs_page *wb_this_page;
	struct nfs_page *wb_head;
	short unsigned int wb_nio;
};

struct nfs_page_array {
	struct page **pagevec;
	unsigned int npages;
	struct page *page_array[8];
};

struct nfs_page_iter_page {
	const struct nfs_page *req;
	size_t count;
};

struct nfs_pgio_mirror {
	struct list_head pg_list;
	long unsigned int pg_bytes_written;
	size_t pg_count;
	size_t pg_bsize;
	unsigned int pg_base;
	unsigned char pg_recoalesce: 1;
};

struct nfs_pageio_ops;

struct nfs_rw_ops;

struct nfs_pgio_completion_ops;

struct nfs_pageio_descriptor {
	struct inode *pg_inode;
	const struct nfs_pageio_ops *pg_ops;
	const struct nfs_rw_ops *pg_rw_ops;
	int pg_ioflags;
	int pg_error;
	const struct rpc_call_ops *pg_rpc_callops;
	const struct nfs_pgio_completion_ops *pg_completion_ops;
	struct pnfs_layout_segment *pg_lseg;
	struct nfs_io_completion *pg_io_completion;
	struct nfs_direct_req *pg_dreq;
	unsigned int pg_bsize;
	u32 pg_mirror_count;
	struct nfs_pgio_mirror *pg_mirrors;
	struct nfs_pgio_mirror pg_mirrors_static[1];
	struct nfs_pgio_mirror *pg_mirrors_dynamic;
	u32 pg_mirror_idx;
	short unsigned int pg_maxretrans;
	unsigned char pg_moreio: 1;
};

struct nfs_pageio_ops {
	void (*pg_init)(struct nfs_pageio_descriptor *, struct nfs_page *);
	size_t (*pg_test)(struct nfs_pageio_descriptor *, struct nfs_page *, struct nfs_page *);
	int (*pg_doio)(struct nfs_pageio_descriptor *);
	unsigned int (*pg_get_mirror_count)(struct nfs_pageio_descriptor *, struct nfs_page *);
	void (*pg_cleanup)(struct nfs_pageio_descriptor *);
	struct nfs_pgio_mirror * (*pg_get_mirror)(struct nfs_pageio_descriptor *, u32);
	u32 (*pg_set_mirror)(struct nfs_pageio_descriptor *, u32);
};

struct nfs_pathconf {
	struct nfs_fattr *fattr;
	__u32 max_link;
	__u32 max_namelen;
};

struct nfs_pgio_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct nfs_open_context *context;
	struct nfs_lock_context *lock_context;
	nfs4_stateid stateid;
	__u64 offset;
	__u32 count;
	unsigned int pgbase;
	struct page **pages;
	union {
		unsigned int replen;
		struct {
			const u32 *bitmask;
			u32 bitmask_store[3];
			enum nfs3_stable_how stable;
		};
	};
};

struct nfs_pgio_header;

struct nfs_pgio_completion_ops {
	void (*error_cleanup)(struct list_head *, int);
	void (*init_hdr)(struct nfs_pgio_header *);
	void (*completion)(struct nfs_pgio_header *);
	void (*reschedule_io)(struct nfs_pgio_header *);
};

struct nfs_pgio_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	__u64 count;
	__u32 op_status;
	union {
		struct {
			unsigned int replen;
			int eof;
			void *scratch;
		};
		struct {
			struct nfs_writeverf *verf;
			const struct nfs_server *server;
		};
	};
};

struct nfs_pgio_header {
	struct inode *inode;
	const struct cred *cred;
	struct list_head pages;
	struct nfs_page *req;
	struct nfs_writeverf verf;
	fmode_t rw_mode;
	struct pnfs_layout_segment *lseg;
	loff_t io_start;
	const struct rpc_call_ops *mds_ops;
	void (*release)(struct nfs_pgio_header *);
	const struct nfs_pgio_completion_ops *completion_ops;
	const struct nfs_rw_ops *rw_ops;
	struct nfs_io_completion *io_completion;
	struct nfs_direct_req *dreq;
	int pnfs_error;
	int error;
	unsigned int good_bytes;
	long unsigned int flags;
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct nfs_pgio_args args;
	struct nfs_pgio_res res;
	long unsigned int timestamp;
	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
	__u64 mds_offset;
	struct nfs_page_array page_array;
	struct nfs_client *ds_clp;
	u32 ds_commit_idx;
	u32 pgio_mirror_idx;
};

struct nfs_readdir_arg {
	struct dentry *dentry;
	const struct cred *cred;
	__be32 *verf;
	u64 cookie;
	struct page **pages;
	unsigned int page_len;
	bool plus;
};

struct nfs_readdir_descriptor {
	struct file *file;
	struct folio *folio;
	struct dir_context *ctx;
	long unsigned int folio_index;
	long unsigned int folio_index_max;
	u64 dir_cookie;
	u64 last_cookie;
	loff_t current_index;
	__be32 verf[2];
	long unsigned int dir_verifier;
	long unsigned int timestamp;
	long unsigned int gencount;
	long unsigned int attr_gencount;
	unsigned int cache_entry_index;
	unsigned int buffer_fills;
	unsigned int dtsize;
	bool clear_cache;
	bool plus;
	bool eob;
	bool eof;
};

struct nfs_readdir_res {
	__be32 *verf;
};

struct nfs_referral_count {
	struct list_head list;
	const struct task_struct *task;
	unsigned int referral_count;
};

struct nfs_release_lockowner_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_lowner lock_owner;
};

struct nfs_release_lockowner_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs_release_lockowner_data {
	struct nfs4_lock_state *lsp;
	struct nfs_server *server;
	struct nfs_release_lockowner_args args;
	struct nfs_release_lockowner_res res;
	long unsigned int timestamp;
};

struct nfs_removeargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct qstr name;
};

struct nfs_removeres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs_fattr *dir_attr;
	struct nfs4_change_info cinfo;
};

struct nfs_renameargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *old_dir;
	const struct nfs_fh *new_dir;
	const struct qstr *old_name;
	const struct qstr *new_name;
};

struct nfs_renameres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs4_change_info old_cinfo;
	struct nfs_fattr *old_fattr;
	struct nfs4_change_info new_cinfo;
	struct nfs_fattr *new_fattr;
};

struct nfs_renamedata {
	struct nfs_renameargs args;
	struct nfs_renameres res;
	struct rpc_task task;
	const struct cred *cred;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct nfs_fattr old_fattr;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct nfs_fattr new_fattr;
	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
	long int timeout;
	bool cancelled;
};

struct nlmclnt_operations;

struct nfs_unlinkdata;

struct nfs_rpc_ops {
	u32 version;
	const struct dentry_operations *dentry_ops;
	const struct inode_operations *dir_inode_ops;
	const struct inode_operations *file_inode_ops;
	const struct file_operations *file_ops;
	const struct nlmclnt_operations *nlmclnt_ops;
	int (*getroot)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*submount)(struct fs_context *, struct nfs_server *);
	int (*try_get_tree)(struct fs_context *);
	int (*getattr)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, struct inode *);
	int (*setattr)(struct dentry *, struct nfs_fattr *, struct iattr *);
	int (*lookup)(struct inode *, struct dentry *, const struct qstr *, struct nfs_fh *, struct nfs_fattr *);
	int (*lookupp)(struct inode *, struct nfs_fh *, struct nfs_fattr *);
	int (*access)(struct inode *, struct nfs_access_entry *, const struct cred *);
	int (*readlink)(struct inode *, struct page *, unsigned int, unsigned int);
	int (*create)(struct inode *, struct dentry *, struct iattr *, int);
	int (*remove)(struct inode *, struct dentry *);
	void (*unlink_setup)(struct rpc_message *, struct dentry *, struct inode *);
	void (*unlink_rpc_prepare)(struct rpc_task *, struct nfs_unlinkdata *);
	int (*unlink_done)(struct rpc_task *, struct inode *);
	void (*rename_setup)(struct rpc_message *, struct dentry *, struct dentry *);
	void (*rename_rpc_prepare)(struct rpc_task *, struct nfs_renamedata *);
	int (*rename_done)(struct rpc_task *, struct inode *, struct inode *);
	int (*link)(struct inode *, struct inode *, const struct qstr *);
	int (*symlink)(struct inode *, struct dentry *, struct folio *, unsigned int, struct iattr *);
	int (*mkdir)(struct inode *, struct dentry *, struct iattr *);
	int (*rmdir)(struct inode *, const struct qstr *);
	int (*readdir)(struct nfs_readdir_arg *, struct nfs_readdir_res *);
	int (*mknod)(struct inode *, struct dentry *, struct iattr *, dev_t);
	int (*statfs)(struct nfs_server *, struct nfs_fh *, struct nfs_fsstat *);
	int (*fsinfo)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*pathconf)(struct nfs_server *, struct nfs_fh *, struct nfs_pathconf *);
	int (*set_capabilities)(struct nfs_server *, struct nfs_fh *);
	int (*decode_dirent)(struct xdr_stream *, struct nfs_entry *, bool);
	int (*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_header *);
	void (*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
	int (*read_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*write_setup)(struct nfs_pgio_header *, struct rpc_message *, struct rpc_clnt **);
	int (*write_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*commit_setup)(struct nfs_commit_data *, struct rpc_message *, struct rpc_clnt **);
	void (*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
	int (*commit_done)(struct rpc_task *, struct nfs_commit_data *);
	int (*lock)(struct file *, int, struct file_lock *);
	int (*lock_check_bounds)(const struct file_lock *);
	void (*clear_acl_cache)(struct inode *);
	void (*close_context)(struct nfs_open_context *, int);
	struct inode * (*open_context)(struct inode *, struct nfs_open_context *, int, struct iattr *, int *);
	int (*have_delegation)(struct inode *, fmode_t, int);
	int (*return_delegation)(struct inode *);
	struct nfs_client * (*alloc_client)(const struct nfs_client_initdata *);
	struct nfs_client * (*init_client)(struct nfs_client *, const struct nfs_client_initdata *);
	void (*free_client)(struct nfs_client *);
	struct nfs_server * (*create_server)(struct fs_context *);
	struct nfs_server * (*clone_server)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, rpc_authflavor_t);
	int (*discover_trunking)(struct nfs_server *, struct nfs_fh *);
	void (*enable_swap)(struct inode *);
	void (*disable_swap)(struct inode *);
};

struct rpc_task_setup;

struct nfs_rw_ops {
	struct nfs_pgio_header * (*rw_alloc_header)(void);
	void (*rw_free_header)(struct nfs_pgio_header *);
	int (*rw_done)(struct rpc_task *, struct nfs_pgio_header *, struct inode *);
	void (*rw_result)(struct rpc_task *, struct nfs_pgio_header *);
	void (*rw_initiate)(struct nfs_pgio_header *, struct rpc_message *, const struct nfs_rpc_ops *, struct rpc_task_setup *, int);
};

struct nfs_seqid {
	struct nfs_seqid_counter *sequence;
	struct list_head list;
	struct rpc_task *task;
};

struct pnfs_layoutdriver_type;

struct nlm_host;

struct nfs_server {
	struct nfs_client *nfs_client;
	struct list_head client_link;
	struct list_head master_link;
	struct rpc_clnt *client;
	struct rpc_clnt *client_acl;
	struct nlm_host *nlm_host;
	struct nfs_iostats *io_stats;
	wait_queue_head_t write_congestion_wait;
	atomic_long_t writeback;
	unsigned int write_congested;
	unsigned int flags;
	unsigned int fattr_valid;
	unsigned int caps;
	unsigned int rsize;
	unsigned int rpages;
	unsigned int wsize;
	unsigned int wpages;
	unsigned int wtmult;
	unsigned int dtsize;
	short unsigned int port;
	unsigned int bsize;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namelen;
	unsigned int options;
	unsigned int clone_blksize;
	enum nfs4_change_attr_type change_attr_type;
	struct nfs_fsid fsid;
	int s_sysfs_id;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	long unsigned int mount_time;
	struct super_block *super;
	dev_t s_dev;
	struct nfs_auth_info auth_info;
	u32 pnfs_blksize;
	u32 attr_bitmask[3];
	u32 attr_bitmask_nl[3];
	u32 exclcreat_bitmask[3];
	u32 cache_consistency_bitmask[3];
	u32 acl_bitmask;
	u32 fh_expire_type;
	struct pnfs_layoutdriver_type *pnfs_curr_ld;
	struct rpc_wait_queue roc_rpcwaitq;
	void *pnfs_ld_data;
	struct rb_root state_owners;
	atomic64_t owner_ctr;
	struct list_head state_owners_lru;
	struct list_head layouts;
	struct list_head delegations;
	struct list_head ss_copies;
	struct list_head ss_src_copies;
	long unsigned int delegation_flags;
	long unsigned int delegation_gen;
	long unsigned int mig_gen;
	long unsigned int mig_status;
	void (*destroy)(struct nfs_server *);
	atomic_t active;
	struct __kernel_sockaddr_storage mountd_address;
	size_t mountd_addrlen;
	u32 mountd_version;
	short unsigned int mountd_port;
	short unsigned int mountd_protocol;
	struct rpc_wait_queue uoc_rpcwaitq;
	unsigned int read_hdrsize;
	const struct cred *cred;
	bool has_sec_mnt_opts;
	struct kobject kobj;
	struct callback_head rcu;
};

struct nfs_setaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_setaclres {
	struct nfs4_sequence_res seq_res;
};

struct nfs_setattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct iattr *iap;
	const struct nfs_server *server;
	const u32 *bitmask;
	const struct nfs4_label *label;
};

struct nfs_setattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
};

struct rpc_version;

struct super_operations;

struct xattr_handler;

struct nfs_subversion {
	struct module *owner;
	struct file_system_type *nfs_fs;
	const struct rpc_version *rpc_vers;
	const struct nfs_rpc_ops *rpc_ops;
	const struct super_operations *sops;
	const struct xattr_handler * const *xattr;
};

struct nfs_unlinkdata {
	struct nfs_removeargs args;
	struct nfs_removeres res;
	struct dentry *dentry;
	wait_queue_head_t wq;
	const struct cred *cred;
	struct nfs_fattr dir_attr;
	long int timeout;
};

struct xdr_array2_desc;

typedef int (*xdr_xcode_elem_t)(struct xdr_array2_desc *, void *);

struct xdr_array2_desc {
	unsigned int elem_size;
	unsigned int array_len;
	unsigned int array_maxlen;
	xdr_xcode_elem_t xcode;
};

struct nfsacl_decode_desc {
	struct xdr_array2_desc desc;
	unsigned int count;
	struct posix_acl *acl;
};

struct nfsacl_encode_desc {
	struct xdr_array2_desc desc;
	unsigned int count;
	struct posix_acl *acl;
	int typeflag;
	kuid_t uid;
	kgid_t gid;
};

struct posix_acl_entry {
	short int e_tag;
	short unsigned int e_perm;
	union {
		kuid_t e_uid;
		kgid_t e_gid;
	};
};

struct posix_acl {
	refcount_t a_refcount;
	unsigned int a_count;
	struct callback_head a_rcu;
	struct posix_acl_entry a_entries[0];
};

struct nfsacl_simple_acl {
	struct posix_acl acl;
	struct posix_acl_entry ace[4];
};

struct nft_table;

struct nft_audit_data {
	struct nft_table *table;
	int entries;
	int op;
	struct list_head list;
};

struct nft_rule_blob;

struct nft_chain {
	struct nft_rule_blob *blob_gen_0;
	struct nft_rule_blob *blob_gen_1;
	struct list_head rules;
	struct list_head list;
	struct rhlist_head rhlhead;
	struct nft_table *table;
	u64 handle;
	u32 use;
	u8 flags: 5;
	u8 bound: 1;
	u8 genmask: 2;
	char *name;
	u16 udlen;
	u8 *udata;
	struct nft_rule_blob *blob_next;
};

struct nft_chain_type;

struct nft_stats;

struct nft_base_chain {
	struct nf_hook_ops ops;
	struct list_head hook_list;
	const struct nft_chain_type *type;
	u8 policy;
	u8 flags;
	struct nft_stats *stats;
	struct nft_chain chain;
	struct flow_block flow_block;
};

struct nft_bitmap {
	struct list_head list;
	u16 bitmap_size;
	u8 bitmap[0];
};

struct nft_elem_priv {};

struct nft_set_ext {
	u8 genmask;
	u8 offset[8];
	char data[0];
	long: 0;
};

struct nft_bitmap_elem {
	struct nft_elem_priv priv;
	struct list_head head;
	struct nft_set_ext ext;
};

struct nft_verdict {
	u32 code;
	struct nft_chain *chain;
};

struct nft_data {
	union {
		u32 data[4];
		struct nft_verdict verdict;
	};
};

struct nft_bitwise {
	u8 sreg;
	u8 sreg2;
	u8 dreg;
	enum nft_bitwise_ops op: 8;
	u8 len;
	struct nft_data mask;
	struct nft_data xor;
	struct nft_data data;
};

struct nft_bitwise_fast_expr {
	u32 mask;
	u32 xor;
	u8 sreg;
	u8 dreg;
};

struct nft_byteorder {
	u8 sreg;
	u8 dreg;
	enum nft_byteorder_ops op: 8;
	u8 len;
	u8 size;
};

struct nft_chain_hook {
	u32 num;
	s32 priority;
	const struct nft_chain_type *type;
	struct list_head list;
};

struct nft_chain_type {
	const char *name;
	enum nft_chain_types type;
	int family;
	struct module *owner;
	unsigned int hook_mask;
	nf_hookfn *hooks[6];
	int (*ops_register)(struct net *, const struct nf_hook_ops *);
	void (*ops_unregister)(struct net *, const struct nf_hook_ops *);
};

struct nft_cmp16_fast_expr {
	struct nft_data data;
	struct nft_data mask;
	u8 sreg;
	u8 len;
	bool inv;
};

struct nft_cmp_expr {
	struct nft_data data;
	u8 sreg;
	u8 len;
	enum nft_cmp_ops op: 8;
};

struct nft_cmp_fast_expr {
	u32 data;
	u32 mask;
	u8 sreg;
	u8 len;
	bool inv;
};

union nft_cmp_offload_data {
	u16 val16;
	u32 val32;
	u64 val64;
};

struct nft_connlimit {
	struct nf_conncount_list *list;
	u32 limit;
	bool invert;
};

struct nft_counter {
	u64_stats_t bytes;
	u64_stats_t packets;
};

struct nft_counter_percpu_priv {
	struct nft_counter *counter;
};

struct nft_counter_tot {
	s64 bytes;
	s64 packets;
};

struct nft_ct {
	enum nft_ct_keys key: 8;
	enum ip_conntrack_dir dir: 8;
	u8 len;
	union {
		u8 dreg;
		u8 sreg;
	};
};

struct nft_ct_expect_obj {
	u16 l3num;
	__be16 dport;
	u8 l4proto;
	u8 size;
	u32 timeout;
};

struct nft_ct_frag6_pernet {
	struct ctl_table_header *nf_frag_frags_hdr;
	struct fqdir *fqdir;
};

struct nft_ct_helper_obj {
	struct nf_conntrack_helper *helper4;
	struct nf_conntrack_helper *helper6;
	u8 l4proto;
};

struct nft_ct_timeout_obj {
	struct nf_ct_timeout *timeout;
	u8 l4proto;
};

struct nft_ctx {
	struct net *net;
	struct nft_table *table;
	struct nft_chain *chain;
	const struct nlattr * const *nla;
	u32 portid;
	u32 seq;
	u16 flags;
	u8 family;
	u8 level;
	bool report;
	long unsigned int reg_inited[1];
};

struct nft_data_desc {
	enum nft_data_types type;
	unsigned int size;
	unsigned int len;
	unsigned int flags;
};

struct nft_dup_ipv4 {
	u8 sreg_addr;
	u8 sreg_dev;
};

struct nft_dup_ipv6 {
	u8 sreg_addr;
	u8 sreg_dev;
};

struct nft_dup_netdev {
	u8 sreg_dev;
};

struct nft_set_ext_tmpl {
	u16 len;
	u8 offset[8];
	u8 ext_len[8];
};

struct nft_set_binding {
	struct list_head list;
	const struct nft_chain *chain;
	u32 flags;
};

struct nft_set;

struct nft_expr;

struct nft_dynset {
	struct nft_set *set;
	struct nft_set_ext_tmpl tmpl;
	enum nft_dynset_ops op: 8;
	u8 sreg_key;
	u8 sreg_data;
	bool invert;
	bool expr;
	u8 num_exprs;
	u64 timeout;
	struct nft_expr *expr_array[2];
	struct nft_set_binding binding;
};

struct nft_elem_update {
	u64 timeout;
	u64 expiration;
	u8 flags;
};

union nft_entry {
	struct ipt_entry e4;
	struct ip6t_entry e6;
	struct ebt_entry ebt;
	struct arpt_entry arp;
};

struct nft_expr {
	const struct nft_expr_ops *ops;
	unsigned char data[0];
};

struct nft_expr_info {
	const struct nft_expr_ops *ops;
	const struct nlattr *attr;
	struct nlattr *tb[17];
};

struct nft_regs;

struct nft_pktinfo;

struct nft_regs_track;

struct nft_offload_ctx;

struct nft_flow_rule;

struct nft_expr_type;

struct nft_expr_ops {
	void (*eval)(const struct nft_expr *, struct nft_regs *, const struct nft_pktinfo *);
	int (*clone)(struct nft_expr *, const struct nft_expr *, gfp_t);
	unsigned int size;
	int (*init)(const struct nft_ctx *, const struct nft_expr *, const struct nlattr * const *);
	void (*activate)(const struct nft_ctx *, const struct nft_expr *);
	void (*deactivate)(const struct nft_ctx *, const struct nft_expr *, enum nft_trans_phase);
	void (*destroy)(const struct nft_ctx *, const struct nft_expr *);
	void (*destroy_clone)(const struct nft_ctx *, const struct nft_expr *);
	int (*dump)(struct sk_buff *, const struct nft_expr *, bool);
	int (*validate)(const struct nft_ctx *, const struct nft_expr *);
	bool (*reduce)(struct nft_regs_track *, const struct nft_expr *);
	bool (*gc)(struct net *, const struct nft_expr *);
	int (*offload)(struct nft_offload_ctx *, struct nft_flow_rule *, const struct nft_expr *);
	bool (*offload_action)(const struct nft_expr *);
	void (*offload_stats)(struct nft_expr *, const struct flow_stats *);
	const struct nft_expr_type *type;
	void *data;
};

struct nft_expr_type {
	const struct nft_expr_ops * (*select_ops)(const struct nft_ctx *, const struct nlattr * const *);
	void (*release_ops)(const struct nft_expr_ops *);
	const struct nft_expr_ops *ops;
	const struct nft_expr_ops *inner_ops;
	struct list_head list;
	const char *name;
	struct module *owner;
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 family;
	u8 flags;
};

struct nft_exthdr {
	u8 type;
	u8 offset;
	u8 len;
	u8 op;
	u8 dreg;
	u8 sreg;
	u8 flags;
};

struct nft_fib {
	u8 dreg;
	u8 result;
	u32 flags;
};

struct nft_flow_key {
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_control control;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
	struct flow_dissector_key_meta meta;
};

struct nft_flow_match {
	struct flow_dissector dissector;
	struct nft_flow_key key;
	struct nft_flow_key mask;
};

struct nft_flow_rule {
	__be16 proto;
	struct nft_flow_match match;
	struct flow_rule *rule;
};

struct nft_flowtable {
	struct list_head list;
	struct nft_table *table;
	char *name;
	int hooknum;
	int ops_len;
	u32 genmask: 2;
	u32 use;
	u64 handle;
	long: 64;
	struct list_head hook_list;
	struct nf_flowtable data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nft_flowtable_filter {
	char *table;
};

struct nft_flowtable_hook {
	u32 num;
	int priority;
	struct list_head list;
};

struct nft_fwd_neigh {
	u8 sreg_dev;
	u8 sreg_addr;
	u8 nfproto;
};

struct nft_fwd_netdev {
	u8 sreg_dev;
};

struct nft_hash {
	u32 seed;
	u32 buckets;
	struct hlist_head table[0];
};

struct nft_hash_elem {
	struct nft_elem_priv priv;
	struct hlist_node node;
	struct nft_set_ext ext;
};

struct nft_hook {
	struct list_head list;
	struct nf_hook_ops ops;
	struct callback_head rcu;
	char ifname[16];
	u8 ifnamelen;
};

struct nft_immediate_expr {
	struct nft_data data;
	u8 dreg;
	u8 dlen;
};

struct nft_inner {
	u8 flags;
	u8 hdrsize;
	u8 type;
	u8 expr_type;
	struct __nft_expr expr;
};

struct nft_inner_tun_ctx {
	long unsigned int cookie;
	u16 type;
	u16 inner_tunoff;
	u16 inner_lloff;
	u16 inner_nhoff;
	u16 inner_thoff;
	__be16 llproto;
	u8 l4proto;
	u8 flags;
};

struct nft_jhash {
	u8 sreg;
	u8 dreg;
	u8 len;
	bool autogen_seed: 1;
	u32 modulus;
	u32 seed;
	u32 offset;
};

struct nft_rule_dp;

struct nft_jumpstack {
	const struct nft_rule_dp *rule;
};

struct nft_last {
	long unsigned int jiffies;
	unsigned int set;
};

struct nft_last_priv {
	struct nft_last *last;
};

struct nft_limit {
	spinlock_t lock;
	u64 last;
	u64 tokens;
};

struct nft_limit_priv {
	struct nft_limit *limit;
	u64 tokens_max;
	u64 rate;
	u64 nsecs;
	u32 burst;
	bool invert;
};

struct nft_limit_priv_pkts {
	struct nft_limit_priv limit;
	u64 cost;
};

struct nft_log {
	struct nf_loginfo loginfo;
	char *prefix;
};

struct nft_lookup {
	struct nft_set *set;
	u8 sreg;
	u8 dreg;
	bool dreg_set;
	bool invert;
	struct nft_set_binding binding;
};

struct nft_masq {
	u32 flags;
	u8 sreg_proto_min;
	u8 sreg_proto_max;
};

struct nft_module_request {
	struct list_head list;
	char module[56];
	bool done;
};

struct nft_nat {
	u8 sreg_addr_min;
	u8 sreg_addr_max;
	u8 sreg_proto_min;
	u8 sreg_proto_max;
	enum nf_nat_manip_type type: 8;
	u8 family;
	u16 flags;
};

struct nft_ng_inc {
	u8 dreg;
	u32 modulus;
	atomic_t *counter;
	u32 offset;
};

struct nft_ng_random {
	u8 dreg;
	u32 modulus;
	u32 offset;
};

struct nft_obj_dump_ctx {
	unsigned int s_idx;
	char *table;
	u32 type;
	bool reset;
};

struct nft_object_hash_key {
	const char *name;
	const struct nft_table *table;
};

struct nft_object_ops;

struct nft_object {
	struct list_head list;
	struct rhlist_head rhlhead;
	struct nft_object_hash_key key;
	u32 genmask: 2;
	u32 use;
	u64 handle;
	u16 udlen;
	u8 *udata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	const struct nft_object_ops *ops;
	unsigned char data[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct nft_object_type;

struct nft_object_ops {
	void (*eval)(struct nft_object *, struct nft_regs *, const struct nft_pktinfo *);
	unsigned int size;
	int (*init)(const struct nft_ctx *, const struct nlattr * const *, struct nft_object *);
	void (*destroy)(const struct nft_ctx *, struct nft_object *);
	int (*dump)(struct sk_buff *, struct nft_object *, bool);
	void (*update)(struct nft_object *, struct nft_object *);
	const struct nft_object_type *type;
};

struct nft_object_type {
	const struct nft_object_ops * (*select_ops)(const struct nft_ctx *, const struct nlattr * const *);
	const struct nft_object_ops *ops;
	struct list_head list;
	u32 type;
	unsigned int maxattr;
	u8 family;
	struct module *owner;
	const struct nla_policy *policy;
};

struct nft_objref_map {
	struct nft_set *set;
	u8 sreg;
	struct nft_set_binding binding;
};

struct nft_offload_reg {
	u32 key;
	u32 len;
	u32 base_offset;
	u32 offset;
	u32 flags;
	struct nft_data data;
	struct nft_data mask;
};

struct nft_offload_ctx {
	struct {
		enum nft_offload_dep_type type;
		__be16 l3num;
		u8 protonum;
	} dep;
	unsigned int num_actions;
	struct net *net;
	struct nft_offload_reg regs[24];
};

struct nft_offload_ethertype {
	__be16 value;
	__be16 mask;
};

struct nft_osf {
	u8 dreg;
	u8 ttl;
	u32 flags;
};

struct nft_payload_set {
	enum nft_payload_bases base: 8;
	u8 offset;
	u8 len;
	u8 sreg;
	u8 csum_type;
	u8 csum_offset;
	u8 csum_flags;
};

struct nft_payload_vlan_hdr {
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
};

struct nft_pipapo_match;

struct nft_pipapo {
	struct nft_pipapo_match *match;
	struct nft_pipapo_match *clone;
	int width;
	long unsigned int last_gc;
};

struct nft_pipapo_elem {
	struct nft_elem_priv priv;
	struct nft_set_ext ext;
};

union nft_pipapo_map_bucket;

struct nft_pipapo_field {
	unsigned int rules;
	unsigned int bsize;
	unsigned int rules_alloc;
	u8 groups;
	u8 bb;
	long unsigned int *lt;
	union nft_pipapo_map_bucket *mt;
};

union nft_pipapo_map_bucket {
	struct {
		u32 to;
		u32 n;
	};
	struct nft_pipapo_elem *e;
};

struct nft_pipapo_scratch;

struct nft_pipapo_match {
	u8 field_count;
	unsigned int bsize_max;
	struct nft_pipapo_scratch **scratch;
	struct callback_head rcu;
	struct nft_pipapo_field f[0];
};

struct nft_pipapo_scratch {
	u8 map_index;
	u32 align_off;
	long unsigned int map[0];
};

struct nft_pktinfo {
	struct sk_buff *skb;
	const struct nf_hook_state *state;
	u8 flags;
	u8 tprot;
	u16 fragoff;
	u16 thoff;
	u16 inneroff;
};

struct nft_queue {
	u8 sreg_qnum;
	u16 queuenum;
	u16 queues_total;
	u16 flags;
};

struct nft_quota {
	atomic64_t quota;
	long unsigned int flags;
	atomic64_t *consumed;
};

struct nft_range_expr {
	struct nft_data data_from;
	struct nft_data data_to;
	u8 sreg;
	u8 len;
	enum nft_range_ops op: 8;
};

struct seqcount_rwlock {
	seqcount_t seqcount;
};

typedef struct seqcount_rwlock seqcount_rwlock_t;

struct nft_rbtree {
	struct rb_root root;
	rwlock_t lock;
	seqcount_rwlock_t count;
	long unsigned int last_gc;
};

struct nft_rbtree_elem {
	struct nft_elem_priv priv;
	struct rb_node node;
	struct nft_set_ext ext;
};

struct nft_redir {
	u8 sreg_proto_min;
	u8 sreg_proto_max;
	u16 flags;
};

struct nft_regs {
	union {
		u32 data[20];
		struct nft_verdict verdict;
	};
};

struct nft_regs_track {
	struct {
		const struct nft_expr *selector;
		const struct nft_expr *bitwise;
		u8 num_reg;
	} regs[20];
	const struct nft_expr *cur;
	const struct nft_expr *last;
};

struct nft_reject {
	enum nft_reject_types type: 8;
	u8 icmp_code;
};

struct nft_rhash {
	struct rhashtable ht;
	struct delayed_work gc_work;
	u32 wq_gc_seq;
};

struct nft_rhash_cmp_arg {
	const struct nft_set *set;
	const u32 *key;
	u8 genmask;
	u64 tstamp;
};

struct nft_rhash_ctx {
	const struct nft_ctx ctx;
	const struct nft_set *set;
};

struct nft_rhash_elem {
	struct nft_elem_priv priv;
	struct rhash_head node;
	u32 wq_gc_seq;
	long: 0;
	struct nft_set_ext ext;
};

struct nft_rt {
	enum nft_rt_keys key: 8;
	u8 dreg;
};

struct nft_rule {
	struct list_head list;
	u64 handle: 42;
	u64 genmask: 2;
	u64 dlen: 12;
	u64 udata: 1;
	unsigned char data[0];
};

struct nft_rule_blob {
	long unsigned int size;
	unsigned char data[0];
};

struct nft_rule_dp {
	u64 is_last: 1;
	u64 dlen: 12;
	u64 handle: 42;
	long: 0;
	unsigned char data[0];
};

struct nft_rule_dp_last {
	struct nft_rule_dp end;
	struct callback_head h;
	struct nft_rule_blob *blob;
	const struct nft_chain *chain;
};

struct nft_rule_dump_ctx {
	unsigned int s_idx;
	char *table;
	char *chain;
	bool reset;
};

struct nft_secmark {
	u32 secid;
	char *ctx;
};

struct nft_set_ops;

struct nft_set {
	struct list_head list;
	struct list_head bindings;
	refcount_t refs;
	struct nft_table *table;
	possible_net_t net;
	char *name;
	u64 handle;
	u32 ktype;
	u32 dtype;
	u32 objtype;
	u32 size;
	u8 field_len[16];
	u8 field_count;
	u32 use;
	atomic_t nelems;
	u32 ndeact;
	u64 timeout;
	u32 gc_int;
	u16 policy;
	u16 udlen;
	unsigned char *udata;
	struct list_head pending_update;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	const struct nft_set_ops *ops;
	u16 flags: 13;
	u16 dead: 1;
	u16 genmask: 2;
	u8 klen;
	u8 dlen;
	u8 num_exprs;
	struct nft_expr *exprs[2];
	struct list_head catchall_list;
	unsigned char data[0];
	long: 64;
	long: 64;
};

struct nft_set_desc {
	u32 ktype;
	unsigned int klen;
	u32 dtype;
	unsigned int dlen;
	u32 objtype;
	unsigned int size;
	u32 policy;
	u32 gc_int;
	u64 timeout;
	u8 field_len[16];
	u8 field_count;
	bool expr;
};

struct nft_set_iter {
	u8 genmask;
	enum nft_iter_type type: 8;
	unsigned int count;
	unsigned int skip;
	int err;
	int (*fn)(const struct nft_ctx *, struct nft_set *, const struct nft_set_iter *, struct nft_elem_priv *);
};

struct nft_set_dump_args {
	const struct netlink_callback *cb;
	struct nft_set_iter iter;
	struct sk_buff *skb;
	bool reset;
};

struct nft_set_dump_ctx {
	const struct nft_set *set;
	struct nft_ctx ctx;
	bool reset;
};

struct nft_set_elem {
	union {
		u32 buf[16];
		struct nft_data val;
	} key;
	union {
		u32 buf[16];
		struct nft_data val;
	} key_end;
	union {
		u32 buf[16];
		struct nft_data val;
	} data;
	struct nft_elem_priv *priv;
};

struct nft_set_elem_catchall {
	struct list_head list;
	struct callback_head rcu;
	struct nft_elem_priv *elem;
};

struct nft_set_elem_expr {
	u8 size;
	long: 0;
	unsigned char data[0];
};

struct nft_set_estimate {
	u64 size;
	enum nft_set_class lookup;
	enum nft_set_class space;
};

struct nft_set_ext_type {
	u8 len;
	u8 align;
};

struct nft_set_ops {
	bool (*lookup)(const struct net *, const struct nft_set *, const u32 *, const struct nft_set_ext **);
	bool (*update)(struct nft_set *, const u32 *, struct nft_elem_priv * (*)(struct nft_set *, const struct nft_expr *, struct nft_regs *), const struct nft_expr *, struct nft_regs *, const struct nft_set_ext **);
	bool (*delete)(const struct nft_set *, const u32 *);
	int (*insert)(const struct net *, const struct nft_set *, const struct nft_set_elem *, struct nft_elem_priv **);
	void (*activate)(const struct net *, const struct nft_set *, struct nft_elem_priv *);
	struct nft_elem_priv * (*deactivate)(const struct net *, const struct nft_set *, const struct nft_set_elem *);
	void (*flush)(const struct net *, const struct nft_set *, struct nft_elem_priv *);
	void (*remove)(const struct net *, const struct nft_set *, struct nft_elem_priv *);
	void (*walk)(const struct nft_ctx *, struct nft_set *, struct nft_set_iter *);
	struct nft_elem_priv * (*get)(const struct net *, const struct nft_set *, const struct nft_set_elem *, unsigned int);
	u32 (*ksize)(u32);
	u32 (*usize)(u32);
	u32 (*adjust_maxsize)(const struct nft_set *);
	void (*commit)(struct nft_set *);
	void (*abort)(const struct nft_set *);
	u64 (*privsize)(const struct nlattr * const *, const struct nft_set_desc *);
	bool (*estimate)(const struct nft_set_desc *, u32, struct nft_set_estimate *);
	int (*init)(const struct nft_set *, const struct nft_set_desc *, const struct nlattr * const *);
	void (*destroy)(const struct nft_ctx *, const struct nft_set *);
	void (*gc_init)(const struct nft_set *);
	unsigned int elemsize;
};

struct nft_set_type {
	const struct nft_set_ops ops;
	u32 features;
};

struct nft_socket {
	enum nft_socket_keys key: 8;
	u8 level;
	u8 level_user;
	u8 len;
	union {
		u8 dreg;
	};
};

struct nft_stats {
	u64 bytes;
	u64 pkts;
	struct u64_stats_sync syncp;
};

struct nft_symhash {
	u8 dreg;
	u32 modulus;
	u32 offset;
};

struct nft_synproxy {
	struct nf_synproxy_info info;
};

struct nft_table {
	struct list_head list;
	struct rhltable chains_ht;
	struct list_head chains;
	struct list_head sets;
	struct list_head objects;
	struct list_head flowtables;
	u64 hgenerator;
	u64 handle;
	u32 use;
	u16 family: 6;
	u16 flags: 8;
	u16 genmask: 2;
	u32 nlpid;
	char *name;
	u16 udlen;
	u8 *udata;
	u8 validate_state;
};

struct nft_timeout {
	u64 timeout;
	u64 expiration;
};

struct nft_tproxy {
	u8 sreg_addr;
	u8 sreg_port;
	u8 family;
};

struct nft_traceinfo {
	bool trace;
	bool nf_trace;
	bool packet_dumped;
	enum nft_trace_types type: 8;
	u32 skbid;
	const struct nft_base_chain *basechain;
};

struct nft_trans {
	struct list_head list;
	struct net *net;
	struct nft_table *table;
	int msg_type;
	u32 seq;
	u16 flags;
	u8 report: 1;
	u8 put_net: 1;
};

struct nft_trans_binding {
	struct nft_trans nft_trans;
	struct list_head binding_list;
};

struct nft_trans_chain {
	struct nft_trans_binding nft_trans_binding;
	struct nft_chain *chain;
	char *name;
	struct nft_stats *stats;
	u8 policy;
	bool update;
	bool bound;
	u32 chain_id;
	struct nft_base_chain *basechain;
	struct list_head hook_list;
};

struct nft_trans_one_elem {
	struct nft_elem_priv *priv;
	struct nft_elem_update *update;
};

struct nft_trans_elem {
	struct nft_trans nft_trans;
	struct nft_set *set;
	bool bound;
	unsigned int nelems;
	struct nft_trans_one_elem elems[0];
};

struct nft_trans_flowtable {
	struct nft_trans nft_trans;
	struct nft_flowtable *flowtable;
	struct list_head hook_list;
	u32 flags;
	bool update;
};

struct nft_trans_gc {
	struct list_head list;
	struct net *net;
	struct nft_set *set;
	u32 seq;
	u16 count;
	struct nft_elem_priv *priv[256];
	struct callback_head rcu;
};

struct nft_trans_obj {
	struct nft_trans nft_trans;
	struct nft_object *obj;
	struct nft_object *newobj;
	bool update;
};

struct nft_trans_rule {
	struct nft_trans nft_trans;
	struct nft_rule *rule;
	struct nft_chain *chain;
	struct nft_flow_rule *flow;
	u32 rule_id;
	bool bound;
};

struct nft_trans_set {
	struct nft_trans_binding nft_trans_binding;
	struct list_head list_trans_newset;
	struct nft_set *set;
	u32 set_id;
	u32 gc_int;
	u64 timeout;
	bool update;
	bool bound;
	u32 size;
};

struct nft_trans_table {
	struct nft_trans nft_trans;
	bool update;
};

struct nft_tunnel {
	enum nft_tunnel_keys key: 8;
	u8 dreg;
	enum nft_tunnel_mode mode: 8;
	u8 len;
};

struct vxlan_metadata {
	u32 gbp;
};

struct nft_tunnel_opts {
	union {
		struct vxlan_metadata vxlan;
		struct erspan_metadata erspan;
		u8 data[255];
	} u;
	long unsigned int flags[1];
	u32 len;
};

struct nft_tunnel_obj {
	struct metadata_dst *md;
	struct nft_tunnel_opts opts;
};

struct nft_userdata {
	u8 len;
	unsigned char data[0];
};

struct nft_xfrm {
	enum nft_xfrm_keys key: 8;
	u8 dreg;
	u8 dir;
	u8 spnum;
	u8 len;
};

struct nft_xt_match_priv {
	void *info;
};

struct nftables_pernet {
	struct list_head tables;
	struct list_head commit_list;
	struct list_head destroy_list;
	struct list_head commit_set_list;
	struct list_head binding_list;
	struct list_head module_list;
	struct list_head notify_list;
	struct mutex commit_mutex;
	u64 table_handle;
	u64 tstamp;
	unsigned int base_seq;
	unsigned int gc_seq;
	u8 validate_state;
	struct work_struct destroy_work;
};

struct nftnl_skb_parms {
	bool report;
};

struct nfulnl_instance {
	struct hlist_node hlist;
	spinlock_t lock;
	refcount_t use;
	unsigned int qlen;
	struct sk_buff *skb;
	struct timer_list timer;
	struct net *net;
	netns_tracker ns_tracker;
	struct user_namespace *peer_user_ns;
	u32 peer_portid;
	unsigned int flushtimeout;
	unsigned int nlbufsiz;
	unsigned int qthreshold;
	u_int32_t copy_range;
	u_int32_t seq;
	u_int16_t group_num;
	u_int16_t flags;
	u_int8_t copy_mode;
	struct callback_head rcu;
};

struct nfulnl_msg_config_cmd {
	__u8 command;
};

struct nfulnl_msg_config_mode {
	__be32 copy_range;
	__u8 copy_mode;
	__u8 _pad;
} __attribute__((packed));

struct nfulnl_msg_packet_hdr {
	__be16 hw_protocol;
	__u8 hook;
	__u8 _pad;
};

struct nfulnl_msg_packet_hw {
	__be16 hw_addrlen;
	__u16 _pad;
	__u8 hw_addr[8];
};

struct nfulnl_msg_packet_timestamp {
	__be64 sec;
	__be64 usec;
};

struct nh_config {
	u32 nh_id;
	u8 nh_family;
	u8 nh_protocol;
	u8 nh_blackhole;
	u8 nh_fdb;
	u32 nh_flags;
	int nh_ifindex;
	struct net_device *dev;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} gw;
	struct nlattr *nh_grp;
	u16 nh_grp_type;
	u16 nh_grp_res_num_buckets;
	long unsigned int nh_grp_res_idle_timer;
	long unsigned int nh_grp_res_unbalanced_timer;
	bool nh_grp_res_has_num_buckets;
	bool nh_grp_res_has_idle_timer;
	bool nh_grp_res_has_unbalanced_timer;
	bool nh_hw_stats;
	struct nlattr *nh_encap;
	u16 nh_encap_type;
	u32 nlflags;
	struct nl_info nlinfo;
};

struct nh_dump_filter {
	u32 nh_id;
	int dev_idx;
	int master_idx;
	bool group_filter;
	bool fdb_filter;
	u32 res_bucket_nh_id;
	u32 op_flags;
};

struct nh_grp_entry_stats;

struct nh_grp_entry {
	struct nexthop *nh;
	struct nh_grp_entry_stats *stats;
	u16 weight;
	union {
		struct {
			atomic_t upper_bound;
		} hthr;
		struct {
			struct list_head uw_nh_entry;
			u16 count_buckets;
			u16 wants_buckets;
		} res;
	};
	struct list_head nh_list;
	struct nexthop *nh_parent;
	u64 packets_hw;
};

struct nh_res_table;

struct nh_group {
	struct nh_group *spare;
	u16 num_nh;
	bool is_multipath;
	bool hash_threshold;
	bool resilient;
	bool fdb_nh;
	bool has_v4;
	bool hw_stats;
	struct nh_res_table *res_table;
	struct nh_grp_entry nh_entries[0];
};

struct nh_grp_entry_stats {
	u64_stats_t packets;
	struct u64_stats_sync syncp;
};

struct nh_info {
	struct hlist_node dev_hash;
	struct nexthop *nh_parent;
	u8 family;
	bool reject_nh;
	bool fdb_nh;
	union {
		struct fib_nh_common fib_nhc;
		struct fib_nh fib_nh;
		struct fib6_nh fib6_nh;
	};
};

struct nh_notifier_single_info {
	struct net_device *dev;
	u8 gw_family;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	};
	u32 id;
	u8 is_reject: 1;
	u8 is_fdb: 1;
	u8 has_encap: 1;
};

struct nh_notifier_grp_entry_info {
	u16 weight;
	struct nh_notifier_single_info nh;
};

struct nh_notifier_grp_hw_stats_entry_info {
	u32 id;
	u64 packets;
};

struct nh_notifier_grp_hw_stats_info {
	u16 num_nh;
	bool hw_stats_used;
	struct nh_notifier_grp_hw_stats_entry_info stats[0];
};

struct nh_notifier_grp_info {
	u16 num_nh;
	bool is_fdb;
	bool hw_stats;
	struct nh_notifier_grp_entry_info nh_entries[0];
};

struct nh_notifier_res_table_info;

struct nh_notifier_res_bucket_info;

struct nh_notifier_info {
	struct net *net;
	struct netlink_ext_ack *extack;
	u32 id;
	enum nh_notifier_info_type type;
	union {
		struct nh_notifier_single_info *nh;
		struct nh_notifier_grp_info *nh_grp;
		struct nh_notifier_res_table_info *nh_res_table;
		struct nh_notifier_res_bucket_info *nh_res_bucket;
		struct nh_notifier_grp_hw_stats_info *nh_grp_hw_stats;
	};
};

struct nh_notifier_res_bucket_info {
	u16 bucket_index;
	unsigned int idle_timer_ms;
	bool force;
	struct nh_notifier_single_info old_nh;
	struct nh_notifier_single_info new_nh;
};

struct nh_notifier_res_table_info {
	u16 num_nh_buckets;
	bool hw_stats;
	struct nh_notifier_single_info nhs[0];
};

struct nh_res_bucket {
	struct nh_grp_entry *nh_entry;
	atomic_long_t used_time;
	long unsigned int migrated_time;
	bool occupied;
	u8 nh_flags;
};

struct nh_res_table {
	struct net *net;
	u32 nhg_id;
	struct delayed_work upkeep_dw;
	struct list_head uw_nh_entries;
	long unsigned int unbalanced_since;
	u32 idle_timer;
	u32 unbalanced_timer;
	u16 num_nh_buckets;
	struct nh_res_bucket nh_buckets[0];
};

struct nhmsg {
	unsigned char nh_family;
	unsigned char nh_scope;
	unsigned char nh_protocol;
	unsigned char resvd;
	unsigned int nh_flags;
};

struct nl80211_sta_flag_update {
	__u32 mask;
	__u32 set;
};

struct nl_pktinfo {
	__u32 group;
};

struct nl_seq_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
	int link;
};

struct nla_bitfield32 {
	__u32 value;
	__u32 selector;
};

struct nla_map {
	__u32 key;
	__u32 val;
};

struct nla_map___2 {
	u32 key;
	u32 val;
};

struct nlattr {
	__u16 nla_len;
	__u16 nla_type;
};

struct nlm_cookie {
	unsigned char data[32];
	unsigned int len;
};

struct nlm_lock {
	char *caller;
	unsigned int len;
	struct nfs_fh fh;
	struct xdr_netobj oh;
	u32 svid;
	u64 lock_start;
	u64 lock_len;
	struct file_lock fl;
};

struct nlm_args {
	struct nlm_cookie cookie;
	struct nlm_lock lock;
	u32 block;
	u32 reclaim;
	u32 state;
	u32 monitor;
	u32 fsm_access;
	u32 fsm_mode;
};

struct nlm_rqst;

struct nlm_file;

struct nlm_block {
	struct kref b_count;
	struct list_head b_list;
	struct list_head b_flist;
	struct nlm_rqst *b_call;
	struct svc_serv *b_daemon;
	struct nlm_host *b_host;
	long unsigned int b_when;
	unsigned int b_id;
	unsigned char b_granted;
	struct nlm_file *b_file;
	struct cache_req *b_cache_req;
	struct cache_deferred_req *b_deferred_req;
	unsigned int b_flags;
};

struct nlm_share;

struct nlm_file {
	struct hlist_node f_list;
	struct nfs_fh f_handle;
	struct file *f_file[2];
	struct nlm_share *f_shares;
	struct list_head f_blocks;
	unsigned int f_locks;
	unsigned int f_count;
	struct mutex f_mutex;
};

struct nsm_handle;

struct nlm_host {
	struct hlist_node h_hash;
	struct __kernel_sockaddr_storage h_addr;
	size_t h_addrlen;
	struct __kernel_sockaddr_storage h_srcaddr;
	size_t h_srcaddrlen;
	struct rpc_clnt *h_rpcclnt;
	char *h_name;
	u32 h_version;
	short unsigned int h_proto;
	short unsigned int h_reclaiming: 1;
	short unsigned int h_server: 1;
	short unsigned int h_noresvport: 1;
	short unsigned int h_inuse: 1;
	wait_queue_head_t h_gracewait;
	struct rw_semaphore h_rwsem;
	u32 h_state;
	u32 h_nsmstate;
	u32 h_pidcount;
	refcount_t h_count;
	struct mutex h_mutex;
	long unsigned int h_nextrebind;
	long unsigned int h_expires;
	struct list_head h_lockowners;
	spinlock_t h_lock;
	struct list_head h_granted;
	struct list_head h_reclaim;
	struct nsm_handle *h_nsmhandle;
	char *h_addrbuf;
	struct net *net;
	const struct cred *h_cred;
	char nodename[65];
	const struct nlmclnt_operations *h_nlmclnt_ops;
};

struct nlm_lockowner {
	struct list_head list;
	refcount_t count;
	struct nlm_host *host;
	fl_owner_t owner;
	uint32_t pid;
};

struct nlm_lookup_host_info {
	const int server;
	const struct sockaddr *sap;
	const size_t salen;
	const short unsigned int protocol;
	const u32 version;
	const char *hostname;
	const size_t hostname_len;
	const int noresvport;
	struct net *net;
	const struct cred *cred;
};

struct nsm_private {
	unsigned char data[16];
};

struct nlm_reboot {
	char *mon;
	unsigned int len;
	u32 state;
	struct nsm_private priv;
};

struct nlm_res {
	struct nlm_cookie cookie;
	__be32 status;
	struct nlm_lock lock;
};

struct nlm_rqst {
	refcount_t a_count;
	unsigned int a_flags;
	struct nlm_host *a_host;
	struct nlm_args a_args;
	struct nlm_res a_res;
	struct nlm_block *a_block;
	unsigned int a_retries;
	u8 a_owner[74];
	void *a_callback_data;
};

struct nlm_share {
	struct nlm_share *s_next;
	struct nlm_host *s_host;
	struct nlm_file *s_file;
	struct xdr_netobj s_owner;
	u32 s_access;
	u32 s_mode;
};

struct nlm_wait {
	struct list_head b_list;
	wait_queue_head_t b_wait;
	struct nlm_host *b_host;
	struct file_lock *b_lock;
	__be32 b_status;
};

struct nlmclnt_initdata {
	const char *hostname;
	const struct sockaddr *address;
	size_t addrlen;
	short unsigned int protocol;
	u32 nfs_version;
	int noresvport;
	struct net *net;
	const struct nlmclnt_operations *nlmclnt_ops;
	const struct cred *cred;
};

struct nlmclnt_operations {
	void (*nlmclnt_alloc_call)(void *);
	bool (*nlmclnt_unlock_prepare)(struct rpc_task *, void *);
	void (*nlmclnt_release_call)(void *);
};

struct nlmsghdr {
	__u32 nlmsg_len;
	__u16 nlmsg_type;
	__u16 nlmsg_flags;
	__u32 nlmsg_seq;
	__u32 nlmsg_pid;
};

struct nlmsgerr {
	int error;
	struct nlmsghdr msg;
};

struct nlmsvc_binding {
	__be32 (*fopen)(struct svc_rqst *, struct nfs_fh *, struct file **, int);
	void (*fclose)(struct file *);
};

struct nls_table {
	const char *charset;
	const char *alias;
	int (*uni2char)(wchar_t, unsigned char *, int);
	int (*char2uni)(const unsigned char *, int, wchar_t *);
	const unsigned char *charset2lower;
	const unsigned char *charset2upper;
	struct module *owner;
	struct nls_table *next;
};

struct nmi_desc {
	raw_spinlock_t lock;
	struct list_head head;
};

struct nmi_stats {
	unsigned int normal;
	unsigned int unknown;
	unsigned int external;
	unsigned int swallow;
	long unsigned int recv_jiffies;
	long unsigned int idt_seq;
	long unsigned int idt_nmi_seq;
	long unsigned int idt_ignored;
	atomic_long_t idt_calls;
	long unsigned int idt_seq_snap;
	long unsigned int idt_nmi_seq_snap;
	long unsigned int idt_ignored_snap;
	long int idt_calls_snap;
};

typedef int (*nmi_handler_t)(unsigned int, struct pt_regs *);

struct nmiaction {
	struct list_head list;
	nmi_handler_t handler;
	u64 max_duration;
	long unsigned int flags;
	const char *name;
};

struct node {
	struct device dev;
	struct list_head access_list;
};

struct node_access_nodes {
	struct device dev;
	struct list_head list_node;
	unsigned int access;
};

struct node_attr {
	struct device_attribute attr;
	enum node_states state;
};

struct node_groups {
	unsigned int id;
	union {
		unsigned int ngroups;
		unsigned int ncpus;
	};
};

struct node_hstate {
	struct kobject *hugepages_kobj;
	struct kobject *hstate_kobjs[2];
};

struct node_memory_type_map {
	struct memory_dev_type *memtype;
	int map_count;
};

struct nodemask_scratch {
	nodemask_t mask1;
	nodemask_t mask2;
};

struct nosave_region {
	struct list_head list;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
};

struct notification {
	atomic_t requests;
	u32 flags;
	u64 next_id;
	struct list_head notifications;
};

struct ns2501_configuration {
	u8 sync;
	u8 conf;
	u8 syncb;
	u8 dither;
	u8 pll_a;
	u16 pll_b;
	u16 hstart;
	u16 hstop;
	u16 vstart;
	u16 vstop;
	u16 vsync;
	u16 vtotal;
	u16 hpos;
	u16 vpos;
	u16 voffs;
	u16 hscale;
	u16 vscale;
};

struct ns2501_priv {
	bool quiet;
	const struct ns2501_configuration *conf;
};

struct ns2501_reg {
	u8 offset;
	u8 value;
};

struct ns_get_path_bpf_map_args {
	struct bpf_offloaded_map *offmap;
	struct bpf_map_info *info;
};

struct ns_get_path_bpf_prog_args {
	struct bpf_prog *prog;
	struct bpf_prog_info *info;
};

struct ns_get_path_task_args {
	const struct proc_ns_operations *ns_ops;
	struct task_struct *task;
};

struct nsh_md1_ctx {
	__be32 context[4];
};

struct nsh_md2_tlv {
	__be16 md_class;
	u8 type;
	u8 length;
	u8 md_value[0];
};

struct nshhdr {
	__be16 ver_flags_ttl_len;
	u8 mdtype;
	u8 np;
	__be32 path_hdr;
	union {
		struct nsh_md1_ctx md1;
		struct nsh_md2_tlv md2;
	};
};

struct nsm_args {
	struct nsm_private *priv;
	u32 prog;
	u32 vers;
	u32 proc;
	char *mon_name;
	const char *nodename;
};

struct nsm_handle {
	struct list_head sm_link;
	refcount_t sm_count;
	char *sm_mon_name;
	char *sm_name;
	struct __kernel_sockaddr_storage sm_addr;
	size_t sm_addrlen;
	unsigned int sm_monitored: 1;
	unsigned int sm_sticky: 1;
	struct nsm_private sm_priv;
	char sm_addrbuf[51];
};

struct nsm_res {
	u32 status;
	u32 state;
};

struct uts_namespace;

struct time_namespace;

struct nsproxy {
	refcount_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net *net_ns;
	struct time_namespace *time_ns;
	struct time_namespace *time_ns_for_children;
	struct cgroup_namespace *cgroup_ns;
};

struct nsset {
	unsigned int flags;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	const struct cred *cred;
};

struct nt_partition_info {
	u32 xlink_enabled;
	u32 target_part_low;
	u32 target_part_high;
	u32 reserved;
};

struct ntb_ctrl_regs {
	u32 partition_status;
	u32 partition_op;
	u32 partition_ctrl;
	u32 bar_setup;
	u32 bar_error;
	u16 lut_table_entries;
	u16 lut_table_offset;
	u32 lut_error;
	u16 req_id_table_size;
	u16 req_id_table_offset;
	u32 req_id_error;
	u32 reserved1[7];
	struct {
		u32 ctl;
		u32 win_size;
		u64 xlate_addr;
	} bar_entry[6];
	struct {
		u32 win_size;
		u32 reserved[3];
	} bar_ext_entry[6];
	u32 reserved2[192];
	u32 req_id_table[512];
	u32 reserved3[256];
	u64 lut_entry[512];
};

struct ntb_info_regs {
	u8 partition_count;
	u8 partition_id;
	u16 reserved1;
	u64 ep_map;
	u16 requester_id;
	u16 reserved2;
	u32 reserved3[4];
	struct nt_partition_info ntp_info[48];
} __attribute__((packed));

struct ntp_data {
	long unsigned int tick_usec;
	u64 tick_length;
	u64 tick_length_base;
	int time_state;
	int time_status;
	s64 time_offset;
	long int time_constant;
	long int time_maxerror;
	long int time_esterror;
	s64 time_freq;
	time64_t time_reftime;
	long int time_adjust;
	s64 ntp_tick_adj;
	time64_t ntp_next_leap_sec;
};

struct numa_maps {
	long unsigned int pages;
	long unsigned int anon;
	long unsigned int active;
	long unsigned int writeback;
	long unsigned int mapcount_max;
	long unsigned int dirty;
	long unsigned int swapcache;
	long unsigned int node[64];
};

struct proc_maps_private {
	struct inode *inode;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vma_iterator iter;
	struct mempolicy *task_mempolicy;
};

struct numa_maps_private {
	struct proc_maps_private proc_maps;
	struct numa_maps md;
};

struct numa_memblk {
	u64 start;
	u64 end;
	int nid;
};

struct numa_meminfo {
	int nr_blks;
	struct numa_memblk blk[128];
};

struct nvme_abort_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[9];
	__le16 sqid;
	__u16 cid;
	__u32 rsvd11[5];
};

struct nvme_ana_group_desc {
	__le32 grpid;
	__le32 nnsids;
	__le64 chgcnt;
	__u8 state;
	__u8 rsvd17[15];
	__le32 nsids[0];
};

struct nvme_ana_rsp_hdr {
	__le64 chgcnt;
	__le16 ngrps;
	__le16 rsvd10[3];
};

struct nvme_auth_dhgroup_map {
	const char name[16];
	const char kpp[16];
};

struct nvme_sgl_desc {
	__le64 addr;
	__le32 length;
	__u8 rsvd[3];
	__u8 type;
};

struct nvme_keyed_sgl_desc {
	__le64 addr;
	__u8 length[3];
	__u8 key[4];
	__u8 type;
};

union nvme_data_ptr {
	struct {
		__le64 prp1;
		__le64 prp2;
	};
	struct nvme_sgl_desc sgl;
	struct nvme_keyed_sgl_desc ksgl;
};

struct nvme_common_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le32 cdw2[2];
	__le64 metadata;
	union nvme_data_ptr dptr;
	union {
		struct {
			__le32 cdw10;
			__le32 cdw11;
			__le32 cdw12;
			__le32 cdw13;
			__le32 cdw14;
			__le32 cdw15;
		};
		struct {
			__le32 cdw10;
			__le32 cdw11;
			__le32 cdw12;
			__le32 cdw13;
			__le32 cdw14;
			__le32 cdw15;
		} cdws;
	};
};

struct nvme_rw_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le32 cdw2;
	__le32 cdw3;
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le16 length;
	__le16 control;
	__le32 dsmgmt;
	__le32 reftag;
	__le16 lbat;
	__le16 lbatm;
};

struct nvme_identify {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__u8 cns;
	__u8 rsvd3;
	__le16 ctrlid;
	__le16 cnssid;
	__u8 rsvd11;
	__u8 csi;
	__u32 rsvd12[4];
};

struct nvme_features {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 fid;
	__le32 dword11;
	__le32 dword12;
	__le32 dword13;
	__le32 dword14;
	__le32 dword15;
};

struct nvme_create_cq {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__u64 rsvd8;
	__le16 cqid;
	__le16 qsize;
	__le16 cq_flags;
	__le16 irq_vector;
	__u32 rsvd12[4];
};

struct nvme_create_sq {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__u64 rsvd8;
	__le16 sqid;
	__le16 qsize;
	__le16 sq_flags;
	__le16 cqid;
	__u32 rsvd12[4];
};

struct nvme_delete_queue {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[9];
	__le16 qid;
	__u16 rsvd10;
	__u32 rsvd11[5];
};

struct nvme_download_firmware {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	union nvme_data_ptr dptr;
	__le32 numd;
	__le32 offset;
	__u32 rsvd12[4];
};

struct nvme_format_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[4];
	__le32 cdw10;
	__u32 rsvd11[5];
};

struct nvme_dsm_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 nr;
	__le32 attributes;
	__u32 rsvd12[4];
};

struct nvme_write_zeroes_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2;
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le16 length;
	__le16 control;
	__le32 dsmgmt;
	__le32 reftag;
	__le16 lbat;
	__le16 lbatm;
};

struct nvme_zone_mgmt_send_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le32 cdw2[2];
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le32 cdw12;
	__u8 zsa;
	__u8 select_all;
	__u8 rsvd13[2];
	__le32 cdw14[2];
};

struct nvme_zone_mgmt_recv_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le64 slba;
	__le32 numd;
	__u8 zra;
	__u8 zrasf;
	__u8 pr;
	__u8 rsvd13;
	__le32 cdw14[2];
};

struct nvme_get_log_page_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__u8 lid;
	__u8 lsp;
	__le16 numdl;
	__le16 numdu;
	__le16 lsi;
	union {
		struct {
			__le32 lpol;
			__le32 lpou;
		};
		__le64 lpo;
	};
	__u8 rsvd14[3];
	__u8 csi;
	__u32 rsvd15;
};

struct nvmf_common_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 ts[24];
};

struct nvmf_connect_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[19];
	union nvme_data_ptr dptr;
	__le16 recfmt;
	__le16 qid;
	__le16 sqsize;
	__u8 cattr;
	__u8 resv3;
	__le32 kato;
	__u8 resv4[12];
};

struct nvmf_property_set_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 attrib;
	__u8 resv3[3];
	__le32 offset;
	__le64 value;
	__u8 resv4[8];
};

struct nvmf_property_get_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 attrib;
	__u8 resv3[3];
	__le32 offset;
	__u8 resv4[16];
};

struct nvmf_auth_common_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[19];
	union nvme_data_ptr dptr;
	__u8 resv3;
	__u8 spsp0;
	__u8 spsp1;
	__u8 secp;
	__le32 al_tl;
	__u8 resv4[16];
};

struct nvmf_auth_send_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[19];
	union nvme_data_ptr dptr;
	__u8 resv3;
	__u8 spsp0;
	__u8 spsp1;
	__u8 secp;
	__le32 tl;
	__u8 resv4[16];
};

struct nvmf_auth_receive_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[19];
	union nvme_data_ptr dptr;
	__u8 resv3;
	__u8 spsp0;
	__u8 spsp1;
	__u8 secp;
	__le32 al;
	__u8 resv4[16];
};

struct nvme_dbbuf {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__le64 prp2;
	__u32 rsvd12[6];
};

struct nvme_directive_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 numd;
	__u8 doper;
	__u8 dtype;
	__le16 dspec;
	__u8 endir;
	__u8 tdtype;
	__u16 rsvd15;
	__u32 rsvd16[3];
};

struct nvme_command {
	union {
		struct nvme_common_command common;
		struct nvme_rw_command rw;
		struct nvme_identify identify;
		struct nvme_features features;
		struct nvme_create_cq create_cq;
		struct nvme_create_sq create_sq;
		struct nvme_delete_queue delete_queue;
		struct nvme_download_firmware dlfw;
		struct nvme_format_cmd format;
		struct nvme_dsm_cmd dsm;
		struct nvme_write_zeroes_cmd write_zeroes;
		struct nvme_zone_mgmt_send_cmd zms;
		struct nvme_zone_mgmt_recv_cmd zmr;
		struct nvme_abort_cmd abort;
		struct nvme_get_log_page_command get_log_page;
		struct nvmf_common_command fabrics;
		struct nvmf_connect_command connect;
		struct nvmf_property_set_command prop_set;
		struct nvmf_property_get_command prop_get;
		struct nvmf_auth_common_command auth_common;
		struct nvmf_auth_send_command auth_send;
		struct nvmf_auth_receive_command auth_receive;
		struct nvme_dbbuf dbbuf;
		struct nvme_directive_cmd directive;
	};
};

union nvme_result {
	__le16 u16;
	__le32 u32;
	__le64 u64;
};

struct nvme_completion {
	union nvme_result result;
	__le16 sq_head;
	__le16 sq_id;
	__u16 command_id;
	__le16 status;
};

struct nvme_core_quirk_entry {
	u16 vid;
	const char *mn;
	const char *fr;
	long unsigned int quirks;
};

struct opal_dev;

struct nvme_id_power_state {
	__le16 max_power;
	__u8 rsvd2;
	__u8 flags;
	__le32 entry_lat;
	__le32 exit_lat;
	__u8 read_tput;
	__u8 read_lat;
	__u8 write_tput;
	__u8 write_lat;
	__le16 idle_power;
	__u8 idle_scale;
	__u8 rsvd19;
	__le16 active_power;
	__u8 active_work_scale;
	__u8 rsvd23[9];
};

struct nvme_fault_inject {};

struct nvme_ctrl_ops;

struct nvme_subsystem;

struct nvme_effects_log;

struct nvme_dhchap_queue_context;

struct nvme_dhchap_key;

struct nvmf_ctrl_options;

struct nvme_ctrl {
	bool comp_seen;
	bool identified;
	bool passthru_err_log_enabled;
	enum nvme_ctrl_state state;
	spinlock_t lock;
	struct mutex scan_lock;
	const struct nvme_ctrl_ops *ops;
	struct request_queue *admin_q;
	struct request_queue *connect_q;
	struct request_queue *fabrics_q;
	struct device *dev;
	int instance;
	int numa_node;
	struct blk_mq_tag_set *tagset;
	struct blk_mq_tag_set *admin_tagset;
	struct list_head namespaces;
	struct mutex namespaces_lock;
	struct srcu_struct srcu;
	struct device ctrl_device;
	struct device *device;
	struct device *hwmon_device;
	struct cdev cdev;
	struct work_struct reset_work;
	struct work_struct delete_work;
	wait_queue_head_t state_wq;
	struct nvme_subsystem *subsys;
	struct list_head subsys_entry;
	struct opal_dev *opal_dev;
	u16 cntlid;
	u16 mtfa;
	u32 ctrl_config;
	u32 queue_count;
	u64 cap;
	u32 max_hw_sectors;
	u32 max_segments;
	u32 max_integrity_segments;
	u32 max_zeroes_sectors;
	u16 crdt[3];
	u16 oncs;
	u8 dmrl;
	u32 dmrsl;
	u16 oacs;
	u16 sqsize;
	u32 max_namespaces;
	atomic_t abort_limit;
	u8 vwc;
	u32 vs;
	u32 sgls;
	u16 kas;
	u8 npss;
	u8 apsta;
	u16 wctemp;
	u16 cctemp;
	u32 oaes;
	u32 aen_result;
	u32 ctratt;
	unsigned int shutdown_timeout;
	unsigned int kato;
	bool subsystem;
	long unsigned int quirks;
	struct nvme_id_power_state psd[32];
	struct nvme_effects_log *effects;
	struct xarray cels;
	struct work_struct scan_work;
	struct work_struct async_event_work;
	struct delayed_work ka_work;
	struct delayed_work failfast_work;
	struct nvme_command ka_cmd;
	long unsigned int ka_last_check_time;
	struct work_struct fw_act_work;
	long unsigned int events;
	u8 anacap;
	u8 anatt;
	u32 anagrpmax;
	u32 nanagrpid;
	struct mutex ana_lock;
	struct nvme_ana_rsp_hdr *ana_log_buf;
	size_t ana_log_size;
	struct timer_list anatt_timer;
	struct work_struct ana_work;
	atomic_t nr_active;
	struct work_struct dhchap_auth_work;
	struct mutex dhchap_auth_mutex;
	struct nvme_dhchap_queue_context *dhchap_ctxs;
	struct nvme_dhchap_key *host_key;
	struct nvme_dhchap_key *ctrl_key;
	u16 transaction;
	key_serial_t tls_pskid;
	u64 ps_max_latency_us;
	bool apst_enabled;
	u16 hmmaxd;
	u32 hmpre;
	u32 hmmin;
	u32 hmminds;
	u32 ioccsz;
	u32 iorcsz;
	u16 icdoff;
	u16 maxcmd;
	int nr_reconnects;
	long unsigned int flags;
	struct nvmf_ctrl_options *opts;
	struct page *discard_page;
	long unsigned int discard_page_busy;
	struct nvme_fault_inject fault_inject;
	enum nvme_ctrl_type cntrltype;
	enum nvme_dctype dctype;
};

struct nvme_ctrl_ops {
	const char *name;
	struct module *module;
	unsigned int flags;
	const struct attribute_group **dev_attr_groups;
	int (*reg_read32)(struct nvme_ctrl *, u32, u32 *);
	int (*reg_write32)(struct nvme_ctrl *, u32, u32);
	int (*reg_read64)(struct nvme_ctrl *, u32, u64 *);
	void (*free_ctrl)(struct nvme_ctrl *);
	void (*submit_async_event)(struct nvme_ctrl *);
	int (*subsystem_reset)(struct nvme_ctrl *);
	void (*delete_ctrl)(struct nvme_ctrl *);
	void (*stop_ctrl)(struct nvme_ctrl *);
	int (*get_address)(struct nvme_ctrl *, char *, int);
	void (*print_device_info)(struct nvme_ctrl *);
	bool (*supports_pci_p2pdma)(struct nvme_ctrl *);
};

union nvme_descriptor {
	struct nvme_sgl_desc *sg_list;
	__le64 *prp_list;
};

struct nvme_queue;

struct nvme_host_mem_buf_desc;

struct nvme_dev {
	struct nvme_queue *queues;
	struct blk_mq_tag_set tagset;
	struct blk_mq_tag_set admin_tagset;
	u32 *dbs;
	struct device *dev;
	struct dma_pool *prp_page_pool;
	struct dma_pool *prp_small_pool;
	unsigned int online_queues;
	unsigned int max_qid;
	unsigned int io_queues[3];
	unsigned int num_vecs;
	u32 q_depth;
	int io_sqes;
	u32 db_stride;
	void *bar;
	long unsigned int bar_mapped_size;
	struct mutex shutdown_lock;
	bool subsystem;
	u64 cmb_size;
	bool cmb_use_sqes;
	u32 cmbsz;
	u32 cmbloc;
	struct nvme_ctrl ctrl;
	u32 last_ps;
	bool hmb;
	struct sg_table *hmb_sgt;
	mempool_t *iod_mempool;
	mempool_t *iod_meta_mempool;
	__le32 *dbbuf_dbs;
	dma_addr_t dbbuf_dbs_dma_addr;
	__le32 *dbbuf_eis;
	dma_addr_t dbbuf_eis_dma_addr;
	u64 host_mem_size;
	u32 nr_host_mem_descs;
	u32 host_mem_descs_size;
	dma_addr_t host_mem_descs_dma;
	struct nvme_host_mem_buf_desc *host_mem_descs;
	void **host_mem_desc_bufs;
	unsigned int nr_allocated_queues;
	unsigned int nr_write_queues;
	unsigned int nr_poll_queues;
};

struct nvme_dhchap_hash_map {
	int len;
	const char hmac[15];
	const char digest[8];
};

struct nvme_dhchap_key {
	size_t len;
	u8 hash;
	u8 key[0];
};

struct nvme_dhchap_queue_context {
	struct list_head entry;
	struct work_struct auth_work;
	struct nvme_ctrl *ctrl;
	struct crypto_shash *shash_tfm;
	struct crypto_kpp *dh_tfm;
	struct nvme_dhchap_key *transformed_key;
	void *buf;
	int qid;
	int error;
	u32 s1;
	u32 s2;
	bool bi_directional;
	u16 transaction;
	u8 status;
	u8 dhgroup_id;
	u8 hash_id;
	size_t hash_len;
	u8 c1[64];
	u8 c2[64];
	u8 response[64];
	u8 *ctrl_key;
	u8 *host_key;
	u8 *sess_key;
	int ctrl_key_len;
	int host_key_len;
	int sess_key_len;
};

struct nvme_dsm_range {
	__le32 cattr;
	__le32 nlb;
	__le64 slba;
};

struct nvme_effects_log {
	__le32 acs[256];
	__le32 iocs[256];
	__u8 resv[2048];
};

struct nvme_fc_cmd_iu {
	__u8 format_id;
	__u8 fc_id;
	__be16 iu_len;
	__u8 rsvd4[2];
	__u8 rsv_cat;
	__u8 flags;
	__be64 connection_id;
	__be32 csn;
	__be32 data_len;
	struct nvme_command sqe;
	__u8 dps;
	__u8 lbads;
	__be16 ms;
	__be32 rsvd92;
};

struct nvme_request {
	struct nvme_command *cmd;
	union nvme_result result;
	u8 genctr;
	u8 retries;
	u8 flags;
	u16 status;
	long unsigned int start_time;
	struct nvme_ctrl *ctrl;
};

struct nvmefc_fcp_req {
	void *cmdaddr;
	void *rspaddr;
	dma_addr_t cmddma;
	dma_addr_t rspdma;
	u16 cmdlen;
	u16 rsplen;
	u32 payload_length;
	struct sg_table sg_table;
	struct scatterlist *first_sgl;
	int sg_cnt;
	enum nvmefc_fcp_datadir io_dir;
	void (*done)(struct nvmefc_fcp_req *);
	void *private;
	__le16 sqid;
	u16 rcv_rsplen;
	u32 transferred_length;
	u32 status;
};

struct nvme_fc_ersp_iu {
	__u8 ersp_result;
	__u8 rsvd1;
	__be16 iu_len;
	__be32 rsn;
	__be32 xfrd_len;
	__be32 rsvd12;
	struct nvme_completion cqe;
};

struct nvme_fc_ctrl;

struct nvme_fc_queue;

struct nvme_fc_fcp_op {
	struct nvme_request nreq;
	struct nvmefc_fcp_req fcp_req;
	struct nvme_fc_ctrl *ctrl;
	struct nvme_fc_queue *queue;
	struct request *rq;
	atomic_t state;
	u32 flags;
	u32 rqno;
	u32 nents;
	struct nvme_fc_cmd_iu cmd_iu;
	struct nvme_fc_ersp_iu rsp_iu;
};

struct nvme_fc_lport;

struct nvme_fc_rport;

struct nvmefc_ls_rcv_op;

struct nvme_fc_ctrl {
	spinlock_t lock;
	struct nvme_fc_queue *queues;
	struct device *dev;
	struct nvme_fc_lport *lport;
	struct nvme_fc_rport *rport;
	u32 cnum;
	bool ioq_live;
	u64 association_id;
	struct nvmefc_ls_rcv_op *rcv_disconn;
	struct list_head ctrl_list;
	struct blk_mq_tag_set admin_tag_set;
	struct blk_mq_tag_set tag_set;
	struct work_struct ioerr_work;
	struct delayed_work connect_work;
	struct kref ref;
	long unsigned int flags;
	u32 iocnt;
	wait_queue_head_t ioabort_wait;
	struct nvme_fc_fcp_op aen_ops[1];
	struct nvme_ctrl ctrl;
};

struct nvme_fc_local_port {
	u32 port_num;
	u32 port_role;
	u64 node_name;
	u64 port_name;
	void *private;
	u32 port_id;
	enum nvme_fc_obj_state port_state;
};

struct nvme_fc_port_template;

struct nvme_fc_lport {
	struct nvme_fc_local_port localport;
	struct ida endp_cnt;
	struct list_head port_list;
	struct list_head endp_list;
	struct device *dev;
	struct nvme_fc_port_template *ops;
	struct kref ref;
	atomic_t act_rport_cnt;
};

struct nvme_fc_port_info {
	u64 node_name;
	u64 port_name;
	u32 port_role;
	u32 port_id;
	u32 dev_loss_tmo;
};

struct nvme_fc_remote_port;

struct nvmefc_ls_req;

struct nvmefc_ls_rsp;

struct nvme_fc_port_template {
	void (*localport_delete)(struct nvme_fc_local_port *);
	void (*remoteport_delete)(struct nvme_fc_remote_port *);
	int (*create_queue)(struct nvme_fc_local_port *, unsigned int, u16, void **);
	void (*delete_queue)(struct nvme_fc_local_port *, unsigned int, void *);
	int (*ls_req)(struct nvme_fc_local_port *, struct nvme_fc_remote_port *, struct nvmefc_ls_req *);
	int (*fcp_io)(struct nvme_fc_local_port *, struct nvme_fc_remote_port *, void *, struct nvmefc_fcp_req *);
	void (*ls_abort)(struct nvme_fc_local_port *, struct nvme_fc_remote_port *, struct nvmefc_ls_req *);
	void (*fcp_abort)(struct nvme_fc_local_port *, struct nvme_fc_remote_port *, void *, struct nvmefc_fcp_req *);
	int (*xmt_ls_rsp)(struct nvme_fc_local_port *, struct nvme_fc_remote_port *, struct nvmefc_ls_rsp *);
	void (*map_queues)(struct nvme_fc_local_port *, struct blk_mq_queue_map *);
	u32 max_hw_queues;
	u16 max_sgl_segments;
	u16 max_dif_sgl_segments;
	u64 dma_boundary;
	u32 local_priv_sz;
	u32 remote_priv_sz;
	u32 lsrqst_priv_sz;
	u32 fcprqst_priv_sz;
};

struct nvme_fc_queue {
	struct nvme_fc_ctrl *ctrl;
	struct device *dev;
	struct blk_mq_hw_ctx *hctx;
	void *lldd_handle;
	size_t cmnd_capsule_len;
	u32 qnum;
	u32 rqcnt;
	u32 seqno;
	u64 connection_id;
	atomic_t csn;
	long unsigned int flags;
};

struct nvme_fc_remote_port {
	u32 port_num;
	u32 port_role;
	u64 node_name;
	u64 port_name;
	struct nvme_fc_local_port *localport;
	void *private;
	u32 dev_loss_tmo;
	u32 port_id;
	enum nvme_fc_obj_state port_state;
};

struct nvme_fc_rport {
	struct nvme_fc_remote_port remoteport;
	struct list_head endp_list;
	struct list_head ctrl_list;
	struct list_head ls_req_list;
	struct list_head ls_rcv_list;
	struct list_head disc_list;
	struct device *dev;
	struct nvme_fc_lport *lport;
	spinlock_t lock;
	struct kref ref;
	atomic_t act_ctrl_cnt;
	long unsigned int dev_loss_end;
	struct work_struct lsrcv_work;
};

struct nvme_fcp_op_w_sgl {
	struct nvme_fc_fcp_op op;
	struct scatterlist sgl[2];
	uint8_t priv[0];
};

struct nvme_feat_auto_pst {
	__le64 entries[32];
};

struct nvme_feat_host_behavior {
	__u8 acre;
	__u8 etdas;
	__u8 lbafee;
	__u8 resv1[509];
};

struct nvme_fw_slot_info_log {
	__u8 afi;
	__u8 rsvd1[7];
	__le64 frs[7];
	__u8 rsvd64[448];
};

struct nvme_host_mem_buf_desc {
	__le64 addr;
	__le32 size;
	__u32 rsvd;
};

struct nvme_smart_log;

struct nvme_hwmon_data {
	struct nvme_ctrl *ctrl;
	struct nvme_smart_log *log;
	struct mutex read_lock;
};

struct nvme_id_ctrl {
	__le16 vid;
	__le16 ssvid;
	char sn[20];
	char mn[40];
	char fr[8];
	__u8 rab;
	__u8 ieee[3];
	__u8 cmic;
	__u8 mdts;
	__le16 cntlid;
	__le32 ver;
	__le32 rtd3r;
	__le32 rtd3e;
	__le32 oaes;
	__le32 ctratt;
	__u8 rsvd100[11];
	__u8 cntrltype;
	__u8 fguid[16];
	__le16 crdt1;
	__le16 crdt2;
	__le16 crdt3;
	__u8 rsvd134[122];
	__le16 oacs;
	__u8 acl;
	__u8 aerl;
	__u8 frmw;
	__u8 lpa;
	__u8 elpe;
	__u8 npss;
	__u8 avscc;
	__u8 apsta;
	__le16 wctemp;
	__le16 cctemp;
	__le16 mtfa;
	__le32 hmpre;
	__le32 hmmin;
	__u8 tnvmcap[16];
	__u8 unvmcap[16];
	__le32 rpmbs;
	__le16 edstt;
	__u8 dsto;
	__u8 fwug;
	__le16 kas;
	__le16 hctma;
	__le16 mntmt;
	__le16 mxtmt;
	__le32 sanicap;
	__le32 hmminds;
	__le16 hmmaxd;
	__le16 nvmsetidmax;
	__le16 endgidmax;
	__u8 anatt;
	__u8 anacap;
	__le32 anagrpmax;
	__le32 nanagrpid;
	__u8 rsvd352[160];
	__u8 sqes;
	__u8 cqes;
	__le16 maxcmd;
	__le32 nn;
	__le16 oncs;
	__le16 fuses;
	__u8 fna;
	__u8 vwc;
	__le16 awun;
	__le16 awupf;
	__u8 nvscc;
	__u8 nwpc;
	__le16 acwu;
	__u8 rsvd534[2];
	__le32 sgls;
	__le32 mnan;
	__u8 rsvd544[224];
	char subnqn[256];
	__u8 rsvd1024[768];
	__le32 ioccsz;
	__le32 iorcsz;
	__le16 icdoff;
	__u8 ctrattr;
	__u8 msdbd;
	__u8 rsvd1804[2];
	__u8 dctype;
	__u8 rsvd1807[241];
	struct nvme_id_power_state psd[32];
	__u8 vs[1024];
};

struct nvme_id_ctrl_nvm {
	__u8 vsl;
	__u8 wzsl;
	__u8 wusl;
	__u8 dmrl;
	__le32 dmrsl;
	__le64 dmsl;
	__u8 rsvd16[4080];
};

struct nvme_lbaf {
	__le16 ms;
	__u8 ds;
	__u8 rp;
};

struct nvme_id_ns {
	__le64 nsze;
	__le64 ncap;
	__le64 nuse;
	__u8 nsfeat;
	__u8 nlbaf;
	__u8 flbas;
	__u8 mc;
	__u8 dpc;
	__u8 dps;
	__u8 nmic;
	__u8 rescap;
	__u8 fpi;
	__u8 dlfeat;
	__le16 nawun;
	__le16 nawupf;
	__le16 nacwu;
	__le16 nabsn;
	__le16 nabo;
	__le16 nabspf;
	__le16 noiob;
	__u8 nvmcap[16];
	__le16 npwg;
	__le16 npwa;
	__le16 npdg;
	__le16 npda;
	__le16 nows;
	__u8 rsvd74[18];
	__le32 anagrpid;
	__u8 rsvd96[3];
	__u8 nsattr;
	__le16 nvmsetid;
	__le16 endgid;
	__u8 nguid[16];
	__u8 eui64[8];
	struct nvme_lbaf lbaf[64];
	__u8 vs[3712];
};

struct nvme_id_ns_cs_indep {
	__u8 nsfeat;
	__u8 nmic;
	__u8 rescap;
	__u8 fpi;
	__le32 anagrpid;
	__u8 nsattr;
	__u8 rsvd9;
	__le16 nvmsetid;
	__le16 endgid;
	__u8 nstat;
	__u8 rsvd15[4081];
};

struct nvme_id_ns_nvm {
	__le64 lbstm;
	__u8 pic;
	__u8 rsvd9[3];
	__le32 elbaf[64];
	__u8 rsvd268[3828];
};

struct nvme_iod {
	struct nvme_request req;
	struct nvme_command cmd;
	bool aborted;
	s8 nr_allocations;
	unsigned int dma_len;
	dma_addr_t first_dma;
	dma_addr_t meta_dma;
	struct sg_table sgt;
	struct sg_table meta_sgt;
	union nvme_descriptor meta_list;
	union nvme_descriptor list[5];
};

struct nvme_ns_head;

struct nvme_ns {
	struct list_head list;
	struct nvme_ctrl *ctrl;
	struct request_queue *queue;
	struct gendisk *disk;
	enum nvme_ana_state ana_state;
	u32 ana_grpid;
	struct list_head siblings;
	struct kref kref;
	struct nvme_ns_head *head;
	long unsigned int flags;
	struct cdev cdev;
	struct device cdev_device;
	struct nvme_fault_inject fault_inject;
};

struct nvme_ns_ids {
	u8 eui64[8];
	u8 nguid[16];
	uuid_t uuid;
	u8 csi;
};

struct nvme_ns_head {
	struct list_head list;
	struct srcu_struct srcu;
	struct nvme_subsystem *subsys;
	struct nvme_ns_ids ids;
	u8 lba_shift;
	u16 ms;
	u16 pi_size;
	u8 pi_type;
	u8 guard_type;
	struct list_head entry;
	struct kref ref;
	bool shared;
	bool rotational;
	bool passthru_err_log_enabled;
	struct nvme_effects_log *effects;
	u64 nuse;
	unsigned int ns_id;
	int instance;
	long unsigned int features;
	struct ratelimit_state rs_nuse;
	struct cdev cdev;
	struct device cdev_device;
	struct gendisk *disk;
	struct bio_list requeue_list;
	spinlock_t requeue_lock;
	struct work_struct requeue_work;
	struct work_struct partition_scan_work;
	struct mutex lock;
	long unsigned int flags;
	struct nvme_ns *current_path[0];
};

struct nvme_ns_id_desc {
	__u8 nidt;
	__u8 nidl;
	__le16 reserved;
};

struct nvme_ns_info {
	struct nvme_ns_ids ids;
	u32 nsid;
	__le32 anagrpid;
	u8 pi_offset;
	bool is_shared;
	bool is_readonly;
	bool is_ready;
	bool is_removed;
	bool is_rotational;
	bool no_vwc;
};

struct nvme_passthru_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 rsvd1;
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	__u32 data_len;
	__u32 cdw10;
	__u32 cdw11;
	__u32 cdw12;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u32 timeout_ms;
	__u32 result;
};

struct nvme_passthru_cmd64 {
	__u8 opcode;
	__u8 flags;
	__u16 rsvd1;
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	union {
		__u32 data_len;
		__u32 vec_cnt;
	};
	__u32 cdw10;
	__u32 cdw11;
	__u32 cdw12;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u32 timeout_ms;
	__u32 rsvd2;
	__u64 result;
};

struct nvme_queue {
	struct nvme_dev *dev;
	spinlock_t sq_lock;
	void *sq_cmds;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t cq_poll_lock;
	struct nvme_completion *cqes;
	dma_addr_t sq_dma_addr;
	dma_addr_t cq_dma_addr;
	u32 *q_db;
	u32 q_depth;
	u16 cq_vector;
	u16 sq_tail;
	u16 last_sq_tail;
	u16 cq_head;
	u16 qid;
	u8 cq_phase;
	u8 sqes;
	long unsigned int flags;
	__le32 *dbbuf_sq_db;
	__le32 *dbbuf_cq_db;
	__le32 *dbbuf_sq_ei;
	__le32 *dbbuf_cq_ei;
	struct completion delete_done;
};

struct nvme_registered_ctrl {
	__le16 cntlid;
	__u8 rcsts;
	__u8 rsvd3[5];
	__le64 hostid;
	__le64 rkey;
};

struct nvme_registered_ctrl_ext {
	__le16 cntlid;
	__u8 rcsts;
	__u8 rsvd3[5];
	__le64 rkey;
	__u8 hostid[16];
	__u8 rsvd32[32];
};

struct nvme_reservation_status {
	__le32 gen;
	__u8 rtype;
	__u8 regctl[2];
	__u8 resv5[2];
	__u8 ptpls;
	__u8 resv10[14];
	struct nvme_registered_ctrl regctl_ds[0];
};

struct nvme_reservation_status_ext {
	__le32 gen;
	__u8 rtype;
	__u8 regctl[2];
	__u8 resv5[2];
	__u8 ptpls;
	__u8 resv10[14];
	__u8 rsvd24[40];
	struct nvme_registered_ctrl_ext regctl_eds[0];
};

struct nvme_smart_log {
	__u8 critical_warning;
	__u8 temperature[2];
	__u8 avail_spare;
	__u8 spare_thresh;
	__u8 percent_used;
	__u8 endu_grp_crit_warn_sumry;
	__u8 rsvd7[25];
	__u8 data_units_read[16];
	__u8 data_units_written[16];
	__u8 host_reads[16];
	__u8 host_writes[16];
	__u8 ctrl_busy_time[16];
	__u8 power_cycles[16];
	__u8 power_on_hours[16];
	__u8 unsafe_shutdowns[16];
	__u8 media_errors[16];
	__u8 num_err_log_entries[16];
	__le32 warning_temp_time;
	__le32 critical_comp_time;
	__le16 temp_sensor[8];
	__le32 thm_temp1_trans_count;
	__le32 thm_temp2_trans_count;
	__le32 thm_temp1_total_time;
	__le32 thm_temp2_total_time;
	__u8 rsvd232[280];
};

struct nvme_subsystem {
	int instance;
	struct device dev;
	struct kref ref;
	struct list_head entry;
	struct mutex lock;
	struct list_head ctrls;
	struct list_head nsheads;
	char subnqn[223];
	char serial[20];
	char model[40];
	char firmware_rev[8];
	u8 cmic;
	enum nvme_subsys_type subtype;
	u16 vendor_id;
	u16 awupf;
	struct ida ns_ida;
	enum nvme_iopolicy iopolicy;
};

struct nvme_uring_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 rsvd1;
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	__u32 data_len;
	__u32 cdw10;
	__u32 cdw11;
	__u32 cdw12;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u32 timeout_ms;
	__u32 rsvd2;
};

struct nvme_uring_cmd_pdu {
	struct request *req;
	struct bio *bio;
	u64 result;
	int status;
};

struct nvme_uring_data {
	__u64 metadata;
	__u64 addr;
	__u32 data_len;
	__u32 metadata_len;
	__u32 timeout_ms;
};

struct nvme_user_io {
	__u8 opcode;
	__u8 flags;
	__u16 control;
	__u16 nblocks;
	__u16 rsvd;
	__u64 metadata;
	__u64 addr;
	__u64 slba;
	__u32 dsmgmt;
	__u32 reftag;
	__u16 apptag;
	__u16 appmask;
};

struct nvme_zone_info {
	u64 zone_size;
	unsigned int max_open_zones;
	unsigned int max_active_zones;
};

union nvmefc_ls_requests;

union nvmefc_ls_responses;

struct nvmefc_ls_rcv_op {
	struct nvme_fc_rport *rport;
	struct nvmefc_ls_rsp *lsrsp;
	union nvmefc_ls_requests *rqstbuf;
	union nvmefc_ls_responses *rspbuf;
	u16 rqstdatalen;
	bool handled;
	dma_addr_t rspdma;
	struct list_head lsrcv_list;
};

struct nvmefc_ls_req {
	void *rqstaddr;
	dma_addr_t rqstdma;
	u32 rqstlen;
	void *rspaddr;
	dma_addr_t rspdma;
	u32 rsplen;
	u32 timeout;
	void *private;
	void (*done)(struct nvmefc_ls_req *, int);
};

struct nvmefc_ls_req_op {
	struct nvmefc_ls_req ls_req;
	struct nvme_fc_rport *rport;
	struct nvme_fc_queue *queue;
	struct request *rq;
	u32 flags;
	int ls_error;
	struct completion ls_done;
	struct list_head lsreq_list;
	bool req_queued;
};

union nvmefc_ls_requests {
	struct fcnvme_ls_rqst_w0 w0;
	struct fcnvme_ls_cr_assoc_rqst rq_cr_assoc;
	struct fcnvme_ls_cr_conn_rqst rq_cr_conn;
	struct fcnvme_ls_disconnect_assoc_rqst rq_dis_assoc;
	struct fcnvme_ls_disconnect_conn_rqst rq_dis_conn;
};

union nvmefc_ls_responses {
	struct fcnvme_ls_rjt rsp_rjt;
	struct fcnvme_ls_cr_assoc_acc rsp_cr_assoc;
	struct fcnvme_ls_cr_conn_acc rsp_cr_conn;
	struct fcnvme_ls_disconnect_assoc_acc rsp_dis_assoc;
	struct fcnvme_ls_disconnect_conn_acc rsp_dis_conn;
};

struct nvmefc_ls_rsp {
	void *rspbuf;
	dma_addr_t rspdma;
	u16 rsplen;
	void (*done)(struct nvmefc_ls_rsp *);
	void *nvme_fc_private;
};

struct nvmem_cell_entry;

struct nvmem_cell {
	struct nvmem_cell_entry *entry;
	const char *id;
	int index;
};

typedef int (*nvmem_cell_post_process_t)(void *, const char *, int, unsigned int, void *, size_t);

struct nvmem_device;

struct nvmem_cell_entry {
	const char *name;
	int offset;
	size_t raw_len;
	int bytes;
	int bit_offset;
	int nbits;
	nvmem_cell_post_process_t read_post_process;
	void *priv;
	struct device_node *np;
	struct nvmem_device *nvmem;
	struct list_head node;
};

struct nvmem_cell_info {
	const char *name;
	unsigned int offset;
	size_t raw_len;
	unsigned int bytes;
	unsigned int bit_offset;
	unsigned int nbits;
	struct device_node *np;
	nvmem_cell_post_process_t read_post_process;
	void *priv;
};

struct nvmem_cell_lookup {
	const char *nvmem_name;
	const char *cell_name;
	const char *dev_id;
	const char *con_id;
	struct list_head node;
};

struct nvmem_cell_table {
	const char *nvmem_name;
	const struct nvmem_cell_info *cells;
	size_t ncells;
	struct list_head node;
};

typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);

struct nvmem_keepout;

struct nvmem_layout;

struct nvmem_config {
	struct device *dev;
	const char *name;
	int id;
	struct module *owner;
	const struct nvmem_cell_info *cells;
	int ncells;
	bool add_legacy_fixed_of_cells;
	void (*fixup_dt_cell_info)(struct nvmem_device *, struct nvmem_cell_info *);
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	enum nvmem_type type;
	bool read_only;
	bool root_only;
	bool ignore_wp;
	struct nvmem_layout *layout;
	struct device_node *of_node;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	int size;
	int word_size;
	int stride;
	void *priv;
	bool compat;
	struct device *base_dev;
};

struct nvmem_device {
	struct module *owner;
	struct device dev;
	struct list_head node;
	int stride;
	int word_size;
	int id;
	struct kref refcnt;
	size_t size;
	bool read_only;
	bool root_only;
	int flags;
	enum nvmem_type type;
	struct bin_attribute eeprom;
	struct device *base_dev;
	struct list_head cells;
	void (*fixup_dt_cell_info)(struct nvmem_device *, struct nvmem_cell_info *);
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	struct gpio_desc *wp_gpio;
	struct nvmem_layout *layout;
	void *priv;
	bool sysfs_cells_populated;
};

struct nvmem_keepout {
	unsigned int start;
	unsigned int end;
	unsigned char value;
};

struct nvmem_layout {
	struct device dev;
	struct nvmem_device *nvmem;
	int (*add_cells)(struct nvmem_layout *);
};

struct nvmet_fc_traddr {
	u64 nn;
	u64 pn;
};

struct nvmet_pr_acquire_data {
	__le64 crkey;
	__le64 prkey;
};

struct nvmet_pr_register_data {
	__le64 crkey;
	__le64 nrkey;
};

struct nvmet_pr_release_data {
	__le64 crkey;
};

struct nvmf_auth_dhchap_challenge_data {
	__u8 auth_type;
	__u8 auth_id;
	__u16 rsvd1;
	__le16 t_id;
	__u8 hl;
	__u8 rsvd2;
	__u8 hashid;
	__u8 dhgid;
	__le16 dhvlen;
	__le32 seqnum;
	__u8 cval[0];
};

struct nvmf_auth_dhchap_failure_data {
	__u8 auth_type;
	__u8 auth_id;
	__le16 rsvd1;
	__le16 t_id;
	__u8 rescode;
	__u8 rescode_exp;
};

struct nvmf_auth_dhchap_protocol_descriptor {
	__u8 authid;
	__u8 rsvd;
	__u8 halen;
	__u8 dhlen;
	__u8 idlist[60];
};

union nvmf_auth_protocol {
	struct nvmf_auth_dhchap_protocol_descriptor dhchap;
};

struct nvmf_auth_dhchap_negotiate_data {
	__u8 auth_type;
	__u8 auth_id;
	__le16 rsvd;
	__le16 t_id;
	__u8 sc_c;
	__u8 napd;
	union nvmf_auth_protocol auth_protocol[0];
};

struct nvmf_auth_dhchap_reply_data {
	__u8 auth_type;
	__u8 auth_id;
	__le16 rsvd1;
	__le16 t_id;
	__u8 hl;
	__u8 rsvd2;
	__u8 cvalid;
	__u8 rsvd3;
	__le16 dhvlen;
	__le32 seqnum;
	__u8 rval[0];
};

struct nvmf_auth_dhchap_success1_data {
	__u8 auth_type;
	__u8 auth_id;
	__le16 rsvd1;
	__le16 t_id;
	__u8 hl;
	__u8 rsvd2;
	__u8 rvalid;
	__u8 rsvd3[7];
	__u8 rval[0];
};

struct nvmf_auth_dhchap_success2_data {
	__u8 auth_type;
	__u8 auth_id;
	__le16 rsvd1;
	__le16 t_id;
	__u8 rsvd2[10];
};

struct nvmf_connect_data {
	uuid_t hostid;
	__le16 cntlid;
	char resv4[238];
	char subsysnqn[256];
	char hostnqn[256];
	char resv5[256];
};

struct nvmf_host;

struct nvmf_ctrl_options {
	unsigned int mask;
	int max_reconnects;
	char *transport;
	char *subsysnqn;
	char *traddr;
	char *trsvcid;
	char *host_traddr;
	char *host_iface;
	size_t queue_size;
	unsigned int nr_io_queues;
	unsigned int reconnect_delay;
	bool discovery_nqn;
	bool duplicate_connect;
	unsigned int kato;
	struct nvmf_host *host;
	char *dhchap_secret;
	char *dhchap_ctrl_secret;
	struct key *keyring;
	struct key *tls_key;
	bool tls;
	bool disable_sqflow;
	bool hdr_digest;
	bool data_digest;
	unsigned int nr_write_queues;
	unsigned int nr_poll_queues;
	int tos;
	int fast_io_fail_tmo;
};

struct nvmf_host {
	struct kref ref;
	struct list_head list;
	char nqn[223];
	uuid_t id;
};

struct nvmf_transport_ops {
	struct list_head entry;
	struct module *module;
	const char *name;
	int required_opts;
	int allowed_opts;
	struct nvme_ctrl * (*create_ctrl)(struct device *, struct nvmf_ctrl_options *);
};

struct nvram_ops {
	ssize_t (*get_size)(void);
	unsigned char (*read_byte)(int);
	void (*write_byte)(unsigned char, int);
	ssize_t (*read)(char *, size_t, loff_t *);
	ssize_t (*write)(char *, size_t, loff_t *);
	long int (*initialize)(void);
	long int (*set_checksum)(void);
};

struct nvs_page {
	long unsigned int phys_start;
	unsigned int size;
	void *kaddr;
	void *data;
	bool unmap;
	struct list_head node;
};

struct nvs_region {
	__u64 phys_start;
	__u64 size;
	struct list_head node;
};

struct obj_cgroup {
	struct percpu_ref refcnt;
	struct mem_cgroup *memcg;
	atomic_t nr_charged_bytes;
	union {
		struct list_head list;
		struct callback_head rcu;
	};
};

struct objpool_head;

typedef int (*objpool_fini_cb)(struct objpool_head *, void *);

struct objpool_slot;

struct objpool_head {
	int obj_size;
	int nr_objs;
	int nr_possible_cpus;
	int capacity;
	gfp_t gfp;
	refcount_t ref;
	long unsigned int flags;
	struct objpool_slot **cpu_slots;
	objpool_fini_cb release;
	void *context;
};

struct objpool_slot {
	uint32_t head;
	uint32_t tail;
	uint32_t last;
	uint32_t mask;
	void *entries[0];
};

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

struct od_dbs_tuners {
	unsigned int powersave_bias;
};

struct od_ops {
	unsigned int (*powersave_bias_target)(struct cpufreq_policy *, unsigned int, unsigned int);
};

struct policy_dbs_info {
	struct cpufreq_policy *policy;
	struct mutex update_mutex;
	u64 last_sample_time;
	s64 sample_delay_ns;
	atomic_t work_count;
	struct irq_work irq_work;
	struct work_struct work;
	struct dbs_data *dbs_data;
	struct list_head list;
	unsigned int rate_mult;
	unsigned int idle_periods;
	bool is_shared;
	bool work_in_progress;
};

struct od_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int freq_lo;
	unsigned int freq_lo_delay_us;
	unsigned int freq_hi_delay_us;
	unsigned int sample_type: 1;
};

struct of_device_id {
	char name[32];
	char type[32];
	char compatible[128];
	const void *data;
};

struct of_phandle_args {
	struct device_node *np;
	int args_count;
	uint32_t args[16];
};

struct offset_ctx {
	struct maple_tree mt;
	long unsigned int next_offset;
};

struct old_timespec32 {
	old_time32_t tv_sec;
	s32 tv_nsec;
};

struct old_itimerspec32 {
	struct old_timespec32 it_interval;
	struct old_timespec32 it_value;
};

struct old_linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_offset;
	short unsigned int d_namlen;
	char d_name[0];
};

struct old_serial_port {
	unsigned int uart;
	unsigned int baud_base;
	unsigned int port;
	unsigned int irq;
	upf_t flags;
	unsigned char io_type;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
};

struct old_timeval32 {
	old_time32_t tv_sec;
	s32 tv_usec;
};

struct old_timex32 {
	u32 modes;
	s32 offset;
	s32 freq;
	s32 maxerror;
	s32 esterror;
	s32 status;
	s32 constant;
	s32 precision;
	s32 tolerance;
	struct old_timeval32 time;
	s32 tick;
	s32 ppsfreq;
	s32 jitter;
	s32 shift;
	s32 stabil;
	s32 jitcnt;
	s32 calcnt;
	s32 errcnt;
	s32 stbcnt;
	s32 tai;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct old_utimbuf32 {
	old_time32_t actime;
	old_time32_t modtime;
};

struct old_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
};

struct oldold_utsname {
	char sysname[9];
	char nodename[9];
	char release[9];
	char version[9];
	char machine[9];
};

struct once_work {
	struct work_struct work;
	struct static_key_true *key;
	struct module *module;
};

struct online_data {
	unsigned int cpu;
	bool online;
};

struct oom_control {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct mem_cgroup *memcg;
	const gfp_t gfp_mask;
	const int order;
	long unsigned int totalpages;
	struct task_struct *chosen;
	long int chosen_points;
	enum oom_constraint constraint;
};

struct open_flags {
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;
};

struct opregion_acpi {
	u32 drdy;
	u32 csts;
	u32 cevt;
	u8 rsvd1[20];
	u32 didl[8];
	u32 cpdl[8];
	u32 cadl[8];
	u32 nadl[8];
	u32 aslp;
	u32 tidx;
	u32 chpd;
	u32 clid;
	u32 cdck;
	u32 sxsw;
	u32 evts;
	u32 cnot;
	u32 nrdy;
	u32 did2[7];
	u32 cpd2[7];
	u8 rsvd2[4];
};

struct opregion_asle {
	u32 ardy;
	u32 aslc;
	u32 tche;
	u32 alsi;
	u32 bclp;
	u32 pfit;
	u32 cblv;
	u16 bclm[20];
	u32 cpfm;
	u32 epfm;
	u8 plut[74];
	u32 pfmb;
	u32 cddv;
	u32 pcft;
	u32 srot;
	u32 iuer;
	u64 fdss;
	u32 fdsp;
	u32 stat;
	u64 rvda;
	u32 rvds;
	u8 rsvd[58];
} __attribute__((packed));

struct opregion_asle_ext {
	u32 phed;
	u8 bddc[256];
	u8 rsvd[764];
};

struct opregion_header {
	u8 signature[16];
	u32 size;
	struct {
		u8 rsvd;
		u8 revision;
		u8 minor;
		u8 major;
	} over;
	u8 bios_ver[32];
	u8 vbios_ver[16];
	u8 driver_ver[16];
	u32 mboxes;
	u32 driver_model;
	u32 pcon;
	u8 dver[32];
	u8 rsvd[124];
};

struct opregion_swsci {
	u32 scic;
	u32 parm;
	u32 dslp;
	u8 rsvd[244];
};

struct optimistic_spin_node {
	struct optimistic_spin_node *next;
	struct optimistic_spin_node *prev;
	int locked;
	int cpu;
};

struct optimized_kprobe {
	struct kprobe kp;
	struct list_head list;
	struct arch_optimized_insn optinsn;
};

struct orc_entry {
	s16 sp_offset;
	s16 bp_offset;
	unsigned int sp_reg: 4;
	unsigned int bp_reg: 4;
	unsigned int type: 3;
	unsigned int signal: 1;
} __attribute__((packed));

struct orlov_stats {
	__u64 free_clusters;
	__u32 free_inodes;
	__u32 used_dirs;
};

struct orphan_dir_info {
	struct rb_node node;
	u64 ino;
	u64 gen;
	u64 last_dir_index_offset;
	u64 dir_high_seq_ino;
};

struct osnoise_entry {
	struct trace_entry ent;
	u64 noise;
	u64 runtime;
	u64 max_sample;
	unsigned int hw_count;
	unsigned int nmi_count;
	unsigned int irq_count;
	unsigned int softirq_count;
	unsigned int thread_count;
};

struct tipc_socket_addr {
	__u32 ref;
	__u32 node;
};

struct tipc_service_range {
	__u32 type;
	__u32 lower;
	__u32 upper;
};

struct tipc_subscr {
	struct tipc_service_range seq;
	__u32 timeout;
	__u32 filter;
	char usr_handle[8];
};

struct tipc_event {
	__u32 event;
	__u32 found_lower;
	__u32 found_upper;
	struct tipc_socket_addr port;
	struct tipc_subscr s;
};

struct outqueue_entry {
	bool inactive;
	struct tipc_event evt;
	struct list_head list;
};

struct x86_cpu_id {
	__u16 vendor;
	__u16 family;
	__u16 model;
	__u16 steppings;
	__u16 feature;
	__u16 flags;
	kernel_ulong_t driver_data;
};

struct override_status_id {
	struct acpi_device_id hid[2];
	struct x86_cpu_id cpu_ids[2];
	struct dmi_system_id dmi_ids[2];
	const char *uid;
	const char *path;
	long long unsigned int status;
};

struct ovl_cache_entry {
	unsigned int len;
	unsigned int type;
	u64 real_ino;
	u64 ino;
	struct list_head l_node;
	struct rb_node node;
	struct ovl_cache_entry *next_maybe_whiteout;
	bool is_upper;
	bool is_whiteout;
	bool check_xwhiteout;
	char name[0];
};

struct ovl_cattr {
	dev_t rdev;
	umode_t mode;
	const char *link;
	struct dentry *hardlink;
};

struct ovl_config {
	char *upperdir;
	char *workdir;
	char **lowerdirs;
	bool default_permissions;
	int redirect_mode;
	int verity_mode;
	bool index;
	int uuid;
	bool nfs_export;
	int xino;
	bool metacopy;
	bool userxattr;
	bool ovl_volatile;
};

struct ovl_fh;

struct ovl_copy_up_ctx {
	struct dentry *parent;
	struct dentry *dentry;
	struct path lowerpath;
	struct kstat stat;
	struct kstat pstat;
	const char *link;
	struct dentry *destdir;
	struct qstr destname;
	struct dentry *workdir;
	const struct ovl_fh *origin_fh;
	bool origin;
	bool indexed;
	bool metacopy;
	bool metacopy_digest;
	bool metadata_fsync;
};

struct ovl_cu_creds {
	const struct cred *old;
	struct cred *new;
};

struct ovl_dir_cache {
	long int refcount;
	u64 version;
	struct list_head entries;
	struct rb_root root;
};

struct ovl_dir_file {
	bool is_real;
	bool is_upper;
	struct ovl_dir_cache *cache;
	struct list_head *cursor;
	struct file *realfile;
	struct file *upperfile;
};

struct ovl_layer;

struct ovl_path {
	const struct ovl_layer *layer;
	struct dentry *dentry;
};

struct ovl_entry {
	unsigned int __numlower;
	struct ovl_path __lowerstack[0];
};

struct ovl_fb {
	u8 version;
	u8 magic;
	u8 len;
	u8 flags;
	u8 type;
	uuid_t uuid;
	u32 fid[0];
} __attribute__((packed));

struct ovl_fh {
	u8 padding[3];
	union {
		struct ovl_fb fb;
		struct {
			struct {} __empty_buf;
			u8 buf[0];
		};
	};
};

struct ovl_file {
	struct file *realfile;
	struct file *upperfile;
};

struct ovl_sb;

struct ovl_fs {
	unsigned int numlayer;
	unsigned int numfs;
	unsigned int numdatalayer;
	struct ovl_layer *layers;
	struct ovl_sb *fs;
	struct dentry *workbasedir;
	struct dentry *workdir;
	long int namelen;
	struct ovl_config config;
	const struct cred *creator_cred;
	bool tmpfile;
	bool noxattr;
	bool nofh;
	bool upperdir_locked;
	bool workdir_locked;
	struct inode *workbasedir_trap;
	struct inode *workdir_trap;
	int xino_mode;
	atomic_long_t last_ino;
	struct dentry *whiteout;
	bool no_shared_whiteout;
	errseq_t errseq;
};

struct ovl_opt_set {
	bool metacopy;
	bool redirect;
	bool nfs_export;
	bool index;
};

struct ovl_fs_context_layer;

struct ovl_fs_context {
	struct path upper;
	struct path work;
	size_t capacity;
	size_t nr;
	size_t nr_data;
	struct ovl_opt_set set;
	struct ovl_fs_context_layer *lower;
	char *lowerdir_all;
};

struct ovl_fs_context_layer {
	char *name;
	struct path path;
};

struct ovl_inode {
	union {
		struct ovl_dir_cache *cache;
		const char *lowerdata_redirect;
	};
	const char *redirect;
	u64 version;
	long unsigned int flags;
	struct inode vfs_inode;
	struct dentry *__upperdentry;
	struct ovl_entry *oe;
	struct mutex lock;
};

struct ovl_inode_params {
	struct inode *newinode;
	struct dentry *upperdentry;
	struct ovl_entry *oe;
	bool index;
	char *redirect;
	char *lowerdata_redirect;
};

struct ovl_layer {
	struct vfsmount *mnt;
	struct inode *trap;
	struct ovl_sb *fs;
	int idx;
	int fsid;
	bool has_xwhiteouts;
};

struct ovl_lookup_data {
	struct super_block *sb;
	const struct ovl_layer *layer;
	struct qstr name;
	bool is_dir;
	bool opaque;
	bool xwhiteouts;
	bool stop;
	bool last;
	char *redirect;
	int metacopy;
	bool absolute_redirect;
};

struct ovl_metacopy {
	u8 version;
	u8 len;
	u8 flags;
	u8 digest_algo;
	u8 digest[64];
};

struct ovl_readdir_data {
	struct dir_context ctx;
	struct dentry *dentry;
	bool is_lowest;
	struct rb_root *root;
	struct list_head *list;
	struct list_head middle;
	struct ovl_cache_entry *first_maybe_whiteout;
	int count;
	int err;
	bool is_upper;
	bool d_type_supported;
	bool in_xwhiteouts_dir;
};

struct ovl_readdir_translate {
	struct dir_context *orig_ctx;
	struct ovl_dir_cache *cache;
	struct dir_context ctx;
	u64 parent_ino;
	int fsid;
	int xinobits;
	bool xinowarn;
};

struct ovl_sb {
	struct super_block *sb;
	dev_t pseudo_dev;
	bool bad_uuid;
	bool is_lower;
};

struct ovs_action_add_mpls {
	__be32 mpls_lse;
	__be16 mpls_ethertype;
	__u16 tun_flags;
};

struct ovs_action_hash {
	__u32 hash_alg;
	__u32 hash_basis;
};

struct ovs_key_ethernet {
	__u8 eth_src[6];
	__u8 eth_dst[6];
};

struct ovs_action_push_eth {
	struct ovs_key_ethernet addresses;
};

struct ovs_action_push_mpls {
	__be32 mpls_lse;
	__be16 mpls_ethertype;
};

struct ovs_action_push_vlan {
	__be16 vlan_tpid;
	__be16 vlan_tci;
};

struct ovs_action_trunc {
	__u32 max_len;
};

struct ovs_conntrack_info {
	struct nf_conntrack_helper *helper;
	struct nf_conntrack_zone zone;
	struct nf_conn *ct;
	u8 commit: 1;
	u8 nat: 3;
	u8 force: 1;
	u8 have_eventmask: 1;
	u16 family;
	u32 eventmask;
	struct md_mark mark;
	struct md_labels labels;
	char timeout[32];
	struct nf_ct_timeout *nf_ct_timeout;
	struct nf_nat_range2 range;
};

struct ovs_ct_len_tbl {
	int maxlen;
	int minlen;
};

struct ovs_ct_limit {
	struct hlist_node hlist_node;
	struct callback_head rcu;
	u16 zone;
	u32 limit;
};

struct ovs_ct_limit_info {
	u32 default_limit;
	struct hlist_head *limits;
	struct nf_conncount_data *data;
};

struct ovs_dp_megaflow_stats {
	__u64 n_mask_hit;
	__u32 n_masks;
	__u32 pad0;
	__u64 n_cache_hit;
	__u64 pad1;
};

struct ovs_dp_stats {
	__u64 n_hit;
	__u64 n_missed;
	__u64 n_lost;
	__u64 n_flows;
};

struct ovs_skb_cb {
	struct vport *input_vport;
	u16 mru;
	u16 acts_origlen;
	u32 cutlen;
	u32 probability;
};

struct ovs_frag_data {
	long unsigned int dst;
	struct vport *vport;
	struct ovs_skb_cb cb;
	__be16 inner_protocol;
	u16 network_offset;
	u16 vlan_tci;
	__be16 vlan_proto;
	unsigned int l2_len;
	u8 mac_proto;
	u8 l2_data[30];
};

struct ovs_header {
	int dp_ifindex;
};

struct ovs_key_arp {
	__be32 arp_sip;
	__be32 arp_tip;
	__be16 arp_op;
	__u8 arp_sha[6];
	__u8 arp_tha[6];
};

struct ovs_key_ct_tuple_ipv4 {
	__be32 ipv4_src;
	__be32 ipv4_dst;
	__be16 src_port;
	__be16 dst_port;
	__u8 ipv4_proto;
};

struct ovs_key_ct_tuple_ipv6 {
	__be32 ipv6_src[4];
	__be32 ipv6_dst[4];
	__be16 src_port;
	__be16 dst_port;
	__u8 ipv6_proto;
};

struct ovs_key_icmp {
	__u8 icmp_type;
	__u8 icmp_code;
};

struct ovs_key_icmpv6 {
	__u8 icmpv6_type;
	__u8 icmpv6_code;
};

struct ovs_key_ipv4 {
	__be32 ipv4_src;
	__be32 ipv4_dst;
	__u8 ipv4_proto;
	__u8 ipv4_tos;
	__u8 ipv4_ttl;
	__u8 ipv4_frag;
};

struct ovs_key_ipv6 {
	__be32 ipv6_src[4];
	__be32 ipv6_dst[4];
	__be32 ipv6_label;
	__u8 ipv6_proto;
	__u8 ipv6_tclass;
	__u8 ipv6_hlimit;
	__u8 ipv6_frag;
};

struct ovs_key_ipv6_exthdrs {
	__u16 hdrs;
};

struct ovs_key_mpls {
	__be32 mpls_lse;
};

struct ovs_key_nd {
	__be32 nd_target[4];
	__u8 nd_sll[6];
	__u8 nd_tll[6];
};

struct ovs_key_sctp {
	__be16 sctp_src;
	__be16 sctp_dst;
};

struct ovs_key_tcp {
	__be16 tcp_src;
	__be16 tcp_dst;
};

struct ovs_key_udp {
	__be16 udp_src;
	__be16 udp_dst;
};

struct ovs_len_tbl {
	int len;
	const struct ovs_len_tbl *next;
};

struct ovs_net {
	struct list_head dps;
	struct work_struct dp_notify_work;
	struct delayed_work masks_rebalance;
	struct ovs_ct_limit_info *ct_limit_info;
	bool xt_label;
};

struct ovs_nsh_key_md1 {
	__be32 context[4];
};

struct ovs_tunnel_info {
	struct metadata_dst *tun_dst;
};

struct ovs_vport_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct ovs_zone_limit {
	int zone_id;
	__u32 limit;
	__u32 count;
};

struct p2sb_res_cache {
	u32 bus_dev_id;
	struct resource res;
};

struct p4_event_alias {
	u64 original;
	u64 alternative;
};

struct p4_event_bind {
	unsigned int opcode;
	unsigned int escr_msr[2];
	unsigned int escr_emask;
	unsigned int shared;
	signed char cntr[6];
};

struct p4_pebs_bind {
	unsigned int metric_pebs;
	unsigned int metric_vert;
};

struct p9_trans_module;

struct p9_client {
	spinlock_t lock;
	unsigned int msize;
	unsigned char proto_version;
	struct p9_trans_module *trans_mod;
	enum p9_trans_status status;
	void *trans;
	struct kmem_cache *fcall_cache;
	union {
		struct {
			int rfd;
			int wfd;
		} fd;
		struct {
			u16 port;
			bool privport;
		} tcp;
	} trans_opts;
	struct idr fids;
	struct idr reqs;
	char name[65];
};

struct p9_fcall {
	u32 size;
	u8 id;
	u16 tag;
	size_t offset;
	size_t capacity;
	struct kmem_cache *cache;
	u8 *sdata;
	bool zc;
};

struct p9_conn;

struct p9_poll_wait {
	struct p9_conn *conn;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_addr;
};

struct p9_req_t;

struct p9_conn {
	struct list_head mux_list;
	struct p9_client *client;
	int err;
	spinlock_t req_lock;
	struct list_head req_list;
	struct list_head unsent_req_list;
	struct p9_req_t *rreq;
	struct p9_req_t *wreq;
	char tmp_buf[7];
	struct p9_fcall rc;
	int wpos;
	int wsize;
	char *wbuf;
	struct list_head poll_pending_link;
	struct p9_poll_wait poll_wait[2];
	poll_table pt;
	struct work_struct rq;
	struct work_struct wq;
	long unsigned int wsched;
};

struct p9_qid {
	u8 type;
	u32 version;
	u64 path;
};

struct p9_dirent {
	struct p9_qid qid;
	u64 d_off;
	unsigned char d_type;
	char d_name[256];
};

struct p9_fd_opts {
	int rfd;
	int wfd;
	u16 port;
	bool privport;
};

struct p9_fid {
	struct p9_client *clnt;
	u32 fid;
	refcount_t count;
	int mode;
	struct p9_qid qid;
	u32 iounit;
	kuid_t uid;
	void *rdir;
	struct hlist_node dlist;
	struct hlist_node ilist;
};

struct p9_flock {
	u8 type;
	u32 flags;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_getlock {
	u8 type;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_iattr_dotl {
	u32 valid;
	u32 mode;
	kuid_t uid;
	kgid_t gid;
	u64 size;
	u64 atime_sec;
	u64 atime_nsec;
	u64 mtime_sec;
	u64 mtime_nsec;
};

struct p9_rdir {
	int head;
	int tail;
	uint8_t buf[0];
};

struct p9_req_t {
	int status;
	int t_err;
	refcount_t refcount;
	wait_queue_head_t wq;
	struct p9_fcall tc;
	struct p9_fcall rc;
	struct list_head req_list;
};

struct p9_rstatfs {
	u32 type;
	u32 bsize;
	u64 blocks;
	u64 bfree;
	u64 bavail;
	u64 files;
	u64 ffree;
	u64 fsid;
	u32 namelen;
};

struct p9_stat_dotl {
	u64 st_result_mask;
	struct p9_qid qid;
	u32 st_mode;
	kuid_t st_uid;
	kgid_t st_gid;
	u64 st_nlink;
	u64 st_rdev;
	u64 st_size;
	u64 st_blksize;
	u64 st_blocks;
	u64 st_atime_sec;
	u64 st_atime_nsec;
	u64 st_mtime_sec;
	u64 st_mtime_nsec;
	u64 st_ctime_sec;
	u64 st_ctime_nsec;
	u64 st_btime_sec;
	u64 st_btime_nsec;
	u64 st_gen;
	u64 st_data_version;
};

struct p9_trans_fd {
	struct file *rd;
	struct file *wr;
	struct p9_conn conn;
};

struct p9_trans_module {
	struct list_head list;
	char *name;
	int maxsize;
	bool pooled_rbuffers;
	int def;
	struct module *owner;
	int (*create)(struct p9_client *, const char *, char *);
	void (*close)(struct p9_client *);
	int (*request)(struct p9_client *, struct p9_req_t *);
	int (*cancel)(struct p9_client *, struct p9_req_t *);
	int (*cancelled)(struct p9_client *, struct p9_req_t *);
	int (*zc_request)(struct p9_client *, struct p9_req_t *, struct iov_iter *, struct iov_iter *, int, int, int);
	int (*show_options)(struct seq_file *, struct p9_client *);
};

struct p9_wstat {
	u16 size;
	u16 type;
	u32 dev;
	struct p9_qid qid;
	u32 mode;
	u32 atime;
	u32 mtime;
	u64 length;
	const char *name;
	const char *uid;
	const char *gid;
	const char *muid;
	char *extension;
	kuid_t n_uid;
	kgid_t n_gid;
	kuid_t n_muid;
};

struct pacct_struct {
	int ac_flag;
	long int ac_exitcode;
	long unsigned int ac_mem;
	u64 ac_utime;
	u64 ac_stime;
	long unsigned int ac_minflt;
	long unsigned int ac_majflt;
};

struct scsi_sense_hdr;

struct packet_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct scsi_sense_hdr *sshdr;
	unsigned char data_direction;
	int quiet;
	int timeout;
	void *reserved[1];
};

struct packet_diag_info {
	__u32 pdi_index;
	__u32 pdi_version;
	__u32 pdi_reserve;
	__u32 pdi_copy_thresh;
	__u32 pdi_tstamp;
	__u32 pdi_flags;
};

struct packet_diag_mclist {
	__u32 pdmc_index;
	__u32 pdmc_count;
	__u16 pdmc_type;
	__u16 pdmc_alen;
	__u8 pdmc_addr[32];
};

struct packet_diag_msg {
	__u8 pdiag_family;
	__u8 pdiag_type;
	__u16 pdiag_num;
	__u32 pdiag_ino;
	__u32 pdiag_cookie[2];
};

struct packet_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 pdiag_ino;
	__u32 pdiag_show;
	__u32 pdiag_cookie[2];
};

struct packet_diag_ring {
	__u32 pdr_block_size;
	__u32 pdr_block_nr;
	__u32 pdr_frame_size;
	__u32 pdr_frame_nr;
	__u32 pdr_retire_tmo;
	__u32 pdr_sizeof_priv;
	__u32 pdr_features;
};

struct packet_fanout {
	possible_net_t net;
	unsigned int num_members;
	u32 max_num_members;
	u16 id;
	u8 type;
	u8 flags;
	union {
		atomic_t rr_cur;
		struct bpf_prog *bpf_prog;
	};
	struct list_head list;
	spinlock_t lock;
	refcount_t sk_ref;
	long: 64;
	struct packet_type prot_hook;
	struct sock *arr[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_mclist {
	struct packet_mclist *next;
	int ifindex;
	int count;
	short unsigned int type;
	short unsigned int alen;
	unsigned char addr[32];
};

struct packet_mreq_max {
	int mr_ifindex;
	short unsigned int mr_type;
	short unsigned int mr_alen;
	unsigned char mr_address[32];
};

struct pgv;

struct tpacket_kbdq_core {
	struct pgv *pkbdq;
	unsigned int feature_req_word;
	unsigned int hdrlen;
	unsigned char reset_pending_on_curr_blk;
	unsigned char delete_blk_timer;
	short unsigned int kactive_blk_num;
	short unsigned int blk_sizeof_priv;
	short unsigned int last_kactive_blk_num;
	char *pkblk_start;
	char *pkblk_end;
	int kblk_size;
	unsigned int max_frame_len;
	unsigned int knum_blocks;
	uint64_t knxt_seq_num;
	char *prev;
	char *nxt_offset;
	struct sk_buff *skb;
	rwlock_t blk_fill_in_prog_lock;
	short unsigned int retire_blk_tov;
	short unsigned int version;
	long unsigned int tov_in_jiffies;
	struct timer_list retire_blk_timer;
};

struct packet_ring_buffer {
	struct pgv *pg_vec;
	unsigned int head;
	unsigned int frames_per_block;
	unsigned int frame_size;
	unsigned int frame_max;
	unsigned int pg_vec_order;
	unsigned int pg_vec_pages;
	unsigned int pg_vec_len;
	unsigned int *pending_refcnt;
	union {
		long unsigned int *rx_owner_map;
		struct tpacket_kbdq_core prb_bdqc;
	};
};

struct packet_rollover {
	int sock;
	atomic_long_t num;
	atomic_long_t num_huge;
	atomic_long_t num_failed;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 history[16];
};

struct sockaddr_pkt {
	short unsigned int spkt_family;
	unsigned char spkt_device[14];
	__be16 spkt_protocol;
};

struct sockaddr_ll {
	short unsigned int sll_family;
	__be16 sll_protocol;
	int sll_ifindex;
	short unsigned int sll_hatype;
	unsigned char sll_pkttype;
	unsigned char sll_halen;
	unsigned char sll_addr[8];
};

struct packet_skb_cb {
	union {
		struct sockaddr_pkt pkt;
		union {
			unsigned int origlen;
			struct sockaddr_ll ll;
		};
	} sa;
};

struct tpacket_stats {
	unsigned int tp_packets;
	unsigned int tp_drops;
};

struct tpacket_stats_v3 {
	unsigned int tp_packets;
	unsigned int tp_drops;
	unsigned int tp_freeze_q_cnt;
};

union tpacket_stats_u {
	struct tpacket_stats stats1;
	struct tpacket_stats_v3 stats3;
};

struct packet_sock {
	struct sock sk;
	struct packet_fanout *fanout;
	union tpacket_stats_u stats;
	struct packet_ring_buffer rx_ring;
	struct packet_ring_buffer tx_ring;
	int copy_thresh;
	spinlock_t bind_lock;
	struct mutex pg_vec_lock;
	long unsigned int flags;
	int ifindex;
	u8 vnet_hdr_sz;
	__be16 num;
	struct packet_rollover *rollover;
	struct packet_mclist *mclist;
	atomic_long_t mapped;
	enum tpacket_versions tp_version;
	unsigned int tp_hdrlen;
	unsigned int tp_reserve;
	unsigned int tp_tstamp;
	struct completion skb_completion;
	struct net_device *cached_dev;
	long: 64;
	long: 64;
	struct packet_type prot_hook;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t tp_drops;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct padata_cpumask {
	cpumask_var_t pcpu;
	cpumask_var_t cbcpu;
};

struct padata_instance {
	struct hlist_node cpu_online_node;
	struct hlist_node cpu_dead_node;
	struct workqueue_struct *parallel_wq;
	struct workqueue_struct *serial_wq;
	struct list_head pslist;
	struct padata_cpumask cpumask;
	struct kobject kobj;
	struct mutex lock;
	u8 flags;
};

struct padata_list {
	struct list_head list;
	spinlock_t lock;
};

struct padata_mt_job {
	void (*thread_fn)(long unsigned int, long unsigned int, void *);
	void *fn_arg;
	long unsigned int start;
	long unsigned int size;
	long unsigned int align;
	long unsigned int min_chunk;
	int max_threads;
	bool numa_aware;
};

struct padata_mt_job_state {
	spinlock_t lock;
	struct completion completion;
	struct padata_mt_job *job;
	int nworks;
	int nworks_fini;
	long unsigned int chunk_size;
};

struct parallel_data;

struct padata_priv {
	struct list_head list;
	struct parallel_data *pd;
	int cb_cpu;
	unsigned int seq_nr;
	int info;
	void (*parallel)(struct padata_priv *);
	void (*serial)(struct padata_priv *);
};

struct padata_serial_queue {
	struct padata_list serial;
	struct work_struct work;
	struct parallel_data *pd;
};

struct padata_shell {
	struct padata_instance *pinst;
	struct parallel_data *pd;
	struct parallel_data *opd;
	struct list_head list;
};

struct padata_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct padata_instance *, struct attribute *, char *);
	ssize_t (*store)(struct padata_instance *, struct attribute *, const char *, size_t);
};

struct padata_work {
	struct work_struct pw_work;
	struct list_head pw_list;
	void *pw_data;
};

typedef struct page *pgtable_t;

struct page_ext {
	long unsigned int flags;
};

struct page_ext_operations {
	size_t offset;
	size_t size;
	bool (*need)(void);
	void (*init)(void);
	bool need_shared_flags;
};

struct printf_spec;

struct page_flags_fields {
	int width;
	int shift;
	int mask;
	const struct printf_spec *spec;
	const char *name;
};

struct page_list {
	struct page_list *next;
	struct page *page;
};

struct page_pool_params_fast {
	unsigned int order;
	unsigned int pool_size;
	int nid;
	struct device *dev;
	struct napi_struct *napi;
	enum dma_data_direction dma_dir;
	unsigned int max_len;
	unsigned int offset;
};

struct pp_alloc_cache {
	u32 count;
	netmem_ref cache[128];
};

struct ptr_ring {
	int producer;
	spinlock_t producer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int consumer_head;
	int consumer_tail;
	spinlock_t consumer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int size;
	int batch;
	void **queue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct page_pool_params_slow {
	struct net_device *netdev;
	unsigned int queue_idx;
	unsigned int flags;
	void (*init_callback)(netmem_ref, void *);
	void *init_arg;
};

struct page_pool {
	struct page_pool_params_fast p;
	int cpuid;
	u32 pages_state_hold_cnt;
	bool has_init_callback: 1;
	bool dma_map: 1;
	bool dma_sync: 1;
	bool dma_sync_for_cpu: 1;
	long: 0;
	__u8 __cacheline_group_begin__frag[0];
	long int frag_users;
	netmem_ref frag_page;
	unsigned int frag_offset;
	long: 0;
	__u8 __cacheline_group_end__frag[0];
	long: 64;
	struct {} __cacheline_group_pad__frag;
	struct delayed_work release_dw;
	void (*disconnect)(void *);
	long unsigned int defer_start;
	long unsigned int defer_warn;
	u32 xdp_mem_id;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct pp_alloc_cache alloc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring ring;
	void *mp_priv;
	atomic_t pages_state_release_cnt;
	refcount_t user_cnt;
	u64 destroy_cnt;
	struct page_pool_params_slow slow;
	struct {
		struct hlist_node list;
		u64 detach_time;
		u32 id;
	} user;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct page_pool_dump_cb {
	long unsigned int ifindex;
	u32 pp_id;
};

struct page_pool_params {
	union {
		struct {
			unsigned int order;
			unsigned int pool_size;
			int nid;
			struct device *dev;
			struct napi_struct *napi;
			enum dma_data_direction dma_dir;
			unsigned int max_len;
			unsigned int offset;
		};
		struct page_pool_params_fast fast;
	};
	union {
		struct {
			struct net_device *netdev;
			unsigned int queue_idx;
			unsigned int flags;
			void (*init_callback)(netmem_ref, void *);
			void *init_arg;
		};
		struct page_pool_params_slow slow;
	};
};

struct page_region {
	__u64 start;
	__u64 end;
	__u64 categories;
};

struct page_req_dsc {
	union {
		struct {
			u64 type: 8;
			u64 pasid_present: 1;
			u64 rsvd: 7;
			u64 rid: 16;
			u64 pasid: 20;
			u64 exe_req: 1;
			u64 pm_req: 1;
			u64 rsvd2: 10;
		};
		u64 qw_0;
	};
	union {
		struct {
			u64 rd_req: 1;
			u64 wr_req: 1;
			u64 lpig: 1;
			u64 prg_index: 9;
			u64 addr: 52;
		};
		u64 qw_1;
	};
	u64 qw_2;
	u64 qw_3;
};

struct page_table_check {
	atomic_t anon_map_count;
	atomic_t file_map_count;
};

struct page_vma_mapped_walk {
	long unsigned int pfn;
	long unsigned int nr_pages;
	long unsigned int pgoff;
	struct vm_area_struct *vma;
	long unsigned int address;
	pmd_t *pmd;
	pte_t *pte;
	spinlock_t *ptl;
	unsigned int flags;
};

struct pm_scan_arg {
	__u64 size;
	__u64 flags;
	__u64 start;
	__u64 end;
	__u64 walk_end;
	__u64 vec;
	__u64 vec_len;
	__u64 max_pages;
	__u64 category_inverted;
	__u64 category_mask;
	__u64 category_anyof_mask;
	__u64 return_mask;
};

struct pagemap_scan_private {
	struct pm_scan_arg arg;
	long unsigned int masks_of_interest;
	long unsigned int cur_vma_category;
	struct page_region *vec_buf;
	long unsigned int vec_buf_len;
	long unsigned int vec_buf_index;
	long unsigned int found_pages;
	struct page_region *vec_out;
};

struct pagemapread {
	int pos;
	int len;
	pagemap_entry_t *buffer;
	bool show_pfn;
};

struct pagerange_state {
	long unsigned int cur_pfn;
	int ram;
	int not_ram;
};

struct pages_devres {
	long unsigned int addr;
	unsigned int order;
};

struct pages_or_folios {
	union {
		struct page **pages;
		struct folio **folios;
		void **entries;
	};
	bool has_folios;
	long int nr_entries;
};

struct panel_bridge {
	struct drm_bridge bridge;
	struct drm_connector connector;
	struct drm_panel *panel;
	u32 connector_type;
};

struct parallel_data {
	struct padata_shell *ps;
	struct padata_list *reorder_list;
	struct padata_serial_queue *squeue;
	refcount_t refcnt;
	unsigned int seq_nr;
	unsigned int processed;
	int cpu;
	struct padata_cpumask cpumask;
	struct work_struct reorder_work;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct thermal_genl_cpu_caps;

struct param {
	struct nlattr **attrs;
	struct sk_buff *msg;
	const char *name;
	int tz_id;
	int cdev_id;
	int trip_id;
	int trip_temp;
	int trip_type;
	int trip_hyst;
	int temp;
	int prev_temp;
	int direction;
	int cdev_state;
	int cdev_max_state;
	struct thermal_genl_cpu_caps *cpu_capabilities;
	int cpu_capabilities_count;
};

struct paravirt_callee_save {
	void *func;
};

struct pv_cpu_ops {
	void (*io_delay)(void);
};

struct pv_irq_ops {
	void (*safe_halt)(void);
	void (*halt)(void);
};

struct pv_mmu_ops {
	void (*flush_tlb_user)(void);
	void (*flush_tlb_kernel)(void);
	void (*flush_tlb_one_user)(long unsigned int);
	void (*flush_tlb_multi)(const struct cpumask *, const struct flush_tlb_info *);
	void (*tlb_remove_table)(struct mmu_gather *, void *);
	void (*exit_mmap)(struct mm_struct *);
	void (*notify_page_enc_status_changed)(long unsigned int, int, bool);
};

struct pv_lock_ops {
	void (*queued_spin_lock_slowpath)(struct qspinlock *, u32);
	struct paravirt_callee_save queued_spin_unlock;
	void (*wait)(u8 *, u8);
	void (*kick)(int);
	struct paravirt_callee_save vcpu_is_preempted;
};

struct paravirt_patch_template {
	struct pv_cpu_ops cpu;
	struct pv_irq_ops irq;
	struct pv_mmu_ops mmu;
	struct pv_lock_ops lock;
};

struct sync_semaphore {
	u32 semaphore;
	u8 unused[60];
};

struct parent_scratch {
	union guc_descs descs;
	struct sync_semaphore go;
	struct sync_semaphore join[9];
	u8 unused[1216];
	u32 wq[512];
};

struct partition_meta_info {
	char uuid[37];
	u8 volname[64];
};

struct parsed_partitions {
	struct gendisk *disk;
	char name[32];
	struct {
		sector_t from;
		sector_t size;
		int flags;
		bool has_info;
		struct partition_meta_info info;
	} *parts;
	int next;
	int limit;
	bool access_beyond_eod;
	char *pp_buf;
};

struct partial_cluster {
	ext4_fsblk_t pclu;
	ext4_lblk_t lblk;
	enum {
		initial = 0,
		tofree = 1,
		nofree = 2,
	} state;
};

struct partial_context {
	gfp_t flags;
	unsigned int orig_size;
	void *object;
};

struct partial_page {
	unsigned int offset;
	unsigned int len;
	long unsigned int private;
};

struct pasid_dir_entry {
	u64 val;
};

struct pasid_entry {
	u64 val[8];
};

struct pasid_table {
	void *table;
	int order;
	u32 max_pasid;
};

struct patch_digest {
	u32 patch_id;
	u8 sha256[32];
};

struct pause_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pauseparam pauseparam;
	struct ethtool_pause_stats pausestat;
};

struct pause_req_info {
	struct ethnl_req_info base;
	enum ethtool_mac_stats_src src;
};

struct pbe {
	void *address;
	void *orig_address;
	struct pbe *next;
};

struct pcc_mbox_chan {
	struct mbox_chan *mchan;
	u64 shmem_base_addr;
	void *shmem;
	u64 shmem_size;
	u32 latency;
	u32 max_access_rate;
	u16 min_turnaround_time;
};

struct pcc_chan_reg {
	void *vaddr;
	struct acpi_generic_address *gas;
	u64 preserve_mask;
	u64 set_mask;
	u64 status_mask;
};

struct pcc_chan_info {
	struct pcc_mbox_chan chan;
	struct pcc_chan_reg db;
	struct pcc_chan_reg plat_irq_ack;
	struct pcc_chan_reg cmd_complete;
	struct pcc_chan_reg cmd_update;
	struct pcc_chan_reg error;
	int plat_irq;
	u8 type;
	unsigned int plat_irq_flags;
	bool chan_in_use;
};

struct pcc_data {
	struct pcc_mbox_chan *pcc_chan;
	void *pcc_comm_addr;
	struct completion done;
	struct mbox_client cl;
	struct acpi_pcc_info ctx;
};

struct pccard_io_map {
	u_char map;
	u_char flags;
	u_short speed;
	phys_addr_t start;
	phys_addr_t stop;
};

typedef struct pccard_io_map pccard_io_map;

struct pccard_mem_map {
	u_char map;
	u_char flags;
	u_short speed;
	phys_addr_t static_start;
	u_int card_start;
	struct resource *res;
};

typedef struct pccard_mem_map pccard_mem_map;

struct pcmcia_socket;

struct socket_state_t;

typedef struct socket_state_t socket_state_t;

struct pccard_operations {
	int (*init)(struct pcmcia_socket *);
	int (*suspend)(struct pcmcia_socket *);
	int (*get_status)(struct pcmcia_socket *, u_int *);
	int (*set_socket)(struct pcmcia_socket *, socket_state_t *);
	int (*set_io_map)(struct pcmcia_socket *, struct pccard_io_map *);
	int (*set_mem_map)(struct pcmcia_socket *, struct pccard_mem_map *);
};

struct pccard_resource_ops {
	int (*validate_mem)(struct pcmcia_socket *);
	int (*find_io)(struct pcmcia_socket *, unsigned int, unsigned int *, unsigned int, unsigned int, struct resource **);
	struct resource * (*find_mem)(long unsigned int, long unsigned int, long unsigned int, int, struct pcmcia_socket *);
	int (*init)(struct pcmcia_socket *);
	void (*exit)(struct pcmcia_socket *);
};

struct pci2phy_map {
	struct list_head list;
	int segment;
	int pbus_to_dieid[256];
};

struct pci_acs {
	u16 cap;
	u16 ctrl;
	u16 fw_ctrl;
};

struct pci_bus {
	struct list_head node;
	struct pci_bus *parent;
	struct list_head children;
	struct list_head devices;
	struct pci_dev *self;
	struct list_head slots;
	struct resource *resource[4];
	struct list_head resources;
	struct resource busn_res;
	struct pci_ops *ops;
	void *sysdata;
	struct proc_dir_entry *procdir;
	unsigned char number;
	unsigned char primary;
	unsigned char max_bus_speed;
	unsigned char cur_bus_speed;
	char name[48];
	short unsigned int bridge_ctl;
	pci_bus_flags_t bus_flags;
	struct device *bridge;
	struct device dev;
	struct bin_attribute *legacy_io;
	struct bin_attribute *legacy_mem;
	unsigned int is_added: 1;
	unsigned int unsafe_warn: 1;
};

struct pci_bus_region {
	pci_bus_addr_t start;
	pci_bus_addr_t end;
};

struct pci_bus_resource {
	struct list_head list;
	struct resource *res;
};

struct pci_cap_saved_data {
	u16 cap_nr;
	bool cap_extended;
	unsigned int size;
	u32 data[0];
};

struct pci_cap_saved_state {
	struct hlist_node next;
	struct pci_cap_saved_data cap;
};

struct pci_check_idx_range {
	int start;
	int end;
};

struct pci_vpd {
	struct mutex lock;
	unsigned int len;
	u8 cap;
};

struct rcec_ea;

struct pcie_link_state;

struct pcie_bwctrl_data;

struct pci_sriov;

struct pci_dev {
	struct list_head bus_list;
	struct pci_bus *bus;
	struct pci_bus *subordinate;
	void *sysdata;
	struct proc_dir_entry *procent;
	struct pci_slot *slot;
	unsigned int devfn;
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int subsystem_vendor;
	short unsigned int subsystem_device;
	unsigned int class;
	u8 revision;
	u8 hdr_type;
	struct rcec_ea *rcec_ea;
	struct pci_dev *rcec;
	u32 devcap;
	u8 pcie_cap;
	u8 msi_cap;
	u8 msix_cap;
	u8 pcie_mpss: 3;
	u8 rom_base_reg;
	u8 pin;
	u16 pcie_flags_reg;
	long unsigned int *dma_alias_mask;
	struct pci_driver *driver;
	u64 dma_mask;
	struct device_dma_parameters dma_parms;
	pci_power_t current_state;
	u8 pm_cap;
	unsigned int pme_support: 5;
	unsigned int pme_poll: 1;
	unsigned int pinned: 1;
	unsigned int config_rrs_sv: 1;
	unsigned int imm_ready: 1;
	unsigned int d1_support: 1;
	unsigned int d2_support: 1;
	unsigned int no_d1d2: 1;
	unsigned int no_d3cold: 1;
	unsigned int bridge_d3: 1;
	unsigned int d3cold_allowed: 1;
	unsigned int mmio_always_on: 1;
	unsigned int wakeup_prepared: 1;
	unsigned int skip_bus_pm: 1;
	unsigned int ignore_hotplug: 1;
	unsigned int hotplug_user_indicators: 1;
	unsigned int clear_retrain_link: 1;
	unsigned int d3hot_delay;
	unsigned int d3cold_delay;
	u16 l1ss;
	struct pcie_link_state *link_state;
	unsigned int ltr_path: 1;
	unsigned int pasid_no_tlp: 1;
	unsigned int eetlp_prefix_max: 3;
	pci_channel_state_t error_state;
	struct device dev;
	int cfg_size;
	unsigned int irq;
	struct resource resource[11];
	struct resource driver_exclusive_resource;
	bool match_driver;
	unsigned int transparent: 1;
	unsigned int io_window: 1;
	unsigned int pref_window: 1;
	unsigned int pref_64_window: 1;
	unsigned int multifunction: 1;
	unsigned int is_busmaster: 1;
	unsigned int no_msi: 1;
	unsigned int no_64bit_msi: 1;
	unsigned int block_cfg_access: 1;
	unsigned int broken_parity_status: 1;
	unsigned int irq_reroute_variant: 2;
	unsigned int msi_enabled: 1;
	unsigned int msix_enabled: 1;
	unsigned int ari_enabled: 1;
	unsigned int ats_enabled: 1;
	unsigned int pasid_enabled: 1;
	unsigned int pri_enabled: 1;
	unsigned int tph_enabled: 1;
	unsigned int is_managed: 1;
	unsigned int is_msi_managed: 1;
	unsigned int needs_freset: 1;
	unsigned int state_saved: 1;
	unsigned int is_physfn: 1;
	unsigned int is_virtfn: 1;
	unsigned int is_hotplug_bridge: 1;
	unsigned int shpc_managed: 1;
	unsigned int is_thunderbolt: 1;
	unsigned int untrusted: 1;
	unsigned int external_facing: 1;
	unsigned int broken_intx_masking: 1;
	unsigned int io_window_1k: 1;
	unsigned int irq_managed: 1;
	unsigned int non_compliant_bars: 1;
	unsigned int is_probed: 1;
	unsigned int link_active_reporting: 1;
	unsigned int no_vf_scan: 1;
	unsigned int no_command_memory: 1;
	unsigned int rom_bar_overlap: 1;
	unsigned int rom_attr_enabled: 1;
	pci_dev_flags_t dev_flags;
	atomic_t enable_cnt;
	spinlock_t pcie_cap_lock;
	u32 saved_config_space[16];
	struct hlist_head saved_cap_space;
	struct bin_attribute *res_attr[11];
	struct bin_attribute *res_attr_wc[11];
	void *msix_base;
	raw_spinlock_t msi_lock;
	struct pci_vpd vpd;
	struct pcie_bwctrl_data *link_bwctrl;
	union {
		struct pci_sriov *sriov;
		struct pci_dev *physfn;
	};
	u16 ats_cap;
	u8 ats_stu;
	u16 pri_cap;
	u32 pri_reqs_alloc;
	unsigned int pasid_required: 1;
	u16 pasid_cap;
	u16 pasid_features;
	u16 acs_cap;
	u8 supported_speeds;
	phys_addr_t rom;
	size_t romlen;
	const char *driver_override;
	long unsigned int priv_flags;
	u8 reset_methods[8];
};

struct pci_dev_acs_enabled {
	u16 vendor;
	u16 device;
	int (*acs_enabled)(struct pci_dev *, u16);
};

struct pci_dev_acs_ops {
	u16 vendor;
	u16 device;
	int (*enable_acs)(struct pci_dev *);
	int (*disable_acs_redir)(struct pci_dev *);
};

struct pci_dev_reset_methods {
	u16 vendor;
	u16 device;
	int (*reset)(struct pci_dev *, bool);
};

struct pci_dev_resource {
	struct list_head list;
	struct resource *res;
	struct pci_dev *dev;
	resource_size_t start;
	resource_size_t end;
	resource_size_t add_size;
	resource_size_t min_align;
	long unsigned int flags;
};

struct pci_device_id {
	__u32 vendor;
	__u32 device;
	__u32 subvendor;
	__u32 subdevice;
	__u32 class;
	__u32 class_mask;
	kernel_ulong_t driver_data;
	__u32 override_only;
};

struct pci_domain_busn_res {
	struct list_head list;
	struct resource res;
	int domain_nr;
};

struct pci_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct pci_error_handlers;

struct pci_driver {
	const char *name;
	const struct pci_device_id *id_table;
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
	int (*suspend)(struct pci_dev *, pm_message_t);
	int (*resume)(struct pci_dev *);
	void (*shutdown)(struct pci_dev *);
	int (*sriov_configure)(struct pci_dev *, int);
	int (*sriov_set_msix_vec_count)(struct pci_dev *, int);
	u32 (*sriov_get_vf_total_msix)(struct pci_dev *);
	const struct pci_error_handlers *err_handler;
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	struct device_driver driver;
	struct pci_dynids dynids;
	bool driver_managed_dma;
};

struct pci_dynid {
	struct list_head node;
	struct pci_device_id id;
};

struct pci_error_handlers {
	pci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);
	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
	pci_ers_result_t (*slot_reset)(struct pci_dev *);
	void (*reset_prepare)(struct pci_dev *);
	void (*reset_done)(struct pci_dev *);
	void (*resume)(struct pci_dev *);
	void (*cor_error_detected)(struct pci_dev *);
};

struct pci_extra_dev {
	struct pci_dev *dev[4];
};

struct pci_filp_private {
	enum pci_mmap_state mmap_state;
	int write_combine;
};

struct pci_fixup {
	u16 vendor;
	u16 device;
	u32 class;
	unsigned int class_shift;
	int hook_offset;
};

struct pci_host_bridge {
	struct device dev;
	struct pci_bus *bus;
	struct pci_ops *ops;
	struct pci_ops *child_ops;
	void *sysdata;
	int busnr;
	int domain_nr;
	struct list_head windows;
	struct list_head dma_ranges;
	u8 (*swizzle_irq)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void (*release_fn)(struct pci_host_bridge *);
	int (*enable_device)(struct pci_host_bridge *, struct pci_dev *);
	void (*disable_device)(struct pci_host_bridge *, struct pci_dev *);
	void *release_data;
	unsigned int ignore_reset_delay: 1;
	unsigned int no_ext_tags: 1;
	unsigned int no_inc_mrrs: 1;
	unsigned int native_aer: 1;
	unsigned int native_pcie_hotplug: 1;
	unsigned int native_shpc_hotplug: 1;
	unsigned int native_pme: 1;
	unsigned int native_ltr: 1;
	unsigned int native_dpc: 1;
	unsigned int native_cxl_error: 1;
	unsigned int preserve_config: 1;
	unsigned int size_windows: 1;
	unsigned int msi_domain: 1;
	resource_size_t (*align_resource)(struct pci_dev *, const struct resource *, resource_size_t, resource_size_t, resource_size_t);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

struct pci_hostbridge_probe {
	u32 bus;
	u32 slot;
	u32 vendor;
	u32 device;
};

struct pci_mmcfg_hostbridge_probe {
	u32 bus;
	u32 devfn;
	u32 vendor;
	u32 device;
	const char * (*probe)(void);
};

struct pci_mmcfg_region {
	struct list_head list;
	struct resource res;
	u64 address;
	char *virt;
	u16 segment;
	u8 start_bus;
	u8 end_bus;
	char name[30];
};

struct pci_ops {
	int (*add_bus)(struct pci_bus *);
	void (*remove_bus)(struct pci_bus *);
	void * (*map_bus)(struct pci_bus *, unsigned int, int);
	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
};

struct pci_osc_bit_struct {
	u32 bit;
	char *desc;
};

struct pci_p2pdma_map_state {
	struct dev_pagemap *pgmap;
	int map;
	u64 bus_off;
};

struct pci_pme_device {
	struct list_head list;
	struct pci_dev *dev;
};

struct pci_raw_ops {
	int (*read)(unsigned int, unsigned int, unsigned int, int, int, u32 *);
	int (*write)(unsigned int, unsigned int, unsigned int, int, int, u32);
};

struct pci_reset_fn_method {
	int (*reset_fn)(struct pci_dev *, bool);
	char *name;
};

struct pci_root_info {
	struct list_head list;
	char name[12];
	struct list_head resources;
	struct resource busn;
	int node;
	int link;
};

struct pci_sysdata {
	int domain;
	int node;
	struct acpi_device *companion;
	void *iommu;
	void *fwnode;
};

struct pci_root_info___2 {
	struct acpi_pci_root_info common;
	struct pci_sysdata sd;
	bool mcfg_added;
	u8 start_bus;
	u8 end_bus;
};

struct pci_root_res {
	struct list_head list;
	struct resource res;
};

struct pci_saved_state {
	u32 config_space[16];
	struct pci_cap_saved_data cap[0];
};

struct serial_private;

struct pciserial_board;

struct pci_serial_quirk {
	u32 vendor;
	u32 device;
	u32 subvendor;
	u32 subdevice;
	int (*probe)(struct pci_dev *);
	int (*init)(struct pci_dev *);
	int (*setup)(struct serial_private *, const struct pciserial_board *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct setup_data {
	__u64 next;
	__u32 type;
	__u32 len;
	__u8 data[0];
};

struct pci_setup_rom {
	struct setup_data data;
	uint16_t vendor;
	uint16_t devid;
	uint64_t pcilen;
	long unsigned int segment;
	long unsigned int bus;
	long unsigned int device;
	long unsigned int function;
	uint8_t romdata[0];
};

struct pci_slot {
	struct pci_bus *bus;
	struct list_head list;
	struct hotplug_slot *hotplug;
	unsigned char number;
	struct kobject kobj;
};

struct pci_slot_attribute {
	struct attribute attr;
	ssize_t (*show)(struct pci_slot *, char *);
	ssize_t (*store)(struct pci_slot *, const char *, size_t);
};

struct pci_sriov {
	int pos;
	int nres;
	u32 cap;
	u16 ctrl;
	u16 total_VFs;
	u16 initial_VFs;
	u16 num_VFs;
	u16 offset;
	u16 stride;
	u16 vf_device;
	u32 pgsz;
	u8 link;
	u8 max_VF_buses;
	u16 driver_max_VFs;
	struct pci_dev *dev;
	struct pci_dev *self;
	u32 class;
	u8 hdr_type;
	u16 subsystem_vendor;
	u16 subsystem_device;
	resource_size_t barsz[6];
	bool drivers_autoprobe;
};

struct pcibios_fwaddrmap {
	struct list_head list;
	struct pci_dev *dev;
	resource_size_t fw_addr[11];
};

struct pcie_bwctrl_data {
	struct mutex set_speed_mutex;
	atomic_t lbms_count;
	struct thermal_cooling_device *cdev;
};

struct pcie_device {
	int irq;
	struct pci_dev *port;
	u32 service;
	void *priv_data;
	struct device device;
};

struct pcie_link_state {
	struct pci_dev *pdev;
	struct pci_dev *downstream;
	struct pcie_link_state *root;
	struct pcie_link_state *parent;
	struct list_head sibling;
	u32 aspm_support: 7;
	u32 aspm_enabled: 7;
	u32 aspm_capable: 7;
	u32 aspm_default: 7;
	int: 4;
	u32 aspm_disable: 7;
	u32 clkpm_capable: 1;
	u32 clkpm_enabled: 1;
	u32 clkpm_default: 1;
	u32 clkpm_disable: 1;
};

struct pcie_pme_service_data {
	spinlock_t lock;
	struct pcie_device *srv;
	struct work_struct work;
	bool noirq;
};

struct pcie_port_service_driver {
	const char *name;
	int (*probe)(struct pcie_device *);
	void (*remove)(struct pcie_device *);
	int (*suspend)(struct pcie_device *);
	int (*resume_noirq)(struct pcie_device *);
	int (*resume)(struct pcie_device *);
	int (*runtime_suspend)(struct pcie_device *);
	int (*runtime_resume)(struct pcie_device *);
	int (*slot_reset)(struct pcie_device *);
	int port_type;
	u32 service;
	struct device_driver driver;
};

struct pcim_addr_devres {
	enum pcim_addr_devres_type type;
	void *baseaddr;
	long unsigned int offset;
	long unsigned int len;
	int bar;
};

struct pcim_intx_devres {
	int orig_intx;
};

struct pcim_iomap_devres {
	void *table[11];
};

struct pciserial_board {
	unsigned int flags;
	unsigned int num_ports;
	unsigned int base_baud;
	unsigned int uart_offset;
	unsigned int reg_shift;
	unsigned int first_offset;
};

struct resource_map;

struct pcmcia_align_data {
	long unsigned int mask;
	long unsigned int offset;
	struct resource_map *map;
};

struct pcmcia_callback {
	struct module *owner;
	int (*add)(struct pcmcia_socket *);
	int (*remove)(struct pcmcia_socket *);
	void (*requery)(struct pcmcia_socket *);
	int (*validate)(struct pcmcia_socket *, unsigned int *);
	int (*suspend)(struct pcmcia_socket *);
	int (*early_resume)(struct pcmcia_socket *);
	int (*resume)(struct pcmcia_socket *);
};

struct pcmcia_device;

struct pcmcia_cfg_mem {
	struct pcmcia_device *p_dev;
	int (*conf_check)(struct pcmcia_device *, void *);
	void *priv_data;
	cisparse_t parse;
	cistpl_cftable_entry_t dflt;
};

struct pcmcia_device {
	struct pcmcia_socket *socket;
	char *devname;
	u8 device_no;
	u8 func;
	struct config_t *function_config;
	struct list_head socket_device_list;
	unsigned int irq;
	struct resource *resource[6];
	resource_size_t card_addr;
	unsigned int vpp;
	unsigned int config_flags;
	unsigned int config_base;
	unsigned int config_index;
	unsigned int config_regs;
	unsigned int io_lines;
	u16 suspended: 1;
	u16 _irq: 1;
	u16 _io: 1;
	u16 _win: 4;
	u16 _locked: 1;
	u16 allow_func_id_match: 1;
	u16 has_manf_id: 1;
	u16 has_card_id: 1;
	u16 has_func_id: 1;
	u16 reserved: 4;
	u8 func_id;
	u16 manf_id;
	u16 card_id;
	char *prod_id[4];
	u64 dma_mask;
	struct device dev;
	void *priv;
	unsigned int open;
};

struct pcmcia_device_id {
	__u16 match_flags;
	__u16 manf_id;
	__u16 card_id;
	__u8 func_id;
	__u8 function;
	__u8 device_no;
	__u32 prod_id_hash[4];
	const char *prod_id[4];
	kernel_ulong_t driver_info;
	char *cisfile;
};

struct pcmcia_dynids {
	struct mutex lock;
	struct list_head list;
};

struct pcmcia_driver {
	const char *name;
	int (*probe)(struct pcmcia_device *);
	void (*remove)(struct pcmcia_device *);
	int (*suspend)(struct pcmcia_device *);
	int (*resume)(struct pcmcia_device *);
	struct module *owner;
	const struct pcmcia_device_id *id_table;
	struct device_driver drv;
	struct pcmcia_dynids dynids;
};

struct pcmcia_dynid {
	struct list_head node;
	struct pcmcia_device_id id;
};

struct pcmcia_loop_get {
	size_t len;
	cisdata_t **buf;
};

struct tuple_t;

typedef struct tuple_t tuple_t;

struct pcmcia_loop_mem {
	struct pcmcia_device *p_dev;
	void *priv_data;
	int (*loop_tuple)(struct pcmcia_device *, tuple_t *, void *);
};

struct socket_state_t {
	u_int flags;
	u_int csc_mask;
	u_char Vcc;
	u_char Vpp;
	u_char io_irq;
};

struct pcmcia_socket {
	struct module *owner;
	socket_state_t socket;
	u_int state;
	u_int suspended_state;
	u_short functions;
	u_short lock_count;
	pccard_mem_map cis_mem;
	void *cis_virt;
	io_window_t io[2];
	pccard_mem_map win[4];
	struct list_head cis_cache;
	size_t fake_cis_len;
	u8 *fake_cis;
	struct list_head socket_list;
	struct completion socket_released;
	unsigned int sock;
	u_int features;
	u_int irq_mask;
	u_int map_size;
	u_int io_offset;
	u_int pci_irq;
	struct pci_dev *cb_dev;
	u8 resource_setup_done;
	struct pccard_operations *ops;
	struct pccard_resource_ops *resource_ops;
	void *resource_data;
	void (*zoom_video)(struct pcmcia_socket *, int);
	int (*power_hook)(struct pcmcia_socket *, int);
	void (*tune_bridge)(struct pcmcia_socket *, struct pci_bus *);
	struct task_struct *thread;
	struct completion thread_done;
	unsigned int thread_events;
	unsigned int sysfs_events;
	struct mutex skt_mutex;
	struct mutex ops_mutex;
	spinlock_t thread_lock;
	struct pcmcia_callback *callback;
	struct list_head devices_list;
	u8 device_count;
	u8 pcmcia_pfc;
	atomic_t present;
	unsigned int pcmcia_irq;
	struct device dev;
	void *driver_data;
	int resume_status;
};

struct pcpu_group_info {
	int nr_units;
	long unsigned int base_offset;
	unsigned int *cpu_map;
};

struct pcpu_alloc_info {
	size_t static_size;
	size_t reserved_size;
	size_t dyn_size;
	size_t unit_size;
	size_t atom_size;
	size_t alloc_size;
	size_t __ai_size;
	int nr_groups;
	struct pcpu_group_info groups[0];
};

struct pcpu_block_md {
	int scan_hint;
	int scan_hint_start;
	int contig_hint;
	int contig_hint_start;
	int left_free;
	int right_free;
	int first_free;
	int nr_bits;
};

struct pcpuobj_ext;

struct pcpu_chunk {
	struct list_head list;
	int free_bytes;
	struct pcpu_block_md chunk_md;
	long unsigned int *bound_map;
	void *base_addr;
	long unsigned int *alloc_map;
	struct pcpu_block_md *md_blocks;
	void *data;
	bool immutable;
	bool isolated;
	int start_offset;
	int end_offset;
	struct pcpuobj_ext *obj_exts;
	int nr_pages;
	int nr_populated;
	int nr_empty_pop_pages;
	long unsigned int populated[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct pcpu_dstats {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	u64_stats_t rx_drops;
	u64_stats_t tx_drops;
	struct u64_stats_sync syncp;
	long: 64;
	long: 64;
};

struct pcpu_gen_cookie {
	local_t nesting;
	u64 last;
};

struct pcpu_hot {
	union {
		struct {
			struct task_struct *current_task;
			int preempt_count;
			int cpu_number;
			u64 call_depth;
			long unsigned int top_of_stack;
			void *hardirq_stack_ptr;
			u16 softirq_pending;
			bool hardirq_stack_inuse;
		};
		u8 pad[64];
	};
};

struct pcpu_lstats {
	u64_stats_t packets;
	u64_stats_t bytes;
	struct u64_stats_sync syncp;
};

struct pcpu_seg6_local_counters {
	u64_stats_t packets;
	u64_stats_t bytes;
	u64_stats_t errors;
	struct u64_stats_sync syncp;
};

struct pcpu_sw_netstats {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	struct u64_stats_sync syncp;
};

struct pcpuobj_ext {
	struct obj_cgroup *cgroup;
};

struct pde_opener {
	struct list_head lh;
	struct file *file;
	bool closing;
	struct completion *c;
};

struct pdev_archdata {};

struct pdom_dev_data {
	struct iommu_dev_data *dev_data;
	ioasid_t pasid;
	struct list_head list;
};

struct pdom_iommu_info {
	struct amd_iommu *iommu;
	u32 refcnt;
};

struct pebs_basic {
	u64 format_group: 32;
	u64 retire_latency: 16;
	u64 format_size: 16;
	u64 ip;
	u64 applicable_counters;
	u64 tsc;
};

struct pebs_gprs {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 cx;
	u64 dx;
	u64 bx;
	u64 sp;
	u64 bp;
	u64 si;
	u64 di;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
};

struct pebs_meminfo {
	u64 address;
	u64 aux;
	union {
		u64 mem_latency;
		struct {
			u64 instr_latency: 16;
			u64 pad2: 16;
			u64 cache_latency: 16;
			u64 pad3: 16;
		};
	};
	u64 tsx_tuning;
};

struct pebs_record_core {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
};

struct pebs_record_nhm {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u64 status;
	u64 dla;
	u64 dse;
	u64 lat;
};

struct pebs_record_skl {
	u64 flags;
	u64 ip;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 si;
	u64 di;
	u64 bp;
	u64 sp;
	u64 r8;
	u64 r9;
	u64 r10;
	u64 r11;
	u64 r12;
	u64 r13;
	u64 r14;
	u64 r15;
	u64 status;
	u64 dla;
	u64 dse;
	u64 lat;
	u64 real_ip;
	u64 tsx_tuning;
	u64 tsc;
};

struct pebs_xmm {
	u64 xmm[32];
};

struct pending_dir_move {
	struct rb_node node;
	struct list_head list;
	u64 parent_ino;
	u64 ino;
	u64 gen;
	struct list_head update_refs;
};

struct pending_reservation {
	struct rb_node rb_node;
	ext4_lblk_t lclu;
};

struct pn_sock {
	struct sock sk;
	u16 sobject;
	u16 dobject;
	u8 resource;
};

struct pep_sock {
	struct pn_sock pn_sk;
	struct hlist_head hlist;
	struct sock *listener;
	struct sk_buff_head ctrlreq_queue;
	atomic_t tx_credits;
	int ifindex;
	u16 peer_type;
	u8 pipe_handle;
	u8 rx_credits;
	u8 rx_fc;
	u8 tx_fc;
	u8 init_enable;
	u8 aligned;
};

struct per_cpu_nodestat {
	s8 stat_threshold;
	s8 vm_node_stat_diff[46];
};

struct per_cpu_pages {
	spinlock_t lock;
	int count;
	int high;
	int high_min;
	int high_max;
	int batch;
	u8 flags;
	u8 alloc_factor;
	u8 expire;
	short int free_count;
	struct list_head lists[12];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct per_cpu_zonestat {
	s8 vm_stat_diff[10];
	s8 stat_threshold;
	long unsigned int vm_numa_event[6];
};

struct percpu_cluster {
	local_lock_t lock;
	unsigned int next[1];
};

struct percpu_free_defer {
	struct callback_head rcu;
	void *ptr;
};

typedef void percpu_ref_func_t(struct percpu_ref *);

struct percpu_ref_data {
	atomic_long_t count;
	percpu_ref_func_t *release;
	percpu_ref_func_t *confirm_switch;
	bool force_atomic: 1;
	bool allow_reinit: 1;
	struct callback_head rcu;
	struct percpu_ref *ref;
};

struct perf_addr_filter {
	struct list_head entry;
	struct path path;
	long unsigned int offset;
	long unsigned int size;
	enum perf_addr_filter_action_t action;
};

struct perf_addr_filter_range {
	long unsigned int start;
	long unsigned int size;
};

struct perf_addr_filters_head {
	struct list_head list;
	raw_spinlock_t lock;
	unsigned int nr_file_filters;
};

struct perf_amd_iommu {
	struct list_head list;
	struct pmu pmu;
	struct amd_iommu *iommu;
	char name[16];
	u8 max_banks;
	u8 max_counters;
	u64 cntr_assign_mask;
	raw_spinlock_t lock;
};

struct perf_event_header {
	__u32 type;
	__u16 misc;
	__u16 size;
};

struct perf_aux_event {
	struct perf_event_header header;
	u64 hw_id;
};

struct perf_aux_event___2 {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct perf_aux_event___3 {
	struct perf_event_header header;
	u64 offset;
	u64 size;
	u64 flags;
};

struct perf_bpf_event {
	struct bpf_prog *prog;
	struct {
		struct perf_event_header header;
		u16 type;
		u16 flags;
		u32 id;
		u8 tag[8];
	} event_id;
};

struct perf_event_mmap_page;

struct perf_buffer {
	refcount_t refcount;
	struct callback_head callback_head;
	int nr_pages;
	int overwrite;
	int paused;
	atomic_t poll;
	local_t head;
	unsigned int nest;
	local_t events;
	local_t wakeup;
	local_t lost;
	long int watermark;
	long int aux_watermark;
	spinlock_t event_lock;
	struct list_head event_list;
	atomic_t mmap_count;
	long unsigned int mmap_locked;
	struct user_struct *mmap_user;
	struct mutex aux_mutex;
	long int aux_head;
	unsigned int aux_nest;
	long int aux_wakeup;
	long unsigned int aux_pgoff;
	int aux_nr_pages;
	int aux_overwrite;
	atomic_t aux_mmap_count;
	long unsigned int aux_mmap_locked;
	void (*free_aux)(void *);
	refcount_t aux_refcount;
	int aux_in_sampling;
	int aux_in_pause_resume;
	void **aux_pages;
	void *aux_priv;
	struct perf_event_mmap_page *user_page;
	void *data_pages[0];
};

struct perf_callchain_entry {
	__u64 nr;
	__u64 ip[0];
};

struct perf_callchain_entry_ctx {
	struct perf_callchain_entry *entry;
	u32 max_stack;
	u32 nr;
	short int contexts;
	bool contexts_maxed;
};

union perf_capabilities {
	struct {
		u64 lbr_format: 6;
		u64 pebs_trap: 1;
		u64 pebs_arch_reg: 1;
		u64 pebs_format: 4;
		u64 smm_freeze: 1;
		u64 full_width_write: 1;
		u64 pebs_baseline: 1;
		u64 perf_metrics: 1;
		u64 pebs_output_pt_available: 1;
		u64 pebs_timing_info: 1;
		u64 anythread_deprecated: 1;
		u64 rdpmc_metrics_clear: 1;
	};
	u64 capabilities;
};

struct perf_cgroup_info;

struct perf_cgroup {
	struct cgroup_subsys_state css;
	struct perf_cgroup_info *info;
};

struct perf_cgroup_event {
	char *path;
	int path_size;
	struct {
		struct perf_event_header header;
		u64 id;
		char path[0];
	} event_id;
};

struct perf_cgroup_info {
	u64 time;
	u64 timestamp;
	u64 timeoffset;
	int active;
};

struct perf_comm_event {
	struct task_struct *task;
	char *comm;
	int comm_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
	} event_id;
};

struct perf_event_groups {
	struct rb_root tree;
	u64 index;
};

struct perf_event_context {
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head pmu_ctx_list;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	int nr_events;
	int nr_user;
	int is_active;
	int nr_task_data;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	refcount_t refcount;
	struct task_struct *task;
	u64 time;
	u64 timestamp;
	u64 timeoffset;
	struct perf_event_context *parent_ctx;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	int nr_cgroups;
	struct callback_head callback_head;
	local_t nr_no_switch_fast;
};

struct perf_cpu_context {
	struct perf_event_context ctx;
	struct perf_event_context *task_ctx;
	int online;
	struct perf_cgroup *cgrp;
	int heap_size;
	struct perf_event **heap;
	struct perf_event *heap_default[2];
};

struct perf_event_pmu_context {
	struct pmu *pmu;
	struct perf_event_context *ctx;
	struct list_head pmu_ctx_entry;
	struct list_head pinned_active;
	struct list_head flexible_active;
	unsigned int embedded: 1;
	unsigned int nr_events;
	unsigned int nr_cgroups;
	unsigned int nr_freq;
	atomic_t refcount;
	struct callback_head callback_head;
	void *task_ctx_data;
	int rotate_necessary;
};

struct perf_cpu_pmu_context {
	struct perf_event_pmu_context epc;
	struct perf_event_pmu_context *task_epc;
	struct list_head sched_cb_entry;
	int sched_cb_usage;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
};

struct perf_ctx_data {
	struct callback_head callback_head;
	refcount_t refcount;
	int global;
	struct kmem_cache *ctx_cache;
	void *data;
};

struct perf_domain {
	struct em_perf_domain *em_pd;
	struct perf_domain *next;
	struct callback_head rcu;
};

struct perf_event_attr {
	__u32 type;
	__u32 size;
	__u64 config;
	union {
		__u64 sample_period;
		__u64 sample_freq;
	};
	__u64 sample_type;
	__u64 read_format;
	__u64 disabled: 1;
	__u64 inherit: 1;
	__u64 pinned: 1;
	__u64 exclusive: 1;
	__u64 exclude_user: 1;
	__u64 exclude_kernel: 1;
	__u64 exclude_hv: 1;
	__u64 exclude_idle: 1;
	__u64 mmap: 1;
	__u64 comm: 1;
	__u64 freq: 1;
	__u64 inherit_stat: 1;
	__u64 enable_on_exec: 1;
	__u64 task: 1;
	__u64 watermark: 1;
	__u64 precise_ip: 2;
	__u64 mmap_data: 1;
	__u64 sample_id_all: 1;
	__u64 exclude_host: 1;
	__u64 exclude_guest: 1;
	__u64 exclude_callchain_kernel: 1;
	__u64 exclude_callchain_user: 1;
	__u64 mmap2: 1;
	__u64 comm_exec: 1;
	__u64 use_clockid: 1;
	__u64 context_switch: 1;
	__u64 write_backward: 1;
	__u64 namespaces: 1;
	__u64 ksymbol: 1;
	__u64 bpf_event: 1;
	__u64 aux_output: 1;
	__u64 cgroup: 1;
	__u64 text_poke: 1;
	__u64 build_id: 1;
	__u64 inherit_thread: 1;
	__u64 remove_on_exec: 1;
	__u64 sigtrap: 1;
	__u64 __reserved_1: 26;
	union {
		__u32 wakeup_events;
		__u32 wakeup_watermark;
	};
	__u32 bp_type;
	union {
		__u64 bp_addr;
		__u64 kprobe_func;
		__u64 uprobe_path;
		__u64 config1;
	};
	union {
		__u64 bp_len;
		__u64 kprobe_addr;
		__u64 probe_offset;
		__u64 config2;
	};
	__u64 branch_sample_type;
	__u64 sample_regs_user;
	__u32 sample_stack_user;
	__s32 clockid;
	__u64 sample_regs_intr;
	__u32 aux_watermark;
	__u16 sample_max_stack;
	__u16 __reserved_2;
	__u32 aux_sample_size;
	union {
		__u32 aux_action;
		struct {
			__u32 aux_start_paused: 1;
			__u32 aux_pause: 1;
			__u32 aux_resume: 1;
			__u32 __reserved_3: 29;
		};
	};
	__u64 sig_data;
	__u64 config3;
};

typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);

struct perf_event {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	unsigned int group_generation;
	struct perf_event *group_leader;
	struct pmu *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event hw;
	struct perf_event_context *ctx;
	struct perf_event_pmu_context *pmu_ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct perf_buffer *rb;
	struct list_head rb_entry;
	long unsigned int rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
	unsigned int pending_wakeup;
	unsigned int pending_kill;
	unsigned int pending_disable;
	long unsigned int pending_addr;
	struct irq_work pending_irq;
	struct irq_work pending_disable_irq;
	struct callback_head pending_task;
	unsigned int pending_work;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	long unsigned int addr_filters_gen;
	struct perf_event *aux_event;
	void (*destroy)(struct perf_event *);
	struct callback_head callback_head;
	struct pid_namespace *ns;
	u64 id;
	atomic64_t lost_samples;
	u64 (*clock)(void);
	perf_overflow_handler_t overflow_handler;
	void *overflow_handler_context;
	struct bpf_prog *prog;
	u64 bpf_cookie;
	struct trace_event_call *tp_event;
	struct event_filter *filter;
	struct perf_cgroup *cgrp;
	void *security;
	struct list_head sb_list;
	__u32 orig_type;
};

struct perf_event_min_heap {
	size_t nr;
	size_t size;
	struct perf_event **data;
	struct perf_event *preallocated[0];
};

struct perf_event_mmap_page {
	__u32 version;
	__u32 compat_version;
	__u32 lock;
	__u32 index;
	__s64 offset;
	__u64 time_enabled;
	__u64 time_running;
	union {
		__u64 capabilities;
		struct {
			__u64 cap_bit0: 1;
			__u64 cap_bit0_is_deprecated: 1;
			__u64 cap_user_rdpmc: 1;
			__u64 cap_user_time: 1;
			__u64 cap_user_time_zero: 1;
			__u64 cap_user_time_short: 1;
			__u64 cap_____res: 58;
		};
	};
	__u16 pmc_width;
	__u16 time_shift;
	__u32 time_mult;
	__u64 time_offset;
	__u64 time_zero;
	__u32 size;
	__u32 __reserved_1;
	__u64 time_cycles;
	__u64 time_mask;
	__u8 __reserved[928];
	__u64 data_head;
	__u64 data_tail;
	__u64 data_offset;
	__u64 data_size;
	__u64 aux_head;
	__u64 aux_tail;
	__u64 aux_offset;
	__u64 aux_size;
};

struct perf_event_query_bpf {
	__u32 ids_len;
	__u32 prog_cnt;
	__u32 ids[0];
};

struct perf_guest_info_callbacks {
	unsigned int (*state)(void);
	long unsigned int (*get_ip)(void);
	unsigned int (*handle_intel_pt_intr)(void);
};

struct perf_ibs {
	struct pmu pmu;
	unsigned int msr;
	u64 config_mask;
	u64 cnt_mask;
	u64 enable_mask;
	u64 valid_mask;
	u64 max_period;
	long unsigned int offset_mask[1];
	int offset_max;
	unsigned int fetch_count_reset_broken: 1;
	unsigned int fetch_ignore_if_zero_rip: 1;
	struct cpu_perf_ibs *pcpu;
	u64 (*get_count)(u64);
};

struct perf_ibs_data {
	u32 size;
	union {
		u32 data[0];
		u32 caps;
	};
	u64 regs[8];
};

struct perf_ksymbol_event {
	const char *name;
	int name_len;
	struct {
		struct perf_event_header header;
		u64 addr;
		u32 len;
		u16 ksym_type;
		u16 flags;
	} event_id;
};

struct perf_mmap_event {
	struct vm_area_struct *vma;
	const char *file_name;
	int file_size;
	int maj;
	int min;
	u64 ino;
	u64 ino_generation;
	u32 prot;
	u32 flags;
	u8 build_id[20];
	u32 build_id_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 start;
		u64 len;
		u64 pgoff;
	} event_id;
};

struct perf_msr {
	u64 msr;
	struct attribute_group *grp;
	bool (*test)(int, void *);
	bool no_check;
	u64 mask;
};

struct perf_ns_link_info {
	__u64 dev;
	__u64 ino;
};

struct perf_namespaces_event {
	struct task_struct *task;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 nr_namespaces;
		struct perf_ns_link_info link_info[7];
	} event_id;
};

struct perf_open_properties {
	u32 sample_flags;
	u64 single_context: 1;
	u64 hold_preemption: 1;
	u64 ctx_handle;
	int metrics_set;
	int oa_format;
	bool oa_periodic;
	int oa_period_exponent;
	struct intel_engine_cs *engine;
	bool has_sseu;
	struct intel_sseu sseu;
	u64 poll_oa_period;
};

struct perf_pmu_events_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
};

struct perf_pmu_events_ht_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str_ht;
	const char *event_str_noht;
};

struct perf_pmu_events_hybrid_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
	u64 pmu_type;
};

struct perf_pmu_format_hybrid_attr {
	struct device_attribute attr;
	u64 pmu_type;
};

typedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);

struct perf_raw_frag {
	union {
		struct perf_raw_frag *next;
		long unsigned int pad;
	};
	perf_copy_f copy;
	void *data;
	u32 size;
} __attribute__((packed));

struct perf_raw_record {
	struct perf_raw_frag frag;
	u32 size;
};

struct perf_read_data {
	struct perf_event *event;
	bool group;
	int ret;
};

struct perf_read_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct sched_state {
	int weight;
	int event;
	int counter;
	int unassigned;
	int nr_gp;
	u64 used;
};

struct perf_sched {
	int max_weight;
	int max_events;
	int max_gp;
	int saved_states;
	struct event_constraint **constraints;
	struct sched_state state;
	struct sched_state saved[2];
};

struct perf_switch_event {
	struct task_struct *task;
	struct task_struct *next_prev;
	struct {
		struct perf_event_header header;
		u32 next_prev_pid;
		u32 next_prev_tid;
	} event_id;
};

struct perf_task_event {
	struct task_struct *task;
	struct perf_event_context *task_ctx;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 ppid;
		u32 tid;
		u32 ptid;
		u64 time;
	} event_id;
};

struct perf_text_poke_event {
	const void *old_bytes;
	const void *new_bytes;
	size_t pad;
	u16 old_len;
	u16 new_len;
	struct {
		struct perf_event_header header;
		u64 addr;
	} event_id;
};

struct pericom8250 {
	void *virt;
	unsigned int nr;
	int line[0];
};

struct pernet_operations {
	struct list_head list;
	int (*init)(struct net *);
	void (*pre_exit)(struct net *);
	void (*exit)(struct net *);
	void (*exit_batch)(struct list_head *);
	void (*exit_batch_rtnl)(struct list_head *, struct list_head *);
	unsigned int * const id;
	const size_t size;
};

struct pf_desc {
	u32 pseudoflavor;
	u32 qop;
	u32 service;
	char *name;
	char *auth_domain_name;
	struct auth_domain *domain;
	bool datatouch;
};

struct pfcp_metadata {
	u8 type;
	__be64 seid;
} __attribute__((packed));

struct skb_array {
	struct ptr_ring ring;
};

struct pfifo_fast_priv {
	struct skb_array q[3];
};

struct xfrm_policy_walk_entry {
	struct list_head all;
	u8 dead;
};

struct xfrm_policy_walk {
	struct xfrm_policy_walk_entry walk;
	u8 type;
	u32 seq;
};

struct xfrm_address_filter;

struct xfrm_state_walk {
	struct list_head all;
	u8 state;
	u8 dying;
	u8 proto;
	u32 seq;
	struct xfrm_address_filter *filter;
};

struct pfkey_sock {
	struct sock sk;
	int registered;
	int promisc;
	struct {
		uint8_t msg_version;
		uint32_t msg_portid;
		int (*dump)(struct pfkey_sock *);
		void (*done)(struct pfkey_sock *);
		union {
			struct xfrm_policy_walk policy;
			struct xfrm_state_walk state;
		} u;
		struct sk_buff *skb;
	} dump;
	struct mutex dump_lock;
};

struct pfn_batch {
	long unsigned int *pfns;
	u32 *npfns;
	unsigned int array_size;
	unsigned int end;
	unsigned int total_pfns;
};

struct pfn_reader_user {
	struct page **upages;
	size_t upages_len;
	long unsigned int upages_start;
	long unsigned int upages_end;
	unsigned int gup_flags;
	int locked;
	struct file *file;
	struct folio **ufolios;
	size_t ufolios_len;
	long unsigned int ufolios_offset;
	struct folio **ufolios_next;
};

struct pfn_reader {
	struct iopt_pages *pages;
	struct interval_tree_double_span_iter span;
	struct pfn_batch batch;
	long unsigned int batch_start_index;
	long unsigned int batch_end_index;
	long unsigned int last_index;
	struct pfn_reader_user user;
};

struct ptdump_range;

struct ptdump_state {
	void (*note_page)(struct ptdump_state *, long unsigned int, int, u64);
	void (*effective_prot)(struct ptdump_state *, int, u64);
	const struct ptdump_range *range;
};

struct pg_state {
	struct ptdump_state ptdump;
	int level;
	pgprotval_t current_prot;
	pgprotval_t effective_prot;
	pgprotval_t prot_levels[5];
	long unsigned int start_address;
	const struct addr_marker *marker;
	long unsigned int lines;
	bool to_dmesg;
	bool check_wx;
	long unsigned int wx_pages;
	struct seq_file *seq;
};

struct zone {
	long unsigned int _watermark[4];
	long unsigned int watermark_boost;
	long unsigned int nr_reserved_highatomic;
	long unsigned int nr_free_highatomic;
	long int lowmem_reserve[4];
	int node;
	struct pglist_data *zone_pgdat;
	struct per_cpu_pages *per_cpu_pageset;
	struct per_cpu_zonestat *per_cpu_zonestats;
	int pageset_high_min;
	int pageset_high_max;
	int pageset_batch;
	long unsigned int zone_start_pfn;
	atomic_long_t managed_pages;
	long unsigned int spanned_pages;
	long unsigned int present_pages;
	long unsigned int present_early_pages;
	const char *name;
	long unsigned int nr_isolate_pageblock;
	seqlock_t span_seqlock;
	int initialized;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad1_;
	struct free_area free_area[11];
	long unsigned int flags;
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad2_;
	long unsigned int percpu_drift_mark;
	long unsigned int compact_cached_free_pfn;
	long unsigned int compact_cached_migrate_pfn[2];
	long unsigned int compact_init_migrate_pfn;
	long unsigned int compact_init_free_pfn;
	unsigned int compact_considered;
	unsigned int compact_defer_shift;
	int compact_order_failed;
	bool compact_blockskip_flush;
	bool contiguous;
	long: 0;
	struct cacheline_padding _pad3_;
	atomic_long_t vm_stat[10];
	atomic_long_t vm_numa_event[6];
};

struct zoneref {
	struct zone *zone;
	int zone_idx;
};

struct zonelist {
	struct zoneref _zonerefs[257];
};

struct pglist_data {
	struct zone node_zones[4];
	struct zonelist node_zonelists[2];
	int nr_zones;
	spinlock_t node_size_lock;
	long unsigned int node_start_pfn;
	long unsigned int node_present_pages;
	long unsigned int node_spanned_pages;
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	wait_queue_head_t reclaim_wait[4];
	atomic_t nr_writeback_throttled;
	long unsigned int nr_reclaim_start;
	struct mutex kswapd_lock;
	struct task_struct *kswapd;
	int kswapd_order;
	enum zone_type kswapd_highest_zoneidx;
	int kswapd_failures;
	int kcompactd_max_order;
	enum zone_type kcompactd_highest_zoneidx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	bool proactive_compact_trigger;
	long unsigned int totalreserve_pages;
	long unsigned int min_unmapped_pages;
	long unsigned int min_slab_pages;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad1_;
	struct lruvec __lruvec;
	long unsigned int flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cacheline_padding _pad2_;
	struct per_cpu_nodestat *per_cpu_nodestats;
	atomic_long_t vm_stat[46];
	struct memory_tier *memtier;
};

struct pgv {
	char *buffer;
};

struct phc_vclocks_reply_data {
	struct ethnl_reply_data base;
	int num;
	int *index;
};

struct phonet_device {
	struct list_head list;
	struct net_device *netdev;
	long unsigned int addrs[1];
	struct callback_head rcu;
};

struct phonet_device_list {
	struct list_head list;
	spinlock_t lock;
};

struct phonet_routes {
	spinlock_t lock;
	struct net_device *table[64];
};

struct phonet_net {
	struct phonet_device_list pndevs;
	struct phonet_routes routes;
};

struct phonet_protocol {
	const struct proto_ops *ops;
	struct proto *prot;
	int sock_type;
};

struct phonethdr {
	__u8 pn_rdev;
	__u8 pn_sdev;
	__u8 pn_res;
	__be16 pn_length;
	__u8 pn_robj;
	__u8 pn_sobj;
} __attribute__((packed));

struct phonetmsg {
	__u8 pn_trans_id;
	__u8 pn_msg_id;
	union {
		struct {
			__u8 pn_submsg_id;
			__u8 pn_data[5];
		} base;
		struct {
			__u16 pn_e_res_id;
			__u8 pn_e_submsg_id;
			__u8 pn_e_data[3];
		} ext;
	} pn_msg_u;
};

struct phy_c45_device_ids {
	u32 devices_in_package;
	u32 mmds_present;
	u32 device_ids[32];
};

struct phylink;

struct pse_control;

struct phy_driver;

struct phy_device {
	struct mdio_device mdio;
	const struct phy_driver *drv;
	struct device_link *devlink;
	u32 phyindex;
	u32 phy_id;
	struct phy_c45_device_ids c45_ids;
	unsigned int is_c45: 1;
	unsigned int is_internal: 1;
	unsigned int is_pseudo_fixed_link: 1;
	unsigned int is_gigabit_capable: 1;
	unsigned int has_fixups: 1;
	unsigned int suspended: 1;
	unsigned int suspended_by_mdio_bus: 1;
	unsigned int sysfs_links: 1;
	unsigned int loopback_enabled: 1;
	unsigned int downshifted_rate: 1;
	unsigned int is_on_sfp_module: 1;
	unsigned int mac_managed_pm: 1;
	unsigned int wol_enabled: 1;
	unsigned int autoneg: 1;
	unsigned int link: 1;
	unsigned int autoneg_complete: 1;
	unsigned int interrupts: 1;
	unsigned int irq_suspended: 1;
	unsigned int irq_rerun: 1;
	unsigned int default_timestamp: 1;
	int rate_matching;
	enum phy_state state;
	u32 dev_flags;
	phy_interface_t interface;
	long unsigned int possible_interfaces[1];
	int speed;
	int duplex;
	int port;
	int pause;
	int asym_pause;
	u8 master_slave_get;
	u8 master_slave_set;
	u8 master_slave_state;
	long unsigned int supported[2];
	long unsigned int advertising[2];
	long unsigned int lp_advertising[2];
	long unsigned int adv_old[2];
	long unsigned int supported_eee[2];
	long unsigned int advertising_eee[2];
	long unsigned int eee_broken_modes[2];
	bool enable_tx_lpi;
	bool eee_active;
	struct eee_config eee_cfg;
	long unsigned int host_interfaces[1];
	struct list_head leds;
	int irq;
	void *priv;
	struct phy_package_shared *shared;
	struct sk_buff *skb;
	void *ehdr;
	struct nlattr *nest;
	struct delayed_work state_queue;
	struct mutex lock;
	bool sfp_bus_attached;
	struct sfp_bus *sfp_bus;
	struct phylink *phylink;
	struct net_device *attached_dev;
	struct mii_timestamper *mii_ts;
	struct pse_control *psec;
	u8 mdix;
	u8 mdix_ctrl;
	int pma_extable;
	unsigned int link_down_events;
	void (*phy_link_change)(struct phy_device *, bool);
	void (*adjust_link)(struct net_device *);
};

struct phy_device_node {
	enum phy_upstream upstream_type;
	union {
		struct net_device *netdev;
		struct phy_device *phydev;
	} upstream;
	struct sfp_bus *parent_sfp_bus;
	struct phy_device *phy;
};

struct phy_driver {
	struct mdio_driver_common mdiodrv;
	u32 phy_id;
	char *name;
	u32 phy_id_mask;
	const long unsigned int * const features;
	u32 flags;
	const void *driver_data;
	int (*soft_reset)(struct phy_device *);
	int (*config_init)(struct phy_device *);
	int (*probe)(struct phy_device *);
	int (*get_features)(struct phy_device *);
	unsigned int (*inband_caps)(struct phy_device *, phy_interface_t);
	int (*config_inband)(struct phy_device *, unsigned int);
	int (*get_rate_matching)(struct phy_device *, phy_interface_t);
	int (*suspend)(struct phy_device *);
	int (*resume)(struct phy_device *);
	int (*config_aneg)(struct phy_device *);
	int (*aneg_done)(struct phy_device *);
	int (*read_status)(struct phy_device *);
	int (*config_intr)(struct phy_device *);
	irqreturn_t (*handle_interrupt)(struct phy_device *);
	void (*remove)(struct phy_device *);
	int (*match_phy_device)(struct phy_device *);
	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*link_change_notify)(struct phy_device *);
	int (*read_mmd)(struct phy_device *, int, u16);
	int (*write_mmd)(struct phy_device *, int, u16, u16);
	int (*read_page)(struct phy_device *);
	int (*write_page)(struct phy_device *, int);
	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
	int (*cable_test_start)(struct phy_device *);
	int (*cable_test_tdr_start)(struct phy_device *, const struct phy_tdr_config *);
	int (*cable_test_get_status)(struct phy_device *, bool *);
	void (*get_phy_stats)(struct phy_device *, struct ethtool_eth_phy_stats *, struct ethtool_phy_stats *);
	void (*get_link_stats)(struct phy_device *, struct ethtool_link_ext_stats *);
	int (*update_stats)(struct phy_device *);
	int (*get_sset_count)(struct phy_device *);
	void (*get_strings)(struct phy_device *, u8 *);
	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
	int (*set_loopback)(struct phy_device *, bool);
	int (*get_sqi)(struct phy_device *);
	int (*get_sqi_max)(struct phy_device *);
	int (*get_plca_cfg)(struct phy_device *, struct phy_plca_cfg *);
	int (*set_plca_cfg)(struct phy_device *, const struct phy_plca_cfg *);
	int (*get_plca_status)(struct phy_device *, struct phy_plca_status *);
	int (*led_brightness_set)(struct phy_device *, u8, enum led_brightness);
	int (*led_blink_set)(struct phy_device *, u8, long unsigned int *, long unsigned int *);
	int (*led_hw_is_supported)(struct phy_device *, u8, long unsigned int);
	int (*led_hw_control_set)(struct phy_device *, u8, long unsigned int);
	int (*led_hw_control_get)(struct phy_device *, u8, long unsigned int *);
	int (*led_polarity_set)(struct phy_device *, int, long unsigned int);
};

struct phy_fixup {
	struct list_head list;
	char bus_id[64];
	u32 phy_uid;
	u32 phy_uid_mask;
	int (*run)(struct phy_device *);
};

struct phy_link_topology {
	struct xarray phys;
	u32 next_phy_index;
};

struct phy_package_shared {
	u8 base_addr;
	struct device_node *np;
	refcount_t refcnt;
	long unsigned int flags;
	size_t priv_size;
	void *priv;
};

struct phy_plca_cfg {
	int version;
	int enabled;
	int node_id;
	int node_cnt;
	int to_tmr;
	int burst_cnt;
	int burst_tmr;
};

struct phy_plca_status {
	bool pst;
};

struct phy_req_info {
	struct ethnl_req_info base;
	struct phy_device_node *pdn;
};

struct phy_setting {
	u32 speed;
	u8 duplex;
	u8 bit;
};

struct phy_tdr_config {
	u32 first;
	u32 last;
	u32 step;
	s8 pair;
};

struct phylib_stubs {
	int (*hwtstamp_get)(struct phy_device *, struct kernel_hwtstamp_config *);
	int (*hwtstamp_set)(struct phy_device *, struct kernel_hwtstamp_config *, struct netlink_ext_ack *);
	void (*get_phy_stats)(struct phy_device *, struct ethtool_eth_phy_stats *, struct ethtool_phy_stats *);
	void (*get_link_ext_stats)(struct phy_device *, struct ethtool_link_ext_stats *);
};

struct phys_vec {
	phys_addr_t paddr;
	u32 len;
};

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct pid {
	refcount_t count;
	unsigned int level;
	spinlock_t lock;
	struct dentry *stashed;
	u64 ino;
	struct rb_node pidfs_node;
	struct hlist_head tasks[4];
	struct hlist_head inodes;
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid numbers[0];
};

union proc_op {
	int (*proc_get_link)(struct dentry *, struct path *);
	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
	int lsmid;
};

struct pid_entry {
	const char *name;
	unsigned int len;
	umode_t mode;
	const struct inode_operations *iop;
	const struct file_operations *fop;
	union proc_op op;
};

struct pid_namespace {
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	int pid_max;
	struct pid_namespace *parent;
	struct fs_pin *bacct;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	int reboot;
	struct ns_common ns;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	int memfd_noexec_scope;
};

struct pidfd_info {
	__u64 mask;
	__u64 cgroupid;
	__u32 pid;
	__u32 tgid;
	__u32 ppid;
	__u32 ruid;
	__u32 rgid;
	__u32 euid;
	__u32 egid;
	__u32 suid;
	__u32 sgid;
	__u32 fsuid;
	__u32 fsgid;
	__u32 spare0[1];
};

struct pids_cgroup {
	struct cgroup_subsys_state css;
	atomic64_t counter;
	atomic64_t limit;
	int64_t watermark;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	atomic64_t events[2];
	atomic64_t events_local[2];
};

struct pie_sched_data {
	struct pie_vars vars;
	struct pie_params params;
	struct pie_stats stats;
	struct timer_list adapt_timer;
	struct Qdisc *sch;
};

struct pie_skb_cb {
	psched_time_t enqueue_time;
	u32 mem_usage;
};

struct pimhdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
};

struct pimreghdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
	__be32 flags;
};

struct pinctrl_map_mux {
	const char *group;
	const char *function;
};

struct pinctrl_map_configs {
	const char *group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_map {
	const char *dev_name;
	const char *name;
	enum pinctrl_map_type type;
	const char *ctrl_dev_name;
	union {
		struct pinctrl_map_mux mux;
		struct pinctrl_map_configs configs;
	} data;
};

struct ping_iter_state {
	struct seq_net_private p;
	int bucket;
	sa_family_t family;
};

struct ping_table {
	struct hlist_head hash[64];
	spinlock_t lock;
};

struct pingfakehdr {
	struct icmphdr icmph;
	struct msghdr *msg;
	sa_family_t family;
	__wsum wcheck;
};

struct pingv6_ops {
	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	int (*icmpv6_err_convert)(u8, u8, int *);
	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*ipv6_chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
};

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};

struct pipe_buffer {
	struct page *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	long unsigned int private;
};

union pipe_index {
	long unsigned int head_tail;
	struct {
		pipe_index_t head;
		pipe_index_t tail;
	};
};

struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t rd_wait;
	wait_queue_head_t wr_wait;
	union {
		long unsigned int head_tail;
		struct {
			pipe_index_t head;
			pipe_index_t tail;
		};
	};
	unsigned int max_usage;
	unsigned int ring_size;
	unsigned int nr_accounted;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int r_counter;
	unsigned int w_counter;
	bool poll_usage;
	struct page *tmp_page;
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;
	struct user_struct *user;
};

struct pipe_wait {
	struct trace_iterator *iter;
	int wait_index;
};

struct pkcs1pad_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct pkcs1pad_inst_ctx {
	struct crypto_akcipher_spawn spawn;
};

struct pkcs1pad_request {
	struct scatterlist in_sg[2];
	struct scatterlist out_sg[1];
	uint8_t *in_buf;
	uint8_t *out_buf;
	struct akcipher_request child_req;
};

struct x509_certificate;

struct pkcs7_signed_info;

struct pkcs7_message {
	struct x509_certificate *certs;
	struct x509_certificate *crl;
	struct pkcs7_signed_info *signed_infos;
	u8 version;
	bool have_authattrs;
	enum OID data_type;
	size_t data_len;
	size_t data_hdrlen;
	const void *data;
};

struct pkcs7_parse_context {
	struct pkcs7_message *msg;
	struct pkcs7_signed_info *sinfo;
	struct pkcs7_signed_info **ppsinfo;
	struct x509_certificate *certs;
	struct x509_certificate **ppcerts;
	long unsigned int data;
	enum OID last_oid;
	unsigned int x509_index;
	unsigned int sinfo_index;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_skid;
	unsigned int raw_skid_size;
	bool expect_skid;
};

struct pkcs7_signed_info {
	struct pkcs7_signed_info *next;
	struct x509_certificate *signer;
	unsigned int index;
	bool unsupported_crypto;
	bool blacklisted;
	const void *msgdigest;
	unsigned int msgdigest_len;
	unsigned int authattrs_len;
	const void *authattrs;
	long unsigned int aa_set;
	time64_t signing_time;
	struct public_key_signature *sig;
};

struct pkru_state {
	u32 pkru;
	u32 pad;
};

struct plat_serial8250_port {
	long unsigned int iobase;
	void *membase;
	resource_size_t mapbase;
	resource_size_t mapsize;
	unsigned int uartclk;
	unsigned int irq;
	long unsigned int irqflags;
	void *private_data;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char hub6;
	unsigned char has_sysrq;
	unsigned int type;
	upf_t flags;
	u16 bugs;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	u32 (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, u32);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
};

struct stepping_desc {
	const enum intel_step *map;
	size_t size;
};

struct subplatform_desc;

struct platform_desc {
	struct intel_display_platforms platforms;
	const char *name;
	const struct subplatform_desc *subplatforms;
	const struct intel_display_device_info *info;
	struct stepping_desc step_info;
};

struct mfd_cell;

struct platform_device_id;

struct platform_device {
	const char *name;
	int id;
	bool id_auto;
	struct device dev;
	u64 platform_dma_mask;
	struct device_dma_parameters dma_parms;
	u32 num_resources;
	struct resource *resource;
	const struct platform_device_id *id_entry;
	const char *driver_override;
	struct mfd_cell *mfd_cell;
	struct pdev_archdata archdata;
};

struct platform_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct platform_device_info {
	struct device *parent;
	struct fwnode_handle *fwnode;
	bool of_node_reused;
	const char *name;
	int id;
	const struct resource *res;
	unsigned int num_res;
	const void *data;
	size_t size_data;
	u64 dma_mask;
	const struct property_entry *properties;
};

struct platform_driver {
	int (*probe)(struct platform_device *);
	void (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
	bool driver_managed_dma;
};

struct platform_hibernation_ops {
	int (*begin)(pm_message_t);
	void (*end)(void);
	int (*pre_snapshot)(void);
	void (*finish)(void);
	int (*prepare)(void);
	int (*enter)(void);
	void (*leave)(void);
	int (*pre_restore)(void);
	void (*restore_cleanup)(void);
	void (*recover)(void);
};

struct platform_object {
	struct platform_device pdev;
	char name[0];
};

struct platform_s2idle_ops {
	int (*begin)(void);
	int (*prepare)(void);
	int (*prepare_late)(void);
	void (*check)(void);
	bool (*wake)(void);
	void (*restore_early)(void);
	void (*restore)(void);
	void (*end)(void);
};

struct platform_suspend_ops {
	int (*valid)(suspend_state_t);
	int (*begin)(suspend_state_t);
	int (*prepare)(void);
	int (*prepare_late)(void);
	int (*enter)(suspend_state_t);
	void (*wake)(void);
	void (*finish)(void);
	bool (*suspend_again)(void);
	void (*end)(void);
	void (*recover)(void);
};

struct plca_reply_data {
	struct ethnl_reply_data base;
	struct phy_plca_cfg plca_cfg;
	struct phy_plca_status plca_st;
};

struct plug_sched_data {
	bool unplug_indefinite;
	bool throttled;
	u32 limit;
	u32 pkts_current_epoch;
	u32 pkts_last_epoch;
	u32 pkts_to_release;
};

struct pm_nl_pernet {
	spinlock_t lock;
	struct list_head local_addr_list;
	unsigned int addrs;
	unsigned int stale_loss_cnt;
	unsigned int add_addr_signal_max;
	unsigned int add_addr_accept_max;
	unsigned int local_addr_max;
	unsigned int subflows_max;
	unsigned int next_id;
	long unsigned int id_bitmap[4];
};

struct pm_subsys_data {
	spinlock_t lock;
	unsigned int refcount;
};

struct pm_vt_switch {
	struct list_head head;
	struct device *dev;
	bool required;
};

struct pmap {
	size_t offset;
	const char *name;
};

struct pmu_event_list {
	raw_spinlock_t lock;
	struct list_head list;
};

struct pneigh_entry {
	struct pneigh_entry *next;
	possible_net_t net;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u32 flags;
	u8 protocol;
	u32 key[0];
};

struct pnfs_layout_segment {
	struct list_head pls_list;
	struct list_head pls_lc_list;
	struct list_head pls_commits;
	struct pnfs_layout_range pls_range;
	refcount_t pls_refcount;
	u32 pls_seq;
	long unsigned int pls_flags;
	struct pnfs_layout_hdr *pls_layout;
};

struct pnp_protocol;

struct pnp_id;

struct pnp_card {
	struct device dev;
	unsigned char number;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head devices;
	struct pnp_protocol *protocol;
	struct pnp_id *id;
	char name[50];
	unsigned char pnpver;
	unsigned char productver;
	unsigned int serial;
	unsigned char checksum;
	struct proc_dir_entry *procdir;
};

struct pnp_card_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
	struct {
		__u8 id[8];
	} devs[8];
};

struct pnp_device_id;

struct pnp_driver {
	const char *name;
	const struct pnp_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_dev *, const struct pnp_device_id *);
	void (*remove)(struct pnp_dev *);
	void (*shutdown)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	struct device_driver driver;
};

struct pnp_card_link;

struct pnp_card_driver {
	struct list_head global_list;
	char *name;
	const struct pnp_card_device_id *id_table;
	unsigned int flags;
	int (*probe)(struct pnp_card_link *, const struct pnp_card_device_id *);
	void (*remove)(struct pnp_card_link *);
	int (*suspend)(struct pnp_card_link *, pm_message_t);
	int (*resume)(struct pnp_card_link *);
	struct pnp_driver link;
};

struct pnp_card_link {
	struct pnp_card *card;
	struct pnp_card_driver *driver;
	void *driver_data;
	pm_message_t pm_state;
};

struct pnp_dev {
	struct device dev;
	u64 dma_mask;
	unsigned int number;
	int status;
	struct list_head global_list;
	struct list_head protocol_list;
	struct list_head card_list;
	struct list_head rdev_list;
	struct pnp_protocol *protocol;
	struct pnp_card *card;
	struct pnp_driver *driver;
	struct pnp_card_link *card_link;
	struct pnp_id *id;
	int active;
	int capabilities;
	unsigned int num_dependent_sets;
	struct list_head resources;
	struct list_head options;
	char name[50];
	int flags;
	struct proc_dir_entry *procent;
	void *data;
};

struct pnp_device_id {
	__u8 id[8];
	kernel_ulong_t driver_data;
};

struct pnp_dma {
	unsigned char map;
	unsigned char flags;
};

struct pnp_fixup {
	char id[7];
	void (*quirk_function)(struct pnp_dev *);
};

struct pnp_id {
	char id[8];
	struct pnp_id *next;
};

struct pnp_info_buffer {
	char *buffer;
	char *curr;
	long unsigned int size;
	long unsigned int len;
	int stop;
	int error;
};

typedef struct pnp_info_buffer pnp_info_buffer_t;

struct pnp_irq {
	pnp_irq_mask_t map;
	unsigned char flags;
};

struct pnp_mem {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

struct pnp_port {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t size;
	unsigned char flags;
};

struct pnp_option {
	struct list_head list;
	unsigned int flags;
	long unsigned int type;
	union {
		struct pnp_port port;
		struct pnp_irq irq;
		struct pnp_dma dma;
		struct pnp_mem mem;
	} u;
};

struct pnp_protocol {
	struct list_head protocol_list;
	char *name;
	int (*get)(struct pnp_dev *);
	int (*set)(struct pnp_dev *);
	int (*disable)(struct pnp_dev *);
	bool (*can_wakeup)(struct pnp_dev *);
	int (*suspend)(struct pnp_dev *, pm_message_t);
	int (*resume)(struct pnp_dev *);
	unsigned char number;
	struct device dev;
	struct list_head cards;
	struct list_head devices;
};

struct pnp_resource {
	struct list_head list;
	struct resource res;
};

struct pnpipehdr {
	u8 utid;
	u8 message_id;
	u8 pipe_handle;
	union {
		u8 state_after_connect;
		u8 state_after_reset;
		u8 error_code;
		u8 pep_type;
		u8 data0;
	};
	u8 data[0];
};

struct pollfd {
	int fd;
	short int events;
	short int revents;
};

struct poll_list {
	struct poll_list *next;
	unsigned int len;
	struct pollfd entries[0];
};

struct poll_table_entry {
	struct file *filp;
	__poll_t key;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_address;
};

struct poll_table_page {
	struct poll_table_page *next;
	struct poll_table_entry *entry;
	struct poll_table_entry entries[0];
};

struct poll_wqueues {
	poll_table pt;
	struct poll_table_page *table;
	struct task_struct *polling_task;
	int triggered;
	int error;
	int inline_index;
	struct poll_table_entry inline_entries[9];
};

struct worker_pool;

struct pool_workqueue {
	struct worker_pool *pool;
	struct workqueue_struct *wq;
	int work_color;
	int flush_color;
	int refcnt;
	int nr_in_flight[16];
	bool plugged;
	int nr_active;
	struct list_head inactive_works;
	struct list_head pending_node;
	struct list_head pwqs_node;
	struct list_head mayday_node;
	u64 stats[8];
	struct kthread_work release_work;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct port_stats {
	long unsigned int bytes_sent;
	long unsigned int bytes_received;
	long unsigned int bytes_discarded;
};

struct ports_device;

struct port_buffer;

struct virtqueue;

struct port___2 {
	struct list_head list;
	struct ports_device *portdev;
	struct port_buffer *inbuf;
	spinlock_t inbuf_lock;
	spinlock_t outvq_lock;
	struct virtqueue *in_vq;
	struct virtqueue *out_vq;
	struct dentry *debugfs_file;
	struct port_stats stats;
	struct console___2 cons;
	struct cdev *cdev;
	struct device *dev;
	struct kref kref;
	wait_queue_head_t waitqueue;
	char *name;
	struct fasync_struct *async_queue;
	u32 id;
	bool outvq_full;
	bool host_connected;
	bool guest_connected;
};

struct port_buffer {
	char *buf;
	size_t size;
	size_t len;
	size_t offset;
	dma_addr_t dma;
	struct device *dev;
	struct list_head list;
	unsigned int sgpages;
	struct scatterlist sg[0];
};

struct port_identity {
	struct clock_identity clock_identity;
	__be16 port_number;
};

struct portdrv_service_data {
	struct pcie_port_service_driver *drv;
	struct device *dev;
	u32 service;
};

struct virtio_console_control {
	__virtio32 id;
	__virtio16 event;
	__virtio16 value;
};

struct virtio_device;

struct ports_device {
	struct list_head list;
	struct work_struct control_work;
	struct work_struct config_work;
	struct list_head ports;
	spinlock_t ports_lock;
	spinlock_t c_ivq_lock;
	spinlock_t c_ovq_lock;
	u32 max_nr_ports;
	struct virtio_device *vdev;
	struct virtqueue *c_ivq;
	struct virtqueue *c_ovq;
	struct virtio_console_control cpkt;
	struct virtqueue **in_vqs;
	struct virtqueue **out_vqs;
	int chr_major;
};

struct ports_driver_data {
	struct dentry *debugfs_dir;
	struct list_head portdevs;
	struct list_head consoles;
};

struct posix_acl_xattr_entry {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
};

struct posix_acl_xattr_header {
	__le32 a_version;
};

struct posix_clock;

struct posix_clock_context;

struct posix_clock_operations {
	struct module *owner;
	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
	long int (*ioctl)(struct posix_clock_context *, unsigned int, long unsigned int);
	int (*open)(struct posix_clock_context *, fmode_t);
	__poll_t (*poll)(struct posix_clock_context *, struct file *, poll_table *);
	int (*release)(struct posix_clock_context *);
	ssize_t (*read)(struct posix_clock_context *, uint, char *, size_t);
};

struct posix_clock {
	struct posix_clock_operations ops;
	struct cdev cdev;
	struct device *dev;
	struct rw_semaphore rwsem;
	bool zombie;
};

struct posix_clock_context {
	struct posix_clock *clk;
	void *private_clkdata;
};

struct posix_clock_desc {
	struct file *fp;
	struct posix_clock *clk;
};

struct posix_cputimer_base {
	u64 nextevt;
	struct timerqueue_head tqhead;
};

struct posix_cputimers {
	struct posix_cputimer_base bases[3];
	unsigned int timers_active;
	unsigned int expiry_active;
};

struct posix_cputimers_work {
	struct callback_head work;
	struct mutex mutex;
	unsigned int scheduled;
};

struct posix_msg_tree_node {
	struct rb_node rb_node;
	struct list_head msg_list;
	int priority;
};

struct postprocess_bh_ctx {
	struct work_struct work;
	struct buffer_head *bh;
};

struct power_supply_battery_info;

struct power_supply {
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;
	char **supplied_from;
	size_t num_supplies;
	struct device_node *of_node;
	void *drv_data;
	struct device dev;
	struct work_struct changed_work;
	struct delayed_work deferred_register_work;
	spinlock_t changed_lock;
	bool changed;
	bool update_groups;
	bool initialized;
	bool removing;
	atomic_t use_cnt;
	struct power_supply_battery_info *battery_info;
	struct rw_semaphore extensions_sem;
	struct list_head extensions;
	struct thermal_zone_device *tzd;
	struct thermal_cooling_device *tcd;
	struct led_trigger *trig;
	struct led_trigger *charging_trig;
	struct led_trigger *full_trig;
	struct led_trigger *charging_blink_full_solid_trig;
	struct led_trigger *charging_orange_full_green_trig;
};

struct power_supply_attr {
	const char *prop_name;
	char attr_name[31];
	struct device_attribute dev_attr;
	const char * const *text_values;
	int text_values_len;
};

struct power_supply_maintenance_charge_table;

struct power_supply_battery_ocv_table;

struct power_supply_resistance_temp_table;

struct power_supply_vbat_ri_table;

struct power_supply_battery_info {
	unsigned int technology;
	int energy_full_design_uwh;
	int charge_full_design_uah;
	int voltage_min_design_uv;
	int voltage_max_design_uv;
	int tricklecharge_current_ua;
	int precharge_current_ua;
	int precharge_voltage_max_uv;
	int charge_term_current_ua;
	int charge_restart_voltage_uv;
	int overvoltage_limit_uv;
	int constant_charge_current_max_ua;
	int constant_charge_voltage_max_uv;
	const struct power_supply_maintenance_charge_table *maintenance_charge;
	int maintenance_charge_size;
	int alert_low_temp_charge_current_ua;
	int alert_low_temp_charge_voltage_uv;
	int alert_high_temp_charge_current_ua;
	int alert_high_temp_charge_voltage_uv;
	int factory_internal_resistance_uohm;
	int factory_internal_resistance_charging_uohm;
	int ocv_temp[20];
	int temp_ambient_alert_min;
	int temp_ambient_alert_max;
	int temp_alert_min;
	int temp_alert_max;
	int temp_min;
	int temp_max;
	const struct power_supply_battery_ocv_table *ocv_table[20];
	int ocv_table_size[20];
	const struct power_supply_resistance_temp_table *resist_table;
	int resist_table_size;
	const struct power_supply_vbat_ri_table *vbat2ri_discharging;
	int vbat2ri_discharging_size;
	const struct power_supply_vbat_ri_table *vbat2ri_charging;
	int vbat2ri_charging_size;
	int bti_resistance_ohm;
	int bti_resistance_tolerance;
};

struct power_supply_battery_ocv_table {
	int ocv;
	int capacity;
};

struct power_supply_config {
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	void *drv_data;
	const struct attribute_group **attr_grp;
	char **supplied_to;
	size_t num_supplicants;
	bool no_wakeup_source;
};

struct power_supply_ext {
	const char * const name;
	u8 charge_behaviours;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, const struct power_supply_ext *, void *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, const struct power_supply_ext *, void *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, const struct power_supply_ext *, void *, enum power_supply_property);
};

struct power_supply_ext_registration {
	struct list_head list_head;
	const struct power_supply_ext *ext;
	struct device *dev;
	void *data;
};

struct power_supply_hwmon {
	struct power_supply *psy;
	long unsigned int *props;
};

struct power_supply_led_trigger {
	struct led_trigger trig;
	struct power_supply *psy;
};

struct power_supply_maintenance_charge_table {
	int charge_current_max_ua;
	int charge_voltage_max_uv;
	int charge_safety_timer_minutes;
};

union power_supply_propval {
	int intval;
	const char *strval;
};

struct power_supply_resistance_temp_table {
	int temp;
	int resistance;
};

struct power_supply_vbat_ri_table {
	int vbat_uv;
	int ri_uohm;
};

struct ppin_info {
	int feature;
	int msr_ppin_ctl;
	int msr_ppin;
};

struct pppoe_tag {
	__be16 tag_type;
	__be16 tag_len;
	char tag_data[0];
};

struct pppoe_hdr {
	__u8 type: 4;
	__u8 ver: 4;
	__u8 code;
	__be16 sid;
	__be16 length;
	struct pppoe_tag tag[0];
};

struct pps_bind_args {
	int tsformat;
	int edge;
	int consumer;
};

struct pps_device;

struct pps_source_info {
	char name[32];
	char path[32];
	int mode;
	void (*echo)(struct pps_device *, int, void *);
	struct module *owner;
	struct device *dev;
};

struct pps_ktime {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_kparams {
	int api_version;
	int mode;
	struct pps_ktime assert_off_tu;
	struct pps_ktime clear_off_tu;
};

struct pps_device {
	struct pps_source_info info;
	struct pps_kparams params;
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
	unsigned int last_ev;
	wait_queue_head_t queue;
	unsigned int id;
	const void *lookup_cookie;
	struct device dev;
	struct fasync_struct *async_queue;
	spinlock_t lock;
};

struct pps_event_time {
	struct timespec64 ts_real;
};

struct pps_kinfo {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
};

struct pps_fdata {
	struct pps_kinfo info;
	struct pps_ktime timeout;
};

struct pps_registers {
	i915_reg_t pp_ctrl;
	i915_reg_t pp_stat;
	i915_reg_t pp_on;
	i915_reg_t pp_off;
	i915_reg_t pp_div;
};

union pptp_ctrl_union {
	struct PptpStartSessionRequest sreq;
	struct PptpStartSessionReply srep;
	struct PptpStopSessionRequest streq;
	struct PptpStopSessionReply strep;
	struct PptpOutCallRequest ocreq;
	struct PptpOutCallReply ocack;
	struct PptpInCallRequest icreq;
	struct PptpInCallReply icack;
	struct PptpInCallConnected iccon;
	struct PptpClearCallRequest clrreq;
	struct PptpCallDisconnectNotify disc;
	struct PptpWanErrorNotify wanerr;
	struct PptpSetLinkInfo setlink;
};

struct pptp_gre_header {
	struct gre_base_hdr gre_hd;
	__be16 payload_len;
	__be16 call_id;
	__be32 seq;
	__be32 ack;
};

struct pptp_pkt_hdr {
	__u16 packetLength;
	__be16 packetType;
	__be32 magicCookie;
};

struct pr_clear {
	__u64 key;
	__u32 flags;
	__u32 __pad;
};

struct pr_cont_work_struct {
	bool comma;
	work_func_t func;
	long int ctr;
};

struct pr_held_reservation {
	u64 key;
	u32 generation;
	enum pr_type type;
};

struct pr_keys {
	u32 generation;
	u32 num_keys;
	u64 keys[0];
};

struct pr_ops {
	int (*pr_register)(struct block_device *, u64, u64, u32);
	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
	int (*pr_release)(struct block_device *, u64, enum pr_type);
	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
	int (*pr_clear)(struct block_device *, u64);
	int (*pr_read_keys)(struct block_device *, struct pr_keys *);
	int (*pr_read_reservation)(struct block_device *, struct pr_held_reservation *);
};

struct pr_preempt {
	__u64 old_key;
	__u64 new_key;
	__u32 type;
	__u32 flags;
};

struct pr_registration {
	__u64 old_key;
	__u64 new_key;
	__u32 flags;
	__u32 __pad;
};

struct pr_reservation {
	__u64 key;
	__u32 type;
	__u32 flags;
};

struct prb_data_blk_lpos {
	long unsigned int begin;
	long unsigned int next;
};

struct prb_data_block {
	long unsigned int id;
	char data[0];
};

struct prb_data_ring {
	unsigned int size_bits;
	char *data;
	atomic_long_t head_lpos;
	atomic_long_t tail_lpos;
};

struct prb_desc {
	atomic_long_t state_var;
	struct prb_data_blk_lpos text_blk_lpos;
};

struct printk_info;

struct prb_desc_ring {
	unsigned int count_bits;
	struct prb_desc *descs;
	struct printk_info *infos;
	atomic_long_t head_id;
	atomic_long_t tail_id;
	atomic_long_t last_finalized_seq;
};

struct printk_ringbuffer;

struct prb_reserved_entry {
	struct printk_ringbuffer *rb;
	long unsigned int irqflags;
	long unsigned int id;
	unsigned int text_space;
};

struct prctl_mm_map {
	__u64 start_code;
	__u64 end_code;
	__u64 start_data;
	__u64 end_data;
	__u64 start_brk;
	__u64 brk;
	__u64 start_stack;
	__u64 arg_start;
	__u64 arg_end;
	__u64 env_start;
	__u64 env_end;
	__u64 *auxv;
	__u32 auxv_size;
	__u32 exe_fd;
};

struct preempt_ops {
	void (*sched_in)(struct preempt_notifier *, int);
	void (*sched_out)(struct preempt_notifier *, struct task_struct *);
};

struct prefix_cacheinfo {
	__u32 preferred_time;
	__u32 valid_time;
};

struct prefix_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	union {
		__u8 flags;
		struct {
			__u8 reserved: 4;
			__u8 preferpd: 1;
			__u8 routeraddr: 1;
			__u8 autoconf: 1;
			__u8 onlink: 1;
		};
	};
	__be32 valid;
	__be32 prefered;
	__be32 reserved2;
	struct in6_addr prefix;
};

struct prefixmsg {
	unsigned char prefix_family;
	unsigned char prefix_pad1;
	short unsigned int prefix_pad2;
	int prefix_ifindex;
	unsigned char prefix_type;
	unsigned char prefix_len;
	unsigned char prefix_flags;
	unsigned char prefix_pad3;
};

struct preftree {
	struct rb_root_cached root;
	unsigned int count;
};

struct preftrees {
	struct preftree direct;
	struct preftree indirect;
	struct preftree indirect_missing_keys;
};

struct prelim_ref {
	struct rb_node rbnode;
	u64 root_id;
	struct btrfs_key key_for_search;
	u8 level;
	int count;
	struct extent_inode_elem *inode_list;
	u64 parent;
	u64 wanted_disk_byte;
};

struct prepend_buffer {
	char *buf;
	int len;
};

struct print_entry {
	struct trace_entry ent;
	long unsigned int ip;
	char buf[0];
};

struct printf_spec {
	unsigned char flags;
	unsigned char base;
	short int precision;
	int field_width;
};

struct printk_info {
	u64 seq;
	u64 ts_nsec;
	u16 text_len;
	u8 facility;
	u8 flags: 5;
	u8 level: 3;
	u32 caller_id;
	struct dev_printk_info dev_info;
};

struct printk_message {
	struct printk_buffers *pbufs;
	unsigned int outbuf_len;
	u64 seq;
	long unsigned int dropped;
};

struct printk_record {
	struct printk_info *info;
	char *text_buf;
	unsigned int text_buf_size;
};

struct printk_ringbuffer {
	struct prb_desc_ring desc_ring;
	struct prb_data_ring text_data_ring;
	atomic_long_t fail;
};

struct prio_sched_data {
	int bands;
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	u8 prio2band[16];
	struct Qdisc *queues[16];
};

struct privflags_reply_data {
	struct ethnl_reply_data base;
	const char (*priv_flag_names)[32];
	unsigned int n_priv_flags;
	u32 priv_flags;
};

struct prm_buffer {
	u8 prm_status;
	u64 efi_status;
	u8 prm_cmd;
	guid_t handler_guid;
} __attribute__((packed));

struct prm_mmio_info;

struct prm_context_buffer {
	char signature[4];
	u16 revision;
	u16 reserved;
	guid_t identifier;
	u64 static_data_buffer;
	struct prm_mmio_info *mmio_ranges;
};

struct prm_handler_info {
	efi_guid_t guid;
	efi_status_t (*handler_addr)(u64, void *);
	u64 static_data_buffer_addr;
	u64 acpi_param_buffer_addr;
	struct list_head handler_list;
};

struct prm_mmio_addr_range {
	u64 phys_addr;
	u64 virt_addr;
	u32 length;
} __attribute__((packed));

struct prm_mmio_info {
	u64 mmio_count;
	struct prm_mmio_addr_range addr_ranges[0];
};

struct prm_module_info {
	guid_t guid;
	u16 major_rev;
	u16 minor_rev;
	u16 handler_count;
	struct prm_mmio_info *mmio_info;
	bool updatable;
	struct list_head module_list;
	struct prm_handler_info handlers[0];
};

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);

struct probe {
	struct probe *next;
	dev_t dev;
	long unsigned int range;
	struct module *owner;
	kobj_probe_t *get;
	int (*lock)(dev_t, void *);
	void *data;
};

struct probe_arg {
	struct fetch_insn *code;
	bool dynamic;
	unsigned int offset;
	unsigned int count;
	const char *name;
	const char *comm;
	char *fmt;
	const struct fetch_type *type;
};

struct probe_entry_arg {
	struct fetch_insn *code;
	unsigned int size;
};

typedef int (*proc_write_t)(struct file *, char *, size_t);

struct proc_ops;

struct proc_dir_entry {
	atomic_t in_use;
	refcount_t refcnt;
	struct list_head pde_openers;
	spinlock_t pde_unload_lock;
	struct completion *pde_unload_completion;
	const struct inode_operations *proc_iops;
	union {
		const struct proc_ops *proc_ops;
		const struct file_operations *proc_dir_ops;
	};
	const struct dentry_operations *proc_dops;
	union {
		const struct seq_operations *seq_ops;
		int (*single_show)(struct seq_file *, void *);
	};
	proc_write_t write;
	void *data;
	unsigned int state_size;
	unsigned int low_ino;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct proc_dir_entry *parent;
	struct rb_root subdir;
	struct rb_node subdir_node;
	char *name;
	umode_t mode;
	u8 flags;
	u8 namelen;
	char inline_name[0];
};

struct sid_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct ptrace_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t tracer_pid;
	__kernel_pid_t tracer_tgid;
};

struct proc_event {
	enum proc_cn_event what;
	__u32 cpu;
	__u64 timestamp_ns;
	union {
		struct {
			__u32 err;
		} ack;
		struct fork_proc_event fork;
		struct exec_proc_event exec;
		struct id_proc_event id;
		struct sid_proc_event sid;
		struct ptrace_proc_event ptrace;
		struct comm_proc_event comm;
		struct coredump_proc_event coredump;
		struct exit_proc_event exit;
	} event_data;
};

struct proc_fs_context {
	struct pid_namespace *pid_ns;
	unsigned int mask;
	enum proc_hidepid hidepid;
	int gid;
	enum proc_pidonly pidonly;
};

struct proc_fs_info {
	struct pid_namespace *pid_ns;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
	kgid_t pid_gid;
	enum proc_hidepid hide_pid;
	enum proc_pidonly pidonly;
	struct callback_head rcu;
};

struct proc_fs_opts {
	int flag;
	const char *str;
};

struct proc_inode {
	struct pid *pid;
	unsigned int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	const struct ctl_table *sysctl_entry;
	struct hlist_node sibling_inodes;
	const struct proc_ns_operations *ns_ops;
	struct inode vfs_inode;
};

struct proc_input {
	enum proc_cn_mcast_op mcast_op;
	enum proc_cn_event event_type;
};

struct proc_mounts {
	struct mnt_namespace *ns;
	struct path root;
	int (*show)(struct seq_file *, struct vfsmount *);
};

struct proc_nfs_info {
	int flag;
	const char *str;
	const char *nostr;
};

struct proc_ns_operations {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common * (*get)(struct task_struct *);
	void (*put)(struct ns_common *);
	int (*install)(struct nsset *, struct ns_common *);
	struct user_namespace * (*owner)(struct ns_common *);
	struct ns_common * (*get_parent)(struct ns_common *);
};

struct proc_ops {
	unsigned int proc_flags;
	int (*proc_open)(struct inode *, struct file *);
	ssize_t (*proc_read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*proc_write)(struct file *, const char *, size_t, loff_t *);
	loff_t (*proc_lseek)(struct file *, loff_t, int);
	int (*proc_release)(struct inode *, struct file *);
	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
	long int (*proc_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*proc_mmap)(struct file *, struct vm_area_struct *);
	long unsigned int (*proc_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
};

struct proc_timens_offset {
	int clockid;
	struct timespec64 val;
};

struct proc_xfs_info {
	uint64_t flag;
	char *str;
};

struct process_timer {
	struct timer_list timer;
	struct task_struct *task;
};

struct procmap_query {
	__u64 size;
	__u64 query_flags;
	__u64 query_addr;
	__u64 vma_start;
	__u64 vma_end;
	__u64 vma_flags;
	__u64 vma_page_size;
	__u64 vma_offset;
	__u64 inode;
	__u32 dev_major;
	__u32 dev_minor;
	__u32 vma_name_size;
	__u32 build_id_size;
	__u64 vma_name_addr;
	__u64 build_id_addr;
};

struct prog_entry {
	int target;
	int when_to_branch;
	struct filter_pred *pred;
};

struct prog_poke_elem {
	struct list_head list;
	struct bpf_prog_aux *aux;
};

struct prog_test_member1 {
	int a;
};

struct prog_test_member {
	struct prog_test_member1 m;
	int c;
};

struct prog_test_ref_kfunc {
	int a;
	int b;
	struct prog_test_member memb;
	struct prog_test_ref_kfunc *next;
	refcount_t cnt;
};

struct prop_handler {
	struct hlist_node node;
	const char *xattr_name;
	int (*validate)(const struct btrfs_inode *, const char *, size_t);
	int (*apply)(struct inode *, const char *, size_t);
	const char * (*extract)(const struct inode *);
	bool (*ignore)(const struct btrfs_inode *);
	int inheritable;
};

struct property {
	char *name;
	int length;
	void *value;
	struct property *next;
};

struct prot_inuse {
	int all;
	int val[64];
};

struct protection_domain {
	struct list_head dev_list;
	struct iommu_domain domain;
	struct amd_io_pgtable iop;
	spinlock_t lock;
	u16 id;
	enum protection_domain_mode pd_mode;
	bool dirty_tracking;
	struct xarray iommu_array;
	struct mmu_notifier mn;
	struct list_head dev_data_list;
};

struct smc_hashinfo;

struct proto_accept_arg;

struct sk_psock;

struct timewait_sock_ops;

struct raw_hashinfo;

struct proto {
	void (*close)(struct sock *, long int);
	int (*pre_connect)(struct sock *, struct sockaddr *, int);
	int (*connect)(struct sock *, struct sockaddr *, int);
	int (*disconnect)(struct sock *, int);
	struct sock * (*accept)(struct sock *, struct proto_accept_arg *);
	int (*ioctl)(struct sock *, int, int *);
	int (*init)(struct sock *);
	void (*destroy)(struct sock *);
	void (*shutdown)(struct sock *, int);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*keepalive)(struct sock *, int);
	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int *);
	void (*splice_eof)(struct socket *);
	int (*bind)(struct sock *, struct sockaddr *, int);
	int (*bind_add)(struct sock *, struct sockaddr *, int);
	int (*backlog_rcv)(struct sock *, struct sk_buff *);
	bool (*bpf_bypass_getsockopt)(int, int);
	void (*release_cb)(struct sock *);
	int (*hash)(struct sock *);
	void (*unhash)(struct sock *);
	void (*rehash)(struct sock *);
	int (*get_port)(struct sock *, short unsigned int);
	void (*put_port)(struct sock *);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	unsigned int inuse_idx;
	int (*forward_alloc_get)(const struct sock *);
	bool (*stream_memory_free)(const struct sock *, int);
	bool (*sock_is_readable)(struct sock *);
	void (*enter_memory_pressure)(struct sock *);
	void (*leave_memory_pressure)(struct sock *);
	atomic_long_t *memory_allocated;
	int *per_cpu_fw_alloc;
	struct percpu_counter *sockets_allocated;
	long unsigned int *memory_pressure;
	long int *sysctl_mem;
	int *sysctl_wmem;
	int *sysctl_rmem;
	u32 sysctl_wmem_offset;
	u32 sysctl_rmem_offset;
	int max_header;
	bool no_autobind;
	struct kmem_cache *slab;
	unsigned int obj_size;
	unsigned int ipv6_pinfo_offset;
	slab_flags_t slab_flags;
	unsigned int useroffset;
	unsigned int usersize;
	unsigned int *orphan_count;
	struct request_sock_ops *rsk_prot;
	struct timewait_sock_ops *twsk_prot;
	union {
		struct inet_hashinfo *hashinfo;
		struct udp_table *udp_table;
		struct raw_hashinfo *raw_hash;
		struct smc_hashinfo *smc_hash;
	} h;
	struct module *owner;
	char name[32];
	struct list_head node;
	int (*diag_destroy)(struct sock *, int);
};

struct proto_accept_arg {
	int flags;
	int err;
	int is_empty;
	bool kern;
};

typedef int (*skb_read_actor_t)(struct sock *, struct sk_buff *);

struct proto_ops {
	int family;
	struct module *owner;
	int (*release)(struct socket *);
	int (*bind)(struct socket *, struct sockaddr *, int);
	int (*connect)(struct socket *, struct sockaddr *, int, int);
	int (*socketpair)(struct socket *, struct socket *);
	int (*accept)(struct socket *, struct socket *, struct proto_accept_arg *);
	int (*getname)(struct socket *, struct sockaddr *, int);
	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*gettstamp)(struct socket *, void *, bool, bool);
	int (*listen)(struct socket *, int);
	int (*shutdown)(struct socket *, int);
	int (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct socket *, int, int, char *, int *);
	void (*show_fdinfo)(struct seq_file *, struct socket *);
	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*splice_eof)(struct socket *);
	int (*set_peek_off)(struct sock *, int);
	int (*peek_len)(struct socket *);
	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
	int (*read_skb)(struct sock *, skb_read_actor_t);
	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
	int (*set_rcvlowat)(struct sock *, int);
};

struct prp_rct {
	__be16 sequence_nr;
	__be16 lan_id_and_LSDU_size;
	__be16 PRP_suffix;
};

struct prt_quirk {
	const struct dmi_system_id *system;
	unsigned int segment;
	unsigned int bus;
	unsigned int device;
	unsigned char pin;
	const char *source;
	const char *actual_source;
};

struct ps2pp_info {
	u8 model;
	u8 kind;
	u16 features;
};

struct psample_group {
	struct list_head list;
	struct net *net;
	u32 group_num;
	u32 refcount;
	u32 seq;
	struct callback_head rcu;
};

struct psample_metadata {
	u32 trunc_size;
	int in_ifindex;
	int out_ifindex;
	u16 out_tc;
	u64 out_tc_occ;
	u64 latency;
	u8 out_tc_valid: 1;
	u8 out_tc_occ_valid: 1;
	u8 latency_valid: 1;
	u8 rate_as_probability: 1;
	u8 unused: 4;
	const u8 *user_cookie;
	u32 user_cookie_len;
};

struct psched_pktrate {
	u64 rate_pkts_ps;
	u32 mult;
	u8 shift;
};

struct pse_control_config {
	enum ethtool_podl_pse_admin_state podl_admin_control;
	enum ethtool_c33_pse_admin_state c33_admin_control;
};

struct pse_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pse_control_status status;
};

struct pseudo_fs_context {
	const struct super_operations *ops;
	const struct export_operations *eops;
	const struct xattr_handler * const *xattr;
	const struct dentry_operations *dops;
	long unsigned int magic;
};

struct psi_group_cpu;

struct psi_group {
	struct psi_group *parent;
	bool enabled;
	struct mutex avgs_lock;
	struct psi_group_cpu *pcpu;
	u64 avg_total[6];
	u64 avg_last_update;
	u64 avg_next_update;
	struct delayed_work avgs_work;
	struct list_head avg_triggers;
	u32 avg_nr_triggers[6];
	u64 total[12];
	long unsigned int avg[18];
	struct task_struct *rtpoll_task;
	struct timer_list rtpoll_timer;
	wait_queue_head_t rtpoll_wait;
	atomic_t rtpoll_wakeup;
	atomic_t rtpoll_scheduled;
	struct mutex rtpoll_trigger_lock;
	struct list_head rtpoll_triggers;
	u32 rtpoll_nr_triggers[6];
	u32 rtpoll_states;
	u64 rtpoll_min_period;
	u64 rtpoll_total[6];
	u64 rtpoll_next_update;
	u64 rtpoll_until;
};

struct psi_group_cpu {
	seqcount_t seq;
	unsigned int tasks[4];
	u32 state_mask;
	u32 times[7];
	u64 state_start;
	u32 times_prev[14];
	long: 64;
};

struct psi_window {
	u64 size;
	u64 start_time;
	u64 start_value;
	u64 prev_growth;
};

struct psi_trigger {
	enum psi_states state;
	u64 threshold;
	struct list_head node;
	struct psi_group *group;
	wait_queue_head_t event_wait;
	struct kernfs_open_file *of;
	int event;
	struct psi_window win;
	u64 last_event_time;
	bool pending_event;
	enum psi_aggregators aggregator;
};

struct psmouse_protocol;

struct psmouse {
	void *private;
	struct input_dev *dev;
	struct ps2dev ps2dev;
	struct delayed_work resync_work;
	const char *vendor;
	const char *name;
	const struct psmouse_protocol *protocol;
	unsigned char packet[8];
	unsigned char badbyte;
	unsigned char pktcnt;
	unsigned char pktsize;
	unsigned char oob_data_type;
	unsigned char extra_buttons;
	bool acks_disable_command;
	unsigned int model;
	long unsigned int last;
	long unsigned int out_of_sync_cnt;
	long unsigned int num_resyncs;
	enum psmouse_state state;
	char devname[64];
	char phys[32];
	unsigned int rate;
	unsigned int resolution;
	unsigned int resetafter;
	unsigned int resync_time;
	bool smartscroll;
	psmouse_ret_t (*protocol_handler)(struct psmouse *);
	void (*set_rate)(struct psmouse *, unsigned int);
	void (*set_resolution)(struct psmouse *, unsigned int);
	void (*set_scale)(struct psmouse *, enum psmouse_scale);
	int (*reconnect)(struct psmouse *);
	int (*fast_reconnect)(struct psmouse *);
	void (*disconnect)(struct psmouse *);
	void (*cleanup)(struct psmouse *);
	int (*poll)(struct psmouse *);
	void (*pt_activate)(struct psmouse *);
	void (*pt_deactivate)(struct psmouse *);
};

struct psmouse_attribute {
	struct device_attribute dattr;
	void *data;
	ssize_t (*show)(struct psmouse *, void *, char *);
	ssize_t (*set)(struct psmouse *, void *, const char *, size_t);
	bool protect;
};

struct psmouse_protocol {
	enum psmouse_type type;
	bool maxproto;
	bool ignore_parity;
	bool try_passthru;
	bool smbus_companion;
	const char *name;
	const char *alias;
	int (*detect)(struct psmouse *, bool);
	int (*init)(struct psmouse *);
};

struct psmouse_smbus_dev {
	struct i2c_board_info board;
	struct psmouse *psmouse;
	struct i2c_client *client;
	struct list_head node;
	bool dead;
	bool need_deactivate;
};

struct psmouse_smbus_removal_work {
	struct work_struct work;
	struct i2c_client *client;
};

struct pstate_funcs {
	int (*get_max)(int);
	int (*get_max_physical)(int);
	int (*get_min)(int);
	int (*get_turbo)(int);
	int (*get_scaling)(void);
	int (*get_cpu_scaling)(int);
	int (*get_aperf_mperf_shift)(void);
	u64 (*get_val)(struct cpudata *, int);
	void (*get_vid)(struct cpudata *);
};

struct psy_am_i_supplied_data {
	struct power_supply *psy;
	unsigned int count;
};

struct psy_for_each_psy_cb_data {
	int (*fn)(struct power_supply *, void *);
	void *data;
};

struct psy_get_supplier_prop_data {
	struct power_supply *psy;
	enum power_supply_property psp;
	union power_supply_propval *val;
};

struct pt_filter {
	long unsigned int msr_a;
	long unsigned int msr_b;
	long unsigned int config;
};

struct pt_filters {
	struct pt_filter filter[4];
	unsigned int nr_filters;
};

struct pt {
	struct perf_output_handle handle;
	struct pt_filters filters;
	int handle_nmi;
	int vmx_on;
	int pause_allowed;
	int resume_allowed;
	u64 output_base;
	u64 output_mask;
};

struct pt_address_range {
	long unsigned int msr_a;
	long unsigned int msr_b;
	unsigned int reg_off;
};

struct topa;

struct topa_entry;

struct pt_buffer {
	struct list_head tables;
	struct topa *first;
	struct topa *last;
	struct topa *cur;
	unsigned int cur_idx;
	size_t output_off;
	long unsigned int nr_pages;
	local_t data_size;
	local64_t head;
	bool snapshot;
	bool single;
	bool wrapped;
	long int stop_pos;
	long int intr_pos;
	struct topa_entry *stop_te;
	struct topa_entry *intr_te;
	void **data_pages;
};

struct pt_cap_desc {
	const char *name;
	u32 leaf;
	u8 reg;
	u32 mask;
};

struct pt_pmu {
	struct pmu pmu;
	u32 caps[8];
	bool vmx;
	bool branch_en_always_on;
	long unsigned int max_nonturbo_ratio;
	unsigned int tsc_art_num;
	unsigned int tsc_art_den;
};

struct pt_regs_offset {
	const char *name;
	int offset;
};

struct ptdesc {
	long unsigned int __page_flags;
	union {
		struct callback_head pt_rcu_head;
		struct list_head pt_list;
		struct {
			long unsigned int _pt_pad_1;
			pgtable_t pmd_huge_pte;
		};
	};
	long unsigned int __page_mapping;
	union {
		long unsigned int pt_index;
		struct mm_struct *pt_mm;
		atomic_t pt_frag_refcount;
		atomic_t pt_share_count;
	};
	union {
		long unsigned int _pt_pad_2;
		spinlock_t ptl;
	};
	unsigned int __page_type;
	atomic_t __page_refcount;
	long unsigned int pt_memcg_data;
};

struct ptdump_range {
	long unsigned int start;
	long unsigned int end;
};

struct ptp_clock {
	struct posix_clock clock;
	struct device dev;
	struct ptp_clock_info *info;
	dev_t devid;
	int index;
	struct pps_device *pps_source;
	long int dialed_frequency;
	struct list_head tsevqs;
	spinlock_t tsevqs_lock;
	struct mutex pincfg_mux;
	wait_queue_head_t tsev_wq;
	int defunct;
	struct device_attribute *pin_dev_attr;
	struct attribute **pin_attr;
	struct attribute_group pin_attr_group;
	const struct attribute_group *pin_attr_groups[2];
	struct kthread_worker *kworker;
	struct kthread_delayed_work aux_work;
	unsigned int max_vclocks;
	unsigned int n_vclocks;
	int *vclock_index;
	struct mutex n_vclocks_mux;
	bool is_virtual_clock;
	bool has_cycles;
	struct dentry *debugfs_root;
};

struct ptp_clock_caps {
	int max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int pps;
	int n_pins;
	int cross_timestamping;
	int adjust_phase;
	int max_phase_adj;
	int rsv[11];
};

struct ptp_clock_event {
	int type;
	int index;
	union {
		u64 timestamp;
		s64 offset;
		struct pps_event_time pps_times;
	};
};

struct ptp_extts_request {
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_clock_time {
	__s64 sec;
	__u32 nsec;
	__u32 reserved;
};

struct ptp_perout_request {
	union {
		struct ptp_clock_time start;
		struct ptp_clock_time phase;
	};
	struct ptp_clock_time period;
	unsigned int index;
	unsigned int flags;
	union {
		struct ptp_clock_time on;
		unsigned int rsv[4];
	};
};

struct ptp_clock_request {
	enum {
		PTP_CLK_REQ_EXTTS = 0,
		PTP_CLK_REQ_PEROUT = 1,
		PTP_CLK_REQ_PPS = 2,
	} type;
	union {
		struct ptp_extts_request extts;
		struct ptp_perout_request perout;
	};
};

struct ptp_extts_event {
	struct ptp_clock_time t;
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_header {
	u8 tsmt;
	u8 ver;
	__be16 message_length;
	u8 domain_number;
	u8 reserved1;
	u8 flag_field[2];
	__be64 correction;
	__be32 reserved2;
	struct port_identity source_port_identity;
	__be16 sequence_id;
	u8 control;
	u8 log_message_interval;
} __attribute__((packed));

struct ptp_pin_desc {
	char name[64];
	unsigned int index;
	unsigned int func;
	unsigned int chan;
	unsigned int rsv[5];
};

struct ptp_sys_offset {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[51];
};

struct ptp_sys_offset_extended {
	unsigned int n_samples;
	__kernel_clockid_t clockid;
	unsigned int rsv[2];
	struct ptp_clock_time ts[75];
};

struct ptp_sys_offset_precise {
	struct ptp_clock_time device;
	struct ptp_clock_time sys_realtime;
	struct ptp_clock_time sys_monoraw;
	unsigned int rsv[4];
};

struct ptp_system_timestamp {
	struct timespec64 pre_ts;
	struct timespec64 post_ts;
	clockid_t clockid;
};

struct timecounter {
	const struct cyclecounter *cc;
	u64 cycle_last;
	u64 nsec;
	u64 mask;
	u64 frac;
};

struct ptp_vclock {
	struct ptp_clock *pclock;
	struct ptp_clock_info info;
	struct ptp_clock *clock;
	struct hlist_node vclock_hash_node;
	struct cyclecounter cc;
	struct timecounter tc;
	struct mutex lock;
};

struct ptrace_peeksiginfo_args {
	__u64 off;
	__u32 flags;
	__s32 nr;
};

struct ptrace_rseq_configuration {
	__u64 rseq_abi_pointer;
	__u32 rseq_abi_size;
	__u32 signature;
	__u32 flags;
	__u32 pad;
};

struct ptrace_sud_config {
	__u64 mode;
	__u64 selector;
	__u64 offset;
	__u64 len;
};

struct ptrace_syscall_info {
	__u8 op;
	__u8 pad[3];
	__u32 arch;
	__u64 instruction_pointer;
	__u64 stack_pointer;
	union {
		struct {
			__u64 nr;
			__u64 args[6];
		} entry;
		struct {
			__s64 rval;
			__u8 is_error;
		} exit;
		struct {
			__u64 nr;
			__u64 args[6];
			__u32 ret_data;
		} seccomp;
	};
};

struct pts_mount_opts {
	int setuid;
	int setgid;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	umode_t ptmxmode;
	int reserve;
	int max;
};

struct pts_fs_info {
	struct ida allocated_ptys;
	struct pts_mount_opts mount_opts;
	struct super_block *sb;
	struct dentry *ptmx_dentry;
};

struct pubkey_hdr {
	uint8_t version;
	uint32_t timestamp;
	uint8_t algo;
	uint8_t nmpi;
	char mpi[0];
} __attribute__((packed));

struct public_key {
	void *key;
	u32 keylen;
	enum OID algo;
	void *params;
	u32 paramlen;
	bool key_is_private;
	const char *id_type;
	const char *pkey_algo;
	long unsigned int key_eflags;
};

struct public_key_signature {
	struct asymmetric_key_id *auth_ids[3];
	u8 *s;
	u8 *digest;
	u32 s_size;
	u32 digest_size;
	const char *pkey_algo;
	const char *hash_algo;
	const char *encoding;
};

struct publication {
	struct tipc_service_range sr;
	struct tipc_socket_addr sk;
	u16 scope;
	u32 key;
	u32 id;
	struct list_head binding_node;
	struct list_head binding_sock;
	struct list_head local_publ;
	struct list_head all_publ;
	struct list_head list;
	struct callback_head rcu;
};

struct pv_info {
	const char *name;
};

struct pvclock_vsyscall_time_info {
	struct pvclock_vcpu_time_info pvti;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct pvclock_wall_clock {
	u32 version;
	u32 sec;
	u32 nsec;
};

struct pwm_args {
	u64 period;
	enum pwm_polarity polarity;
};

struct pwm_capture {
	unsigned int period;
	unsigned int duty_cycle;
};

struct pwm_chip;

struct pwm_device {
	const char *label;
	long unsigned int flags;
	unsigned int hwpwm;
	struct pwm_chip *chip;
	struct pwm_args args;
	struct pwm_state state;
	struct pwm_state last;
};

struct pwm_ops;

struct pwm_chip {
	struct device dev;
	const struct pwm_ops *ops;
	struct module *owner;
	unsigned int id;
	unsigned int npwm;
	struct pwm_device * (*of_xlate)(struct pwm_chip *, const struct of_phandle_args *);
	bool atomic;
	bool uses_pwmchip_alloc;
	bool operational;
	union {
		struct mutex nonatomic_lock;
		spinlock_t atomic_lock;
	};
	struct pwm_device pwms[0];
};

struct pwm_waveform;

struct pwm_ops {
	int (*request)(struct pwm_chip *, struct pwm_device *);
	void (*free)(struct pwm_chip *, struct pwm_device *);
	int (*capture)(struct pwm_chip *, struct pwm_device *, struct pwm_capture *, long unsigned int);
	size_t sizeof_wfhw;
	int (*round_waveform_tohw)(struct pwm_chip *, struct pwm_device *, const struct pwm_waveform *, void *);
	int (*round_waveform_fromhw)(struct pwm_chip *, struct pwm_device *, const void *, struct pwm_waveform *);
	int (*read_waveform)(struct pwm_chip *, struct pwm_device *, void *);
	int (*write_waveform)(struct pwm_chip *, struct pwm_device *, const void *);
	int (*apply)(struct pwm_chip *, struct pwm_device *, const struct pwm_state *);
	int (*get_state)(struct pwm_chip *, struct pwm_device *, struct pwm_state *);
};

struct pwm_waveform {
	u64 period_length_ns;
	u64 duty_length_ns;
	u64 duty_offset_ns;
};

struct pxp42_create_arb_in {
	struct pxp_cmd_header header;
	u32 protection_mode;
	u32 session_id;
};

struct pxp42_create_arb_out {
	struct pxp_cmd_header header;
};

struct pxp42_inv_stream_key_in {
	struct pxp_cmd_header header;
	u32 rsvd[3];
};

struct pxp42_inv_stream_key_out {
	struct pxp_cmd_header header;
	u32 rsvd;
};

struct pxp43_start_huc_auth_in {
	struct pxp_cmd_header header;
	__le64 huc_base_address;
};

struct q_inval {
	raw_spinlock_t q_lock;
	void *desc;
	int *desc_status;
	int free_head;
	int free_tail;
	int free_cnt;
};

struct qc_dqblk {
	int d_fieldmask;
	u64 d_spc_hardlimit;
	u64 d_spc_softlimit;
	u64 d_ino_hardlimit;
	u64 d_ino_softlimit;
	u64 d_space;
	u64 d_ino_count;
	s64 d_ino_timer;
	s64 d_spc_timer;
	int d_ino_warns;
	int d_spc_warns;
	u64 d_rt_spc_hardlimit;
	u64 d_rt_spc_softlimit;
	u64 d_rt_space;
	s64 d_rt_spc_timer;
	int d_rt_spc_warns;
};

struct qc_info {
	int i_fieldmask;
	unsigned int i_flags;
	unsigned int i_spc_timelimit;
	unsigned int i_ino_timelimit;
	unsigned int i_rt_spc_timelimit;
	unsigned int i_spc_warnlimit;
	unsigned int i_ino_warnlimit;
	unsigned int i_rt_spc_warnlimit;
};

struct qc_type_state {
	unsigned int flags;
	unsigned int spc_timelimit;
	unsigned int ino_timelimit;
	unsigned int rt_spc_timelimit;
	unsigned int spc_warnlimit;
	unsigned int ino_warnlimit;
	unsigned int rt_spc_warnlimit;
	long long unsigned int ino;
	blkcnt_t blocks;
	blkcnt_t nextents;
};

struct qc_state {
	unsigned int s_incoredqs;
	struct qc_type_state s_state[3];
};

struct qdisc_dump_args {
	struct qdisc_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
};

struct tc_ratespec {
	unsigned char cell_log;
	__u8 linklayer;
	short unsigned int overhead;
	short int cell_align;
	short unsigned int mpu;
	__u32 rate;
};

struct qdisc_rate_table {
	struct tc_ratespec rate;
	u32 data[256];
	struct qdisc_rate_table *next;
	int refcnt;
};

struct tc_sizespec {
	unsigned char cell_log;
	unsigned char size_log;
	short int cell_align;
	int overhead;
	unsigned int linklayer;
	unsigned int mpu;
	unsigned int mtu;
	unsigned int tsize;
};

struct qdisc_size_table {
	struct callback_head rcu;
	struct list_head list;
	struct tc_sizespec szopts;
	int refcnt;
	u16 data[0];
};

struct qfq_group;

struct qfq_aggregate {
	struct hlist_node next;
	u64 S;
	u64 F;
	struct qfq_group *grp;
	u32 class_weight;
	int lmax;
	u32 inv_w;
	u32 budgetmax;
	u32 initial_budget;
	u32 budget;
	int num_classes;
	struct list_head active;
	struct hlist_node nonfull_next;
};

struct qfq_class {
	struct Qdisc_class_common common;
	long: 64;
	struct gnet_stats_basic_sync bstats;
	struct gnet_stats_queue qstats;
	struct net_rate_estimator *rate_est;
	struct Qdisc *qdisc;
	struct list_head alist;
	struct qfq_aggregate *agg;
	int deficit;
	long: 64;
};

struct qfq_group {
	u64 S;
	u64 F;
	unsigned int slot_shift;
	unsigned int index;
	unsigned int front;
	long unsigned int full_slots;
	struct hlist_head slots[32];
};

struct qfq_sched {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct Qdisc_class_hash clhash;
	u64 oldV;
	u64 V;
	struct qfq_aggregate *in_serv_agg;
	u32 wsum;
	u32 iwsum;
	long unsigned int bitmaps[4];
	struct qfq_group groups[25];
	u32 min_slot_shift;
	u32 max_agg_classes;
	struct hlist_head nonfull_aggs;
};

struct qi_desc {
	u64 qw0;
	u64 qw1;
	u64 qw2;
	u64 qw3;
};

struct qi_batch {
	struct qi_desc descs[16];
	unsigned int index;
};

struct qnode {
	struct mcs_spinlock mcs;
};

struct qt_disk_dqdbheader {
	__le32 dqdh_next_free;
	__le32 dqdh_prev_free;
	__le16 dqdh_entries;
	__le16 dqdh_pad1;
	__le32 dqdh_pad2;
};

struct qtag_prefix {
	__be16 eth_type;
	__be16 tci;
};

struct qtree_fmt_operations {
	void (*mem2disk_dqblk)(void *, struct dquot *);
	void (*disk2mem_dqblk)(struct dquot *, void *);
	int (*is_id)(void *, struct dquot *);
};

struct qtree_mem_dqinfo {
	struct super_block *dqi_sb;
	int dqi_type;
	unsigned int dqi_blocks;
	unsigned int dqi_free_blk;
	unsigned int dqi_free_entry;
	unsigned int dqi_blocksize_bits;
	unsigned int dqi_entry_size;
	unsigned int dqi_usable_bs;
	unsigned int dqi_qtree_depth;
	const struct qtree_fmt_operations *dqi_ops;
};

struct queue_pages {
	struct list_head *pagelist;
	long unsigned int flags;
	nodemask_t *nmask;
	long unsigned int start;
	long unsigned int end;
	struct vm_area_struct *first;
	struct folio *large;
	long int nr_failed;
};

struct queue_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct gendisk *, char *);
	ssize_t (*store)(struct gendisk *, const char *, size_t);
	int (*store_limit)(struct gendisk *, const char *, size_t, struct queue_limits *);
	void (*load_module)(struct gendisk *, const char *, size_t);
};

struct quirk_entry {
	u32 nominal_freq;
	u32 lowest_freq;
};

struct quota_format_ops {
	int (*check_quota_file)(struct super_block *, int);
	int (*read_file_info)(struct super_block *, int);
	int (*write_file_info)(struct super_block *, int);
	int (*free_file_info)(struct super_block *, int);
	int (*read_dqblk)(struct dquot *);
	int (*commit_dqblk)(struct dquot *);
	int (*release_dqblk)(struct dquot *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct quota_format_type {
	int qf_fmt_id;
	const struct quota_format_ops *qf_ops;
	struct module *qf_owner;
	struct quota_format_type *qf_next;
};

struct quota_info {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode *files[3];
	struct mem_dqinfo info[3];
	const struct quota_format_ops *ops[3];
};

struct quota_module_name {
	int qm_fmt_id;
	char *qm_mod_name;
};

struct quotactl_ops {
	int (*quota_on)(struct super_block *, int, int, const struct path *);
	int (*quota_off)(struct super_block *, int);
	int (*quota_enable)(struct super_block *, unsigned int);
	int (*quota_disable)(struct super_block *, unsigned int);
	int (*quota_sync)(struct super_block *, int);
	int (*set_info)(struct super_block *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block *, struct qc_state *);
	int (*rm_xquota)(struct super_block *, unsigned int);
};

struct ra_msg {
	struct icmp6hdr icmph;
	__be32 reachable_time;
	__be32 retrans_timer;
};

struct xa_node;

struct radix_tree_iter {
	long unsigned int index;
	long unsigned int next_index;
	long unsigned int tags;
	struct xa_node *node;
};

struct radix_tree_preload {
	local_lock_t lock;
	unsigned int nr;
	struct xa_node *nodes;
};

struct raid56_bio_trace_info {
	u64 devid;
	u32 offset;
	u8 stripe_nr;
};

struct raid6_avx2_constants {
	u64 x1d[4];
};

struct raid6_avx512_constants {
	u64 x1d[8];
};

struct raid6_calls {
	void (*gen_syndrome)(int, size_t, void **);
	void (*xor_syndrome)(int, int, int, size_t, void **);
	int (*valid)(void);
	const char *name;
	int priority;
};

struct raid6_recov_calls {
	void (*data2)(int, size_t, int, int, void **);
	void (*datap)(int, size_t, int, void **);
	int (*valid)(void);
	const char *name;
	int priority;
};

struct raid6_sse_constants {
	u64 x1d[2];
};

struct raid_kobject {
	u64 flags;
	struct kobject kobj;
};

struct ramfs_mount_opts {
	umode_t mode;
};

struct ramfs_fs_info {
	struct ramfs_mount_opts mount_opts;
};

struct rand_data {
	void *hash_state;
	__u64 prev_time;
	__u64 last_delta;
	__s64 last_delta2;
	unsigned int flags;
	unsigned int osr;
	unsigned char *mem;
	unsigned int memlocation;
	unsigned int memblocks;
	unsigned int memblocksize;
	unsigned int memaccessloops;
	unsigned int rct_count;
	unsigned int apt_cutoff;
	unsigned int apt_cutoff_permanent;
	unsigned int apt_observations;
	unsigned int apt_count;
	unsigned int apt_base;
	unsigned int health_failure;
	unsigned int apt_base_set: 1;
};

struct range_node {
	struct rb_node rn_rbnode;
	struct rb_node rb_range_size;
	u32 rn_start;
	u32 rn_last;
	u32 __rn_subtree_last;
};

struct rapl_model {
	struct perf_msr *rapl_pkg_msrs;
	struct perf_msr *rapl_core_msrs;
	long unsigned int pkg_events;
	long unsigned int core_events;
	unsigned int msr_power_unit;
	enum rapl_unit_quirk unit_quirk;
};

struct rapl_pmu {
	raw_spinlock_t lock;
	int n_active;
	int cpu;
	struct list_head active_list;
	struct pmu *pmu;
	ktime_t timer_interval;
	struct hrtimer hrtimer;
};

struct rapl_pmus {
	struct pmu pmu;
	unsigned int nr_rapl_pmu;
	unsigned int cntr_mask;
	struct rapl_pmu *rapl_pmu[0];
};

struct rate_info {
	u16 flags;
	u16 legacy;
	u8 mcs;
	u8 nss;
	u8 bw;
	u8 he_gi;
	u8 he_dcm;
	u8 he_ru_alloc;
	u8 n_bonded_ch;
	u8 eht_gi;
	u8 eht_ru_alloc;
};

struct rate_sample {
	u64 prior_mstamp;
	u32 prior_delivered;
	u32 prior_delivered_ce;
	s32 delivered;
	s32 delivered_ce;
	long int interval_us;
	u32 snd_interval_us;
	u32 rcv_interval_us;
	long int rtt_us;
	int losses;
	u32 acked_sacked;
	u32 prior_in_flight;
	u32 last_end_seq;
	bool is_app_limited;
	bool is_retrans;
	bool is_ack_delayed;
};

struct raw6_frag_vec {
	struct msghdr *msg;
	int hlen;
	char c[4];
};

struct raw6_sock {
	struct inet_sock inet;
	__u32 checksum;
	__u32 offset;
	struct icmp6_filter filter;
	__u32 ip6mr_table;
	struct ipv6_pinfo inet6;
};

struct raw_data_entry {
	struct trace_entry ent;
	unsigned int id;
	char buf[0];
};

struct raw_frag_vec {
	struct msghdr *msg;
	union {
		struct icmphdr icmph;
		char c[1];
	} hdr;
	int hlen;
};

struct raw_hashinfo {
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct hlist_head ht[256];
};

struct raw_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct raw_sock {
	struct inet_sock inet;
	struct icmp_filter filter;
	u32 ipmr_table;
};

struct rb_augment_callbacks {
	void (*propagate)(struct rb_node *, struct rb_node *);
	void (*copy)(struct rb_node *, struct rb_node *);
	void (*rotate)(struct rb_node *, struct rb_node *);
};

struct rb_event_info {
	u64 ts;
	u64 delta;
	u64 before;
	u64 after;
	long unsigned int length;
	struct buffer_page *tail_page;
	int add_timestamp;
};

struct rb_irq_work {
	struct irq_work work;
	wait_queue_head_t waiters;
	wait_queue_head_t full_waiters;
	atomic_t seq;
	bool waiters_pending;
	bool full_waiters_pending;
	bool wakeup_full;
};

struct rb_list {
	struct rb_root root;
	struct list_head head;
	spinlock_t lock;
};

struct rb_simple_node {
	struct rb_node rb_node;
	u64 bytenr;
};

struct rb_time_struct {
	local64_t time;
};

typedef struct rb_time_struct rb_time_t;

struct rb_wait_data {
	struct rb_irq_work *irq_work;
	int seq;
};

struct rc {
	long int (*fill)(void *, long unsigned int);
	uint8_t *ptr;
	uint8_t *buffer;
	uint8_t *buffer_end;
	long int buffer_size;
	uint32_t code;
	uint32_t range;
	uint32_t bound;
	void (*error)(char *);
};

struct rc_dec {
	uint32_t range;
	uint32_t code;
	uint32_t init_bytes_left;
	const uint8_t *in;
	size_t in_pos;
	size_t in_limit;
};

struct rc_map_table;

struct rc_map {
	struct rc_map_table *scan;
	unsigned int size;
	unsigned int len;
	unsigned int alloc;
	enum rc_proto rc_proto;
	const char *name;
	spinlock_t lock;
};

struct ir_raw_event_ctrl;

struct rc_scancode_filter {
	u32 data;
	u32 mask;
};

struct rc_dev {
	struct device dev;
	bool managed_alloc;
	const struct attribute_group *sysfs_groups[5];
	const char *device_name;
	const char *input_phys;
	struct input_id input_id;
	const char *driver_name;
	const char *map_name;
	struct rc_map rc_map;
	struct mutex lock;
	unsigned int minor;
	struct ir_raw_event_ctrl *raw;
	struct input_dev *input_dev;
	enum rc_driver_type driver_type;
	bool idle;
	bool encode_wakeup;
	u64 allowed_protocols;
	u64 enabled_protocols;
	u64 allowed_wakeup_protocols;
	enum rc_proto wakeup_protocol;
	struct rc_scancode_filter scancode_filter;
	struct rc_scancode_filter scancode_wakeup_filter;
	u32 scancode_mask;
	u32 users;
	void *priv;
	spinlock_t keylock;
	bool keypressed;
	long unsigned int keyup_jiffies;
	struct timer_list timer_keyup;
	struct timer_list timer_repeat;
	u32 last_keycode;
	enum rc_proto last_protocol;
	u64 last_scancode;
	u8 last_toggle;
	u32 timeout;
	u32 min_timeout;
	u32 max_timeout;
	u32 rx_resolution;
	bool registered;
	int (*change_protocol)(struct rc_dev *, u64 *);
	int (*open)(struct rc_dev *);
	void (*close)(struct rc_dev *);
	int (*s_tx_mask)(struct rc_dev *, u32);
	int (*s_tx_carrier)(struct rc_dev *, u32);
	int (*s_tx_duty_cycle)(struct rc_dev *, u32);
	int (*s_rx_carrier_range)(struct rc_dev *, u32, u32);
	int (*tx_ir)(struct rc_dev *, unsigned int *, unsigned int);
	void (*s_idle)(struct rc_dev *, bool);
	int (*s_wideband_receiver)(struct rc_dev *, int);
	int (*s_carrier_report)(struct rc_dev *, int);
	int (*s_filter)(struct rc_dev *, struct rc_scancode_filter *);
	int (*s_wakeup_filter)(struct rc_dev *, struct rc_scancode_filter *);
	int (*s_timeout)(struct rc_dev *, unsigned int);
};

struct rc_map_table {
	u64 scancode;
	u32 keycode;
};

struct rc_parameters {
	u16 initial_xmit_delay;
	u8 first_line_bpg_offset;
	u16 initial_offset;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	u8 rc_quant_incr_limit0;
	u8 rc_quant_incr_limit1;
	struct drm_dsc_rc_range_parameters rc_range_params[15];
};

struct rc_parameters_data {
	u8 bpp;
	u8 bpc;
	struct rc_parameters params;
};

struct rcec_ea {
	u8 nextbusn;
	u8 lastbusn;
	u32 bitmap;
};

struct rchan_callbacks;

struct rchan_buf;

struct rchan {
	u32 version;
	size_t subbuf_size;
	size_t n_subbufs;
	size_t alloc_size;
	const struct rchan_callbacks *cb;
	struct kref kref;
	void *private_data;
	size_t last_toobig;
	struct rchan_buf **buf;
	int is_global;
	struct list_head list;
	struct dentry *parent;
	int has_base_filename;
	char base_filename[255];
};

struct rchan_buf {
	void *start;
	void *data;
	size_t offset;
	size_t subbufs_produced;
	size_t subbufs_consumed;
	struct rchan *chan;
	wait_queue_head_t read_wait;
	struct irq_work wakeup_work;
	struct dentry *dentry;
	struct kref kref;
	struct page **page_array;
	unsigned int page_count;
	unsigned int finalized;
	size_t *padding;
	size_t prev_padding;
	size_t bytes_consumed;
	size_t early_bytes;
	unsigned int cpu;
	long: 64;
	long: 64;
};

struct rchan_callbacks {
	int (*subbuf_start)(struct rchan_buf *, void *, void *, size_t);
	struct dentry * (*create_buf_file)(const char *, struct dentry *, umode_t, struct rchan_buf *, int *);
	int (*remove_buf_file)(struct dentry *);
};

struct rchan_percpu_buf_dispatcher {
	struct rchan_buf *buf;
	struct dentry *dentry;
};

struct rcu_cblist {
	struct callback_head *head;
	struct callback_head **tail;
	long int len;
};

union rcu_noqs {
	struct {
		u8 norm;
		u8 exp;
	} b;
	u16 s;
};

struct rcu_segcblist {
	struct callback_head *head;
	struct callback_head **tails[4];
	long unsigned int gp_seq[4];
	long int len;
	long int seglen[4];
	u8 flags;
};

struct rcu_snap_record {
	long unsigned int gp_seq;
	u64 cputime_irq;
	u64 cputime_softirq;
	u64 cputime_system;
	long unsigned int nr_hardirqs;
	unsigned int nr_softirqs;
	long long unsigned int nr_csw;
	long unsigned int jiffies;
};

struct rcu_node;

struct rcu_data {
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	union rcu_noqs cpu_no_qs;
	bool core_needs_qs;
	bool beenonline;
	bool gpwrap;
	bool cpu_started;
	struct rcu_node *mynode;
	long unsigned int grpmask;
	long unsigned int ticks_this_gp;
	struct irq_work defer_qs_iw;
	bool defer_qs_iw_pending;
	struct work_struct strict_work;
	struct rcu_segcblist cblist;
	long int qlen_last_fqs_check;
	long unsigned int n_cbs_invoked;
	long unsigned int n_force_qs_snap;
	long int blimit;
	int watching_snap;
	bool rcu_need_heavy_qs;
	bool rcu_urgent_qs;
	bool rcu_forced_tick;
	bool rcu_forced_tick_exp;
	long unsigned int barrier_seq_snap;
	struct callback_head barrier_head;
	int exp_watching_snap;
	struct task_struct *rcu_cpu_kthread_task;
	unsigned int rcu_cpu_kthread_status;
	char rcu_cpu_has_work;
	long unsigned int rcuc_activity;
	unsigned int softirq_snap;
	struct irq_work rcu_iw;
	bool rcu_iw_pending;
	long unsigned int rcu_iw_gp_seq;
	long unsigned int rcu_ofl_gp_seq;
	short int rcu_ofl_gp_state;
	long unsigned int rcu_onl_gp_seq;
	short int rcu_onl_gp_state;
	long unsigned int last_fqs_resched;
	long unsigned int last_sched_clock;
	struct rcu_snap_record snap_record;
	long int lazy_len;
	int cpu;
};

struct rcu_exp_work {
	long unsigned int rew_s;
	struct kthread_work rew_work;
};

struct rcu_node {
	raw_spinlock_t lock;
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	long unsigned int completedqs;
	long unsigned int qsmask;
	long unsigned int rcu_gp_init_mask;
	long unsigned int qsmaskinit;
	long unsigned int qsmaskinitnext;
	long unsigned int expmask;
	long unsigned int expmaskinit;
	long unsigned int expmaskinitnext;
	struct kthread_worker *exp_kworker;
	long unsigned int cbovldmask;
	long unsigned int ffmask;
	long unsigned int grpmask;
	int grplo;
	int grphi;
	u8 grpnum;
	u8 level;
	bool wait_blkd_tasks;
	struct rcu_node *parent;
	struct list_head blkd_tasks;
	struct list_head *gp_tasks;
	struct list_head *exp_tasks;
	struct list_head *boost_tasks;
	struct rt_mutex boost_mtx;
	long unsigned int boost_time;
	struct mutex kthread_mutex;
	struct task_struct *boost_kthread_task;
	unsigned int boost_kthread_status;
	long unsigned int n_boosts;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	raw_spinlock_t fqslock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t exp_lock;
	long unsigned int exp_seq_rq;
	wait_queue_head_t exp_wq[4];
	struct rcu_exp_work rew;
	bool exp_need_flush;
	raw_spinlock_t exp_poll_lock;
	long unsigned int exp_seq_poll_rq;
	struct work_struct exp_poll_wq;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

union rcu_special {
	struct {
		u8 blocked;
		u8 need_qs;
		u8 exp_hint;
		u8 need_mb;
	} b;
	u32 s;
};

struct rcu_stall_chk_rdr {
	int nesting;
	union rcu_special rs;
	bool on_blkd_list;
};

struct sr_wait_node {
	atomic_t inuse;
	struct llist_node node;
};

struct rcu_state {
	struct rcu_node node[5];
	struct rcu_node *level[3];
	int ncpus;
	int n_online_cpus;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int gp_seq;
	long unsigned int gp_max;
	struct task_struct *gp_kthread;
	struct swait_queue_head gp_wq;
	short int gp_flags;
	short int gp_state;
	long unsigned int gp_wake_time;
	long unsigned int gp_wake_seq;
	long unsigned int gp_seq_polled;
	long unsigned int gp_seq_polled_snap;
	long unsigned int gp_seq_polled_exp_snap;
	struct mutex barrier_mutex;
	atomic_t barrier_cpu_count;
	struct completion barrier_completion;
	long unsigned int barrier_sequence;
	raw_spinlock_t barrier_lock;
	struct mutex exp_mutex;
	struct mutex exp_wake_mutex;
	long unsigned int expedited_sequence;
	atomic_t expedited_need_qs;
	struct swait_queue_head expedited_wq;
	int ncpus_snap;
	u8 cbovld;
	u8 cbovldnext;
	long unsigned int jiffies_force_qs;
	long unsigned int jiffies_kick_kthreads;
	long unsigned int n_force_qs;
	long unsigned int gp_start;
	long unsigned int gp_end;
	long unsigned int gp_activity;
	long unsigned int gp_req_activity;
	long unsigned int jiffies_stall;
	int nr_fqs_jiffies_stall;
	long unsigned int jiffies_resched;
	long unsigned int n_force_qs_gpstart;
	const char *name;
	char abbr;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	arch_spinlock_t ofl_lock;
	struct llist_head srs_next;
	struct llist_node *srs_wait_tail;
	struct llist_node *srs_done_tail;
	struct sr_wait_node srs_wait_nodes[5];
	struct work_struct srs_cleanup_work;
	atomic_t srs_cleanups_pending;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rcu_string {
	struct callback_head rcu;
	char str[0];
};

struct rcu_synchronize {
	struct callback_head head;
	struct completion completion;
};

struct rcu_tasks;

typedef void (*rcu_tasks_gp_func_t)(struct rcu_tasks *);

typedef void (*pregp_func_t)(struct list_head *);

typedef void (*pertask_func_t)(struct task_struct *, struct list_head *);

typedef void (*postscan_func_t)(struct list_head *);

typedef void (*holdouts_func_t)(struct list_head *, bool, bool *);

typedef void (*postgp_func_t)(struct rcu_tasks *);

typedef void (*rcu_callback_t)(struct callback_head *);

typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);

struct rcu_tasks_percpu;

struct rcu_tasks {
	struct rcuwait cbs_wait;
	raw_spinlock_t cbs_gbl_lock;
	struct mutex tasks_gp_mutex;
	int gp_state;
	int gp_sleep;
	int init_fract;
	long unsigned int gp_jiffies;
	long unsigned int gp_start;
	long unsigned int tasks_gp_seq;
	long unsigned int n_ipis;
	long unsigned int n_ipis_fails;
	struct task_struct *kthread_ptr;
	long unsigned int lazy_jiffies;
	rcu_tasks_gp_func_t gp_func;
	pregp_func_t pregp_func;
	pertask_func_t pertask_func;
	postscan_func_t postscan_func;
	holdouts_func_t holdouts_func;
	postgp_func_t postgp_func;
	call_rcu_func_t call_func;
	unsigned int wait_state;
	struct rcu_tasks_percpu *rtpcpu;
	struct rcu_tasks_percpu **rtpcp_array;
	int percpu_enqueue_shift;
	int percpu_enqueue_lim;
	int percpu_dequeue_lim;
	long unsigned int percpu_dequeue_gpseq;
	struct mutex barrier_q_mutex;
	atomic_t barrier_q_count;
	struct completion barrier_q_completion;
	long unsigned int barrier_q_seq;
	long unsigned int barrier_q_start;
	char *name;
	char *kname;
};

struct rcu_tasks_percpu {
	struct rcu_segcblist cblist;
	raw_spinlock_t lock;
	long unsigned int rtp_jiffies;
	long unsigned int rtp_n_lock_retries;
	struct timer_list lazy_timer;
	unsigned int urgent_gp;
	struct work_struct rtp_work;
	struct irq_work rtp_irq_work;
	struct callback_head barrier_q_head;
	struct list_head rtp_blkd_tasks;
	struct list_head rtp_exit_list;
	int cpu;
	int index;
	struct rcu_tasks *rtpp;
};

struct rd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	struct in6_addr dest;
	__u8 opt[0];
};

struct rdev_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct md_rdev *, char *);
	ssize_t (*store)(struct md_rdev *, const char *, size_t);
};

struct rdma_dev_addr {
	unsigned char src_dev_addr[32];
	unsigned char dst_dev_addr[32];
	unsigned char broadcast[32];
	short unsigned int dev_type;
	int bound_dev_if;
	enum rdma_transport_type transport;
	struct net *net;
	const struct ib_gid_attr *sgid_attr;
	enum rdma_network_type network;
	int hoplimit;
};

struct rdma_addr {
	struct __kernel_sockaddr_storage src_addr;
	struct __kernel_sockaddr_storage dst_addr;
	struct rdma_dev_addr dev_addr;
};

struct rdma_ah_init_attr {
	struct rdma_ah_attr *ah_attr;
	u32 flags;
	struct net_device *xmit_slave;
};

struct rdma_cgroup {
	struct cgroup_subsys_state css;
	struct list_head rpools;
};

struct rdma_conn_param {
	const void *private_data;
	u8 private_data_len;
	u8 responder_resources;
	u8 initiator_depth;
	u8 flow_control;
	u8 retry_count;
	u8 rnr_retry_count;
	u8 srq;
	u32 qp_num;
	u32 qkey;
};

struct rdma_ud_param {
	const void *private_data;
	u8 private_data_len;
	struct rdma_ah_attr ah_attr;
	u32 qp_num;
	u32 qkey;
};

struct rdma_ucm_ece {
	__u32 vendor_id;
	__u32 attr_mod;
};

struct rdma_cm_event {
	enum rdma_cm_event_type event;
	int status;
	union {
		struct rdma_conn_param conn;
		struct rdma_ud_param ud;
	} param;
	struct rdma_ucm_ece ece;
};

typedef int (*rdma_cm_event_handler)(struct rdma_cm_id *, struct rdma_cm_event *);

struct sa_path_rec;

struct rdma_route {
	struct rdma_addr addr;
	struct sa_path_rec *path_rec;
	struct sa_path_rec *path_rec_inbound;
	struct sa_path_rec *path_rec_outbound;
	int num_pri_alt_paths;
};

struct rdma_cm_id {
	struct ib_device *device;
	void *context;
	struct ib_qp *qp;
	rdma_cm_event_handler event_handler;
	struct rdma_route route;
	enum rdma_ucm_port_space ps;
	enum ib_qp_type qp_type;
	u32 port_num;
	struct work_struct net_work;
};

struct rdma_counter {
	struct rdma_restrack_entry res;
	struct ib_device *device;
	uint32_t id;
	struct kref kref;
	struct rdma_counter_mode mode;
	struct mutex lock;
	struct rdma_hw_stats *stats;
	u32 port;
};

struct rdma_stat_desc;

struct rdma_hw_stats {
	struct mutex lock;
	long unsigned int timestamp;
	long unsigned int lifespan;
	const struct rdma_stat_desc *descs;
	long unsigned int *is_disabled;
	int num_counters;
	u64 value[0];
};

struct rdma_link_ops {
	struct list_head list;
	const char *type;
	int (*newlink)(const char *, struct net_device *);
};

struct rdma_netdev_alloc_params {
	size_t sizeof_priv;
	unsigned int txqs;
	unsigned int rxqs;
	void *param;
	int (*initialize_rdma_netdev)(struct ib_device *, u32, struct net_device *, void *);
};

struct rdma_stat_desc {
	const char *name;
	unsigned int flags;
	const void *priv;
};

struct rdma_user_mmap_entry {
	struct kref ref;
	struct ib_ucontext *ucontext;
	long unsigned int start_pgoff;
	size_t npages;
	bool driver_removed;
};

struct rdmacg_resource {
	int max;
	int usage;
};

struct rdmacg_resource_pool {
	struct rdmacg_device *device;
	struct rdmacg_resource resources[2];
	struct list_head cg_node;
	struct list_head dev_node;
	u64 usage_sum;
	int num_max_cnt;
};

struct rds6_info_connection {
	__u64 next_tx_seq;
	__u64 next_rx_seq;
	struct in6_addr laddr;
	struct in6_addr faddr;
	__u8 transport[16];
	__u8 flags;
} __attribute__((packed));

struct rds6_info_message {
	__u64 seq;
	__u32 len;
	struct in6_addr laddr;
	struct in6_addr faddr;
	__be16 lport;
	__be16 fport;
	__u8 flags;
	__u8 tos;
} __attribute__((packed));

struct rds6_info_socket {
	__u32 sndbuf;
	struct in6_addr bound_addr;
	struct in6_addr connected_addr;
	__be16 bound_port;
	__be16 connected_port;
	__u32 rcvbuf;
	__u64 inum;
} __attribute__((packed));

struct rds6_info_tcp_socket {
	struct in6_addr local_addr;
	__be16 local_port;
	struct in6_addr peer_addr;
	__be16 peer_port;
	__u64 hdr_rem;
	__u64 data_rem;
	__u32 last_sent_nxt;
	__u32 last_expected_una;
	__u32 last_seen_una;
} __attribute__((packed));

struct rds_atomic_args {
	rds_rdma_cookie_t cookie;
	__u64 local_addr;
	__u64 remote_addr;
	union {
		struct {
			__u64 compare;
			__u64 swap;
		} cswp;
		struct {
			__u64 add;
		} fadd;
		struct {
			__u64 compare;
			__u64 swap;
			__u64 compare_mask;
			__u64 swap_mask;
		} m_cswp;
		struct {
			__u64 add;
			__u64 nocarry_mask;
		} m_fadd;
	};
	__u64 flags;
	__u64 user_token;
};

struct rds_cmsg_rx_trace {
	__u8 rx_traces;
	__u8 rx_trace_pos[3];
	__u64 rx_trace[3];
};

struct rds_cong_map {
	struct rb_node m_rb_node;
	struct in6_addr m_addr;
	wait_queue_head_t m_waitq;
	struct list_head m_conn_list;
	long unsigned int m_page_addrs[2];
};

struct rds_connection;

struct rds_message;

struct rds_conn_path {
	struct rds_connection *cp_conn;
	struct rds_message *cp_xmit_rm;
	long unsigned int cp_xmit_sg;
	unsigned int cp_xmit_hdr_off;
	unsigned int cp_xmit_data_off;
	unsigned int cp_xmit_atomic_sent;
	unsigned int cp_xmit_rdma_sent;
	unsigned int cp_xmit_data_sent;
	spinlock_t cp_lock;
	u64 cp_next_tx_seq;
	struct list_head cp_send_queue;
	struct list_head cp_retrans;
	u64 cp_next_rx_seq;
	void *cp_transport_data;
	atomic_t cp_state;
	long unsigned int cp_send_gen;
	long unsigned int cp_flags;
	long unsigned int cp_reconnect_jiffies;
	struct delayed_work cp_send_w;
	struct delayed_work cp_recv_w;
	struct delayed_work cp_conn_w;
	struct work_struct cp_down_w;
	struct mutex cp_cm_lock;
	wait_queue_head_t cp_waitq;
	unsigned int cp_unacked_packets;
	unsigned int cp_unacked_bytes;
	unsigned int cp_index;
};

struct rds_transport;

struct rds_connection {
	struct hlist_node c_hash_node;
	struct in6_addr c_laddr;
	struct in6_addr c_faddr;
	int c_dev_if;
	int c_bound_if;
	unsigned int c_loopback: 1;
	unsigned int c_isv6: 1;
	unsigned int c_ping_triggered: 1;
	unsigned int c_pad_to_32: 29;
	int c_npaths;
	struct rds_connection *c_passive;
	struct rds_transport *c_trans;
	struct rds_cong_map *c_lcong;
	struct rds_cong_map *c_fcong;
	unsigned int c_proposed_version;
	unsigned int c_version;
	possible_net_t c_net;
	u8 c_tos;
	struct list_head c_map_item;
	long unsigned int c_map_queued;
	struct rds_conn_path *c_path;
	wait_queue_head_t c_hs_waitq;
	u32 c_my_gen_num;
	u32 c_peer_gen_num;
};

struct rds_ext_header_rdma {
	__be32 h_rdma_rkey;
};

struct rds_ext_header_rdma_dest {
	__be32 h_rdma_rkey;
	__be32 h_rdma_offset;
};

struct rds_ext_header_version {
	__be32 h_version;
};

struct rds_free_mr_args {
	rds_rdma_cookie_t cookie;
	__u64 flags;
};

struct rds_iovec {
	__u64 addr;
	__u64 bytes;
};

struct rds_get_mr_args {
	struct rds_iovec vec;
	__u64 cookie_addr;
	__u64 flags;
};

struct rds_get_mr_for_dest_args {
	struct __kernel_sockaddr_storage dest_addr;
	struct rds_iovec vec;
	__u64 cookie_addr;
	__u64 flags;
};

struct rds_header {
	__be64 h_sequence;
	__be64 h_ack;
	__be32 h_len;
	__be16 h_sport;
	__be16 h_dport;
	u8 h_flags;
	u8 h_credit;
	u8 h_padding[4];
	__sum16 h_csum;
	u8 h_exthdr[16];
};

struct rds_inc_usercopy {
	rds_rdma_cookie_t rdma_cookie;
	ktime_t rx_tstamp;
};

struct rds_incoming {
	refcount_t i_refcount;
	struct list_head i_item;
	struct rds_connection *i_conn;
	struct rds_conn_path *i_conn_path;
	struct rds_header i_hdr;
	long unsigned int i_rx_jiffies;
	struct in6_addr i_saddr;
	struct rds_inc_usercopy i_usercopy;
	u64 i_rx_lat_trace[4];
};

struct rds_info_connection {
	__u64 next_tx_seq;
	__u64 next_rx_seq;
	__be32 laddr;
	__be32 faddr;
	__u8 transport[16];
	__u8 flags;
	__u8 tos;
} __attribute__((packed));

struct rds_info_counter {
	__u8 name[32];
	__u64 value;
};

struct rds_info_iterator {
	struct page **pages;
	void *addr;
	long unsigned int offset;
};

struct rds_info_lengths {
	unsigned int nr;
	unsigned int each;
};

struct rds_info_message {
	__u64 seq;
	__u32 len;
	__be32 laddr;
	__be32 faddr;
	__be16 lport;
	__be16 fport;
	__u8 flags;
	__u8 tos;
} __attribute__((packed));

struct rds_info_socket {
	__u32 sndbuf;
	__be32 bound_addr;
	__be32 connected_addr;
	__be16 bound_port;
	__be16 connected_port;
	__u32 rcvbuf;
	__u64 inum;
} __attribute__((packed));

struct rds_info_tcp_socket {
	__be32 local_addr;
	__be16 local_port;
	__be32 peer_addr;
	__be16 peer_port;
	__u64 hdr_rem;
	__u64 data_rem;
	__u32 last_sent_nxt;
	__u32 last_expected_una;
	__u32 last_seen_una;
	__u8 tos;
} __attribute__((packed));

struct rds_iov_vector {
	struct rds_iovec *iov;
	int len;
};

struct rds_iov_vector_arr {
	struct rds_iov_vector *vec;
	int len;
	int indx;
	int incr;
};

struct rds_loop_connection {
	struct list_head loop_node;
	struct rds_connection *conn;
};

struct rds_notifier;

struct rds_mr;

struct rm_atomic_op {
	int op_type;
	union {
		struct {
			uint64_t compare;
			uint64_t swap;
			uint64_t compare_mask;
			uint64_t swap_mask;
		} op_m_cswp;
		struct {
			uint64_t add;
			uint64_t nocarry_mask;
		} op_m_fadd;
	};
	u32 op_rkey;
	u64 op_remote_addr;
	unsigned int op_notify: 1;
	unsigned int op_recverr: 1;
	unsigned int op_mapped: 1;
	unsigned int op_silent: 1;
	unsigned int op_active: 1;
	struct scatterlist *op_sg;
	struct rds_notifier *op_notifier;
	struct rds_mr *op_rdma_mr;
};

struct rm_rdma_op {
	u32 op_rkey;
	u64 op_remote_addr;
	unsigned int op_write: 1;
	unsigned int op_fence: 1;
	unsigned int op_notify: 1;
	unsigned int op_recverr: 1;
	unsigned int op_mapped: 1;
	unsigned int op_silent: 1;
	unsigned int op_active: 1;
	unsigned int op_bytes;
	unsigned int op_nents;
	unsigned int op_count;
	struct scatterlist *op_sg;
	struct rds_notifier *op_notifier;
	struct rds_mr *op_rdma_mr;
	u64 op_odp_addr;
	struct rds_mr *op_odp_mr;
};

struct rds_znotifier;

struct rm_data_op {
	unsigned int op_active: 1;
	unsigned int op_nents;
	unsigned int op_count;
	unsigned int op_dmasg;
	unsigned int op_dmaoff;
	struct rds_znotifier *op_mmp_znotifier;
	struct scatterlist *op_sg;
};

struct rds_sock;

struct rds_message {
	refcount_t m_refcount;
	struct list_head m_sock_item;
	struct list_head m_conn_item;
	struct rds_incoming m_inc;
	u64 m_ack_seq;
	struct in6_addr m_daddr;
	long unsigned int m_flags;
	spinlock_t m_rs_lock;
	wait_queue_head_t m_flush_wait;
	struct rds_sock *m_rs;
	rds_rdma_cookie_t m_rdma_cookie;
	unsigned int m_used_sgs;
	unsigned int m_total_sgs;
	void *m_final_op;
	struct {
		struct rm_atomic_op atomic;
		struct rm_rdma_op rdma;
		struct rm_data_op data;
	};
	struct rds_conn_path *m_conn_path;
};

struct rds_mr {
	struct rb_node r_rb_node;
	struct kref r_kref;
	u32 r_key;
	unsigned int r_use_once: 1;
	unsigned int r_invalidate: 1;
	unsigned int r_write: 1;
	struct rds_sock *r_sock;
	struct rds_transport *r_trans;
	void *r_trans_private;
};

struct rds_znotifier {
	struct mmpin z_mmp;
	u32 z_cookie;
};

struct rds_zcopy_cookies {
	__u32 num;
	__u32 cookies[8];
};

struct rds_msg_zcopy_info {
	struct list_head rs_zcookie_next;
	union {
		struct rds_znotifier znotif;
		struct rds_zcopy_cookies zcookies;
	};
};

struct rds_msg_zcopy_queue {
	struct list_head zcookie_head;
	spinlock_t lock;
};

struct rds_notifier {
	struct list_head n_list;
	uint64_t n_user_token;
	int n_status;
};

struct rds_page_remainder {
	struct page *r_page;
	long unsigned int r_offset;
};

struct rds_rdma_args {
	rds_rdma_cookie_t cookie;
	struct rds_iovec remote_vec;
	__u64 local_vec_addr;
	__u64 nr_local;
	__u64 flags;
	__u64 user_token;
};

struct rds_rdma_notify {
	__u64 user_token;
	__s32 status;
};

struct rds_rx_trace_so {
	__u8 rx_traces;
	__u8 rx_trace_pos[3];
};

struct rds_sock {
	struct sock rs_sk;
	u64 rs_user_addr;
	u64 rs_user_bytes;
	struct rhash_head rs_bound_node;
	u8 rs_bound_key[22];
	struct sockaddr_in6 rs_bound_sin6;
	struct in6_addr rs_conn_addr;
	__be16 rs_conn_port;
	struct rds_transport *rs_transport;
	struct rds_connection *rs_conn;
	int rs_congested;
	int rs_seen_congestion;
	spinlock_t rs_lock;
	struct list_head rs_send_queue;
	u32 rs_snd_bytes;
	int rs_rcv_bytes;
	struct list_head rs_notify_queue;
	uint64_t rs_cong_mask;
	uint64_t rs_cong_notify;
	struct list_head rs_cong_list;
	long unsigned int rs_cong_track;
	rwlock_t rs_recv_lock;
	struct list_head rs_recv_queue;
	struct list_head rs_item;
	spinlock_t rs_rdma_lock;
	struct rb_root rs_rdma_keys;
	unsigned char rs_recverr;
	unsigned char rs_cong_monitor;
	u32 rs_hash_initval;
	u8 rs_rx_traces;
	u8 rs_rx_trace[3];
	struct rds_msg_zcopy_queue rs_zcookie_queue;
	u8 rs_tos;
};

struct rds_statistics {
	uint64_t s_conn_reset;
	uint64_t s_recv_drop_bad_checksum;
	uint64_t s_recv_drop_old_seq;
	uint64_t s_recv_drop_no_sock;
	uint64_t s_recv_drop_dead_sock;
	uint64_t s_recv_deliver_raced;
	uint64_t s_recv_delivered;
	uint64_t s_recv_queued;
	uint64_t s_recv_immediate_retry;
	uint64_t s_recv_delayed_retry;
	uint64_t s_recv_ack_required;
	uint64_t s_recv_rdma_bytes;
	uint64_t s_recv_ping;
	uint64_t s_send_queue_empty;
	uint64_t s_send_queue_full;
	uint64_t s_send_lock_contention;
	uint64_t s_send_lock_queue_raced;
	uint64_t s_send_immediate_retry;
	uint64_t s_send_delayed_retry;
	uint64_t s_send_drop_acked;
	uint64_t s_send_ack_required;
	uint64_t s_send_queued;
	uint64_t s_send_rdma;
	uint64_t s_send_rdma_bytes;
	uint64_t s_send_pong;
	uint64_t s_page_remainder_hit;
	uint64_t s_page_remainder_miss;
	uint64_t s_copy_to_user;
	uint64_t s_copy_from_user;
	uint64_t s_cong_update_queued;
	uint64_t s_cong_update_received;
	uint64_t s_cong_send_error;
	uint64_t s_cong_send_blocked;
	uint64_t s_recv_bytes_added_to_socket;
	uint64_t s_recv_bytes_removed_from_socket;
	uint64_t s_send_stuck_rm;
};

struct rds_tcp_incoming;

struct rds_tcp_connection {
	struct list_head t_tcp_node;
	bool t_tcp_node_detached;
	struct rds_conn_path *t_cpath;
	struct mutex t_conn_path_lock;
	struct socket *t_sock;
	void *t_orig_write_space;
	void *t_orig_data_ready;
	void *t_orig_state_change;
	struct rds_tcp_incoming *t_tinc;
	size_t t_tinc_hdr_rem;
	size_t t_tinc_data_rem;
	struct work_struct t_conn_w;
	struct work_struct t_send_w;
	struct work_struct t_down_w;
	struct work_struct t_recv_w;
	struct list_head t_list_item;
	u32 t_last_sent_nxt;
	u32 t_last_expected_una;
	u32 t_last_seen_una;
};

struct rds_tcp_desc_arg {
	struct rds_conn_path *conn_path;
	gfp_t gfp;
};

struct rds_tcp_incoming {
	struct rds_incoming ti_inc;
	struct sk_buff_head ti_skb_list;
};

struct rds_tcp_net {
	struct socket *rds_tcp_listen_sock;
	struct work_struct rds_tcp_accept_w;
	struct ctl_table_header *rds_tcp_sysctl;
	struct ctl_table *ctl_table;
	int sndbuf_size;
	int rcvbuf_size;
};

struct rds_tcp_statistics {
	uint64_t s_tcp_data_ready_calls;
	uint64_t s_tcp_write_space_calls;
	uint64_t s_tcp_sndbuf_full;
	uint64_t s_tcp_connect_raced;
	uint64_t s_tcp_listen_closed_stale;
};

struct rds_transport {
	char t_name[16];
	struct list_head t_item;
	struct module *t_owner;
	unsigned int t_prefer_loopback: 1;
	unsigned int t_mp_capable: 1;
	unsigned int t_type;
	int (*laddr_check)(struct net *, const struct in6_addr *, __u32);
	int (*conn_alloc)(struct rds_connection *, gfp_t);
	void (*conn_free)(void *);
	int (*conn_path_connect)(struct rds_conn_path *);
	void (*conn_path_shutdown)(struct rds_conn_path *);
	void (*xmit_path_prepare)(struct rds_conn_path *);
	void (*xmit_path_complete)(struct rds_conn_path *);
	int (*xmit)(struct rds_connection *, struct rds_message *, unsigned int, unsigned int, unsigned int);
	int (*xmit_rdma)(struct rds_connection *, struct rm_rdma_op *);
	int (*xmit_atomic)(struct rds_connection *, struct rm_atomic_op *);
	int (*recv_path)(struct rds_conn_path *);
	int (*inc_copy_to_user)(struct rds_incoming *, struct iov_iter *);
	void (*inc_free)(struct rds_incoming *);
	int (*cm_handle_connect)(struct rdma_cm_id *, struct rdma_cm_event *, bool);
	int (*cm_initiate_connect)(struct rdma_cm_id *, bool);
	void (*cm_connect_complete)(struct rds_connection *, struct rdma_cm_event *);
	unsigned int (*stats_info_copy)(struct rds_info_iterator *, unsigned int);
	void (*exit)(void);
	void * (*get_mr)(struct scatterlist *, long unsigned int, struct rds_sock *, u32 *, struct rds_connection *, u64, u64, int);
	void (*sync_mr)(void *, int);
	void (*free_mr)(void *, int);
	void (*flush_mrs)(void);
	bool (*t_unloading)(struct rds_connection *);
	u8 (*get_tos_map)(u8);
};

struct readahead_control {
	struct file *file;
	struct address_space *mapping;
	struct file_ra_state *ra;
	long unsigned int _index;
	unsigned int _nr_pages;
	unsigned int _batch_count;
	bool dropbehind;
	bool _workingset;
	long unsigned int _pflags;
};

struct readdir_callback {
	struct dir_context ctx;
	struct old_linux_dirent *dirent;
	int result;
};

struct real_mode_header {
	u32 text_start;
	u32 ro_end;
	u32 trampoline_start;
	u32 trampoline_header;
	u32 trampoline_start64;
	u32 trampoline_pgd;
	u32 wakeup_start;
	u32 wakeup_header;
	u32 machine_real_restart_asm;
	u32 machine_real_restart_seg;
};

struct virtnet_rq_stats {
	struct u64_stats_sync syncp;
	u64_stats_t packets;
	u64_stats_t bytes;
	u64_stats_t drops;
	u64_stats_t xdp_packets;
	u64_stats_t xdp_tx;
	u64_stats_t xdp_redirects;
	u64_stats_t xdp_drops;
	u64_stats_t kicks;
};

struct virtnet_interrupt_coalesce {
	u32 max_packets;
	u32 max_usecs;
};

struct virtnet_rq_dma;

struct receive_queue {
	struct virtqueue *vq;
	struct napi_struct napi;
	struct bpf_prog *xdp_prog;
	struct virtnet_rq_stats stats;
	u16 calls;
	bool dim_enabled;
	struct mutex dim_lock;
	struct dim dim;
	u32 packets_in_napi;
	struct virtnet_interrupt_coalesce intr_coal;
	struct page *pages;
	struct ewma_pkt_len mrg_avg_pkt_len;
	struct page_frag alloc_frag;
	struct scatterlist sg[19];
	unsigned int min_buf_len;
	char name[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
	struct virtnet_rq_dma *last_dma;
	struct xsk_buff_pool *xsk_pool;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xsk_rxq_info;
	struct xdp_buff **xsk_buffs;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct recent_entry {
	struct list_head list;
	struct list_head lru_list;
	union nf_inet_addr addr;
	u_int16_t family;
	u_int8_t ttl;
	u_int16_t index;
	u_int16_t nstamps;
	long unsigned int stamps[0];
};

struct recent_table;

struct recent_iter_state {
	const struct recent_table *table;
	unsigned int bucket;
};

struct recent_net {
	struct list_head tables;
	struct proc_dir_entry *xt_recent;
};

struct recent_table {
	struct list_head list;
	char name[200];
	union nf_inet_addr mask;
	unsigned int refcnt;
	unsigned int entries;
	u_int16_t nstamps_max_mask;
	struct list_head lru_list;
	struct list_head iphash[0];
};

struct reciprocal_value_adv {
	u32 m;
	u8 sh;
	u8 exp;
	bool is_wide_m;
};

struct reclaim_stat {
	unsigned int nr_dirty;
	unsigned int nr_unqueued_dirty;
	unsigned int nr_congested;
	unsigned int nr_writeback;
	unsigned int nr_immediate;
	unsigned int nr_pageout;
	unsigned int nr_activate[2];
	unsigned int nr_ref_keep;
	unsigned int nr_unmap_fail;
	unsigned int nr_lazyfree_fail;
	unsigned int nr_demoted;
};

struct reclaim_state {
	long unsigned int reclaimed;
};

struct recorded_ref {
	struct list_head list;
	char *name;
	struct fs_path *full_path;
	u64 dir;
	u64 dir_gen;
	int name_len;
	struct rb_node node;
	struct rb_root *root;
};

struct recovery_info {
	tid_t start_transaction;
	tid_t end_transaction;
	long unsigned int head_block;
	int nr_replays;
	int nr_revokes;
	int nr_revoke_hits;
};

struct tcf_qevent {
	struct tcf_block *block;
	struct tcf_block_ext_info info;
	struct tcf_proto *filter_chain;
};

struct red_sched_data {
	u32 limit;
	unsigned char flags;
	unsigned char userbits;
	struct timer_list adapt_timer;
	struct Qdisc *sch;
	struct red_parms parms;
	struct red_vars vars;
	struct red_stats stats;
	struct Qdisc *qdisc;
	struct tcf_qevent qe_early_drop;
	struct tcf_qevent qe_mark;
};

struct reg_whitelist {
	i915_reg_t offset_ldw;
	i915_reg_t offset_udw;
	u8 min_graphics_ver;
	u8 max_graphics_ver;
	u8 size;
};

typedef int (*regex_match_func)(char *, struct regex *, int);

struct regex {
	char pattern[256];
	int len;
	int field_len;
	regex_match_func match;
};

struct region {
	unsigned int start;
	unsigned int off;
	unsigned int group_len;
	unsigned int end;
	unsigned int nbits;
};

struct region_devres {
	struct resource *parent;
	resource_size_t start;
	resource_size_t n;
};

struct reloc_control {
	struct btrfs_block_group *block_group;
	struct btrfs_root *extent_root;
	struct inode *data_inode;
	struct btrfs_block_rsv *block_rsv;
	struct btrfs_backref_cache backref_cache;
	struct file_extent_cluster cluster;
	struct extent_io_tree processed_blocks;
	struct mapping_tree reloc_root_tree;
	struct list_head reloc_roots;
	struct list_head dirty_subvol_roots;
	u64 merging_rsv_size;
	u64 nodes_relocated;
	u64 reserved_bytes;
	u64 search_start;
	u64 extents_found;
	enum reloc_stage stage;
	bool create_reloc_tree;
	bool merge_reloc_tree;
	bool found_file_extent;
};

struct sgt_iter {
	struct scatterlist *sgp;
	union {
		long unsigned int pfn;
		dma_addr_t dma;
	};
	unsigned int curr;
	unsigned int max;
};

struct remap_pfn {
	struct mm_struct *mm;
	long unsigned int pfn;
	pgprot_t prot;
	struct sgt_iter sgt;
	resource_size_t iobase;
};

typedef int (*remote_function_f)(void *);

struct remote_function_call {
	struct task_struct *p;
	remote_function_f func;
	void *info;
	int ret;
};

struct remote_output {
	struct perf_buffer *rb;
	int err;
};

struct renamedata {
	struct mnt_idmap *old_mnt_idmap;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct mnt_idmap *new_mnt_idmap;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct inode **delegated_inode;
	unsigned int flags;
};

struct repcodes_s {
	U32 rep[3];
};

typedef struct repcodes_s repcodes_t;

struct reply_func {
	int type;
	int (*cb)(struct net_device *, struct nlmsghdr *, u32, struct nlattr **, struct sk_buff *);
};

struct req {
	struct req *next;
	struct completion done;
	int err;
	const char *name;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	struct device *dev;
};

struct req_iterator {
	struct bvec_iter iter;
	struct bio *bio;
};

typedef enum rq_end_io_ret rq_end_io_fn(struct request *, blk_status_t);

struct request {
	struct request_queue *q;
	struct blk_mq_ctx *mq_ctx;
	struct blk_mq_hw_ctx *mq_hctx;
	blk_opf_t cmd_flags;
	req_flags_t rq_flags;
	int tag;
	int internal_tag;
	unsigned int timeout;
	unsigned int __data_len;
	sector_t __sector;
	struct bio *bio;
	struct bio *biotail;
	union {
		struct list_head queuelist;
		struct request *rq_next;
	};
	struct block_device *part;
	u64 alloc_time_ns;
	u64 start_time_ns;
	u64 io_start_time_ns;
	short unsigned int stats_sectors;
	short unsigned int nr_phys_segments;
	short unsigned int nr_integrity_segments;
	enum mq_rq_state state;
	atomic_t ref;
	long unsigned int deadline;
	union {
		struct hlist_node hash;
		struct llist_node ipi_list;
	};
	union {
		struct rb_node rb_node;
		struct bio_vec special_vec;
	};
	struct {
		struct io_cq *icq;
		void *priv[2];
	} elv;
	struct {
		unsigned int seq;
		rq_end_io_fn *saved_end_io;
	} flush;
	u64 fifo_time;
	rq_end_io_fn *end_io;
	void *end_io_data;
};

struct request_key_auth {
	struct callback_head rcu;
	struct key *target_key;
	struct key *dest_keyring;
	const struct cred *cred;
	void *callout_info;
	size_t callout_len;
	pid_t pid;
	char op[8];
};

struct throtl_data;

struct request_queue {
	void *queuedata;
	struct elevator_queue *elevator;
	const struct blk_mq_ops *mq_ops;
	struct blk_mq_ctx *queue_ctx;
	long unsigned int queue_flags;
	unsigned int rq_timeout;
	unsigned int queue_depth;
	refcount_t refs;
	unsigned int nr_hw_queues;
	struct xarray hctx_table;
	struct percpu_ref q_usage_counter;
	struct lock_class_key io_lock_cls_key;
	struct lockdep_map io_lockdep_map;
	struct lock_class_key q_lock_cls_key;
	struct lockdep_map q_lockdep_map;
	struct request *last_merge;
	spinlock_t queue_lock;
	int quiesce_depth;
	struct gendisk *disk;
	struct kobject *mq_kobj;
	struct queue_limits limits;
	struct device *dev;
	enum rpm_status rpm_status;
	atomic_t pm_only;
	struct blk_queue_stats *stats;
	struct rq_qos *rq_qos;
	struct mutex rq_qos_mutex;
	int id;
	long unsigned int nr_requests;
	struct timer_list timeout;
	struct work_struct timeout_work;
	atomic_t nr_active_requests_shared_tags;
	struct blk_mq_tags *sched_shared_tags;
	struct list_head icq_list;
	long unsigned int blkcg_pols[1];
	struct blkcg_gq *root_blkg;
	struct list_head blkg_list;
	struct mutex blkcg_mutex;
	int node;
	spinlock_t requeue_lock;
	struct list_head requeue_list;
	struct delayed_work requeue_work;
	struct blk_trace *blk_trace;
	struct blk_flush_queue *fq;
	struct list_head flush_list;
	struct mutex sysfs_lock;
	struct mutex limits_lock;
	struct list_head unused_hctx_list;
	spinlock_t unused_hctx_lock;
	int mq_freeze_depth;
	struct throtl_data *td;
	struct callback_head callback_head;
	wait_queue_head_t mq_freeze_wq;
	struct mutex mq_freeze_lock;
	struct blk_mq_tag_set *tag_set;
	struct list_head tag_set_list;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct dentry *rqos_debugfs_dir;
	struct mutex debugfs_mutex;
};

struct request_sense {
	__u8 error_code: 7;
	__u8 valid: 1;
	__u8 segment_number;
	__u8 sense_key: 4;
	__u8 reserved2: 1;
	__u8 ili: 1;
	__u8 reserved1: 2;
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

struct request_sock__safe_rcu_or_null {
	struct sock *sk;
};

struct request_sock_ops {
	int family;
	unsigned int obj_size;
	struct kmem_cache *slab;
	char *slab_name;
	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*send_reset)(const struct sock *, struct sk_buff *, enum sk_rst_reason);
	void (*destructor)(struct request_sock *);
	void (*syn_ack_timeout)(const struct request_sock *);
};

struct request_wait {
	struct dma_fence_cb cb;
	struct task_struct *tsk;
};

struct res_proc_context {
	struct list_head *list;
	int (*preproc)(struct acpi_resource *, void *);
	void *preproc_data;
	int count;
	int error;
};

struct reserve_mem_table {
	char name[16];
	phys_addr_t start;
	phys_addr_t size;
};

struct reserve_ticket {
	u64 bytes;
	int error;
	bool steal;
	struct list_head list;
	wait_queue_head_t wait;
};

typedef resource_size_t (*resource_alignf)(void *, const struct resource *, resource_size_t, resource_size_t);

struct resource_constraint {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_alignf alignf;
	void *alignf_data;
};

struct resource_entry {
	struct list_head node;
	struct resource *res;
	resource_size_t offset;
	struct resource __res;
};

struct resource_map {
	u_long base;
	u_long num;
	struct resource_map *next;
};

struct resource_win {
	struct resource res;
	resource_size_t offset;
};

struct restart_block {
	long unsigned int arch_data;
	long int (*fn)(struct restart_block *);
	union {
		struct {
			u32 *uaddr;
			u32 val;
			u32 flags;
			u32 bitset;
			u64 time;
			u32 *uaddr2;
		} futex;
		struct {
			clockid_t clockid;
			enum timespec_type type;
			union {
				struct __kernel_timespec *rmtp;
				struct old_timespec32 *compat_rmtp;
			};
			u64 expires;
		} nanosleep;
		struct {
			struct pollfd *ufds;
			int nfds;
			int has_timeout;
			long unsigned int tv_sec;
			long unsigned int tv_nsec;
		} poll;
	};
};

struct restore_data_record {
	long unsigned int jump_address;
	long unsigned int jump_address_phys;
	long unsigned int cr3;
	long unsigned int magic;
	long unsigned int e820_checksum;
};

struct resume_swap_area {
	__kernel_loff_t offset;
	__u32 dev;
} __attribute__((packed));

struct resv_map {
	struct kref refs;
	spinlock_t lock;
	struct list_head regions;
	long int adds_in_progress;
	struct list_head region_cache;
	long int region_cache_count;
	struct rw_semaphore rw_sema;
	struct page_counter *reservation_counter;
	long unsigned int pages_per_hpage;
	struct cgroup_subsys_state *css;
};

struct rethook {
	void *data;
	void (*handler)(struct rethook_node *, void *, long unsigned int, struct pt_regs *);
	struct objpool_head pool;
	struct callback_head rcu;
};

struct return_consumer {
	__u64 cookie;
	__u64 id;
};

struct return_instance {
	struct hprobe hprobe;
	long unsigned int func;
	long unsigned int stack;
	long unsigned int orig_ret_vaddr;
	bool chained;
	int cons_cnt;
	struct return_instance *next;
	struct callback_head rcu;
	struct return_consumer consumer;
	struct return_consumer *extra_consumers;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct reuseport_array {
	struct bpf_map map;
	struct sock *ptrs[0];
};

struct rgb {
	u8 r;
	u8 g;
	u8 b;
};

struct rhash_lock_head {};

struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

struct ring_buffer_event {
	u32 type_len: 5;
	u32 time_delta: 27;
	u32 array[0];
};

struct ring_buffer_per_cpu;

struct ring_buffer_iter {
	struct ring_buffer_per_cpu *cpu_buffer;
	long unsigned int head;
	long unsigned int next_event;
	struct buffer_page *head_page;
	struct buffer_page *cache_reader_page;
	long unsigned int cache_read;
	long unsigned int cache_pages_removed;
	u64 read_stamp;
	u64 page_stamp;
	struct ring_buffer_event *event;
	size_t event_size;
	int missed_events;
};

struct ring_buffer_meta {
	int magic;
	int struct_size;
	long unsigned int text_addr;
	long unsigned int data_addr;
	long unsigned int first_buffer;
	long unsigned int head_buffer;
	long unsigned int commit_buffer;
	__u32 subbuf_size;
	__u32 nr_subbufs;
	int buffers[0];
};

struct trace_buffer_meta;

struct ring_buffer_per_cpu {
	int cpu;
	atomic_t record_disabled;
	atomic_t resize_disabled;
	struct trace_buffer *buffer;
	raw_spinlock_t reader_lock;
	arch_spinlock_t lock;
	struct lock_class_key lock_key;
	struct buffer_data_page *free_page;
	long unsigned int nr_pages;
	unsigned int current_context;
	struct list_head *pages;
	long unsigned int cnt;
	struct buffer_page *head_page;
	struct buffer_page *tail_page;
	struct buffer_page *commit_page;
	struct buffer_page *reader_page;
	long unsigned int lost_events;
	long unsigned int last_overrun;
	long unsigned int nest;
	local_t entries_bytes;
	local_t entries;
	local_t overrun;
	local_t commit_overrun;
	local_t dropped_events;
	local_t committing;
	local_t commits;
	local_t pages_touched;
	local_t pages_lost;
	local_t pages_read;
	long int last_pages_touch;
	size_t shortest_full;
	long unsigned int read;
	long unsigned int read_bytes;
	rb_time_t write_stamp;
	rb_time_t before_stamp;
	u64 event_stamp[5];
	u64 read_stamp;
	long unsigned int pages_removed;
	unsigned int mapped;
	unsigned int user_mapped;
	struct mutex mapping_lock;
	long unsigned int *subbuf_ids;
	struct trace_buffer_meta *meta_page;
	struct ring_buffer_meta *ring_meta;
	long int nr_pages_to_update;
	struct list_head new_pages;
	struct work_struct update_pages_work;
	struct completion update_done;
	struct rb_irq_work irq_work;
};

struct rings_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ringparam ringparam;
	struct kernel_ethtool_ringparam kernel_ringparam;
	u32 supported_ring_params;
};

struct rlimit64 {
	__u64 rlim_cur;
	__u64 rlim_max;
};

struct rmap_walk_arg {
	struct folio *folio;
	bool map_unused_to_zeropage;
};

struct rmap_walk_control {
	void *arg;
	bool try_lock;
	bool contended;
	bool (*rmap_one)(struct folio *, struct vm_area_struct *, long unsigned int, void *);
	int (*done)(struct folio *);
	struct anon_vma * (*anon_lock)(const struct folio *, struct rmap_walk_control *);
	bool (*invalid_vma)(struct vm_area_struct *, void *);
};

struct rmi_2d_axis_alignment {
	bool swap_axes;
	bool flip_x;
	bool flip_y;
	u16 clip_x_low;
	u16 clip_y_low;
	u16 clip_x_high;
	u16 clip_y_high;
	u16 offset_x;
	u16 offset_y;
	u8 delta_x_threshold;
	u8 delta_y_threshold;
};

struct rmi_2d_sensor_platform_data {
	struct rmi_2d_axis_alignment axis_align;
	enum rmi_sensor_type sensor_type;
	int x_mm;
	int y_mm;
	int disable_report_mask;
	u16 rezero_wait;
	bool topbuttonpad;
	bool kernel_tracking;
	int dmax;
	int dribble;
	int palm_detect;
};

struct rmi_device_platform_data_spi {
	u32 block_delay_us;
	u32 split_read_block_delay_us;
	u32 read_delay_us;
	u32 write_delay_us;
	u32 split_read_byte_delay_us;
	u32 pre_delay_us;
	u32 post_delay_us;
	u8 bits_per_word;
	u16 mode;
	void *cs_assert_data;
	int (*cs_assert)(const void *, const bool);
};

struct rmi_f01_power_management {
	enum rmi_reg_state nosleep;
	u8 wakeup_threshold;
	u8 doze_holdoff;
	u8 doze_interval;
};

struct rmi_gpio_data {
	bool buttonpad;
	bool trackstick_buttons;
	bool disable;
};

struct rmi_device_platform_data {
	int reset_delay_ms;
	int irq;
	struct rmi_device_platform_data_spi spi_data;
	struct rmi_2d_sensor_platform_data sensor_pdata;
	struct rmi_f01_power_management power_management;
	struct rmi_gpio_data gpio_data;
};

struct rng_alg {
	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
	unsigned int seedsize;
	struct crypto_alg base;
};

struct rng_ctx {
	unsigned int len;
	struct crypto_rng *drng;
	u8 *addtl;
	size_t addtl_len;
};

struct rng_parent_ctx {
	struct crypto_rng *drng;
	u8 *entropy;
};

struct robust_list {
	struct robust_list *next;
};

struct robust_list_head {
	struct robust_list list;
	long int futex_offset;
	struct robust_list *list_op_pending;
};

struct rock_ridge {
	__u8 signature[2];
	__u8 len;
	__u8 version;
	union {
		struct SU_SP_s SP;
		struct SU_CE_s CE;
		struct SU_ER_s ER;
		struct RR_RR_s RR;
		struct RR_PX_s PX;
		struct RR_PN_s PN;
		struct RR_SL_s SL;
		struct RR_NM_s NM;
		struct RR_CL_s CL;
		struct RR_PL_s PL;
		struct RR_TF_s TF;
		struct RR_ZF_s ZF;
	} u;
};

struct rock_state {
	void *buffer;
	unsigned char *chr;
	int len;
	int cont_size;
	int cont_extent;
	int cont_offset;
	int cont_loops;
	struct inode *inode;
};

struct root_device {
	struct device dev;
	struct module *owner;
};

struct root_domain {
	atomic_t refcount;
	atomic_t rto_count;
	struct callback_head rcu;
	cpumask_var_t span;
	cpumask_var_t online;
	bool overloaded;
	bool overutilized;
	cpumask_var_t dlo_mask;
	atomic_t dlo_count;
	struct dl_bw dl_bw;
	struct cpudl cpudl;
	u64 visit_cookie;
	struct irq_work rto_push_work;
	raw_spinlock_t rto_lock;
	int rto_loop;
	int rto_cpu;
	atomic_t rto_loop_next;
	atomic_t rto_loop_start;
	cpumask_var_t rto_mask;
	struct cpupri cpupri;
	struct perf_domain *pd;
};

struct root_entry {
	u64 lo;
	u64 hi;
};

struct root_name_map {
	u64 id;
	const char *name;
};

struct route4_filter;

struct route4_bucket {
	struct route4_filter *ht[33];
	struct callback_head rcu;
};

struct route4_fastmap {
	struct route4_filter *filter;
	u32 id;
	int iif;
};

struct route4_filter {
	struct route4_filter *next;
	u32 id;
	int iif;
	struct tcf_result res;
	struct tcf_exts exts;
	u32 handle;
	struct route4_bucket *bkt;
	struct tcf_proto *tp;
	struct rcu_work rwork;
};

struct route4_head {
	struct route4_fastmap fastmap[16];
	struct route4_bucket *table[257];
	struct callback_head rcu;
};

struct route_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved_l: 3;
	__u8 route_pref: 2;
	__u8 reserved_h: 3;
	__be32 lifetime;
	__u8 prefix[0];
};

struct rpc_add_xprt_test {
	void (*add_xprt_test)(struct rpc_clnt *, struct rpc_xprt *, void *);
	void *data;
};

struct rpc_auth_create_args {
	rpc_authflavor_t pseudoflavor;
	const char *target_name;
};

struct rpc_authops {
	struct module *owner;
	rpc_authflavor_t au_flavor;
	char *au_name;
	struct rpc_auth * (*create)(const struct rpc_auth_create_args *, struct rpc_clnt *);
	void (*destroy)(struct rpc_auth *);
	int (*hash_cred)(struct auth_cred *, unsigned int);
	struct rpc_cred * (*lookup_cred)(struct rpc_auth *, struct auth_cred *, int);
	struct rpc_cred * (*crcreate)(struct rpc_auth *, struct auth_cred *, int, gfp_t);
	rpc_authflavor_t (*info2flavor)(struct rpcsec_gss_info *);
	int (*flavor2info)(rpc_authflavor_t, struct rpcsec_gss_info *);
	int (*key_timeout)(struct rpc_auth *, struct rpc_cred *);
	int (*ping)(struct rpc_clnt *);
};

struct rpc_buffer {
	size_t len;
	char data[0];
};

struct rpc_call_ops {
	void (*rpc_call_prepare)(struct rpc_task *, void *);
	void (*rpc_call_done)(struct rpc_task *, void *);
	void (*rpc_count_stats)(struct rpc_task *, void *);
	void (*rpc_release)(void *);
};

struct rpc_xprt_switch;

struct rpc_cb_add_xprt_calldata {
	struct rpc_xprt_switch *xps;
	struct rpc_xprt *xprt;
};

struct rpc_pipe_dir_head {
	struct list_head pdh_entries;
	struct dentry *pdh_dentry;
};

struct rpc_rtt {
	long unsigned int timeo;
	long unsigned int srtt[5];
	long unsigned int sdrtt[5];
	int ntimeouts[5];
};

struct rpc_timeout {
	long unsigned int to_initval;
	long unsigned int to_maxval;
	long unsigned int to_increment;
	unsigned int to_retries;
	unsigned char to_exponential;
};

struct rpc_xprt_iter_ops;

struct rpc_xprt_iter {
	struct rpc_xprt_switch *xpi_xpswitch;
	struct rpc_xprt *xpi_cursor;
	const struct rpc_xprt_iter_ops *xpi_ops;
};

struct rpc_iostats;

struct rpc_sysfs_client;

struct rpc_clnt {
	refcount_t cl_count;
	unsigned int cl_clid;
	struct list_head cl_clients;
	struct list_head cl_tasks;
	atomic_t cl_pid;
	spinlock_t cl_lock;
	struct rpc_xprt *cl_xprt;
	const struct rpc_procinfo *cl_procinfo;
	u32 cl_prog;
	u32 cl_vers;
	u32 cl_maxproc;
	struct rpc_auth *cl_auth;
	struct rpc_stat *cl_stats;
	struct rpc_iostats *cl_metrics;
	unsigned int cl_softrtry: 1;
	unsigned int cl_softerr: 1;
	unsigned int cl_discrtry: 1;
	unsigned int cl_noretranstimeo: 1;
	unsigned int cl_autobind: 1;
	unsigned int cl_chatty: 1;
	unsigned int cl_shutdown: 1;
	struct xprtsec_parms cl_xprtsec;
	struct rpc_rtt *cl_rtt;
	const struct rpc_timeout *cl_timeout;
	atomic_t cl_swapper;
	int cl_nodelen;
	char cl_nodename[65];
	struct rpc_pipe_dir_head cl_pipedir_objects;
	struct rpc_clnt *cl_parent;
	struct rpc_rtt cl_rtt_default;
	struct rpc_timeout cl_timeout_default;
	const struct rpc_program *cl_program;
	const char *cl_principal;
	struct rpc_sysfs_client *cl_sysfs;
	union {
		struct rpc_xprt_iter cl_xpi;
		struct work_struct cl_work;
	};
	const struct cred *cl_cred;
	unsigned int cl_max_connect;
	struct super_block *pipefs_sb;
	atomic_t cl_task_count;
};

struct svc_xprt;

struct rpc_create_args {
	struct net *net;
	int protocol;
	struct sockaddr *address;
	size_t addrsize;
	struct sockaddr *saddress;
	const struct rpc_timeout *timeout;
	const char *servername;
	const char *nodename;
	const struct rpc_program *program;
	struct rpc_stat *stats;
	u32 prognumber;
	u32 version;
	rpc_authflavor_t authflavor;
	u32 nconnect;
	long unsigned int flags;
	char *client_name;
	struct svc_xprt *bc_xprt;
	const struct cred *cred;
	unsigned int max_connect;
	struct xprtsec_parms xprtsec;
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct rpc_cred_cache {
	struct hlist_head *hashtable;
	unsigned int hashbits;
	spinlock_t lock;
};

struct rpc_credops {
	const char *cr_name;
	int (*cr_init)(struct rpc_auth *, struct rpc_cred *);
	void (*crdestroy)(struct rpc_cred *);
	int (*crmatch)(struct auth_cred *, struct rpc_cred *, int);
	int (*crmarshal)(struct rpc_task *, struct xdr_stream *);
	int (*crrefresh)(struct rpc_task *);
	int (*crvalidate)(struct rpc_task *, struct xdr_stream *);
	int (*crwrap_req)(struct rpc_task *, struct xdr_stream *);
	int (*crunwrap_resp)(struct rpc_task *, struct xdr_stream *);
	int (*crkey_timeout)(struct rpc_cred *);
	char * (*crstringify_acceptor)(struct rpc_cred *);
	bool (*crneed_reencode)(struct rpc_task *);
};

struct rpc_filelist {
	const char *name;
	const struct file_operations *i_fop;
	umode_t mode;
};

struct rpc_inode {
	struct inode vfs_inode;
	void *private;
	struct rpc_pipe *pipe;
	wait_queue_head_t waitq;
};

struct rpc_iostats {
	spinlock_t om_lock;
	long unsigned int om_ops;
	long unsigned int om_ntrans;
	long unsigned int om_timeouts;
	long long unsigned int om_bytes_sent;
	long long unsigned int om_bytes_recv;
	ktime_t om_queue;
	ktime_t om_rtt;
	ktime_t om_execute;
	long unsigned int om_error_status;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rpc_pipe {
	struct list_head pipe;
	struct list_head in_upcall;
	struct list_head in_downcall;
	int pipelen;
	int nreaders;
	int nwriters;
	int flags;
	struct delayed_work queue_timeout;
	const struct rpc_pipe_ops *ops;
	spinlock_t lock;
	struct dentry *dentry;
};

struct rpc_pipe_dir_object_ops {
	int (*create)(struct dentry *, struct rpc_pipe_dir_object *);
	void (*destroy)(struct dentry *, struct rpc_pipe_dir_object *);
};

struct rpc_pipe_ops {
	ssize_t (*upcall)(struct file *, struct rpc_pipe_msg *, char *, size_t);
	ssize_t (*downcall)(struct file *, const char *, size_t);
	void (*release_pipe)(struct inode *);
	int (*open_pipe)(struct inode *);
	void (*destroy_msg)(struct rpc_pipe_msg *);
};

typedef void (*kxdreproc_t)(struct rpc_rqst *, struct xdr_stream *, const void *);

typedef int (*kxdrdproc_t)(struct rpc_rqst *, struct xdr_stream *, void *);

struct rpc_procinfo {
	u32 p_proc;
	kxdreproc_t p_encode;
	kxdrdproc_t p_decode;
	unsigned int p_arglen;
	unsigned int p_replen;
	unsigned int p_timer;
	u32 p_statidx;
	const char *p_name;
};

struct rpc_program {
	const char *name;
	u32 number;
	unsigned int nrvers;
	const struct rpc_version **version;
	struct rpc_stat *stats;
	const char *pipe_dir_name;
};

struct xdr_buf {
	struct kvec head[1];
	struct kvec tail[1];
	struct bio_vec *bvec;
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int flags;
	unsigned int buflen;
	unsigned int len;
};

struct rpc_rqst {
	struct rpc_xprt *rq_xprt;
	struct xdr_buf rq_snd_buf;
	struct xdr_buf rq_rcv_buf;
	struct rpc_task *rq_task;
	struct rpc_cred *rq_cred;
	__be32 rq_xid;
	int rq_cong;
	u32 rq_seqno;
	int rq_enc_pages_num;
	struct page **rq_enc_pages;
	void (*rq_release_snd_buf)(struct rpc_rqst *);
	union {
		struct list_head rq_list;
		struct rb_node rq_recv;
	};
	struct list_head rq_xmit;
	struct list_head rq_xmit2;
	void *rq_buffer;
	size_t rq_callsize;
	void *rq_rbuffer;
	size_t rq_rcvsize;
	size_t rq_xmit_bytes_sent;
	size_t rq_reply_bytes_recvd;
	struct xdr_buf rq_private_buf;
	long unsigned int rq_majortimeo;
	long unsigned int rq_minortimeo;
	long unsigned int rq_timeout;
	ktime_t rq_rtt;
	unsigned int rq_retries;
	unsigned int rq_connect_cookie;
	atomic_t rq_pin;
	u32 rq_bytes_sent;
	ktime_t rq_xtime;
	int rq_ntrans;
};

struct rpc_sysfs_client {
	struct kobject kobject;
	struct net *net;
	struct rpc_clnt *clnt;
	struct rpc_xprt_switch *xprt_switch;
};

struct rpc_sysfs_xprt {
	struct kobject kobject;
	struct rpc_xprt *xprt;
	struct rpc_xprt_switch *xprt_switch;
};

struct rpc_sysfs_xprt_switch {
	struct kobject kobject;
	struct net *net;
	struct rpc_xprt_switch *xprt_switch;
	struct rpc_xprt *xprt;
};

struct rpc_task_setup {
	struct rpc_task *task;
	struct rpc_clnt *rpc_client;
	struct rpc_xprt *rpc_xprt;
	struct rpc_cred *rpc_op_cred;
	const struct rpc_message *rpc_message;
	const struct rpc_call_ops *callback_ops;
	void *callback_data;
	struct workqueue_struct *workqueue;
	short unsigned int flags;
	signed char priority;
};

struct rpc_version {
	u32 number;
	unsigned int nrprocs;
	const struct rpc_procinfo *procs;
	unsigned int *counts;
};

struct rpc_xprt_ops;

struct xprt_class;

struct rpc_xprt {
	struct kref kref;
	const struct rpc_xprt_ops *ops;
	unsigned int id;
	const struct rpc_timeout *timeout;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	int prot;
	long unsigned int cong;
	long unsigned int cwnd;
	size_t max_payload;
	struct rpc_wait_queue binding;
	struct rpc_wait_queue sending;
	struct rpc_wait_queue pending;
	struct rpc_wait_queue backlog;
	struct list_head free;
	unsigned int max_reqs;
	unsigned int min_reqs;
	unsigned int num_reqs;
	long unsigned int state;
	unsigned char resvport: 1;
	unsigned char reuseport: 1;
	atomic_t swapper;
	unsigned int bind_index;
	struct list_head xprt_switch;
	long unsigned int bind_timeout;
	long unsigned int reestablish_timeout;
	struct xprtsec_parms xprtsec;
	unsigned int connect_cookie;
	struct work_struct task_cleanup;
	struct timer_list timer;
	long unsigned int last_used;
	long unsigned int idle_timeout;
	long unsigned int connect_timeout;
	long unsigned int max_reconnect_timeout;
	atomic_long_t queuelen;
	spinlock_t transport_lock;
	spinlock_t reserve_lock;
	spinlock_t queue_lock;
	u32 xid;
	struct rpc_task *snd_task;
	struct list_head xmit_queue;
	atomic_long_t xmit_queuelen;
	struct svc_xprt *bc_xprt;
	struct rb_root recv_queue;
	struct {
		long unsigned int bind_count;
		long unsigned int connect_count;
		long unsigned int connect_start;
		long unsigned int connect_time;
		long unsigned int sends;
		long unsigned int recvs;
		long unsigned int bad_xids;
		long unsigned int max_slots;
		long long unsigned int req_u;
		long long unsigned int bklog_u;
		long long unsigned int sending_u;
		long long unsigned int pending_u;
	} stat;
	struct net *xprt_net;
	netns_tracker ns_tracker;
	const char *servername;
	const char *address_strings[6];
	struct callback_head rcu;
	const struct xprt_class *xprt_class;
	struct rpc_sysfs_xprt *xprt_sysfs;
	bool main;
};

struct rpc_xprt_iter_ops {
	void (*xpi_rewind)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_xprt)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_next)(struct rpc_xprt_iter *);
};

struct rpc_xprt_ops {
	void (*set_buffer_size)(struct rpc_xprt *, size_t, size_t);
	int (*reserve_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*release_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*alloc_slot)(struct rpc_xprt *, struct rpc_task *);
	void (*free_slot)(struct rpc_xprt *, struct rpc_rqst *);
	void (*rpcbind)(struct rpc_task *);
	void (*set_port)(struct rpc_xprt *, short unsigned int);
	void (*connect)(struct rpc_xprt *, struct rpc_task *);
	int (*get_srcaddr)(struct rpc_xprt *, char *, size_t);
	short unsigned int (*get_srcport)(struct rpc_xprt *);
	int (*buf_alloc)(struct rpc_task *);
	void (*buf_free)(struct rpc_task *);
	int (*prepare_request)(struct rpc_rqst *, struct xdr_buf *);
	int (*send_request)(struct rpc_rqst *);
	void (*abort_send_request)(struct rpc_rqst *);
	void (*wait_for_reply_request)(struct rpc_task *);
	void (*timer)(struct rpc_xprt *, struct rpc_task *);
	void (*release_request)(struct rpc_task *);
	void (*close)(struct rpc_xprt *);
	void (*destroy)(struct rpc_xprt *);
	void (*set_connect_timeout)(struct rpc_xprt *, long unsigned int, long unsigned int);
	void (*print_stats)(struct rpc_xprt *, struct seq_file *);
	int (*enable_swap)(struct rpc_xprt *);
	void (*disable_swap)(struct rpc_xprt *);
	void (*inject_disconnect)(struct rpc_xprt *);
	int (*bc_setup)(struct rpc_xprt *, unsigned int);
	size_t (*bc_maxpayload)(struct rpc_xprt *);
	unsigned int (*bc_num_slots)(struct rpc_xprt *);
	void (*bc_free_rqst)(struct rpc_rqst *);
	void (*bc_destroy)(struct rpc_xprt *, unsigned int);
};

struct rpc_xprt_switch {
	spinlock_t xps_lock;
	struct kref xps_kref;
	unsigned int xps_id;
	unsigned int xps_nxprts;
	unsigned int xps_nactive;
	unsigned int xps_nunique_destaddr_xprts;
	atomic_long_t xps_queuelen;
	struct list_head xps_xprt_list;
	struct net *xps_net;
	const struct rpc_xprt_iter_ops *xps_iter_ops;
	struct rpc_sysfs_xprt_switch *xps_sysfs;
	struct callback_head xps_rcu;
};

struct rpcb_info {
	u32 rpc_vers;
	const struct rpc_procinfo *rpc_proc;
};

struct rpcbind_args {
	struct rpc_xprt *r_xprt;
	u32 r_prog;
	u32 r_vers;
	u32 r_prot;
	short unsigned int r_port;
	const char *r_netid;
	const char *r_addr;
	const char *r_owner;
	int r_status;
};

struct rpl_iptunnel_encap {
	struct {
		struct {} __empty_srh;
		struct ipv6_rpl_sr_hdr srh[0];
	};
};

struct rpl_lwt {
	struct dst_cache cache;
	struct rpl_iptunnel_encap tuninfo;
};

struct rps_dev_flow {
	u16 cpu;
	u16 filter;
	unsigned int last_qtail;
};

struct rps_dev_flow_table {
	unsigned int mask;
	struct callback_head rcu;
	struct rps_dev_flow flows[0];
};

struct rps_map {
	unsigned int len;
	struct callback_head rcu;
	u16 cpus[0];
};

struct rps_sock_flow_table {
	u32 mask;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 ents[0];
};

struct rt_prio_array {
	long unsigned int bitmap[2];
	struct list_head queue[100];
};

struct rt_rq {
	struct rt_prio_array active;
	unsigned int rt_nr_running;
	unsigned int rr_nr_running;
	struct {
		int curr;
		int next;
	} highest_prio;
	bool overloaded;
	struct plist_head pushable_tasks;
	int rt_queued;
};

struct sched_dl_entity;

typedef bool (*dl_server_has_tasks_f)(struct sched_dl_entity *);

typedef struct task_struct * (*dl_server_pick_f)(struct sched_dl_entity *);

struct sched_dl_entity {
	struct rb_node rb_node;
	u64 dl_runtime;
	u64 dl_deadline;
	u64 dl_period;
	u64 dl_bw;
	u64 dl_density;
	s64 runtime;
	u64 deadline;
	unsigned int flags;
	unsigned int dl_throttled: 1;
	unsigned int dl_yielded: 1;
	unsigned int dl_non_contending: 1;
	unsigned int dl_overrun: 1;
	unsigned int dl_server: 1;
	unsigned int dl_server_active: 1;
	unsigned int dl_defer: 1;
	unsigned int dl_defer_armed: 1;
	unsigned int dl_defer_running: 1;
	struct hrtimer dl_timer;
	struct hrtimer inactive_timer;
	struct rq *rq;
	dl_server_has_tasks_f server_has_tasks;
	dl_server_pick_f server_pick_task;
	struct sched_dl_entity *pi_se;
};

struct sched_info {
	long unsigned int pcount;
	long long unsigned int run_delay;
	long long unsigned int max_run_delay;
	long long unsigned int min_run_delay;
	long long unsigned int last_arrival;
	long long unsigned int last_queued;
};

struct rq {
	raw_spinlock_t __lock;
	unsigned int nr_running;
	long unsigned int last_blocked_load_update_tick;
	unsigned int has_blocked_load;
	long: 64;
	call_single_data_t nohz_csd;
	unsigned int nohz_tick_stopped;
	atomic_t nohz_flags;
	unsigned int ttwu_pending;
	u64 nr_switches;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cfs_rq cfs;
	struct rt_rq rt;
	struct dl_rq dl;
	struct sched_dl_entity fair_server;
	struct list_head leaf_cfs_rq_list;
	struct list_head *tmp_alone_branch;
	unsigned int nr_uninterruptible;
	union {
		struct task_struct *donor;
		struct task_struct *curr;
	};
	struct sched_dl_entity *dl_server;
	struct task_struct *idle;
	struct task_struct *stop;
	long unsigned int next_balance;
	struct mm_struct *prev_mm;
	unsigned int clock_update_flags;
	u64 clock;
	u64 clock_task;
	u64 clock_pelt;
	long unsigned int lost_idle_time;
	u64 clock_pelt_idle;
	u64 clock_idle;
	atomic_t nr_iowait;
	u64 last_seen_need_resched_ns;
	int ticks_without_resched;
	int membarrier_state;
	struct root_domain *rd;
	struct sched_domain *sd;
	long unsigned int cpu_capacity;
	struct balance_callback *balance_callback;
	unsigned char nohz_idle_balance;
	unsigned char idle_balance;
	long unsigned int misfit_task_load;
	int active_balance;
	int push_cpu;
	struct cpu_stop_work active_balance_work;
	int cpu;
	int online;
	struct list_head cfs_tasks;
	struct sched_avg avg_rt;
	struct sched_avg avg_dl;
	u64 idle_stamp;
	u64 avg_idle;
	u64 max_idle_balance_cost;
	struct rcuwait hotplug_wait;
	u64 prev_steal_time;
	long unsigned int calc_load_update;
	long int calc_load_active;
	long: 64;
	call_single_data_t hrtick_csd;
	struct hrtimer hrtick_timer;
	ktime_t hrtick_time;
	struct sched_info rq_sched_info;
	long long unsigned int rq_cpu_time;
	unsigned int yld_count;
	unsigned int sched_count;
	unsigned int sched_goidle;
	unsigned int ttwu_count;
	unsigned int ttwu_local;
	struct cpuidle_state *idle_state;
	unsigned int nr_pinned;
	unsigned int push_busy;
	struct cpu_stop_work push_work;
	cpumask_var_t scratch_mask;
	call_single_data_t cfsb_csd;
	struct list_head cfsb_csd_list;
	long: 64;
	long: 64;
};

struct rq_depth {
	unsigned int max_depth;
	int scale_step;
	bool scaled_max;
	unsigned int queue_depth;
	unsigned int default_depth;
};

struct rq_iter_data {
	struct blk_mq_hw_ctx *hctx;
	bool has_rq;
};

struct rq_map_data {
	struct page **pages;
	long unsigned int offset;
	short unsigned int page_order;
	short unsigned int nr_entries;
	bool null_mapped;
	bool from_user;
};

struct rq_qos_ops {
	void (*throttle)(struct rq_qos *, struct bio *);
	void (*track)(struct rq_qos *, struct request *, struct bio *);
	void (*merge)(struct rq_qos *, struct request *, struct bio *);
	void (*issue)(struct rq_qos *, struct request *);
	void (*requeue)(struct rq_qos *, struct request *);
	void (*done)(struct rq_qos *, struct request *);
	void (*done_bio)(struct rq_qos *, struct bio *);
	void (*cleanup)(struct rq_qos *, struct bio *);
	void (*queue_depth_changed)(struct rq_qos *);
	void (*exit)(struct rq_qos *);
	const struct blk_mq_debugfs_attr *debugfs_attrs;
};

typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);

struct rq_qos_wait_data {
	struct wait_queue_entry wq;
	struct task_struct *task;
	struct rq_wait *rqw;
	acquire_inflight_cb_t *cb;
	void *private_data;
	bool got_token;
};

struct rs_msg {
	struct icmp6hdr icmph;
	__u8 opt[0];
};

struct rsa_key {
	const u8 *n;
	const u8 *e;
	const u8 *d;
	const u8 *p;
	const u8 *q;
	const u8 *dp;
	const u8 *dq;
	const u8 *qinv;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	size_t dp_sz;
	size_t dq_sz;
	size_t qinv_sz;
};

struct rsa_mpi_key {
	MPI n;
	MPI e;
	MPI d;
	MPI p;
	MPI q;
	MPI dp;
	MPI dq;
	MPI qinv;
};

struct rsassa_pkcs1_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct rsassa_pkcs1_inst_ctx {
	struct crypto_akcipher_spawn spawn;
	const struct hash_prefix *hash_prefix;
};

struct rsc {
	struct cache_head h;
	struct xdr_netobj handle;
	struct svc_cred cred;
	struct gss_svc_seq_data seqdata;
	struct gss_ctx *mechctx;
	struct callback_head callback_head;
};

struct rseq {
	__u32 cpu_id_start;
	__u32 cpu_id;
	__u64 rseq_cs;
	__u32 flags;
	__u32 node_id;
	__u32 mm_cid;
	char end[0];
};

struct rseq_cs {
	__u32 version;
	__u32 flags;
	__u64 start_ip;
	__u64 post_commit_offset;
	__u64 abort_ip;
};

struct rsi {
	struct cache_head h;
	struct xdr_netobj in_handle;
	struct xdr_netobj in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	int major_status;
	int minor_status;
	struct callback_head callback_head;
};

struct rss_nl_dump_ctx {
	long unsigned int ifindex;
	long unsigned int ctx_idx;
	unsigned int match_ifindex;
	unsigned int start_ctx;
};

struct rss_reply_data {
	struct ethnl_reply_data base;
	bool no_key_fields;
	u32 indir_size;
	u32 hkey_size;
	u32 hfunc;
	u32 input_xfrm;
	u32 *indir_table;
	u8 *hkey;
};

struct rss_req_info {
	struct ethnl_req_info base;
	u32 rss_context;
};

struct rsvd_count {
	int ndelayed;
	bool first_do_lblk_found;
	ext4_lblk_t first_do_lblk;
	ext4_lblk_t last_do_lblk;
	struct extent_status *left_es;
	bool partial;
	ext4_lblk_t lclu;
};

struct rt0_hdr {
	struct ipv6_rt_hdr rt_hdr;
	__u32 reserved;
	struct in6_addr addr[0];
};

struct rt2_hdr {
	struct ipv6_rt_hdr rt_hdr;
	__u32 reserved;
	struct in6_addr addr;
};

struct rt6_exception {
	struct hlist_node hlist;
	struct rt6_info *rt6i;
	long unsigned int stamp;
	struct callback_head rcu;
};

struct rt6_exception_bucket {
	struct hlist_head chain;
	int depth;
};

struct rt6_mtu_change_arg {
	struct net_device *dev;
	unsigned int mtu;
	struct fib6_info *f6i;
};

struct rt6_nh {
	struct fib6_info *fib6_info;
	struct fib6_config r_cfg;
	struct list_head next;
};

struct rt6_rtnl_dump_arg {
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net *net;
	struct fib_dump_filter filter;
};

struct rt6_statistics {
	__u32 fib_nodes;
	__u32 fib_route_nodes;
	__u32 fib_rt_entries;
	__u32 fib_rt_cache;
	__u32 fib_discarded_routes;
	atomic_t fib_rt_alloc;
};

struct rt_cache_stat {
	unsigned int in_slow_tot;
	unsigned int in_slow_mc;
	unsigned int in_no_route;
	unsigned int in_brd;
	unsigned int in_martian_dst;
	unsigned int in_martian_src;
	unsigned int out_slow_tot;
	unsigned int out_slow_mc;
};

struct rt_waiter_node {
	struct rb_node entry;
	int prio;
	u64 deadline;
};

struct rt_mutex_waiter {
	struct rt_waiter_node tree;
	struct rt_waiter_node pi_tree;
	struct task_struct *task;
	struct rt_mutex_base *lock;
	unsigned int wake_state;
	struct ww_acquire_ctx *ww_ctx;
};

typedef struct rt_rq *rt_rq_iter_t;

struct sigaltstack {
	void *ss_sp;
	int ss_flags;
	__kernel_size_t ss_size;
};

typedef struct sigaltstack stack_t;

struct sigcontext_64 {
	__u64 r8;
	__u64 r9;
	__u64 r10;
	__u64 r11;
	__u64 r12;
	__u64 r13;
	__u64 r14;
	__u64 r15;
	__u64 di;
	__u64 si;
	__u64 bp;
	__u64 bx;
	__u64 dx;
	__u64 ax;
	__u64 cx;
	__u64 sp;
	__u64 ip;
	__u64 flags;
	__u16 cs;
	__u16 gs;
	__u16 fs;
	__u16 ss;
	__u64 err;
	__u64 trapno;
	__u64 oldmask;
	__u64 cr2;
	__u64 fpstate;
	__u64 reserved1[8];
};

struct ucontext {
	long unsigned int uc_flags;
	struct ucontext *uc_link;
	stack_t uc_stack;
	struct sigcontext_64 uc_mcontext;
	sigset_t uc_sigmask;
};

struct rt_sigframe {
	char *pretcode;
	struct ucontext uc;
	struct siginfo info;
};

struct wake_q_node;

struct wake_q_head {
	struct wake_q_node *first;
	struct wake_q_node **lastp;
};

struct rt_wake_q_head {
	struct wake_q_head head;
	struct task_struct *rtlock_task;
};

struct rta_cacheinfo {
	__u32 rta_clntref;
	__u32 rta_lastuse;
	__s32 rta_expires;
	__u32 rta_error;
	__u32 rta_used;
	__u32 rta_id;
	__u32 rta_ts;
	__u32 rta_tsage;
};

struct rta_mfc_stats {
	__u64 mfcs_packets;
	__u64 mfcs_bytes;
	__u64 mfcs_wrong_if;
};

struct rtc_param;

struct rtc_class_ops {
	int (*ioctl)(struct device *, unsigned int, long unsigned int);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*alarm_irq_enable)(struct device *, unsigned int);
	int (*read_offset)(struct device *, long int *);
	int (*set_offset)(struct device *, long int);
	int (*param_get)(struct device *, struct rtc_param *);
	int (*param_set)(struct device *, struct rtc_param *);
};

struct rtc_timer {
	struct timerqueue_node node;
	ktime_t period;
	void (*func)(struct rtc_device *);
	struct rtc_device *rtc;
	int enabled;
};

struct rtc_device {
	struct device dev;
	struct module *owner;
	int id;
	const struct rtc_class_ops *ops;
	struct mutex ops_lock;
	struct cdev char_dev;
	long unsigned int flags;
	long unsigned int irq_data;
	spinlock_t irq_lock;
	wait_queue_head_t irq_queue;
	struct fasync_struct *async_queue;
	int irq_freq;
	int max_user_freq;
	struct timerqueue_head timerqueue;
	struct rtc_timer aie_timer;
	struct rtc_timer uie_rtctimer;
	struct hrtimer pie_timer;
	int pie_enabled;
	struct work_struct irqwork;
	long unsigned int set_offset_nsec;
	long unsigned int features[1];
	time64_t range_min;
	timeu64_t range_max;
	timeu64_t alarm_offset_max;
	time64_t start_secs;
	time64_t offset_secs;
	bool set_start_time;
};

struct rtc_param {
	__u64 param;
	union {
		__u64 uvalue;
		__s64 svalue;
		__u64 ptr;
	};
	__u32 index;
	__u32 __pad;
};

struct rtentry {
	long unsigned int rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	long unsigned int rt_pad3;
	void *rt_pad4;
	short int rt_metric;
	char *rt_dev;
	long unsigned int rt_mtu;
	long unsigned int rt_window;
	short unsigned int rt_irtt;
};

struct rtgenmsg {
	unsigned char rtgen_family;
};

struct rtm_dump_res_bucket_ctx;

struct rtm_dump_nexthop_bucket_data {
	struct rtm_dump_res_bucket_ctx *ctx;
	struct nh_dump_filter filter;
};

struct rtm_dump_nh_ctx {
	u32 idx;
};

struct rtm_dump_res_bucket_ctx {
	struct rtm_dump_nh_ctx nh;
	u16 bucket_index;
};

struct rtmsg {
	unsigned char rtm_family;
	unsigned char rtm_dst_len;
	unsigned char rtm_src_len;
	unsigned char rtm_tos;
	unsigned char rtm_table;
	unsigned char rtm_protocol;
	unsigned char rtm_scope;
	unsigned char rtm_type;
	unsigned int rtm_flags;
};

struct rtnexthop {
	short unsigned int rtnh_len;
	unsigned char rtnh_flags;
	unsigned char rtnh_hops;
	int rtnh_ifindex;
};

struct rtnl_af_ops {
	struct list_head list;
	struct srcu_struct srcu;
	int family;
	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
	size_t (*get_link_af_size)(const struct net_device *, u32);
	int (*validate_link_af)(const struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*set_link_af)(struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
	size_t (*get_stats_af_size)(const struct net_device *);
};

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);

typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

struct rtnl_link {
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	struct module *owner;
	unsigned int flags;
	struct callback_head rcu;
};

struct rtnl_link_ifmap {
	__u64 mem_start;
	__u64 mem_end;
	__u64 base_addr;
	__u16 irq;
	__u8 dma;
	__u8 port;
};

struct rtnl_link_ops {
	struct list_head list;
	struct srcu_struct srcu;
	const char *kind;
	size_t priv_size;
	struct net_device * (*alloc)(struct nlattr **, const char *, unsigned char, unsigned int, unsigned int);
	void (*setup)(struct net_device *);
	bool netns_refund;
	const u16 peer_type;
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device *, struct list_head *);
	size_t (*get_size)(const struct net_device *);
	int (*fill_info)(struct sk_buff *, const struct net_device *);
	size_t (*get_xstats_size)(const struct net_device *);
	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
	unsigned int (*get_num_tx_queues)(void);
	unsigned int (*get_num_rx_queues)(void);
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
	struct net * (*get_link_net)(const struct net_device *);
	size_t (*get_linkxstats_size)(const struct net_device *, int);
	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
};

struct rtnl_link_stats {
	__u32 rx_packets;
	__u32 tx_packets;
	__u32 rx_bytes;
	__u32 tx_bytes;
	__u32 rx_errors;
	__u32 tx_errors;
	__u32 rx_dropped;
	__u32 tx_dropped;
	__u32 multicast;
	__u32 collisions;
	__u32 rx_length_errors;
	__u32 rx_over_errors;
	__u32 rx_crc_errors;
	__u32 rx_frame_errors;
	__u32 rx_fifo_errors;
	__u32 rx_missed_errors;
	__u32 tx_aborted_errors;
	__u32 tx_carrier_errors;
	__u32 tx_fifo_errors;
	__u32 tx_heartbeat_errors;
	__u32 tx_window_errors;
	__u32 rx_compressed;
	__u32 tx_compressed;
	__u32 rx_nohandler;
};

struct rtnl_mdb_dump_ctx {
	long int idx;
};

struct rtnl_msg_handler {
	struct module *owner;
	int protocol;
	int msgtype;
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	int flags;
};

struct rtnl_net_dump_cb {
	struct net *tgt_net;
	struct net *ref_net;
	struct sk_buff *skb;
	struct net_fill_args fillargs;
	int idx;
	int s_idx;
};

struct rtnl_nets {
	struct net *net[3];
	unsigned char len;
};

struct rtnl_newlink_tbs {
	struct nlattr *tb[67];
	struct nlattr *linkinfo[6];
	struct nlattr *attr[51];
	struct nlattr *slave_attr[45];
};

struct rtnl_offload_xstats_request_used {
	bool request;
	bool used;
};

struct rtnl_stats_dump_filters {
	u32 mask[6];
};

struct rtree_node {
	struct list_head list;
	long unsigned int *data;
};

struct rtvia {
	__kernel_sa_family_t rtvia_family;
	__u8 rtvia_addr[0];
};

struct rusage {
	struct __kernel_old_timeval ru_utime;
	struct __kernel_old_timeval ru_stime;
	__kernel_long_t ru_maxrss;
	__kernel_long_t ru_ixrss;
	__kernel_long_t ru_idrss;
	__kernel_long_t ru_isrss;
	__kernel_long_t ru_minflt;
	__kernel_long_t ru_majflt;
	__kernel_long_t ru_nswap;
	__kernel_long_t ru_inblock;
	__kernel_long_t ru_oublock;
	__kernel_long_t ru_msgsnd;
	__kernel_long_t ru_msgrcv;
	__kernel_long_t ru_nsignals;
	__kernel_long_t ru_nvcsw;
	__kernel_long_t ru_nivcsw;
};

typedef struct rw_semaphore *class_rwsem_read_t;

typedef struct rw_semaphore *class_rwsem_write_t;

struct rwsem_waiter {
	struct list_head list;
	struct task_struct *task;
	enum rwsem_waiter_type type;
	long unsigned int timeout;
	bool handoff_set;
};

struct rx_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_rx_queue *, char *);
	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
};

struct s_data {
	struct sched_domain **sd;
	struct root_domain *rd;
};

struct value_name_pair;

struct sa_name_list {
	int opcode;
	const struct value_name_pair *arr;
	int arr_sz;
};

struct sa_path_rec_ib {
	__be16 dlid;
	__be16 slid;
	u8 raw_traffic;
};

struct sa_path_rec_roce {
	bool route_resolved;
	u8 dmac[6];
};

struct sa_path_rec_opa {
	__be32 dlid;
	__be32 slid;
	u8 raw_traffic;
	u8 l2_8B;
	u8 l2_10B;
	u8 l2_9B;
	u8 l2_16B;
	u8 qos_type;
	u8 qos_priority;
};

struct sa_path_rec {
	union ib_gid dgid;
	union ib_gid sgid;
	__be64 service_id;
	__be32 flow_label;
	u8 hop_limit;
	u8 traffic_class;
	u8 reversible;
	u8 numb_path;
	__be16 pkey;
	__be16 qos_class;
	u8 sl;
	u8 mtu_selector;
	u8 mtu;
	u8 rate_selector;
	u8 rate;
	u8 packet_life_time_selector;
	u8 packet_life_time;
	u8 preference;
	union {
		struct sa_path_rec_ib ib;
		struct sa_path_rec_roce roce;
		struct sa_path_rec_opa opa;
	};
	enum sa_path_rec_type rec_type;
	u32 flags;
};

struct sadb_address {
	__u16 sadb_address_len;
	__u16 sadb_address_exttype;
	__u8 sadb_address_proto;
	__u8 sadb_address_prefixlen;
	__u16 sadb_address_reserved;
};

struct sadb_alg {
	__u8 sadb_alg_id;
	__u8 sadb_alg_ivlen;
	__u16 sadb_alg_minbits;
	__u16 sadb_alg_maxbits;
	__u16 sadb_alg_reserved;
};

struct sadb_comb {
	__u8 sadb_comb_auth;
	__u8 sadb_comb_encrypt;
	__u16 sadb_comb_flags;
	__u16 sadb_comb_auth_minbits;
	__u16 sadb_comb_auth_maxbits;
	__u16 sadb_comb_encrypt_minbits;
	__u16 sadb_comb_encrypt_maxbits;
	__u32 sadb_comb_reserved;
	__u32 sadb_comb_soft_allocations;
	__u32 sadb_comb_hard_allocations;
	__u64 sadb_comb_soft_bytes;
	__u64 sadb_comb_hard_bytes;
	__u64 sadb_comb_soft_addtime;
	__u64 sadb_comb_hard_addtime;
	__u64 sadb_comb_soft_usetime;
	__u64 sadb_comb_hard_usetime;
};

struct sadb_ext {
	__u16 sadb_ext_len;
	__u16 sadb_ext_type;
};

struct sadb_key {
	__u16 sadb_key_len;
	__u16 sadb_key_exttype;
	__u16 sadb_key_bits;
	__u16 sadb_key_reserved;
};

struct sadb_lifetime {
	__u16 sadb_lifetime_len;
	__u16 sadb_lifetime_exttype;
	__u32 sadb_lifetime_allocations;
	__u64 sadb_lifetime_bytes;
	__u64 sadb_lifetime_addtime;
	__u64 sadb_lifetime_usetime;
};

struct sadb_msg {
	__u8 sadb_msg_version;
	__u8 sadb_msg_type;
	__u8 sadb_msg_errno;
	__u8 sadb_msg_satype;
	__u16 sadb_msg_len;
	__u16 sadb_msg_reserved;
	__u32 sadb_msg_seq;
	__u32 sadb_msg_pid;
};

struct sadb_prop {
	__u16 sadb_prop_len;
	__u16 sadb_prop_exttype;
	__u8 sadb_prop_replay;
	__u8 sadb_prop_reserved[3];
};

struct sadb_sa {
	__u16 sadb_sa_len;
	__u16 sadb_sa_exttype;
	__be32 sadb_sa_spi;
	__u8 sadb_sa_replay;
	__u8 sadb_sa_state;
	__u8 sadb_sa_auth;
	__u8 sadb_sa_encrypt;
	__u32 sadb_sa_flags;
};

struct sadb_spirange {
	__u16 sadb_spirange_len;
	__u16 sadb_spirange_exttype;
	__u32 sadb_spirange_min;
	__u32 sadb_spirange_max;
	__u32 sadb_spirange_reserved;
};

struct sadb_supported {
	__u16 sadb_supported_len;
	__u16 sadb_supported_exttype;
	__u32 sadb_supported_reserved;
};

struct sadb_x_filter {
	__u16 sadb_x_filter_len;
	__u16 sadb_x_filter_exttype;
	__u32 sadb_x_filter_saddr[4];
	__u32 sadb_x_filter_daddr[4];
	__u16 sadb_x_filter_family;
	__u8 sadb_x_filter_splen;
	__u8 sadb_x_filter_dplen;
};

struct sadb_x_ipsecrequest {
	__u16 sadb_x_ipsecrequest_len;
	__u16 sadb_x_ipsecrequest_proto;
	__u8 sadb_x_ipsecrequest_mode;
	__u8 sadb_x_ipsecrequest_level;
	__u16 sadb_x_ipsecrequest_reserved1;
	__u32 sadb_x_ipsecrequest_reqid;
	__u32 sadb_x_ipsecrequest_reserved2;
};

struct sadb_x_kmaddress {
	__u16 sadb_x_kmaddress_len;
	__u16 sadb_x_kmaddress_exttype;
	__u32 sadb_x_kmaddress_reserved;
};

struct sadb_x_nat_t_port {
	__u16 sadb_x_nat_t_port_len;
	__u16 sadb_x_nat_t_port_exttype;
	__be16 sadb_x_nat_t_port_port;
	__u16 sadb_x_nat_t_port_reserved;
};

struct sadb_x_nat_t_type {
	__u16 sadb_x_nat_t_type_len;
	__u16 sadb_x_nat_t_type_exttype;
	__u8 sadb_x_nat_t_type_type;
	__u8 sadb_x_nat_t_type_reserved[3];
};

struct sadb_x_policy {
	__u16 sadb_x_policy_len;
	__u16 sadb_x_policy_exttype;
	__u16 sadb_x_policy_type;
	__u8 sadb_x_policy_dir;
	__u8 sadb_x_policy_reserved;
	__u32 sadb_x_policy_id;
	__u32 sadb_x_policy_priority;
};

struct sadb_x_sa2 {
	__u16 sadb_x_sa2_len;
	__u16 sadb_x_sa2_exttype;
	__u8 sadb_x_sa2_mode;
	__u8 sadb_x_sa2_reserved1;
	__u16 sadb_x_sa2_reserved2;
	__u32 sadb_x_sa2_sequence;
	__u32 sadb_x_sa2_reqid;
};

struct sadb_x_sec_ctx {
	__u16 sadb_x_sec_len;
	__u16 sadb_x_sec_exttype;
	__u8 sadb_x_ctx_alg;
	__u8 sadb_x_ctx_doi;
	__u16 sadb_x_ctx_len;
};

struct sample_arg {
	bool exec;
	u32 probability;
};

struct sane_reply_net_start {
	__be32 status;
	__be16 zero;
	__be16 port;
};

struct sane_request {
	__be32 RPC_code;
	__be32 handle;
};

struct saved_alias {
	struct kmem_cache *s;
	const char *name;
	struct saved_alias *next;
};

struct saved_cmdlines_buffer {
	unsigned int map_pid_to_cmdline[32769];
	unsigned int *map_cmdline_to_pid;
	unsigned int cmdline_num;
	int cmdline_idx;
	char saved_cmdlines[0];
};

struct saved_msr;

struct saved_msrs {
	unsigned int num;
	struct saved_msr *array;
};

struct saved_context {
	struct pt_regs regs;
	u16 ds;
	u16 es;
	u16 fs;
	u16 gs;
	long unsigned int kernelmode_gs_base;
	long unsigned int usermode_gs_base;
	long unsigned int fs_base;
	long unsigned int cr0;
	long unsigned int cr2;
	long unsigned int cr3;
	long unsigned int cr4;
	u64 misc_enable;
	struct saved_msrs saved_msrs;
	long unsigned int efer;
	u16 gdt_pad;
	struct desc_ptr gdt_desc;
	u16 idt_pad;
	struct desc_ptr idt;
	u16 ldt;
	u16 tss;
	long unsigned int tr;
	long unsigned int safety;
	long unsigned int return_address;
	bool misc_enable_saved;
} __attribute__((packed));

struct saved_msr {
	bool valid;
	struct msr_info info;
};

struct saved_syn {
	u32 mac_hdrlen;
	u32 network_hdrlen;
	u32 tcp_hdrlen;
	u8 data[0];
};

struct sb_writers {
	short unsigned int frozen;
	int freeze_kcount;
	int freeze_ucount;
	struct percpu_rw_semaphore rw_sem[3];
};

struct sbitmap_word {
	long unsigned int word;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int cleared;
	raw_spinlock_t swap_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbq_wait_state {
	wait_queue_head_t wait;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct scan_area {
	u64 addr;
	u64 size;
};

struct scan_control {
	long unsigned int nr_to_reclaim;
	nodemask_t *nodemask;
	struct mem_cgroup *target_mem_cgroup;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	int *proactive_swappiness;
	unsigned int may_deactivate: 2;
	unsigned int force_deactivate: 1;
	unsigned int skipped_deactivate: 1;
	unsigned int may_writepage: 1;
	unsigned int may_unmap: 1;
	unsigned int may_swap: 1;
	unsigned int no_cache_trim_mode: 1;
	unsigned int cache_trim_mode_failed: 1;
	unsigned int proactive: 1;
	unsigned int memcg_low_reclaim: 1;
	unsigned int memcg_low_skipped: 1;
	unsigned int memcg_full_walk: 1;
	unsigned int hibernation_mode: 1;
	unsigned int compaction_ready: 1;
	unsigned int cache_trim_mode: 1;
	unsigned int file_is_tiny: 1;
	unsigned int no_demotion: 1;
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};

struct scatter_walk {
	struct scatterlist *sg;
	unsigned int offset;
};

struct sch_frag_data {
	long unsigned int dst;
	struct qdisc_skb_cb cb;
	__be16 inner_protocol;
	u16 vlan_tci;
	__be16 vlan_proto;
	unsigned int l2_len;
	u8 l2_data[18];
	int (*xmit)(struct sk_buff *);
};

struct sched_attr {
	__u32 size;
	__u32 sched_policy;
	__u64 sched_flags;
	__s32 sched_nice;
	__u32 sched_priority;
	__u64 sched_runtime;
	__u64 sched_deadline;
	__u64 sched_period;
	__u32 sched_util_min;
	__u32 sched_util_max;
};

struct sched_cache {
	struct list_head *priolist;
};

struct sched_class {
	void (*enqueue_task)(struct rq *, struct task_struct *, int);
	bool (*dequeue_task)(struct rq *, struct task_struct *, int);
	void (*yield_task)(struct rq *);
	bool (*yield_to_task)(struct rq *, struct task_struct *);
	void (*wakeup_preempt)(struct rq *, struct task_struct *, int);
	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
	struct task_struct * (*pick_task)(struct rq *);
	struct task_struct * (*pick_next_task)(struct rq *, struct task_struct *);
	void (*put_prev_task)(struct rq *, struct task_struct *, struct task_struct *);
	void (*set_next_task)(struct rq *, struct task_struct *, bool);
	int (*select_task_rq)(struct task_struct *, int, int);
	void (*migrate_task_rq)(struct task_struct *, int);
	void (*task_woken)(struct rq *, struct task_struct *);
	void (*set_cpus_allowed)(struct task_struct *, struct affinity_context *);
	void (*rq_online)(struct rq *);
	void (*rq_offline)(struct rq *);
	struct rq * (*find_lock_rq)(struct task_struct *, struct rq *);
	void (*task_tick)(struct rq *, struct task_struct *, int);
	void (*task_fork)(struct task_struct *);
	void (*task_dead)(struct task_struct *);
	void (*switching_to)(struct rq *, struct task_struct *);
	void (*switched_from)(struct rq *, struct task_struct *);
	void (*switched_to)(struct rq *, struct task_struct *);
	void (*reweight_task)(struct rq *, struct task_struct *, const struct load_weight *);
	void (*prio_changed)(struct rq *, struct task_struct *, int);
	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
	void (*update_curr)(struct rq *);
	void (*task_change_group)(struct task_struct *);
};

struct sched_clock_data {
	u64 tick_raw;
	u64 tick_gtod;
	u64 clock;
};

struct sched_group;

struct sched_domain_shared;

struct sched_domain {
	struct sched_domain *parent;
	struct sched_domain *child;
	struct sched_group *groups;
	long unsigned int min_interval;
	long unsigned int max_interval;
	unsigned int busy_factor;
	unsigned int imbalance_pct;
	unsigned int cache_nice_tries;
	unsigned int imb_numa_nr;
	int nohz_idle;
	int flags;
	int level;
	long unsigned int last_balance;
	unsigned int balance_interval;
	unsigned int nr_balance_failed;
	u64 max_newidle_lb_cost;
	long unsigned int last_decay_max_lb_cost;
	unsigned int lb_count[3];
	unsigned int lb_failed[3];
	unsigned int lb_balanced[3];
	unsigned int lb_imbalance_load[3];
	unsigned int lb_imbalance_util[3];
	unsigned int lb_imbalance_task[3];
	unsigned int lb_imbalance_misfit[3];
	unsigned int lb_gained[3];
	unsigned int lb_hot_gained[3];
	unsigned int lb_nobusyg[3];
	unsigned int lb_nobusyq[3];
	unsigned int alb_count;
	unsigned int alb_failed;
	unsigned int alb_pushed;
	unsigned int sbe_count;
	unsigned int sbe_balanced;
	unsigned int sbe_pushed;
	unsigned int sbf_count;
	unsigned int sbf_balanced;
	unsigned int sbf_pushed;
	unsigned int ttwu_wake_remote;
	unsigned int ttwu_move_affine;
	unsigned int ttwu_move_balance;
	char *name;
	union {
		void *private;
		struct callback_head rcu;
	};
	struct sched_domain_shared *shared;
	unsigned int span_weight;
	long unsigned int span[0];
};

struct sched_domain_attr {
	int relax_domain_level;
};

struct sched_domain_shared {
	atomic_t ref;
	atomic_t nr_busy_cpus;
	int has_idle_cores;
	int nr_idle_scan;
};

typedef const struct cpumask * (*sched_domain_mask_f)(int);

typedef int (*sched_domain_flags_f)(void);

struct sched_group_capacity;

struct sd_data {
	struct sched_domain **sd;
	struct sched_domain_shared **sds;
	struct sched_group **sg;
	struct sched_group_capacity **sgc;
};

struct sched_domain_topology_level {
	sched_domain_mask_f mask;
	sched_domain_flags_f sd_flags;
	int flags;
	int numa_level;
	struct sd_data data;
	char *name;
};

struct sched_entity {
	struct load_weight load;
	struct rb_node run_node;
	u64 deadline;
	u64 min_vruntime;
	u64 min_slice;
	struct list_head group_node;
	unsigned char on_rq;
	unsigned char sched_delayed;
	unsigned char rel_deadline;
	unsigned char custom_slice;
	u64 exec_start;
	u64 sum_exec_runtime;
	u64 prev_sum_exec_runtime;
	u64 vruntime;
	s64 vlag;
	u64 slice;
	u64 nr_migrations;
	int depth;
	struct sched_entity *parent;
	struct cfs_rq *cfs_rq;
	struct cfs_rq *my_q;
	long unsigned int runnable_weight;
	long: 64;
	struct sched_avg avg;
};

struct sched_statistics {
	u64 wait_start;
	u64 wait_max;
	u64 wait_count;
	u64 wait_sum;
	u64 iowait_count;
	u64 iowait_sum;
	u64 sleep_start;
	u64 sleep_max;
	s64 sum_sleep_runtime;
	u64 block_start;
	u64 block_max;
	s64 sum_block_runtime;
	s64 exec_max;
	u64 slice_max;
	u64 nr_migrations_cold;
	u64 nr_failed_migrations_affine;
	u64 nr_failed_migrations_running;
	u64 nr_failed_migrations_hot;
	u64 nr_forced_migrations;
	u64 nr_wakeups;
	u64 nr_wakeups_sync;
	u64 nr_wakeups_migrate;
	u64 nr_wakeups_local;
	u64 nr_wakeups_remote;
	u64 nr_wakeups_affine;
	u64 nr_wakeups_affine_attempts;
	u64 nr_wakeups_passive;
	u64 nr_wakeups_idle;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sched_entity_stats {
	struct sched_entity se;
	struct sched_statistics stats;
};

struct sched_entry {
	u64 gate_duration[16];
	atomic_t budget[16];
	ktime_t gate_close_time[16];
	struct list_head list;
	ktime_t end_time;
	ktime_t next_txtime;
	int index;
	u32 gate_mask;
	u32 interval;
	u8 command;
};

struct sched_gate_list {
	u64 max_open_gate_duration[16];
	u32 max_frm_len[16];
	u32 max_sdu[16];
	struct callback_head rcu;
	struct list_head entries;
	size_t num_entries;
	ktime_t cycle_end_time;
	s64 cycle_time;
	s64 cycle_time_extension;
	s64 base_time;
};

struct sched_group {
	struct sched_group *next;
	atomic_t ref;
	unsigned int group_weight;
	unsigned int cores;
	struct sched_group_capacity *sgc;
	int asym_prefer_cpu;
	int flags;
	long unsigned int cpumask[0];
};

struct sched_group_capacity {
	atomic_t ref;
	long unsigned int capacity;
	long unsigned int min_capacity;
	long unsigned int max_capacity;
	long unsigned int next_update;
	int imbalance;
	int id;
	long unsigned int cpumask[0];
};

struct sched_param {
	int sched_priority;
};

struct sched_rt_entity {
	struct list_head run_list;
	long unsigned int timeout;
	long unsigned int watchdog_stamp;
	unsigned int time_slice;
	short unsigned int on_rq;
	short unsigned int on_list;
	struct sched_rt_entity *back;
};

struct scheduling_policy {
	u32 max_words;
	u32 num_words;
	u32 count;
	struct guc_update_scheduling_policy h2g;
};

struct scm_fp_list;

struct scm_cookie {
	struct pid *pid;
	struct scm_fp_list *fp;
	struct scm_creds creds;
	u32 secid;
};

struct unix_edge;

struct scm_fp_list {
	short int count;
	short int count_unix;
	short int max;
	bool inflight;
	bool dead;
	struct list_head vertices;
	struct unix_edge *edges;
	struct user_struct *user;
	struct file *fp[253];
};

struct scm_stat {
	atomic_t nr_fds;
	long unsigned int nr_unix_fds;
};

struct scm_timestamping {
	struct __kernel_old_timespec ts[3];
};

struct scm_timestamping64 {
	struct __kernel_timespec ts[3];
};

struct scm_timestamping_internal {
	struct timespec64 ts[3];
};

struct scm_ts_pktinfo {
	__u32 if_index;
	__u32 pkt_length;
	__u32 reserved[2];
};

struct scomp_alg {
	void * (*alloc_ctx)(struct crypto_scomp *);
	void (*free_ctx)(struct crypto_scomp *, void *);
	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	union {
		struct {
			struct crypto_alg base;
		};
		struct comp_alg_common calg;
	};
};

struct scomp_scratch {
	spinlock_t lock;
	void *src;
	void *dst;
};

struct scratches_to_free {
	struct callback_head rcu;
	unsigned int cnt;
	void *scratches[0];
};

struct scrub_sector_verification;

struct scrub_stripe {
	struct scrub_ctx *sctx;
	struct btrfs_block_group *bg;
	struct page *pages[16];
	struct scrub_sector_verification *sectors;
	struct btrfs_device *dev;
	u64 logical;
	u64 physical;
	u16 mirror_num;
	u16 nr_sectors;
	u16 nr_data_extents;
	u16 nr_meta_extents;
	atomic_t pending_io;
	wait_queue_head_t io_wait;
	wait_queue_head_t repair_wait;
	long unsigned int state;
	long unsigned int extent_sector_bitmap;
	long unsigned int init_error_bitmap;
	unsigned int init_nr_io_errors;
	unsigned int init_nr_csum_errors;
	unsigned int init_nr_meta_errors;
	long unsigned int error_bitmap;
	long unsigned int io_error_bitmap;
	long unsigned int csum_error_bitmap;
	long unsigned int meta_error_bitmap;
	long unsigned int write_error_bitmap;
	spinlock_t write_error_lock;
	u8 *csums;
	struct work_struct work;
};

struct scrub_ctx {
	struct scrub_stripe stripes[128];
	struct scrub_stripe *raid56_data_stripes;
	struct btrfs_fs_info *fs_info;
	struct btrfs_path extent_path;
	struct btrfs_path csum_path;
	int first_free;
	int cur_stripe;
	atomic_t cancel_req;
	int readonly;
	ktime_t throttle_deadline;
	u64 throttle_sent;
	int is_dev_replace;
	u64 write_pointer;
	struct mutex wr_lock;
	struct btrfs_device *wr_tgtdev;
	struct btrfs_scrub_progress stat;
	spinlock_t stat_lock;
	refcount_t refs;
};

struct scrub_sector_verification {
	bool is_metadata;
	union {
		u8 *csum;
		u64 generation;
	};
};

struct scrub_warning {
	struct btrfs_path *path;
	u64 extent_item_size;
	const char *errstr;
	u64 physical;
	u64 logical;
	struct btrfs_device *dev;
};

struct scsi_data_buffer {
	struct sg_table table;
	unsigned int length;
};

struct scsi_device;

struct scsi_cmnd {
	struct scsi_device *device;
	struct list_head eh_entry;
	struct delayed_work abort_work;
	struct callback_head rcu;
	int eh_eflags;
	int budget_token;
	long unsigned int jiffies_at_alloc;
	int retries;
	int allowed;
	unsigned char prot_op;
	unsigned char prot_type;
	unsigned char prot_flags;
	enum scsi_cmnd_submitter submitter;
	short unsigned int cmd_len;
	enum dma_data_direction sc_data_direction;
	unsigned char cmnd[32];
	struct scsi_data_buffer sdb;
	struct scsi_data_buffer *prot_sdb;
	unsigned int underflow;
	unsigned int transfersize;
	unsigned int resid_len;
	unsigned int sense_len;
	unsigned char *sense_buffer;
	int flags;
	long unsigned int state;
	unsigned int extra_len;
	unsigned char *host_scribble;
	int result;
};

struct scsi_dev_info_list {
	struct list_head dev_info_list;
	char vendor[8];
	char model[16];
	blist_flags_t flags;
	unsigned int compatible;
};

struct scsi_dev_info_list_table {
	struct list_head node;
	struct list_head scsi_dev_info_list;
	const char *name;
	int key;
};

struct scsi_vpd;

struct scsi_target;

struct scsi_device_handler;

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;
	struct list_head siblings;
	struct list_head same_target_siblings;
	struct sbitmap budget_map;
	atomic_t device_blocked;
	atomic_t restarts;
	spinlock_t list_lock;
	struct list_head starved_entry;
	short unsigned int queue_depth;
	short unsigned int max_queue_depth;
	short unsigned int last_queue_full_depth;
	short unsigned int last_queue_full_count;
	long unsigned int last_queue_full_time;
	long unsigned int queue_ramp_up_period;
	long unsigned int last_queue_ramp_up;
	unsigned int id;
	unsigned int channel;
	u64 lun;
	unsigned int manufacturer;
	unsigned int sector_size;
	void *hostdata;
	unsigned char type;
	char scsi_level;
	char inq_periph_qual;
	struct mutex inquiry_mutex;
	unsigned char inquiry_len;
	unsigned char *inquiry;
	const char *vendor;
	const char *model;
	const char *rev;
	struct scsi_vpd *vpd_pg0;
	struct scsi_vpd *vpd_pg83;
	struct scsi_vpd *vpd_pg80;
	struct scsi_vpd *vpd_pg89;
	struct scsi_vpd *vpd_pgb0;
	struct scsi_vpd *vpd_pgb1;
	struct scsi_vpd *vpd_pgb2;
	struct scsi_vpd *vpd_pgb7;
	struct scsi_target *sdev_target;
	blist_flags_t sdev_bflags;
	unsigned int eh_timeout;
	unsigned int manage_system_start_stop: 1;
	unsigned int manage_runtime_start_stop: 1;
	unsigned int manage_shutdown: 1;
	unsigned int force_runtime_start_on_system_start: 1;
	unsigned int removable: 1;
	unsigned int changed: 1;
	unsigned int busy: 1;
	unsigned int lockable: 1;
	unsigned int locked: 1;
	unsigned int borken: 1;
	unsigned int disconnect: 1;
	unsigned int soft_reset: 1;
	unsigned int sdtr: 1;
	unsigned int wdtr: 1;
	unsigned int ppr: 1;
	unsigned int tagged_supported: 1;
	unsigned int simple_tags: 1;
	unsigned int was_reset: 1;
	unsigned int expecting_cc_ua: 1;
	unsigned int use_10_for_rw: 1;
	unsigned int use_10_for_ms: 1;
	unsigned int set_dbd_for_ms: 1;
	unsigned int read_before_ms: 1;
	unsigned int no_report_opcodes: 1;
	unsigned int no_write_same: 1;
	unsigned int use_16_for_rw: 1;
	unsigned int use_16_for_sync: 1;
	unsigned int skip_ms_page_8: 1;
	unsigned int skip_ms_page_3f: 1;
	unsigned int skip_vpd_pages: 1;
	unsigned int try_vpd_pages: 1;
	unsigned int use_192_bytes_for_3f: 1;
	unsigned int no_start_on_add: 1;
	unsigned int allow_restart: 1;
	unsigned int start_stop_pwr_cond: 1;
	unsigned int no_uld_attach: 1;
	unsigned int select_no_atn: 1;
	unsigned int fix_capacity: 1;
	unsigned int guess_capacity: 1;
	unsigned int retry_hwerror: 1;
	unsigned int last_sector_bug: 1;
	unsigned int no_read_disc_info: 1;
	unsigned int no_read_capacity_16: 1;
	unsigned int try_rc_10_first: 1;
	unsigned int security_supported: 1;
	unsigned int is_visible: 1;
	unsigned int wce_default_on: 1;
	unsigned int no_dif: 1;
	unsigned int broken_fua: 1;
	unsigned int lun_in_cdb: 1;
	unsigned int unmap_limit_for_ws: 1;
	unsigned int rpm_autosuspend: 1;
	unsigned int ignore_media_change: 1;
	unsigned int silence_suspend: 1;
	unsigned int no_vpd_size: 1;
	unsigned int cdl_supported: 1;
	unsigned int cdl_enable: 1;
	unsigned int queue_stopped;
	bool offline_already;
	atomic_t disk_events_disable_depth;
	long unsigned int supported_events[1];
	long unsigned int pending_events[1];
	struct list_head event_list;
	struct work_struct event_work;
	unsigned int max_device_blocked;
	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;
	atomic_t iotmo_cnt;
	struct device sdev_gendev;
	struct device sdev_dev;
	struct work_struct requeue_work;
	struct scsi_device_handler *handler;
	void *handler_data;
	size_t dma_drain_len;
	void *dma_drain_buf;
	unsigned int sg_timeout;
	unsigned int sg_reserved_size;
	struct bsg_device *bsg_dev;
	unsigned char access_state;
	struct mutex state_mutex;
	enum scsi_device_state sdev_state;
	struct task_struct *quiesced_by;
	long unsigned int sdev_data[0];
};

typedef void (*activate_complete)(void *, int);

struct scsi_device_handler {
	struct list_head list;
	struct module *module;
	const char *name;
	enum scsi_disposition (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	blk_status_t (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	void (*rescan)(struct scsi_device *);
};

struct scsi_disk {
	struct scsi_device *device;
	struct device disk_dev;
	struct gendisk *disk;
	struct opal_dev *opal_dev;
	atomic_t openers;
	sector_t capacity;
	int max_retries;
	u32 min_xfer_blocks;
	u32 max_xfer_blocks;
	u32 opt_xfer_blocks;
	u32 max_ws_blocks;
	u32 max_unmap_blocks;
	u32 unmap_granularity;
	u32 unmap_alignment;
	u32 max_atomic;
	u32 atomic_alignment;
	u32 atomic_granularity;
	u32 max_atomic_with_boundary;
	u32 max_atomic_boundary;
	u32 index;
	unsigned int physical_block_size;
	unsigned int max_medium_access_timeouts;
	unsigned int medium_access_timed_out;
	u16 permanent_stream_count;
	u8 media_present;
	u8 write_prot;
	u8 protection_type;
	u8 provisioning_mode;
	u8 zeroing_mode;
	u8 nr_actuators;
	bool suspended;
	unsigned int ATO: 1;
	unsigned int cache_override: 1;
	unsigned int WCE: 1;
	unsigned int RCD: 1;
	unsigned int DPOFUA: 1;
	unsigned int first_scan: 1;
	unsigned int lbpme: 1;
	unsigned int lbprz: 1;
	unsigned int lbpu: 1;
	unsigned int lbpws: 1;
	unsigned int lbpws10: 1;
	unsigned int lbpvpd: 1;
	unsigned int ws10: 1;
	unsigned int ws16: 1;
	unsigned int rc_basis: 2;
	unsigned int zoned: 2;
	unsigned int urswrz: 1;
	unsigned int security: 1;
	unsigned int ignore_medium_access_errors: 1;
	unsigned int rscs: 1;
	unsigned int use_atomic_write_boundary: 1;
};

struct scsi_driver {
	struct device_driver gendrv;
	int (*resume)(struct device *);
	void (*rescan)(struct device *);
	blk_status_t (*init_command)(struct scsi_cmnd *);
	void (*uninit_command)(struct scsi_cmnd *);
	int (*done)(struct scsi_cmnd *);
	int (*eh_action)(struct scsi_cmnd *, int);
	void (*eh_reset)(struct scsi_cmnd *);
};

struct scsi_eh_save {
	int result;
	unsigned int resid_len;
	int eh_eflags;
	enum dma_data_direction data_direction;
	unsigned int underflow;
	unsigned char cmd_len;
	unsigned char prot_op;
	unsigned char cmnd[32];
	struct scsi_data_buffer sdb;
	struct scatterlist sense_sgl;
};

struct scsi_event {
	enum scsi_device_event evt_type;
	struct list_head node;
};

struct scsi_failures;

struct scsi_exec_args {
	unsigned char *sense;
	unsigned int sense_len;
	struct scsi_sense_hdr *sshdr;
	blk_mq_req_flags_t req_flags;
	int scmd_flags;
	int *resid;
	struct scsi_failures *failures;
};

struct scsi_failure {
	int result;
	u8 sense;
	u8 asc;
	u8 ascq;
	s8 allowed;
	s8 retries;
};

struct scsi_failures {
	int total_allowed;
	int total_retries;
	struct scsi_failure *failure_definitions;
};

struct scsi_host_busy_iter_data {
	bool (*fn)(struct scsi_cmnd *, void *);
	void *priv;
};

struct scsi_host_template {
	unsigned int cmd_size;
	int (*queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
	void (*commit_rqs)(struct Scsi_Host *, u16);
	struct module *module;
	const char *name;
	const char * (*info)(struct Scsi_Host *);
	int (*ioctl)(struct scsi_device *, unsigned int, void *);
	int (*init_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*exit_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*eh_abort_handler)(struct scsi_cmnd *);
	int (*eh_device_reset_handler)(struct scsi_cmnd *);
	int (*eh_target_reset_handler)(struct scsi_cmnd *);
	int (*eh_bus_reset_handler)(struct scsi_cmnd *);
	int (*eh_host_reset_handler)(struct scsi_cmnd *);
	int (*sdev_init)(struct scsi_device *);
	int (*sdev_configure)(struct scsi_device *, struct queue_limits *);
	void (*sdev_destroy)(struct scsi_device *);
	int (*target_alloc)(struct scsi_target *);
	void (*target_destroy)(struct scsi_target *);
	int (*scan_finished)(struct Scsi_Host *, long unsigned int);
	void (*scan_start)(struct Scsi_Host *);
	int (*change_queue_depth)(struct scsi_device *, int);
	void (*map_queues)(struct Scsi_Host *);
	int (*mq_poll)(struct Scsi_Host *, unsigned int);
	bool (*dma_need_drain)(struct request *);
	int (*bios_param)(struct scsi_device *, struct block_device *, sector_t, int *);
	void (*unlock_native_capacity)(struct scsi_device *);
	int (*show_info)(struct seq_file *, struct Scsi_Host *);
	int (*write_info)(struct Scsi_Host *, char *, int);
	enum scsi_timeout_action (*eh_timed_out)(struct scsi_cmnd *);
	bool (*eh_should_retry_cmd)(struct scsi_cmnd *);
	int (*host_reset)(struct Scsi_Host *, int);
	const char *proc_name;
	int can_queue;
	int this_id;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	unsigned int dma_alignment;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	short int cmd_per_lun;
	bool tag_alloc_policy_rr: 1;
	unsigned int track_queue_depth: 1;
	unsigned int supported_mode: 2;
	unsigned int emulated: 1;
	unsigned int skip_settle_delay: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int queuecommand_may_block: 1;
	unsigned int max_host_blocked;
	const struct attribute_group **shost_groups;
	const struct attribute_group **sdev_groups;
	u64 vendor_id;
};

struct scsi_idlun {
	__u32 dev_id;
	__u32 host_unique_id;
};

struct scsi_io_group_descriptor {
	u8 ic_enable: 1;
	u8 cs_enble: 1;
	u8 st_enble: 1;
	u8 reserved1: 3;
	u8 io_advice_hints_mode: 2;
	u8 reserved2[3];
	u8 lbm_descriptor_type: 4;
	u8 rlbsr: 2;
	u8 reserved3: 1;
	u8 acdlu: 1;
	u8 params[2];
	u8 reserved4;
	u8 reserved5[8];
};

struct scsi_ioctl_command {
	unsigned int inlen;
	unsigned int outlen;
	unsigned char data[0];
};

struct scsi_lun {
	__u8 scsi_lun[8];
};

struct scsi_mode_data {
	__u32 length;
	__u16 block_descriptor_length;
	__u8 medium_type;
	__u8 device_specific;
	__u8 header_length;
	__u8 longlba: 1;
};

struct scsi_proc_entry {
	struct list_head entry;
	const struct scsi_host_template *sht;
	struct proc_dir_entry *proc_dir;
	unsigned int present;
};

struct scsi_sense_hdr {
	u8 response_code;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	u8 byte4;
	u8 byte5;
	u8 byte6;
	u8 additional_length;
};

struct scsi_stream_status {
	u8 reserved1: 7;
	u8 perm: 1;
	u8 reserved2;
	__be16 stream_identifier;
	u8 rel_lifetime: 6;
	u8 reserved3: 2;
	u8 reserved4[3];
};

struct scsi_stream_status_header {
	__be32 len;
	u16 reserved;
	__be16 number_of_open_streams;
	struct {
		struct {} __empty_stream_status;
		struct scsi_stream_status stream_status[0];
	};
};

struct scsi_target {
	struct scsi_device *starget_sdev_user;
	struct list_head siblings;
	struct list_head devices;
	struct device dev;
	struct kref reap_ref;
	unsigned int channel;
	unsigned int id;
	unsigned int create: 1;
	unsigned int single_lun: 1;
	unsigned int pdt_1f_for_no_lun: 1;
	unsigned int no_report_luns: 1;
	unsigned int expecting_lun_change: 1;
	atomic_t target_busy;
	atomic_t target_blocked;
	unsigned int can_queue;
	unsigned int max_target_blocked;
	char scsi_level;
	enum scsi_target_state state;
	void *hostdata;
	long unsigned int starget_data[0];
};

struct transport_container {
	struct attribute_container ac;
	const struct attribute_group *statistics;
};

struct scsi_transport_template {
	struct transport_container host_attrs;
	struct transport_container target_attrs;
	struct transport_container device_attrs;
	int (*user_scan)(struct Scsi_Host *, uint, uint, u64);
	int device_size;
	int device_private_offset;
	int target_size;
	int target_private_offset;
	int host_size;
	unsigned int create_work_queue: 1;
	void (*eh_strategy_handler)(struct Scsi_Host *);
};

struct scsi_varlen_cdb_hdr {
	__u8 opcode;
	__u8 control;
	__u8 misc[5];
	__u8 additional_cdb_length;
	__be16 service_action;
};

struct scsi_vpd {
	struct callback_head rcu;
	int len;
	unsigned char data[0];
};

struct sctp_rtoinfo {
	sctp_assoc_t srto_assoc_id;
	__u32 srto_initial;
	__u32 srto_max;
	__u32 srto_min;
};

struct sctp_paddrparams {
	sctp_assoc_t spp_assoc_id;
	struct __kernel_sockaddr_storage spp_address;
	__u32 spp_hbinterval;
	__u16 spp_pathmaxrxt;
	__u32 spp_pathmtu;
	__u32 spp_sackdelay;
	__u32 spp_flags;
	__u32 spp_ipv6_flowlabel;
	__u8 spp_dscp;
	int: 0;
} __attribute__((packed));

struct sctp_assocparams {
	sctp_assoc_t sasoc_assoc_id;
	__u16 sasoc_asocmaxrxt;
	__u16 sasoc_number_peer_destinations;
	__u32 sasoc_peer_rwnd;
	__u32 sasoc_local_rwnd;
	__u32 sasoc_cookie_life;
};

struct sctp_initmsg {
	__u16 sinit_num_ostreams;
	__u16 sinit_max_instreams;
	__u16 sinit_max_attempts;
	__u16 sinit_max_init_timeo;
};

struct sctp_pf;

struct sctp_endpoint;

struct sctp_bind_bucket;

struct sctp_sock {
	struct inet_sock inet;
	enum sctp_socket_type type;
	struct sctp_pf *pf;
	struct crypto_shash *hmac;
	char *sctp_hmac_alg;
	struct sctp_endpoint *ep;
	struct sctp_bind_bucket *bind_hash;
	__u16 default_stream;
	__u32 default_ppid;
	__u16 default_flags;
	__u32 default_context;
	__u32 default_timetolive;
	__u32 default_rcv_context;
	int max_burst;
	__u32 hbinterval;
	__u32 probe_interval;
	__be16 udp_port;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u32 pathmtu;
	__u32 sackdelay;
	__u32 sackfreq;
	__u32 param_flags;
	__u32 default_ss;
	struct sctp_rtoinfo rtoinfo;
	struct sctp_paddrparams paddrparam;
	struct sctp_assocparams assocparams;
	__u16 subscribe;
	struct sctp_initmsg initmsg;
	int user_frag;
	__u32 autoclose;
	__u32 adaptation_ind;
	__u32 pd_point;
	__u16 nodelay: 1;
	__u16 pf_expose: 2;
	__u16 reuse: 1;
	__u16 disable_fragments: 1;
	__u16 v4mapped: 1;
	__u16 frag_interleave: 1;
	__u16 recvrcvinfo: 1;
	__u16 recvnxtinfo: 1;
	__u16 data_ready_signalled: 1;
	atomic_t pd_mode;
	struct sk_buff_head pd_lobby;
	struct list_head auto_asconf_list;
	int do_auto_asconf;
};

struct sctp6_sock {
	struct sctp_sock sctp;
	struct ipv6_pinfo inet6;
};

struct sctp_adaptation_event {
	__u16 sai_type;
	__u16 sai_flags;
	__u32 sai_length;
	__u32 sai_adaptation_ind;
	sctp_assoc_t sai_assoc_id;
};

struct sctp_paramhdr {
	__be16 type;
	__be16 length;
};

struct sctp_adaptation_ind_param {
	struct sctp_paramhdr param_hdr;
	__be32 adaptation_ind;
};

struct sctp_add_streams {
	sctp_assoc_t sas_assoc_id;
	uint16_t sas_instrms;
	uint16_t sas_outstrms;
};

struct sctp_chunkhdr {
	__u8 type;
	__u8 flags;
	__be16 length;
};

struct sctp_addiphdr {
	__be32 serial;
};

struct sctp_addip_chunk {
	struct sctp_chunkhdr chunk_hdr;
	struct sctp_addiphdr addip_hdr;
};

struct sctp_addip_param {
	struct sctp_paramhdr param_hdr;
	__be32 crr_id;
};

union sctp_addr {
	struct sockaddr_in v4;
	struct sockaddr_in6 v6;
	struct sockaddr sa;
};

struct sctp_ipv4addr_param {
	struct sctp_paramhdr param_hdr;
	struct in_addr addr;
};

struct sctp_ipv6addr_param {
	struct sctp_paramhdr param_hdr;
	struct in6_addr addr;
};

union sctp_addr_param {
	struct sctp_paramhdr p;
	struct sctp_ipv4addr_param v4;
	struct sctp_ipv6addr_param v6;
};

struct sctp_transport;

struct sctp_af {
	int (*sctp_xmit)(struct sk_buff *, struct sctp_transport *);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*get_dst)(struct sctp_transport *, union sctp_addr *, struct flowi *, struct sock *);
	void (*get_saddr)(struct sctp_sock *, struct sctp_transport *, struct flowi *);
	void (*copy_addrlist)(struct list_head *, struct net_device *);
	int (*cmp_addr)(const union sctp_addr *, const union sctp_addr *);
	void (*addr_copy)(union sctp_addr *, union sctp_addr *);
	void (*from_skb)(union sctp_addr *, struct sk_buff *, int);
	void (*from_sk)(union sctp_addr *, struct sock *);
	bool (*from_addr_param)(union sctp_addr *, union sctp_addr_param *, __be16, int);
	int (*to_addr_param)(const union sctp_addr *, union sctp_addr_param *);
	int (*addr_valid)(union sctp_addr *, struct sctp_sock *, const struct sk_buff *);
	enum sctp_scope (*scope)(union sctp_addr *);
	void (*inaddr_any)(union sctp_addr *, __be16);
	int (*is_any)(const union sctp_addr *);
	int (*available)(union sctp_addr *, struct sctp_sock *);
	int (*skb_iif)(const struct sk_buff *);
	int (*skb_sdif)(const struct sk_buff *);
	int (*is_ce)(const struct sk_buff *);
	void (*seq_dump_addr)(struct seq_file *, union sctp_addr *);
	void (*ecn_capable)(struct sock *);
	__u16 net_header_len;
	int sockaddr_len;
	int (*ip_options_len)(struct sock *);
	sa_family_t sa_family;
	struct list_head list;
};

struct sctp_chunk;

struct sctp_association;

struct sctp_bind_addr;

struct sctp_init_chunk;

struct sctp_ulpevent;

struct sctp_packet;

struct sctp_sackhdr;

struct sctp_datamsg;

union sctp_arg {
	void *zero_all;
	__s32 i32;
	__u32 u32;
	__be32 be32;
	__u16 u16;
	__u8 u8;
	int error;
	__be16 err;
	enum sctp_state state;
	enum sctp_event_timeout to;
	struct sctp_chunk *chunk;
	struct sctp_association *asoc;
	struct sctp_transport *transport;
	struct sctp_bind_addr *bp;
	struct sctp_init_chunk *init;
	struct sctp_ulpevent *ulpevent;
	struct sctp_packet *packet;
	struct sctp_sackhdr *sackh;
	struct sctp_datamsg *msg;
};

struct sctp_assoc_change {
	__u16 sac_type;
	__u16 sac_flags;
	__u32 sac_length;
	__u16 sac_state;
	__u16 sac_error;
	__u16 sac_outbound_streams;
	__u16 sac_inbound_streams;
	sctp_assoc_t sac_assoc_id;
	__u8 sac_info[0];
};

struct sctp_assoc_ids {
	__u32 gaids_number_of_ids;
	sctp_assoc_t gaids_assoc_id[0];
};

struct sctp_assoc_reset_event {
	__u16 assocreset_type;
	__u16 assocreset_flags;
	__u32 assocreset_length;
	sctp_assoc_t assocreset_assoc_id;
	__u32 assocreset_local_tsn;
	__u32 assocreset_remote_tsn;
};

struct sctp_assoc_stats {
	sctp_assoc_t sas_assoc_id;
	struct __kernel_sockaddr_storage sas_obs_rto_ipaddr;
	__u64 sas_maxrto;
	__u64 sas_isacks;
	__u64 sas_osacks;
	__u64 sas_opackets;
	__u64 sas_ipackets;
	__u64 sas_rtxchunks;
	__u64 sas_outofseqtsns;
	__u64 sas_idupchunks;
	__u64 sas_gapcnt;
	__u64 sas_ouodchunks;
	__u64 sas_iuodchunks;
	__u64 sas_oodchunks;
	__u64 sas_iodchunks;
	__u64 sas_octrlchunks;
	__u64 sas_ictrlchunks;
};

struct sctp_assoc_value {
	sctp_assoc_t assoc_id;
	uint32_t assoc_value;
};

struct sctp_inq {
	struct list_head in_chunk_list;
	struct sctp_chunk *in_progress;
	struct work_struct immediate;
};

struct sctp_bind_addr {
	__u16 port;
	struct list_head address_list;
};

struct sctp_ep_common {
	enum sctp_endpoint_type type;
	refcount_t refcnt;
	bool dead;
	struct sock *sk;
	struct net *net;
	struct sctp_inq inqueue;
	struct sctp_bind_addr bind_addr;
};

struct sctp_cookie {
	__u32 my_vtag;
	__u32 peer_vtag;
	__u32 my_ttag;
	__u32 peer_ttag;
	ktime_t expiration;
	__u16 sinit_num_ostreams;
	__u16 sinit_max_instreams;
	__u32 initial_tsn;
	union sctp_addr peer_addr;
	__u16 my_port;
	__u8 prsctp_capable;
	__u8 padding;
	__u32 adaptation_ind;
	__u8 auth_random[36];
	__u8 auth_hmacs[10];
	__u8 auth_chunks[20];
	__u32 raw_addr_list_len;
};

struct sctp_tsnmap {
	long unsigned int *tsn_map;
	__u32 base_tsn;
	__u32 cumulative_tsn_ack_point;
	__u32 max_tsn_seen;
	__u16 len;
	__u16 pending_data;
	__u16 num_dup_tsns;
	__be32 dup_tsns[16];
};

struct sctp_inithdr_host {
	__u32 init_tag;
	__u32 a_rwnd;
	__u16 num_outbound_streams;
	__u16 num_inbound_streams;
	__u32 initial_tsn;
};

struct sctp_stream_out_ext;

struct sctp_stream_out {
	union {
		__u32 mid;
		__u16 ssn;
	};
	__u32 mid_uo;
	struct sctp_stream_out_ext *ext;
	__u8 state;
};

struct sctp_stream_in {
	union {
		__u32 mid;
		__u16 ssn;
	};
	__u32 mid_uo;
	__u32 fsn;
	__u32 fsn_uo;
	char pd_mode;
	char pd_mode_uo;
};

struct sctp_stream_interleave;

struct sctp_stream {
	struct {
		struct __genradix tree;
		struct sctp_stream_out type[0];
	} out;
	struct {
		struct __genradix tree;
		struct sctp_stream_in type[0];
	} in;
	__u16 outcnt;
	__u16 incnt;
	struct sctp_stream_out *out_curr;
	union {
		struct {
			struct list_head prio_list;
		};
		struct {
			struct list_head rr_list;
			struct sctp_stream_out_ext *rr_next;
		};
		struct {
			struct list_head fc_list;
		};
	};
	struct sctp_stream_interleave *si;
};

struct sctp_sched_ops;

struct sctp_outq {
	struct sctp_association *asoc;
	struct list_head out_chunk_list;
	struct sctp_sched_ops *sched;
	unsigned int out_qlen;
	unsigned int error;
	struct list_head control_chunk_list;
	struct list_head sacked;
	struct list_head retransmit;
	struct list_head abandoned;
	__u32 outstanding_bytes;
	char fast_rtx;
	char cork;
};

struct sctp_ulpq {
	char pd_mode;
	struct sctp_association *asoc;
	struct sk_buff_head reasm;
	struct sk_buff_head reasm_uo;
	struct sk_buff_head lobby;
};

struct sctp_priv_assoc_stats {
	struct __kernel_sockaddr_storage obs_rto_ipaddr;
	__u64 max_obs_rto;
	__u64 isacks;
	__u64 osacks;
	__u64 opackets;
	__u64 ipackets;
	__u64 rtxchunks;
	__u64 outofseqtsns;
	__u64 idupchunks;
	__u64 gapcnt;
	__u64 ouodchunks;
	__u64 iuodchunks;
	__u64 oodchunks;
	__u64 iodchunks;
	__u64 octrlchunks;
	__u64 ictrlchunks;
};

struct sctp_random_param;

struct sctp_chunks_param;

struct sctp_hmac_algo_param;

struct sctp_auth_bytes;

struct sctp_shared_key;

struct sctp_association {
	struct sctp_ep_common base;
	struct list_head asocs;
	sctp_assoc_t assoc_id;
	struct sctp_endpoint *ep;
	struct sctp_cookie c;
	struct {
		struct list_head transport_addr_list;
		__u32 rwnd;
		__u16 transport_count;
		__u16 port;
		struct sctp_transport *primary_path;
		union sctp_addr primary_addr;
		struct sctp_transport *active_path;
		struct sctp_transport *retran_path;
		struct sctp_transport *last_sent_to;
		struct sctp_transport *last_data_from;
		struct sctp_tsnmap tsn_map;
		__be16 addip_disabled_mask;
		__u16 ecn_capable: 1;
		__u16 ipv4_address: 1;
		__u16 ipv6_address: 1;
		__u16 asconf_capable: 1;
		__u16 prsctp_capable: 1;
		__u16 reconf_capable: 1;
		__u16 intl_capable: 1;
		__u16 auth_capable: 1;
		__u16 sack_needed: 1;
		__u16 sack_generation: 1;
		__u16 zero_window_announced: 1;
		__u32 sack_cnt;
		__u32 adaptation_ind;
		struct sctp_inithdr_host i;
		void *cookie;
		int cookie_len;
		__u32 addip_serial;
		struct sctp_random_param *peer_random;
		struct sctp_chunks_param *peer_chunks;
		struct sctp_hmac_algo_param *peer_hmacs;
	} peer;
	enum sctp_state state;
	int overall_error_count;
	ktime_t cookie_life;
	long unsigned int rto_initial;
	long unsigned int rto_max;
	long unsigned int rto_min;
	int max_burst;
	int max_retrans;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u16 max_init_attempts;
	__u16 init_retries;
	long unsigned int max_init_timeo;
	long unsigned int hbinterval;
	long unsigned int probe_interval;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u8 pmtu_pending;
	__u32 pathmtu;
	__u32 param_flags;
	__u32 sackfreq;
	long unsigned int sackdelay;
	long unsigned int timeouts[12];
	struct timer_list timers[12];
	struct sctp_transport *shutdown_last_sent_to;
	struct sctp_transport *init_last_sent_to;
	int shutdown_retries;
	__u32 next_tsn;
	__u32 ctsn_ack_point;
	__u32 adv_peer_ack_point;
	__u32 highest_sacked;
	__u32 fast_recovery_exit;
	__u8 fast_recovery;
	__u16 unack_data;
	__u32 rtx_data_chunks;
	__u32 rwnd;
	__u32 a_rwnd;
	__u32 rwnd_over;
	__u32 rwnd_press;
	int sndbuf_used;
	atomic_t rmem_alloc;
	wait_queue_head_t wait;
	__u32 frag_point;
	__u32 user_frag;
	int init_err_counter;
	int init_cycle;
	__u16 default_stream;
	__u16 default_flags;
	__u32 default_ppid;
	__u32 default_context;
	__u32 default_timetolive;
	__u32 default_rcv_context;
	struct sctp_stream stream;
	struct sctp_outq outqueue;
	struct sctp_ulpq ulpq;
	__u32 last_ecne_tsn;
	__u32 last_cwr_tsn;
	int numduptsns;
	struct sctp_chunk *addip_last_asconf;
	struct list_head asconf_ack_list;
	struct list_head addip_chunk_list;
	__u32 addip_serial;
	int src_out_of_asoc_ok;
	union sctp_addr *asconf_addr_del_pending;
	struct sctp_transport *new_transport;
	struct list_head endpoint_shared_keys;
	struct sctp_auth_bytes *asoc_shared_key;
	struct sctp_shared_key *shkey;
	__u16 default_hmac_id;
	__u16 active_key_id;
	__u8 need_ecne: 1;
	__u8 temp: 1;
	__u8 pf_expose: 2;
	__u8 force_delay: 1;
	__u8 strreset_enable;
	__u8 strreset_outstanding;
	__u32 strreset_outseq;
	__u32 strreset_inseq;
	__u32 strreset_result[2];
	struct sctp_chunk *strreset_chunk;
	struct sctp_priv_assoc_stats stats;
	int sent_cnt_removable;
	__u16 subscribe;
	__u64 abandoned_unsent[3];
	__u64 abandoned_sent[3];
	u32 secid;
	u32 peer_secid;
	struct callback_head rcu;
};

struct sctp_auth_bytes {
	refcount_t refcnt;
	__u32 len;
	__u8 data[0];
};

struct sctp_authhdr {
	__be16 shkey_id;
	__be16 hmac_id;
};

struct sctp_auth_chunk {
	struct sctp_chunkhdr chunk_hdr;
	struct sctp_authhdr auth_hdr;
};

struct sctp_authchunk {
	__u8 sauth_chunk;
};

struct sctp_authchunks {
	sctp_assoc_t gauth_assoc_id;
	__u32 gauth_number_of_chunks;
	uint8_t gauth_chunks[0];
};

struct sctp_authinfo {
	__u16 auth_keynumber;
};

struct sctp_authkey {
	sctp_assoc_t sca_assoc_id;
	__u16 sca_keynumber;
	__u16 sca_keylength;
	__u8 sca_key[0];
};

struct sctp_authkey_event {
	__u16 auth_type;
	__u16 auth_flags;
	__u32 auth_length;
	__u16 auth_keynumber;
	__u16 auth_altkeynumber;
	__u32 auth_indication;
	sctp_assoc_t auth_assoc_id;
};

struct sctp_authkeyid {
	sctp_assoc_t scact_assoc_id;
	__u16 scact_keynumber;
};

struct sctp_bind_bucket {
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct hlist_node node;
	struct hlist_head owner;
	struct net *net;
};

struct sctp_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct sctp_cookie_preserve_param;

struct sctp_hostname_param;

struct sctp_cookie_param;

struct sctp_supported_addrs_param;

struct sctp_supported_ext_param;

union sctp_params {
	void *v;
	struct sctp_paramhdr *p;
	struct sctp_cookie_preserve_param *life;
	struct sctp_hostname_param *dns;
	struct sctp_cookie_param *cookie;
	struct sctp_supported_addrs_param *sat;
	struct sctp_ipv4addr_param *v4;
	struct sctp_ipv6addr_param *v6;
	union sctp_addr_param *addr;
	struct sctp_adaptation_ind_param *aind;
	struct sctp_supported_ext_param *ext;
	struct sctp_random_param *random;
	struct sctp_chunks_param *chunks;
	struct sctp_hmac_algo_param *hmac_algo;
	struct sctp_addip_param *addip;
};

struct sctp_sndrcvinfo {
	__u16 sinfo_stream;
	__u16 sinfo_ssn;
	__u16 sinfo_flags;
	__u32 sinfo_ppid;
	__u32 sinfo_context;
	__u32 sinfo_timetolive;
	__u32 sinfo_tsn;
	__u32 sinfo_cumtsn;
	sctp_assoc_t sinfo_assoc_id;
};

struct sctp_datahdr;

struct sctp_inithdr;

struct sctp_heartbeathdr;

struct sctp_sender_hb_info;

struct sctp_shutdownhdr;

struct sctp_signed_cookie;

struct sctp_ecnehdr;

struct sctp_cwrhdr;

struct sctp_errhdr;

struct sctp_fwdtsn_hdr;

struct sctp_idatahdr;

struct sctp_ifwdtsn_hdr;

struct sctphdr;

struct sctp_chunk {
	struct list_head list;
	refcount_t refcnt;
	int sent_count;
	union {
		struct list_head transmitted_list;
		struct list_head stream_list;
	};
	struct list_head frag_list;
	struct sk_buff *skb;
	union {
		struct sk_buff *head_skb;
		struct sctp_shared_key *shkey;
	};
	union sctp_params param_hdr;
	union {
		__u8 *v;
		struct sctp_datahdr *data_hdr;
		struct sctp_inithdr *init_hdr;
		struct sctp_sackhdr *sack_hdr;
		struct sctp_heartbeathdr *hb_hdr;
		struct sctp_sender_hb_info *hbs_hdr;
		struct sctp_shutdownhdr *shutdown_hdr;
		struct sctp_signed_cookie *cookie_hdr;
		struct sctp_ecnehdr *ecne_hdr;
		struct sctp_cwrhdr *ecn_cwr_hdr;
		struct sctp_errhdr *err_hdr;
		struct sctp_addiphdr *addip_hdr;
		struct sctp_fwdtsn_hdr *fwdtsn_hdr;
		struct sctp_authhdr *auth_hdr;
		struct sctp_idatahdr *idata_hdr;
		struct sctp_ifwdtsn_hdr *ifwdtsn_hdr;
	} subh;
	__u8 *chunk_end;
	struct sctp_chunkhdr *chunk_hdr;
	struct sctphdr *sctp_hdr;
	struct sctp_sndrcvinfo sinfo;
	struct sctp_association *asoc;
	struct sctp_ep_common *rcvr;
	long unsigned int sent_at;
	union sctp_addr source;
	union sctp_addr dest;
	struct sctp_datamsg *msg;
	struct sctp_transport *transport;
	struct sk_buff *auth_chunk;
	__u16 rtt_in_progress: 1;
	__u16 has_tsn: 1;
	__u16 has_ssn: 1;
	__u16 singleton: 1;
	__u16 end_of_packet: 1;
	__u16 ecn_ce_done: 1;
	__u16 pdiscard: 1;
	__u16 tsn_gap_acked: 1;
	__u16 data_accepted: 1;
	__u16 auth: 1;
	__u16 has_asconf: 1;
	__u16 pmtu_probe: 1;
	__u16 tsn_missing_report: 2;
	__u16 fast_retransmit: 2;
};

struct sctp_chunks_param {
	struct sctp_paramhdr param_hdr;
	__u8 chunks[0];
};

struct sctp_cmd {
	union sctp_arg obj;
	enum sctp_verb verb;
};

struct sctp_cmd_seq {
	struct sctp_cmd cmds[20];
	struct sctp_cmd *last_used_slot;
	struct sctp_cmd *next_cmd;
};

struct sctp_sndinfo;

struct sctp_prinfo;

struct sctp_cmsgs {
	struct sctp_initmsg *init;
	struct sctp_sndrcvinfo *srinfo;
	struct sctp_sndinfo *sinfo;
	struct sctp_prinfo *prinfo;
	struct sctp_authinfo *authinfo;
	struct msghdr *addrs_msg;
};

struct sctp_comm_param {
	struct sk_buff *skb;
	struct netlink_callback *cb;
	const struct inet_diag_req_v2 *r;
	const struct nlmsghdr *nlh;
	bool net_admin;
};

struct sctp_cookie_param {
	struct sctp_paramhdr p;
	__u8 body[0];
};

struct sctp_cookie_preserve_param {
	struct sctp_paramhdr param_hdr;
	__be32 lifespan_increment;
};

struct sctp_cwrhdr {
	__be32 lowest_tsn;
};

struct sctp_datahdr {
	__be32 tsn;
	__be16 stream;
	__be16 ssn;
	__u32 ppid;
};

struct sctp_datamsg {
	struct list_head chunks;
	refcount_t refcnt;
	long unsigned int expires_at;
	int send_error;
	u8 send_failed: 1;
	u8 can_delay: 1;
	u8 abandoned: 1;
};

struct sctp_default_prinfo {
	sctp_assoc_t pr_assoc_id;
	__u32 pr_value;
	__u16 pr_policy;
};

struct sctp_ecnehdr {
	__be32 lowest_tsn;
};

struct sctp_endpoint {
	struct sctp_ep_common base;
	struct hlist_node node;
	int hashent;
	struct list_head asocs;
	__u8 secret_key[32];
	__u8 *digest;
	__u32 sndbuf_policy;
	__u32 rcvbuf_policy;
	struct crypto_shash **auth_hmacs;
	struct sctp_hmac_algo_param *auth_hmacs_list;
	struct sctp_chunks_param *auth_chunk_list;
	struct list_head endpoint_shared_keys;
	__u16 active_key_id;
	__u8 ecn_enable: 1;
	__u8 auth_enable: 1;
	__u8 intl_enable: 1;
	__u8 prsctp_enable: 1;
	__u8 asconf_enable: 1;
	__u8 reconf_enable: 1;
	__u8 strreset_enable;
	struct callback_head rcu;
};

struct sctp_errhdr {
	__be16 cause;
	__be16 length;
};

struct sctp_event {
	sctp_assoc_t se_assoc_id;
	uint16_t se_type;
	uint8_t se_on;
};

struct sctp_event_subscribe {
	__u8 sctp_data_io_event;
	__u8 sctp_association_event;
	__u8 sctp_address_event;
	__u8 sctp_send_failure_event;
	__u8 sctp_peer_error_event;
	__u8 sctp_shutdown_event;
	__u8 sctp_partial_delivery_event;
	__u8 sctp_adaptation_layer_event;
	__u8 sctp_authentication_event;
	__u8 sctp_sender_dry_event;
	__u8 sctp_stream_reset_event;
	__u8 sctp_assoc_reset_event;
	__u8 sctp_stream_change_event;
	__u8 sctp_send_failure_event_event;
};

struct sctp_flush_ctx {
	struct sctp_outq *q;
	struct sctp_transport *transport;
	struct list_head transport_list;
	struct sctp_association *asoc;
	struct sctp_packet *packet;
	gfp_t gfp;
};

struct sctp_fwdtsn_hdr {
	__be32 new_cum_tsn;
};

struct sctp_fwdtsn_skip {
	__be16 stream;
	__be16 ssn;
};

struct sctp_gap_ack_block {
	__be16 start;
	__be16 end;
};

struct sctp_getaddrs {
	sctp_assoc_t assoc_id;
	__u32 addr_num;
	__u8 addrs[0];
};

struct sctp_getaddrs_old {
	sctp_assoc_t assoc_id;
	int addr_num;
	struct sockaddr *addrs;
};

struct sctp_hashbucket;

struct sctp_globals {
	struct list_head address_families;
	struct sctp_hashbucket *ep_hashtable;
	struct sctp_bind_hashbucket *port_hashtable;
	struct rhltable transport_hashtable;
	int ep_hashsize;
	int port_hashsize;
	__u16 max_instreams;
	__u16 max_outstreams;
	bool checksum_disable;
};

struct sctp_hash_cmp_arg {
	const union sctp_addr *paddr;
	const struct net *net;
	__be16 lport;
};

struct sctp_hashbucket {
	rwlock_t lock;
	struct hlist_head chain;
};

struct sctp_heartbeathdr {
	struct sctp_paramhdr info;
};

struct sctp_hmac {
	__u16 hmac_id;
	char *hmac_name;
	__u16 hmac_len;
};

struct sctp_hmac_algo_param {
	struct sctp_paramhdr param_hdr;
	__be16 hmac_ids[0];
};

struct sctp_hmacalgo {
	__u32 shmac_num_idents;
	__u16 shmac_idents[0];
};

struct sctp_hostname_param {
	struct sctp_paramhdr param_hdr;
	uint8_t hostname[0];
};

struct sctp_ht_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
};

struct sctp_idatahdr {
	__be32 tsn;
	__be16 stream;
	__be16 reserved;
	__be32 mid;
	union {
		__u32 ppid;
		__be32 fsn;
	};
	__u8 payload[0];
};

struct sctp_ifwdtsn_hdr {
	__be32 new_cum_tsn;
};

struct sctp_ifwdtsn_skip {
	__be16 stream;
	__u8 reserved;
	__u8 flags;
	__be32 mid;
};

struct sctp_info {
	__u32 sctpi_tag;
	__u32 sctpi_state;
	__u32 sctpi_rwnd;
	__u16 sctpi_unackdata;
	__u16 sctpi_penddata;
	__u16 sctpi_instrms;
	__u16 sctpi_outstrms;
	__u32 sctpi_fragmentation_point;
	__u32 sctpi_inqueue;
	__u32 sctpi_outqueue;
	__u32 sctpi_overall_error;
	__u32 sctpi_max_burst;
	__u32 sctpi_maxseg;
	__u32 sctpi_peer_rwnd;
	__u32 sctpi_peer_tag;
	__u8 sctpi_peer_capable;
	__u8 sctpi_peer_sack;
	__u16 __reserved1;
	__u64 sctpi_isacks;
	__u64 sctpi_osacks;
	__u64 sctpi_opackets;
	__u64 sctpi_ipackets;
	__u64 sctpi_rtxchunks;
	__u64 sctpi_outofseqtsns;
	__u64 sctpi_idupchunks;
	__u64 sctpi_gapcnt;
	__u64 sctpi_ouodchunks;
	__u64 sctpi_iuodchunks;
	__u64 sctpi_oodchunks;
	__u64 sctpi_iodchunks;
	__u64 sctpi_octrlchunks;
	__u64 sctpi_ictrlchunks;
	struct __kernel_sockaddr_storage sctpi_p_address;
	__s32 sctpi_p_state;
	__u32 sctpi_p_cwnd;
	__u32 sctpi_p_srtt;
	__u32 sctpi_p_rto;
	__u32 sctpi_p_hbinterval;
	__u32 sctpi_p_pathmaxrxt;
	__u32 sctpi_p_sackdelay;
	__u32 sctpi_p_sackfreq;
	__u32 sctpi_p_ssthresh;
	__u32 sctpi_p_partial_bytes_acked;
	__u32 sctpi_p_flight_size;
	__u16 sctpi_p_error;
	__u16 __reserved2;
	__u32 sctpi_s_autoclose;
	__u32 sctpi_s_adaptation_ind;
	__u32 sctpi_s_pd_point;
	__u8 sctpi_s_nodelay;
	__u8 sctpi_s_disable_fragments;
	__u8 sctpi_s_v4mapped;
	__u8 sctpi_s_frag_interleave;
	__u32 sctpi_s_type;
	__u32 __reserved3;
};

struct sctp_infox {
	struct sctp_info *sctpinfo;
	struct sctp_association *asoc;
};

struct sctp_inithdr {
	__be32 init_tag;
	__be32 a_rwnd;
	__be16 num_outbound_streams;
	__be16 num_inbound_streams;
	__be32 initial_tsn;
};

struct sctp_init_chunk {
	struct sctp_chunkhdr chunk_hdr;
	struct sctp_inithdr init_hdr;
};

struct sctp_initack_chunk {
	struct sctp_chunkhdr chunk_hdr;
	struct sctp_inithdr init_hdr;
};

struct sctp_input_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sctp_chunk *chunk;
	struct sctp_af *af;
	__be16 encap_port;
};

struct sctp_mib {
	long unsigned int mibs[34];
};

struct sctp_new_encap_port_hdr {
	__be16 cur_port;
	__be16 new_port;
};

struct sctp_paddr_change {
	__u16 spc_type;
	__u16 spc_flags;
	__u32 spc_length;
	struct __kernel_sockaddr_storage spc_aaddr;
	int spc_state;
	int spc_error;
	sctp_assoc_t spc_assoc_id;
} __attribute__((packed));

struct sctp_remote_error {
	__u16 sre_type;
	__u16 sre_flags;
	__u32 sre_length;
	__be16 sre_error;
	sctp_assoc_t sre_assoc_id;
	__u8 sre_data[0];
};

struct sctp_send_failed {
	__u16 ssf_type;
	__u16 ssf_flags;
	__u32 ssf_length;
	__u32 ssf_error;
	struct sctp_sndrcvinfo ssf_info;
	sctp_assoc_t ssf_assoc_id;
	__u8 ssf_data[0];
};

struct sctp_shutdown_event {
	__u16 sse_type;
	__u16 sse_flags;
	__u32 sse_length;
	sctp_assoc_t sse_assoc_id;
};

struct sctp_pdapi_event {
	__u16 pdapi_type;
	__u16 pdapi_flags;
	__u32 pdapi_length;
	__u32 pdapi_indication;
	sctp_assoc_t pdapi_assoc_id;
	__u32 pdapi_stream;
	__u32 pdapi_seq;
};

struct sctp_sender_dry_event {
	__u16 sender_dry_type;
	__u16 sender_dry_flags;
	__u32 sender_dry_length;
	sctp_assoc_t sender_dry_assoc_id;
};

struct sctp_stream_reset_event {
	__u16 strreset_type;
	__u16 strreset_flags;
	__u32 strreset_length;
	sctp_assoc_t strreset_assoc_id;
	__u16 strreset_stream_list[0];
};

struct sctp_stream_change_event {
	__u16 strchange_type;
	__u16 strchange_flags;
	__u32 strchange_length;
	sctp_assoc_t strchange_assoc_id;
	__u16 strchange_instrms;
	__u16 strchange_outstrms;
};

struct sctp_sndinfo {
	__u16 snd_sid;
	__u16 snd_flags;
	__u32 snd_ppid;
	__u32 snd_context;
	sctp_assoc_t snd_assoc_id;
};

struct sctp_send_failed_event {
	__u16 ssf_type;
	__u16 ssf_flags;
	__u32 ssf_length;
	__u32 ssf_error;
	struct sctp_sndinfo ssfe_info;
	sctp_assoc_t ssf_assoc_id;
	__u8 ssf_data[0];
};

union sctp_notification {
	struct {
		__u16 sn_type;
		__u16 sn_flags;
		__u32 sn_length;
	} sn_header;
	struct sctp_assoc_change sn_assoc_change;
	struct sctp_paddr_change sn_paddr_change;
	struct sctp_remote_error sn_remote_error;
	struct sctp_send_failed sn_send_failed;
	struct sctp_shutdown_event sn_shutdown_event;
	struct sctp_adaptation_event sn_adaptation_event;
	struct sctp_pdapi_event sn_pdapi_event;
	struct sctp_authkey_event sn_authkey_event;
	struct sctp_sender_dry_event sn_sender_dry_event;
	struct sctp_stream_reset_event sn_strreset_event;
	struct sctp_assoc_reset_event sn_assocreset_event;
	struct sctp_stream_change_event sn_strchange_event;
	struct sctp_send_failed_event sn_send_failed_event;
};

struct sctp_nxtinfo {
	__u16 nxt_sid;
	__u16 nxt_flags;
	__u32 nxt_ppid;
	__u32 nxt_length;
	sctp_assoc_t nxt_assoc_id;
};

struct sctp_output_cb {
	struct sk_buff *last;
};

struct sctp_packet {
	__u16 source_port;
	__u16 destination_port;
	__u32 vtag;
	struct list_head chunk_list;
	size_t overhead;
	size_t size;
	size_t max_size;
	struct sctp_transport *transport;
	struct sctp_chunk *auth;
	u8 has_cookie_echo: 1;
	u8 has_sack: 1;
	u8 has_auth: 1;
	u8 has_data: 1;
	u8 ipfragok: 1;
};

struct sctp_paddrinfo {
	sctp_assoc_t spinfo_assoc_id;
	struct __kernel_sockaddr_storage spinfo_address;
	__s32 spinfo_state;
	__u32 spinfo_cwnd;
	__u32 spinfo_srtt;
	__u32 spinfo_rto;
	__u32 spinfo_mtu;
} __attribute__((packed));

struct sctp_paddrthlds_v2 {
	sctp_assoc_t spt_assoc_id;
	struct __kernel_sockaddr_storage spt_address;
	__u16 spt_pathmaxrxt;
	__u16 spt_pathpfthld;
	__u16 spt_pathcpthld;
};

struct sctp_pf {
	void (*event_msgname)(struct sctp_ulpevent *, char *, int *);
	void (*skb_msgname)(struct sk_buff *, char *, int *);
	int (*af_supported)(sa_family_t, struct sctp_sock *);
	int (*cmp_addr)(const union sctp_addr *, const union sctp_addr *, struct sctp_sock *);
	int (*bind_verify)(struct sctp_sock *, union sctp_addr *);
	int (*send_verify)(struct sctp_sock *, union sctp_addr *);
	int (*supported_addrs)(const struct sctp_sock *, __be16 *);
	struct sock * (*create_accept_sk)(struct sock *, struct sctp_association *, bool);
	int (*addr_to_user)(struct sctp_sock *, union sctp_addr *);
	void (*to_sk_saddr)(union sctp_addr *, struct sock *);
	void (*to_sk_daddr)(union sctp_addr *, struct sock *);
	void (*copy_ip_options)(struct sock *, struct sock *);
	struct sctp_af *af;
};

struct sctp_prim {
	sctp_assoc_t ssp_assoc_id;
	struct __kernel_sockaddr_storage ssp_addr;
} __attribute__((packed));

struct sctp_prinfo {
	__u16 pr_policy;
	__u32 pr_value;
};

struct sctp_probeinterval {
	sctp_assoc_t spi_assoc_id;
	struct __kernel_sockaddr_storage spi_address;
	__u32 spi_interval;
};

struct sctp_prstatus {
	sctp_assoc_t sprstat_assoc_id;
	__u16 sprstat_sid;
	__u16 sprstat_policy;
	__u64 sprstat_abandoned_unsent;
	__u64 sprstat_abandoned_sent;
};

struct sctp_random_param {
	struct sctp_paramhdr param_hdr;
	__u8 random_val[0];
};

struct sctp_rcvinfo {
	__u16 rcv_sid;
	__u16 rcv_ssn;
	__u16 rcv_flags;
	__u32 rcv_ppid;
	__u32 rcv_tsn;
	__u32 rcv_cumtsn;
	__u32 rcv_context;
	sctp_assoc_t rcv_assoc_id;
};

struct sctp_reconf_chunk {
	struct sctp_chunkhdr chunk_hdr;
};

struct sctp_reset_streams {
	sctp_assoc_t srs_assoc_id;
	uint16_t srs_flags;
	uint16_t srs_number_streams;
	uint16_t srs_stream_list[0];
};

struct sctp_sack_info {
	sctp_assoc_t sack_assoc_id;
	uint32_t sack_delay;
	uint32_t sack_freq;
};

union sctp_sack_variable {
	struct sctp_gap_ack_block gab;
	__be32 dup;
};

struct sctp_sackhdr {
	__be32 cum_tsn_ack;
	__be32 a_rwnd;
	__be16 num_gap_ack_blocks;
	__be16 num_dup_tsns;
};

struct sctp_sched_ops {
	int (*set)(struct sctp_stream *, __u16, __u16, gfp_t);
	int (*get)(struct sctp_stream *, __u16, __u16 *);
	int (*init)(struct sctp_stream *);
	int (*init_sid)(struct sctp_stream *, __u16, gfp_t);
	void (*free_sid)(struct sctp_stream *, __u16);
	void (*enqueue)(struct sctp_outq *, struct sctp_datamsg *);
	struct sctp_chunk * (*dequeue)(struct sctp_outq *);
	void (*dequeue_done)(struct sctp_outq *, struct sctp_chunk *);
	void (*sched_all)(struct sctp_stream *);
	void (*unsched_all)(struct sctp_stream *);
};

struct sctp_sender_hb_info {
	struct sctp_paramhdr param_hdr;
	union sctp_addr daddr;
	long unsigned int sent_at;
	__u64 hb_nonce;
	__u32 probe_size;
};

struct sctp_setadaptation {
	__u32 ssb_adaptation_ind;
};

struct sctp_setpeerprim {
	sctp_assoc_t sspp_assoc_id;
	struct __kernel_sockaddr_storage sspp_addr;
} __attribute__((packed));

struct sctp_shared_key {
	struct list_head key_list;
	struct sctp_auth_bytes *key;
	refcount_t refcnt;
	__u16 key_id;
	__u8 deactivated;
};

struct sctp_shutdownhdr {
	__be32 cum_tsn_ack;
};

struct sctp_signed_cookie {
	__u8 signature[32];
	__u32 __pad;
	struct sctp_cookie c;
} __attribute__((packed));

union sctp_subtype;

typedef enum sctp_disposition sctp_state_fn_t(struct net *, const struct sctp_endpoint *, const struct sctp_association *, const union sctp_subtype, void *, struct sctp_cmd_seq *);

struct sctp_sm_table_entry {
	sctp_state_fn_t *fn;
	const char *name;
};

struct sctp_sockaddr_entry {
	struct list_head list;
	struct callback_head rcu;
	union sctp_addr a;
	__u8 state;
	__u8 valid;
};

struct sctp_status {
	sctp_assoc_t sstat_assoc_id;
	__s32 sstat_state;
	__u32 sstat_rwnd;
	__u16 sstat_unackdata;
	__u16 sstat_penddata;
	__u16 sstat_instrms;
	__u16 sstat_outstrms;
	__u32 sstat_fragmentation_point;
	struct sctp_paddrinfo sstat_primary;
};

struct sctp_stream_interleave {
	__u16 data_chunk_len;
	__u16 ftsn_chunk_len;
	struct sctp_chunk * (*make_datafrag)(const struct sctp_association *, const struct sctp_sndrcvinfo *, int, __u8, gfp_t);
	void (*assign_number)(struct sctp_chunk *);
	bool (*validate_data)(struct sctp_chunk *);
	int (*ulpevent_data)(struct sctp_ulpq *, struct sctp_chunk *, gfp_t);
	int (*enqueue_event)(struct sctp_ulpq *, struct sctp_ulpevent *);
	void (*renege_events)(struct sctp_ulpq *, struct sctp_chunk *, gfp_t);
	void (*start_pd)(struct sctp_ulpq *, gfp_t);
	void (*abort_pd)(struct sctp_ulpq *, gfp_t);
	void (*generate_ftsn)(struct sctp_outq *, __u32);
	bool (*validate_ftsn)(struct sctp_chunk *);
	void (*report_ftsn)(struct sctp_ulpq *, __u32);
	void (*handle_ftsn)(struct sctp_ulpq *, struct sctp_chunk *);
};

struct sctp_stream_priorities;

struct sctp_stream_out_ext {
	__u64 abandoned_unsent[3];
	__u64 abandoned_sent[3];
	struct list_head outq;
	union {
		struct {
			struct list_head prio_list;
			struct sctp_stream_priorities *prio_head;
		};
		struct {
			struct list_head rr_list;
		};
		struct {
			struct list_head fc_list;
			__u32 fc_length;
			__u16 fc_weight;
		};
	};
};

struct sctp_stream_priorities {
	struct list_head prio_sched;
	struct list_head active;
	struct sctp_stream_out_ext *next;
	__u16 prio;
	__u16 users;
};

struct sctp_stream_value {
	sctp_assoc_t assoc_id;
	uint16_t stream_id;
	uint16_t stream_value;
};

struct sctp_strreset_addstrm {
	struct sctp_paramhdr param_hdr;
	__be32 request_seq;
	__be16 number_of_streams;
	__be16 reserved;
};

struct sctp_strreset_inreq {
	struct sctp_paramhdr param_hdr;
	__be32 request_seq;
	__be16 list_of_streams[0];
};

struct sctp_strreset_outreq {
	struct sctp_paramhdr param_hdr;
	__be32 request_seq;
	__be32 response_seq;
	__be32 send_reset_at_tsn;
	__be16 list_of_streams[0];
};

struct sctp_strreset_resp {
	struct sctp_paramhdr param_hdr;
	__be32 response_seq;
	__be32 result;
};

struct sctp_strreset_resptsn {
	struct sctp_paramhdr param_hdr;
	__be32 response_seq;
	__be32 result;
	__be32 senders_next_tsn;
	__be32 receivers_next_tsn;
};

struct sctp_strreset_tsnreq {
	struct sctp_paramhdr param_hdr;
	__be32 request_seq;
};

union sctp_subtype {
	enum sctp_cid chunk;
	enum sctp_event_timeout timeout;
	enum sctp_event_other other;
	enum sctp_event_primitive primitive;
};

struct sctp_supported_addrs_param {
	struct sctp_paramhdr param_hdr;
	__be16 types[0];
};

struct sctp_supported_ext_param {
	struct sctp_paramhdr param_hdr;
	__u8 chunks[0];
};

struct sctp_transport {
	struct list_head transports;
	struct rhlist_head node;
	refcount_t refcnt;
	__u32 dead: 1;
	__u32 rto_pending: 1;
	__u32 hb_sent: 1;
	__u32 pmtu_pending: 1;
	__u32 dst_pending_confirm: 1;
	__u32 sack_generation: 1;
	u32 dst_cookie;
	struct flowi fl;
	union sctp_addr ipaddr;
	struct sctp_af *af_specific;
	struct sctp_association *asoc;
	long unsigned int rto;
	__u32 rtt;
	__u32 rttvar;
	__u32 srtt;
	__u32 cwnd;
	__u32 ssthresh;
	__u32 partial_bytes_acked;
	__u32 flight_size;
	__u32 burst_limited;
	struct dst_entry *dst;
	union sctp_addr saddr;
	long unsigned int hbinterval;
	long unsigned int probe_interval;
	long unsigned int sackdelay;
	__u32 sackfreq;
	atomic_t mtu_info;
	ktime_t last_time_heard;
	long unsigned int last_time_sent;
	long unsigned int last_time_ecne_reduced;
	__be16 encap_port;
	__u16 pathmaxrxt;
	__u32 flowlabel;
	__u8 dscp;
	__u16 pf_retrans;
	__u16 ps_retrans;
	__u32 pathmtu;
	__u32 param_flags;
	int init_sent_count;
	int state;
	short unsigned int error_count;
	struct timer_list T3_rtx_timer;
	struct timer_list hb_timer;
	struct timer_list proto_unreach_timer;
	struct timer_list reconf_timer;
	struct timer_list probe_timer;
	struct list_head transmitted;
	struct sctp_packet packet;
	struct list_head send_ready;
	struct {
		__u32 next_tsn_at_change;
		char changeover_active;
		char cycling_changeover;
		char cacc_saw_newack;
	} cacc;
	struct {
		__u16 pmtu;
		__u16 probe_size;
		__u16 probe_high;
		__u8 probe_count;
		__u8 state;
	} pl;
	__u64 hb_nonce;
	struct callback_head rcu;
};

struct sctp_tsnmap_iter {
	__u32 start;
};

struct sctp_udpencaps {
	sctp_assoc_t sue_assoc_id;
	struct __kernel_sockaddr_storage sue_address;
	uint16_t sue_port;
};

struct sctp_ulpevent {
	struct sctp_association *asoc;
	struct sctp_chunk *chunk;
	unsigned int rmem_len;
	union {
		__u32 mid;
		__u16 ssn;
	};
	union {
		__u32 ppid;
		__u32 fsn;
	};
	__u32 tsn;
	__u32 cumtsn;
	__u16 stream;
	__u16 flags;
	__u16 msg_flags;
} __attribute__((packed));

struct sctp_unrecognized_param {
	struct sctp_paramhdr param_hdr;
	struct sctp_paramhdr unrecognized;
};

struct sctphdr {
	__be16 source;
	__be16 dest;
	__be32 vtag;
	__le32 checksum;
};

struct sd_flag_debug {
	unsigned int meta_flags;
	char *name;
};

struct sd_flow_limit {
	u64 count;
	unsigned int num_buckets;
	unsigned int history_head;
	u16 history[128];
	u8 buckets[0];
};

struct sg_lb_stats {
	long unsigned int avg_load;
	long unsigned int group_load;
	long unsigned int group_capacity;
	long unsigned int group_util;
	long unsigned int group_runnable;
	unsigned int sum_nr_running;
	unsigned int sum_h_nr_running;
	unsigned int idle_cpus;
	unsigned int group_weight;
	enum group_type group_type;
	unsigned int group_asym_packing;
	unsigned int group_smt_balance;
	long unsigned int group_misfit_task_load;
};

struct sd_lb_stats {
	struct sched_group *busiest;
	struct sched_group *local;
	long unsigned int total_load;
	long unsigned int total_capacity;
	long unsigned int avg_load;
	unsigned int prefer_sibling;
	struct sg_lb_stats busiest_stat;
	struct sg_lb_stats local_stat;
};

struct shash_desc {
	struct crypto_shash *tfm;
	void *__ctx[0];
};

struct sdesc {
	struct shash_desc shash;
	char ctx[0];
};

struct sdp_media_type {
	const char *name;
	unsigned int len;
	enum sip_expectation_classes class;
};

struct xfrm_offload {
	struct {
		__u32 low;
		__u32 hi;
	} seq;
	__u32 flags;
	__u32 status;
	__u32 orig_mac_len;
	__u8 proto;
	__u8 inner_ipproto;
};

struct sec_path {
	int len;
	int olen;
	int verified_cnt;
	struct xfrm_state *xvec[6];
	struct xfrm_offload ovec[1];
};

struct seccomp_filter;

struct seccomp {
	int mode;
	atomic_t filter_count;
	struct seccomp_filter *filter;
};

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

struct seccomp_filter {
	refcount_t refs;
	refcount_t users;
	bool log;
	bool wait_killable_recv;
	struct action_cache cache;
	struct seccomp_filter *prev;
	struct bpf_prog *prog;
	struct notification *notif;
	struct mutex notify_lock;
	wait_queue_head_t wqh;
};

struct seccomp_kaddfd {
	struct file *file;
	int fd;
	unsigned int flags;
	__u32 ioctl_flags;
	union {
		bool setfd;
		int ret;
	};
	struct completion completion;
	struct list_head list;
};

struct seccomp_knotif {
	struct task_struct *task;
	u64 id;
	const struct seccomp_data *data;
	enum notify_state state;
	int error;
	long int val;
	u32 flags;
	struct completion ready;
	struct list_head list;
	struct list_head addfd;
};

struct seccomp_log_name {
	u32 log;
	const char *name;
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_addfd {
	__u64 id;
	__u32 flags;
	__u32 srcfd;
	__u32 newfd;
	__u32 newfd_flags;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

struct seccomp_notif_sizes {
	__u16 seccomp_notif;
	__u16 seccomp_notif_resp;
	__u16 seccomp_data;
};

struct sector_ptr {
	struct page *page;
	unsigned int pgoff: 24;
	unsigned int uptodate: 8;
};

struct timezone;

struct xattr;

struct sembuf;

union security_list_options {
	int (*binder_set_context_mgr)(const struct cred *);
	int (*binder_transaction)(const struct cred *, const struct cred *);
	int (*binder_transfer_binder)(const struct cred *, const struct cred *);
	int (*binder_transfer_file)(const struct cred *, const struct cred *, const struct file *);
	int (*ptrace_access_check)(struct task_struct *, unsigned int);
	int (*ptrace_traceme)(struct task_struct *);
	int (*capget)(const struct task_struct *, kernel_cap_t *, kernel_cap_t *, kernel_cap_t *);
	int (*capset)(struct cred *, const struct cred *, const kernel_cap_t *, const kernel_cap_t *, const kernel_cap_t *);
	int (*capable)(const struct cred *, struct user_namespace *, int, unsigned int);
	int (*quotactl)(int, int, int, const struct super_block *);
	int (*quota_on)(struct dentry *);
	int (*syslog)(int);
	int (*settime)(const struct timespec64 *, const struct timezone *);
	int (*vm_enough_memory)(struct mm_struct *, long int);
	int (*bprm_creds_for_exec)(struct linux_binprm *);
	int (*bprm_creds_from_file)(struct linux_binprm *, const struct file *);
	int (*bprm_check_security)(struct linux_binprm *);
	void (*bprm_committing_creds)(const struct linux_binprm *);
	void (*bprm_committed_creds)(const struct linux_binprm *);
	int (*fs_context_submount)(struct fs_context *, struct super_block *);
	int (*fs_context_dup)(struct fs_context *, struct fs_context *);
	int (*fs_context_parse_param)(struct fs_context *, struct fs_parameter *);
	int (*sb_alloc_security)(struct super_block *);
	void (*sb_delete)(struct super_block *);
	void (*sb_free_security)(struct super_block *);
	void (*sb_free_mnt_opts)(void *);
	int (*sb_eat_lsm_opts)(char *, void **);
	int (*sb_mnt_opts_compat)(struct super_block *, void *);
	int (*sb_remount)(struct super_block *, void *);
	int (*sb_kern_mount)(const struct super_block *);
	int (*sb_show_options)(struct seq_file *, struct super_block *);
	int (*sb_statfs)(struct dentry *);
	int (*sb_mount)(const char *, const struct path *, const char *, long unsigned int, void *);
	int (*sb_umount)(struct vfsmount *, int);
	int (*sb_pivotroot)(const struct path *, const struct path *);
	int (*sb_set_mnt_opts)(struct super_block *, void *, long unsigned int, long unsigned int *);
	int (*sb_clone_mnt_opts)(const struct super_block *, struct super_block *, long unsigned int, long unsigned int *);
	int (*move_mount)(const struct path *, const struct path *);
	int (*dentry_init_security)(struct dentry *, int, const struct qstr *, const char **, struct lsm_context *);
	int (*dentry_create_files_as)(struct dentry *, int, struct qstr *, const struct cred *, struct cred *);
	int (*path_unlink)(const struct path *, struct dentry *);
	int (*path_mkdir)(const struct path *, struct dentry *, umode_t);
	int (*path_rmdir)(const struct path *, struct dentry *);
	int (*path_mknod)(const struct path *, struct dentry *, umode_t, unsigned int);
	void (*path_post_mknod)(struct mnt_idmap *, struct dentry *);
	int (*path_truncate)(const struct path *);
	int (*path_symlink)(const struct path *, struct dentry *, const char *);
	int (*path_link)(struct dentry *, const struct path *, struct dentry *);
	int (*path_rename)(const struct path *, struct dentry *, const struct path *, struct dentry *, unsigned int);
	int (*path_chmod)(const struct path *, umode_t);
	int (*path_chown)(const struct path *, kuid_t, kgid_t);
	int (*path_chroot)(const struct path *);
	int (*path_notify)(const struct path *, u64, unsigned int);
	int (*inode_alloc_security)(struct inode *);
	void (*inode_free_security)(struct inode *);
	void (*inode_free_security_rcu)(void *);
	int (*inode_init_security)(struct inode *, struct inode *, const struct qstr *, struct xattr *, int *);
	int (*inode_init_security_anon)(struct inode *, const struct qstr *, const struct inode *);
	int (*inode_create)(struct inode *, struct dentry *, umode_t);
	void (*inode_post_create_tmpfile)(struct mnt_idmap *, struct inode *);
	int (*inode_link)(struct dentry *, struct inode *, struct dentry *);
	int (*inode_unlink)(struct inode *, struct dentry *);
	int (*inode_symlink)(struct inode *, struct dentry *, const char *);
	int (*inode_mkdir)(struct inode *, struct dentry *, umode_t);
	int (*inode_rmdir)(struct inode *, struct dentry *);
	int (*inode_mknod)(struct inode *, struct dentry *, umode_t, dev_t);
	int (*inode_rename)(struct inode *, struct dentry *, struct inode *, struct dentry *);
	int (*inode_readlink)(struct dentry *);
	int (*inode_follow_link)(struct dentry *, struct inode *, bool);
	int (*inode_permission)(struct inode *, int);
	int (*inode_setattr)(struct mnt_idmap *, struct dentry *, struct iattr *);
	void (*inode_post_setattr)(struct mnt_idmap *, struct dentry *, int);
	int (*inode_getattr)(const struct path *);
	int (*inode_xattr_skipcap)(const char *);
	int (*inode_setxattr)(struct mnt_idmap *, struct dentry *, const char *, const void *, size_t, int);
	void (*inode_post_setxattr)(struct dentry *, const char *, const void *, size_t, int);
	int (*inode_getxattr)(struct dentry *, const char *);
	int (*inode_listxattr)(struct dentry *);
	int (*inode_removexattr)(struct mnt_idmap *, struct dentry *, const char *);
	void (*inode_post_removexattr)(struct dentry *, const char *);
	int (*inode_set_acl)(struct mnt_idmap *, struct dentry *, const char *, struct posix_acl *);
	void (*inode_post_set_acl)(struct dentry *, const char *, struct posix_acl *);
	int (*inode_get_acl)(struct mnt_idmap *, struct dentry *, const char *);
	int (*inode_remove_acl)(struct mnt_idmap *, struct dentry *, const char *);
	void (*inode_post_remove_acl)(struct mnt_idmap *, struct dentry *, const char *);
	int (*inode_need_killpriv)(struct dentry *);
	int (*inode_killpriv)(struct mnt_idmap *, struct dentry *);
	int (*inode_getsecurity)(struct mnt_idmap *, struct inode *, const char *, void **, bool);
	int (*inode_setsecurity)(struct inode *, const char *, const void *, size_t, int);
	int (*inode_listsecurity)(struct inode *, char *, size_t);
	void (*inode_getlsmprop)(struct inode *, struct lsm_prop *);
	int (*inode_copy_up)(struct dentry *, struct cred **);
	int (*inode_copy_up_xattr)(struct dentry *, const char *);
	int (*inode_setintegrity)(const struct inode *, enum lsm_integrity_type, const void *, size_t);
	int (*kernfs_init_security)(struct kernfs_node *, struct kernfs_node *);
	int (*file_permission)(struct file *, int);
	int (*file_alloc_security)(struct file *);
	void (*file_release)(struct file *);
	void (*file_free_security)(struct file *);
	int (*file_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*file_ioctl_compat)(struct file *, unsigned int, long unsigned int);
	int (*mmap_addr)(long unsigned int);
	int (*mmap_file)(struct file *, long unsigned int, long unsigned int, long unsigned int);
	int (*file_mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int);
	int (*file_lock)(struct file *, unsigned int);
	int (*file_fcntl)(struct file *, unsigned int, long unsigned int);
	void (*file_set_fowner)(struct file *);
	int (*file_send_sigiotask)(struct task_struct *, struct fown_struct *, int);
	int (*file_receive)(struct file *);
	int (*file_open)(struct file *);
	int (*file_post_open)(struct file *, int);
	int (*file_truncate)(struct file *);
	int (*task_alloc)(struct task_struct *, long unsigned int);
	void (*task_free)(struct task_struct *);
	int (*cred_alloc_blank)(struct cred *, gfp_t);
	void (*cred_free)(struct cred *);
	int (*cred_prepare)(struct cred *, const struct cred *, gfp_t);
	void (*cred_transfer)(struct cred *, const struct cred *);
	void (*cred_getsecid)(const struct cred *, u32 *);
	void (*cred_getlsmprop)(const struct cred *, struct lsm_prop *);
	int (*kernel_act_as)(struct cred *, u32);
	int (*kernel_create_files_as)(struct cred *, struct inode *);
	int (*kernel_module_request)(char *);
	int (*kernel_load_data)(enum kernel_load_data_id, bool);
	int (*kernel_post_load_data)(char *, loff_t, enum kernel_load_data_id, char *);
	int (*kernel_read_file)(struct file *, enum kernel_read_file_id, bool);
	int (*kernel_post_read_file)(struct file *, char *, loff_t, enum kernel_read_file_id);
	int (*task_fix_setuid)(struct cred *, const struct cred *, int);
	int (*task_fix_setgid)(struct cred *, const struct cred *, int);
	int (*task_fix_setgroups)(struct cred *, const struct cred *);
	int (*task_setpgid)(struct task_struct *, pid_t);
	int (*task_getpgid)(struct task_struct *);
	int (*task_getsid)(struct task_struct *);
	void (*current_getlsmprop_subj)(struct lsm_prop *);
	void (*task_getlsmprop_obj)(struct task_struct *, struct lsm_prop *);
	int (*task_setnice)(struct task_struct *, int);
	int (*task_setioprio)(struct task_struct *, int);
	int (*task_getioprio)(struct task_struct *);
	int (*task_prlimit)(const struct cred *, const struct cred *, unsigned int);
	int (*task_setrlimit)(struct task_struct *, unsigned int, struct rlimit *);
	int (*task_setscheduler)(struct task_struct *);
	int (*task_getscheduler)(struct task_struct *);
	int (*task_movememory)(struct task_struct *);
	int (*task_kill)(struct task_struct *, struct kernel_siginfo *, int, const struct cred *);
	int (*task_prctl)(int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	void (*task_to_inode)(struct task_struct *, struct inode *);
	int (*userns_create)(const struct cred *);
	int (*ipc_permission)(struct kern_ipc_perm *, short int);
	void (*ipc_getlsmprop)(struct kern_ipc_perm *, struct lsm_prop *);
	int (*msg_msg_alloc_security)(struct msg_msg *);
	void (*msg_msg_free_security)(struct msg_msg *);
	int (*msg_queue_alloc_security)(struct kern_ipc_perm *);
	void (*msg_queue_free_security)(struct kern_ipc_perm *);
	int (*msg_queue_associate)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgctl)(struct kern_ipc_perm *, int);
	int (*msg_queue_msgsnd)(struct kern_ipc_perm *, struct msg_msg *, int);
	int (*msg_queue_msgrcv)(struct kern_ipc_perm *, struct msg_msg *, struct task_struct *, long int, int);
	int (*shm_alloc_security)(struct kern_ipc_perm *);
	void (*shm_free_security)(struct kern_ipc_perm *);
	int (*shm_associate)(struct kern_ipc_perm *, int);
	int (*shm_shmctl)(struct kern_ipc_perm *, int);
	int (*shm_shmat)(struct kern_ipc_perm *, char *, int);
	int (*sem_alloc_security)(struct kern_ipc_perm *);
	void (*sem_free_security)(struct kern_ipc_perm *);
	int (*sem_associate)(struct kern_ipc_perm *, int);
	int (*sem_semctl)(struct kern_ipc_perm *, int);
	int (*sem_semop)(struct kern_ipc_perm *, struct sembuf *, unsigned int, int);
	int (*netlink_send)(struct sock *, struct sk_buff *);
	void (*d_instantiate)(struct dentry *, struct inode *);
	int (*getselfattr)(unsigned int, struct lsm_ctx *, u32 *, u32);
	int (*setselfattr)(unsigned int, struct lsm_ctx *, u32, u32);
	int (*getprocattr)(struct task_struct *, const char *, char **);
	int (*setprocattr)(const char *, void *, size_t);
	int (*ismaclabel)(const char *);
	int (*secid_to_secctx)(u32, struct lsm_context *);
	int (*lsmprop_to_secctx)(struct lsm_prop *, struct lsm_context *);
	int (*secctx_to_secid)(const char *, u32, u32 *);
	void (*release_secctx)(struct lsm_context *);
	void (*inode_invalidate_secctx)(struct inode *);
	int (*inode_notifysecctx)(struct inode *, void *, u32);
	int (*inode_setsecctx)(struct dentry *, void *, u32);
	int (*inode_getsecctx)(struct inode *, struct lsm_context *);
	int (*unix_stream_connect)(struct sock *, struct sock *, struct sock *);
	int (*unix_may_send)(struct socket *, struct socket *);
	int (*socket_create)(int, int, int, int);
	int (*socket_post_create)(struct socket *, int, int, int, int);
	int (*socket_socketpair)(struct socket *, struct socket *);
	int (*socket_bind)(struct socket *, struct sockaddr *, int);
	int (*socket_connect)(struct socket *, struct sockaddr *, int);
	int (*socket_listen)(struct socket *, int);
	int (*socket_accept)(struct socket *, struct socket *);
	int (*socket_sendmsg)(struct socket *, struct msghdr *, int);
	int (*socket_recvmsg)(struct socket *, struct msghdr *, int, int);
	int (*socket_getsockname)(struct socket *);
	int (*socket_getpeername)(struct socket *);
	int (*socket_getsockopt)(struct socket *, int, int);
	int (*socket_setsockopt)(struct socket *, int, int);
	int (*socket_shutdown)(struct socket *, int);
	int (*socket_sock_rcv_skb)(struct sock *, struct sk_buff *);
	int (*socket_getpeersec_stream)(struct socket *, sockptr_t, sockptr_t, unsigned int);
	int (*socket_getpeersec_dgram)(struct socket *, struct sk_buff *, u32 *);
	int (*sk_alloc_security)(struct sock *, int, gfp_t);
	void (*sk_free_security)(struct sock *);
	void (*sk_clone_security)(const struct sock *, struct sock *);
	void (*sk_getsecid)(const struct sock *, u32 *);
	void (*sock_graft)(struct sock *, struct socket *);
	int (*inet_conn_request)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*inet_csk_clone)(struct sock *, const struct request_sock *);
	void (*inet_conn_established)(struct sock *, struct sk_buff *);
	int (*secmark_relabel_packet)(u32);
	void (*secmark_refcount_inc)(void);
	void (*secmark_refcount_dec)(void);
	void (*req_classify_flow)(const struct request_sock *, struct flowi_common *);
	int (*tun_dev_alloc_security)(void *);
	int (*tun_dev_create)(void);
	int (*tun_dev_attach_queue)(void *);
	int (*tun_dev_attach)(struct sock *, void *);
	int (*tun_dev_open)(void *);
	int (*sctp_assoc_request)(struct sctp_association *, struct sk_buff *);
	int (*sctp_bind_connect)(struct sock *, int, struct sockaddr *, int);
	void (*sctp_sk_clone)(struct sctp_association *, struct sock *, struct sock *);
	int (*sctp_assoc_established)(struct sctp_association *, struct sk_buff *);
	int (*mptcp_add_subflow)(struct sock *, struct sock *);
	int (*key_alloc)(struct key *, const struct cred *, long unsigned int);
	int (*key_permission)(key_ref_t, const struct cred *, enum key_need_perm);
	int (*key_getsecurity)(struct key *, char **);
	void (*key_post_create_or_update)(struct key *, struct key *, const void *, size_t, long unsigned int, bool);
	int (*audit_rule_init)(u32, u32, char *, void **, gfp_t);
	int (*audit_rule_known)(struct audit_krule *);
	int (*audit_rule_match)(struct lsm_prop *, u32, u32, void *);
	void (*audit_rule_free)(void *);
	int (*bpf)(int, union bpf_attr *, unsigned int);
	int (*bpf_map)(struct bpf_map *, fmode_t);
	int (*bpf_prog)(struct bpf_prog *);
	int (*bpf_map_create)(struct bpf_map *, union bpf_attr *, struct bpf_token *);
	void (*bpf_map_free)(struct bpf_map *);
	int (*bpf_prog_load)(struct bpf_prog *, union bpf_attr *, struct bpf_token *);
	void (*bpf_prog_free)(struct bpf_prog *);
	int (*bpf_token_create)(struct bpf_token *, union bpf_attr *, const struct path *);
	void (*bpf_token_free)(struct bpf_token *);
	int (*bpf_token_cmd)(const struct bpf_token *, enum bpf_cmd);
	int (*bpf_token_capable)(const struct bpf_token *, int);
	int (*locked_down)(enum lockdown_reason);
	int (*perf_event_open)(struct perf_event_attr *, int);
	int (*perf_event_alloc)(struct perf_event *);
	int (*perf_event_read)(struct perf_event *);
	int (*perf_event_write)(struct perf_event *);
	int (*uring_override_creds)(const struct cred *);
	int (*uring_sqpoll)(void);
	int (*uring_cmd)(struct io_uring_cmd *);
	void (*initramfs_populated)(void);
	int (*bdev_alloc_security)(struct block_device *);
	void (*bdev_free_security)(struct block_device *);
	int (*bdev_setintegrity)(struct block_device *, enum lsm_integrity_type, const void *, size_t);
	void *lsm_func_addr;
};

struct security_hook_list {
	struct lsm_static_call *scalls;
	union security_list_options hook;
	const struct lsm_id *lsmid;
};

struct seg6_local_lwt;

struct seg6_local_lwtunnel_ops {
	int (*build_state)(struct seg6_local_lwt *, const void *, struct netlink_ext_ack *);
	void (*destroy_state)(struct seg6_local_lwt *);
};

struct seg6_action_desc {
	int action;
	long unsigned int attrs;
	long unsigned int optattrs;
	int (*input)(struct sk_buff *, struct seg6_local_lwt *);
	int static_headroom;
	struct seg6_local_lwtunnel_ops slwt_ops;
};

struct seg6_action_param {
	int (*parse)(struct nlattr **, struct seg6_local_lwt *, struct netlink_ext_ack *);
	int (*put)(struct sk_buff *, struct seg6_local_lwt *);
	int (*cmp)(struct seg6_local_lwt *, struct seg6_local_lwt *);
	void (*destroy)(struct seg6_local_lwt *);
};

struct seg6_bpf_srh_state {
	local_lock_t bh_lock;
	struct ipv6_sr_hdr *srh;
	u16 hdrlen;
	bool valid;
};

struct seg6_end_dt_info {
	enum seg6_end_dt_mode mode;
	struct net *net;
	int vrf_ifindex;
	int vrf_table;
	u16 family;
};

struct seg6_flavors_info {
	__u32 flv_ops;
	__u8 lcblock_bits;
	__u8 lcnode_func_bits;
};

struct seg6_hmac_algo {
	u8 alg_id;
	char name[64];
	struct crypto_shash **tfms;
	struct shash_desc **shashs;
};

struct seg6_hmac_info {
	struct rhash_head node;
	struct callback_head rcu;
	u32 hmackeyid;
	char secret[64];
	u8 slen;
	u8 alg_id;
};

struct seg6_iptunnel_encap {
	int mode;
	struct ipv6_sr_hdr srh[0];
};

struct seg6_local_counters {
	__u64 packets;
	__u64 bytes;
	__u64 errors;
};

struct seg6_local_lwt {
	int action;
	struct ipv6_sr_hdr *srh;
	int table;
	struct in_addr nh4;
	struct in6_addr nh6;
	int iif;
	int oif;
	struct bpf_lwt_prog bpf;
	struct seg6_end_dt_info dt_info;
	struct seg6_flavors_info flv_info;
	struct pcpu_seg6_local_counters *pcpu_counters;
	int headroom;
	struct seg6_action_desc *desc;
	long unsigned int parsed_optattrs;
};

struct seg6_lwt {
	struct dst_cache cache;
	struct seg6_iptunnel_encap tuninfo[0];
};

struct seg6_pernet_data {
	struct mutex lock;
	struct in6_addr *tun_src;
	struct rhashtable hmac_infos;
};

struct select_data {
	struct dentry *start;
	union {
		long int found;
		struct dentry *victim;
	};
	struct list_head dispose;
};

struct sem {
	int semval;
	struct pid *sempid;
	spinlock_t lock;
	struct list_head pending_alter;
	struct list_head pending_const;
	time64_t sem_otime;
};

struct sem_array {
	struct kern_ipc_perm sem_perm;
	time64_t sem_ctime;
	struct list_head pending_alter;
	struct list_head pending_const;
	struct list_head list_id;
	int sem_nsems;
	int complex_count;
	unsigned int use_global_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sem sems[0];
};

struct sem_undo;

struct sem_queue {
	struct list_head list;
	struct task_struct *sleeper;
	struct sem_undo *undo;
	struct pid *pid;
	int status;
	struct sembuf *sops;
	struct sembuf *blocking;
	int nsops;
	bool alter;
	bool dupsop;
};

struct sem_undo_list;

struct sem_undo {
	struct list_head list_proc;
	struct callback_head rcu;
	struct sem_undo_list *ulp;
	struct list_head list_id;
	int semid;
	short int semadj[0];
};

struct sem_undo_list {
	refcount_t refcnt;
	spinlock_t lock;
	struct list_head list_proc;
};

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

struct sembuf {
	short unsigned int sem_num;
	short int sem_op;
	short int sem_flg;
};

struct semid64_ds {
	struct ipc64_perm sem_perm;
	__kernel_long_t sem_otime;
	__kernel_ulong_t __unused1;
	__kernel_long_t sem_ctime;
	__kernel_ulong_t __unused2;
	__kernel_ulong_t sem_nsems;
	__kernel_ulong_t __unused3;
	__kernel_ulong_t __unused4;
};

struct semid_ds {
	struct ipc_perm sem_perm;
	__kernel_old_time_t sem_otime;
	__kernel_old_time_t sem_ctime;
	struct sem *sem_base;
	struct sem_queue *sem_pending;
	struct sem_queue **sem_pending_last;
	struct sem_undo *undo;
	short unsigned int sem_nsems;
};

struct seminfo {
	int semmap;
	int semmni;
	int semmns;
	int semmnu;
	int semmsl;
	int semopm;
	int semume;
	int semusz;
	int semvmx;
	int semaem;
};

struct send_ctx {
	struct file *send_filp;
	loff_t send_off;
	char *send_buf;
	u32 send_size;
	u32 send_max_size;
	bool put_data;
	struct page **send_buf_pages;
	u64 flags;
	u32 proto;
	struct btrfs_root *send_root;
	struct btrfs_root *parent_root;
	struct clone_root *clone_roots;
	int clone_roots_cnt;
	struct btrfs_path *left_path;
	struct btrfs_path *right_path;
	struct btrfs_key *cmp_key;
	u64 last_reloc_trans;
	u64 cur_ino;
	u64 cur_inode_gen;
	u64 cur_inode_size;
	u64 cur_inode_mode;
	u64 cur_inode_rdev;
	u64 cur_inode_last_extent;
	u64 cur_inode_next_write_offset;
	bool cur_inode_new;
	bool cur_inode_new_gen;
	bool cur_inode_deleted;
	bool ignore_cur_inode;
	bool cur_inode_needs_verity;
	void *verity_descriptor;
	u64 send_progress;
	struct list_head new_refs;
	struct list_head deleted_refs;
	struct btrfs_lru_cache name_cache;
	struct inode *cur_inode;
	struct file_ra_state ra;
	u64 page_cache_clear_start;
	bool clean_page_cache;
	struct rb_root pending_dir_moves;
	struct rb_root waiting_dir_moves;
	struct rb_root orphan_dirs;
	struct rb_root rbtree_new_refs;
	struct rb_root rbtree_deleted_refs;
	struct btrfs_lru_cache backref_cache;
	u64 backref_cache_last_reloc_trans;
	struct btrfs_lru_cache dir_created_cache;
	struct btrfs_lru_cache dir_utimes_cache;
};

struct virtnet_sq_stats {
	struct u64_stats_sync syncp;
	u64_stats_t packets;
	u64_stats_t bytes;
	u64_stats_t xdp_tx;
	u64_stats_t xdp_tx_drops;
	u64_stats_t kicks;
	u64_stats_t tx_timeouts;
	u64_stats_t stop;
	u64_stats_t wake;
};

struct send_queue {
	struct virtqueue *vq;
	struct scatterlist sg[19];
	char name[16];
	struct virtnet_sq_stats stats;
	struct virtnet_interrupt_coalesce intr_coal;
	struct napi_struct napi;
	bool reset;
	struct xsk_buff_pool *xsk_pool;
	dma_addr_t xsk_hdr_dma_addr;
};

struct send_signal_irq_work {
	struct irq_work irq_work;
	struct task_struct *task;
	u32 sig;
	enum pid_type type;
	bool has_siginfo;
	struct kernel_siginfo info;
};

struct sensor_device_attribute {
	struct device_attribute dev_attr;
	int index;
};

struct seqDef_s {
	U32 offBase;
	U16 litLength;
	U16 mlBase;
};

struct seq_operations {
	void * (*start)(struct seq_file *, loff_t *);
	void (*stop)(struct seq_file *, void *);
	void * (*next)(struct seq_file *, void *, loff_t *);
	int (*show)(struct seq_file *, void *);
};

struct serial8250_config {
	const char *name;
	short unsigned int fifo_size;
	short unsigned int tx_loadsz;
	unsigned char fcr;
	unsigned char rxtrig_bytes[4];
	unsigned int flags;
};

struct serial_ctrl_device {
	struct device dev;
	struct ida port_ida;
};

struct serial_icounter_struct {
	int cts;
	int dsr;
	int rng;
	int dcd;
	int rx;
	int tx;
	int frame;
	int overrun;
	int parity;
	int brk;
	int buf_overrun;
	int reserved[9];
};

struct serial_in_rdev {
	struct rb_root_cached serial_rb;
	spinlock_t serial_lock;
	wait_queue_head_t serial_io_wait;
};

struct serial_port_device {
	struct device dev;
	struct uart_port *port;
	unsigned int tx_enabled: 1;
};

struct serial_private {
	struct pci_dev *dev;
	unsigned int nr;
	struct pci_serial_quirk *quirk;
	const struct pciserial_board *board;
	int line[0];
};

struct serial_struct {
	int type;
	int line;
	unsigned int port;
	int irq;
	int flags;
	int xmit_fifo_size;
	int custom_divisor;
	int baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char[1];
	int hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	long unsigned int iomap_base;
};

typedef struct serio *class_serio_pause_rx_t;

struct serio_device_id {
	__u8 type;
	__u8 extra;
	__u8 id;
	__u8 proto;
};

struct serio_driver;

struct serio {
	void *port_data;
	char name[32];
	char phys[32];
	char firmware_id[128];
	bool manual_bind;
	struct serio_device_id id;
	spinlock_t lock;
	int (*write)(struct serio *, unsigned char);
	int (*open)(struct serio *);
	void (*close)(struct serio *);
	int (*start)(struct serio *);
	void (*stop)(struct serio *);
	struct serio *parent;
	struct list_head child_node;
	struct list_head children;
	unsigned int depth;
	struct serio_driver *drv;
	struct mutex drv_mutex;
	struct device dev;
	struct list_head node;
	struct mutex *ps2_cmd_mutex;
};

struct serio_driver {
	const char *description;
	const struct serio_device_id *id_table;
	bool manual_bind;
	void (*write_wakeup)(struct serio *);
	irqreturn_t (*interrupt)(struct serio *, unsigned char, unsigned int);
	int (*connect)(struct serio *, struct serio_driver *);
	int (*reconnect)(struct serio *);
	int (*fast_reconnect)(struct serio *);
	void (*disconnect)(struct serio *);
	void (*cleanup)(struct serio *);
	struct device_driver driver;
};

struct serio_event {
	enum serio_event_type type;
	void *object;
	struct module *owner;
	struct list_head node;
};

struct serport {
	struct tty_struct *tty;
	wait_queue_head_t wait;
	struct serio *serio;
	struct serio_device_id id;
	spinlock_t lock;
	long unsigned int flags;
};

struct service_range {
	u32 lower;
	u32 upper;
	struct rb_node tree_node;
	u32 max;
	struct list_head local_publ;
	struct list_head all_publ;
};

struct set_adt_elem {
	ip_set_id_t id;
	ip_set_id_t refid;
	int before;
};

struct set_affinity_pending {
	refcount_t refs;
	unsigned int stop_pending;
	struct completion done;
	struct cpu_stop_work stop_work;
	struct migration_arg arg;
};

struct set_elem {
	struct callback_head rcu;
	struct list_head list;
	struct ip_set *set;
	ip_set_id_t id;
};

struct set_event_iter {
	enum set_event_iter_type type;
	union {
		struct trace_event_file *file;
		struct event_mod_load *event_mod;
	};
};

struct set_mtrr_data {
	long unsigned int smp_base;
	long unsigned int smp_size;
	unsigned int smp_reg;
	mtrr_type smp_type;
};

struct set_proto_ctx_engines {
	struct drm_i915_private *i915;
	unsigned int num_engines;
	struct i915_gem_proto_engine *engines;
};

struct setup_data_node {
	u64 paddr;
	u32 type;
	u32 len;
};

struct setup_indirect {
	__u32 type;
	__u32 reserved;
	__u64 len;
	__u64 addr;
};

struct sev_config {
	__u64 debug: 1;
	__u64 ghcbs_initialized: 1;
	__u64 use_cas: 1;
	__u64 __reserved: 61;
};

struct severity {
	u64 mask;
	u64 result;
	unsigned char sev;
	short unsigned int mcgmask;
	short unsigned int mcgres;
	unsigned char ser;
	unsigned char context;
	unsigned char excp;
	unsigned char covered;
	unsigned int cpu_vfm;
	unsigned char cpu_minstepping;
	unsigned char bank_lo;
	unsigned char bank_hi;
	char *msg;
};

struct sfb_bucket {
	u16 qlen;
	u16 p_mark;
};

struct sfb_bins {
	siphash_key_t perturbation;
	struct sfb_bucket bins[128];
};

struct sfb_sched_data {
	struct Qdisc *qdisc;
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	long unsigned int rehash_interval;
	long unsigned int warmup_time;
	u32 max;
	u32 bin_size;
	u32 increment;
	u32 decrement;
	u32 limit;
	u32 penalty_rate;
	u32 penalty_burst;
	u32 tokens_avail;
	long unsigned int rehash_time;
	long unsigned int token_time;
	u8 slot;
	bool double_buffering;
	struct sfb_bins bins[2];
	struct {
		u32 earlydrop;
		u32 penaltydrop;
		u32 bucketdrop;
		u32 queuedrop;
		u32 childdrop;
		u32 marked;
	} stats;
};

struct sfb_skb_cb {
	u32 hashes[2];
};

struct sfc_lock_data {
	i915_reg_t lock_reg;
	i915_reg_t ack_reg;
	i915_reg_t usage_reg;
	u32 lock_bit;
	u32 ack_bit;
	u32 usage_bit;
	u32 reset_bit;
};

struct sfp_eeprom_base {
	u8 phys_id;
	u8 phys_ext_id;
	u8 connector;
	u8 if_1x_copper_passive: 1;
	u8 if_1x_copper_active: 1;
	u8 if_1x_lx: 1;
	u8 if_1x_sx: 1;
	u8 e10g_base_sr: 1;
	u8 e10g_base_lr: 1;
	u8 e10g_base_lrm: 1;
	u8 e10g_base_er: 1;
	u8 sonet_oc3_short_reach: 1;
	u8 sonet_oc3_smf_intermediate_reach: 1;
	u8 sonet_oc3_smf_long_reach: 1;
	u8 unallocated_5_3: 1;
	u8 sonet_oc12_short_reach: 1;
	u8 sonet_oc12_smf_intermediate_reach: 1;
	u8 sonet_oc12_smf_long_reach: 1;
	u8 unallocated_5_7: 1;
	u8 sonet_oc48_short_reach: 1;
	u8 sonet_oc48_intermediate_reach: 1;
	u8 sonet_oc48_long_reach: 1;
	u8 sonet_reach_bit2: 1;
	u8 sonet_reach_bit1: 1;
	u8 sonet_oc192_short_reach: 1;
	u8 escon_smf_1310_laser: 1;
	u8 escon_mmf_1310_led: 1;
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e_base_bx10: 1;
	u8 e_base_px: 1;
	u8 fc_tech_electrical_inter_enclosure: 1;
	u8 fc_tech_lc: 1;
	u8 fc_tech_sa: 1;
	u8 fc_ll_m: 1;
	u8 fc_ll_l: 1;
	u8 fc_ll_i: 1;
	u8 fc_ll_s: 1;
	u8 fc_ll_v: 1;
	u8 unallocated_8_0: 1;
	u8 unallocated_8_1: 1;
	u8 sfp_ct_passive: 1;
	u8 sfp_ct_active: 1;
	u8 fc_tech_ll: 1;
	u8 fc_tech_sl: 1;
	u8 fc_tech_sn: 1;
	u8 fc_tech_electrical_intra_enclosure: 1;
	u8 fc_media_sm: 1;
	u8 unallocated_9_1: 1;
	u8 fc_media_m5: 1;
	u8 fc_media_m6: 1;
	u8 fc_media_tv: 1;
	u8 fc_media_mi: 1;
	u8 fc_media_tp: 1;
	u8 fc_media_tw: 1;
	u8 fc_speed_100: 1;
	u8 unallocated_10_1: 1;
	u8 fc_speed_200: 1;
	u8 fc_speed_3200: 1;
	u8 fc_speed_400: 1;
	u8 fc_speed_1600: 1;
	u8 fc_speed_800: 1;
	u8 fc_speed_1200: 1;
	u8 encoding;
	u8 br_nominal;
	u8 rate_id;
	u8 link_len[6];
	char vendor_name[16];
	u8 extended_cc;
	char vendor_oui[3];
	char vendor_pn[16];
	char vendor_rev[4];
	union {
		__be16 optical_wavelength;
		__be16 cable_compliance;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 reserved60_2: 6;
			u8 reserved61: 8;
		} passive;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 sff8431_lim: 1;
			u8 fc_pi_4_lim: 1;
			u8 reserved60_4: 4;
			u8 reserved61: 8;
		} active;
	};
	u8 reserved62;
	u8 cc_base;
};

struct sfp_eeprom_ext {
	__be16 options;
	u8 br_max;
	u8 br_min;
	char vendor_sn[16];
	char datecode[8];
	u8 diagmon;
	u8 enhopts;
	u8 sff8472_compliance;
	u8 cc_ext;
};

struct sfp_eeprom_id {
	struct sfp_eeprom_base base;
	struct sfp_eeprom_ext ext;
};

struct sfp_upstream_ops {
	void (*attach)(void *, struct sfp_bus *);
	void (*detach)(void *, struct sfp_bus *);
	int (*module_insert)(void *, const struct sfp_eeprom_id *);
	void (*module_remove)(void *);
	int (*module_start)(void *);
	void (*module_stop)(void *);
	void (*link_down)(void *);
	void (*link_up)(void *);
	int (*connect_phy)(void *, struct phy_device *);
	void (*disconnect_phy)(void *, struct phy_device *);
};

struct sfq_head {
	sfq_index next;
	sfq_index prev;
};

struct tc_sfqred_stats {
	__u32 prob_drop;
	__u32 forced_drop;
	__u32 prob_mark;
	__u32 forced_mark;
	__u32 prob_mark_head;
	__u32 forced_mark_head;
};

struct sfq_slot;

struct sfq_sched_data {
	int limit;
	unsigned int divisor;
	u8 headdrop;
	u8 maxdepth;
	siphash_key_t perturbation;
	u8 cur_depth;
	u8 flags;
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	sfq_index *ht;
	struct sfq_slot *slots;
	struct red_parms *red_parms;
	struct tc_sfqred_stats stats;
	struct sfq_slot *tail;
	struct sfq_head dep[128];
	unsigned int maxflows;
	int perturb_period;
	unsigned int quantum;
	struct timer_list perturb_timer;
	struct Qdisc *sch;
};

struct sfq_slot {
	struct sk_buff *skblist_next;
	struct sk_buff *skblist_prev;
	sfq_index qlen;
	sfq_index next;
	struct sfq_head dep;
	short unsigned int hash;
	int allot;
	unsigned int backlog;
	struct red_vars vars;
};

struct sg {
	struct ext4_group_info info;
	ext4_grpblk_t counters[18];
};

struct sg_append_table {
	struct sg_table sgt;
	struct scatterlist *prv;
	unsigned int total_nents;
};

struct sg_device {
	struct scsi_device *device;
	wait_queue_head_t open_wait;
	struct mutex open_rel_lock;
	int sg_tablesize;
	u32 index;
	struct list_head sfds;
	rwlock_t sfd_lock;
	atomic_t detaching;
	bool exclude;
	int open_cnt;
	char sgdebug;
	char name[32];
	struct cdev *cdev;
	struct kref d_ref;
};

typedef struct sg_device Sg_device;

struct sg_page_iter {
	struct scatterlist *sg;
	unsigned int sg_pgoffset;
	unsigned int __nents;
	int __pg_advance;
};

struct sg_dma_page_iter {
	struct sg_page_iter base;
};

struct sg_scatter_hold {
	short unsigned int k_use_sg;
	unsigned int sglist_len;
	unsigned int bufflen;
	struct page **pages;
	int page_order;
	char dio_in_use;
	unsigned char cmd_opcode;
};

typedef struct sg_scatter_hold Sg_scatter_hold;

struct sg_io_hdr {
	int interface_id;
	int dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	unsigned int dxfer_len;
	void *dxferp;
	unsigned char *cmdp;
	void *sbp;
	unsigned int timeout;
	unsigned int flags;
	int pack_id;
	void *usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	int resid;
	unsigned int duration;
	unsigned int info;
};

typedef struct sg_io_hdr sg_io_hdr_t;

struct sg_fd;

struct sg_request {
	struct list_head entry;
	struct sg_fd *parentfp;
	Sg_scatter_hold data;
	sg_io_hdr_t header;
	unsigned char sense_b[96];
	char res_used;
	char orphan;
	char sg_io_owned;
	char done;
	struct request *rq;
	struct bio *bio;
	struct execute_work ew;
};

typedef struct sg_request Sg_request;

struct sg_fd {
	struct list_head sfd_siblings;
	struct sg_device *parentdp;
	wait_queue_head_t read_wait;
	rwlock_t rq_list_lock;
	struct mutex f_mutex;
	int timeout;
	int timeout_user;
	Sg_scatter_hold reserve;
	struct list_head rq_list;
	struct fasync_struct *async_qp;
	Sg_request req_arr[16];
	char force_packid;
	char cmd_q;
	unsigned char next_cmd_len;
	char keep_orphan;
	char mmap_called;
	char res_in_use;
	struct kref f_ref;
	struct execute_work ew;
};

typedef struct sg_fd Sg_fd;

struct sg_header {
	int pack_len;
	int reply_len;
	int pack_id;
	int result;
	unsigned int twelve_byte: 1;
	unsigned int target_status: 5;
	unsigned int host_status: 8;
	unsigned int driver_status: 8;
	unsigned int other_flags: 10;
	unsigned char sense_buffer[16];
};

struct sg_io_v4 {
	__s32 guard;
	__u32 protocol;
	__u32 subprotocol;
	__u32 request_len;
	__u64 request;
	__u64 request_tag;
	__u32 request_attr;
	__u32 request_priority;
	__u32 request_extra;
	__u32 max_response_len;
	__u64 response;
	__u32 dout_iovec_count;
	__u32 dout_xfer_len;
	__u32 din_iovec_count;
	__u32 din_xfer_len;
	__u64 dout_xferp;
	__u64 din_xferp;
	__u32 timeout;
	__u32 flags;
	__u64 usr_ptr;
	__u32 spare_in;
	__u32 driver_status;
	__u32 transport_status;
	__u32 device_status;
	__u32 retry_delay;
	__u32 info;
	__u32 duration;
	__u32 response_len;
	__s32 din_resid;
	__s32 dout_resid;
	__u64 generated_tag;
	__u32 spare_out;
	__u32 padding;
};

struct sg_list {
	unsigned int n;
	unsigned int size;
	size_t len;
	struct scatterlist *sg;
};

struct sg_mapping_iter {
	struct page *page;
	void *addr;
	size_t length;
	size_t consumed;
	struct sg_page_iter piter;
	unsigned int __offset;
	unsigned int __remaining;
	unsigned int __flags;
};

struct sg_pool {
	size_t size;
	char *name;
	struct kmem_cache *slab;
	mempool_t *pool;
};

struct sg_proc_deviter {
	loff_t index;
	size_t max;
};

struct sg_req_info {
	char req_state;
	char orphan;
	char sg_io_owned;
	char problem;
	int pack_id;
	void *usr_ptr;
	unsigned int duration;
	int unused;
};

typedef struct sg_req_info sg_req_info_t;

struct sg_scsi_id {
	int host_no;
	int channel;
	int scsi_id;
	int lun;
	int scsi_type;
	short int h_cmd_per_lun;
	short int d_queue_depth;
	int unused[2];
};

typedef struct sg_scsi_id sg_scsi_id_t;

struct sgt_dma {
	struct scatterlist *sg;
	dma_addr_t dma;
	dma_addr_t max;
};

struct sha1_state {
	u32 state[5];
	u64 count;
	u8 buffer[64];
};

struct sha256_state {
	u32 state[8];
	u64 count;
	u8 buf[64];
};

struct sha3_state {
	u64 st[25];
	unsigned int rsiz;
	unsigned int rsizw;
	unsigned int partial;
	u8 buf[144];
};

struct sha512_state {
	u64 state[8];
	u64 count[2];
	u8 buf[128];
};

struct share_check {
	struct btrfs_backref_share_check_ctx *ctx;
	struct btrfs_root *root;
	u64 inum;
	u64 data_bytenr;
	u64 data_extent_gen;
	int share_count;
	int self_ref_count;
	bool have_delayed_delete_refs;
};

struct shared_policy {
	struct rb_root root;
	rwlock_t lock;
};

struct shash_alg {
	int (*init)(struct shash_desc *);
	int (*update)(struct shash_desc *, const u8 *, unsigned int);
	int (*final)(struct shash_desc *, u8 *);
	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*export)(struct shash_desc *, void *);
	int (*import)(struct shash_desc *, const void *);
	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_shash *);
	void (*exit_tfm)(struct crypto_shash *);
	int (*clone_tfm)(struct crypto_shash *, struct crypto_shash *);
	unsigned int descsize;
	union {
		struct {
			unsigned int digestsize;
			unsigned int statesize;
			struct crypto_alg base;
		};
		struct hash_alg_common halg;
	};
};

struct shash_instance {
	void (*free)(struct shash_instance *);
	union {
		struct {
			char head[104];
			struct crypto_instance base;
		} s;
		struct shash_alg alg;
	};
};

struct shm_file_data {
	int id;
	struct ipc_namespace *ns;
	struct file *file;
	const struct vm_operations_struct *vm_ops;
};

struct shm_info {
	int used_ids;
	__kernel_ulong_t shm_tot;
	__kernel_ulong_t shm_rss;
	__kernel_ulong_t shm_swp;
	__kernel_ulong_t swap_attempts;
	__kernel_ulong_t swap_successes;
};

struct shmem_falloc {
	wait_queue_head_t *waitq;
	long unsigned int start;
	long unsigned int next;
	long unsigned int nr_falloced;
	long unsigned int nr_unswapped;
};

struct shmem_inode_info {
	spinlock_t lock;
	unsigned int seals;
	long unsigned int flags;
	long unsigned int alloced;
	long unsigned int swapped;
	union {
		struct offset_ctx dir_offsets;
		struct {
			struct list_head shrinklist;
			struct list_head swaplist;
		};
	};
	struct timespec64 i_crtime;
	struct shared_policy policy;
	struct simple_xattrs xattrs;
	long unsigned int fallocend;
	unsigned int fsflags;
	atomic_t stop_eviction;
	struct inode vfs_inode;
};

struct shmem_quota_limits {
	qsize_t usrquota_bhardlimit;
	qsize_t usrquota_ihardlimit;
	qsize_t grpquota_bhardlimit;
	qsize_t grpquota_ihardlimit;
};

struct shmem_options {
	long long unsigned int blocks;
	long long unsigned int inodes;
	struct mempolicy *mpol;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	bool full_inums;
	int huge;
	int seen;
	bool noswap;
	short unsigned int quota_types;
	struct shmem_quota_limits qlimits;
};

struct shmem_sb_info {
	long unsigned int max_blocks;
	struct percpu_counter used_blocks;
	long unsigned int max_inodes;
	long unsigned int free_ispace;
	raw_spinlock_t stat_lock;
	umode_t mode;
	unsigned char huge;
	kuid_t uid;
	kgid_t gid;
	bool full_inums;
	bool noswap;
	ino_t next_ino;
	ino_t *ino_batch;
	struct mempolicy *mpol;
	spinlock_t shrinklist_lock;
	struct list_head shrinklist;
	long unsigned int shrinklist_len;
	struct shmem_quota_limits qlimits;
};

struct shmid64_ds {
	struct ipc64_perm shm_perm;
	__kernel_size_t shm_segsz;
	long int shm_atime;
	long int shm_dtime;
	long int shm_ctime;
	__kernel_pid_t shm_cpid;
	__kernel_pid_t shm_lpid;
	long unsigned int shm_nattch;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct shmid_ds {
	struct ipc_perm shm_perm;
	int shm_segsz;
	__kernel_old_time_t shm_atime;
	__kernel_old_time_t shm_dtime;
	__kernel_old_time_t shm_ctime;
	__kernel_ipc_pid_t shm_cpid;
	__kernel_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	void *shm_unused2;
	void *shm_unused3;
};

struct shmid_kernel {
	struct kern_ipc_perm shm_perm;
	struct file *shm_file;
	long unsigned int shm_nattch;
	long unsigned int shm_segsz;
	time64_t shm_atim;
	time64_t shm_dtim;
	time64_t shm_ctim;
	struct pid *shm_cprid;
	struct pid *shm_lprid;
	struct ucounts *mlock_ucounts;
	struct task_struct *shm_creator;
	struct list_head shm_clist;
	struct ipc_namespace *ns;
	long: 64;
	long: 64;
	long: 64;
};

struct shminfo {
	int shmmax;
	int shmmin;
	int shmmni;
	int shmseg;
	int shmall;
};

struct shminfo64 {
	long unsigned int shmmax;
	long unsigned int shmmin;
	long unsigned int shmmni;
	long unsigned int shmseg;
	long unsigned int shmall;
	long unsigned int __unused1;
	long unsigned int __unused2;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct shortname_info {
	unsigned char lower: 1;
	unsigned char upper: 1;
	unsigned char valid: 1;
};

struct show_busy_params {
	struct seq_file *m;
	struct blk_mq_hw_ctx *hctx;
};

struct shrink_control {
	gfp_t gfp_mask;
	int nid;
	long unsigned int nr_to_scan;
	long unsigned int nr_scanned;
	struct mem_cgroup *memcg;
};

struct shrinker {
	long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
	long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
	long int batch;
	int seeks;
	unsigned int flags;
	refcount_t refcount;
	struct completion done;
	struct callback_head rcu;
	void *private_data;
	struct list_head list;
	int id;
	atomic_long_t *nr_deferred;
};

struct shrinker_info_unit;

struct shrinker_info {
	struct callback_head rcu;
	int map_nr_max;
	struct shrinker_info_unit *unit[0];
};

struct shrinker_info_unit {
	atomic_long_t nr_deferred[64];
	long unsigned int map[1];
};

struct sig_alg {
	int (*sign)(struct crypto_sig *, const void *, unsigned int, void *, unsigned int);
	int (*verify)(struct crypto_sig *, const void *, unsigned int, const void *, unsigned int);
	int (*set_pub_key)(struct crypto_sig *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_sig *, const void *, unsigned int);
	unsigned int (*key_size)(struct crypto_sig *);
	unsigned int (*digest_size)(struct crypto_sig *);
	unsigned int (*max_size)(struct crypto_sig *);
	int (*init)(struct crypto_sig *);
	void (*exit)(struct crypto_sig *);
	struct crypto_alg base;
};

struct sig_instance {
	void (*free)(struct sig_instance *);
	union {
		struct {
			char head[72];
			struct crypto_instance base;
		};
		struct sig_alg alg;
	};
};

typedef struct sigevent sigevent_t;

struct sighand_struct {
	spinlock_t siglock;
	refcount_t count;
	wait_queue_head_t signalfd_wqh;
	struct k_sigaction action[64];
};

struct sigpending {
	struct list_head list;
	sigset_t signal;
};

struct task_cputime_atomic {
	atomic64_t utime;
	atomic64_t stime;
	atomic64_t sum_exec_runtime;
};

struct thread_group_cputimer {
	struct task_cputime_atomic cputime_atomic;
};

struct task_io_accounting {
	u64 rchar;
	u64 wchar;
	u64 syscr;
	u64 syscw;
	u64 read_bytes;
	u64 write_bytes;
	u64 cancelled_write_bytes;
};

struct taskstats;

struct tty_audit_buf;

struct signal_struct {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	int quick_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct *group_exec_task;
	int group_stop_count;
	unsigned int flags;
	struct core_state *core_state;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	unsigned int next_posix_timer_id;
	struct hlist_head posix_timers;
	struct hlist_head ignored_posix_timers;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid *pids[4];
	struct pid *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	seqlock_t stats_lock;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	long unsigned int cnvcsw;
	long unsigned int cnivcsw;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	long unsigned int cmin_flt;
	long unsigned int cmaj_flt;
	long unsigned int inblock;
	long unsigned int oublock;
	long unsigned int cinblock;
	long unsigned int coublock;
	long unsigned int maxrss;
	long unsigned int cmaxrss;
	struct task_io_accounting ioac;
	long long unsigned int sum_sched_runtime;
	struct rlimit rlim[16];
	struct pacct_struct pacct;
	struct taskstats *stats;
	unsigned int audit_tty;
	struct tty_audit_buf *tty_audit_buf;
	bool oom_flag_origin;
	short int oom_score_adj;
	short int oom_score_adj_min;
	struct mm_struct *oom_mm;
	struct mutex cred_guard_mutex;
	struct rw_semaphore exec_update_lock;
};

struct signalfd_ctx {
	sigset_t sigmask;
};

struct signalfd_siginfo {
	__u32 ssi_signo;
	__s32 ssi_errno;
	__s32 ssi_code;
	__u32 ssi_pid;
	__u32 ssi_uid;
	__s32 ssi_fd;
	__u32 ssi_tid;
	__u32 ssi_band;
	__u32 ssi_overrun;
	__u32 ssi_trapno;
	__s32 ssi_status;
	__s32 ssi_int;
	__u64 ssi_ptr;
	__u64 ssi_utime;
	__u64 ssi_stime;
	__u64 ssi_addr;
	__u16 ssi_addr_lsb;
	__u16 __pad2;
	__s32 ssi_syscall;
	__u64 ssi_call_addr;
	__u32 ssi_arch;
	__u8 __pad[28];
};

struct signature_hdr {
	uint8_t version;
	uint32_t timestamp;
	uint8_t algo;
	uint8_t hash;
	uint8_t keyid[8];
	uint8_t nmpi;
	char mpi[0];
} __attribute__((packed));

struct signature_v2_hdr {
	uint8_t type;
	uint8_t version;
	uint8_t hash_algo;
	__be32 keyid;
	__be16 sig_size;
	uint8_t sig[0];
} __attribute__((packed));

struct sigpool_entry {
	struct crypto_ahash *hash;
	const char *alg;
	struct kref kref;
	uint16_t needs_key: 1;
	uint16_t reserved: 15;
};

struct sigpool_scratch {
	local_lock_t bh_lock;
	void *pad;
};

struct sigset_argpack {
	sigset_t *p;
	size_t size;
};

struct sil164_priv {
	bool quiet;
};

struct simple_attr {
	int (*get)(void *, u64 *);
	int (*set)(void *, u64);
	char get_buf[24];
	char set_buf[24];
	void *data;
	const char *fmt;
	struct mutex mutex;
};

struct simple_transaction_argresp {
	ssize_t size;
	char data[0];
};

struct simple_xattr {
	struct rb_node rb_node;
	char *name;
	size_t size;
	char value[0];
};

struct sioc_mif_req6 {
	mifi_t mifi;
	long unsigned int icount;
	long unsigned int ocount;
	long unsigned int ibytes;
	long unsigned int obytes;
};

struct sioc_sg_req {
	struct in_addr src;
	struct in_addr grp;
	long unsigned int pktcnt;
	long unsigned int bytecnt;
	long unsigned int wrong_if;
};

struct sioc_sg_req6 {
	struct sockaddr_in6 src;
	struct sockaddr_in6 grp;
	long unsigned int pktcnt;
	long unsigned int bytecnt;
	long unsigned int wrong_if;
};

struct sioc_vif_req {
	vifi_t vifi;
	long unsigned int icount;
	long unsigned int ocount;
	long unsigned int ibytes;
	long unsigned int obytes;
};

struct sip_handler {
	const char *method;
	unsigned int len;
	int (*request)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, unsigned int);
	int (*response)(struct sk_buff *, unsigned int, unsigned int, const char **, unsigned int *, unsigned int, unsigned int);
};

struct sip_header {
	const char *name;
	const char *cname;
	const char *search;
	unsigned int len;
	unsigned int clen;
	unsigned int slen;
	int (*match_len)(const struct nf_conn *, const char *, const char *, int *);
};

struct sit_net {
	struct ip_tunnel *tunnels_r_l[16];
	struct ip_tunnel *tunnels_r[16];
	struct ip_tunnel *tunnels_l[16];
	struct ip_tunnel *tunnels_wc[1];
	struct ip_tunnel **tunnels[4];
	struct net_device *fb_tunnel_dev;
};

struct sk_buff__safe_rcu_or_null {
	struct sock *sk;
};

struct sk_buff_fclones {
	struct sk_buff skb1;
	struct sk_buff skb2;
	refcount_t fclone_ref;
};

struct sk_filter {
	refcount_t refcnt;
	struct callback_head rcu;
	struct bpf_prog *prog;
};

struct sk_psock_work_state {
	u32 len;
	u32 off;
};

struct sk_psock {
	struct sock *sk;
	struct sock *sk_redir;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 eval;
	bool redir_ingress;
	struct sk_msg *cork;
	struct sk_psock_progs progs;
	struct strparser strp;
	u32 copied_seq;
	u32 ingress_bytes;
	struct sk_buff_head ingress_skb;
	struct list_head ingress_msg;
	spinlock_t ingress_lock;
	long unsigned int state;
	struct list_head link;
	spinlock_t link_lock;
	refcount_t refcnt;
	void (*saved_unhash)(struct sock *);
	void (*saved_destroy)(struct sock *);
	void (*saved_close)(struct sock *, long int);
	void (*saved_write_space)(struct sock *);
	void (*saved_data_ready)(struct sock *);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	struct proto *sk_proto;
	struct mutex work_mutex;
	struct sk_psock_work_state work_state;
	struct delayed_work work;
	struct sock *sk_pair;
	struct rcu_work rwork;
};

struct sk_psock_link {
	struct list_head list;
	struct bpf_map *map;
	void *link_raw;
};

struct tls_msg {
	u8 control;
};

struct sk_skb_cb {
	unsigned char data[20];
	unsigned char pad[4];
	struct _strp_msg strp;
	struct tls_msg tls;
	u64 temp_reg;
};

struct skb_checksum_ops {
	__wsum (*update)(const void *, int, __wsum);
	__wsum (*combine)(__wsum, __wsum, int, int);
};

struct skb_ext {
	refcount_t refcnt;
	u8 offset[4];
	u8 chunks;
	long: 0;
	char data[0];
};

struct skb_frag {
	netmem_ref netmem;
	unsigned int len;
	unsigned int offset;
};

typedef struct skb_frag skb_frag_t;

struct skb_free_array {
	unsigned int skb_count;
	void *skb_array[16];
};

struct skb_gso_cb {
	union {
		int mac_offset;
		int data_offset;
	};
	int encap_level;
	__wsum csum;
	__u16 csum_start;
};

struct skb_seq_state {
	__u32 lower_offset;
	__u32 upper_offset;
	__u32 frag_idx;
	__u32 stepped_offset;
	struct sk_buff *root_skb;
	struct sk_buff *cur_skb;
	__u8 *frag_data;
	__u32 frag_off;
};

struct skb_shared_hwtstamps {
	union {
		ktime_t hwtstamp;
		void *netdev_data;
	};
};

struct xsk_tx_metadata_compl {
	__u64 *tx_timestamp;
};

struct skb_shared_info {
	__u8 flags;
	__u8 meta_len;
	__u8 nr_frags;
	__u8 tx_flags;
	short unsigned int gso_size;
	short unsigned int gso_segs;
	struct sk_buff *frag_list;
	union {
		struct skb_shared_hwtstamps hwtstamps;
		struct xsk_tx_metadata_compl xsk_meta;
	};
	unsigned int gso_type;
	u32 tskey;
	atomic_t dataref;
	union {
		struct {
			u32 xdp_frags_size;
			u32 xdp_frags_truesize;
		};
		void *destructor_arg;
	};
	skb_frag_t frags[17];
};

struct skbprio_sched_data {
	struct sk_buff_head qdiscs[64];
	struct gnet_stats_queue qstats[64];
	u16 highest_prio;
	u16 lowest_prio;
};

struct skcipher_alg {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	int (*export)(struct skcipher_request *, void *);
	int (*import)(struct skcipher_request *, const void *);
	int (*init)(struct crypto_skcipher *);
	void (*exit)(struct crypto_skcipher *);
	unsigned int walksize;
	union {
		struct {
			unsigned int min_keysize;
			unsigned int max_keysize;
			unsigned int ivsize;
			unsigned int chunksize;
			unsigned int statesize;
			struct crypto_alg base;
		};
		struct skcipher_alg_common co;
	};
};

struct skcipher_ctx_simple {
	struct crypto_cipher *cipher;
};

struct skcipher_instance {
	void (*free)(struct skcipher_instance *);
	union {
		struct {
			char head[88];
			struct crypto_instance base;
		} s;
		struct skcipher_alg alg;
	};
};

struct skcipher_walk {
	union {
		struct {
			void *addr;
		} virt;
	} src;
	union {
		struct {
			void *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	u8 *page;
	u8 *buffer;
	u8 *oiv;
	void *iv;
	unsigned int ivsize;
	int flags;
	unsigned int blocksize;
	unsigned int stride;
	unsigned int alignmask;
};

struct skl_dpll_regs {
	i915_reg_t ctl;
	i915_reg_t cfgcr1;
	i915_reg_t cfgcr2;
};

struct skl_hw_state {
	struct skl_ddb_entry ddb[8];
	struct skl_ddb_entry ddb_y[8];
	u16 min_ddb[8];
	u16 interim_ddb[8];
	struct skl_pipe_wm wm;
};

struct skl_plane_ddb_iter {
	u64 data_rate;
	u16 start;
	u16 size;
};

struct skl_wm_params {
	bool x_tiled;
	bool y_tiled;
	bool rc_surface;
	bool is_planar;
	u32 width;
	u8 cpp;
	u32 plane_pixel_rate;
	u32 y_min_scanlines;
	u32 plane_bytes_per_line;
	uint_fixed_16_16_t plane_blocks_per_line;
	uint_fixed_16_16_t y_tile_minimum;
	u32 linetime_us;
	u32 dbuf_block_size;
};

struct skl_wrpll_context {
	u64 min_deviation;
	u64 central_freq;
	u64 dco_freq;
	unsigned int p;
};

struct sku_microcode {
	u32 vfm;
	u8 stepping;
	u32 microcode;
};

struct slab {
	long unsigned int __page_flags;
	struct kmem_cache *slab_cache;
	union {
		struct {
			union {
				struct list_head slab_list;
				struct {
					struct slab *next;
					int slabs;
				};
			};
			union {
				struct {
					void *freelist;
					union {
						long unsigned int counters;
						struct {
							unsigned int inuse: 16;
							unsigned int objects: 15;
							unsigned int frozen: 1;
						};
					};
				};
				freelist_aba_t freelist_counter;
			};
		};
		struct callback_head callback_head;
	};
	unsigned int __page_type;
	atomic_t __page_refcount;
	long unsigned int obj_exts;
};

struct slab_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kmem_cache *, char *);
	ssize_t (*store)(struct kmem_cache *, const char *, size_t);
};

struct slabinfo {
	long unsigned int active_objs;
	long unsigned int num_objs;
	long unsigned int active_slabs;
	long unsigned int num_slabs;
	long unsigned int shared_avail;
	unsigned int limit;
	unsigned int batchcount;
	unsigned int shared;
	unsigned int objects_per_slab;
	unsigned int cache_order;
};

struct slpc_override_params {
	u32 bits[8];
	u32 values[256];
};

struct slpc_shared_data_header {
	u32 size;
	u32 global_state;
	u32 display_data_addr;
};

struct slpc_task_state_data {
	union {
		u32 task_status_padding;
		struct {
			u32 status;
		};
	};
	union {
		u32 freq_padding;
		struct {
			u32 freq;
		};
	};
};

struct slpc_shared_data {
	struct slpc_shared_data_header header;
	u8 shared_data_header_pad[52];
	u8 platform_info_pad[64];
	struct slpc_task_state_data task_state_data;
	u8 task_state_data_pad[56];
	struct slpc_override_params override_params;
	u8 override_params_pad[32];
	u8 shared_data_pad[2816];
	u8 reserved_mode_definition[4096];
};

struct slub_flush_work {
	struct work_struct work;
	struct kmem_cache *s;
	bool skip;
};

struct sm3_state {
	u32 state[8];
	u64 count;
	u8 buffer[64];
};

struct sm4_ctx {
	u32 rkey_enc[32];
	u32 rkey_dec[32];
};

struct smca_hwid;

struct smca_bank {
	const struct smca_hwid *hwid;
	u32 id;
	u8 sysfs_id;
};

struct smca_hwid {
	unsigned int bank_type;
	u32 hwid_mcatype;
};

struct smp_alt_module {
	struct module *mod;
	char *name;
	const s32 *locks;
	const s32 *locks_end;
	u8 *text;
	u8 *text_end;
	struct list_head next;
};

struct smp_call_on_cpu_struct {
	struct work_struct work;
	struct completion done;
	int (*func)(void *);
	void *data;
	int ret;
	int cpu;
};

struct smp_hotplug_thread {
	struct task_struct **store;
	struct list_head list;
	int (*thread_should_run)(unsigned int);
	void (*thread_fn)(unsigned int);
	void (*create)(unsigned int);
	void (*setup)(unsigned int);
	void (*cleanup)(unsigned int, bool);
	void (*park)(unsigned int);
	void (*unpark)(unsigned int);
	bool selfparking;
	const char *thread_comm;
};

struct smp_ops {
	void (*smp_prepare_boot_cpu)(void);
	void (*smp_prepare_cpus)(unsigned int);
	void (*smp_cpus_done)(unsigned int);
	void (*stop_other_cpus)(int);
	void (*crash_stop_other_cpus)(void);
	void (*smp_send_reschedule)(int);
	void (*cleanup_dead_cpu)(unsigned int);
	void (*poll_sync_state)(void);
	int (*kick_ap_alive)(unsigned int, struct task_struct *);
	int (*cpu_disable)(void);
	void (*cpu_die)(unsigned int);
	void (*play_dead)(void);
	void (*stop_this_cpu)(void);
	void (*send_call_func_ipi)(const struct cpumask *);
	void (*send_call_func_single_ipi)(int);
};

struct smpboot_thread_data {
	unsigned int cpu;
	unsigned int status;
	struct smp_hotplug_thread *ht;
};

struct snapshot_handle {
	unsigned int cur;
	void *buffer;
	int sync_read;
};

struct snapshot_data {
	struct snapshot_handle handle;
	int swap;
	int mode;
	bool frozen;
	bool ready;
	bool platform_support;
	bool free_bitmaps;
	dev_t dev;
};

struct snmp_ctx {
	unsigned char *begin;
	__sum16 *check;
	__be32 from;
	__be32 to;
};

struct snmp_mib {
	const char *name;
	int entry;
};

struct so_timestamping {
	int flags;
	int bind_phc;
};

struct sock_bh_locked {
	struct sock *sock;
	local_lock_t bh_lock;
};

struct sock_diag_handler {
	struct module *owner;
	__u8 family;
	int (*dump)(struct sk_buff *, struct nlmsghdr *);
	int (*get_info)(struct sk_buff *, struct sock *);
	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
};

struct sock_diag_inet_compat {
	struct module *owner;
	int (*fn)(struct sk_buff *, struct nlmsghdr *);
};

struct sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
};

struct sock_ee_data_rfc4884 {
	__u16 len;
	__u8 flags;
	__u8 reserved;
};

struct sock_extended_err {
	__u32 ee_errno;
	__u8 ee_origin;
	__u8 ee_type;
	__u8 ee_code;
	__u8 ee_pad;
	__u32 ee_info;
	union {
		__u32 ee_data;
		struct sock_ee_data_rfc4884 ee_rfc4884;
	};
};

struct sock_exterr_skb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sock_extended_err ee;
	u16 addr_offset;
	__be16 port;
	u8 opt_stats: 1;
	u8 unused: 7;
};

struct sock_fprog {
	short unsigned int len;
	struct sock_filter *filter;
};

struct sock_fprog_kern {
	u16 len;
	struct sock_filter *filter;
};

struct sock_hash_seq_info {
	struct bpf_map *map;
	struct bpf_shtab *htab;
	u32 bucket_id;
};

struct sock_map_seq_info {
	struct bpf_map *map;
	struct sock *sk;
	u32 index;
};

struct sock_reuseport {
	struct callback_head rcu;
	u16 max_socks;
	u16 num_socks;
	u16 num_closed_socks;
	u16 incoming_cpu;
	unsigned int synq_overflow_ts;
	unsigned int reuseport_id;
	unsigned int bind_inany: 1;
	unsigned int has_conns: 1;
	struct bpf_prog *prog;
	struct sock *socks[0];
};

struct sock_skb_cb {
	u32 dropcount;
};

struct sock_txtime {
	__kernel_clockid_t clockid;
	__u32 flags;
};

struct sock_xprt {
	struct rpc_xprt xprt;
	struct socket *sock;
	struct sock *inet;
	struct file *file;
	struct {
		struct {
			__be32 fraghdr;
			__be32 xid;
			__be32 calldir;
		};
		u32 offset;
		u32 len;
		long unsigned int copied;
	} recv;
	struct {
		u32 offset;
	} xmit;
	long unsigned int sock_state;
	struct delayed_work connect_worker;
	struct work_struct error_worker;
	struct work_struct recv_worker;
	struct mutex recv_mutex;
	struct completion handshake_done;
	struct __kernel_sockaddr_storage srcaddr;
	short unsigned int srcport;
	int xprt_err;
	struct rpc_clnt *clnt;
	size_t rcvsize;
	size_t sndsize;
	struct rpc_timeout tcp_timeout;
	void (*old_data_ready)(struct sock *);
	void (*old_state_change)(struct sock *);
	void (*old_write_space)(struct sock *);
	void (*old_error_report)(struct sock *);
};

struct sockaddr_alg_new {
	__u16 salg_family;
	__u8 salg_type[14];
	__u32 salg_feat;
	__u32 salg_mask;
	__u8 salg_name[0];
};

struct sockaddr_at {
	__kernel_sa_family_t sat_family;
	__u8 sat_port;
	struct atalk_addr sat_addr;
	char sat_zero[8];
};

struct sockaddr_l2tpip {
	__kernel_sa_family_t l2tp_family;
	__be16 l2tp_unused;
	struct in_addr l2tp_addr;
	__u32 l2tp_conn_id;
	unsigned char __pad[4];
};

struct sockaddr_l2tpip6 {
	__kernel_sa_family_t l2tp_family;
	__be16 l2tp_unused;
	__be32 l2tp_flowinfo;
	struct in6_addr l2tp_addr;
	__u32 l2tp_scope_id;
	__u32 l2tp_conn_id;
};

struct sockaddr_nl {
	__kernel_sa_family_t nl_family;
	short unsigned int nl_pad;
	__u32 nl_pid;
	__u32 nl_groups;
};

struct tipc_service_addr {
	__u32 type;
	__u32 instance;
};

struct sockaddr_tipc {
	short unsigned int family;
	unsigned char addrtype;
	signed char scope;
	union {
		struct tipc_socket_addr id;
		struct tipc_service_range nameseq;
		struct {
			struct tipc_service_addr name;
			__u32 domain;
		} name;
	} addr;
};

struct sockaddr_pair {
	struct sockaddr_tipc sock;
	struct sockaddr_tipc member;
};

struct sockaddr_pn {
	__kernel_sa_family_t spn_family;
	__u8 spn_obj;
	__u8 spn_dev;
	__u8 spn_resource;
	__u8 spn_zero[11];
};

struct sockaddr_un {
	__kernel_sa_family_t sun_family;
	char sun_path[108];
};

struct sockaddr_vm {
	__kernel_sa_family_t svm_family;
	short unsigned int svm_reserved1;
	unsigned int svm_port;
	unsigned int svm_cid;
	__u8 svm_flags;
	unsigned char svm_zero[3];
};

struct x25_address {
	char x25_addr[16];
};

struct sockaddr_x25 {
	__kernel_sa_family_t sx25_family;
	struct x25_address sx25_addr;
};

struct socket_wq {
	wait_queue_head_t wait;
	struct fasync_struct *fasync_list;
	long unsigned int flags;
	struct callback_head rcu;
	long: 64;
};

struct socket {
	socket_state state;
	short int type;
	long unsigned int flags;
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq wq;
};

struct socket__safe_trusted_or_null {
	struct sock *sk;
};

struct socket_alloc {
	struct socket socket;
	struct inode vfs_inode;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct socket_data {
	struct resource_map mem_db;
	struct resource_map mem_db_valid;
	struct resource_map io_db;
};

struct sockmap_link {
	struct bpf_link link;
	struct bpf_map *map;
	enum bpf_attach_type attach_type;
};

struct softirq_action {
	void (*action)(void);
};

struct softnet_data {
	struct list_head poll_list;
	struct sk_buff_head process_queue;
	local_lock_t process_queue_bh_lock;
	unsigned int processed;
	unsigned int time_squeeze;
	struct softnet_data *rps_ipi_list;
	unsigned int received_rps;
	bool in_net_rx_action;
	bool in_napi_threaded_poll;
	struct sd_flow_limit *flow_limit;
	struct Qdisc *output_queue;
	struct Qdisc **output_queue_tailp;
	struct sk_buff *completion_queue;
	struct sk_buff_head xfrm_backlog;
	struct netdev_xmit xmit;
	long: 0;
	unsigned int input_queue_head;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t csd;
	struct softnet_data *rps_ipi_next;
	unsigned int cpu;
	unsigned int input_queue_tail;
	struct sk_buff_head input_pkt_queue;
	struct napi_struct backlog;
	long: 64;
	atomic_t dropped;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t defer_lock;
	int defer_count;
	int defer_ipi_scheduled;
	struct sk_buff *defer_list;
	long: 64;
	call_single_data_t defer_csd;
};

struct software_node {
	const char *name;
	const struct software_node *parent;
	const struct property_entry *properties;
};

struct sonet_stats {
	int section_bip;
	int line_bip;
	int path_bip;
	int line_febe;
	int path_febe;
	int corr_hcs;
	int uncorr_hcs;
	int tx_cells;
	int rx_cells;
};

struct sp_node {
	struct rb_node nd;
	long unsigned int start;
	long unsigned int end;
	struct mempolicy *policy;
};

struct space_resv {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

struct spi_function_template {
	void (*get_period)(struct scsi_target *);
	void (*set_period)(struct scsi_target *, int);
	void (*get_offset)(struct scsi_target *);
	void (*set_offset)(struct scsi_target *, int);
	void (*get_width)(struct scsi_target *);
	void (*set_width)(struct scsi_target *, int);
	void (*get_iu)(struct scsi_target *);
	void (*set_iu)(struct scsi_target *, int);
	void (*get_dt)(struct scsi_target *);
	void (*set_dt)(struct scsi_target *, int);
	void (*get_qas)(struct scsi_target *);
	void (*set_qas)(struct scsi_target *, int);
	void (*get_wr_flow)(struct scsi_target *);
	void (*set_wr_flow)(struct scsi_target *, int);
	void (*get_rd_strm)(struct scsi_target *);
	void (*set_rd_strm)(struct scsi_target *, int);
	void (*get_rti)(struct scsi_target *);
	void (*set_rti)(struct scsi_target *, int);
	void (*get_pcomp_en)(struct scsi_target *);
	void (*set_pcomp_en)(struct scsi_target *, int);
	void (*get_hold_mcs)(struct scsi_target *);
	void (*set_hold_mcs)(struct scsi_target *, int);
	void (*get_signalling)(struct Scsi_Host *);
	void (*set_signalling)(struct Scsi_Host *, enum spi_signal_type);
	int (*deny_binding)(struct scsi_target *);
	long unsigned int show_period: 1;
	long unsigned int show_offset: 1;
	long unsigned int show_width: 1;
	long unsigned int show_iu: 1;
	long unsigned int show_dt: 1;
	long unsigned int show_qas: 1;
	long unsigned int show_wr_flow: 1;
	long unsigned int show_rd_strm: 1;
	long unsigned int show_rti: 1;
	long unsigned int show_pcomp_en: 1;
	long unsigned int show_hold_mcs: 1;
};

struct spi_host_attrs {
	enum spi_signal_type signalling;
};

struct spi_internal {
	struct scsi_transport_template t;
	struct spi_function_template *f;
};

struct spi_transport_attrs {
	int period;
	int min_period;
	int offset;
	int max_offset;
	unsigned int width: 1;
	unsigned int max_width: 1;
	unsigned int iu: 1;
	unsigned int max_iu: 1;
	unsigned int dt: 1;
	unsigned int qas: 1;
	unsigned int max_qas: 1;
	unsigned int wr_flow: 1;
	unsigned int rd_strm: 1;
	unsigned int rti: 1;
	unsigned int pcomp_en: 1;
	unsigned int hold_mcs: 1;
	unsigned int initial_dv: 1;
	long unsigned int flags;
	unsigned int support_sync: 1;
	unsigned int support_wide: 1;
	unsigned int support_dt: 1;
	unsigned int support_dt_only;
	unsigned int support_ius;
	unsigned int support_qas;
	unsigned int dv_pending: 1;
	unsigned int dv_in_progress: 1;
	struct mutex dv_mutex;
};

struct splice_desc {
	size_t total_len;
	unsigned int len;
	unsigned int flags;
	union {
		void *userptr;
		struct file *file;
		void *data;
	} u;
	void (*splice_eof)(struct splice_desc *);
	loff_t pos;
	loff_t *opos;
	size_t num_spliced;
	bool need_wakeup;
};

struct splice_pipe_desc {
	struct page **pages;
	struct partial_page *partial;
	int nr_pages;
	unsigned int nr_pages_max;
	const struct pipe_buf_operations *ops;
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

struct sr6_tlv {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

struct sr6_tlv_hmac {
	struct sr6_tlv tlvhdr;
	__u16 reserved;
	__be32 hmackeyid;
	__u8 hmac[32];
};

struct srcu_node;

struct srcu_data {
	atomic_long_t srcu_lock_count[2];
	atomic_long_t srcu_unlock_count[2];
	int srcu_reader_flavor;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	struct rcu_segcblist srcu_cblist;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	bool srcu_cblist_invoking;
	struct timer_list delay_work;
	struct work_struct work;
	struct callback_head srcu_barrier_head;
	struct srcu_node *mynode;
	long unsigned int grpmask;
	int cpu;
	struct srcu_struct *ssp;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct srcu_node {
	spinlock_t lock;
	long unsigned int srcu_have_cbs[4];
	long unsigned int srcu_data_have_cbs[4];
	long unsigned int srcu_gp_seq_needed_exp;
	struct srcu_node *srcu_parent;
	int grplo;
	int grphi;
};

struct srcu_usage {
	struct srcu_node *node;
	struct srcu_node *level[3];
	int srcu_size_state;
	struct mutex srcu_cb_mutex;
	spinlock_t lock;
	struct mutex srcu_gp_mutex;
	long unsigned int srcu_gp_seq;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	long unsigned int srcu_gp_start;
	long unsigned int srcu_last_gp_end;
	long unsigned int srcu_size_jiffies;
	long unsigned int srcu_n_lock_retries;
	long unsigned int srcu_n_exp_nodelay;
	bool sda_is_static;
	long unsigned int srcu_barrier_seq;
	struct mutex srcu_barrier_mutex;
	struct completion srcu_barrier_completion;
	atomic_t srcu_barrier_cpu_cnt;
	long unsigned int reschedule_jiffies;
	long unsigned int reschedule_count;
	struct delayed_work work;
	struct srcu_struct *srcu_ssp;
};

struct srcu_notifier_head {
	struct mutex mutex;
	struct srcu_usage srcuu;
	struct srcu_struct srcu;
	struct notifier_block *head;
};

struct ssb_state {
	struct ssb_state *shared_state;
	raw_spinlock_t lock;
	unsigned int disable_state;
	long unsigned int local_state;
};

struct sta_bss_parameters {
	u8 flags;
	u8 dtim_period;
	u16 beacon_interval;
};

struct stack_entry {
	struct trace_entry ent;
	int size;
	long unsigned int caller[0];
};

struct stack_frame {
	struct stack_frame *next_frame;
	long unsigned int return_address;
};

struct stack_frame_user {
	const void *next_fp;
	long unsigned int ret_addr;
};

struct stack_info {
	enum stack_type type;
	long unsigned int *begin;
	long unsigned int *end;
	long unsigned int *next_sp;
};

struct stack_map_bucket {
	struct pcpu_freelist_node fnode;
	u32 hash;
	u32 nr;
	u64 data[0];
};

struct stack_record {
	struct list_head hash_list;
	u32 hash;
	u32 size;
	union handle_parts handle;
	refcount_t count;
	union {
		long unsigned int entries[64];
		struct {
			struct list_head free_list;
			long unsigned int rcu_state;
		};
	};
};

struct stacktrace_cookie {
	long unsigned int *store;
	unsigned int size;
	unsigned int skip;
	unsigned int len;
};

struct stashed_operations {
	void (*put_data)(void *);
	int (*init_inode)(struct inode *, void *);
};

struct stat {
	__kernel_ulong_t st_dev;
	__kernel_ulong_t st_ino;
	__kernel_ulong_t st_nlink;
	unsigned int st_mode;
	unsigned int st_uid;
	unsigned int st_gid;
	unsigned int __pad0;
	__kernel_ulong_t st_rdev;
	__kernel_long_t st_size;
	__kernel_long_t st_blksize;
	__kernel_long_t st_blocks;
	__kernel_ulong_t st_atime;
	__kernel_ulong_t st_atime_nsec;
	__kernel_ulong_t st_mtime;
	__kernel_ulong_t st_mtime_nsec;
	__kernel_ulong_t st_ctime;
	__kernel_ulong_t st_ctime_nsec;
	__kernel_long_t __unused[3];
};

struct stat_node {
	struct rb_node node;
	void *stat;
};

struct tracer_stat;

struct stat_session {
	struct list_head session_list;
	struct tracer_stat *ts;
	struct rb_root stat_root;
	struct mutex stat_mutex;
	struct dentry *file;
};

struct statfs {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__kernel_long_t f_blocks;
	__kernel_long_t f_bfree;
	__kernel_long_t f_bavail;
	__kernel_long_t f_files;
	__kernel_long_t f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct statfs64 {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct static_call_mod;

struct static_call_key {
	void *func;
	union {
		long unsigned int type;
		struct static_call_mod *mods;
		struct static_call_site *sites;
	};
};

struct static_call_mod {
	struct static_call_mod *next;
	struct module *mod;
	struct static_call_site *sites;
};

struct static_call_site {
	s32 addr;
	s32 key;
};

struct static_call_tramp_key {
	s32 tramp;
	s32 key;
};

struct static_key_deferred {
	struct static_key key;
	long unsigned int timeout;
	struct delayed_work work;
};

struct static_key_false_deferred {
	struct static_key_false key;
	long unsigned int timeout;
	struct delayed_work work;
};

struct static_key_mod {
	struct static_key_mod *next;
	struct jump_entry *entries;
	struct module *mod;
};

struct static_tree_desc_s {
	const ct_data *static_tree;
	const int *extra_bits;
	int extra_base;
	int elems;
	int max_length;
};

struct station_info {
	u64 filled;
	u32 connected_time;
	u32 inactive_time;
	u64 assoc_at;
	u64 rx_bytes;
	u64 tx_bytes;
	u16 llid;
	u16 plid;
	u8 plink_state;
	s8 signal;
	s8 signal_avg;
	u8 chains;
	s8 chain_signal[4];
	s8 chain_signal_avg[4];
	struct rate_info txrate;
	struct rate_info rxrate;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	struct sta_bss_parameters bss_param;
	struct nl80211_sta_flag_update sta_flags;
	int generation;
	const u8 *assoc_req_ies;
	size_t assoc_req_ies_len;
	u32 beacon_loss_count;
	s64 t_offset;
	enum nl80211_mesh_power_mode local_pm;
	enum nl80211_mesh_power_mode peer_pm;
	enum nl80211_mesh_power_mode nonpeer_pm;
	u32 expected_throughput;
	u64 tx_duration;
	u64 rx_duration;
	u64 rx_beacon;
	u8 rx_beacon_signal_avg;
	u8 connected_to_gate;
	struct cfg80211_tid_stats *pertid;
	s8 ack_signal;
	s8 avg_ack_signal;
	u16 airtime_weight;
	u32 rx_mpdu_count;
	u32 fcs_err_count;
	u32 airtime_link_metric;
	u8 connected_to_as;
	bool mlo_params_valid;
	u8 assoc_link_id;
	int: 0;
	u8 mld_addr[6];
	const u8 *assoc_resp_ies;
	size_t assoc_resp_ies_len;
};

struct stats_reply_data {
	struct ethnl_reply_data base;
	union {
		struct {
			struct ethtool_eth_phy_stats phy_stats;
			struct ethtool_eth_mac_stats mac_stats;
			struct ethtool_eth_ctrl_stats ctrl_stats;
			struct ethtool_rmon_stats rmon_stats;
			struct ethtool_phy_stats phydev_stats;
		};
		struct {
			struct ethtool_eth_phy_stats phy_stats;
			struct ethtool_eth_mac_stats mac_stats;
			struct ethtool_eth_ctrl_stats ctrl_stats;
			struct ethtool_rmon_stats rmon_stats;
			struct ethtool_phy_stats phydev_stats;
		} stats;
	};
	const struct ethtool_rmon_hist_range *rmon_ranges;
};

struct stats_req_info {
	struct ethnl_req_info base;
	long unsigned int stat_mask[1];
	enum ethtool_mac_stats_src src;
};

struct statx_timestamp {
	__s64 tv_sec;
	__u32 tv_nsec;
	__s32 __reserved;
};

struct statx {
	__u32 stx_mask;
	__u32 stx_blksize;
	__u64 stx_attributes;
	__u32 stx_nlink;
	__u32 stx_uid;
	__u32 stx_gid;
	__u16 stx_mode;
	__u16 __spare0[1];
	__u64 stx_ino;
	__u64 stx_size;
	__u64 stx_blocks;
	__u64 stx_attributes_mask;
	struct statx_timestamp stx_atime;
	struct statx_timestamp stx_btime;
	struct statx_timestamp stx_ctime;
	struct statx_timestamp stx_mtime;
	__u32 stx_rdev_major;
	__u32 stx_rdev_minor;
	__u32 stx_dev_major;
	__u32 stx_dev_minor;
	__u64 stx_mnt_id;
	__u32 stx_dio_mem_align;
	__u32 stx_dio_offset_align;
	__u64 stx_subvol;
	__u32 stx_atomic_write_unit_min;
	__u32 stx_atomic_write_unit_max;
	__u32 stx_atomic_write_segments_max;
	__u32 stx_dio_read_offset_align;
	__u64 __spare3[9];
};

struct stepping_info {
	char stepping;
	char substepping;
};

struct stereo_mandatory_mode {
	int width;
	int height;
	int vrefresh;
	unsigned int flags;
};

struct stop_event_data {
	struct perf_event *event;
	unsigned int restart;
};

struct stp_proto {
	unsigned char group_address[6];
	void (*rcv)(const struct stp_proto *, struct sk_buff *, struct net_device *);
	void *data;
};

struct strarray {
	char **array;
	size_t n;
};

struct stripe {
	struct dm_dev *dev;
	sector_t physical_start;
	atomic_t error_count;
};

struct stripe_c {
	uint32_t stripes;
	int stripes_shift;
	sector_t stripe_width;
	uint32_t chunk_size;
	int chunk_size_shift;
	struct dm_target *ti;
	struct work_struct trigger_event;
	struct stripe stripe[0];
};

struct strset_info {
	bool per_dev;
	bool free_strings;
	unsigned int count;
	const char (*strings)[32];
};

struct strset_reply_data {
	struct ethnl_reply_data base;
	struct strset_info sets[23];
};

struct strset_req_info {
	struct ethnl_req_info base;
	u32 req_ids;
	bool counts_only;
};

struct subflow_send_info {
	struct sock *ssk;
	u64 linger_time;
};

struct subplatform_desc {
	struct intel_display_platforms platforms;
	const char *name;
	const u16 *pciidlist;
	struct stepping_desc step_info;
};

struct subprocess_info {
	struct work_struct work;
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	int wait;
	int retval;
	int (*init)(struct subprocess_info *, struct cred *);
	void (*cleanup)(struct subprocess_info *);
	void *data;
};

struct subsys_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

struct subsys_interface {
	const char *name;
	const struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *, struct subsys_interface *);
	void (*remove_dev)(struct device *, struct subsys_interface *);
};

struct subsys_private {
	struct kset subsys;
	struct kset *devices_kset;
	struct list_head interfaces;
	struct mutex mutex;
	struct kset *drivers_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe: 1;
	const struct bus_type *bus;
	struct device *dev_root;
	struct kset glue_dirs;
	const struct class *class;
	struct lock_class_key lock_key;
};

struct sugov_policy;

struct sugov_cpu {
	struct update_util_data update_util;
	struct sugov_policy *sg_policy;
	unsigned int cpu;
	bool iowait_boost_pending;
	unsigned int iowait_boost;
	u64 last_update;
	long unsigned int util;
	long unsigned int bw_min;
	long unsigned int saved_idle_calls;
};

struct sugov_tunables;

struct sugov_policy {
	struct cpufreq_policy *policy;
	struct sugov_tunables *tunables;
	struct list_head tunables_hook;
	raw_spinlock_t update_lock;
	u64 last_freq_update_time;
	s64 freq_update_delay_ns;
	unsigned int next_freq;
	unsigned int cached_raw_freq;
	struct irq_work irq_work;
	struct kthread_work work;
	struct mutex work_lock;
	struct kthread_worker worker;
	struct task_struct *thread;
	bool work_in_progress;
	bool limits_changed;
	bool need_freq_update;
};

struct sugov_tunables {
	struct gov_attr_set attr_set;
	unsigned int rate_limit_us;
};

struct sunrpc_net {
	struct proc_dir_entry *proc_net_rpc;
	struct cache_detail *ip_map_cache;
	struct cache_detail *unix_gid_cache;
	struct cache_detail *rsc_cache;
	struct cache_detail *rsi_cache;
	struct super_block *pipefs_sb;
	struct rpc_pipe *gssd_dummy;
	struct mutex pipefs_sb_lock;
	struct list_head all_clients;
	spinlock_t rpc_client_lock;
	struct rpc_clnt *rpcb_local_clnt;
	struct rpc_clnt *rpcb_local_clnt4;
	spinlock_t rpcb_clnt_lock;
	unsigned int rpcb_users;
	unsigned int rpcb_is_af_local: 1;
	struct mutex gssp_lock;
	struct rpc_clnt *gssp_clnt;
	int use_gss_proxy;
	int pipe_version;
	atomic_t pipe_users;
	struct proc_dir_entry *use_gssp_proc;
	struct proc_dir_entry *gss_krb5_enctypes;
};

struct mtd_info;

struct super_block {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	long unsigned int s_blocksize;
	loff_t s_maxbytes;
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	const struct dquot_operations *dq_op;
	const struct quotactl_ops *s_qcop;
	const struct export_operations *s_export_op;
	long unsigned int s_flags;
	long unsigned int s_iflags;
	long unsigned int s_magic;
	struct dentry *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	void *s_security;
	const struct xattr_handler * const *s_xattr;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device *s_bdev;
	struct file *s_bdev_file;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	struct quota_info s_dquot;
	struct sb_writers s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	time64_t s_time_min;
	time64_t s_time_max;
	u32 s_fsnotify_mask;
	struct fsnotify_sb_info *s_fsnotify_info;
	char s_id[32];
	uuid_t s_uuid;
	u8 s_uuid_len;
	char s_sysfs_name[37];
	unsigned int s_max_links;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations *s_d_op;
	struct shrinker *s_shrink;
	atomic_long_t s_remove_count;
	int s_readonly_remount;
	errseq_t s_wb_err;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	long: 64;
	long: 64;
};

struct super_operations {
	struct inode * (*alloc_inode)(struct super_block *);
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *);
	void (*dirty_inode)(struct inode *, int);
	int (*write_inode)(struct inode *, struct writeback_control *);
	int (*drop_inode)(struct inode *);
	void (*evict_inode)(struct inode *);
	void (*put_super)(struct super_block *);
	int (*sync_fs)(struct super_block *, int);
	int (*freeze_super)(struct super_block *, enum freeze_holder);
	int (*freeze_fs)(struct super_block *);
	int (*thaw_super)(struct super_block *, enum freeze_holder);
	int (*unfreeze_fs)(struct super_block *);
	int (*statfs)(struct dentry *, struct kstatfs *);
	int (*remount_fs)(struct super_block *, int *, char *);
	void (*umount_begin)(struct super_block *);
	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
	struct dquot ** (*get_dquots)(struct inode *);
	long int (*nr_cached_objects)(struct super_block *, struct shrink_control *);
	long int (*free_cached_objects)(struct super_block *, struct shrink_control *);
	void (*shutdown)(struct super_block *);
};

struct super_type {
	char *name;
	struct module *owner;
	int (*load_super)(struct md_rdev *, struct md_rdev *, int);
	int (*validate_super)(struct mddev *, struct md_rdev *, struct md_rdev *);
	void (*sync_super)(struct mddev *, struct md_rdev *);
	long long unsigned int (*rdev_size_change)(struct md_rdev *, sector_t);
	int (*allow_new_offset)(struct md_rdev *, long long unsigned int);
};

struct suspend_stats {
	unsigned int step_failures[8];
	unsigned int success;
	unsigned int fail;
	int last_failed_dev;
	char failed_devs[80];
	int last_failed_errno;
	int errno[2];
	int last_failed_step;
	u64 last_hw_sleep;
	u64 total_hw_sleep;
	u64 max_hw_sleep;
	enum suspend_stat_step failed_steps[2];
};

struct svc_deferred_req {
	u32 prot;
	struct svc_xprt *xprt;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	struct __kernel_sockaddr_storage daddr;
	size_t daddrlen;
	void *xprt_ctxt;
	struct cache_deferred_req handle;
	int argslen;
	__be32 args[0];
};

struct svc_info {
	struct svc_serv *serv;
	struct mutex *mutex;
};

struct svc_pool {
	unsigned int sp_id;
	struct lwq sp_xprts;
	unsigned int sp_nrthreads;
	struct list_head sp_all_threads;
	struct llist_head sp_idle_threads;
	struct percpu_counter sp_messages_arrived;
	struct percpu_counter sp_sockets_queued;
	struct percpu_counter sp_threads_woken;
	long unsigned int sp_flags;
};

struct svc_pool_map {
	int count;
	int mode;
	unsigned int npools;
	unsigned int *pool_to;
	unsigned int *to_pool;
};

struct svc_procedure {
	__be32 (*pc_func)(struct svc_rqst *);
	bool (*pc_decode)(struct svc_rqst *, struct xdr_stream *);
	bool (*pc_encode)(struct svc_rqst *, struct xdr_stream *);
	void (*pc_release)(struct svc_rqst *);
	unsigned int pc_argsize;
	unsigned int pc_argzero;
	unsigned int pc_ressize;
	unsigned int pc_cachetype;
	unsigned int pc_xdrressize;
	const char *pc_name;
};

struct svc_process_info {
	union {
		int (*dispatch)(struct svc_rqst *);
		struct {
			unsigned int lovers;
			unsigned int hivers;
		} mismatch;
	};
};

struct svc_version;

struct svc_program {
	u32 pg_prog;
	unsigned int pg_lovers;
	unsigned int pg_hivers;
	unsigned int pg_nvers;
	const struct svc_version **pg_vers;
	char *pg_name;
	char *pg_class;
	enum svc_auth_status (*pg_authenticate)(struct svc_rqst *);
	__be32 (*pg_init_request)(struct svc_rqst *, const struct svc_program *, struct svc_process_info *);
	int (*pg_rpcbind_set)(struct net *, const struct svc_program *, u32, int, short unsigned int, short unsigned int);
};

struct xdr_stream {
	__be32 *p;
	struct xdr_buf *buf;
	__be32 *end;
	struct kvec *iov;
	struct kvec scratch;
	struct page **page_ptr;
	void *page_kaddr;
	unsigned int nwords;
	struct rpc_rqst *rqst;
};

struct svc_rqst {
	struct list_head rq_all;
	struct llist_node rq_idle;
	struct callback_head rq_rcu_head;
	struct svc_xprt *rq_xprt;
	struct __kernel_sockaddr_storage rq_addr;
	size_t rq_addrlen;
	struct __kernel_sockaddr_storage rq_daddr;
	size_t rq_daddrlen;
	struct svc_serv *rq_server;
	struct svc_pool *rq_pool;
	const struct svc_procedure *rq_procinfo;
	struct auth_ops *rq_authop;
	struct svc_cred rq_cred;
	void *rq_xprt_ctxt;
	struct svc_deferred_req *rq_deferred;
	struct xdr_buf rq_arg;
	struct xdr_stream rq_arg_stream;
	struct xdr_stream rq_res_stream;
	struct page *rq_scratch_page;
	struct xdr_buf rq_res;
	struct page *rq_pages[260];
	struct page **rq_respages;
	struct page **rq_next_page;
	struct page **rq_page_end;
	struct folio_batch rq_fbatch;
	struct kvec rq_vec[259];
	struct bio_vec rq_bvec[259];
	__be32 rq_xid;
	u32 rq_prog;
	u32 rq_vers;
	u32 rq_proc;
	u32 rq_prot;
	int rq_cachetype;
	long unsigned int rq_flags;
	ktime_t rq_qtime;
	void *rq_argp;
	void *rq_resp;
	__be32 *rq_accept_statp;
	void *rq_auth_data;
	__be32 rq_auth_stat;
	int rq_auth_slack;
	int rq_reserved;
	ktime_t rq_stime;
	struct cache_req rq_chandle;
	struct auth_domain *rq_client;
	struct auth_domain *rq_gssclient;
	struct task_struct *rq_task;
	struct net *rq_bc_net;
	int rq_err;
	long unsigned int bc_to_initval;
	unsigned int bc_to_retries;
	void **rq_lease_breaker;
	unsigned int rq_status_counter;
};

struct svc_stat;

struct svc_serv {
	struct svc_program *sv_programs;
	struct svc_stat *sv_stats;
	spinlock_t sv_lock;
	unsigned int sv_nprogs;
	unsigned int sv_nrthreads;
	unsigned int sv_max_payload;
	unsigned int sv_max_mesg;
	unsigned int sv_xdrsize;
	struct list_head sv_permsocks;
	struct list_head sv_tempsocks;
	int sv_tmpcnt;
	struct timer_list sv_temptimer;
	char *sv_name;
	unsigned int sv_nrpools;
	bool sv_is_pooled;
	struct svc_pool *sv_pools;
	int (*sv_threadfn)(void *);
};

struct svc_xprt_class;

struct svc_xprt_ops;

struct svc_xprt {
	struct svc_xprt_class *xpt_class;
	const struct svc_xprt_ops *xpt_ops;
	struct kref xpt_ref;
	struct list_head xpt_list;
	struct lwq_node xpt_ready;
	long unsigned int xpt_flags;
	struct svc_serv *xpt_server;
	atomic_t xpt_reserved;
	atomic_t xpt_nr_rqsts;
	struct mutex xpt_mutex;
	spinlock_t xpt_lock;
	void *xpt_auth_cache;
	struct list_head xpt_deferred;
	struct __kernel_sockaddr_storage xpt_local;
	size_t xpt_locallen;
	struct __kernel_sockaddr_storage xpt_remote;
	size_t xpt_remotelen;
	char xpt_remotebuf[58];
	struct list_head xpt_users;
	struct net *xpt_net;
	netns_tracker ns_tracker;
	const struct cred *xpt_cred;
	struct rpc_xprt *xpt_bc_xprt;
	struct rpc_xprt_switch *xpt_bc_xps;
};

struct svc_sock {
	struct svc_xprt sk_xprt;
	struct socket *sk_sock;
	struct sock *sk_sk;
	void (*sk_ostate)(struct sock *);
	void (*sk_odata)(struct sock *);
	void (*sk_owspace)(struct sock *);
	__be32 sk_marker;
	u32 sk_tcplen;
	u32 sk_datalen;
	struct page_frag_cache sk_frag_cache;
	struct completion sk_handshake_done;
	struct page *sk_pages[259];
};

struct svc_stat {
	struct svc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int rpccnt;
	unsigned int rpcbadfmt;
	unsigned int rpcbadauth;
	unsigned int rpcbadclnt;
};

struct svc_version {
	u32 vs_vers;
	u32 vs_nproc;
	const struct svc_procedure *vs_proc;
	long unsigned int *vs_count;
	u32 vs_xdrsize;
	bool vs_hidden;
	bool vs_rpcb_optnl;
	bool vs_need_cong_ctrl;
	int (*vs_dispatch)(struct svc_rqst *);
};

struct svc_xprt_class {
	const char *xcl_name;
	struct module *xcl_owner;
	const struct svc_xprt_ops *xcl_ops;
	struct list_head xcl_list;
	u32 xcl_max_payload;
	int xcl_ident;
};

struct svc_xprt_ops {
	struct svc_xprt * (*xpo_create)(struct svc_serv *, struct net *, struct sockaddr *, int, int);
	struct svc_xprt * (*xpo_accept)(struct svc_xprt *);
	int (*xpo_has_wspace)(struct svc_xprt *);
	int (*xpo_recvfrom)(struct svc_rqst *);
	int (*xpo_sendto)(struct svc_rqst *);
	int (*xpo_result_payload)(struct svc_rqst *, unsigned int, unsigned int);
	void (*xpo_release_ctxt)(struct svc_xprt *, void *);
	void (*xpo_detach)(struct svc_xprt *);
	void (*xpo_free)(struct svc_xprt *);
	void (*xpo_kill_temp_xprt)(struct svc_xprt *);
	void (*xpo_handshake)(struct svc_xprt *);
};

struct svc_xpt_user {
	struct list_head list;
	void (*callback)(struct svc_xpt_user *);
};

struct sw_flow_id {
	u32 ufid_len;
	union {
		u32 ufid[4];
		struct sw_flow_key *unmasked_key;
	};
};

struct sw_flow_actions;

struct sw_flow_stats;

struct sw_flow {
	struct callback_head rcu;
	struct {
		struct hlist_node node[2];
		u32 hash;
	} flow_table;
	struct {
		struct hlist_node node[2];
		u32 hash;
	} ufid_table;
	int stats_last_writer;
	struct sw_flow_key key;
	struct sw_flow_id id;
	struct cpumask *cpu_used_mask;
	struct sw_flow_mask *mask;
	struct sw_flow_actions *sf_acts;
	struct sw_flow_stats *stats[0];
};

struct sw_flow_actions {
	struct callback_head rcu;
	size_t orig_len;
	u32 actions_len;
	struct nlattr actions[0];
};

struct sw_flow_key_range {
	short unsigned int start;
	short unsigned int end;
};

struct sw_flow_mask {
	int ref_count;
	struct callback_head rcu;
	struct sw_flow_key_range range;
	struct sw_flow_key key;
};

struct sw_flow_match {
	struct sw_flow_key *key;
	struct sw_flow_key_range range;
	struct sw_flow_mask *mask;
};

struct sw_flow_stats {
	u64 packet_count;
	u64 byte_count;
	long unsigned int used;
	spinlock_t lock;
	__be16 tcp_flags;
};

struct swait_queue {
	struct task_struct *task;
	struct list_head task_list;
};

struct swap_cgroup {
	atomic_t ids;
};

struct swap_cgroup_ctrl {
	struct swap_cgroup *map;
};

struct swap_cluster_info {
	spinlock_t lock;
	u16 count;
	u8 flags;
	u8 order;
	struct list_head list;
};

struct swap_extent {
	struct rb_node rb_node;
	long unsigned int start_page;
	long unsigned int nr_pages;
	sector_t start_block;
};

union swap_header {
	struct {
		char reserved[4086];
		char magic[10];
	} magic;
	struct {
		char bootbits[1024];
		__u32 version;
		__u32 last_page;
		__u32 nr_badpages;
		unsigned char sws_uuid[16];
		unsigned char sws_volume[16];
		__u32 padding[117];
		__u32 badpages[1];
	} info;
};

struct swap_info_struct {
	struct percpu_ref users;
	long unsigned int flags;
	short int prio;
	struct plist_node list;
	signed char type;
	unsigned int max;
	unsigned char *swap_map;
	long unsigned int *zeromap;
	struct swap_cluster_info *cluster_info;
	struct list_head free_clusters;
	struct list_head full_clusters;
	struct list_head nonfull_clusters[1];
	struct list_head frag_clusters[1];
	atomic_long_t frag_cluster_nr[1];
	unsigned int pages;
	atomic_long_t inuse_pages;
	struct percpu_cluster *percpu_cluster;
	struct percpu_cluster *global_cluster;
	spinlock_t global_cluster_lock;
	struct rb_root swap_extent_root;
	struct block_device *bdev;
	struct file *swap_file;
	struct completion comp;
	spinlock_t lock;
	spinlock_t cont_lock;
	struct work_struct discard_work;
	struct work_struct reclaim_work;
	struct list_head discard_clusters;
	struct plist_node avail_lists[0];
};

struct swap_iocb {
	struct kiocb iocb;
	struct bio_vec bvec[32];
	int pages;
	int len;
};

struct swap_map_page;

struct swap_map_page_list;

struct swap_map_handle {
	struct swap_map_page *cur;
	struct swap_map_page_list *maps;
	sector_t cur_swap;
	sector_t first_sector;
	unsigned int k;
	long unsigned int reqd_free_pages;
	u32 crc32;
};

struct swap_map_page {
	sector_t entries[511];
	sector_t next_swap;
};

struct swap_map_page_list {
	struct swap_map_page *map;
	struct swap_map_page_list *next;
};

struct swap_slots_cache {
	bool lock_initialized;
	struct mutex alloc_lock;
	swp_entry_t *slots;
	int nr;
	int cur;
	int n_ret;
};

struct swevent_hlist {
	struct hlist_head heads[256];
	struct callback_head callback_head;
};

struct swevent_htable {
	struct swevent_hlist *swevent_hlist;
	struct mutex hlist_mutex;
	int hlist_refcount;
};

struct switchdev_mst_state {
	u16 msti;
	u8 state;
};

struct switchdev_brport_flags {
	long unsigned int val;
	long unsigned int mask;
};

struct switchdev_vlan_msti {
	u16 vid;
	u16 msti;
};

struct switchdev_attr {
	struct net_device *orig_dev;
	enum switchdev_attr_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
	union {
		u8 stp_state;
		struct switchdev_mst_state mst_state;
		struct switchdev_brport_flags brport_flags;
		bool mrouter;
		clock_t ageing_time;
		bool vlan_filtering;
		u16 vlan_protocol;
		bool mst;
		bool mc_disabled;
		u8 mrp_port_role;
		struct switchdev_vlan_msti vlan_msti;
	} u;
};

struct switchdev_brport {
	struct net_device *dev;
	const void *ctx;
	struct notifier_block *atomic_nb;
	struct notifier_block *blocking_nb;
	bool tx_fwd_offload;
};

struct switchdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
	const void *ctx;
};

struct switchdev_notifier_brport_info {
	struct switchdev_notifier_info info;
	const struct switchdev_brport brport;
};

struct switchdev_notifier_fdb_info {
	struct switchdev_notifier_info info;
	const unsigned char *addr;
	u16 vid;
	u8 added_by_user: 1;
	u8 is_local: 1;
	u8 locked: 1;
	u8 offloaded: 1;
};

union vxlan_addr {
	struct sockaddr_in sin;
	struct sockaddr_in6 sin6;
	struct sockaddr sa;
};

struct switchdev_notifier_vxlan_fdb_info {
	struct switchdev_notifier_info info;
	union vxlan_addr remote_ip;
	__be16 remote_port;
	__be32 remote_vni;
	u32 remote_ifindex;
	u8 eth_addr[6];
	__be32 vni;
	bool offloaded;
	bool added_by_user;
};

struct switchdev_obj {
	struct list_head list;
	struct net_device *orig_dev;
	enum switchdev_obj_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
};

struct switchdev_obj_in_role_mrp {
	struct switchdev_obj obj;
	struct net_device *i_port;
	u32 ring_id;
	u16 in_id;
	u8 in_role;
	u8 sw_backup;
};

struct switchdev_obj_in_state_mrp {
	struct switchdev_obj obj;
	u32 in_id;
	u8 in_state;
};

struct switchdev_obj_in_test_mrp {
	struct switchdev_obj obj;
	u32 interval;
	u32 in_id;
	u32 period;
	u8 max_miss;
};

struct switchdev_obj_mrp {
	struct switchdev_obj obj;
	struct net_device *p_port;
	struct net_device *s_port;
	u32 ring_id;
	u16 prio;
};

struct switchdev_obj_ring_role_mrp {
	struct switchdev_obj obj;
	u8 ring_role;
	u32 ring_id;
	u8 sw_backup;
};

struct switchdev_obj_ring_state_mrp {
	struct switchdev_obj obj;
	u8 ring_state;
	u32 ring_id;
};

struct switchdev_obj_ring_test_mrp {
	struct switchdev_obj obj;
	u32 interval;
	u8 max_miss;
	u32 ring_id;
	u32 period;
	bool monitor;
};

struct swmii_regs {
	u16 bmsr;
	u16 lpa;
	u16 lpagb;
	u16 estat;
};

struct swnode {
	struct kobject kobj;
	struct fwnode_handle fwnode;
	const struct software_node *node;
	int id;
	struct ida child_ids;
	struct list_head entry;
	struct list_head children;
	struct swnode *parent;
	unsigned int allocated: 1;
	unsigned int managed: 1;
};

struct swsusp_extent {
	struct rb_node node;
	long unsigned int start;
	long unsigned int end;
};

struct swsusp_header {
	char reserved[4056];
	u32 hw_sig;
	u32 crc32;
	sector_t image;
	unsigned int flags;
	char orig_sig[10];
	char sig[10];
};

struct swsusp_info {
	struct new_utsname uts;
	u32 version_code;
	long unsigned int num_physpages;
	int cpus;
	long unsigned int image_pages;
	long unsigned int pages;
	long unsigned int size;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sym_count_ctx {
	unsigned int count;
	const char *name;
};

struct symsearch {
	const struct kernel_symbol *start;
	const struct kernel_symbol *stop;
	const u32 *crcs;
	enum mod_license license;
};

struct synaptics_device_info {
	u32 model_id;
	u32 firmware_id;
	u32 board_id;
	u32 capabilities;
	u32 ext_cap;
	u32 ext_cap_0c;
	u32 ext_cap_10;
	u32 identity;
	u32 x_res;
	u32 y_res;
	u32 x_max;
	u32 y_max;
	u32 x_min;
	u32 y_min;
};

struct synaptics_hw_state {
	int x;
	int y;
	int z;
	int w;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int up: 1;
	unsigned int down: 1;
	u8 ext_buttons;
	s8 scroll;
};

struct synaptics_data {
	struct synaptics_device_info info;
	enum synaptics_pkt_type pkt_type;
	u8 mode;
	int scroll;
	bool absolute_mode;
	bool disable_gesture;
	struct serio *pt_port;
	bool pt_port_open;
	struct synaptics_hw_state agm;
	unsigned int agm_count;
	long unsigned int press_start;
	bool press;
	bool report_press;
	bool is_forcepad;
};

struct sync_fence_info {
	char obj_name[32];
	char driver_name[32];
	__s32 status;
	__u32 flags;
	__u64 timestamp_ns;
};

struct sync_file {
	struct file *file;
	char user_name[32];
	struct list_head sync_file_list;
	wait_queue_head_t wq;
	long unsigned int flags;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct sync_file_info {
	char name[32];
	__s32 status;
	__u32 flags;
	__u32 num_fences;
	__u32 pad;
	__u64 sync_fence_info;
};

struct sync_io {
	long unsigned int error_bits;
	struct completion wait;
};

struct sync_merge_data {
	char name[32];
	__s32 fd2;
	__s32 fence;
	__u32 flags;
	__u32 pad;
};

struct sync_set_deadline {
	__u64 deadline_ns;
	__u64 pad;
};

struct syncobj_eventfd_entry {
	struct list_head node;
	struct dma_fence *fence;
	struct dma_fence_cb fence_cb;
	struct drm_syncobj *syncobj;
	struct eventfd_ctx *ev_fd_ctx;
	u64 point;
	u32 flags;
};

struct syncobj_wait_entry {
	struct list_head node;
	struct task_struct *task;
	struct dma_fence *fence;
	struct dma_fence_cb fence_cb;
	u64 point;
};

struct synproxy_stats;

struct synproxy_net {
	struct nf_conn *tmpl;
	struct synproxy_stats *stats;
	unsigned int hook_ref4;
	unsigned int hook_ref6;
};

struct synproxy_options {
	u8 options;
	u8 wscale;
	u16 mss_option;
	u16 mss_encode;
	u32 tsval;
	u32 tsecr;
};

struct synproxy_stats {
	unsigned int syn_received;
	unsigned int cookie_invalid;
	unsigned int cookie_valid;
	unsigned int cookie_retrans;
	unsigned int conn_reopened;
};

struct sys_off_data {
	int mode;
	void *cb_data;
	const char *cmd;
	struct device *dev;
};

struct sys_off_handler {
	struct notifier_block nb;
	int (*sys_off_cb)(struct sys_off_data *);
	void *cb_data;
	enum sys_off_mode mode;
	bool blocking;
	void *list;
	struct device *dev;
};

struct syscall_info {
	__u64 sp;
	struct seccomp_data data;
};

struct syscall_user_dispatch {
	char *selector;
	long unsigned int offset;
	long unsigned int len;
	bool on_dispatch;
};

struct syscore_ops {
	struct list_head node;
	int (*suspend)(void);
	void (*resume)(void);
	void (*shutdown)(void);
};

struct sysctl_alias {
	const char *kernel_param;
	const char *sysctl_param;
};

struct sysfs_ops {
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

struct sysinfo {
	__kernel_long_t uptime;
	__kernel_ulong_t loads[3];
	__kernel_ulong_t totalram;
	__kernel_ulong_t freeram;
	__kernel_ulong_t sharedram;
	__kernel_ulong_t bufferram;
	__kernel_ulong_t totalswap;
	__kernel_ulong_t freeswap;
	__u16 procs;
	__u16 pad;
	__kernel_ulong_t totalhigh;
	__kernel_ulong_t freehigh;
	__u32 mem_unit;
	char _f[0];
};

struct sysrq_key_op {
	void (* const handler)(u8);
	const char * const help_msg;
	const char * const action_msg;
	const int enable_mask;
};

struct sysrq_state {
	struct input_handle handle;
	struct work_struct reinject_work;
	long unsigned int key_down[12];
	unsigned int alt;
	unsigned int alt_use;
	unsigned int shift;
	unsigned int shift_use;
	bool active;
	bool need_reinject;
	bool reinjecting;
	bool reset_canceled;
	bool reset_requested;
	long unsigned int reset_keybit[12];
	int reset_seq_len;
	int reset_seq_cnt;
	int reset_seq_version;
	struct timer_list keyreset_timer;
};

struct system_counterval_t {
	u64 cycles;
	enum clocksource_ids cs_id;
	bool use_nsecs;
};

struct system_device_crosststamp {
	ktime_t device;
	ktime_t sys_realtime;
	ktime_t sys_monoraw;
};

struct system_time_snapshot {
	u64 cycles;
	ktime_t real;
	ktime_t boot;
	ktime_t raw;
	enum clocksource_ids cs_id;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
};

struct sysv_sem {
	struct sem_undo_list *undo_list;
};

struct sysv_shm {
	struct list_head shm_clist;
};

struct table_device {
	struct list_head list;
	refcount_t count;
	struct dm_dev dm_dev;
};

struct table_instance {
	struct hlist_head *buckets;
	unsigned int n_buckets;
	struct callback_head rcu;
	int node_ver;
	u32 hash_seed;
};

struct taint_flag {
	char c_true;
	char c_false;
	bool module;
	const char *desc;
};

struct tap_queue {
	struct sock sk;
	struct socket sock;
	int vnet_hdr_sz;
	struct tap_dev *tap;
	struct file *file;
	unsigned int flags;
	u16 queue_index;
	bool enabled;
	struct list_head next;
	long: 64;
	long: 64;
	struct ptr_ring ring;
};

struct taprio_sched {
	struct Qdisc **qdiscs;
	struct Qdisc *root;
	u32 flags;
	enum tk_offsets tk_offset;
	int clockid;
	bool offloaded;
	bool detected_mqprio;
	bool broken_mqprio;
	atomic64_t picos_per_byte;
	spinlock_t current_entry_lock;
	struct sched_entry *current_entry;
	struct sched_gate_list *oper_sched;
	struct sched_gate_list *admin_sched;
	struct hrtimer advance_timer;
	struct list_head taprio_list;
	int cur_txq[16];
	u32 max_sdu[16];
	u32 fp[16];
	u32 txtime_delay;
};

typedef int (*dm_ctr_fn)(struct dm_target *, unsigned int, char **);

typedef void (*dm_dtr_fn)(struct dm_target *);

typedef int (*dm_map_fn)(struct dm_target *, struct bio *);

typedef int (*dm_clone_and_map_request_fn)(struct dm_target *, struct request *, union map_info *, struct request **);

typedef void (*dm_release_clone_request_fn)(struct request *, union map_info *);

typedef int (*dm_endio_fn)(struct dm_target *, struct bio *, blk_status_t *);

typedef int (*dm_request_endio_fn)(struct dm_target *, struct request *, blk_status_t, union map_info *);

typedef void (*dm_presuspend_fn)(struct dm_target *);

typedef void (*dm_presuspend_undo_fn)(struct dm_target *);

typedef void (*dm_postsuspend_fn)(struct dm_target *);

typedef int (*dm_preresume_fn)(struct dm_target *);

typedef void (*dm_resume_fn)(struct dm_target *);

typedef void (*dm_status_fn)(struct dm_target *, status_type_t, unsigned int, char *, unsigned int);

typedef int (*dm_message_fn)(struct dm_target *, unsigned int, char **, char *, unsigned int);

typedef int (*dm_prepare_ioctl_fn)(struct dm_target *, struct block_device **);

typedef int (*dm_report_zones_fn)(struct dm_target *);

typedef int (*dm_busy_fn)(struct dm_target *);

typedef int (*iterate_devices_callout_fn)(struct dm_target *, struct dm_dev *, sector_t, sector_t, void *);

typedef int (*dm_iterate_devices_fn)(struct dm_target *, iterate_devices_callout_fn, void *);

typedef void (*dm_io_hints_fn)(struct dm_target *, struct queue_limits *);

typedef long int (*dm_dax_direct_access_fn)(struct dm_target *, long unsigned int, long int, enum dax_access_mode, void **, pfn_t *);

typedef int (*dm_dax_zero_page_range_fn)(struct dm_target *, long unsigned int, size_t);

typedef size_t (*dm_dax_recovery_write_fn)(struct dm_target *, long unsigned int, void *, size_t, struct iov_iter *);

struct target_type {
	uint64_t features;
	const char *name;
	struct module *module;
	unsigned int version[3];
	dm_ctr_fn ctr;
	dm_dtr_fn dtr;
	dm_map_fn map;
	dm_clone_and_map_request_fn clone_and_map_rq;
	dm_release_clone_request_fn release_clone_rq;
	dm_endio_fn end_io;
	dm_request_endio_fn rq_end_io;
	dm_presuspend_fn presuspend;
	dm_presuspend_undo_fn presuspend_undo;
	dm_postsuspend_fn postsuspend;
	dm_preresume_fn preresume;
	dm_resume_fn resume;
	dm_status_fn status;
	dm_message_fn message;
	dm_prepare_ioctl_fn prepare_ioctl;
	dm_report_zones_fn report_zones;
	dm_busy_fn busy;
	dm_iterate_devices_fn iterate_devices;
	dm_io_hints_fn io_hints;
	dm_dax_direct_access_fn direct_access;
	dm_dax_zero_page_range_fn dax_zero_page_range;
	dm_dax_recovery_write_fn dax_recovery_write;
	struct list_head list;
};

struct task_delay_info {
	raw_spinlock_t lock;
	u64 blkio_start;
	u64 blkio_delay_max;
	u64 blkio_delay_min;
	u64 blkio_delay;
	u64 swapin_start;
	u64 swapin_delay_max;
	u64 swapin_delay_min;
	u64 swapin_delay;
	u32 blkio_count;
	u32 swapin_count;
	u64 freepages_start;
	u64 freepages_delay_max;
	u64 freepages_delay_min;
	u64 freepages_delay;
	u64 thrashing_start;
	u64 thrashing_delay_max;
	u64 thrashing_delay_min;
	u64 thrashing_delay;
	u64 compact_start;
	u64 compact_delay_max;
	u64 compact_delay_min;
	u64 compact_delay;
	u64 wpcopy_start;
	u64 wpcopy_delay_max;
	u64 wpcopy_delay_min;
	u64 wpcopy_delay;
	u64 irq_delay_max;
	u64 irq_delay_min;
	u64 irq_delay;
	u32 freepages_count;
	u32 thrashing_count;
	u32 compact_count;
	u32 wpcopy_count;
	u32 irq_count;
};

struct task_group {
	struct cgroup_subsys_state css;
	int idle;
	struct sched_entity **se;
	struct cfs_rq **cfs_rq;
	long unsigned int shares;
	long: 64;
	long: 64;
	atomic_long_t load_avg;
	struct callback_head rcu;
	struct list_head list;
	struct task_group *parent;
	struct list_head siblings;
	struct list_head children;
	struct cfs_bandwidth cfs_bandwidth;
};

typedef struct task_struct *class_find_get_task_t;

typedef struct task_struct *class_task_lock_t;

struct thread_info {
	long unsigned int flags;
	long unsigned int syscall_work;
	u32 status;
	u32 cpu;
};

struct wake_q_node {
	struct wake_q_node *next;
};

struct tlbflush_unmap_batch {
	struct arch_tlbflush_unmap_batch arch;
	bool flush_required;
	bool writable;
};

struct thread_shstk {
	u64 base;
	u64 size;
};

struct thread_struct {
	struct desc_struct tls_array[3];
	long unsigned int sp;
	short unsigned int es;
	short unsigned int ds;
	short unsigned int fsindex;
	short unsigned int gsindex;
	long unsigned int fsbase;
	long unsigned int gsbase;
	struct perf_event *ptrace_bps[4];
	long unsigned int virtual_dr6;
	long unsigned int ptrace_dr7;
	long unsigned int cr2;
	long unsigned int trap_nr;
	long unsigned int error_code;
	struct io_bitmap *io_bitmap;
	long unsigned int iopl_emul;
	unsigned int iopl_warn: 1;
	u32 pkru;
	long unsigned int features;
	long unsigned int features_locked;
	struct thread_shstk shstk;
	long: 64;
	struct fpu fpu;
};

struct uprobe_task;

struct task_struct {
	struct thread_info thread_info;
	unsigned int __state;
	unsigned int saved_state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	int on_cpu;
	struct __call_single_node wake_entry;
	unsigned int wakee_flips;
	long unsigned int wakee_flip_decay_ts;
	struct task_struct *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	struct sched_entity se;
	struct sched_rt_entity rt;
	struct sched_dl_entity dl;
	struct sched_dl_entity *dl_server;
	const struct sched_class *sched_class;
	struct task_group *sched_task_group;
	struct sched_statistics stats;
	struct hlist_head preempt_notifiers;
	unsigned int btrace_seq;
	unsigned int policy;
	long unsigned int max_allowed_capacity;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t *user_cpus_ptr;
	cpumask_t cpus_mask;
	void *migration_pending;
	short unsigned int migration_disabled;
	short unsigned int migration_flags;
	int rcu_read_lock_nesting;
	union rcu_special rcu_read_unlock_special;
	struct list_head rcu_node_entry;
	struct rcu_node *rcu_blocked_node;
	long unsigned int rcu_tasks_nvcsw;
	u8 rcu_tasks_holdout;
	u8 rcu_tasks_idx;
	int rcu_tasks_idle_cpu;
	struct list_head rcu_tasks_holdout_list;
	int rcu_tasks_exit_cpu;
	struct list_head rcu_tasks_exit_list;
	int trc_reader_nesting;
	int trc_ipi_to_cpu;
	union rcu_special trc_reader_special;
	struct list_head trc_holdout_list;
	struct list_head trc_blkd_node;
	int trc_blkd_cpu;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct *mm;
	struct mm_struct *active_mm;
	struct address_space *faults_disabled_mapping;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	long unsigned int jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	unsigned int sched_task_hot: 1;
	long: 28;
	unsigned int sched_remote_wakeup: 1;
	unsigned int sched_rt_mutex: 1;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int restore_sigmask: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	unsigned int use_memdelay: 1;
	unsigned int in_memstall: 1;
	unsigned int in_eventfd: 1;
	unsigned int pasid_activated: 1;
	unsigned int reported_split_lock: 1;
	unsigned int in_thrashing: 1;
	long unsigned int atomic_flags;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	long unsigned int stack_canary;
	struct task_struct *real_parent;
	struct task_struct *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_node;
	struct completion *vfork_done;
	int *set_child_tid;
	int *clear_child_tid;
	void *worker_private;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	u64 start_time;
	u64 start_boottime;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	struct posix_cputimers posix_cputimers;
	struct posix_cputimers_work posix_cputimers_work;
	const struct cred *ptracer_cred;
	const struct cred *real_cred;
	const struct cred *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	struct fs_struct *fs;
	struct files_struct *files;
	struct io_uring_task *io_uring;
	struct nsproxy *nsproxy;
	struct signal_struct *signal;
	struct sighand_struct *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	long unsigned int sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct audit_context *audit_context;
	kuid_t loginuid;
	unsigned int sessionid;
	struct seccomp seccomp;
	struct syscall_user_dispatch syscall_dispatch;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	struct rb_root_cached pi_waiters;
	struct task_struct *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct io_context *io_context;
	struct capture_control *capture_control;
	long unsigned int ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	unsigned int psi_flags;
	u64 acct_rss_mem1;
	u64 acct_vm_mem1;
	u64 acct_timexpd;
	nodemask_t mems_allowed;
	seqcount_spinlock_t mems_allowed_seq;
	int cpuset_mem_spread_rotor;
	struct css_set *cgroups;
	struct list_head cg_list;
	struct robust_list_head *robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	u8 perf_recursion[4];
	struct perf_event_context *perf_event_ctxp;
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	struct perf_ctx_data *perf_ctx_data;
	struct mempolicy *mempolicy;
	short int il_prev;
	u8 il_weight;
	short int pref_node_fork;
	struct rseq *rseq;
	u32 rseq_len;
	u32 rseq_sig;
	long unsigned int rseq_event_mask;
	int mm_cid;
	int last_mm_cid;
	int migrate_from_cpu;
	int mm_cid_active;
	struct callback_head cid_work;
	struct tlbflush_unmap_batch tlb_ubc;
	struct pipe_inode_info *splice_pipe;
	struct page_frag task_frag;
	struct task_delay_info *delays;
	int nr_dirtied;
	int nr_dirtied_pause;
	long unsigned int dirty_paused_when;
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	long unsigned int trace_recursion;
	unsigned int memcg_nr_pages_over_high;
	struct mem_cgroup *active_memcg;
	struct obj_cgroup *objcg;
	struct gendisk *throttle_disk;
	struct uprobe_task *utask;
	struct kmap_ctrl kmap_ctrl;
	struct callback_head rcu;
	refcount_t rcu_users;
	int pagefault_disabled;
	struct task_struct *oom_reaper_list;
	struct timer_list oom_reaper_timer;
	struct vm_struct *stack_vm_area;
	refcount_t stack_refcount;
	void *security;
	struct bpf_local_storage *bpf_storage;
	struct bpf_run_ctx *bpf_ctx;
	struct bpf_net_context *bpf_net_context;
	void *mce_vaddr;
	__u64 mce_kflags;
	u64 mce_addr;
	__u64 mce_ripv: 1;
	__u64 mce_whole_page: 1;
	__u64 __mce_reserved: 62;
	struct callback_head mce_kill_me;
	int mce_count;
	struct llist_head kretprobe_instances;
	struct llist_head rethooks;
	struct callback_head l1d_flush_kill;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct thread_struct thread;
};

struct task_struct__safe_rcu {
	const cpumask_t *cpus_ptr;
	struct css_set *cgroups;
	struct task_struct *real_parent;
	struct task_struct *group_leader;
};

struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

struct taskstats {
	__u16 version;
	__u32 ac_exitcode;
	__u8 ac_flag;
	__u8 ac_nice;
	__u64 cpu_count;
	__u64 cpu_delay_total;
	__u64 cpu_delay_max;
	__u64 cpu_delay_min;
	__u64 blkio_count;
	__u64 blkio_delay_total;
	__u64 blkio_delay_max;
	__u64 blkio_delay_min;
	__u64 swapin_count;
	__u64 swapin_delay_total;
	__u64 swapin_delay_max;
	__u64 swapin_delay_min;
	__u64 cpu_run_real_total;
	__u64 cpu_run_virtual_total;
	char ac_comm[32];
	__u8 ac_sched;
	__u8 ac_pad[3];
	long: 0;
	__u32 ac_uid;
	__u32 ac_gid;
	__u32 ac_pid;
	__u32 ac_ppid;
	__u32 ac_btime;
	__u64 ac_etime;
	__u64 ac_utime;
	__u64 ac_stime;
	__u64 ac_minflt;
	__u64 ac_majflt;
	__u64 coremem;
	__u64 virtmem;
	__u64 hiwater_rss;
	__u64 hiwater_vm;
	__u64 read_char;
	__u64 write_char;
	__u64 read_syscalls;
	__u64 write_syscalls;
	__u64 read_bytes;
	__u64 write_bytes;
	__u64 cancelled_write_bytes;
	__u64 nvcsw;
	__u64 nivcsw;
	__u64 ac_utimescaled;
	__u64 ac_stimescaled;
	__u64 cpu_scaled_run_real_total;
	__u64 freepages_count;
	__u64 freepages_delay_total;
	__u64 freepages_delay_max;
	__u64 freepages_delay_min;
	__u64 thrashing_count;
	__u64 thrashing_delay_total;
	__u64 thrashing_delay_max;
	__u64 thrashing_delay_min;
	__u64 ac_btime64;
	__u64 compact_count;
	__u64 compact_delay_total;
	__u64 compact_delay_max;
	__u64 compact_delay_min;
	__u32 ac_tgid;
	__u64 ac_tgetime;
	__u64 ac_exe_dev;
	__u64 ac_exe_inode;
	__u64 wpcopy_count;
	__u64 wpcopy_delay_total;
	__u64 wpcopy_delay_max;
	__u64 wpcopy_delay_min;
	__u64 irq_count;
	__u64 irq_delay_total;
	__u64 irq_delay_max;
	__u64 irq_delay_min;
};

struct tbf_sched_data {
	u32 limit;
	u32 max_size;
	s64 buffer;
	s64 mtu;
	struct psched_ratecfg rate;
	struct psched_ratecfg peak;
	s64 tokens;
	s64 ptokens;
	s64 t_c;
	struct Qdisc *qdisc;
	struct qdisc_watchdog watchdog;
};

struct tc_act_bpf {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
};

struct tc_act_pernet_id {
	struct list_head list;
	unsigned int id;
};

struct tcf_t {
	__u64 install;
	__u64 lastuse;
	__u64 expires;
	__u64 firstuse;
};

struct tc_action_ops;

struct tcf_idrinfo;

struct tc_cookie;

struct tc_action {
	const struct tc_action_ops *ops;
	__u32 type;
	struct tcf_idrinfo *idrinfo;
	u32 tcfa_index;
	refcount_t tcfa_refcnt;
	atomic_t tcfa_bindcnt;
	int tcfa_action;
	struct tcf_t tcfa_tm;
	long: 64;
	struct gnet_stats_basic_sync tcfa_bstats;
	struct gnet_stats_basic_sync tcfa_bstats_hw;
	struct gnet_stats_queue tcfa_qstats;
	struct net_rate_estimator *tcfa_rate_est;
	spinlock_t tcfa_lock;
	struct gnet_stats_basic_sync *cpu_bstats;
	struct gnet_stats_basic_sync *cpu_bstats_hw;
	struct gnet_stats_queue *cpu_qstats;
	struct tc_cookie *user_cookie;
	struct tcf_chain *goto_chain;
	u32 tcfa_flags;
	u8 hw_stats;
	u8 used_hw_stats;
	bool used_hw_stats_valid;
	u32 in_hw_count;
};

struct tc_action_net {
	struct tcf_idrinfo *idrinfo;
	const struct tc_action_ops *ops;
};

typedef void (*tc_action_priv_destructor)(void *);

struct tc_action_ops {
	struct list_head head;
	char kind[16];
	enum tca_id id;
	unsigned int net_id;
	size_t size;
	struct module *owner;
	int (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
	int (*dump)(struct sk_buff *, struct tc_action *, int, int);
	void (*cleanup)(struct tc_action *);
	int (*lookup)(struct net *, struct tc_action **, u32);
	int (*init)(struct net *, struct nlattr *, struct nlattr *, struct tc_action **, struct tcf_proto *, u32, struct netlink_ext_ack *);
	int (*walk)(struct net *, struct sk_buff *, struct netlink_callback *, int, const struct tc_action_ops *, struct netlink_ext_ack *);
	void (*stats_update)(struct tc_action *, u64, u64, u64, u64, bool);
	size_t (*get_fill_size)(const struct tc_action *);
	struct net_device * (*get_dev)(const struct tc_action *, tc_action_priv_destructor *);
	struct psample_group * (*get_psample_group)(const struct tc_action *, tc_action_priv_destructor *);
	int (*offload_act_setup)(struct tc_action *, void *, u32 *, bool, struct netlink_ext_ack *);
};

struct tc_basic_pcnt {
	__u64 rcnt;
	__u64 rhit;
};

struct tc_bind_class_args {
	struct qdisc_walker w;
	long unsigned int new_cl;
	u32 portid;
	u32 clid;
};

struct tc_cbs_qopt {
	__u8 offload;
	__u8 _pad[3];
	__s32 hicredit;
	__s32 locredit;
	__s32 idleslope;
	__s32 sendslope;
};

struct tc_cbs_qopt_offload {
	u8 enable;
	s32 queue;
	s32 hicredit;
	s32 locredit;
	s32 idleslope;
	s32 sendslope;
};

struct tc_choke_xstats {
	__u32 early;
	__u32 pdrop;
	__u32 other;
	__u32 marked;
	__u32 matched;
};

struct tc_cls_bpf_offload {
	struct flow_cls_common_offload common;
	enum tc_clsbpf_command command;
	struct tcf_exts *exts;
	struct bpf_prog *prog;
	struct bpf_prog *oldprog;
	const char *name;
	bool exts_integrated;
};

struct tc_cls_matchall_offload {
	struct flow_cls_common_offload common;
	enum tc_matchall_command command;
	struct flow_rule *rule;
	struct flow_stats stats;
	bool use_act_stats;
	long unsigned int cookie;
};

struct tc_cls_u32_hnode {
	u32 handle;
	u32 prio;
	unsigned int divisor;
};

struct tc_u32_sel;

struct tc_cls_u32_knode {
	struct tcf_exts *exts;
	struct tcf_result *res;
	struct tc_u32_sel *sel;
	u32 handle;
	u32 val;
	u32 mask;
	u32 link_handle;
	u8 fshift;
};

struct tc_cls_u32_offload {
	struct flow_cls_common_offload common;
	enum tc_clsu32_command command;
	union {
		struct tc_cls_u32_knode knode;
		struct tc_cls_u32_hnode hnode;
	};
};

struct tc_codel_xstats {
	__u32 maxpacket;
	__u32 count;
	__u32 lastcount;
	__u32 ldelay;
	__s32 drop_next;
	__u32 drop_overlimit;
	__u32 ecn_mark;
	__u32 dropping;
	__u32 ce_mark;
};

struct tc_connmark {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
	__u16 zone;
};

struct tc_cookie {
	u8 *data;
	u32 len;
	struct callback_head rcu;
};

struct tc_csum {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
	__u32 update_flags;
};

struct tc_ct {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
};

struct tc_ct_action_net {
	struct tc_action_net tn;
};

struct tc_ctinfo {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
};

struct tc_defact {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
};

struct tc_drr_stats {
	__u32 deficit;
};

struct tc_etf_qopt {
	__s32 delta;
	__s32 clockid;
	__u32 flags;
};

struct tc_etf_qopt_offload {
	u8 enable;
	s32 queue;
};

struct tc_ets_qopt_offload_replace_params {
	unsigned int bands;
	u8 priomap[16];
	unsigned int quanta[16];
	unsigned int weights[16];
	struct gnet_stats_queue *qstats;
};

struct tc_qopt_offload_stats {
	struct gnet_stats_basic_sync *bstats;
	struct gnet_stats_queue *qstats;
};

struct tc_ets_qopt_offload_graft_params {
	u8 band;
	u32 child_handle;
};

struct tc_ets_qopt_offload {
	enum tc_ets_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_ets_qopt_offload_replace_params replace_params;
		struct tc_qopt_offload_stats stats;
		struct tc_ets_qopt_offload_graft_params graft_params;
	};
};

struct tc_fifo_qopt {
	__u32 limit;
};

struct tc_fifo_qopt_offload {
	enum tc_fifo_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_qopt_offload_stats stats;
	};
};

struct tc_fq_codel_cl_stats {
	__s32 deficit;
	__u32 ldelay;
	__u32 count;
	__u32 lastcount;
	__u32 dropping;
	__s32 drop_next;
};

struct tc_fq_codel_qd_stats {
	__u32 maxpacket;
	__u32 drop_overlimit;
	__u32 ecn_mark;
	__u32 new_flow_count;
	__u32 new_flows_len;
	__u32 old_flows_len;
	__u32 ce_mark;
	__u32 memory_usage;
	__u32 drop_overmemory;
};

struct tc_fq_codel_xstats {
	__u32 type;
	union {
		struct tc_fq_codel_qd_stats qdisc_stats;
		struct tc_fq_codel_cl_stats class_stats;
	};
};

struct tc_fq_pie_xstats {
	__u32 packets_in;
	__u32 dropped;
	__u32 overlimit;
	__u32 overmemory;
	__u32 ecn_mark;
	__u32 new_flow_count;
	__u32 new_flows_len;
	__u32 old_flows_len;
	__u32 memory_usage;
};

struct tc_fq_qd_stats {
	__u64 gc_flows;
	__u64 highprio_packets;
	__u64 tcp_retrans;
	__u64 throttled;
	__u64 flows_plimit;
	__u64 pkts_too_long;
	__u64 allocation_errors;
	__s64 time_next_delayed_flow;
	__u32 flows;
	__u32 inactive_flows;
	__u32 throttled_flows;
	__u32 unthrottle_latency_ns;
	__u64 ce_mark;
	__u64 horizon_drops;
	__u64 horizon_caps;
	__u64 fastpath_packets;
	__u64 band_drops[3];
	__u32 band_pkt_count[3];
	__u32 pad;
};

struct tc_gact {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
};

struct tc_gact_p {
	__u16 ptype;
	__u16 pval;
	int paction;
};

struct tc_gate {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
};

struct tc_gred_qopt {
	__u32 limit;
	__u32 qth_min;
	__u32 qth_max;
	__u32 DP;
	__u32 backlog;
	__u32 qave;
	__u32 forced;
	__u32 early;
	__u32 other;
	__u32 pdrop;
	__u8 Wlog;
	__u8 Plog;
	__u8 Scell_log;
	__u8 prio;
	__u32 packets;
	__u32 bytesin;
};

struct tc_gred_vq_qopt_offload_params {
	bool present;
	u32 limit;
	u32 prio;
	u32 min;
	u32 max;
	bool is_ecn;
	bool is_harddrop;
	u32 probability;
	u32 *backlog;
};

struct tc_gred_qopt_offload_params {
	bool grio_on;
	bool wred_on;
	unsigned int dp_cnt;
	unsigned int dp_def;
	struct gnet_stats_queue *qstats;
	struct tc_gred_vq_qopt_offload_params tab[16];
};

struct tc_gred_qopt_offload_stats {
	struct gnet_stats_basic_sync bstats[16];
	struct gnet_stats_queue qstats[16];
	struct red_stats *xstats[16];
};

struct tc_gred_qopt_offload {
	enum tc_gred_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_gred_qopt_offload_params set;
		struct tc_gred_qopt_offload_stats stats;
	};
};

struct tc_gred_sopt {
	__u32 DPs;
	__u32 def_DP;
	__u8 grio;
	__u8 flags;
	__u16 pad1;
};

struct tc_hfsc_qopt {
	__u16 defcls;
};

struct tc_hfsc_stats {
	__u64 work;
	__u64 rtwork;
	__u32 period;
	__u32 level;
};

struct tc_hhf_xstats {
	__u32 drop_overlimit;
	__u32 hh_overlimit;
	__u32 hh_tot_count;
	__u32 hh_cur_count;
};

struct tc_htb_glob {
	__u32 version;
	__u32 rate2quantum;
	__u32 defcls;
	__u32 debug;
	__u32 direct_pkts;
};

struct tc_htb_opt {
	struct tc_ratespec rate;
	struct tc_ratespec ceil;
	__u32 buffer;
	__u32 cbuffer;
	__u32 quantum;
	__u32 level;
	__u32 prio;
};

struct tc_htb_qopt_offload {
	struct netlink_ext_ack *extack;
	enum tc_htb_command command;
	u32 parent_classid;
	u16 classid;
	u16 qid;
	u32 quantum;
	u64 rate;
	u64 ceil;
	u8 prio;
};

struct tc_ife {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
	__u16 flags;
};

struct tc_matchall_pcnt {
	__u64 rhit;
};

struct tc_mirred {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
	int eaction;
	__u32 ifindex;
};

struct tc_mpls {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
	int m_action;
};

struct tc_mq_opt_offload_graft_params {
	long unsigned int queue;
	u32 child_handle;
};

struct tc_mq_qopt_offload {
	enum tc_mq_command command;
	u32 handle;
	union {
		struct tc_qopt_offload_stats stats;
		struct tc_mq_opt_offload_graft_params graft_params;
	};
};

struct tc_mqprio_caps {
	bool validate_queue_counts: 1;
};

struct tc_multiq_qopt {
	__u16 bands;
	__u16 max_bands;
};

struct tc_nat {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
	__be32 old_addr;
	__be32 new_addr;
	__be32 mask;
	__u32 flags;
};

struct tc_netem_corr {
	__u32 delay_corr;
	__u32 loss_corr;
	__u32 dup_corr;
};

struct tc_netem_corrupt {
	__u32 probability;
	__u32 correlation;
};

struct tc_netem_gemodel {
	__u32 p;
	__u32 r;
	__u32 h;
	__u32 k1;
};

struct tc_netem_gimodel {
	__u32 p13;
	__u32 p31;
	__u32 p32;
	__u32 p14;
	__u32 p23;
};

struct tc_netem_qopt {
	__u32 latency;
	__u32 limit;
	__u32 loss;
	__u32 gap;
	__u32 duplicate;
	__u32 jitter;
};

struct tc_netem_rate {
	__u32 rate;
	__s32 packet_overhead;
	__u32 cell_size;
	__s32 cell_overhead;
};

struct tc_netem_reorder {
	__u32 probability;
	__u32 correlation;
};

struct tc_pedit_key {
	__u32 mask;
	__u32 val;
	__u32 off;
	__u32 at;
	__u32 offmask;
	__u32 shift;
};

struct tc_pedit_sel {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
	unsigned char nkeys;
	unsigned char flags;
	struct tc_pedit_key keys[0];
};

struct tc_pie_xstats {
	__u64 prob;
	__u32 delay;
	__u32 avg_dq_rate;
	__u32 dq_rate_estimating;
	__u32 packets_in;
	__u32 dropped;
	__u32 overlimit;
	__u32 maxq;
	__u32 ecn_mark;
};

struct tc_plug_qopt {
	int action;
	__u32 limit;
};

struct tc_police {
	__u32 index;
	int action;
	__u32 limit;
	__u32 burst;
	__u32 mtu;
	struct tc_ratespec rate;
	struct tc_ratespec peakrate;
	int refcnt;
	int bindcnt;
	__u32 capab;
};

struct tc_prio_qopt {
	int bands;
	__u8 priomap[16];
};

struct tc_prio_qopt_offload_params {
	int bands;
	u8 priomap[16];
	struct gnet_stats_queue *qstats;
};

struct tc_prio_qopt_offload_graft_params {
	u8 band;
	u32 child_handle;
};

struct tc_prio_qopt_offload {
	enum tc_prio_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_prio_qopt_offload_params replace_params;
		struct tc_qopt_offload_stats stats;
		struct tc_prio_qopt_offload_graft_params graft_params;
	};
};

struct tc_qfq_stats {
	__u32 weight;
	__u32 lmax;
};

struct tc_query_caps_base {
	enum tc_setup_type type;
	void *caps;
};

struct tc_red_qopt {
	__u32 limit;
	__u32 qth_min;
	__u32 qth_max;
	unsigned char Wlog;
	unsigned char Plog;
	unsigned char Scell_log;
	unsigned char flags;
};

struct tc_red_qopt_offload_params {
	u32 min;
	u32 max;
	u32 probability;
	u32 limit;
	bool is_ecn;
	bool is_harddrop;
	bool is_nodrop;
	struct gnet_stats_queue *qstats;
};

struct tc_red_qopt_offload {
	enum tc_red_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_red_qopt_offload_params set;
		struct tc_qopt_offload_stats stats;
		struct red_stats *xstats;
		u32 child_handle;
	};
};

struct tc_red_xstats {
	__u32 early;
	__u32 pdrop;
	__u32 other;
	__u32 marked;
};

struct tc_root_qopt_offload {
	enum tc_root_command command;
	u32 handle;
	bool ingress;
};

struct tc_sample {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
};

struct tc_service_curve {
	__u32 m1;
	__u32 d;
	__u32 m2;
};

struct tc_sfb_qopt {
	__u32 rehash_interval;
	__u32 warmup_time;
	__u32 max;
	__u32 bin_size;
	__u32 increment;
	__u32 decrement;
	__u32 limit;
	__u32 penalty_rate;
	__u32 penalty_burst;
};

struct tc_sfb_xstats {
	__u32 earlydrop;
	__u32 penaltydrop;
	__u32 bucketdrop;
	__u32 queuedrop;
	__u32 childdrop;
	__u32 marked;
	__u32 maxqlen;
	__u32 maxprob;
	__u32 avgprob;
};

struct tc_sfq_qopt {
	unsigned int quantum;
	int perturb_period;
	__u32 limit;
	unsigned int divisor;
	unsigned int flows;
};

struct tc_sfq_qopt_v1 {
	struct tc_sfq_qopt v0;
	unsigned int depth;
	unsigned int headdrop;
	__u32 limit;
	__u32 qth_min;
	__u32 qth_max;
	unsigned char Wlog;
	unsigned char Plog;
	unsigned char Scell_log;
	unsigned char flags;
	__u32 max_P;
	struct tc_sfqred_stats stats;
};

struct tc_sfq_xstats {
	__s32 allot;
};

struct tc_skb_cb {
	struct qdisc_skb_cb qdisc_cb;
	u32 drop_reason;
	u16 zone;
	u16 mru;
	u8 post_ct: 1;
	u8 post_ct_snat: 1;
	u8 post_ct_dnat: 1;
};

struct tc_skb_ext {
	union {
		u64 act_miss_cookie;
		__u32 chain;
	};
	__u16 mru;
	__u16 zone;
	u8 post_ct: 1;
	u8 post_ct_snat: 1;
	u8 post_ct_dnat: 1;
	u8 act_miss: 1;
	u8 l2_miss: 1;
};

struct tc_skbedit {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
};

struct tc_skbmod {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
	__u64 flags;
};

struct tc_skbprio_qopt {
	__u32 limit;
};

struct tc_taprio_caps {
	bool supports_queue_max_sdu: 1;
	bool gate_mask_per_txq: 1;
	bool broken_mqprio: 1;
};

struct tc_tbf_qopt {
	struct tc_ratespec rate;
	struct tc_ratespec peakrate;
	__u32 limit;
	__u32 buffer;
	__u32 mtu;
};

struct tc_tbf_qopt_offload_replace_params {
	struct psched_ratecfg rate;
	u32 max_size;
	struct gnet_stats_queue *qstats;
};

struct tc_tbf_qopt_offload {
	enum tc_tbf_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_tbf_qopt_offload_replace_params replace_params;
		struct tc_qopt_offload_stats stats;
		u32 child_handle;
	};
};

struct tc_tunnel_key {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
	int t_action;
};

struct tc_u32_key {
	__be32 mask;
	__be32 val;
	int off;
	int offmask;
};

struct tc_u32_mark {
	__u32 val;
	__u32 mask;
	__u32 success;
};

struct tc_u32_pcnt {
	__u64 rcnt;
	__u64 rhit;
	__u64 kcnts[0];
};

struct tc_u32_sel_hdr {
	unsigned char flags;
	unsigned char offshift;
	unsigned char nkeys;
	__be16 offmask;
	__u16 off;
	short int offoff;
	short int hoff;
	__be32 hmask;
};

struct tc_u32_sel {
	union {
		struct {
			unsigned char flags;
			unsigned char offshift;
			unsigned char nkeys;
			__be16 offmask;
			__u16 off;
			short int offoff;
			short int hoff;
			__be32 hmask;
		};
		struct tc_u32_sel_hdr hdr;
	};
	struct tc_u32_key keys[0];
};

struct tc_u_hnode;

struct tc_u_common {
	struct tc_u_hnode *hlist;
	void *ptr;
	refcount_t refcnt;
	struct idr handle_idr;
	struct hlist_node hnode;
	long int knodes;
};

struct tc_u_knode;

struct tc_u_hnode {
	struct tc_u_hnode *next;
	u32 handle;
	u32 prio;
	refcount_t refcnt;
	unsigned int divisor;
	struct idr handle_idr;
	bool is_root;
	struct callback_head rcu;
	u32 flags;
	struct tc_u_knode *ht[0];
};

struct tc_u_knode {
	struct tc_u_knode *next;
	u32 handle;
	struct tc_u_hnode *ht_up;
	struct tcf_exts exts;
	int ifindex;
	u8 fshift;
	struct tcf_result res;
	struct tc_u_hnode *ht_down;
	struct tc_u32_pcnt *pf;
	u32 flags;
	unsigned int in_hw_count;
	u32 val;
	u32 mask;
	u32 *pcpu_success;
	struct rcu_work rwork;
	struct tc_u32_sel sel;
};

struct tc_vlan {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
	int v_action;
};

struct tcamsg {
	unsigned char tca_family;
	unsigned char tca__pad1;
	short unsigned int tca__pad2;
};

struct tcf_walker {
	int stop;
	int skip;
	int count;
	bool nonempty;
	long unsigned int cookie;
	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
};

struct tcf_bind_args {
	struct tcf_walker w;
	long unsigned int base;
	long unsigned int cl;
	u32 classid;
};

struct tcf_block {
	struct xarray ports;
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net *net;
	struct Qdisc *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t useswcnt;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

struct tcf_block_owner_item {
	struct list_head list;
	struct Qdisc *q;
	enum flow_block_binder_type binder_type;
};

struct tcf_bpf {
	struct tc_action common;
	struct bpf_prog *filter;
	union {
		u32 bpf_fd;
		u16 bpf_num_ops;
	};
	struct sock_filter *bpf_ops;
	const char *bpf_name;
};

struct tcf_bpf_cfg {
	struct bpf_prog *filter;
	struct sock_filter *bpf_ops;
	const char *bpf_name;
	u16 bpf_num_ops;
	bool is_ebpf;
};

struct tcf_proto_ops;

struct tcf_chain {
	struct mutex filter_chain_lock;
	struct tcf_proto *filter_chain;
	struct list_head list;
	struct tcf_block *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct tcf_chain_info {
	struct tcf_proto **pprev;
	struct tcf_proto *next;
};

struct tcf_connmark_parms;

struct tcf_connmark_info {
	struct tc_action common;
	struct tcf_connmark_parms *parms;
	long: 64;
};

struct tcf_connmark_parms {
	struct net *net;
	u16 zone;
	struct callback_head rcu;
};

struct tcf_csum_params;

struct tcf_csum {
	struct tc_action common;
	struct tcf_csum_params *params;
	long: 64;
};

struct tcf_csum_params {
	u32 update_flags;
	struct callback_head rcu;
};

struct tcf_ct_params;

struct tcf_ct {
	struct tc_action common;
	struct tcf_ct_params *params;
	long: 64;
};

struct zones_ht_key {
	struct net *net;
	u16 zone;
};

struct tcf_ct_flow_table {
	struct rhash_head node;
	struct rcu_work rwork;
	struct nf_flowtable nf_ft;
	refcount_t ref;
	struct zones_ht_key key;
	bool dying;
};

struct tcf_ct_params {
	struct nf_conntrack_helper *helper;
	struct nf_conn *tmpl;
	u16 zone;
	u32 mark;
	u32 mark_mask;
	u32 labels[4];
	u32 labels_mask[4];
	struct nf_nat_range2 range;
	bool ipv4_range;
	bool put_labels;
	u16 ct_action;
	struct callback_head rcu;
	struct tcf_ct_flow_table *ct_ft;
	struct nf_flowtable *nf_ft;
};

struct tcf_ctinfo_params;

struct tcf_ctinfo {
	struct tc_action common;
	struct tcf_ctinfo_params *params;
	u64 stats_dscp_set;
	u64 stats_dscp_error;
	u64 stats_cpmark_set;
};

struct tcf_ctinfo_params {
	struct callback_head rcu;
	struct net *net;
	u32 dscpmask;
	u32 dscpstatemask;
	u32 cpmarkmask;
	u16 zone;
	u8 mode;
	u8 dscpmaskshift;
};

struct tcf_defact {
	struct tc_action common;
	u32 tcfd_datalen;
	void *tcfd_defdata;
};

struct tcf_dump_args {
	struct tcf_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct tcf_block *block;
	struct Qdisc *q;
	u32 parent;
	bool terse_dump;
};

struct tcf_em_cmp {
	__u32 val;
	__u32 mask;
	__u16 off;
	__u8 align: 4;
	__u8 flags: 4;
	__u8 layer: 4;
	__u8 opnd: 4;
};

struct tcf_em_text {
	char algo[16];
	__u16 from_offset;
	__u16 to_offset;
	__u16 pattern_len;
	__u8 from_layer: 4;
	__u8 to_layer: 4;
	__u8 pad;
};

struct tcf_ematch_ops;

struct tcf_ematch {
	struct tcf_ematch_ops *ops;
	long unsigned int data;
	unsigned int datalen;
	u16 matchid;
	u16 flags;
	struct net *net;
};

struct tcf_ematch_hdr {
	__u16 matchid;
	__u16 kind;
	__u16 flags;
	__u16 pad;
};

struct tcf_ematch_ops {
	int kind;
	int datalen;
	int (*change)(struct net *, void *, int, struct tcf_ematch *);
	int (*match)(struct sk_buff *, struct tcf_ematch *, struct tcf_pkt_info *);
	void (*destroy)(struct tcf_ematch *);
	int (*dump)(struct sk_buff *, struct tcf_ematch *);
	struct module *owner;
	struct list_head link;
};

union tcf_exts_miss_cookie {
	struct {
		u32 miss_cookie_base;
		u32 act_index;
	};
	u64 miss_cookie;
};

struct tcf_exts_miss_cookie_node {
	const struct tcf_chain *chain;
	const struct tcf_proto *tp;
	const struct tcf_exts *exts;
	u32 chain_index;
	u32 tp_prio;
	u32 handle;
	u32 miss_cookie_base;
	struct callback_head rcu;
};

struct tcf_filter_chain_list_item {
	struct list_head list;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
};

struct tcf_gact {
	struct tc_action common;
	u16 tcfg_ptype;
	u16 tcfg_pval;
	int tcfg_paction;
	atomic_t packets;
};

struct tcf_gate_params {
	s32 tcfg_priority;
	u64 tcfg_basetime;
	u64 tcfg_cycletime;
	u64 tcfg_cycletime_ext;
	u32 tcfg_flags;
	s32 tcfg_clockid;
	size_t num_entries;
	struct list_head entries;
};

struct tcfg_gate_entry;

struct tcf_gate {
	struct tc_action common;
	struct tcf_gate_params param;
	u8 current_gate_status;
	ktime_t current_close_time;
	u32 current_entry_octets;
	s32 current_max_octets;
	struct tcfg_gate_entry *next_entry;
	struct hrtimer hitimer;
	enum tk_offsets tk_offset;
	long: 64;
};

struct tcf_idrinfo {
	struct mutex lock;
	struct idr action_idr;
	struct net *net;
};

struct tcf_ife_params;

struct tcf_ife_info {
	struct tc_action common;
	struct tcf_ife_params *params;
	struct list_head metalist;
	long: 64;
};

struct tcf_ife_params {
	u8 eth_dst[6];
	u8 eth_src[6];
	u16 eth_type;
	u16 flags;
	struct callback_head rcu;
};

struct tcf_meta_hdr {
	struct tcf_meta_val left;
	struct tcf_meta_val right;
};

struct tcf_meta_ops;

struct tcf_meta_info {
	const struct tcf_meta_ops *ops;
	void *metaval;
	u16 metaid;
	struct list_head metalist;
};

struct tcf_meta_ops {
	u16 metaid;
	u16 metatype;
	const char *name;
	const char *synopsis;
	struct list_head list;
	int (*check_presence)(struct sk_buff *, struct tcf_meta_info *);
	int (*encode)(struct sk_buff *, void *, struct tcf_meta_info *);
	int (*decode)(struct sk_buff *, void *, u16);
	int (*get)(struct sk_buff *, struct tcf_meta_info *);
	int (*alloc)(struct tcf_meta_info *, void *, gfp_t);
	void (*release)(struct tcf_meta_info *);
	int (*validate)(void *, int);
	struct module *owner;
};

struct tcf_mirred {
	struct tc_action common;
	int tcfm_eaction;
	u32 tcfm_blockid;
	bool tcfm_mac_header_xmit;
	struct net_device *tcfm_dev;
	netdevice_tracker tcfm_dev_tracker;
	struct list_head tcfm_list;
	long: 64;
};

struct tcf_mpls_params;

struct tcf_mpls {
	struct tc_action common;
	struct tcf_mpls_params *mpls_p;
	long: 64;
};

struct tcf_mpls_params {
	int tcfm_action;
	u32 tcfm_label;
	u8 tcfm_tc;
	u8 tcfm_ttl;
	u8 tcfm_bos;
	__be16 tcfm_proto;
	struct callback_head rcu;
};

struct tcf_nat_parms;

struct tcf_nat {
	struct tc_action common;
	struct tcf_nat_parms *parms;
	long: 64;
};

struct tcf_nat_parms {
	__be32 old_addr;
	__be32 new_addr;
	__be32 mask;
	u32 flags;
	struct callback_head rcu;
};

struct tcf_net {
	spinlock_t idr_lock;
	struct idr idr;
};

struct tcf_pedit_parms;

struct tcf_pedit {
	struct tc_action common;
	struct tcf_pedit_parms *parms;
	long: 64;
};

struct tcf_pedit_key_ex {
	enum pedit_header_type htype;
	enum pedit_cmd cmd;
};

struct tcf_pedit_parms {
	struct tc_pedit_key *tcfp_keys;
	struct tcf_pedit_key_ex *tcfp_keys_ex;
	u32 tcfp_off_max_hint;
	unsigned char tcfp_nkeys;
	unsigned char tcfp_flags;
	struct callback_head rcu;
};

struct tcf_pkt_info {
	unsigned char *ptr;
	int nexthdr;
};

struct tcf_police_params;

struct tcf_police {
	struct tc_action common;
	struct tcf_police_params *params;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t tcfp_lock;
	s64 tcfp_toks;
	s64 tcfp_ptoks;
	s64 tcfp_pkttoks;
	s64 tcfp_t_c;
	long: 64;
	long: 64;
	long: 64;
};

struct tcf_police_params {
	int tcfp_result;
	u32 tcfp_ewma_rate;
	s64 tcfp_burst;
	u32 tcfp_mtu;
	s64 tcfp_mtu_ptoks;
	s64 tcfp_pkt_burst;
	struct psched_ratecfg rate;
	bool rate_present;
	struct psched_ratecfg peak;
	bool peak_present;
	struct psched_pktrate ppsrate;
	bool pps_present;
	struct callback_head rcu;
};

struct tcf_proto {
	struct tcf_proto *next;
	void *root;
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops *ops;
	struct tcf_chain *chain;
	spinlock_t lock;
	bool deleting;
	bool counted;
	bool usesw;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

struct tcf_proto_ops {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	int (*init)(struct tcf_proto *);
	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto *, u32);
	void (*put)(struct tcf_proto *, void *);
	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, u32, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto *);
	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto *, void *);
	void (*hw_del)(struct tcf_proto *, void *);
	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	void (*tmplt_reoffload)(struct tcf_chain *, bool, flow_setup_cb_t *, void *);
	struct tcf_exts * (*get_exts)(const struct tcf_proto *, u32);
	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
	struct module *owner;
	int flags;
};

struct tcf_sample {
	struct tc_action common;
	u32 rate;
	bool truncate;
	u32 trunc_size;
	struct psample_group *psample_group;
	u32 psample_group_num;
	struct list_head tcfm_list;
};

struct tcf_skbedit_params;

struct tcf_skbedit {
	struct tc_action common;
	struct tcf_skbedit_params *params;
	long: 64;
};

struct tcf_skbedit_params {
	u32 flags;
	u32 priority;
	u32 mark;
	u32 mask;
	u16 queue_mapping;
	u16 mapping_mod;
	u16 ptype;
	struct callback_head rcu;
};

struct tcf_skbmod_params;

struct tcf_skbmod {
	struct tc_action common;
	struct tcf_skbmod_params *skbmod_p;
	long: 64;
};

struct tcf_skbmod_params {
	struct callback_head rcu;
	u64 flags;
	u8 eth_dst[6];
	u16 eth_type;
	u8 eth_src[6];
};

struct tcf_tunnel_key_params;

struct tcf_tunnel_key {
	struct tc_action common;
	struct tcf_tunnel_key_params *params;
	long: 64;
};

struct tcf_tunnel_key_params {
	struct callback_head rcu;
	int tcft_action;
	struct metadata_dst *tcft_enc_metadata;
};

struct tcf_vlan_params;

struct tcf_vlan {
	struct tc_action common;
	struct tcf_vlan_params *vlan_p;
	long: 64;
};

struct tcf_vlan_params {
	int tcfv_action;
	unsigned char tcfv_push_dst[6];
	unsigned char tcfv_push_src[6];
	u16 tcfv_push_vid;
	__be16 tcfv_push_proto;
	u8 tcfv_push_prio;
	bool tcfv_push_prio_exists;
	struct callback_head rcu;
};

struct tcfg_gate_entry {
	int index;
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
	struct list_head list;
};

struct tcg_efi_specid_event_algs {
	u16 alg_id;
	u16 digest_size;
};

struct tcg_efi_specid_event_head {
	u8 signature[16];
	u32 platform_class;
	u8 spec_version_minor;
	u8 spec_version_major;
	u8 spec_errata;
	u8 uintnsize;
	u32 num_algs;
	struct tcg_efi_specid_event_algs digest_sizes[0];
};

struct tcg_event_field {
	u32 event_size;
	u8 event[0];
};

struct tcg_pcr_event {
	u32 pcr_idx;
	u32 event_type;
	u8 digest[20];
	u32 event_size;
	u8 event[0];
};

struct tpm_digest {
	u16 alg_id;
	u8 digest[64];
};

struct tcg_pcr_event2_head {
	u32 pcr_idx;
	u32 event_type;
	u32 count;
	struct tpm_digest digests[0];
};

struct tcmsg {
	unsigned char tcm_family;
	unsigned char tcm__pad1;
	short unsigned int tcm__pad2;
	int tcm_ifindex;
	__u32 tcm_handle;
	__u32 tcm_parent;
	__u32 tcm_info;
};

struct tcp4_pseudohdr {
	__be32 saddr;
	__be32 daddr;
	__u8 pad;
	__u8 protocol;
	__be16 len;
};

struct tcp6_pseudohdr {
	struct in6_addr saddr;
	struct in6_addr daddr;
	__be32 len;
	__be32 protocol;
};

struct tcp_options_received {
	int ts_recent_stamp;
	u32 ts_recent;
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 saw_tstamp: 1;
	u16 tstamp_ok: 1;
	u16 dsack: 1;
	u16 wscale_ok: 1;
	u16 sack_ok: 3;
	u16 smc_ok: 1;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u8 saw_unknown: 1;
	u8 unused: 7;
	u8 num_sacks;
	u16 user_mss;
	u16 mss_clamp;
};

struct tcp_rack {
	u64 mstamp;
	u32 rtt_us;
	u32 end_seq;
	u32 last_delivered;
	u8 reo_wnd_steps;
	u8 reo_wnd_persist: 5;
	u8 dsack_seen: 1;
	u8 advanced: 1;
};

struct tcp_sack_block {
	u32 start_seq;
	u32 end_seq;
};

struct tcp_sock_af_ops;

struct tcp_md5sig_info;

struct tcp_ao_info;

struct tcp_fastopen_request;

struct tcp_sock {
	struct inet_connection_sock inet_conn;
	__u8 __cacheline_group_begin__tcp_sock_read_tx[0];
	u32 max_window;
	u32 rcv_ssthresh;
	u32 reordering;
	u32 notsent_lowat;
	u16 gso_segs;
	struct sk_buff *lost_skb_hint;
	struct sk_buff *retransmit_skb_hint;
	__u8 __cacheline_group_end__tcp_sock_read_tx[0];
	__u8 __cacheline_group_begin__tcp_sock_read_txrx[0];
	u32 tsoffset;
	u32 snd_wnd;
	u32 mss_cache;
	u32 snd_cwnd;
	u32 prr_out;
	u32 lost_out;
	u32 sacked_out;
	u16 tcp_header_len;
	u8 scaling_ratio;
	u8 chrono_type: 2;
	u8 repair: 1;
	u8 tcp_usec_ts: 1;
	u8 is_sack_reneg: 1;
	u8 is_cwnd_limited: 1;
	__u8 __cacheline_group_end__tcp_sock_read_txrx[0];
	__u8 __cacheline_group_begin__tcp_sock_read_rx[0];
	u32 copied_seq;
	u32 rcv_tstamp;
	u32 snd_wl1;
	u32 tlp_high_seq;
	u32 rttvar_us;
	u32 retrans_out;
	u16 advmss;
	u16 urg_data;
	u32 lost;
	struct minmax rtt_min;
	struct rb_root out_of_order_queue;
	u32 snd_ssthresh;
	u8 recvmsg_inq: 1;
	__u8 __cacheline_group_end__tcp_sock_read_rx[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	__u8 __cacheline_group_begin__tcp_sock_write_tx[0];
	u32 segs_out;
	u32 data_segs_out;
	u64 bytes_sent;
	u32 snd_sml;
	u32 chrono_start;
	u32 chrono_stat[3];
	u32 write_seq;
	u32 pushed_seq;
	u32 lsndtime;
	u32 mdev_us;
	u32 rtt_seq;
	u64 tcp_wstamp_ns;
	struct list_head tsorted_sent_queue;
	struct sk_buff *highest_sack;
	u8 ecn_flags;
	__u8 __cacheline_group_end__tcp_sock_write_tx[0];
	__u8 __cacheline_group_begin__tcp_sock_write_txrx[0];
	__be32 pred_flags;
	u64 tcp_clock_cache;
	u64 tcp_mstamp;
	u32 rcv_nxt;
	u32 snd_nxt;
	u32 snd_una;
	u32 window_clamp;
	u32 srtt_us;
	u32 packets_out;
	u32 snd_up;
	u32 delivered;
	u32 delivered_ce;
	u32 app_limited;
	u32 rcv_wnd;
	struct tcp_options_received rx_opt;
	u8 nonagle: 4;
	u8 rate_app_limited: 1;
	__u8 __cacheline_group_end__tcp_sock_write_txrx[0];
	long: 0;
	__u8 __cacheline_group_begin__tcp_sock_write_rx[0];
	u64 bytes_received;
	u32 segs_in;
	u32 data_segs_in;
	u32 rcv_wup;
	u32 max_packets_out;
	u32 cwnd_usage_seq;
	u32 rate_delivered;
	u32 rate_interval_us;
	u32 rcv_rtt_last_tsecr;
	u64 first_tx_mstamp;
	u64 delivered_mstamp;
	u64 bytes_acked;
	struct {
		u32 rtt_us;
		u32 seq;
		u64 time;
	} rcv_rtt_est;
	struct {
		u32 space;
		u32 seq;
		u64 time;
	} rcvq_space;
	__u8 __cacheline_group_end__tcp_sock_write_rx[0];
	u32 dsack_dups;
	u32 compressed_ack_rcv_nxt;
	struct list_head tsq_node;
	struct tcp_rack rack;
	u8 compressed_ack;
	u8 dup_ack_counter: 2;
	u8 tlp_retrans: 1;
	u8 unused: 5;
	u8 thin_lto: 1;
	u8 fastopen_connect: 1;
	u8 fastopen_no_cookie: 1;
	u8 fastopen_client_fail: 2;
	u8 frto: 1;
	u8 repair_queue;
	u8 save_syn: 2;
	u8 syn_data: 1;
	u8 syn_fastopen: 1;
	u8 syn_fastopen_exp: 1;
	u8 syn_fastopen_ch: 1;
	u8 syn_data_acked: 1;
	u8 keepalive_probes;
	u32 tcp_tx_delay;
	u32 mdev_max_us;
	u32 reord_seen;
	u32 snd_cwnd_cnt;
	u32 snd_cwnd_clamp;
	u32 snd_cwnd_used;
	u32 snd_cwnd_stamp;
	u32 prior_cwnd;
	u32 prr_delivered;
	u32 last_oow_ack_time;
	struct hrtimer pacing_timer;
	struct hrtimer compressed_ack_timer;
	struct sk_buff *ooo_last_skb;
	struct tcp_sack_block duplicate_sack[1];
	struct tcp_sack_block selective_acks[4];
	struct tcp_sack_block recv_sack_cache[4];
	int lost_cnt_hint;
	u32 prior_ssthresh;
	u32 high_seq;
	u32 retrans_stamp;
	u32 undo_marker;
	int undo_retrans;
	u64 bytes_retrans;
	u32 total_retrans;
	u32 rto_stamp;
	u16 total_rto;
	u16 total_rto_recoveries;
	u32 total_rto_time;
	u32 urg_seq;
	unsigned int keepalive_time;
	unsigned int keepalive_intvl;
	int linger2;
	u8 bpf_sock_ops_cb_flags;
	u8 bpf_chg_cc_inprogress: 1;
	u16 timeout_rehash;
	u32 rcv_ooopack;
	struct {
		u32 probe_seq_start;
		u32 probe_seq_end;
	} mtu_probe;
	u32 plb_rehash;
	u32 mtu_info;
	bool is_mptcp;
	const struct tcp_sock_af_ops *af_specific;
	struct tcp_md5sig_info *md5sig_info;
	struct tcp_ao_info *ao_info;
	struct tcp_fastopen_request *fastopen_req;
	struct request_sock *fastopen_rsk;
	struct saved_syn *saved_syn;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcp6_sock {
	struct tcp_sock tcp;
	struct ipv6_pinfo inet6;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcp_ao_add {
	struct __kernel_sockaddr_storage addr;
	char alg_name[64];
	__s32 ifindex;
	__u32 set_current: 1;
	__u32 set_rnext: 1;
	__u32 reserved: 30;
	__u16 reserved2;
	__u8 prefix;
	__u8 sndid;
	__u8 rcvid;
	__u8 maclen;
	__u8 keyflags;
	__u8 keylen;
	__u8 key[80];
};

union tcp_ao_addr {
	struct in_addr a4;
	struct in6_addr a6;
};

struct tcp_ao_counters {
	atomic64_t pkt_good;
	atomic64_t pkt_bad;
	atomic64_t key_not_found;
	atomic64_t ao_required;
	atomic64_t dropped_icmp;
};

struct tcp_ao_del {
	struct __kernel_sockaddr_storage addr;
	__s32 ifindex;
	__u32 set_current: 1;
	__u32 set_rnext: 1;
	__u32 del_async: 1;
	__u32 reserved: 29;
	__u16 reserved2;
	__u8 prefix;
	__u8 sndid;
	__u8 rcvid;
	__u8 current_key;
	__u8 rnext;
	__u8 keyflags;
};

struct tcp_ao_getsockopt {
	struct __kernel_sockaddr_storage addr;
	char alg_name[64];
	__u8 key[80];
	__u32 nkeys;
	__u16 is_current: 1;
	__u16 is_rnext: 1;
	__u16 get_all: 1;
	__u16 reserved: 13;
	__u8 sndid;
	__u8 rcvid;
	__u8 prefix;
	__u8 maclen;
	__u8 keyflags;
	__u8 keylen;
	__s32 ifindex;
	__u64 pkt_good;
	__u64 pkt_bad;
};

struct tcp_ao_hdr {
	u8 kind;
	u8 length;
	u8 keyid;
	u8 rnext_keyid;
};

struct tcp_ao_key;

struct tcp_ao_info {
	struct hlist_head head;
	struct tcp_ao_key *current_key;
	struct tcp_ao_key *rnext_key;
	struct tcp_ao_counters counters;
	u32 ao_required: 1;
	u32 accept_icmps: 1;
	u32 __unused: 30;
	__be32 lisn;
	__be32 risn;
	u32 snd_sne;
	u32 rcv_sne;
	refcount_t refcnt;
	struct callback_head rcu;
};

struct tcp_ao_info_opt {
	__u32 set_current: 1;
	__u32 set_rnext: 1;
	__u32 ao_required: 1;
	__u32 set_counters: 1;
	__u32 accept_icmps: 1;
	__u32 reserved: 27;
	__u16 reserved2;
	__u8 current_key;
	__u8 rnext;
	__u64 pkt_good;
	__u64 pkt_bad;
	__u64 pkt_key_not_found;
	__u64 pkt_ao_required;
	__u64 pkt_dropped_icmp;
};

struct tcp_ao_key {
	struct hlist_node node;
	union tcp_ao_addr addr;
	u8 key[80];
	unsigned int tcp_sigpool_id;
	unsigned int digest_size;
	int l3index;
	u8 prefixlen;
	u8 family;
	u8 keylen;
	u8 keyflags;
	u8 sndid;
	u8 rcvid;
	u8 maclen;
	struct callback_head rcu;
	atomic64_t pkt_good;
	atomic64_t pkt_bad;
	u8 traffic_keys[0];
};

struct tcp_ao_repair {
	__be32 snt_isn;
	__be32 rcv_isn;
	__u32 snd_sne;
	__u32 rcv_sne;
};

struct tcp_bbr_info {
	__u32 bbr_bw_lo;
	__u32 bbr_bw_hi;
	__u32 bbr_min_rtt;
	__u32 bbr_pacing_gain;
	__u32 bbr_cwnd_gain;
};

struct tcpvegas_info {
	__u32 tcpv_enabled;
	__u32 tcpv_rttcnt;
	__u32 tcpv_rtt;
	__u32 tcpv_minrtt;
};

struct tcp_dctcp_info {
	__u16 dctcp_enabled;
	__u16 dctcp_ce_state;
	__u32 dctcp_alpha;
	__u32 dctcp_ab_ecn;
	__u32 dctcp_ab_tot;
};

union tcp_cc_info {
	struct tcpvegas_info vegas;
	struct tcp_dctcp_info dctcp;
	struct tcp_bbr_info bbr;
};

struct tcp_diag_md5sig {
	__u8 tcpm_family;
	__u8 tcpm_prefixlen;
	__u16 tcpm_keylen;
	__be32 tcpm_addr[4];
	__u8 tcpm_key[80];
};

struct tcp_fastopen_context {
	siphash_key_t key[2];
	int num;
	struct callback_head rcu;
};

struct tcp_fastopen_cookie {
	__le64 val[2];
	s8 len;
	bool exp;
};

struct tcp_fastopen_metrics {
	u16 mss;
	u16 syn_loss: 10;
	u16 try_exp: 2;
	long unsigned int last_syn_loss;
	struct tcp_fastopen_cookie cookie;
};

struct tcp_fastopen_request {
	struct tcp_fastopen_cookie cookie;
	struct msghdr *data;
	size_t size;
	int copied;
	struct ubuf_info *uarg;
};

struct tcp_info {
	__u8 tcpi_state;
	__u8 tcpi_ca_state;
	__u8 tcpi_retransmits;
	__u8 tcpi_probes;
	__u8 tcpi_backoff;
	__u8 tcpi_options;
	__u8 tcpi_snd_wscale: 4;
	__u8 tcpi_rcv_wscale: 4;
	__u8 tcpi_delivery_rate_app_limited: 1;
	__u8 tcpi_fastopen_client_fail: 2;
	__u32 tcpi_rto;
	__u32 tcpi_ato;
	__u32 tcpi_snd_mss;
	__u32 tcpi_rcv_mss;
	__u32 tcpi_unacked;
	__u32 tcpi_sacked;
	__u32 tcpi_lost;
	__u32 tcpi_retrans;
	__u32 tcpi_fackets;
	__u32 tcpi_last_data_sent;
	__u32 tcpi_last_ack_sent;
	__u32 tcpi_last_data_recv;
	__u32 tcpi_last_ack_recv;
	__u32 tcpi_pmtu;
	__u32 tcpi_rcv_ssthresh;
	__u32 tcpi_rtt;
	__u32 tcpi_rttvar;
	__u32 tcpi_snd_ssthresh;
	__u32 tcpi_snd_cwnd;
	__u32 tcpi_advmss;
	__u32 tcpi_reordering;
	__u32 tcpi_rcv_rtt;
	__u32 tcpi_rcv_space;
	__u32 tcpi_total_retrans;
	__u64 tcpi_pacing_rate;
	__u64 tcpi_max_pacing_rate;
	__u64 tcpi_bytes_acked;
	__u64 tcpi_bytes_received;
	__u32 tcpi_segs_out;
	__u32 tcpi_segs_in;
	__u32 tcpi_notsent_bytes;
	__u32 tcpi_min_rtt;
	__u32 tcpi_data_segs_in;
	__u32 tcpi_data_segs_out;
	__u64 tcpi_delivery_rate;
	__u64 tcpi_busy_time;
	__u64 tcpi_rwnd_limited;
	__u64 tcpi_sndbuf_limited;
	__u32 tcpi_delivered;
	__u32 tcpi_delivered_ce;
	__u64 tcpi_bytes_sent;
	__u64 tcpi_bytes_retrans;
	__u32 tcpi_dsack_dups;
	__u32 tcpi_reord_seen;
	__u32 tcpi_rcv_ooopack;
	__u32 tcpi_snd_wnd;
	__u32 tcpi_rcv_wnd;
	__u32 tcpi_rehash;
	__u16 tcpi_total_rto;
	__u16 tcpi_total_rto_recoveries;
	__u32 tcpi_total_rto_time;
};

struct tcp_md5sig_key;

struct tcp_key {
	union {
		struct {
			struct tcp_ao_key *ao_key;
			char *traffic_key;
			u32 sne;
			u8 rcv_next;
		};
		struct tcp_md5sig_key *md5_key;
	};
	enum {
		TCP_KEY_NONE = 0,
		TCP_KEY_MD5 = 1,
		TCP_KEY_AO = 2,
	} type;
};

struct tcp_md5sig {
	struct __kernel_sockaddr_storage tcpm_addr;
	__u8 tcpm_flags;
	__u8 tcpm_prefixlen;
	__u16 tcpm_keylen;
	int tcpm_ifindex;
	__u8 tcpm_key[80];
};

struct tcp_md5sig_info {
	struct hlist_head head;
	struct callback_head rcu;
};

struct tcp_md5sig_key {
	struct hlist_node node;
	u8 keylen;
	u8 family;
	u8 prefixlen;
	u8 flags;
	union tcp_ao_addr addr;
	int l3index;
	u8 key[80];
	struct callback_head rcu;
};

struct tcp_metrics_block {
	struct tcp_metrics_block *tcpm_next;
	struct net *tcpm_net;
	struct inetpeer_addr tcpm_saddr;
	struct inetpeer_addr tcpm_daddr;
	long unsigned int tcpm_stamp;
	u32 tcpm_lock;
	u32 tcpm_vals[5];
	struct tcp_fastopen_metrics tcpm_fastopen;
	struct callback_head callback_head;
};

struct tcp_mib {
	long unsigned int mibs[16];
};

struct tcp_out_options {
	u16 options;
	u16 mss;
	u8 ws;
	u8 num_sack_blocks;
	u8 hash_size;
	u8 bpf_opt_len;
	__u8 *hash_location;
	__u32 tsval;
	__u32 tsecr;
	struct tcp_fastopen_cookie *fastopen_cookie;
	struct mptcp_out_options mptcp;
};

struct tcp_repair_opt {
	__u32 opt_code;
	__u32 opt_val;
};

struct tcp_repair_window {
	__u32 snd_wl1;
	__u32 snd_wnd;
	__u32 max_window;
	__u32 rcv_wnd;
	__u32 rcv_wup;
};

struct tcp_request_sock_ops {
	u16 mss_clamp;
	struct tcp_md5sig_key * (*req_md5_lookup)(const struct sock *, const struct sock *);
	int (*calc_md5_hash)(char *, const struct tcp_md5sig_key *, const struct sock *, const struct sk_buff *);
	struct tcp_ao_key * (*ao_lookup)(const struct sock *, struct request_sock *, int, int);
	int (*ao_calc_key)(struct tcp_ao_key *, u8 *, struct request_sock *);
	int (*ao_synack_hash)(char *, struct tcp_ao_key *, struct request_sock *, const struct sk_buff *, int, u32);
	__u32 (*cookie_init_seq)(const struct sk_buff *, __u16 *);
	struct dst_entry * (*route_req)(const struct sock *, struct sk_buff *, struct flowi *, struct request_sock *, u32);
	u32 (*init_seq)(const struct sk_buff *);
	u32 (*init_ts_off)(const struct net *, const struct sk_buff *);
	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type, struct sk_buff *);
};

struct tcp_sack_block_wire {
	__be32 start_seq;
	__be32 end_seq;
};

struct tcp_sacktag_state {
	u64 first_sackt;
	u64 last_sackt;
	u32 reord;
	u32 sack_delivered;
	int flag;
	unsigned int mss_now;
	struct rate_sample *rate;
};

struct tcp_seq_afinfo {
	sa_family_t family;
};

struct tcp_sigpool {
	void *scratch;
	struct ahash_request *req;
};

struct tcp_skb_cb {
	__u32 seq;
	__u32 end_seq;
	union {
		struct {
			u16 tcp_gso_segs;
			u16 tcp_gso_size;
		};
	};
	__u8 tcp_flags;
	__u8 sacked;
	__u8 ip_dsfield;
	__u8 txstamp_ack: 1;
	__u8 eor: 1;
	__u8 has_rxtstamp: 1;
	__u8 unused: 5;
	__u32 ack_seq;
	union {
		struct {
			__u32 is_app_limited: 1;
			__u32 delivered_ce: 20;
			__u32 unused: 11;
			__u32 delivered;
			u64 first_tx_mstamp;
			u64 delivered_mstamp;
		} tx;
		union {
			struct inet_skb_parm h4;
			struct inet6_skb_parm h6;
		} header;
	};
};

struct tcp_sock_af_ops {
	struct tcp_md5sig_key * (*md5_lookup)(const struct sock *, const struct sock *);
	int (*calc_md5_hash)(char *, const struct tcp_md5sig_key *, const struct sock *, const struct sk_buff *);
	int (*md5_parse)(struct sock *, int, sockptr_t, int);
	int (*ao_parse)(struct sock *, int, sockptr_t, int);
	struct tcp_ao_key * (*ao_lookup)(const struct sock *, struct sock *, int, int);
	int (*ao_calc_key_sk)(struct tcp_ao_key *, u8 *, const struct sock *, __be32, __be32, bool);
	int (*calc_ao_hash)(char *, struct tcp_ao_key *, const struct sock *, const struct sk_buff *, const u8 *, int, u32);
};

struct tcp_splice_state {
	struct pipe_inode_info *pipe;
	size_t len;
	unsigned int flags;
};

struct tcp_timewait_sock {
	struct inet_timewait_sock tw_sk;
	u32 tw_rcv_wnd;
	u32 tw_ts_offset;
	u32 tw_ts_recent;
	u32 tw_last_oow_ack_time;
	int tw_ts_recent_stamp;
	u32 tw_tx_delay;
	struct tcp_md5sig_key *tw_md5_key;
	struct tcp_ao_info *ao_info;
};

struct tcp_ulp_ops {
	struct list_head list;
	int (*init)(struct sock *);
	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
	void (*release)(struct sock *);
	int (*get_info)(struct sock *, struct sk_buff *);
	size_t (*get_info_size)(const struct sock *);
	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
	char name[16];
	struct module *owner;
};

struct tcphdr {
	__be16 source;
	__be16 dest;
	__be32 seq;
	__be32 ack_seq;
	__u16 res1: 4;
	__u16 doff: 4;
	__u16 fin: 1;
	__u16 syn: 1;
	__u16 rst: 1;
	__u16 psh: 1;
	__u16 ack: 1;
	__u16 urg: 1;
	__u16 ece: 1;
	__u16 cwr: 1;
	__be16 window;
	__sum16 check;
	__be16 urg_ptr;
};

union tcp_word_hdr {
	struct tcphdr hdr;
	__be32 words[5];
};

struct tcp_xa_pool {
	u8 max;
	u8 idx;
	__u32 tokens[17];
	netmem_ref netmems[17];
};

struct tcp_zerocopy_receive {
	__u64 address;
	__u32 length;
	__u32 recv_skip_hint;
	__u32 inq;
	__s32 err;
	__u64 copybuf_address;
	__s32 copybuf_len;
	__u32 flags;
	__u64 msg_control;
	__u64 msg_controllen;
	__u32 msg_flags;
	__u32 reserved;
};

struct tcpa_event {
	u32 pcr_index;
	u32 event_type;
	u8 pcr_value[20];
	u32 event_size;
	u8 event_data[0];
};

struct tcpa_pc_event {
	u32 event_id;
	u32 event_size;
	u8 event_data[0];
};

struct tcpm_hash_bucket {
	struct tcp_metrics_block *chain;
};

struct tcpnv {
	long unsigned int nv_min_rtt_reset_jiffies;
	s8 cwnd_growth_factor;
	u8 available8;
	u16 available16;
	u8 nv_allow_cwnd_growth: 1;
	u8 nv_reset: 1;
	u8 nv_catchup: 1;
	u8 nv_eval_call_cnt;
	u8 nv_min_cwnd;
	u8 nv_rtt_cnt;
	u32 nv_last_rtt;
	u32 nv_min_rtt;
	u32 nv_min_rtt_new;
	u32 nv_base_rtt;
	u32 nv_lower_bound_rtt;
	u32 nv_rtt_max_rate;
	u32 nv_rtt_start_seq;
	u32 nv_last_snd_una;
	u32 nv_no_cong_cnt;
};

struct tcx_entry {
	struct mini_Qdisc *miniq;
	struct bpf_mprog_bundle bundle;
	u32 miniq_active;
	struct callback_head rcu;
};

struct tcx_link {
	struct bpf_link link;
	struct net_device *dev;
	u32 location;
};

struct tee_net {
	struct list_head priv_list;
	struct mutex lock;
};

struct temp_masks {
	u32 tcc_offset;
	u32 digital_readout;
	u32 pkg_digital_readout;
};

struct temp_regset {
	struct guc_mmio_reg *registers;
	struct guc_mmio_reg *storage;
	u32 storage_used;
	u32 storage_max;
};

struct teql_master {
	struct Qdisc_ops qops;
	struct net_device *dev;
	struct Qdisc *slaves;
	struct list_head master_list;
	long unsigned int tx_bytes;
	long unsigned int tx_packets;
	long unsigned int tx_errors;
	long unsigned int tx_dropped;
};

struct teql_sched_data {
	struct Qdisc *next;
	struct teql_master *m;
	struct sk_buff_head q;
};

struct termio {
	short unsigned int c_iflag;
	short unsigned int c_oflag;
	short unsigned int c_cflag;
	short unsigned int c_lflag;
	unsigned char c_line;
	unsigned char c_cc[8];
};

struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
};

struct termios2 {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct ts_config;

struct text_match {
	u16 from_offset;
	u16 to_offset;
	u8 from_layer;
	u8 to_layer;
	struct ts_config *config;
};

union text_poke_insn {
	u8 text[5];
	struct {
		u8 opcode;
		s32 disp;
	} __attribute__((packed));
};

struct text_poke_loc {
	s32 rel_addr;
	s32 disp;
	u8 len;
	u8 opcode;
	const u8 text[5];
	u8 old;
};

struct tfp410_priv {
	bool quiet;
};

struct tfrc_loss_interval {
	u64 li_seqno: 48;
	u64 li_ccval: 4;
	u64 li_is_closed: 1;
	u32 li_length;
};

struct tfrc_rx_hist_entry {
	u64 tfrchrx_seqno: 48;
	u64 tfrchrx_ccval: 4;
	u64 tfrchrx_type: 4;
	long: 8;
	u64 tfrchrx_ndp: 48;
	ktime_t tfrchrx_tstamp;
};

struct tfrc_rx_info {
	__u32 tfrcrx_x_recv;
	__u32 tfrcrx_rtt;
	__u32 tfrcrx_p;
};

struct tfrc_tx_hist_entry {
	struct tfrc_tx_hist_entry *next;
	u64 seqno;
	ktime_t stamp;
};

struct tfrc_tx_info {
	__u64 tfrctx_x;
	__u64 tfrctx_x_recv;
	__u32 tfrctx_x_calc;
	__u32 tfrctx_rtt;
	__u32 tfrctx_p;
	__u32 tfrctx_rto;
	__u32 tfrctx_ipi;
};

struct tftphdr {
	__be16 opcode;
};

struct tgid_iter {
	unsigned int tgid;
	struct task_struct *task;
};

struct thermal_attr {
	struct device_attribute attr;
	char name[20];
};

typedef struct thermal_cooling_device *class_cooling_dev_t;

struct thermal_cooling_device_ops;

struct thermal_cooling_device {
	int id;
	const char *type;
	long unsigned int max_state;
	struct device device;
	struct device_node *np;
	void *devdata;
	void *stats;
	const struct thermal_cooling_device_ops *ops;
	bool updated;
	struct mutex lock;
	struct list_head thermal_instances;
	struct list_head node;
};

struct thermal_cooling_device_ops {
	int (*get_max_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*get_cur_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*set_cur_state)(struct thermal_cooling_device *, long unsigned int);
	int (*get_requested_power)(struct thermal_cooling_device *, u32 *);
	int (*state2power)(struct thermal_cooling_device *, long unsigned int, u32 *);
	int (*power2state)(struct thermal_cooling_device *, u32, long unsigned int *);
};

struct thermal_genl_cpu_caps {
	int cpu;
	int performance;
	int efficiency;
};

struct thermal_genl_notify {
	int mcgrp;
};

struct thermal_trip;

struct thermal_governor {
	const char *name;
	int (*bind_to_tz)(struct thermal_zone_device *);
	void (*unbind_from_tz)(struct thermal_zone_device *);
	void (*trip_crossed)(struct thermal_zone_device *, const struct thermal_trip *, bool);
	void (*manage)(struct thermal_zone_device *);
	void (*update_tz)(struct thermal_zone_device *, enum thermal_notify_event);
	struct list_head governor_list;
};

struct thermal_hwmon_attr {
	struct device_attribute attr;
	char name[16];
};

struct thermal_hwmon_device {
	char type[20];
	struct device *device;
	int count;
	struct list_head tz_list;
	struct list_head node;
};

struct thermal_hwmon_temp {
	struct list_head hwmon_node;
	struct thermal_zone_device *tz;
	struct thermal_hwmon_attr temp_input;
	struct thermal_hwmon_attr temp_crit;
};

struct thermal_instance {
	int id;
	char name[20];
	struct thermal_cooling_device *cdev;
	const struct thermal_trip *trip;
	bool initialized;
	long unsigned int upper;
	long unsigned int lower;
	long unsigned int target;
	char attr_name[20];
	struct device_attribute attr;
	char weight_attr_name[20];
	struct device_attribute weight_attr;
	struct list_head trip_node;
	struct list_head cdev_node;
	unsigned int weight;
	bool upper_no_limit;
};

struct thermal_state {
	struct _thermal_state core_throttle;
	struct _thermal_state core_power_limit;
	struct _thermal_state package_throttle;
	struct _thermal_state package_power_limit;
	struct _thermal_state core_thresh0;
	struct _thermal_state core_thresh1;
	struct _thermal_state pkg_thresh0;
	struct _thermal_state pkg_thresh1;
};

struct thermal_trip {
	int temperature;
	int hysteresis;
	enum thermal_trip_type type;
	u8 flags;
	void *priv;
};

struct thermal_trip_attrs {
	struct thermal_attr type;
	struct thermal_attr temp;
	struct thermal_attr hyst;
};

struct thermal_trip_desc {
	struct thermal_trip trip;
	struct thermal_trip_attrs trip_attrs;
	struct list_head list_node;
	struct list_head thermal_instances;
	int threshold;
};

typedef struct thermal_zone_device *class_thermal_zone_get_by_id_t;

typedef struct thermal_zone_device *class_thermal_zone_reverse_t;

typedef struct thermal_zone_device *class_thermal_zone_t;

struct thermal_zone_device_ops {
	bool (*should_bind)(struct thermal_zone_device *, const struct thermal_trip *, struct thermal_cooling_device *, struct cooling_spec *);
	int (*get_temp)(struct thermal_zone_device *, int *);
	int (*set_trips)(struct thermal_zone_device *, int, int);
	int (*change_mode)(struct thermal_zone_device *, enum thermal_device_mode);
	int (*set_trip_temp)(struct thermal_zone_device *, const struct thermal_trip *, int);
	int (*get_crit_temp)(struct thermal_zone_device *, int *);
	int (*set_emul_temp)(struct thermal_zone_device *, int);
	int (*get_trend)(struct thermal_zone_device *, const struct thermal_trip *, enum thermal_trend *);
	void (*hot)(struct thermal_zone_device *);
	void (*critical)(struct thermal_zone_device *);
};

struct thermal_zone_params;

struct thermal_zone_device {
	int id;
	char type[20];
	struct device device;
	struct completion removal;
	struct completion resume;
	struct attribute_group trips_attribute_group;
	struct list_head trips_high;
	struct list_head trips_reached;
	struct list_head trips_invalid;
	enum thermal_device_mode mode;
	void *devdata;
	int num_trips;
	long unsigned int passive_delay_jiffies;
	long unsigned int polling_delay_jiffies;
	long unsigned int recheck_delay_jiffies;
	int temperature;
	int last_temperature;
	int emul_temperature;
	int passive;
	int prev_low_trip;
	int prev_high_trip;
	struct thermal_zone_device_ops ops;
	struct thermal_zone_params *tzp;
	struct thermal_governor *governor;
	void *governor_data;
	struct ida ida;
	struct mutex lock;
	struct list_head node;
	struct delayed_work poll_queue;
	enum thermal_notify_event notify_event;
	u8 state;
	struct list_head user_thresholds;
	struct thermal_trip_desc trips[0];
};

struct thermal_zone_params {
	const char *governor_name;
	bool no_hwmon;
	u32 sustainable_power;
	s32 k_po;
	s32 k_pu;
	s32 k_i;
	s32 k_d;
	s32 integral_cutoff;
	int slope;
	int offset;
};

struct thread_deferred_req {
	struct cache_deferred_req handle;
	struct completion completion;
};

struct threshold_block;

struct thresh_restart {
	struct threshold_block *b;
	int reset;
	int set_lvt_off;
	int lvt_off;
	u16 old_limit;
};

struct threshold_attr {
	struct attribute attr;
	ssize_t (*show)(struct threshold_block *, char *);
	ssize_t (*store)(struct threshold_block *, const char *, size_t);
};

struct threshold_bank {
	struct kobject *kobj;
	struct threshold_block *blocks;
};

struct threshold_block {
	unsigned int block;
	unsigned int bank;
	unsigned int cpu;
	u32 address;
	bool interrupt_enable;
	bool interrupt_capable;
	u16 threshold_limit;
	struct kobject kobj;
	struct list_head miscj;
};

struct throtl_service_queue {
	struct throtl_service_queue *parent_sq;
	struct list_head queued[2];
	unsigned int nr_queued[2];
	struct rb_root_cached pending_tree;
	unsigned int nr_pending;
	long unsigned int first_pending_disptime;
	struct timer_list pending_timer;
};

struct throtl_data {
	struct throtl_service_queue service_queue;
	struct request_queue *queue;
	unsigned int nr_queued[2];
	unsigned int throtl_slice;
	struct work_struct dispatch_work;
	bool track_bio_latency;
};

struct throtl_grp;

struct throtl_qnode {
	struct list_head node;
	struct bio_list bios;
	struct throtl_grp *tg;
};

struct throtl_grp {
	struct blkg_policy_data pd;
	struct rb_node rb_node;
	struct throtl_data *td;
	struct throtl_service_queue service_queue;
	struct throtl_qnode qnode_on_self[2];
	struct throtl_qnode qnode_on_parent[2];
	long unsigned int disptime;
	unsigned int flags;
	bool has_rules_bps[2];
	bool has_rules_iops[2];
	uint64_t bps[2];
	unsigned int iops[2];
	uint64_t bytes_disp[2];
	unsigned int io_disp[2];
	uint64_t last_bytes_disp[2];
	unsigned int last_io_disp[2];
	long long int carryover_bytes[2];
	int carryover_ios[2];
	long unsigned int last_check_time;
	long unsigned int slice_start[2];
	long unsigned int slice_end[2];
	struct blkg_rwstat stat_bytes;
	struct blkg_rwstat stat_ios;
};

struct throttling_tstate {
	unsigned int cpu;
	int target_state;
};

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};

struct tick_sched {
	long unsigned int flags;
	unsigned int stalled_jiffies;
	long unsigned int last_tick_jiffies;
	struct hrtimer sched_timer;
	ktime_t last_tick;
	ktime_t next_tick;
	long unsigned int idle_jiffies;
	ktime_t idle_waketime;
	unsigned int got_idle_tick;
	seqcount_t idle_sleeptime_seq;
	ktime_t idle_entrytime;
	long unsigned int last_jiffies;
	u64 timer_expires_base;
	u64 timer_expires;
	u64 next_timer;
	ktime_t idle_expires;
	long unsigned int idle_calls;
	long unsigned int idle_sleeps;
	ktime_t idle_exittime;
	ktime_t idle_sleeptime;
	ktime_t iowait_sleeptime;
	atomic_t tick_dep_mask;
	long unsigned int check_clocks;
};

struct timens_offsets {
	struct timespec64 monotonic;
	struct timespec64 boottime;
};

struct time_namespace {
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
	struct timens_offsets offsets;
	struct page *vvar_page;
	bool frozen_offsets;
};

struct timedia_struct {
	int num;
	const short unsigned int *ids;
};

struct tk_read_base {
	struct clocksource *clock;
	u64 mask;
	u64 cycle_last;
	u32 mult;
	u32 shift;
	u64 xtime_nsec;
	ktime_t base;
	u64 base_real;
};

struct timekeeper {
	struct tk_read_base tkr_mono;
	u64 xtime_sec;
	long unsigned int ktime_sec;
	struct timespec64 wall_to_monotonic;
	ktime_t offs_real;
	ktime_t offs_boot;
	ktime_t offs_tai;
	s32 tai_offset;
	struct tk_read_base tkr_raw;
	u64 raw_sec;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	struct timespec64 monotonic_to_boot;
	u64 cycle_interval;
	u64 xtime_interval;
	s64 xtime_remainder;
	u64 raw_interval;
	ktime_t next_leap_ktime;
	u64 ntp_tick;
	s64 ntp_error;
	u32 ntp_error_shift;
	u32 ntp_err_mult;
	u32 skip_second_overflow;
};

struct timens_offset {
	s64 sec;
	u64 nsec;
};

struct timer_base {
	raw_spinlock_t lock;
	struct timer_list *running_timer;
	long unsigned int clk;
	long unsigned int next_expiry;
	unsigned int cpu;
	bool next_expiry_recalc;
	bool is_idle;
	bool timers_pending;
	long unsigned int pending_map[9];
	struct hlist_head vectors[576];
	long: 64;
	long: 64;
};

struct timer_events {
	u64 local;
	u64 global;
};

struct timer_list_iter {
	int cpu;
	bool second_pass;
	u64 now;
};

struct timer_rand_state {
	long unsigned int last_time;
	long int last_delta;
	long int last_delta2;
};

struct timerfd_ctx {
	union {
		struct hrtimer tmr;
		struct alarm alarm;
	} t;
	ktime_t tintv;
	ktime_t moffs;
	wait_queue_head_t wqh;
	u64 ticks;
	int clockid;
	short unsigned int expired;
	short unsigned int settime_flags;
	struct callback_head rcu;
	struct list_head clist;
	spinlock_t cancel_lock;
	bool might_cancel;
};

struct timerlat_entry {
	struct trace_entry ent;
	unsigned int seqnum;
	int context;
	u64 timer_latency;
};

struct timestamp_event_queue {
	struct ptp_extts_event buf[128];
	int head;
	int tail;
	spinlock_t lock;
	struct list_head qlist;
	long unsigned int *mask;
	struct dentry *debugfs_instance;
	struct debugfs_u32_array dfs_bitmap;
};

struct timewait_sock_ops {
	struct kmem_cache *twsk_slab;
	char *twsk_slab_name;
	unsigned int twsk_obj_size;
	void (*twsk_destructor)(struct sock *);
};

struct timezone {
	int tz_minuteswest;
	int tz_dsttime;
};

struct tiocl_selection {
	short unsigned int xs;
	short unsigned int ys;
	short unsigned int xe;
	short unsigned int ye;
	short unsigned int sel_mode;
};

struct tipc_tfm;

struct tipc_crypto;

struct tipc_aead_key;

struct tipc_aead {
	struct tipc_tfm **tfm_entry;
	struct tipc_crypto *crypto;
	struct tipc_aead *cloned;
	atomic_t users;
	u32 salt;
	u8 authsize;
	u8 mode;
	char hint[11];
	struct callback_head rcu;
	struct tipc_aead_key *key;
	u16 gen;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t seqno;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	refcount_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tipc_aead_key {
	char alg_name[32];
	unsigned int keylen;
	char key[0];
};

struct tipc_basic_hdr {
	__be32 w[4];
};

struct tipc_link;

struct tipc_bc_base {
	struct tipc_link *link;
	struct sk_buff_head inputq;
	int dests[3];
	int primary_bearer;
	bool bcast_support;
	bool force_bcast;
	bool rcast_support;
	bool force_rcast;
	int rc_ratio;
	int bc_threshold;
};

struct tipc_bclink_entry {
	struct tipc_link *link;
	struct sk_buff_head inputq1;
	struct sk_buff_head arrvq;
	struct sk_buff_head inputq2;
	struct sk_buff_head namedq;
	u16 named_rcv_nxt;
	bool named_open;
};

struct tipc_media_addr {
	u8 value[32];
	u8 media_id;
	u8 broadcast;
};

struct tipc_media;

struct tipc_discoverer;

struct tipc_bearer {
	void *media_ptr;
	u32 mtu;
	struct tipc_media_addr addr;
	char name[32];
	struct tipc_media *media;
	struct tipc_media_addr bcast_addr;
	struct packet_type pt;
	struct callback_head rcu;
	u32 priority;
	u32 min_win;
	u32 max_win;
	u32 tolerance;
	u32 domain;
	u32 identity;
	struct tipc_discoverer *disc;
	char net_plane;
	u16 encap_hlen;
	long unsigned int up;
	refcount_t refcnt;
};

struct tipc_bearer_config {
	__be32 priority;
	__be32 disc_domain;
	char name[32];
};

struct tipc_bearer_names {
	char media_name[16];
	char if_name[16];
};

struct tipc_topsrv;

struct tipc_conn {
	struct kref kref;
	int conid;
	struct socket *sock;
	long unsigned int flags;
	struct tipc_topsrv *server;
	struct list_head sub_list;
	spinlock_t sub_lock;
	struct work_struct rwork;
	struct list_head outqueue;
	spinlock_t outqueue_lock;
	struct work_struct swork;
};

struct tipc_key {
	union {
		struct {
			u8 pending: 2;
			u8 active: 2;
			u8 passive: 2;
			u8 reserved: 2;
		};
		u8 keys;
	};
};

struct tipc_node;

struct tipc_crypto_stats;

struct tipc_crypto {
	struct net *net;
	struct tipc_node *node;
	struct tipc_aead *aead[4];
	atomic_t peer_rx_active;
	u16 key_gen;
	struct tipc_key key;
	u8 skey_mode;
	struct tipc_aead_key *skey;
	struct workqueue_struct *wq;
	struct delayed_work work;
	atomic_t key_distr;
	u32 rekeying_intv;
	struct tipc_crypto_stats *stats;
	char name[48];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t sndnxt;
	long unsigned int timer1;
	long unsigned int timer2;
	union {
		struct {
			u8 working: 1;
			u8 key_master: 1;
			u8 legacy_user: 1;
			u8 nokey: 1;
		};
		u8 flags;
	};
	spinlock_t lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tipc_crypto_rx_ctx {
	struct tipc_aead *aead;
	struct tipc_bearer *bearer;
};

struct tipc_crypto_stats {
	unsigned int stat[8];
};

struct tipc_crypto_tx_ctx {
	struct tipc_aead *aead;
	struct tipc_bearer *bearer;
	struct tipc_media_addr dst;
};

struct tipc_dest {
	struct list_head list;
	u32 port;
	u32 node;
};

struct tipc_discoverer {
	u32 bearer_id;
	struct tipc_media_addr dest;
	struct net *net;
	u32 domain;
	int num_nodes;
	spinlock_t lock;
	struct sk_buff *skb;
	struct timer_list timer;
	long unsigned int timer_intv;
};

struct tipc_ehdr {
	union {
		struct {
			__u8 destined: 1;
			__u8 user: 4;
			__u8 version: 3;
			__u8 reserved_1: 1;
			__u8 rx_nokey: 1;
			__u8 master_key: 1;
			__u8 keepalive: 1;
			__u8 rx_key_active: 2;
			__u8 tx_key: 2;
			__be16 reserved_2;
		};
		__be32 w0;
	};
	__be64 seqno;
	union {
		__be32 addr;
		__u8 id[16];
	};
} __attribute__((packed));

struct tipc_gap_ack {
	__be16 ack;
	__be16 gap;
};

struct tipc_gap_ack_blks {
	__be16 len;
	union {
		u8 ugack_cnt;
		u8 start_index;
	};
	u8 bgack_cnt;
	struct tipc_gap_ack gacks[0];
};

struct tipc_genlmsghdr {
	__u32 dest;
	__u16 cmd;
	__u16 reserved;
};

struct tipc_nlist {
	struct list_head list;
	u32 self;
	u16 remote;
	bool local;
};

struct tipc_group {
	struct rb_root members;
	struct list_head small_win;
	struct list_head pending;
	struct list_head active;
	struct tipc_nlist dests;
	struct net *net;
	int subid;
	u32 type;
	u32 instance;
	u32 scope;
	u32 portid;
	u16 member_cnt;
	u16 active_cnt;
	u16 max_active;
	u16 bc_snd_nxt;
	u16 bc_ackers;
	bool *open;
	bool loopback;
	bool events;
};

struct tipc_group_req {
	__u32 type;
	__u32 instance;
	__u32 scope;
	__u32 flags;
};

struct tipc_mon_state {
	u16 list_gen;
	u16 peer_gen;
	u16 acked_gen;
	bool monitoring: 1;
	bool probing: 1;
	bool reset: 1;
	bool synched: 1;
};

struct tipc_stats {
	u32 sent_pkts;
	u32 recv_pkts;
	u32 sent_states;
	u32 recv_states;
	u32 sent_probes;
	u32 recv_probes;
	u32 sent_nacks;
	u32 recv_nacks;
	u32 sent_acks;
	u32 sent_bundled;
	u32 sent_bundles;
	u32 recv_bundled;
	u32 recv_bundles;
	u32 retransmitted;
	u32 sent_fragmented;
	u32 sent_fragments;
	u32 recv_fragmented;
	u32 recv_fragments;
	u32 link_congs;
	u32 deferred_recv;
	u32 duplicates;
	u32 max_queue_sz;
	u32 accu_queue_sz;
	u32 queue_sz_counts;
	u32 msg_length_counts;
	u32 msg_lengths_total;
	u32 msg_length_profile[7];
};

struct tipc_link {
	u32 addr;
	char name[68];
	struct net *net;
	u16 peer_session;
	u16 session;
	u16 snd_nxt_state;
	u16 rcv_nxt_state;
	u32 peer_bearer_id;
	u32 bearer_id;
	u32 tolerance;
	u32 abort_limit;
	u32 state;
	u16 peer_caps;
	bool in_session;
	bool active;
	u32 silent_intv_cnt;
	char if_name[16];
	u32 priority;
	char net_plane;
	struct tipc_mon_state mon_state;
	u16 rst_cnt;
	u16 drop_point;
	struct sk_buff *failover_reasm_skb;
	struct sk_buff_head failover_deferdq;
	u16 mtu;
	u16 advertised_mtu;
	struct sk_buff_head transmq;
	struct sk_buff_head backlogq;
	struct {
		u16 len;
		u16 limit;
		struct sk_buff *target_bskb;
	} backlog[5];
	u16 snd_nxt;
	u16 rcv_nxt;
	u32 rcv_unacked;
	struct sk_buff_head deferdq;
	struct sk_buff_head *inputq;
	struct sk_buff_head *namedq;
	struct sk_buff_head wakeupq;
	u16 window;
	u16 min_win;
	u16 ssthresh;
	u16 max_win;
	u16 cong_acks;
	u16 checkpoint;
	struct sk_buff *reasm_buf;
	struct sk_buff *reasm_tnlmsg;
	u16 ackers;
	u16 acked;
	u16 last_gap;
	struct tipc_gap_ack_blks *last_ga;
	struct tipc_link *bc_rcvlink;
	struct tipc_link *bc_sndlink;
	u8 nack_state;
	bool bc_peer_is_up;
	struct tipc_stats stats;
};

struct tipc_link_config {
	__be32 value;
	char name[68];
};

struct tipc_link_entry {
	struct tipc_link *link;
	spinlock_t lock;
	u32 mtu;
	struct sk_buff_head inputq;
	struct tipc_media_addr maddr;
};

struct tipc_link_info {
	__be32 dest;
	__be32 up;
	char str[68];
};

struct tipc_mc_method {
	bool rcast;
	bool mandatory;
	struct sk_buff_head deferredq;
	long unsigned int expires;
};

struct tipc_media {
	int (*send_msg)(struct net *, struct sk_buff *, struct tipc_bearer *, struct tipc_media_addr *);
	int (*enable_media)(struct net *, struct tipc_bearer *, struct nlattr **);
	void (*disable_media)(struct tipc_bearer *);
	int (*addr2str)(struct tipc_media_addr *, char *, int);
	int (*addr2msg)(char *, struct tipc_media_addr *);
	int (*msg2addr)(struct tipc_bearer *, struct tipc_media_addr *, char *);
	int (*raw2addr)(struct tipc_bearer *, struct tipc_media_addr *, const char *);
	u32 priority;
	u32 tolerance;
	u32 min_win;
	u32 max_win;
	u32 mtu;
	u32 type_id;
	u32 hwaddr_len;
	char name[16];
};

struct tipc_member {
	struct rb_node tree_node;
	struct list_head list;
	struct list_head small_win;
	struct sk_buff_head deferredq;
	struct tipc_group *group;
	u32 node;
	u32 port;
	u32 instance;
	enum mbr_state state;
	u16 advertised;
	u16 window;
	u16 bc_rcv_nxt;
	u16 bc_syncpt;
	u16 bc_acked;
};

struct tipc_mon_domain {
	u16 len;
	u16 gen;
	u16 ack_gen;
	u16 member_cnt;
	u64 up_map;
	u32 members[64];
};

struct tipc_peer;

struct tipc_monitor {
	struct hlist_head peers[512];
	int peer_cnt;
	struct tipc_peer *self;
	rwlock_t lock;
	struct tipc_mon_domain cache;
	u16 list_gen;
	u16 dom_gen;
	struct net *net;
	struct timer_list timer;
	long unsigned int timer_intv;
};

struct tipc_msg {
	__be32 hdr[15];
};

struct tipc_name_table_query {
	__be32 depth;
	__be32 type;
	__be32 lowbound;
	__be32 upbound;
};

struct tipc_net {
	u8 node_id[16];
	u32 node_addr;
	u32 trial_addr;
	long unsigned int addr_trial_end;
	char node_id_string[33];
	int net_id;
	int random;
	bool legacy_addr_format;
	spinlock_t node_list_lock;
	struct hlist_head node_htable[512];
	struct list_head node_list;
	u32 num_nodes;
	u32 num_links;
	struct tipc_monitor *monitors[3];
	int mon_threshold;
	struct tipc_bearer *bearer_list[4];
	spinlock_t bclock;
	struct tipc_bc_base *bcbase;
	struct tipc_link *bcl;
	struct rhashtable sk_rht;
	spinlock_t nametbl_lock;
	struct name_table *nametbl;
	struct tipc_topsrv *topsrv;
	atomic_t subscription_count;
	u16 capabilities;
	struct packet_type loopback_pt;
	struct tipc_crypto *crypto_tx;
	struct work_struct work;
	atomic_t wq_count;
};

struct tipc_nl_compat_msg;

struct tipc_nl_compat_cmd_doit {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*transcode)(struct tipc_nl_compat_cmd_doit *, struct sk_buff *, struct tipc_nl_compat_msg *);
};

struct tipc_nl_compat_cmd_dump {
	int (*header)(struct tipc_nl_compat_msg *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*format)(struct tipc_nl_compat_msg *, struct nlattr **);
};

struct tlv_desc;

struct tipc_nl_compat_msg {
	u16 cmd;
	int rep_type;
	int rep_size;
	int req_type;
	int req_size;
	struct net *net;
	struct sk_buff *rep;
	struct tlv_desc *req;
	struct sock *dst_sk;
};

struct tipc_nl_msg {
	struct sk_buff *skb;
	u32 portid;
	u32 seq;
};

struct tipc_node {
	u32 addr;
	struct kref kref;
	rwlock_t lock;
	struct net *net;
	struct hlist_node hash;
	int active_links[2];
	struct tipc_link_entry links[3];
	struct tipc_bclink_entry bc_entry;
	int action_flags;
	struct list_head list;
	int state;
	bool preliminary;
	bool failover_sent;
	u16 sync_point;
	int link_cnt;
	u16 working_links;
	u16 capabilities;
	u32 signature;
	u32 link_id;
	u8 peer_id[16];
	char peer_id_string[33];
	struct list_head publ_list;
	struct list_head conn_sks;
	long unsigned int keepalive_intv;
	struct timer_list timer;
	struct callback_head rcu;
	long unsigned int delete_at;
	struct net *peer_net;
	u32 peer_hash_mix;
	struct tipc_crypto *crypto_rx;
};

struct tipc_node_info {
	__be32 addr;
	__be32 up;
};

struct tipc_peer {
	u32 addr;
	struct tipc_mon_domain *domain;
	struct hlist_node hash;
	struct list_head list;
	u8 applied;
	u8 down_cnt;
	bool is_up;
	bool is_head;
	bool is_local;
};

struct tipc_service {
	u32 type;
	u32 publ_cnt;
	struct rb_root ranges;
	struct hlist_node service_list;
	struct list_head subscriptions;
	spinlock_t lock;
	struct callback_head rcu;
};

struct tipc_sioc_ln_req {
	__u32 peer;
	__u32 bearer_id;
	char linkname[68];
};

struct tipc_sioc_nodeid_req {
	__u32 peer;
	char node_id[16];
};

struct tipc_skb_cb {
	union {
		struct {
			struct sk_buff *tail;
			long unsigned int nxt_retr;
			long unsigned int retr_stamp;
			u32 bytes_read;
			u32 orig_member;
			u16 chain_imp;
			u16 ackers;
			u16 retr_cnt;
		} __attribute__((packed));
		struct {
			struct tipc_crypto *rx;
			struct tipc_aead *last;
			u8 recurs;
		} tx_clone_ctx;
	};
	union {
		struct {
			u8 validated: 1;
			u8 encrypted: 1;
			u8 decrypted: 1;
			u8 xmit_type: 2;
			u8 tx_clone_deferred: 1;
		};
		u8 flags;
	};
	u8 reserved;
	void *crypto_ctx;
};

struct tipc_sock {
	struct sock sk;
	u32 max_pkt;
	u32 maxnagle;
	u32 portid;
	struct tipc_msg phdr;
	struct list_head cong_links;
	struct list_head publications;
	u32 pub_count;
	atomic_t dupl_rcvcnt;
	u16 conn_timeout;
	bool probe_unacked;
	u16 cong_link_cnt;
	u16 snt_unacked;
	u16 snd_win;
	u16 peer_caps;
	u16 rcv_unacked;
	u16 rcv_win;
	struct sockaddr_tipc peer;
	struct rhash_head node;
	struct tipc_mc_method mc_method;
	struct callback_head rcu;
	struct tipc_group *group;
	u32 oneway;
	u32 nagle_start;
	u16 snd_backlog;
	u16 msg_acc;
	u16 pkt_cnt;
	bool expect_ack;
	bool nodelay;
	bool group_is_open;
	bool published;
	u8 conn_addrtype;
};

struct tipc_sock_conn {
	u32 port;
	u32 peer_port;
	u32 peer_node;
	struct list_head list;
};

struct tipc_sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 tidiag_states;
};

struct tipc_subscription {
	struct tipc_subscr s;
	struct tipc_event evt;
	struct kref kref;
	struct net *net;
	struct timer_list timer;
	struct list_head service_list;
	struct list_head sub_list;
	int conid;
	bool inactive;
	spinlock_t lock;
};

struct tipc_tfm {
	struct crypto_aead *tfm;
	struct list_head list;
};

struct tipc_topsrv {
	struct idr conn_idr;
	spinlock_t idr_lock;
	int idr_in_use;
	struct net *net;
	struct work_struct awork;
	struct workqueue_struct *rcv_wq;
	struct workqueue_struct *send_wq;
	struct socket *listener;
	char name[32];
};

struct tipc_uaddr {
	short unsigned int family;
	unsigned char addrtype;
	signed char scope;
	union {
		struct {
			struct tipc_service_addr sa;
			u32 lookup_node;
		};
		struct tipc_service_range sr;
		struct tipc_socket_addr sk;
	};
};

struct tis_vendor_durations_override {
	u32 did_vid;
	struct tpm1_version version;
	long unsigned int durations[3];
};

struct tis_vendor_timeout_override {
	u32 did_vid;
	long unsigned int timeout_us[4];
};

struct tk_data {
	seqcount_raw_spinlock_t seq;
	struct timekeeper timekeeper;
	struct timekeeper shadow_timekeeper;
	raw_spinlock_t lock;
};

struct tk_fast {
	seqcount_latch_t seq;
	struct tk_read_base base[2];
};

struct tlb_context {
	u64 ctx_id;
	u64 tlb_gen;
};

struct tlb_state {
	struct mm_struct *loaded_mm;
	union {
		struct mm_struct *last_user_mm;
		long unsigned int last_user_mm_spec;
	};
	u16 loaded_mm_asid;
	u16 next_asid;
	bool invalidate_other;
	short unsigned int user_pcid_flush_mask;
	long unsigned int cr4;
	struct tlb_context ctxs[6];
};

struct tlb_state_shared {
	bool is_lazy;
};

struct tls_crypto_info {
	__u16 version;
	__u16 cipher_type;
};

struct tls12_crypto_info_aes_ccm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aria_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aria_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_chacha20_poly1305 {
	struct tls_crypto_info info;
	unsigned char iv[12];
	unsigned char key[32];
	unsigned char salt[0];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_sm4_ccm {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_sm4_gcm {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls_cipher_desc {
	unsigned int nonce;
	unsigned int iv;
	unsigned int key;
	unsigned int salt;
	unsigned int tag;
	unsigned int rec_seq;
	unsigned int iv_offset;
	unsigned int key_offset;
	unsigned int salt_offset;
	unsigned int rec_seq_offset;
	char *cipher_name;
	bool offloadable;
	size_t crypto_info;
};

struct tls_prot_info {
	u16 version;
	u16 cipher_type;
	u16 prepend_size;
	u16 tag_size;
	u16 overhead_size;
	u16 iv_size;
	u16 salt_size;
	u16 rec_seq_size;
	u16 aad_size;
	u16 tail_size;
};

union tls_crypto_context {
	struct tls_crypto_info info;
	union {
		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
		struct tls12_crypto_info_chacha20_poly1305 chacha20_poly1305;
		struct tls12_crypto_info_sm4_gcm sm4_gcm;
		struct tls12_crypto_info_sm4_ccm sm4_ccm;
	};
};

struct tls_context {
	struct tls_prot_info prot_info;
	u8 tx_conf: 3;
	u8 rx_conf: 3;
	u8 zerocopy_sendfile: 1;
	u8 rx_no_pad: 1;
	int (*push_pending_record)(struct sock *, int);
	void (*sk_write_space)(struct sock *);
	void *priv_ctx_tx;
	void *priv_ctx_rx;
	struct net_device *netdev;
	struct cipher_context tx;
	struct cipher_context rx;
	struct scatterlist *partially_sent_record;
	u16 partially_sent_offset;
	bool splicing_pages;
	bool pending_open_record_frags;
	struct mutex tx_lock;
	long unsigned int flags;
	struct proto *sk_proto;
	struct sock *sk;
	void (*sk_destruct)(struct sock *);
	union tls_crypto_context crypto_send;
	union tls_crypto_context crypto_recv;
	struct list_head list;
	refcount_t refcount;
	struct callback_head rcu;
};

struct tls_decrypt_arg {
	union {
		struct {
			bool zc;
			bool async;
			bool async_done;
			u8 tail;
		};
		struct {
			bool zc;
			bool async;
			bool async_done;
			u8 tail;
		} inargs;
	};
	struct sk_buff *skb;
};

struct tls_decrypt_ctx {
	struct sock *sk;
	u8 iv[16];
	u8 aad[13];
	u8 tail;
	bool free_sgout;
	struct scatterlist sg[0];
};

typedef void (*tls_done_func_t)(void *, int, key_serial_t);

struct tls_handshake_args {
	struct socket *ta_sock;
	tls_done_func_t ta_done;
	void *ta_data;
	const char *ta_peername;
	unsigned int ta_timeout_ms;
	key_serial_t ta_keyring;
	key_serial_t ta_my_cert;
	key_serial_t ta_my_privkey;
	unsigned int ta_num_peerids;
	key_serial_t ta_my_peerids[5];
};

struct tls_handshake_req {
	void (*th_consumer_done)(void *, int, key_serial_t);
	void *th_consumer_data;
	int th_type;
	unsigned int th_timeout_ms;
	int th_auth_mode;
	const char *th_peername;
	key_serial_t th_keyring;
	key_serial_t th_certificate;
	key_serial_t th_privkey;
	unsigned int th_num_peerids;
	key_serial_t th_peerid[5];
};

struct tls_rec {
	struct list_head list;
	int tx_ready;
	int tx_flags;
	struct sk_msg msg_plaintext;
	struct sk_msg msg_encrypted;
	struct scatterlist sg_aead_in[2];
	struct scatterlist sg_aead_out[2];
	char content_type;
	struct scatterlist sg_content_type;
	struct sock *sk;
	char aad_space[13];
	u8 iv_data[16];
	struct aead_request aead_req;
	u8 aead_req_ctx[0];
};

struct tls_strparser {
	struct sock *sk;
	u32 mark: 8;
	u32 stopped: 1;
	u32 copy_mode: 1;
	u32 mixed_decrypted: 1;
	bool msg_ready;
	struct strp_msg stm;
	struct sk_buff *anchor;
	struct work_struct work;
};

struct tls_sw_context_rx {
	struct crypto_aead *aead_recv;
	struct crypto_wait async_wait;
	struct sk_buff_head rx_list;
	void (*saved_data_ready)(struct sock *);
	u8 reader_present;
	u8 async_capable: 1;
	u8 zc_capable: 1;
	u8 reader_contended: 1;
	bool key_update_pending;
	struct tls_strparser strp;
	atomic_t decrypt_pending;
	struct sk_buff_head async_hold;
	struct wait_queue_head wq;
};

struct tx_work {
	struct delayed_work work;
	struct sock *sk;
};

struct tls_sw_context_tx {
	struct crypto_aead *aead_send;
	struct crypto_wait async_wait;
	struct tx_work tx_work;
	struct tls_rec *open_rec;
	struct list_head tx_list;
	atomic_t encrypt_pending;
	u8 async_capable: 1;
	long unsigned int tx_bitmask;
};

struct tlv_desc {
	__be16 tlv_len;
	__be16 tlv_type;
};

struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	long int tm_year;
	int tm_wday;
	int tm_yday;
};

struct tmigr_event {
	struct timerqueue_node nextevt;
	unsigned int cpu;
	bool ignore;
};

struct tmigr_group;

struct tmigr_cpu {
	raw_spinlock_t lock;
	bool online;
	bool idle;
	bool remote;
	struct tmigr_group *tmgroup;
	u8 groupmask;
	u64 wakeup;
	struct tmigr_event cpuevt;
};

struct tmigr_group {
	raw_spinlock_t lock;
	struct tmigr_group *parent;
	struct tmigr_event groupevt;
	u64 next_expiry;
	struct timerqueue_head events;
	atomic_t migr_state;
	unsigned int level;
	int numa_node;
	unsigned int num_children;
	u8 groupmask;
	struct list_head list;
};

union tmigr_state {
	u32 state;
	struct {
		u8 active;
		u8 migrator;
		u16 seq;
	};
};

struct tmigr_walk {
	u64 nextexp;
	u64 firstexp;
	struct tmigr_event *evt;
	u8 childmask;
	bool remote;
	long unsigned int basej;
	u64 now;
	bool check;
	bool tmc_active;
};

struct tmp_ext {
	struct in6_addr saddr;
	struct in6_addr daddr;
	char hdrs[0];
};

struct tmpmasks {
	cpumask_var_t addmask;
	cpumask_var_t delmask;
	cpumask_var_t new_cpus;
};

struct tms {
	__kernel_clock_t tms_utime;
	__kernel_clock_t tms_stime;
	__kernel_clock_t tms_cutime;
	__kernel_clock_t tms_cstime;
};

struct tnl_ptk_info {
	long unsigned int flags[1];
	__be16 proto;
	__be32 key;
	__be32 seq;
	int hdr_len;
};

struct tnode {
	struct callback_head rcu;
	t_key empty_children;
	t_key full_children;
	struct key_vector *parent;
	struct key_vector kv[1];
};

struct token_bucket {
	spinlock_t lock;
	int chain_len;
	struct hlist_nulls_head req_chain;
	struct hlist_nulls_head msk_chain;
};

struct topa {
	struct list_head list;
	u64 offset;
	size_t size;
	int last;
	unsigned int z_count;
};

struct topa_entry {
	u64 end: 1;
	u64 rsvd0: 1;
	u64 intr: 1;
	u64 rsvd1: 1;
	u64 stop: 1;
	u64 rsvd2: 1;
	u64 size: 4;
	u64 rsvd3: 2;
	u64 base: 40;
	u64 rsvd4: 12;
};

struct topa_page {
	struct topa_entry table[507];
	struct topa topa;
};

struct topo_scan {
	struct cpuinfo_x86 *c;
	unsigned int dom_shifts[7];
	unsigned int dom_ncpus[7];
	unsigned int ebx1_nproc_shift;
	u16 amd_nodes_per_pkg;
	u16 amd_node_id;
};

struct touchscreen_properties {
	unsigned int max_x;
	unsigned int max_y;
	bool invert_x;
	bool invert_y;
	bool swap_x_y;
};

struct tp_module {
	struct list_head list;
	struct module *mod;
};

struct tracepoint_func {
	void *func;
	void *data;
	int prio;
};

struct tp_probes {
	struct callback_head rcu;
	struct tracepoint_func probes[0];
};

struct tp_transition_snapshot {
	long unsigned int rcu;
	bool ongoing;
};

struct tpacket2_hdr {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u8 tp_padding[4];
};

struct tpacket_hdr_variant1 {
	__u32 tp_rxhash;
	__u32 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u16 tp_padding;
};

struct tpacket3_hdr {
	__u32 tp_next_offset;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u32 tp_snaplen;
	__u32 tp_len;
	__u32 tp_status;
	__u16 tp_mac;
	__u16 tp_net;
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8 tp_padding[8];
};

struct tpacket_auxdata {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
};

struct tpacket_bd_ts {
	unsigned int ts_sec;
	union {
		unsigned int ts_usec;
		unsigned int ts_nsec;
	};
};

struct tpacket_hdr_v1 {
	__u32 block_status;
	__u32 num_pkts;
	__u32 offset_to_first_pkt;
	__u32 blk_len;
	__u64 seq_num;
	struct tpacket_bd_ts ts_first_pkt;
	struct tpacket_bd_ts ts_last_pkt;
};

union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};

struct tpacket_hdr {
	long unsigned int tp_status;
	unsigned int tp_len;
	unsigned int tp_snaplen;
	short unsigned int tp_mac;
	short unsigned int tp_net;
	unsigned int tp_sec;
	unsigned int tp_usec;
};

struct tpacket_req {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
};

struct tpacket_req3 {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
	unsigned int tp_retire_blk_tov;
	unsigned int tp_sizeof_priv;
	unsigned int tp_feature_req_word;
};

union tpacket_req_u {
	struct tpacket_req req;
	struct tpacket_req3 req3;
};

struct tpacket_rollover_stats {
	__u64 tp_all;
	__u64 tp_huge;
	__u64 tp_failed;
};

union tpacket_uhdr {
	struct tpacket_hdr *h1;
	struct tpacket2_hdr *h2;
	struct tpacket3_hdr *h3;
	void *raw;
};

struct tpm1_get_random_out {
	__be32 rng_data_len;
	u8 rng_data[128];
};

struct tpm2_auth {
	u32 handle;
	u32 session;
	u8 our_nonce[32];
	u8 tpm_nonce[32];
	union {
		u8 salt[32];
		u8 scratch[32];
	};
	u8 session_key[32];
	u8 passphrase[32];
	int passphrase_len;
	struct crypto_aes_ctx aes_ctx;
	u8 attrs;
	__be32 ordinal;
	u32 name_h[3];
	u8 name[198];
};

struct tpm2_cap_handles {
	u8 more_data;
	__be32 capability;
	__be32 count;
	__be32 handles[0];
} __attribute__((packed));

struct tpm2_context {
	__be64 sequence;
	__be32 saved_handle;
	__be32 hierarchy;
	__be16 blob_size;
} __attribute__((packed));

struct tpm2_crb_pluton {
	u64 start_addr;
	u64 reply_addr;
};

struct tpm2_crb_smc {
	u32 interrupt;
	u8 interrupt_flags;
	u8 op_flags;
	u16 reserved2;
	u32 smc_func_id;
};

struct tpm2_get_cap_out {
	u8 more_data;
	__be32 subcap_id;
	__be32 property_cnt;
	__be32 property_id;
	__be32 value;
} __attribute__((packed));

struct tpm2_get_random_out {
	__be16 size;
	u8 buffer[128];
};

struct tpm2_hash {
	unsigned int crypto_id;
	unsigned int tpm_id;
};

struct tpm2_pcr_read_out {
	__be32 update_cnt;
	__be32 pcr_selects_cnt;
	__be16 hash_alg;
	u8 pcr_select_size;
	u8 pcr_select[3];
	__be32 digests_cnt;
	__be16 digest_size;
	u8 digest[0];
} __attribute__((packed));

struct tpm2_pcr_selection {
	__be16 hash_alg;
	u8 size_of_select;
	u8 pcr_select[3];
};

struct tpm_bank_info {
	u16 alg_id;
	u16 digest_size;
	u16 crypto_id;
};

struct tpm_bios_log {
	void *bios_event_log;
	void *bios_event_log_end;
};

struct tpm_buf {
	u32 flags;
	u32 length;
	u8 *data;
	u8 handles;
};

struct tpm_chip_seqops {
	struct tpm_chip *chip;
	const struct seq_operations *seqops;
};

struct tpm_space {
	u32 context_tbl[3];
	u8 *context_buf;
	u32 session_tbl[3];
	u8 *session_buf;
	u32 buf_size;
};

struct tpm_class_ops;

struct tpm_chip {
	struct device dev;
	struct device devs;
	struct cdev cdev;
	struct cdev cdevs;
	struct rw_semaphore ops_sem;
	const struct tpm_class_ops *ops;
	struct tpm_bios_log log;
	struct tpm_chip_seqops bin_log_seqops;
	struct tpm_chip_seqops ascii_log_seqops;
	unsigned int flags;
	int dev_num;
	long unsigned int is_open;
	char hwrng_name[64];
	struct hwrng hwrng;
	struct mutex tpm_mutex;
	long unsigned int timeout_a;
	long unsigned int timeout_b;
	long unsigned int timeout_c;
	long unsigned int timeout_d;
	bool timeout_adjusted;
	long unsigned int duration[4];
	bool duration_adjusted;
	struct dentry *bios_dir[3];
	const struct attribute_group *groups[8];
	unsigned int groups_cnt;
	u32 nr_allocated_banks;
	struct tpm_bank_info *allocated_banks;
	acpi_handle acpi_dev_handle;
	char ppi_version[4];
	struct tpm_space work_space;
	u32 last_cc;
	u32 nr_commands;
	u32 *cc_attrs_tbl;
	int locality;
	u8 null_key_context[4096];
	u8 null_key_name[34];
	u8 null_ec_key_x[32];
	u8 null_ec_key_y[32];
	struct tpm2_auth *auth;
};

struct tpm_class_ops {
	unsigned int flags;
	const u8 req_complete_mask;
	const u8 req_complete_val;
	bool (*req_canceled)(struct tpm_chip *, u8);
	int (*recv)(struct tpm_chip *, u8 *, size_t);
	int (*send)(struct tpm_chip *, u8 *, size_t);
	void (*cancel)(struct tpm_chip *);
	u8 (*status)(struct tpm_chip *);
	void (*update_timeouts)(struct tpm_chip *, long unsigned int *);
	void (*update_durations)(struct tpm_chip *, long unsigned int *);
	int (*go_idle)(struct tpm_chip *);
	int (*cmd_ready)(struct tpm_chip *);
	int (*request_locality)(struct tpm_chip *, int);
	int (*relinquish_locality)(struct tpm_chip *, int);
	void (*clk_enable)(struct tpm_chip *, bool);
};

struct tpm_header {
	__be16 tag;
	__be32 length;
	union {
		__be32 ordinal;
		__be32 return_code;
	};
} __attribute__((packed));

struct tpm_info {
	struct resource res;
	int irq;
};

struct tpm_pcr_attr {
	int alg_id;
	int pcr;
	struct device_attribute attr;
};

struct tpm_readpubek_out {
	u8 algorithm[4];
	u8 encscheme[2];
	u8 sigscheme[2];
	__be32 paramsize;
	u8 parameters[12];
	__be32 keysize;
	u8 modulus[256];
	u8 checksum[20];
};

struct tpm_tis_phy_ops;

struct tpm_tis_data {
	struct tpm_chip *chip;
	u16 manufacturer_id;
	struct mutex locality_count_mutex;
	unsigned int locality_count;
	int locality;
	int irq;
	struct work_struct free_irq_work;
	long unsigned int last_unhandled_irq;
	unsigned int unhandled_irqs;
	unsigned int int_mask;
	long unsigned int flags;
	void *ilb_base_addr;
	u16 clkrun_enabled;
	wait_queue_head_t int_queue;
	wait_queue_head_t read_queue;
	const struct tpm_tis_phy_ops *phy_ops;
	short unsigned int rng_quality;
	unsigned int timeout_min;
	unsigned int timeout_max;
};

struct tpm_tis_phy_ops {
	int (*read_bytes)(struct tpm_tis_data *, u32, u16, u8 *, enum tpm_tis_io_mode);
	int (*write_bytes)(struct tpm_tis_data *, u32, u16, const u8 *, enum tpm_tis_io_mode);
	int (*verify_crc)(struct tpm_tis_data *, size_t, const u8 *);
};

struct tpm_tis_tcg_phy {
	struct tpm_tis_data priv;
	void *iobase;
};

struct tpmrm_priv {
	struct file_priv priv;
	struct tpm_space space;
};

struct trace_pid_list;

struct trace_options;

struct trace_func_repeats;

struct trace_array {
	struct list_head list;
	char *name;
	struct array_buffer array_buffer;
	unsigned int mapped;
	long unsigned int range_addr_start;
	long unsigned int range_addr_size;
	long int text_delta;
	long int data_delta;
	struct trace_pid_list *filtered_pids;
	struct trace_pid_list *filtered_no_pids;
	arch_spinlock_t max_lock;
	int buffer_disabled;
	int stop_count;
	int clock_id;
	int nr_topts;
	bool clear_trace;
	int buffer_percent;
	unsigned int n_err_log_entries;
	struct tracer *current_trace;
	unsigned int trace_flags;
	unsigned char trace_flags_index[32];
	unsigned int flags;
	raw_spinlock_t start_lock;
	const char *system_names;
	struct list_head err_log;
	struct dentry *dir;
	struct dentry *options;
	struct dentry *percpu_dir;
	struct eventfs_inode *event_dir;
	struct trace_options *topts;
	struct list_head systems;
	struct list_head events;
	struct trace_event_file *trace_marker_file;
	cpumask_var_t tracing_cpumask;
	cpumask_var_t pipe_cpumask;
	int ref;
	int trace_ref;
	struct list_head mod_events;
	int no_filter_buffering_ref;
	struct list_head hist_vars;
	struct trace_func_repeats *last_func_repeats;
	bool ring_buffer_expanded;
};

struct trace_array_cpu {
	atomic_t disabled;
	void *buffer_page;
	long unsigned int entries;
	long unsigned int saved_latency;
	long unsigned int critical_start;
	long unsigned int critical_end;
	long unsigned int critical_sequence;
	long unsigned int nice;
	long unsigned int policy;
	long unsigned int rt_priority;
	long unsigned int skipped_entries;
	u64 preempt_timestamp;
	pid_t pid;
	kuid_t uid;
	char comm[16];
	bool ignore_pid;
};

struct trace_bprintk_fmt {
	struct list_head list;
	const char *fmt;
};

struct trace_buffer {
	unsigned int flags;
	int cpus;
	atomic_t record_disabled;
	atomic_t resizing;
	cpumask_var_t cpumask;
	struct lock_class_key *reader_lock_key;
	struct mutex mutex;
	struct ring_buffer_per_cpu **buffers;
	struct hlist_node node;
	u64 (*clock)(void);
	struct rb_irq_work irq_work;
	bool time_stamp_abs;
	long unsigned int range_addr_start;
	long unsigned int range_addr_end;
	long int last_text_delta;
	long int last_data_delta;
	unsigned int subbuf_size;
	unsigned int subbuf_order;
	unsigned int max_data_size;
};

struct trace_buffer_meta {
	__u32 meta_page_size;
	__u32 meta_struct_len;
	__u32 subbuf_size;
	__u32 nr_subbufs;
	struct {
		__u64 lost_events;
		__u32 id;
		__u32 read;
	} reader;
	__u64 flags;
	__u64 entries;
	__u64 overrun;
	__u64 read;
	__u64 Reserved1;
	__u64 Reserved2;
};

struct trace_buffer_struct {
	int nesting;
	char buffer[4096];
};

struct trace_probe_event;

struct trace_probe {
	struct list_head list;
	struct trace_probe_event *event;
	ssize_t size;
	unsigned int nr_args;
	struct probe_entry_arg *entry_arg;
	struct probe_arg args[0];
};

struct trace_eprobe {
	const char *event_system;
	const char *event_name;
	char *filter_str;
	struct trace_event_call *event;
	struct dyn_event devent;
	struct trace_probe tp;
};

struct trace_eval_map {
	const char *system;
	const char *eval_string;
	long unsigned int eval_value;
};

struct trace_event_functions;

struct trace_event {
	struct hlist_node node;
	int type;
	struct trace_event_functions *funcs;
};

struct trace_event_buffer {
	struct trace_buffer *buffer;
	struct ring_buffer_event *event;
	struct trace_event_file *trace_file;
	void *entry;
	unsigned int trace_ctx;
	struct pt_regs *regs;
};

struct trace_event_class;

struct trace_event_call {
	struct list_head list;
	struct trace_event_class *class;
	union {
		const char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	union {
		void *module;
		atomic_t refcnt;
	};
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head *perf_events;
	struct bpf_prog_array *prog_array;
	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
};

struct trace_event_fields;

struct trace_event_class {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
	struct trace_event_fields *fields_array;
	struct list_head * (*get_fields)(struct trace_event_call *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call *);
};

struct trace_event_data_offsets_9p_client_req {};

struct trace_event_data_offsets_9p_client_res {};

struct trace_event_data_offsets_9p_fid_ref {};

struct trace_event_data_offsets_9p_protocol_dump {
	u32 line;
	const void *line_ptr_;
};

struct trace_event_data_offsets_ack_update_msk {};

struct trace_event_data_offsets_alarm_class {};

struct trace_event_data_offsets_alarmtimer_suspend {};

struct trace_event_data_offsets_alloc_extent_state {};

struct trace_event_data_offsets_alloc_vmap_area {};

struct trace_event_data_offsets_amd_pstate_epp_perf {};

struct trace_event_data_offsets_amd_pstate_perf {};

struct trace_event_data_offsets_balance_dirty_pages {};

struct trace_event_data_offsets_batadv_dbg {
	u32 device;
	const void *device_ptr_;
	u32 driver;
	const void *driver_ptr_;
	u32 msg;
	const void *msg_ptr_;
};

struct trace_event_data_offsets_bdi_dirty_ratelimit {};

struct trace_event_data_offsets_block_bio {};

struct trace_event_data_offsets_block_bio_complete {};

struct trace_event_data_offsets_block_bio_remap {};

struct trace_event_data_offsets_block_buffer {};

struct trace_event_data_offsets_block_plug {};

struct trace_event_data_offsets_block_rq {
	u32 cmd;
	const void *cmd_ptr_;
};

struct trace_event_data_offsets_block_rq_completion {
	u32 cmd;
	const void *cmd_ptr_;
};

struct trace_event_data_offsets_block_rq_remap {};

struct trace_event_data_offsets_block_rq_requeue {
	u32 cmd;
	const void *cmd_ptr_;
};

struct trace_event_data_offsets_block_split {};

struct trace_event_data_offsets_block_unplug {};

struct trace_event_data_offsets_bpf_test_finish {};

struct trace_event_data_offsets_bpf_trace_printk {
	u32 bpf_string;
	const void *bpf_string_ptr_;
};

struct trace_event_data_offsets_bpf_trigger_tp {};

struct trace_event_data_offsets_bpf_xdp_link_attach_failed {
	u32 msg;
	const void *msg_ptr_;
};

struct trace_event_data_offsets_br_fdb_add {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_br_fdb_external_learn_add {
	u32 br_dev;
	const void *br_dev_ptr_;
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_br_fdb_update {
	u32 br_dev;
	const void *br_dev_ptr_;
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_br_mdb_full {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_btrfs__block_group {};

struct trace_event_data_offsets_btrfs__chunk {};

struct trace_event_data_offsets_btrfs__file_extent_item_inline {};

struct trace_event_data_offsets_btrfs__file_extent_item_regular {};

struct trace_event_data_offsets_btrfs__inode {};

struct trace_event_data_offsets_btrfs__ordered_extent {};

struct trace_event_data_offsets_btrfs__prelim_ref {};

struct trace_event_data_offsets_btrfs__qgroup_rsv_data {};

struct trace_event_data_offsets_btrfs__reserve_extent {};

struct trace_event_data_offsets_btrfs__reserved_extent {};

struct trace_event_data_offsets_btrfs__space_info_update {};

struct trace_event_data_offsets_btrfs__work {};

struct trace_event_data_offsets_btrfs__work__done {};

struct trace_event_data_offsets_btrfs__writepage {};

struct trace_event_data_offsets_btrfs_add_block_group {};

struct trace_event_data_offsets_btrfs_clear_extent_bit {};

struct trace_event_data_offsets_btrfs_convert_extent_bit {};

struct trace_event_data_offsets_btrfs_cow_block {};

struct trace_event_data_offsets_btrfs_delayed_data_ref {};

struct trace_event_data_offsets_btrfs_delayed_ref_head {};

struct trace_event_data_offsets_btrfs_delayed_tree_ref {};

struct trace_event_data_offsets_btrfs_dump_space_info {};

struct trace_event_data_offsets_btrfs_extent_map_shrinker_count {};

struct trace_event_data_offsets_btrfs_extent_map_shrinker_remove_em {};

struct trace_event_data_offsets_btrfs_extent_map_shrinker_scan_enter {};

struct trace_event_data_offsets_btrfs_extent_map_shrinker_scan_exit {};

struct trace_event_data_offsets_btrfs_failed_cluster_setup {};

struct trace_event_data_offsets_btrfs_find_cluster {};

struct trace_event_data_offsets_btrfs_finish_ordered_extent {};

struct trace_event_data_offsets_btrfs_flush_space {};

struct trace_event_data_offsets_btrfs_get_extent {};

struct trace_event_data_offsets_btrfs_get_raid_extent_offset {};

struct trace_event_data_offsets_btrfs_handle_em_exist {};

struct trace_event_data_offsets_btrfs_inode_mod_outstanding_extents {};

struct trace_event_data_offsets_btrfs_insert_one_raid_extent {};

struct trace_event_data_offsets_btrfs_locking_events {};

struct trace_event_data_offsets_btrfs_qgroup_account_extent {};

struct trace_event_data_offsets_btrfs_qgroup_extent {};

struct trace_event_data_offsets_btrfs_raid56_bio {};

struct trace_event_data_offsets_btrfs_raid_extent_delete {};

struct trace_event_data_offsets_btrfs_reserve_ticket {};

struct trace_event_data_offsets_btrfs_set_extent_bit {};

struct trace_event_data_offsets_btrfs_setup_cluster {};

struct trace_event_data_offsets_btrfs_sleep_tree_lock {};

struct trace_event_data_offsets_btrfs_space_reservation {
	u32 type;
	const void *type_ptr_;
};

struct trace_event_data_offsets_btrfs_sync_file {};

struct trace_event_data_offsets_btrfs_sync_fs {};

struct trace_event_data_offsets_btrfs_transaction_commit {};

struct trace_event_data_offsets_btrfs_trigger_flush {
	u32 reason;
	const void *reason_ptr_;
};

struct trace_event_data_offsets_btrfs_workqueue {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_btrfs_workqueue_done {};

struct trace_event_data_offsets_btrfs_writepage_end_io_hook {};

struct trace_event_data_offsets_cache_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_cache_tag_flush {
	u32 iommu;
	const void *iommu_ptr_;
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_cache_tag_log {
	u32 iommu;
	const void *iommu_ptr_;
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_cap_capable {};

struct trace_event_data_offsets_cdev_update {
	u32 type;
	const void *type_ptr_;
};

struct trace_event_data_offsets_cgroup {
	u32 path;
	const void *path_ptr_;
};

struct trace_event_data_offsets_cgroup_event {
	u32 path;
	const void *path_ptr_;
};

struct trace_event_data_offsets_cgroup_migrate {
	u32 dst_path;
	const void *dst_path_ptr_;
	u32 comm;
	const void *comm_ptr_;
};

struct trace_event_data_offsets_cgroup_root {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_cgroup_rstat {};

struct trace_event_data_offsets_clock {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_compact_retry {};

struct trace_event_data_offsets_console {
	u32 msg;
	const void *msg_ptr_;
};

struct trace_event_data_offsets_consume_skb {};

struct trace_event_data_offsets_contention_begin {};

struct trace_event_data_offsets_contention_end {};

struct trace_event_data_offsets_cpu {};

struct trace_event_data_offsets_cpu_frequency_limits {};

struct trace_event_data_offsets_cpu_idle_miss {};

struct trace_event_data_offsets_cpu_latency_qos_request {};

struct trace_event_data_offsets_cpuhp_enter {};

struct trace_event_data_offsets_cpuhp_exit {};

struct trace_event_data_offsets_cpuhp_multi_enter {};

struct trace_event_data_offsets_csd_function {};

struct trace_event_data_offsets_csd_queue_cpu {};

struct trace_event_data_offsets_ctime {};

struct trace_event_data_offsets_ctime_ns_xchg {};

struct trace_event_data_offsets_dccp_probe {};

struct trace_event_data_offsets_dev_pm_qos_request {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_device_pm_callback_end {
	u32 device;
	const void *device_ptr_;
	u32 driver;
	const void *driver_ptr_;
};

struct trace_event_data_offsets_device_pm_callback_start {
	u32 device;
	const void *device_ptr_;
	u32 driver;
	const void *driver_ptr_;
	u32 parent;
	const void *parent_ptr_;
	u32 pm_ops;
	const void *pm_ops_ptr_;
};

struct trace_event_data_offsets_devres {
	u32 devname;
	const void *devname_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_dma_alloc_class {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_dma_alloc_sgt {
	u32 device;
	const void *device_ptr_;
	u32 phys_addrs;
	const void *phys_addrs_ptr_;
};

struct trace_event_data_offsets_dma_fence {
	u32 driver;
	const void *driver_ptr_;
	u32 timeline;
	const void *timeline_ptr_;
};

struct trace_event_data_offsets_dma_free_class {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_dma_free_sgt {
	u32 device;
	const void *device_ptr_;
	u32 phys_addrs;
	const void *phys_addrs_ptr_;
};

struct trace_event_data_offsets_dma_map {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_dma_map_sg {
	u32 device;
	const void *device_ptr_;
	u32 phys_addrs;
	const void *phys_addrs_ptr_;
	u32 dma_addrs;
	const void *dma_addrs_ptr_;
	u32 lengths;
	const void *lengths_ptr_;
};

struct trace_event_data_offsets_dma_map_sg_err {
	u32 device;
	const void *device_ptr_;
	u32 phys_addrs;
	const void *phys_addrs_ptr_;
};

struct trace_event_data_offsets_dma_sync_sg {
	u32 device;
	const void *device_ptr_;
	u32 dma_addrs;
	const void *dma_addrs_ptr_;
	u32 lengths;
	const void *lengths_ptr_;
};

struct trace_event_data_offsets_dma_sync_single {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_dma_unmap {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_dma_unmap_sg {
	u32 device;
	const void *device_ptr_;
	u32 addrs;
	const void *addrs_ptr_;
};

struct trace_event_data_offsets_dql_stall_detected {};

struct trace_event_data_offsets_drm_vblank_event {};

struct trace_event_data_offsets_drm_vblank_event_delivered {};

struct trace_event_data_offsets_drm_vblank_event_queued {};

struct trace_event_data_offsets_emulate_vsyscall {};

struct trace_event_data_offsets_error_report_template {};

struct trace_event_data_offsets_exit_mmap {};

struct trace_event_data_offsets_ext4__bitmap_load {};

struct trace_event_data_offsets_ext4__es_extent {};

struct trace_event_data_offsets_ext4__es_shrink_enter {};

struct trace_event_data_offsets_ext4__fallocate_mode {};

struct trace_event_data_offsets_ext4__folio_op {};

struct trace_event_data_offsets_ext4__map_blocks_enter {};

struct trace_event_data_offsets_ext4__map_blocks_exit {};

struct trace_event_data_offsets_ext4__mb_new_pa {};

struct trace_event_data_offsets_ext4__mballoc {};

struct trace_event_data_offsets_ext4__trim {};

struct trace_event_data_offsets_ext4__truncate {};

struct trace_event_data_offsets_ext4__write_begin {};

struct trace_event_data_offsets_ext4__write_end {};

struct trace_event_data_offsets_ext4_alloc_da_blocks {};

struct trace_event_data_offsets_ext4_allocate_blocks {};

struct trace_event_data_offsets_ext4_allocate_inode {};

struct trace_event_data_offsets_ext4_begin_ordered_truncate {};

struct trace_event_data_offsets_ext4_collapse_range {};

struct trace_event_data_offsets_ext4_da_release_space {};

struct trace_event_data_offsets_ext4_da_reserve_space {};

struct trace_event_data_offsets_ext4_da_update_reserve_space {};

struct trace_event_data_offsets_ext4_da_write_pages {};

struct trace_event_data_offsets_ext4_da_write_pages_extent {};

struct trace_event_data_offsets_ext4_discard_blocks {};

struct trace_event_data_offsets_ext4_discard_preallocations {};

struct trace_event_data_offsets_ext4_drop_inode {};

struct trace_event_data_offsets_ext4_error {};

struct trace_event_data_offsets_ext4_es_find_extent_range_enter {};

struct trace_event_data_offsets_ext4_es_find_extent_range_exit {};

struct trace_event_data_offsets_ext4_es_insert_delayed_extent {};

struct trace_event_data_offsets_ext4_es_lookup_extent_enter {};

struct trace_event_data_offsets_ext4_es_lookup_extent_exit {};

struct trace_event_data_offsets_ext4_es_remove_extent {};

struct trace_event_data_offsets_ext4_es_shrink {};

struct trace_event_data_offsets_ext4_es_shrink_scan_exit {};

struct trace_event_data_offsets_ext4_evict_inode {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_enter {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_fastpath {};

struct trace_event_data_offsets_ext4_ext_handle_unwritten_extents {};

struct trace_event_data_offsets_ext4_ext_load_extent {};

struct trace_event_data_offsets_ext4_ext_remove_space {};

struct trace_event_data_offsets_ext4_ext_remove_space_done {};

struct trace_event_data_offsets_ext4_ext_rm_idx {};

struct trace_event_data_offsets_ext4_ext_rm_leaf {};

struct trace_event_data_offsets_ext4_ext_show_extent {};

struct trace_event_data_offsets_ext4_fallocate_exit {};

struct trace_event_data_offsets_ext4_fc_cleanup {};

struct trace_event_data_offsets_ext4_fc_commit_start {};

struct trace_event_data_offsets_ext4_fc_commit_stop {};

struct trace_event_data_offsets_ext4_fc_replay {};

struct trace_event_data_offsets_ext4_fc_replay_scan {};

struct trace_event_data_offsets_ext4_fc_stats {};

struct trace_event_data_offsets_ext4_fc_track_dentry {};

struct trace_event_data_offsets_ext4_fc_track_inode {};

struct trace_event_data_offsets_ext4_fc_track_range {};

struct trace_event_data_offsets_ext4_forget {};

struct trace_event_data_offsets_ext4_free_blocks {};

struct trace_event_data_offsets_ext4_free_inode {};

struct trace_event_data_offsets_ext4_fsmap_class {};

struct trace_event_data_offsets_ext4_get_implied_cluster_alloc_exit {};

struct trace_event_data_offsets_ext4_getfsmap_class {};

struct trace_event_data_offsets_ext4_insert_range {};

struct trace_event_data_offsets_ext4_invalidate_folio_op {};

struct trace_event_data_offsets_ext4_journal_start_inode {};

struct trace_event_data_offsets_ext4_journal_start_reserved {};

struct trace_event_data_offsets_ext4_journal_start_sb {};

struct trace_event_data_offsets_ext4_lazy_itable_init {};

struct trace_event_data_offsets_ext4_load_inode {};

struct trace_event_data_offsets_ext4_mark_inode_dirty {};

struct trace_event_data_offsets_ext4_mb_discard_preallocations {};

struct trace_event_data_offsets_ext4_mb_release_group_pa {};

struct trace_event_data_offsets_ext4_mb_release_inode_pa {};

struct trace_event_data_offsets_ext4_mballoc_alloc {};

struct trace_event_data_offsets_ext4_mballoc_prealloc {};

struct trace_event_data_offsets_ext4_nfs_commit_metadata {};

struct trace_event_data_offsets_ext4_other_inode_update_time {};

struct trace_event_data_offsets_ext4_prefetch_bitmaps {};

struct trace_event_data_offsets_ext4_read_block_bitmap_load {};

struct trace_event_data_offsets_ext4_remove_blocks {};

struct trace_event_data_offsets_ext4_request_blocks {};

struct trace_event_data_offsets_ext4_request_inode {};

struct trace_event_data_offsets_ext4_shutdown {};

struct trace_event_data_offsets_ext4_sync_file_enter {};

struct trace_event_data_offsets_ext4_sync_file_exit {};

struct trace_event_data_offsets_ext4_sync_fs {};

struct trace_event_data_offsets_ext4_unlink_enter {};

struct trace_event_data_offsets_ext4_unlink_exit {};

struct trace_event_data_offsets_ext4_update_sb {};

struct trace_event_data_offsets_ext4_writepages {};

struct trace_event_data_offsets_ext4_writepages_result {};

struct trace_event_data_offsets_fdb_delete {
	u32 br_dev;
	const void *br_dev_ptr_;
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_fib6_table_lookup {};

struct trace_event_data_offsets_fib_table_lookup {};

struct trace_event_data_offsets_file_check_and_advance_wb_err {};

struct trace_event_data_offsets_filelock_lease {};

struct trace_event_data_offsets_filelock_lock {};

struct trace_event_data_offsets_filemap_set_wb_err {};

struct trace_event_data_offsets_fill_mg_cmtime {};

struct trace_event_data_offsets_find_free_extent {};

struct trace_event_data_offsets_find_free_extent_have_block_group {};

struct trace_event_data_offsets_find_free_extent_search_loop {};

struct trace_event_data_offsets_finish_task_reaping {};

struct trace_event_data_offsets_flush_foreign {};

struct trace_event_data_offsets_free_extent_state {};

struct trace_event_data_offsets_free_vmap_area_noflush {};

struct trace_event_data_offsets_fuse_request_end {};

struct trace_event_data_offsets_fuse_request_send {};

struct trace_event_data_offsets_g4x_wm {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_generic_add_lease {};

struct trace_event_data_offsets_global_dirty_state {};

struct trace_event_data_offsets_guest_halt_poll_ns {};

struct trace_event_data_offsets_handshake_alert_class {};

struct trace_event_data_offsets_handshake_complete {};

struct trace_event_data_offsets_handshake_error_class {};

struct trace_event_data_offsets_handshake_event_class {};

struct trace_event_data_offsets_handshake_fd_class {};

struct trace_event_data_offsets_hrtimer_class {};

struct trace_event_data_offsets_hrtimer_expire_entry {};

struct trace_event_data_offsets_hrtimer_init {};

struct trace_event_data_offsets_hrtimer_start {};

struct trace_event_data_offsets_hugetlbfs__inode {};

struct trace_event_data_offsets_hugetlbfs_alloc_inode {};

struct trace_event_data_offsets_hugetlbfs_fallocate {};

struct trace_event_data_offsets_hugetlbfs_setattr {
	u32 d_name;
	const void *d_name_ptr_;
};

struct trace_event_data_offsets_hwmon_attr_class {
	u32 attr_name;
	const void *attr_name_ptr_;
};

struct trace_event_data_offsets_hwmon_attr_show_string {
	u32 attr_name;
	const void *attr_name_ptr_;
	u32 label;
	const void *label_ptr_;
};

struct trace_event_data_offsets_i2c_read {};

struct trace_event_data_offsets_i2c_reply {
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_i2c_result {};

struct trace_event_data_offsets_i2c_write {
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_i915_context {};

struct trace_event_data_offsets_i915_gem_evict {};

struct trace_event_data_offsets_i915_gem_evict_node {};

struct trace_event_data_offsets_i915_gem_evict_vm {};

struct trace_event_data_offsets_i915_gem_object {};

struct trace_event_data_offsets_i915_gem_object_create {};

struct trace_event_data_offsets_i915_gem_object_fault {};

struct trace_event_data_offsets_i915_gem_object_pread {};

struct trace_event_data_offsets_i915_gem_object_pwrite {};

struct trace_event_data_offsets_i915_gem_shrink {};

struct trace_event_data_offsets_i915_ppgtt {};

struct trace_event_data_offsets_i915_reg_rw {};

struct trace_event_data_offsets_i915_request {};

struct trace_event_data_offsets_i915_request_queue {};

struct trace_event_data_offsets_i915_request_wait_begin {};

struct trace_event_data_offsets_i915_vma_bind {};

struct trace_event_data_offsets_i915_vma_unbind {};

struct trace_event_data_offsets_icmp_send {};

struct trace_event_data_offsets_inet_sk_error_report {};

struct trace_event_data_offsets_inet_sock_set_state {};

struct trace_event_data_offsets_initcall_finish {};

struct trace_event_data_offsets_initcall_level {
	u32 level;
	const void *level_ptr_;
};

struct trace_event_data_offsets_initcall_start {};

struct trace_event_data_offsets_inode_foreign_history {};

struct trace_event_data_offsets_inode_switch_wbs {};

struct trace_event_data_offsets_intel_cpu_fifo_underrun {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_crtc_flip_done {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_crtc_vblank_work_end {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_crtc_vblank_work_start {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_fbc_activate {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_fbc_deactivate {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_fbc_nuke {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_frontbuffer_flush {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_frontbuffer_invalidate {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_memory_cxsr {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pch_fifo_underrun {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_crc {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_disable {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_enable {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_update_end {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_update_start {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_pipe_update_vblank_evaded {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_intel_plane_async_flip {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_plane_disable_arm {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_plane_update_arm {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_intel_plane_update_noarm {
	u32 dev;
	const void *dev_ptr_;
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_io_uring_complete {};

struct trace_event_data_offsets_io_uring_cqe_overflow {};

struct trace_event_data_offsets_io_uring_cqring_wait {};

struct trace_event_data_offsets_io_uring_create {};

struct trace_event_data_offsets_io_uring_defer {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_fail_link {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_file_get {};

struct trace_event_data_offsets_io_uring_link {};

struct trace_event_data_offsets_io_uring_local_work_run {};

struct trace_event_data_offsets_io_uring_poll_arm {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_queue_async_work {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_register {};

struct trace_event_data_offsets_io_uring_req_failed {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_short_write {};

struct trace_event_data_offsets_io_uring_submit_req {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_task_add {
	u32 op_str;
	const void *op_str_ptr_;
};

struct trace_event_data_offsets_io_uring_task_work_run {};

struct trace_event_data_offsets_iocg_inuse_update {
	u32 devname;
	const void *devname_ptr_;
	u32 cgroup;
	const void *cgroup_ptr_;
};

struct trace_event_data_offsets_iocost_ioc_vrate_adj {
	u32 devname;
	const void *devname_ptr_;
};

struct trace_event_data_offsets_iocost_iocg_forgive_debt {
	u32 devname;
	const void *devname_ptr_;
	u32 cgroup;
	const void *cgroup_ptr_;
};

struct trace_event_data_offsets_iocost_iocg_state {
	u32 devname;
	const void *devname_ptr_;
	u32 cgroup;
	const void *cgroup_ptr_;
};

struct trace_event_data_offsets_iomap_class {};

struct trace_event_data_offsets_iomap_dio_complete {};

struct trace_event_data_offsets_iomap_dio_rw_begin {};

struct trace_event_data_offsets_iomap_iter {};

struct trace_event_data_offsets_iomap_range_class {};

struct trace_event_data_offsets_iomap_readpage_class {};

struct trace_event_data_offsets_iomap_writepage_map {};

struct trace_event_data_offsets_iommu_device_event {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_iommu_error {
	u32 device;
	const void *device_ptr_;
	u32 driver;
	const void *driver_ptr_;
};

struct trace_event_data_offsets_iommu_group_event {
	u32 device;
	const void *device_ptr_;
};

struct trace_event_data_offsets_ipi_handler {};

struct trace_event_data_offsets_ipi_raise {
	u32 target_cpus;
	const void *target_cpus_ptr_;
};

struct trace_event_data_offsets_ipi_send_cpu {};

struct trace_event_data_offsets_ipi_send_cpumask {
	u32 cpumask;
	const void *cpumask_ptr_;
};

struct trace_event_data_offsets_irq_handler_entry {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_irq_handler_exit {};

struct trace_event_data_offsets_irq_matrix_cpu {};

struct trace_event_data_offsets_irq_matrix_global {};

struct trace_event_data_offsets_irq_matrix_global_update {};

struct trace_event_data_offsets_itimer_expire {};

struct trace_event_data_offsets_itimer_state {};

struct trace_event_data_offsets_jbd2_checkpoint {};

struct trace_event_data_offsets_jbd2_checkpoint_stats {};

struct trace_event_data_offsets_jbd2_commit {};

struct trace_event_data_offsets_jbd2_end_commit {};

struct trace_event_data_offsets_jbd2_handle_extend {};

struct trace_event_data_offsets_jbd2_handle_start_class {};

struct trace_event_data_offsets_jbd2_handle_stats {};

struct trace_event_data_offsets_jbd2_journal_shrink {};

struct trace_event_data_offsets_jbd2_lock_buffer_stall {};

struct trace_event_data_offsets_jbd2_run_stats {};

struct trace_event_data_offsets_jbd2_shrink_checkpoint_list {};

struct trace_event_data_offsets_jbd2_shrink_scan_exit {};

struct trace_event_data_offsets_jbd2_submit_inode_data {};

struct trace_event_data_offsets_jbd2_update_log_tail {};

struct trace_event_data_offsets_jbd2_write_superblock {};

struct trace_event_data_offsets_kcompactd_wake_template {};

struct trace_event_data_offsets_kfree {};

struct trace_event_data_offsets_kfree_skb {};

struct trace_event_data_offsets_kmalloc {};

struct trace_event_data_offsets_kmem_cache_alloc {};

struct trace_event_data_offsets_kmem_cache_free {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_kyber_adjust {};

struct trace_event_data_offsets_kyber_latency {};

struct trace_event_data_offsets_kyber_throttled {};

struct trace_event_data_offsets_leases_conflict {};

struct trace_event_data_offsets_locks_get_lock_context {};

struct trace_event_data_offsets_ma_op {};

struct trace_event_data_offsets_ma_read {};

struct trace_event_data_offsets_ma_write {};

struct trace_event_data_offsets_map {};

struct trace_event_data_offsets_mark_victim {
	u32 comm;
	const void *comm_ptr_;
};

struct trace_event_data_offsets_mce_record {
	u32 v_data;
	const void *v_data_ptr_;
};

struct trace_event_data_offsets_mdio_access {};

struct trace_event_data_offsets_mei_pci_cfg_read {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_mei_reg_read {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_mei_reg_write {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_mem_connect {};

struct trace_event_data_offsets_mem_disconnect {};

struct trace_event_data_offsets_mem_return_failed {};

struct trace_event_data_offsets_memcg_flush_stats {};

struct trace_event_data_offsets_memcg_rstat_events {};

struct trace_event_data_offsets_memcg_rstat_stats {};

struct trace_event_data_offsets_migration_pte {};

struct trace_event_data_offsets_mm_alloc_contig_migrate_range_info {};

struct trace_event_data_offsets_mm_compaction_begin {};

struct trace_event_data_offsets_mm_compaction_defer_template {};

struct trace_event_data_offsets_mm_compaction_end {};

struct trace_event_data_offsets_mm_compaction_isolate_template {};

struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};

struct trace_event_data_offsets_mm_compaction_migratepages {};

struct trace_event_data_offsets_mm_compaction_suitable_template {};

struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};

struct trace_event_data_offsets_mm_filemap_fault {};

struct trace_event_data_offsets_mm_filemap_op_page_cache {};

struct trace_event_data_offsets_mm_filemap_op_page_cache_range {};

struct trace_event_data_offsets_mm_lru_activate {};

struct trace_event_data_offsets_mm_lru_insertion {};

struct trace_event_data_offsets_mm_migrate_pages {};

struct trace_event_data_offsets_mm_migrate_pages_start {};

struct trace_event_data_offsets_mm_page {};

struct trace_event_data_offsets_mm_page_alloc {};

struct trace_event_data_offsets_mm_page_alloc_extfrag {};

struct trace_event_data_offsets_mm_page_free {};

struct trace_event_data_offsets_mm_page_free_batched {};

struct trace_event_data_offsets_mm_page_pcpu_drain {};

struct trace_event_data_offsets_mm_shrink_slab_end {};

struct trace_event_data_offsets_mm_shrink_slab_start {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};

struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};

struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};

struct trace_event_data_offsets_mm_vmscan_lru_isolate {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};

struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};

struct trace_event_data_offsets_mm_vmscan_reclaim_pages {};

struct trace_event_data_offsets_mm_vmscan_throttled {};

struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};

struct trace_event_data_offsets_mm_vmscan_write_folio {};

struct trace_event_data_offsets_mmap_lock {};

struct trace_event_data_offsets_mmap_lock_acquire_returned {};

struct trace_event_data_offsets_module_free {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_module_load {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_module_refcnt {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_module_request {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_mptcp_dump_mpext {};

struct trace_event_data_offsets_mptcp_subflow_get_send {};

struct trace_event_data_offsets_msr_trace_class {};

struct trace_event_data_offsets_napi_poll {
	u32 dev_name;
	const void *dev_name_ptr_;
};

struct trace_event_data_offsets_neigh__update {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_neigh_create {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_neigh_update {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_net_dev_rx_exit_template {};

struct trace_event_data_offsets_net_dev_rx_verbose_template {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_net_dev_start_xmit {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_net_dev_template {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_net_dev_xmit {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_net_dev_xmit_timeout {
	u32 name;
	const void *name_ptr_;
	u32 driver;
	const void *driver_ptr_;
};

struct trace_event_data_offsets_netfs_collect {};

struct trace_event_data_offsets_netfs_collect_folio {};

struct trace_event_data_offsets_netfs_collect_gap {};

struct trace_event_data_offsets_netfs_collect_sreq {};

struct trace_event_data_offsets_netfs_collect_state {};

struct trace_event_data_offsets_netfs_collect_stream {};

struct trace_event_data_offsets_netfs_failure {};

struct trace_event_data_offsets_netfs_folio {};

struct trace_event_data_offsets_netfs_folioq {};

struct trace_event_data_offsets_netfs_read {};

struct trace_event_data_offsets_netfs_rreq {};

struct trace_event_data_offsets_netfs_rreq_ref {};

struct trace_event_data_offsets_netfs_sreq {};

struct trace_event_data_offsets_netfs_sreq_ref {};

struct trace_event_data_offsets_netfs_write {};

struct trace_event_data_offsets_netfs_write_iter {};

struct trace_event_data_offsets_netlink_extack {
	u32 msg;
	const void *msg_ptr_;
};

struct trace_event_data_offsets_nfs4_cached_open {};

struct trace_event_data_offsets_nfs4_cb_error_class {};

struct trace_event_data_offsets_nfs4_clientid_event {
	u32 dstaddr;
	const void *dstaddr_ptr_;
};

struct trace_event_data_offsets_nfs4_close {};

struct trace_event_data_offsets_nfs4_commit_event {};

struct trace_event_data_offsets_nfs4_delegreturn_exit {};

struct trace_event_data_offsets_nfs4_getattr_event {};

struct trace_event_data_offsets_nfs4_idmap_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs4_inode_callback_event {
	u32 dstaddr;
	const void *dstaddr_ptr_;
};

struct trace_event_data_offsets_nfs4_inode_event {};

struct trace_event_data_offsets_nfs4_inode_stateid_callback_event {
	u32 dstaddr;
	const void *dstaddr_ptr_;
};

struct trace_event_data_offsets_nfs4_inode_stateid_event {};

struct trace_event_data_offsets_nfs4_lock_event {};

struct trace_event_data_offsets_nfs4_lookup_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs4_lookupp {};

struct trace_event_data_offsets_nfs4_open_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs4_read_event {};

struct trace_event_data_offsets_nfs4_rename {
	u32 oldname;
	const void *oldname_ptr_;
	u32 newname;
	const void *newname_ptr_;
};

struct trace_event_data_offsets_nfs4_set_delegation_event {};

struct trace_event_data_offsets_nfs4_set_lock {};

struct trace_event_data_offsets_nfs4_setup_sequence {};

struct trace_event_data_offsets_nfs4_state_lock_reclaim {};

struct trace_event_data_offsets_nfs4_state_mgr {
	u32 hostname;
	const void *hostname_ptr_;
};

struct trace_event_data_offsets_nfs4_state_mgr_failed {
	u32 hostname;
	const void *hostname_ptr_;
	u32 section;
	const void *section_ptr_;
};

struct trace_event_data_offsets_nfs4_write_event {};

struct trace_event_data_offsets_nfs4_xdr_bad_operation {};

struct trace_event_data_offsets_nfs4_xdr_event {};

struct trace_event_data_offsets_nfs_access_exit {};

struct trace_event_data_offsets_nfs_aop_readahead {};

struct trace_event_data_offsets_nfs_aop_readahead_done {};

struct trace_event_data_offsets_nfs_atomic_open_enter {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_atomic_open_exit {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_commit_done {};

struct trace_event_data_offsets_nfs_create_enter {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_create_exit {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_direct_req_class {};

struct trace_event_data_offsets_nfs_directory_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_directory_event_done {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_fh_to_dentry {};

struct trace_event_data_offsets_nfs_folio_event {};

struct trace_event_data_offsets_nfs_folio_event_done {};

struct trace_event_data_offsets_nfs_initiate_commit {};

struct trace_event_data_offsets_nfs_initiate_read {};

struct trace_event_data_offsets_nfs_initiate_write {};

struct trace_event_data_offsets_nfs_inode_event {};

struct trace_event_data_offsets_nfs_inode_event_done {};

struct trace_event_data_offsets_nfs_inode_range_event {};

struct trace_event_data_offsets_nfs_link_enter {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_link_exit {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_local_open_fh {};

struct trace_event_data_offsets_nfs_lookup_event {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_lookup_event_done {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_mount_assign {
	u32 option;
	const void *option_ptr_;
	u32 value;
	const void *value_ptr_;
};

struct trace_event_data_offsets_nfs_mount_option {
	u32 option;
	const void *option_ptr_;
};

struct trace_event_data_offsets_nfs_mount_path {
	u32 path;
	const void *path_ptr_;
};

struct trace_event_data_offsets_nfs_page_error_class {};

struct trace_event_data_offsets_nfs_pgio_error {};

struct trace_event_data_offsets_nfs_readdir_event {};

struct trace_event_data_offsets_nfs_readpage_done {};

struct trace_event_data_offsets_nfs_readpage_short {};

struct trace_event_data_offsets_nfs_rename_event {
	u32 old_name;
	const void *old_name_ptr_;
	u32 new_name;
	const void *new_name_ptr_;
};

struct trace_event_data_offsets_nfs_rename_event_done {
	u32 old_name;
	const void *old_name_ptr_;
	u32 new_name;
	const void *new_name_ptr_;
};

struct trace_event_data_offsets_nfs_sillyrename_unlink {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_nfs_update_size_class {};

struct trace_event_data_offsets_nfs_writeback_done {};

struct trace_event_data_offsets_nfs_xdr_event {
	u32 program;
	const void *program_ptr_;
	u32 procedure;
	const void *procedure_ptr_;
};

struct trace_event_data_offsets_nlmclnt_lock_event {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_nmi_handler {};

struct trace_event_data_offsets_notifier_info {};

struct trace_event_data_offsets_nvme_async_event {};

struct trace_event_data_offsets_nvme_complete_rq {};

struct trace_event_data_offsets_nvme_setup_cmd {};

struct trace_event_data_offsets_nvme_sq {};

struct trace_event_data_offsets_oom_score_adj_update {};

struct trace_event_data_offsets_ovs_do_execute_action {
	u32 dp_name;
	const void *dp_name_ptr_;
	u32 dev_name;
	const void *dev_name_ptr_;
};

struct trace_event_data_offsets_ovs_dp_upcall {
	u32 dp_name;
	const void *dp_name_ptr_;
	u32 dev_name;
	const void *dev_name_ptr_;
};

struct trace_event_data_offsets_page_pool_release {};

struct trace_event_data_offsets_page_pool_state_hold {};

struct trace_event_data_offsets_page_pool_state_release {};

struct trace_event_data_offsets_page_pool_update_nid {};

struct trace_event_data_offsets_percpu_alloc_percpu {};

struct trace_event_data_offsets_percpu_alloc_percpu_fail {};

struct trace_event_data_offsets_percpu_create_chunk {};

struct trace_event_data_offsets_percpu_destroy_chunk {};

struct trace_event_data_offsets_percpu_free_percpu {};

struct trace_event_data_offsets_pm_qos_update {};

struct trace_event_data_offsets_pmap_register {};

struct trace_event_data_offsets_power_domain {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_powernv_throttle {
	u32 reason;
	const void *reason_ptr_;
};

struct trace_event_data_offsets_prq_report {
	u32 iommu;
	const void *iommu_ptr_;
	u32 dev;
	const void *dev_ptr_;
	u32 buff;
	const void *buff_ptr_;
};

struct trace_event_data_offsets_pstate_sample {};

struct trace_event_data_offsets_purge_vmap_area_lazy {};

struct trace_event_data_offsets_qdisc_create {
	u32 dev;
	const void *dev_ptr_;
	u32 kind;
	const void *kind_ptr_;
};

struct trace_event_data_offsets_qdisc_dequeue {};

struct trace_event_data_offsets_qdisc_destroy {
	u32 dev;
	const void *dev_ptr_;
	u32 kind;
	const void *kind_ptr_;
};

struct trace_event_data_offsets_qdisc_enqueue {};

struct trace_event_data_offsets_qdisc_reset {
	u32 dev;
	const void *dev_ptr_;
	u32 kind;
	const void *kind_ptr_;
};

struct trace_event_data_offsets_qgroup_meta_convert {};

struct trace_event_data_offsets_qgroup_meta_free_all_pertrans {};

struct trace_event_data_offsets_qgroup_meta_reserve {};

struct trace_event_data_offsets_qgroup_num_dirty_extents {};

struct trace_event_data_offsets_qgroup_update_counters {};

struct trace_event_data_offsets_qgroup_update_reserve {};

struct trace_event_data_offsets_qi_submit {
	u32 iommu;
	const void *iommu_ptr_;
};

struct trace_event_data_offsets_rcu_barrier {};

struct trace_event_data_offsets_rcu_batch_end {};

struct trace_event_data_offsets_rcu_batch_start {};

struct trace_event_data_offsets_rcu_callback {};

struct trace_event_data_offsets_rcu_exp_funnel_lock {};

struct trace_event_data_offsets_rcu_exp_grace_period {};

struct trace_event_data_offsets_rcu_fqs {};

struct trace_event_data_offsets_rcu_future_grace_period {};

struct trace_event_data_offsets_rcu_grace_period {};

struct trace_event_data_offsets_rcu_grace_period_init {};

struct trace_event_data_offsets_rcu_invoke_callback {};

struct trace_event_data_offsets_rcu_invoke_kfree_bulk_callback {};

struct trace_event_data_offsets_rcu_invoke_kvfree_callback {};

struct trace_event_data_offsets_rcu_kvfree_callback {};

struct trace_event_data_offsets_rcu_preempt_task {};

struct trace_event_data_offsets_rcu_quiescent_state_report {};

struct trace_event_data_offsets_rcu_segcb_stats {};

struct trace_event_data_offsets_rcu_sr_normal {};

struct trace_event_data_offsets_rcu_stall_warning {};

struct trace_event_data_offsets_rcu_torture_read {};

struct trace_event_data_offsets_rcu_unlock_preempted_task {};

struct trace_event_data_offsets_rcu_utilization {};

struct trace_event_data_offsets_rcu_watching {};

struct trace_event_data_offsets_reclaim_retry_zone {};

struct trace_event_data_offsets_register_class {
	u32 program;
	const void *program_ptr_;
};

struct trace_event_data_offsets_register_session {};

struct trace_event_data_offsets_register_tunnel {};

struct trace_event_data_offsets_rpc_buf_alloc {};

struct trace_event_data_offsets_rpc_call_rpcerror {};

struct trace_event_data_offsets_rpc_clnt_class {};

struct trace_event_data_offsets_rpc_clnt_clone_err {};

struct trace_event_data_offsets_rpc_clnt_new {
	u32 program;
	const void *program_ptr_;
	u32 server;
	const void *server_ptr_;
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_rpc_clnt_new_err {
	u32 program;
	const void *program_ptr_;
	u32 server;
	const void *server_ptr_;
};

struct trace_event_data_offsets_rpc_failure {};

struct trace_event_data_offsets_rpc_reply_event {
	u32 progname;
	const void *progname_ptr_;
	u32 procname;
	const void *procname_ptr_;
	u32 servername;
	const void *servername_ptr_;
};

struct trace_event_data_offsets_rpc_request {
	u32 progname;
	const void *progname_ptr_;
	u32 procname;
	const void *procname_ptr_;
};

struct trace_event_data_offsets_rpc_socket_nospace {};

struct trace_event_data_offsets_rpc_stats_latency {
	u32 progname;
	const void *progname_ptr_;
	u32 procname;
	const void *procname_ptr_;
};

struct trace_event_data_offsets_rpc_task_queued {
	u32 q_name;
	const void *q_name_ptr_;
};

struct trace_event_data_offsets_rpc_task_running {};

struct trace_event_data_offsets_rpc_task_status {};

struct trace_event_data_offsets_rpc_tls_class {
	u32 servername;
	const void *servername_ptr_;
	u32 progname;
	const void *progname_ptr_;
};

struct trace_event_data_offsets_rpc_xdr_alignment {
	u32 progname;
	const void *progname_ptr_;
	u32 procedure;
	const void *procedure_ptr_;
};

struct trace_event_data_offsets_rpc_xdr_buf_class {};

struct trace_event_data_offsets_rpc_xdr_overflow {
	u32 progname;
	const void *progname_ptr_;
	u32 procedure;
	const void *procedure_ptr_;
};

struct trace_event_data_offsets_rpc_xprt_event {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_rpc_xprt_lifetime_class {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_rpcb_getport {
	u32 servername;
	const void *servername_ptr_;
};

struct trace_event_data_offsets_rpcb_register {
	u32 addr;
	const void *addr_ptr_;
	u32 netid;
	const void *netid_ptr_;
};

struct trace_event_data_offsets_rpcb_setport {};

struct trace_event_data_offsets_rpcb_unregister {
	u32 netid;
	const void *netid_ptr_;
};

struct trace_event_data_offsets_rpcgss_bad_seqno {};

struct trace_event_data_offsets_rpcgss_context {
	u32 acceptor;
	const void *acceptor_ptr_;
};

struct trace_event_data_offsets_rpcgss_createauth {};

struct trace_event_data_offsets_rpcgss_ctx_class {
	u32 principal;
	const void *principal_ptr_;
};

struct trace_event_data_offsets_rpcgss_gssapi_event {};

struct trace_event_data_offsets_rpcgss_import_ctx {};

struct trace_event_data_offsets_rpcgss_need_reencode {};

struct trace_event_data_offsets_rpcgss_oid_to_mech {
	u32 oid;
	const void *oid_ptr_;
};

struct trace_event_data_offsets_rpcgss_seqno {};

struct trace_event_data_offsets_rpcgss_svc_accept_upcall {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_svc_authenticate {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_svc_gssapi_class {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_svc_seqno_bad {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_svc_seqno_class {};

struct trace_event_data_offsets_rpcgss_svc_seqno_low {};

struct trace_event_data_offsets_rpcgss_svc_unwrap_failed {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_svc_wrap_failed {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_rpcgss_unwrap_failed {};

struct trace_event_data_offsets_rpcgss_upcall_msg {
	u32 msg;
	const void *msg_ptr_;
};

struct trace_event_data_offsets_rpcgss_upcall_result {};

struct trace_event_data_offsets_rpcgss_update_slack {};

struct trace_event_data_offsets_rpm_internal {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_rpm_return_int {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_rpm_status {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_rseq_ip_fixup {};

struct trace_event_data_offsets_rseq_update {};

struct trace_event_data_offsets_rss_stat {};

struct trace_event_data_offsets_rtc_alarm_irq_enable {};

struct trace_event_data_offsets_rtc_irq_set_freq {};

struct trace_event_data_offsets_rtc_irq_set_state {};

struct trace_event_data_offsets_rtc_offset_class {};

struct trace_event_data_offsets_rtc_time_alarm_class {};

struct trace_event_data_offsets_rtc_timer_class {};

struct trace_event_data_offsets_sched_kthread_stop {};

struct trace_event_data_offsets_sched_kthread_stop_ret {};

struct trace_event_data_offsets_sched_kthread_work_execute_end {};

struct trace_event_data_offsets_sched_kthread_work_execute_start {};

struct trace_event_data_offsets_sched_kthread_work_queue_work {};

struct trace_event_data_offsets_sched_migrate_task {};

struct trace_event_data_offsets_sched_move_numa {};

struct trace_event_data_offsets_sched_numa_pair_template {};

struct trace_event_data_offsets_sched_pi_setprio {};

struct trace_event_data_offsets_sched_prepare_exec {
	u32 interp;
	const void *interp_ptr_;
	u32 filename;
	const void *filename_ptr_;
	u32 comm;
	const void *comm_ptr_;
};

struct trace_event_data_offsets_sched_process_exec {
	u32 filename;
	const void *filename_ptr_;
};

struct trace_event_data_offsets_sched_process_fork {};

struct trace_event_data_offsets_sched_process_template {};

struct trace_event_data_offsets_sched_process_wait {};

struct trace_event_data_offsets_sched_stat_runtime {};

struct trace_event_data_offsets_sched_stat_template {};

struct trace_event_data_offsets_sched_switch {};

struct trace_event_data_offsets_sched_wake_idle_without_ipi {};

struct trace_event_data_offsets_sched_wakeup_template {};

struct trace_event_data_offsets_scsi_cmd_done_timeout_template {
	u32 cmnd;
	const void *cmnd_ptr_;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_error {
	u32 cmnd;
	const void *cmnd_ptr_;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_start {
	u32 cmnd;
	const void *cmnd_ptr_;
};

struct trace_event_data_offsets_scsi_eh_wakeup {};

struct trace_event_data_offsets_sctp_probe {};

struct trace_event_data_offsets_sctp_probe_path {};

struct trace_event_data_offsets_session_only_evt {};

struct trace_event_data_offsets_session_pkt_discard_evt {};

struct trace_event_data_offsets_session_seqnum_evt {};

struct trace_event_data_offsets_signal_deliver {};

struct trace_event_data_offsets_signal_generate {};

struct trace_event_data_offsets_sk_data_ready {};

struct trace_event_data_offsets_skb_copy_datagram_iovec {};

struct trace_event_data_offsets_skip_task_reaping {};

struct trace_event_data_offsets_smbus_read {};

struct trace_event_data_offsets_smbus_reply {};

struct trace_event_data_offsets_smbus_result {};

struct trace_event_data_offsets_smbus_write {};

struct trace_event_data_offsets_sock_exceed_buf_limit {};

struct trace_event_data_offsets_sock_msg_length {};

struct trace_event_data_offsets_sock_rcvqueue_full {};

struct trace_event_data_offsets_softirq {};

struct trace_event_data_offsets_start_task_reaping {};

struct trace_event_data_offsets_subflow_check_data_avail {};

struct trace_event_data_offsets_suspend_resume {};

struct trace_event_data_offsets_svc_alloc_arg_err {};

struct trace_event_data_offsets_svc_authenticate {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_deferred_event {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svc_process {
	u32 service;
	const void *service_ptr_;
	u32 procedure;
	const void *procedure_ptr_;
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svc_replace_page_err {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_rqst_event {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_rqst_status {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_stats_latency {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
	u32 procedure;
	const void *procedure_ptr_;
};

struct trace_event_data_offsets_svc_unregister {
	u32 program;
	const void *program_ptr_;
};

struct trace_event_data_offsets_svc_wake_up {};

struct trace_event_data_offsets_svc_xdr_buf_class {};

struct trace_event_data_offsets_svc_xdr_msg_class {};

struct trace_event_data_offsets_svc_xprt_accept {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
	u32 protocol;
	const void *protocol_ptr_;
	u32 service;
	const void *service_ptr_;
};

struct trace_event_data_offsets_svc_xprt_create_err {
	u32 program;
	const void *program_ptr_;
	u32 protocol;
	const void *protocol_ptr_;
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svc_xprt_dequeue {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_xprt_enqueue {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svc_xprt_event {
	u32 server;
	const void *server_ptr_;
	u32 client;
	const void *client_ptr_;
};

struct trace_event_data_offsets_svcsock_accept_class {
	u32 service;
	const void *service_ptr_;
};

struct trace_event_data_offsets_svcsock_class {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svcsock_lifetime_class {};

struct trace_event_data_offsets_svcsock_marker {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svcsock_tcp_recv_short {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_svcsock_tcp_state {
	u32 addr;
	const void *addr_ptr_;
};

struct trace_event_data_offsets_swiotlb_bounced {
	u32 dev_name;
	const void *dev_name_ptr_;
};

struct trace_event_data_offsets_sys_enter {};

struct trace_event_data_offsets_sys_exit {};

struct trace_event_data_offsets_task_newtask {};

struct trace_event_data_offsets_task_prctl_unknown {};

struct trace_event_data_offsets_task_rename {};

struct trace_event_data_offsets_tasklet {};

struct trace_event_data_offsets_tcp_ao_event {};

struct trace_event_data_offsets_tcp_ao_event_sk {};

struct trace_event_data_offsets_tcp_ao_event_sne {};

struct trace_event_data_offsets_tcp_cong_state_set {};

struct trace_event_data_offsets_tcp_event_sk {};

struct trace_event_data_offsets_tcp_event_sk_skb {};

struct trace_event_data_offsets_tcp_event_skb {};

struct trace_event_data_offsets_tcp_hash_event {};

struct trace_event_data_offsets_tcp_probe {};

struct trace_event_data_offsets_tcp_retransmit_synack {};

struct trace_event_data_offsets_tcp_send_reset {};

struct trace_event_data_offsets_test_pages_isolated {};

struct trace_event_data_offsets_thermal_temperature {
	u32 thermal_zone;
	const void *thermal_zone_ptr_;
};

struct trace_event_data_offsets_thermal_zone_trip {
	u32 thermal_zone;
	const void *thermal_zone_ptr_;
};

struct trace_event_data_offsets_tick_stop {};

struct trace_event_data_offsets_timer_base_idle {};

struct trace_event_data_offsets_timer_class {};

struct trace_event_data_offsets_timer_expire_entry {};

struct trace_event_data_offsets_timer_start {};

struct trace_event_data_offsets_tipc_fsm_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_tipc_l2_device_event {
	u32 dev_name;
	const void *dev_name_ptr_;
	u32 b_name;
	const void *b_name_ptr_;
};

struct trace_event_data_offsets_tipc_link_class {
	u32 header;
	const void *header_ptr_;
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_tipc_link_transmq_class {};

struct trace_event_data_offsets_tipc_list_class {
	u32 header;
	const void *header_ptr_;
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_tipc_node_class {
	u32 header;
	const void *header_ptr_;
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_tipc_sk_class {
	u32 header;
	const void *header_ptr_;
	u32 buf;
	const void *buf_ptr_;
	u32 skb_buf;
	const void *skb_buf_ptr_;
};

struct trace_event_data_offsets_tipc_skb_class {
	u32 header;
	const void *header_ptr_;
	u32 buf;
	const void *buf_ptr_;
};

struct trace_event_data_offsets_tlb_flush {};

struct trace_event_data_offsets_tls_contenttype {};

struct trace_event_data_offsets_tls_device_decrypted {};

struct trace_event_data_offsets_tls_device_offload_set {};

struct trace_event_data_offsets_tls_device_rx_resync_nh_delay {};

struct trace_event_data_offsets_tls_device_rx_resync_nh_schedule {};

struct trace_event_data_offsets_tls_device_rx_resync_send {};

struct trace_event_data_offsets_tls_device_tx_resync_req {};

struct trace_event_data_offsets_tls_device_tx_resync_send {};

struct trace_event_data_offsets_tmigr_connect_child_parent {};

struct trace_event_data_offsets_tmigr_connect_cpu_parent {};

struct trace_event_data_offsets_tmigr_cpugroup {};

struct trace_event_data_offsets_tmigr_group_and_cpu {};

struct trace_event_data_offsets_tmigr_group_set {};

struct trace_event_data_offsets_tmigr_handle_remote {};

struct trace_event_data_offsets_tmigr_idle {};

struct trace_event_data_offsets_tmigr_update_events {};

struct trace_event_data_offsets_track_foreign_dirty {};

struct trace_event_data_offsets_tunnel_only_evt {};

struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};

struct trace_event_data_offsets_unmap {};

struct trace_event_data_offsets_vector_activate {};

struct trace_event_data_offsets_vector_alloc {};

struct trace_event_data_offsets_vector_alloc_managed {};

struct trace_event_data_offsets_vector_config {};

struct trace_event_data_offsets_vector_free_moved {};

struct trace_event_data_offsets_vector_mod {};

struct trace_event_data_offsets_vector_reserve {};

struct trace_event_data_offsets_vector_setup {};

struct trace_event_data_offsets_vector_teardown {};

struct trace_event_data_offsets_virtio_gpu_cmd {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_virtio_transport_alloc_pkt {};

struct trace_event_data_offsets_virtio_transport_recv_pkt {};

struct trace_event_data_offsets_vlv_fifo_size {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_vlv_wm {
	u32 dev;
	const void *dev_ptr_;
};

struct trace_event_data_offsets_vm_unmapped_area {};

struct trace_event_data_offsets_vma_mas_szero {};

struct trace_event_data_offsets_vma_store {};

struct trace_event_data_offsets_wake_reaper {};

struct trace_event_data_offsets_wakeup_source {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_watchdog_set_timeout {};

struct trace_event_data_offsets_watchdog_template {};

struct trace_event_data_offsets_wbc_class {};

struct trace_event_data_offsets_workqueue_activate_work {};

struct trace_event_data_offsets_workqueue_execute_end {};

struct trace_event_data_offsets_workqueue_execute_start {};

struct trace_event_data_offsets_workqueue_queue_work {
	u32 workqueue;
	const void *workqueue_ptr_;
};

struct trace_event_data_offsets_writeback_bdi_register {};

struct trace_event_data_offsets_writeback_class {};

struct trace_event_data_offsets_writeback_dirty_inode_template {};

struct trace_event_data_offsets_writeback_folio_template {};

struct trace_event_data_offsets_writeback_inode_template {};

struct trace_event_data_offsets_writeback_pages_written {};

struct trace_event_data_offsets_writeback_queue_io {};

struct trace_event_data_offsets_writeback_sb_inodes_requeue {};

struct trace_event_data_offsets_writeback_single_inode_template {};

struct trace_event_data_offsets_writeback_work_class {};

struct trace_event_data_offsets_writeback_write_inode_template {};

struct trace_event_data_offsets_x86_exceptions {};

struct trace_event_data_offsets_x86_fpu {};

struct trace_event_data_offsets_x86_irq_vector {};

struct trace_event_data_offsets_xchk_block_error_class {};

struct trace_event_data_offsets_xchk_btree_error {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_btree_op_error {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_class {};

struct trace_event_data_offsets_xchk_dirpath_changed {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_dirpath_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_dirpath_outcome_class {};

struct trace_event_data_offsets_xchk_dirtree_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_dirtree_evaluate_class {};

struct trace_event_data_offsets_xchk_dirtree_live_update {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_dqiter_class {};

struct trace_event_data_offsets_xchk_fblock_error_class {};

struct trace_event_data_offsets_xchk_file_op_error {};

struct trace_event_data_offsets_xchk_fscounters_calc {};

struct trace_event_data_offsets_xchk_fscounters_within_range {};

struct trace_event_data_offsets_xchk_fsfreeze_class {};

struct trace_event_data_offsets_xchk_fsgate_class {};

struct trace_event_data_offsets_xchk_iallocbt_check_cluster {};

struct trace_event_data_offsets_xchk_ifork_btree_error {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_ifork_btree_op_error {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_incomplete {};

struct trace_event_data_offsets_xchk_ino_error_class {};

struct trace_event_data_offsets_xchk_inode_is_allocated {};

struct trace_event_data_offsets_xchk_iscan_class {};

struct trace_event_data_offsets_xchk_iscan_iget {};

struct trace_event_data_offsets_xchk_iscan_iget_batch {};

struct trace_event_data_offsets_xchk_iscan_ino_class {};

struct trace_event_data_offsets_xchk_iscan_retry_wait_class {};

struct trace_event_data_offsets_xchk_metapath_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_nlinks_check_zero {};

struct trace_event_data_offsets_xchk_nlinks_collect_dirent {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_nlinks_collect_metafile {};

struct trace_event_data_offsets_xchk_nlinks_collect_pptr {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_nlinks_diff_class {};

struct trace_event_data_offsets_xchk_nlinks_live_update {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_nlinks_update_incore {};

struct trace_event_data_offsets_xchk_op_error {};

struct trace_event_data_offsets_xchk_pptr_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_qcheck_error {};

struct trace_event_data_offsets_xchk_refcount_incorrect {};

struct trace_event_data_offsets_xchk_sbtree_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xchk_vector_class {};

struct trace_event_data_offsets_xchk_vector_head_class {};

struct trace_event_data_offsets_xchk_xref_error {};

struct trace_event_data_offsets_xdp_bulk_tx {};

struct trace_event_data_offsets_xdp_cpumap_enqueue {};

struct trace_event_data_offsets_xdp_cpumap_kthread {};

struct trace_event_data_offsets_xdp_devmap_xmit {};

struct trace_event_data_offsets_xdp_exception {};

struct trace_event_data_offsets_xdp_redirect_template {};

struct trace_event_data_offsets_xfarray_create {};

struct trace_event_data_offsets_xfarray_foliosort {};

struct trace_event_data_offsets_xfarray_isort {};

struct trace_event_data_offsets_xfarray_qsort {};

struct trace_event_data_offsets_xfarray_sort {};

struct trace_event_data_offsets_xfarray_sort_scan {};

struct trace_event_data_offsets_xfarray_sort_stats {};

struct trace_event_data_offsets_xfile_class {};

struct trace_event_data_offsets_xfile_create {};

struct trace_event_data_offsets_xfile_destroy {};

struct trace_event_data_offsets_xfs_ag_class {};

struct trace_event_data_offsets_xfs_ag_inode_class {};

struct trace_event_data_offsets_xfs_ag_resv_class {};

struct trace_event_data_offsets_xfs_ag_resv_init_error {};

struct trace_event_data_offsets_xfs_agf_class {};

struct trace_event_data_offsets_xfs_ail_class {};

struct trace_event_data_offsets_xfs_alloc_class {};

struct trace_event_data_offsets_xfs_alloc_cur_check {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_attr_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_attr_list_class {};

struct trace_event_data_offsets_xfs_attr_list_node_descend {};

struct trace_event_data_offsets_xfs_bmap_class {};

struct trace_event_data_offsets_xfs_bmap_deferred_class {};

struct trace_event_data_offsets_xfs_btree_alloc_block {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_btree_bload_block {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_btree_bload_level_geometry {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_btree_commit_afakeroot {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_btree_commit_ifakeroot {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_btree_cur_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_btree_error_class {};

struct trace_event_data_offsets_xfs_btree_free_block {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_buf_class {};

struct trace_event_data_offsets_xfs_buf_flags_class {};

struct trace_event_data_offsets_xfs_buf_ioerror {};

struct trace_event_data_offsets_xfs_buf_item_class {};

struct trace_event_data_offsets_xfs_bunmap {};

struct trace_event_data_offsets_xfs_check_new_dalign {};

struct trace_event_data_offsets_xfs_da_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_das_state_class {};

struct trace_event_data_offsets_xfs_defer_class {};

struct trace_event_data_offsets_xfs_defer_error_class {};

struct trace_event_data_offsets_xfs_defer_pending_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_defer_pending_item_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_dir2_leafn_moveents {};

struct trace_event_data_offsets_xfs_dir2_space_class {};

struct trace_event_data_offsets_xfs_discard_class {};

struct trace_event_data_offsets_xfs_double_io_class {};

struct trace_event_data_offsets_xfs_dqtrx_class {};

struct trace_event_data_offsets_xfs_dquot_class {};

struct trace_event_data_offsets_xfs_exchmaps_delta_nextents {};

struct trace_event_data_offsets_xfs_exchmaps_delta_nextents_step {};

struct trace_event_data_offsets_xfs_exchmaps_estimate_class {};

struct trace_event_data_offsets_xfs_exchmaps_intent_class {};

struct trace_event_data_offsets_xfs_exchmaps_overhead {};

struct trace_event_data_offsets_xfs_exchrange_class {};

struct trace_event_data_offsets_xfs_exchrange_freshness {};

struct trace_event_data_offsets_xfs_exchrange_inode_class {};

struct trace_event_data_offsets_xfs_extent_busy_class {};

struct trace_event_data_offsets_xfs_extent_busy_trim {};

struct trace_event_data_offsets_xfs_fault_class {};

struct trace_event_data_offsets_xfs_file_class {};

struct trace_event_data_offsets_xfs_filestream_class {};

struct trace_event_data_offsets_xfs_filestream_pick {};

struct trace_event_data_offsets_xfs_force_shutdown {
	u32 fname;
	const void *fname_ptr_;
};

struct trace_event_data_offsets_xfs_free_extent {};

struct trace_event_data_offsets_xfs_free_extent_deferred_class {};

struct trace_event_data_offsets_xfs_fs_class {};

struct trace_event_data_offsets_xfs_fs_corrupt_class {};

struct trace_event_data_offsets_xfs_fsmap_group_key_class {};

struct trace_event_data_offsets_xfs_fsmap_linear_key_class {};

struct trace_event_data_offsets_xfs_fsmap_mapping {};

struct trace_event_data_offsets_xfs_getfsmap_class {};

struct trace_event_data_offsets_xfs_getparents_class {};

struct trace_event_data_offsets_xfs_getparents_rec_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_group_class {};

struct trace_event_data_offsets_xfs_group_corrupt_class {};

struct trace_event_data_offsets_xfs_group_intents_class {};

struct trace_event_data_offsets_xfs_icwalk_class {};

struct trace_event_data_offsets_xfs_imap_class {};

struct trace_event_data_offsets_xfs_inode_class {};

struct trace_event_data_offsets_xfs_inode_corrupt_class {};

struct trace_event_data_offsets_xfs_inode_error_class {};

struct trace_event_data_offsets_xfs_inode_irec_class {};

struct trace_event_data_offsets_xfs_inode_reload_unlinked_bucket {};

struct trace_event_data_offsets_xfs_inodegc_shrinker_scan {};

struct trace_event_data_offsets_xfs_inodegc_worker {};

struct trace_event_data_offsets_xfs_ioctl_clone {};

struct trace_event_data_offsets_xfs_iomap_invalid_class {};

struct trace_event_data_offsets_xfs_iomap_prealloc_size {};

struct trace_event_data_offsets_xfs_irec_merge_post {};

struct trace_event_data_offsets_xfs_irec_merge_pre {};

struct trace_event_data_offsets_xfs_iref_class {};

struct trace_event_data_offsets_xfs_itrunc_class {};

struct trace_event_data_offsets_xfs_iunlink_reload_next {};

struct trace_event_data_offsets_xfs_iunlink_update_bucket {};

struct trace_event_data_offsets_xfs_iunlink_update_dinode {};

struct trace_event_data_offsets_xfs_iwalk_ag_rec {};

struct trace_event_data_offsets_xfs_lock_class {};

struct trace_event_data_offsets_xfs_log_assign_tail_lsn {};

struct trace_event_data_offsets_xfs_log_force {};

struct trace_event_data_offsets_xfs_log_get_max_trans_res {};

struct trace_event_data_offsets_xfs_log_item_class {};

struct trace_event_data_offsets_xfs_log_recover {};

struct trace_event_data_offsets_xfs_log_recover_buf_item_class {};

struct trace_event_data_offsets_xfs_log_recover_icreate_item_class {};

struct trace_event_data_offsets_xfs_log_recover_ino_item_class {};

struct trace_event_data_offsets_xfs_log_recover_item_class {};

struct trace_event_data_offsets_xfs_log_recover_record {};

struct trace_event_data_offsets_xfs_loggrant_class {};

struct trace_event_data_offsets_xfs_metadir_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_metadir_update_class {
	u32 fname;
	const void *fname_ptr_;
};

struct trace_event_data_offsets_xfs_metadir_update_error_class {
	u32 fname;
	const void *fname_ptr_;
};

struct trace_event_data_offsets_xfs_metafile_resv_class {};

struct trace_event_data_offsets_xfs_namespace_class {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xfs_pagecache_inval {};

struct trace_event_data_offsets_xfs_perag_class {};

struct trace_event_data_offsets_xfs_pwork_init {};

struct trace_event_data_offsets_xfs_refcount_class {};

struct trace_event_data_offsets_xfs_refcount_deferred_class {};

struct trace_event_data_offsets_xfs_refcount_double_extent_at_class {};

struct trace_event_data_offsets_xfs_refcount_double_extent_class {};

struct trace_event_data_offsets_xfs_refcount_extent_at_class {};

struct trace_event_data_offsets_xfs_refcount_extent_class {};

struct trace_event_data_offsets_xfs_refcount_lookup {};

struct trace_event_data_offsets_xfs_refcount_triple_extent_class {};

struct trace_event_data_offsets_xfs_reflink_remap_blocks {};

struct trace_event_data_offsets_xfs_rename {
	u32 src_name;
	const void *src_name_ptr_;
	u32 target_name;
	const void *target_name_ptr_;
};

struct trace_event_data_offsets_xfs_rmap_class {};

struct trace_event_data_offsets_xfs_rmap_convert_state {};

struct trace_event_data_offsets_xfs_rmap_deferred_class {};

struct trace_event_data_offsets_xfs_rmapbt_class {};

struct trace_event_data_offsets_xfs_rtdiscard_class {};

struct trace_event_data_offsets_xfs_simple_io_class {};

struct trace_event_data_offsets_xfs_swap_extent_class {};

struct trace_event_data_offsets_xfs_timestamp_range_class {};

struct trace_event_data_offsets_xfs_trans_class {};

struct trace_event_data_offsets_xfs_trans_mod_dquot {};

struct trace_event_data_offsets_xfs_trans_resv_class {};

struct trace_event_data_offsets_xfs_wb_invalid_class {};

struct trace_event_data_offsets_xlog_iclog_class {};

struct trace_event_data_offsets_xlog_intent_recovery_failed {
	u32 name;
	const void *name_ptr_;
};

struct trace_event_data_offsets_xmbuf_create {};

struct trace_event_data_offsets_xmbuf_free {};

struct trace_event_data_offsets_xprt_cong_event {};

struct trace_event_data_offsets_xprt_ping {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_xprt_reserve {};

struct trace_event_data_offsets_xprt_retransmit {
	u32 progname;
	const void *progname_ptr_;
	u32 procname;
	const void *procname_ptr_;
};

struct trace_event_data_offsets_xprt_transmit {};

struct trace_event_data_offsets_xprt_writelock_event {};

struct trace_event_data_offsets_xs_data_ready {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_xs_socket_event {};

struct trace_event_data_offsets_xs_socket_event_done {};

struct trace_event_data_offsets_xs_stream_read_data {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_data_offsets_xs_stream_read_request {
	u32 addr;
	const void *addr_ptr_;
	u32 port;
	const void *port_ptr_;
};

struct trace_event_fields {
	const char *type;
	union {
		struct {
			const char *name;
			const int size;
			const int align;
			const unsigned int is_signed: 1;
			unsigned int needs_test: 1;
			const int filter_type;
			const int len;
		};
		int (*define_fields)(struct trace_event_call *);
	};
};

struct trace_subsystem_dir;

struct trace_event_file {
	struct list_head list;
	struct trace_event_call *event_call;
	struct event_filter *filter;
	struct eventfs_inode *ei;
	struct trace_array *tr;
	struct trace_subsystem_dir *system;
	struct list_head triggers;
	long unsigned int flags;
	refcount_t ref;
	atomic_t sm_ref;
	atomic_t tm_ref;
};

typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);

struct trace_event_functions {
	trace_print_func trace;
	trace_print_func raw;
	trace_print_func hex;
	trace_print_func binary;
};

struct trace_event_raw_9p_client_req {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	char __data[0];
};

struct trace_event_raw_9p_client_res {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	__u32 err;
	char __data[0];
};

struct trace_event_raw_9p_fid_ref {
	struct trace_entry ent;
	int fid;
	int refcount;
	__u8 type;
	char __data[0];
};

struct trace_event_raw_9p_protocol_dump {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u16 tag;
	u32 __data_loc_line;
	char __data[0];
};

struct trace_event_raw_ack_update_msk {
	struct trace_entry ent;
	u64 data_ack;
	u64 old_snd_una;
	u64 new_snd_una;
	u64 new_wnd_end;
	u64 msk_wnd_end;
	char __data[0];
};

struct trace_event_raw_alarm_class {
	struct trace_entry ent;
	void *alarm;
	unsigned char alarm_type;
	s64 expires;
	s64 now;
	char __data[0];
};

struct trace_event_raw_alarmtimer_suspend {
	struct trace_entry ent;
	s64 expires;
	unsigned char alarm_type;
	char __data[0];
};

struct trace_event_raw_alloc_extent_state {
	struct trace_entry ent;
	const struct extent_state *state;
	long unsigned int mask;
	const void *ip;
	char __data[0];
};

struct trace_event_raw_alloc_vmap_area {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int size;
	long unsigned int align;
	long unsigned int vstart;
	long unsigned int vend;
	int failed;
	char __data[0];
};

struct trace_event_raw_amd_pstate_epp_perf {
	struct trace_entry ent;
	unsigned int cpu_id;
	u8 highest_perf;
	u8 epp;
	u8 min_perf;
	u8 max_perf;
	bool boost;
	char __data[0];
};

struct trace_event_raw_amd_pstate_perf {
	struct trace_entry ent;
	u8 min_perf;
	u8 target_perf;
	u8 capacity;
	long long unsigned int freq;
	long long unsigned int mperf;
	long long unsigned int aperf;
	long long unsigned int tsc;
	unsigned int cpu_id;
	bool fast_switch;
	char __data[0];
};

struct trace_event_raw_balance_dirty_pages {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int limit;
	long unsigned int setpoint;
	long unsigned int dirty;
	long unsigned int bdi_setpoint;
	long unsigned int bdi_dirty;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	unsigned int dirtied;
	unsigned int dirtied_pause;
	long unsigned int paused;
	long int pause;
	long unsigned int period;
	long int think;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_batadv_dbg {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_bdi_dirty_ratelimit {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int write_bw;
	long unsigned int avg_write_bw;
	long unsigned int dirty_rate;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_block_bio {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_bio_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_buffer {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	size_t size;
	char __data[0];
};

struct trace_event_raw_block_plug {
	struct trace_entry ent;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	unsigned int bytes;
	short unsigned int ioprio;
	char rwbs[8];
	char comm[16];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_completion {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	short unsigned int ioprio;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	unsigned int nr_bios;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_rq_requeue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	short unsigned int ioprio;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_split {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	sector_t new_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_unplug {
	struct trace_entry ent;
	int nr_rq;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_bpf_test_finish {
	struct trace_entry ent;
	int err;
	char __data[0];
};

struct trace_event_raw_bpf_trace_printk {
	struct trace_entry ent;
	u32 __data_loc_bpf_string;
	char __data[0];
};

struct trace_event_raw_bpf_trigger_tp {
	struct trace_entry ent;
	int nonce;
	char __data[0];
};

struct trace_event_raw_bpf_xdp_link_attach_failed {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_br_fdb_add {
	struct trace_entry ent;
	u8 ndm_flags;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	u16 nlh_flags;
	char __data[0];
};

struct trace_event_raw_br_fdb_external_learn_add {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_br_fdb_update {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_br_mdb_full {
	struct trace_entry ent;
	u32 __data_loc_dev;
	int af;
	u16 vid;
	__u8 src[16];
	__u8 grp[16];
	__u8 grpmac[6];
	char __data[0];
};

struct trace_event_raw_btrfs__block_group {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 len;
	u64 used;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_btrfs__chunk {
	struct trace_entry ent;
	u8 fsid[16];
	int num_stripes;
	u64 type;
	int sub_stripes;
	u64 offset;
	u64 size;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs__file_extent_item_inline {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_obj;
	u64 ino;
	loff_t isize;
	u64 disk_isize;
	u8 extent_type;
	u8 compression;
	u64 extent_start;
	u64 extent_end;
	char __data[0];
};

struct trace_event_raw_btrfs__file_extent_item_regular {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_obj;
	u64 ino;
	loff_t isize;
	u64 disk_isize;
	u64 num_bytes;
	u64 ram_bytes;
	u64 disk_bytenr;
	u64 disk_num_bytes;
	u64 extent_offset;
	u8 extent_type;
	u8 compression;
	u64 extent_start;
	u64 extent_end;
	char __data[0];
};

struct trace_event_raw_btrfs__inode {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 blocks;
	u64 disk_i_size;
	u64 generation;
	u64 last_trans;
	u64 logged_trans;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs__ordered_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 file_offset;
	u64 start;
	u64 len;
	u64 disk_len;
	u64 bytes_left;
	long unsigned int flags;
	int compress_type;
	int refs;
	u64 root_objectid;
	u64 truncated_len;
	char __data[0];
};

struct trace_event_raw_btrfs__prelim_ref {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_id;
	u64 objectid;
	u8 type;
	u64 offset;
	int level;
	int old_count;
	u64 parent;
	u64 bytenr;
	int mod_count;
	u64 tree_size;
	char __data[0];
};

struct trace_event_raw_btrfs__qgroup_rsv_data {
	struct trace_entry ent;
	u8 fsid[16];
	u64 rootid;
	u64 ino;
	u64 start;
	u64 len;
	u64 reserved;
	int op;
	char __data[0];
};

struct trace_event_raw_btrfs__reserve_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	u64 flags;
	int bg_size_class;
	u64 start;
	u64 len;
	u64 loop;
	bool hinted;
	int size_class;
	char __data[0];
};

struct trace_event_raw_btrfs__reserved_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 start;
	u64 len;
	char __data[0];
};

struct trace_event_raw_btrfs__space_info_update {
	struct trace_entry ent;
	u8 fsid[16];
	u64 type;
	u64 old;
	s64 diff;
	char __data[0];
};

struct trace_event_raw_btrfs__work {
	struct trace_entry ent;
	u8 fsid[16];
	const void *work;
	const void *wq;
	const void *func;
	const void *ordered_func;
	const void *normal_work;
	char __data[0];
};

struct trace_event_raw_btrfs__work__done {
	struct trace_entry ent;
	u8 fsid[16];
	const void *wtag;
	char __data[0];
};

struct trace_event_raw_btrfs__writepage {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	long unsigned int index;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	char for_kupdate;
	char for_reclaim;
	char range_cyclic;
	long unsigned int writeback_index;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_add_block_group {
	struct trace_entry ent;
	u8 fsid[16];
	u64 offset;
	u64 size;
	u64 flags;
	u64 bytes_used;
	u64 bytes_super;
	int create;
	char __data[0];
};

struct trace_event_raw_btrfs_clear_extent_bit {
	struct trace_entry ent;
	u8 fsid[16];
	unsigned int owner;
	u64 ino;
	u64 rootid;
	u64 start;
	u64 len;
	unsigned int clear_bits;
	char __data[0];
};

struct trace_event_raw_btrfs_convert_extent_bit {
	struct trace_entry ent;
	u8 fsid[16];
	unsigned int owner;
	u64 ino;
	u64 rootid;
	u64 start;
	u64 len;
	unsigned int set_bits;
	unsigned int clear_bits;
	char __data[0];
};

struct trace_event_raw_btrfs_cow_block {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 buf_start;
	int refs;
	u64 cow_start;
	int buf_level;
	int cow_level;
	char __data[0];
};

struct trace_event_raw_btrfs_delayed_data_ref {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	int action;
	u64 parent;
	u64 ref_root;
	u64 owner;
	u64 offset;
	int type;
	u64 seq;
	char __data[0];
};

struct trace_event_raw_btrfs_delayed_ref_head {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	int action;
	int is_data;
	char __data[0];
};

struct trace_event_raw_btrfs_delayed_tree_ref {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	int action;
	u64 parent;
	u64 ref_root;
	int level;
	int type;
	u64 seq;
	char __data[0];
};

struct trace_event_raw_btrfs_dump_space_info {
	struct trace_entry ent;
	u8 fsid[16];
	u64 flags;
	u64 total_bytes;
	u64 bytes_used;
	u64 bytes_pinned;
	u64 bytes_reserved;
	u64 bytes_may_use;
	u64 bytes_readonly;
	u64 reclaim_size;
	int clamp;
	u64 global_reserved;
	u64 trans_reserved;
	u64 delayed_refs_reserved;
	u64 delayed_reserved;
	u64 free_chunk_space;
	u64 delalloc_bytes;
	u64 ordered_bytes;
	char __data[0];
};

struct trace_event_raw_btrfs_extent_map_shrinker_count {
	struct trace_entry ent;
	u8 fsid[16];
	long int nr;
	char __data[0];
};

struct trace_event_raw_btrfs_extent_map_shrinker_remove_em {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 root_id;
	u64 start;
	u64 len;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_btrfs_extent_map_shrinker_scan_enter {
	struct trace_entry ent;
	u8 fsid[16];
	long int nr_to_scan;
	long int nr;
	u64 last_root_id;
	u64 last_ino;
	char __data[0];
};

struct trace_event_raw_btrfs_extent_map_shrinker_scan_exit {
	struct trace_entry ent;
	u8 fsid[16];
	long int nr_dropped;
	long int nr;
	u64 last_root_id;
	u64 last_ino;
	char __data[0];
};

struct trace_event_raw_btrfs_failed_cluster_setup {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_find_cluster {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	u64 flags;
	u64 start;
	u64 bytes;
	u64 empty_size;
	u64 min_bytes;
	char __data[0];
};

struct trace_event_raw_btrfs_finish_ordered_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 start;
	u64 len;
	bool uptodate;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_flush_space {
	struct trace_entry ent;
	u8 fsid[16];
	u64 flags;
	u64 num_bytes;
	int state;
	int ret;
	bool for_preempt;
	char __data[0];
};

struct trace_event_raw_btrfs_get_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 ino;
	u64 start;
	u64 len;
	u32 flags;
	int refs;
	char __data[0];
};

struct trace_event_raw_btrfs_get_raid_extent_offset {
	struct trace_entry ent;
	u8 fsid[16];
	u64 logical;
	u64 length;
	u64 physical;
	u64 devid;
	char __data[0];
};

struct trace_event_raw_btrfs_handle_em_exist {
	struct trace_entry ent;
	u8 fsid[16];
	u64 e_start;
	u64 e_len;
	u64 map_start;
	u64 map_len;
	u64 start;
	u64 len;
	char __data[0];
};

struct trace_event_raw_btrfs_inode_mod_outstanding_extents {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 ino;
	int mod;
	unsigned int outstanding;
	char __data[0];
};

struct trace_event_raw_btrfs_insert_one_raid_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 logical;
	u64 length;
	int num_stripes;
	char __data[0];
};

struct trace_event_raw_btrfs_locking_events {
	struct trace_entry ent;
	u8 fsid[16];
	u64 block;
	u64 generation;
	u64 owner;
	int is_log_tree;
	char __data[0];
};

struct trace_event_raw_btrfs_qgroup_account_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 transid;
	u64 bytenr;
	u64 num_bytes;
	u64 nr_old_roots;
	u64 nr_new_roots;
	char __data[0];
};

struct trace_event_raw_btrfs_qgroup_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bytenr;
	u64 num_bytes;
	char __data[0];
};

struct trace_event_raw_btrfs_raid56_bio {
	struct trace_entry ent;
	u8 fsid[16];
	u64 full_stripe;
	u64 physical;
	u64 devid;
	u32 offset;
	u32 len;
	u8 opf;
	u8 total_stripes;
	u8 real_stripes;
	u8 nr_data;
	u8 stripe_nr;
	char __data[0];
};

struct trace_event_raw_btrfs_raid_extent_delete {
	struct trace_entry ent;
	u8 fsid[16];
	u64 start;
	u64 end;
	u64 found_start;
	u64 found_end;
	char __data[0];
};

struct trace_event_raw_btrfs_reserve_ticket {
	struct trace_entry ent;
	u8 fsid[16];
	u64 flags;
	u64 bytes;
	u64 start_ns;
	int flush;
	int error;
	char __data[0];
};

struct trace_event_raw_btrfs_set_extent_bit {
	struct trace_entry ent;
	u8 fsid[16];
	unsigned int owner;
	u64 ino;
	u64 rootid;
	u64 start;
	u64 len;
	unsigned int set_bits;
	char __data[0];
};

struct trace_event_raw_btrfs_setup_cluster {
	struct trace_entry ent;
	u8 fsid[16];
	u64 bg_objectid;
	u64 flags;
	u64 start;
	u64 max_size;
	u64 size;
	int bitmap;
	char __data[0];
};

struct trace_event_raw_btrfs_sleep_tree_lock {
	struct trace_entry ent;
	u8 fsid[16];
	u64 block;
	u64 generation;
	u64 start_ns;
	u64 end_ns;
	u64 diff_ns;
	u64 owner;
	int is_log_tree;
	char __data[0];
};

struct trace_event_raw_btrfs_space_reservation {
	struct trace_entry ent;
	u8 fsid[16];
	u32 __data_loc_type;
	u64 val;
	u64 bytes;
	int reserve;
	char __data[0];
};

struct trace_event_raw_btrfs_sync_file {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 parent;
	int datasync;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_sync_fs {
	struct trace_entry ent;
	u8 fsid[16];
	int wait;
	char __data[0];
};

struct trace_event_raw_btrfs_transaction_commit {
	struct trace_entry ent;
	u8 fsid[16];
	u64 generation;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_btrfs_trigger_flush {
	struct trace_entry ent;
	u8 fsid[16];
	u64 flags;
	u64 bytes;
	int flush;
	u32 __data_loc_reason;
	char __data[0];
};

struct trace_event_raw_btrfs_workqueue {
	struct trace_entry ent;
	u8 fsid[16];
	const void *wq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_btrfs_workqueue_done {
	struct trace_entry ent;
	u8 fsid[16];
	const void *wq;
	char __data[0];
};

struct trace_event_raw_btrfs_writepage_end_io_hook {
	struct trace_entry ent;
	u8 fsid[16];
	u64 ino;
	u64 start;
	u64 end;
	int uptodate;
	u64 root_objectid;
	char __data[0];
};

struct trace_event_raw_cache_event {
	struct trace_entry ent;
	const struct cache_head *h;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cache_tag_flush {
	struct trace_entry ent;
	u32 __data_loc_iommu;
	u32 __data_loc_dev;
	u16 type;
	u16 domain_id;
	u32 pasid;
	long unsigned int start;
	long unsigned int end;
	long unsigned int addr;
	long unsigned int pages;
	long unsigned int mask;
	char __data[0];
};

struct trace_event_raw_cache_tag_log {
	struct trace_entry ent;
	u32 __data_loc_iommu;
	u32 __data_loc_dev;
	u16 type;
	u16 domain_id;
	u32 pasid;
	u32 users;
	char __data[0];
};

struct trace_event_raw_cap_capable {
	struct trace_entry ent;
	const struct cred *cred;
	struct user_namespace *target_ns;
	const struct user_namespace *capable_ns;
	int cap;
	int ret;
	char __data[0];
};

struct trace_event_raw_cdev_update {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int target;
	char __data[0];
};

struct trace_event_raw_cgroup {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_cgroup_event {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	int val;
	char __data[0];
};

struct trace_event_raw_cgroup_migrate {
	struct trace_entry ent;
	int dst_root;
	int dst_level;
	u64 dst_id;
	int pid;
	u32 __data_loc_dst_path;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_cgroup_root {
	struct trace_entry ent;
	int root;
	u16 ss_mask;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cgroup_rstat {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	int cpu;
	bool contended;
	char __data[0];
};

struct trace_event_raw_clock {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_compact_retry {
	struct trace_entry ent;
	int order;
	int priority;
	int result;
	int retries;
	int max_retries;
	bool ret;
	char __data[0];
};

struct trace_event_raw_console {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_consume_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	char __data[0];
};

struct trace_event_raw_contention_begin {
	struct trace_entry ent;
	void *lock_addr;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_contention_end {
	struct trace_entry ent;
	void *lock_addr;
	int ret;
	char __data[0];
};

struct trace_event_raw_cpu {
	struct trace_entry ent;
	u32 state;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_frequency_limits {
	struct trace_entry ent;
	u32 min_freq;
	u32 max_freq;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_idle_miss {
	struct trace_entry ent;
	u32 cpu_id;
	u32 state;
	bool below;
	char __data[0];
};

struct trace_event_raw_cpu_latency_qos_request {
	struct trace_entry ent;
	s32 value;
	char __data[0];
};

struct trace_event_raw_cpuhp_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_exit {
	struct trace_entry ent;
	unsigned int cpu;
	int state;
	int idx;
	int ret;
	char __data[0];
};

struct trace_event_raw_cpuhp_multi_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_csd_function {
	struct trace_entry ent;
	void *func;
	void *csd;
	char __data[0];
};

struct trace_event_raw_csd_queue_cpu {
	struct trace_entry ent;
	unsigned int cpu;
	void *callsite;
	void *func;
	void *csd;
	char __data[0];
};

struct trace_event_raw_ctime {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	time64_t ctime_s;
	u32 ctime_ns;
	u32 gen;
	char __data[0];
};

struct trace_event_raw_ctime_ns_xchg {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	u32 gen;
	u32 old;
	u32 new;
	u32 cur;
	char __data[0];
};

struct trace_event_raw_dccp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 size;
	__u16 tx_s;
	__u32 tx_rtt;
	__u32 tx_p;
	__u32 tx_x_calc;
	__u64 tx_x_recv;
	__u64 tx_x;
	__u32 tx_t_ipi;
	char __data[0];
};

struct trace_event_raw_dev_pm_qos_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	enum dev_pm_qos_req_type type;
	s32 new_value;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_end {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	int error;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_start {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_parent;
	u32 __data_loc_pm_ops;
	int event;
	char __data[0];
};

struct trace_event_raw_devres {
	struct trace_entry ent;
	u32 __data_loc_devname;
	struct device *dev;
	const char *op;
	void *node;
	u32 __data_loc_name;
	size_t size;
	char __data[0];
};

struct trace_event_raw_dma_alloc_class {
	struct trace_entry ent;
	u32 __data_loc_device;
	void *virt_addr;
	u64 dma_addr;
	size_t size;
	gfp_t flags;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_alloc_sgt {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_phys_addrs;
	u64 dma_addr;
	size_t size;
	enum dma_data_direction dir;
	gfp_t flags;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_fence {
	struct trace_entry ent;
	u32 __data_loc_driver;
	u32 __data_loc_timeline;
	unsigned int context;
	unsigned int seqno;
	char __data[0];
};

struct trace_event_raw_dma_free_class {
	struct trace_entry ent;
	u32 __data_loc_device;
	void *virt_addr;
	u64 dma_addr;
	size_t size;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_free_sgt {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_phys_addrs;
	u64 dma_addr;
	size_t size;
	enum dma_data_direction dir;
	char __data[0];
};

struct trace_event_raw_dma_map {
	struct trace_entry ent;
	u32 __data_loc_device;
	u64 phys_addr;
	u64 dma_addr;
	size_t size;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_map_sg {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_phys_addrs;
	u32 __data_loc_dma_addrs;
	u32 __data_loc_lengths;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_map_sg_err {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_phys_addrs;
	int err;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_sync_sg {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_dma_addrs;
	u32 __data_loc_lengths;
	enum dma_data_direction dir;
	char __data[0];
};

struct trace_event_raw_dma_sync_single {
	struct trace_entry ent;
	u32 __data_loc_device;
	u64 dma_addr;
	size_t size;
	enum dma_data_direction dir;
	char __data[0];
};

struct trace_event_raw_dma_unmap {
	struct trace_entry ent;
	u32 __data_loc_device;
	u64 addr;
	size_t size;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dma_unmap_sg {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_addrs;
	enum dma_data_direction dir;
	long unsigned int attrs;
	char __data[0];
};

struct trace_event_raw_dql_stall_detected {
	struct trace_entry ent;
	short unsigned int thrs;
	unsigned int len;
	long unsigned int last_reap;
	long unsigned int hist_head;
	long unsigned int now;
	long unsigned int hist[4];
	char __data[0];
};

struct trace_event_raw_drm_vblank_event {
	struct trace_entry ent;
	int crtc;
	unsigned int seq;
	ktime_t time;
	bool high_prec;
	char __data[0];
};

struct trace_event_raw_drm_vblank_event_delivered {
	struct trace_entry ent;
	struct drm_file *file;
	int crtc;
	unsigned int seq;
	char __data[0];
};

struct trace_event_raw_drm_vblank_event_queued {
	struct trace_entry ent;
	struct drm_file *file;
	int crtc;
	unsigned int seq;
	char __data[0];
};

struct trace_event_raw_emulate_vsyscall {
	struct trace_entry ent;
	int nr;
	char __data[0];
};

struct trace_event_raw_error_report_template {
	struct trace_entry ent;
	enum error_detector error_detector;
	long unsigned int id;
	char __data[0];
};

struct trace_event_raw_exit_mmap {
	struct trace_entry ent;
	struct mm_struct *mm;
	struct maple_tree *mt;
	char __data[0];
};

struct trace_event_raw_ext4__bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4__es_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4__es_shrink_enter {
	struct trace_entry ent;
	dev_t dev;
	int nr_to_scan;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4__fallocate_mode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	int mode;
	char __data[0];
};

struct trace_event_raw_ext4__folio_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int flags;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int mflags;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__mb_new_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 pa_pstart;
	__u64 pa_lstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4__mballoc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4__trim {
	struct trace_entry ent;
	int dev_major;
	int dev_minor;
	__u32 group;
	int start;
	int len;
	char __data[0];
};

struct trace_event_raw_ext4__truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 blocks;
	char __data[0];
};

struct trace_event_raw_ext4__write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4__write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_ext4_alloc_da_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int data_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_begin_ordered_truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_ext4_collapse_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_da_release_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int freed_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int reserve_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_update_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int used_blocks;
	int reserved_data_blocks;
	int quota_claim;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int first_page;
	long int nr_to_write;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 lblk;
	__u32 len;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_ext4_discard_blocks {
	struct trace_entry ent;
	dev_t dev;
	__u64 blk;
	__u64 count;
	char __data[0];
};

struct trace_event_raw_ext4_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_drop_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int drop;
	char __data[0];
};

struct trace_event_raw_ext4_error {
	struct trace_entry ent;
	dev_t dev;
	const char *function;
	unsigned int line;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_insert_delayed_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	bool lclu_allocated;
	bool end_allocated;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	int found;
	char __data[0];
};

struct trace_event_raw_ext4_es_remove_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t lblk;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	long long unsigned int scan_time;
	int nr_skipped;
	int retried;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_evict_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int nlink;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_fastpath {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	ext4_lblk_t i_lblk;
	unsigned int i_len;
	ext4_fsblk_t i_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_handle_unwritten_extents {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	unsigned int allocated;
	ext4_fsblk_t newblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_load_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space_done {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	short unsigned int eh_entries;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_idx {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_leaf {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t ee_lblk;
	ext4_fsblk_t ee_pblk;
	short int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_show_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	short unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_fallocate_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_fc_cleanup {
	struct trace_entry ent;
	dev_t dev;
	int j_fc_off;
	int full;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_start {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_stop {
	struct trace_entry ent;
	dev_t dev;
	int nblks;
	int reason;
	int num_fc;
	int num_fc_ineligible;
	int nblks_agg;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay {
	struct trace_entry ent;
	dev_t dev;
	int tag;
	int ino;
	int priv1;
	int priv2;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay_scan {
	struct trace_entry ent;
	dev_t dev;
	int error;
	int off;
	char __data[0];
};

struct trace_event_raw_ext4_fc_stats {
	struct trace_entry ent;
	dev_t dev;
	unsigned int fc_ineligible_rc[10];
	long unsigned int fc_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_numblks;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_dentry {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_inode {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_range {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	long int start;
	long int end;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_forget {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	int is_metadata;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	long unsigned int count;
	int flags;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	uid_t uid;
	gid_t gid;
	__u64 blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u32 agno;
	u64 bno;
	u64 len;
	u64 owner;
	char __data[0];
};

struct trace_event_raw_ext4_get_implied_cluster_alloc_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u64 block;
	u64 len;
	u64 owner;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_ext4_insert_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_invalidate_folio_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	size_t offset;
	size_t length;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_inode {
	struct trace_entry ent;
	long unsigned int ino;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	int type;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_reserved {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_sb {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	int type;
	char __data[0];
};

struct trace_event_raw_ext4_lazy_itable_init {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_load_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_mark_inode_dirty {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_ext4_mb_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	int needed;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_group_pa {
	struct trace_entry ent;
	dev_t dev;
	__u64 pa_pstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_inode_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	__u32 count;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 goal_logical;
	int goal_start;
	__u32 goal_group;
	int goal_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	__u16 found;
	__u16 groups;
	__u16 buddy;
	__u16 flags;
	__u16 tail;
	__u8 cr;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_prealloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4_nfs_commit_metadata {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_other_inode_update_time {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t orig_ino;
	uid_t uid;
	gid_t gid;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_prefetch_bitmaps {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	__u32 next;
	__u32 ios;
	char __data[0];
};

struct trace_event_raw_ext4_read_block_bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	bool prefetch;
	char __data[0];
};

struct trace_event_raw_ext4_remove_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	ext4_fsblk_t ee_pblk;
	ext4_lblk_t ee_lblk;
	short unsigned int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_request_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_request_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int datasync;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int wait;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_update_sb {
	struct trace_entry ent;
	dev_t dev;
	ext4_fsblk_t fsblk;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	long unsigned int writeback_index;
	int sync_mode;
	char for_kupdate;
	char range_cyclic;
	char __data[0];
};

struct trace_event_raw_ext4_writepages_result {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	int pages_written;
	long int pages_skipped;
	long unsigned int writeback_index;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_fdb_delete {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_fib6_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u32 flowlabel;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[16];
	__u8 dst[16];
	u16 sport;
	u16 dport;
	u8 proto;
	u8 rt_type;
	char name[16];
	__u8 gw[16];
	char __data[0];
};

struct trace_event_raw_fib_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u8 proto;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[4];
	__u8 dst[4];
	__u8 gw4[4];
	__u8 gw6[16];
	u16 sport;
	u16 dport;
	char name[16];
	char __data[0];
};

struct trace_event_raw_file_check_and_advance_wb_err {
	struct trace_entry ent;
	struct file *file;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t old;
	errseq_t new;
	char __data[0];
};

struct trace_event_raw_filelock_lease {
	struct trace_entry ent;
	struct file_lease *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock_core *blocker;
	fl_owner_t owner;
	unsigned int flags;
	unsigned char type;
	long unsigned int break_time;
	long unsigned int downgrade_time;
	char __data[0];
};

struct trace_event_raw_filelock_lock {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock_core *blocker;
	fl_owner_t owner;
	unsigned int pid;
	unsigned int flags;
	unsigned char type;
	loff_t fl_start;
	loff_t fl_end;
	int ret;
	char __data[0];
};

struct trace_event_raw_filemap_set_wb_err {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t errseq;
	char __data[0];
};

struct trace_event_raw_fill_mg_cmtime {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	time64_t ctime_s;
	time64_t mtime_s;
	u32 ctime_ns;
	u32 mtime_ns;
	u32 gen;
	char __data[0];
};

struct trace_event_raw_find_free_extent {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 num_bytes;
	u64 empty_size;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_find_free_extent_have_block_group {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 num_bytes;
	u64 empty_size;
	u64 flags;
	u64 loop;
	bool hinted;
	u64 bg_start;
	u64 bg_flags;
	char __data[0];
};

struct trace_event_raw_find_free_extent_search_loop {
	struct trace_entry ent;
	u8 fsid[16];
	u64 root_objectid;
	u64 num_bytes;
	u64 empty_size;
	u64 flags;
	u64 loop;
	char __data[0];
};

struct trace_event_raw_finish_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_flush_foreign {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	unsigned int frn_bdi_id;
	unsigned int frn_memcg_id;
	char __data[0];
};

struct trace_event_raw_free_extent_state {
	struct trace_entry ent;
	const struct extent_state *state;
	const void *ip;
	char __data[0];
};

struct trace_event_raw_free_vmap_area_noflush {
	struct trace_entry ent;
	long unsigned int va_start;
	long unsigned int nr_lazy;
	long unsigned int nr_lazy_max;
	char __data[0];
};

struct trace_event_raw_fuse_request_end {
	struct trace_entry ent;
	dev_t connection;
	uint64_t unique;
	uint32_t len;
	int32_t error;
	char __data[0];
};

struct trace_event_raw_fuse_request_send {
	struct trace_entry ent;
	dev_t connection;
	uint64_t unique;
	enum fuse_opcode opcode;
	uint32_t len;
	char __data[0];
};

struct trace_event_raw_g4x_wm {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u16 primary;
	u16 sprite;
	u16 cursor;
	u16 sr_plane;
	u16 sr_cursor;
	u16 sr_fbc;
	u16 hpll_plane;
	u16 hpll_cursor;
	u16 hpll_fbc;
	bool cxsr;
	bool hpll;
	bool fbc;
	char __data[0];
};

struct trace_event_raw_generic_add_lease {
	struct trace_entry ent;
	long unsigned int i_ino;
	int wcount;
	int rcount;
	int icount;
	dev_t s_dev;
	fl_owner_t owner;
	unsigned int flags;
	unsigned char type;
	char __data[0];
};

struct trace_event_raw_global_dirty_state {
	struct trace_entry ent;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int background_thresh;
	long unsigned int dirty_thresh;
	long unsigned int dirty_limit;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	char __data[0];
};

struct trace_event_raw_guest_halt_poll_ns {
	struct trace_entry ent;
	bool grow;
	unsigned int new;
	unsigned int old;
	char __data[0];
};

struct trace_event_raw_handshake_alert_class {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	unsigned int netns_ino;
	long unsigned int level;
	long unsigned int description;
	char __data[0];
};

struct trace_event_raw_handshake_complete {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	int status;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_handshake_error_class {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	int err;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_handshake_event_class {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_handshake_fd_class {
	struct trace_entry ent;
	const void *req;
	const void *sk;
	int fd;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_hrtimer_class {
	struct trace_entry ent;
	void *hrtimer;
	char __data[0];
};

struct trace_event_raw_hrtimer_expire_entry {
	struct trace_entry ent;
	void *hrtimer;
	s64 now;
	void *function;
	char __data[0];
};

struct trace_event_raw_hrtimer_init {
	struct trace_entry ent;
	void *hrtimer;
	clockid_t clockid;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_start {
	struct trace_entry ent;
	void *hrtimer;
	void *function;
	s64 expires;
	s64 softexpires;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hugetlbfs__inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u16 mode;
	loff_t size;
	unsigned int nlink;
	unsigned int seals;
	blkcnt_t blocks;
	char __data[0];
};

struct trace_event_raw_hugetlbfs_alloc_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_hugetlbfs_fallocate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int mode;
	loff_t offset;
	loff_t len;
	loff_t size;
	int ret;
	char __data[0];
};

struct trace_event_raw_hugetlbfs_setattr {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int d_len;
	u32 __data_loc_d_name;
	unsigned int ia_valid;
	unsigned int ia_mode;
	loff_t old_size;
	loff_t ia_size;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_class {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	long int val;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_show_string {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	u32 __data_loc_label;
	char __data[0];
};

struct trace_event_raw_i2c_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	char __data[0];
};

struct trace_event_raw_i2c_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 nr_msgs;
	__s16 ret;
	char __data[0];
};

struct trace_event_raw_i2c_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i915_context {
	struct trace_entry ent;
	u32 dev;
	struct i915_gem_context *ctx;
	struct i915_address_space *vm;
	char __data[0];
};

struct trace_event_raw_i915_gem_evict {
	struct trace_entry ent;
	u32 dev;
	struct i915_address_space *vm;
	u64 size;
	u64 align;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_i915_gem_evict_node {
	struct trace_entry ent;
	u32 dev;
	struct i915_address_space *vm;
	u64 start;
	u64 size;
	long unsigned int color;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_i915_gem_evict_vm {
	struct trace_entry ent;
	u32 dev;
	struct i915_address_space *vm;
	char __data[0];
};

struct trace_event_raw_i915_gem_object {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	char __data[0];
};

struct trace_event_raw_i915_gem_object_create {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	u64 size;
	char __data[0];
};

struct trace_event_raw_i915_gem_object_fault {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	u64 index;
	bool gtt;
	bool write;
	char __data[0];
};

struct trace_event_raw_i915_gem_object_pread {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	u64 offset;
	u64 len;
	char __data[0];
};

struct trace_event_raw_i915_gem_object_pwrite {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	u64 offset;
	u64 len;
	char __data[0];
};

struct trace_event_raw_i915_gem_shrink {
	struct trace_entry ent;
	int dev;
	long unsigned int target;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_i915_ppgtt {
	struct trace_entry ent;
	struct i915_address_space *vm;
	u32 dev;
	char __data[0];
};

struct trace_event_raw_i915_reg_rw {
	struct trace_entry ent;
	u64 val;
	u32 reg;
	u16 write;
	u16 len;
	char __data[0];
};

struct trace_event_raw_i915_request {
	struct trace_entry ent;
	u32 dev;
	u64 ctx;
	u16 class;
	u16 instance;
	u32 seqno;
	u32 tail;
	char __data[0];
};

struct trace_event_raw_i915_request_queue {
	struct trace_entry ent;
	u32 dev;
	u64 ctx;
	u16 class;
	u16 instance;
	u32 seqno;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_i915_request_wait_begin {
	struct trace_entry ent;
	u32 dev;
	u64 ctx;
	u16 class;
	u16 instance;
	u32 seqno;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_i915_vma_bind {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	struct i915_address_space *vm;
	u64 offset;
	u64 size;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_i915_vma_unbind {
	struct trace_entry ent;
	struct drm_i915_gem_object *obj;
	struct i915_address_space *vm;
	u64 offset;
	u64 size;
	char __data[0];
};

struct trace_event_raw_icmp_send {
	struct trace_entry ent;
	const void *skbaddr;
	int type;
	int code;
	__u8 saddr[4];
	__u8 daddr[4];
	__u16 sport;
	__u16 dport;
	short unsigned int ulen;
	char __data[0];
};

struct trace_event_raw_inet_sk_error_report {
	struct trace_entry ent;
	int error;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_inet_sock_set_state {
	struct trace_entry ent;
	const void *skaddr;
	int oldstate;
	int newstate;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

typedef int (*initcall_t)(void);

struct trace_event_raw_initcall_finish {
	struct trace_entry ent;
	initcall_t func;
	int ret;
	char __data[0];
};

struct trace_event_raw_initcall_level {
	struct trace_entry ent;
	u32 __data_loc_level;
	char __data[0];
};

struct trace_event_raw_initcall_start {
	struct trace_entry ent;
	initcall_t func;
	char __data[0];
};

struct trace_event_raw_inode_foreign_history {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	ino_t cgroup_ino;
	unsigned int history;
	char __data[0];
};

struct trace_event_raw_inode_switch_wbs {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	ino_t old_cgroup_ino;
	ino_t new_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_intel_cpu_fifo_underrun {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_crtc_flip_done {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_crtc_vblank_work_end {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_crtc_vblank_work_start {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_fbc_activate {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_name;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_fbc_deactivate {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_name;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_fbc_nuke {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_name;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_frontbuffer_flush {
	struct trace_entry ent;
	u32 __data_loc_dev;
	unsigned int frontbuffer_bits;
	unsigned int origin;
	char __data[0];
};

struct trace_event_raw_intel_frontbuffer_invalidate {
	struct trace_entry ent;
	u32 __data_loc_dev;
	unsigned int frontbuffer_bits;
	unsigned int origin;
	char __data[0];
};

struct trace_event_raw_intel_memory_cxsr {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 frame[4];
	u32 scanline[4];
	bool old;
	bool new;
	char __data[0];
};

struct trace_event_raw_intel_pch_fifo_underrun {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_pipe_crc {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 crcs[5];
	char __data[0];
};

struct trace_event_raw_intel_pipe_disable {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 frame[4];
	u32 scanline[4];
	char pipe_name;
	char __data[0];
};

struct trace_event_raw_intel_pipe_enable {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 frame[4];
	u32 scanline[4];
	char pipe_name;
	char __data[0];
};

struct trace_event_raw_intel_pipe_update_end {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	char __data[0];
};

struct trace_event_raw_intel_pipe_update_start {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 min;
	u32 max;
	char __data[0];
};

struct trace_event_raw_intel_pipe_update_vblank_evaded {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 min;
	u32 max;
	char __data[0];
};

struct trace_event_raw_intel_plane_async_flip {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	bool async_flip;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_intel_plane_disable_arm {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_intel_plane_update_arm {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	int src[4];
	int dst[4];
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_intel_plane_update_noarm {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	int src[4];
	int dst[4];
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_io_uring_complete {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	int res;
	unsigned int cflags;
	u64 extra1;
	u64 extra2;
	char __data[0];
};

struct trace_event_raw_io_uring_cqe_overflow {
	struct trace_entry ent;
	void *ctx;
	long long unsigned int user_data;
	s32 res;
	u32 cflags;
	void *ocqe;
	char __data[0];
};

struct trace_event_raw_io_uring_cqring_wait {
	struct trace_entry ent;
	void *ctx;
	int min_events;
	char __data[0];
};

struct trace_event_raw_io_uring_create {
	struct trace_entry ent;
	int fd;
	void *ctx;
	u32 sq_entries;
	u32 cq_entries;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_io_uring_defer {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int data;
	u8 opcode;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_fail_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	void *link;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_file_get {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	int fd;
	char __data[0];
};

struct trace_event_raw_io_uring_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	void *target_req;
	char __data[0];
};

struct trace_event_raw_io_uring_local_work_run {
	struct trace_entry ent;
	void *ctx;
	int count;
	unsigned int loops;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_arm {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	int mask;
	int events;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_queue_async_work {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	u8 opcode;
	long long unsigned int flags;
	struct io_wq_work *work;
	int rw;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_register {
	struct trace_entry ent;
	void *ctx;
	unsigned int opcode;
	unsigned int nr_files;
	unsigned int nr_bufs;
	long int ret;
	char __data[0];
};

struct trace_event_raw_io_uring_req_failed {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	u8 flags;
	u8 ioprio;
	u64 off;
	u64 addr;
	u32 len;
	u32 op_flags;
	u16 buf_index;
	u16 personality;
	u32 file_index;
	u64 pad1;
	u64 addr3;
	int error;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_short_write {
	struct trace_entry ent;
	void *ctx;
	u64 fpos;
	u64 wanted;
	u64 got;
	char __data[0];
};

struct trace_event_raw_io_uring_submit_req {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	long long unsigned int flags;
	bool sq_thread;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_task_add {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	int mask;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_task_work_run {
	struct trace_entry ent;
	void *tctx;
	unsigned int count;
	char __data[0];
};

struct trace_event_raw_iocg_inuse_update {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u32 old_inuse;
	u32 new_inuse;
	u64 old_hweight_inuse;
	u64 new_hweight_inuse;
	char __data[0];
};

struct trace_event_raw_iocost_ioc_vrate_adj {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u64 old_vrate;
	u64 new_vrate;
	int busy_level;
	u32 read_missed_ppm;
	u32 write_missed_ppm;
	u32 rq_wait_pct;
	int nr_lagging;
	int nr_shortages;
	char __data[0];
};

struct trace_event_raw_iocost_iocg_forgive_debt {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u64 vnow;
	u32 usage_pct;
	u64 old_debt;
	u64 new_debt;
	u64 old_delay;
	u64 new_delay;
	char __data[0];
};

struct trace_event_raw_iocost_iocg_state {
	struct trace_entry ent;
	u32 __data_loc_devname;
	u32 __data_loc_cgroup;
	u64 now;
	u64 vnow;
	u64 vrate;
	u64 last_period;
	u64 cur_period;
	u64 vtime;
	u32 weight;
	u32 inuse;
	u64 hweight_active;
	u64 hweight_inuse;
	char __data[0];
};

struct trace_event_raw_iomap_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iomap_dio_complete {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t isize;
	loff_t pos;
	int ki_flags;
	bool aio;
	int error;
	ssize_t ret;
	char __data[0];
};

struct trace_event_raw_iomap_dio_rw_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t isize;
	loff_t pos;
	size_t count;
	size_t done_before;
	int ki_flags;
	unsigned int dio_flags;
	bool aio;
	char __data[0];
};

struct trace_event_raw_iomap_iter {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t pos;
	u64 length;
	s64 processed;
	unsigned int flags;
	const void *ops;
	long unsigned int caller;
	char __data[0];
};

struct trace_event_raw_iomap_range_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t size;
	loff_t offset;
	u64 length;
	char __data[0];
};

struct trace_event_raw_iomap_readpage_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	int nr_pages;
	char __data[0];
};

struct trace_event_raw_iomap_writepage_map {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	u64 pos;
	u64 dirty_len;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iommu_device_event {
	struct trace_entry ent;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_iommu_error {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u64 iova;
	int flags;
	char __data[0];
};

struct trace_event_raw_iommu_group_event {
	struct trace_entry ent;
	int gid;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_ipi_handler {
	struct trace_entry ent;
	const char *reason;
	char __data[0];
};

struct trace_event_raw_ipi_raise {
	struct trace_entry ent;
	u32 __data_loc_target_cpus;
	const char *reason;
	char __data[0];
};

struct trace_event_raw_ipi_send_cpu {
	struct trace_entry ent;
	unsigned int cpu;
	void *callsite;
	void *callback;
	char __data[0];
};

struct trace_event_raw_ipi_send_cpumask {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	void *callsite;
	void *callback;
	char __data[0];
};

struct trace_event_raw_irq_handler_entry {
	struct trace_entry ent;
	int irq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_irq_handler_exit {
	struct trace_entry ent;
	int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_irq_matrix_cpu {
	struct trace_entry ent;
	int bit;
	unsigned int cpu;
	bool online;
	unsigned int available;
	unsigned int allocated;
	unsigned int managed;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_raw_irq_matrix_global {
	struct trace_entry ent;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_raw_irq_matrix_global_update {
	struct trace_entry ent;
	int bit;
	unsigned int online_maps;
	unsigned int global_available;
	unsigned int global_reserved;
	unsigned int total_allocated;
	char __data[0];
};

struct trace_event_raw_itimer_expire {
	struct trace_entry ent;
	int which;
	pid_t pid;
	long long unsigned int now;
	char __data[0];
};

struct trace_event_raw_itimer_state {
	struct trace_entry ent;
	int which;
	long long unsigned int expires;
	long int value_sec;
	long int value_nsec;
	long int interval_sec;
	long int interval_nsec;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int result;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	long unsigned int chp_time;
	__u32 forced_to_close;
	__u32 written;
	__u32 dropped;
	char __data[0];
};

struct trace_event_raw_jbd2_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	tid_t transaction;
	char __data[0];
};

struct trace_event_raw_jbd2_end_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	tid_t transaction;
	tid_t head;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_extend {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int buffer_credits;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_start_class {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	unsigned int type;
	unsigned int line_no;
	int interval;
	int sync;
	int requested_blocks;
	int dirtied_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_journal_shrink {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int nr_to_scan;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_jbd2_lock_buffer_stall {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int stall_ms;
	char __data[0];
};

struct trace_event_raw_jbd2_run_stats {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	long unsigned int wait;
	long unsigned int request_delay;
	long unsigned int running;
	long unsigned int locked;
	long unsigned int flushing;
	long unsigned int logging;
	__u32 handle_count;
	__u32 blocks;
	__u32 blocks_logged;
	char __data[0];
};

struct trace_event_raw_jbd2_shrink_checkpoint_list {
	struct trace_entry ent;
	dev_t dev;
	tid_t first_tid;
	tid_t tid;
	tid_t last_tid;
	long unsigned int nr_freed;
	tid_t next_tid;
	char __data[0];
};

struct trace_event_raw_jbd2_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int nr_to_scan;
	long unsigned int nr_shrunk;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_jbd2_submit_inode_data {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_jbd2_update_log_tail {
	struct trace_entry ent;
	dev_t dev;
	tid_t tail_sequence;
	tid_t first_tid;
	long unsigned int block_nr;
	long unsigned int freed;
	char __data[0];
};

struct trace_event_raw_jbd2_write_superblock {
	struct trace_entry ent;
	dev_t dev;
	blk_opf_t write_flags;
	char __data[0];
};

struct trace_event_raw_kcompactd_wake_template {
	struct trace_entry ent;
	int nid;
	int order;
	enum zone_type highest_zoneidx;
	char __data[0];
};

struct trace_event_raw_kfree {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	char __data[0];
};

struct trace_event_raw_kfree_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	void *rx_sk;
	short unsigned int protocol;
	enum skb_drop_reason reason;
	char __data[0];
};

struct trace_event_raw_kmalloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	long unsigned int gfp_flags;
	int node;
	char __data[0];
};

struct trace_event_raw_kmem_cache_alloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	long unsigned int gfp_flags;
	int node;
	bool accounted;
	char __data[0];
};

struct trace_event_raw_kmem_cache_free {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_kyber_adjust {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	unsigned int depth;
	char __data[0];
};

struct trace_event_raw_kyber_latency {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char type[8];
	u8 percentile;
	u8 numerator;
	u8 denominator;
	unsigned int samples;
	char __data[0];
};

struct trace_event_raw_kyber_throttled {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char __data[0];
};

struct trace_event_raw_leases_conflict {
	struct trace_entry ent;
	void *lease;
	void *breaker;
	unsigned int l_fl_flags;
	unsigned int b_fl_flags;
	unsigned char l_fl_type;
	unsigned char b_fl_type;
	bool conflict;
	char __data[0];
};

struct trace_event_raw_locks_get_lock_context {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	unsigned char type;
	struct file_lock_context *ctx;
	char __data[0];
};

struct trace_event_raw_ma_op {
	struct trace_entry ent;
	const char *fn;
	long unsigned int min;
	long unsigned int max;
	long unsigned int index;
	long unsigned int last;
	void *node;
	char __data[0];
};

struct trace_event_raw_ma_read {
	struct trace_entry ent;
	const char *fn;
	long unsigned int min;
	long unsigned int max;
	long unsigned int index;
	long unsigned int last;
	void *node;
	char __data[0];
};

struct trace_event_raw_ma_write {
	struct trace_entry ent;
	const char *fn;
	long unsigned int min;
	long unsigned int max;
	long unsigned int index;
	long unsigned int last;
	long unsigned int piv;
	void *val;
	void *node;
	char __data[0];
};

struct trace_event_raw_map {
	struct trace_entry ent;
	u64 iova;
	u64 paddr;
	size_t size;
	char __data[0];
};

struct trace_event_raw_mark_victim {
	struct trace_entry ent;
	int pid;
	u32 __data_loc_comm;
	long unsigned int total_vm;
	long unsigned int anon_rss;
	long unsigned int file_rss;
	long unsigned int shmem_rss;
	uid_t uid;
	long unsigned int pgtables;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_mce_record {
	struct trace_entry ent;
	u64 mcgcap;
	u64 mcgstatus;
	u64 status;
	u64 addr;
	u64 misc;
	u64 synd;
	u64 ipid;
	u64 ip;
	u64 tsc;
	u64 ppin;
	u64 walltime;
	u32 cpu;
	u32 cpuid;
	u32 apicid;
	u32 socketid;
	u8 cs;
	u8 bank;
	u8 cpuvendor;
	u32 microcode;
	u32 __data_loc_v_data;
	char __data[0];
};

struct trace_event_raw_mdio_access {
	struct trace_entry ent;
	char busid[61];
	char read;
	u8 addr;
	u16 val;
	unsigned int regnum;
	char __data[0];
};

struct trace_event_raw_mei_pci_cfg_read {
	struct trace_entry ent;
	u32 __data_loc_dev;
	const char *reg;
	u32 offs;
	u32 val;
	char __data[0];
};

struct trace_event_raw_mei_reg_read {
	struct trace_entry ent;
	u32 __data_loc_dev;
	const char *reg;
	u32 offs;
	u32 val;
	char __data[0];
};

struct trace_event_raw_mei_reg_write {
	struct trace_entry ent;
	u32 __data_loc_dev;
	const char *reg;
	u32 offs;
	u32 val;
	char __data[0];
};

struct xdp_mem_allocator;

struct trace_event_raw_mem_connect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	const struct xdp_rxq_info *rxq;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_mem_disconnect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	char __data[0];
};

struct trace_event_raw_mem_return_failed {
	struct trace_entry ent;
	const struct page *page;
	u32 mem_id;
	u32 mem_type;
	char __data[0];
};

struct trace_event_raw_memcg_flush_stats {
	struct trace_entry ent;
	u64 id;
	s64 stats_updates;
	bool force;
	bool needs_flush;
	char __data[0];
};

struct trace_event_raw_memcg_rstat_events {
	struct trace_entry ent;
	u64 id;
	int item;
	long unsigned int val;
	char __data[0];
};

struct trace_event_raw_memcg_rstat_stats {
	struct trace_entry ent;
	u64 id;
	int item;
	int val;
	char __data[0];
};

struct trace_event_raw_migration_pte {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int pte;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_alloc_contig_migrate_range_info {
	struct trace_entry ent;
	long unsigned int start;
	long unsigned int end;
	long unsigned int nr_migrated;
	long unsigned int nr_reclaimed;
	long unsigned int nr_mapped;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_compaction_begin {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	char __data[0];
};

struct trace_event_raw_mm_compaction_defer_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	unsigned int considered;
	unsigned int defer_shift;
	int order_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_end {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_compaction_isolate_template {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int nr_scanned;
	long unsigned int nr_taken;
	char __data[0];
};

struct trace_event_raw_mm_compaction_kcompactd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_compaction_migratepages {
	struct trace_entry ent;
	long unsigned int nr_migrated;
	long unsigned int nr_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_suitable_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_compaction_try_to_compact_pages {
	struct trace_entry ent;
	int order;
	long unsigned int gfp_mask;
	int prio;
	char __data[0];
};

struct trace_event_raw_mm_filemap_fault {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_mm_filemap_op_page_cache {
	struct trace_entry ent;
	long unsigned int pfn;
	long unsigned int i_ino;
	long unsigned int index;
	dev_t s_dev;
	unsigned char order;
	char __data[0];
};

struct trace_event_raw_mm_filemap_op_page_cache_range {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	long unsigned int index;
	long unsigned int last_index;
	char __data[0];
};

struct trace_event_raw_mm_lru_activate {
	struct trace_entry ent;
	struct folio *folio;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_lru_insertion {
	struct trace_entry ent;
	struct folio *folio;
	long unsigned int pfn;
	enum lru_list lru;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_mm_migrate_pages {
	struct trace_entry ent;
	long unsigned int succeeded;
	long unsigned int failed;
	long unsigned int thp_succeeded;
	long unsigned int thp_failed;
	long unsigned int thp_split;
	long unsigned int large_folio_split;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_migrate_pages_start {
	struct trace_entry ent;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_page {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	int percpu_refill;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	long unsigned int gfp_flags;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc_extfrag {
	struct trace_entry ent;
	long unsigned int pfn;
	int alloc_order;
	int fallback_order;
	int alloc_migratetype;
	int fallback_migratetype;
	int change_ownership;
	char __data[0];
};

struct trace_event_raw_mm_page_free {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_mm_page_free_batched {
	struct trace_entry ent;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_page_pcpu_drain {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_end {
	struct trace_entry ent;
	struct shrinker *shr;
	int nid;
	void *shrink;
	long int unused_scan;
	long int new_scan;
	int retval;
	long int total_scan;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_start {
	struct trace_entry ent;
	struct shrinker *shr;
	void *shrink;
	int nid;
	long int nr_objects_to_shrink;
	long unsigned int gfp_flags;
	long unsigned int cache_items;
	long long unsigned int delta;
	long unsigned int total_scan;
	int priority;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
	struct trace_entry ent;
	int order;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
	struct trace_entry ent;
	long unsigned int nr_reclaimed;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_wake {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_isolate {
	struct trace_entry ent;
	int highest_zoneidx;
	int order;
	long unsigned int nr_requested;
	long unsigned int nr_scanned;
	long unsigned int nr_skipped;
	long unsigned int nr_taken;
	int lru;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_active {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_taken;
	long unsigned int nr_active;
	long unsigned int nr_deactivated;
	long unsigned int nr_referenced;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_node_reclaim_begin {
	struct trace_entry ent;
	int nid;
	int order;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_reclaim_pages {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_throttled {
	struct trace_entry ent;
	int nid;
	int usec_timeout;
	int usec_delayed;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_wakeup_kswapd {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_write_folio {
	struct trace_entry ent;
	long unsigned int pfn;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mmap_lock {
	struct trace_entry ent;
	struct mm_struct *mm;
	u64 memcg_id;
	bool write;
	char __data[0];
};

struct trace_event_raw_mmap_lock_acquire_returned {
	struct trace_entry ent;
	struct mm_struct *mm;
	u64 memcg_id;
	bool write;
	bool success;
	char __data[0];
};

struct trace_event_raw_module_free {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_load {
	struct trace_entry ent;
	unsigned int taints;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_refcnt {
	struct trace_entry ent;
	long unsigned int ip;
	int refcnt;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_request {
	struct trace_entry ent;
	long unsigned int ip;
	bool wait;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mptcp_dump_mpext {
	struct trace_entry ent;
	u64 data_ack;
	u64 data_seq;
	u32 subflow_seq;
	u16 data_len;
	u16 csum;
	u8 use_map;
	u8 dsn64;
	u8 data_fin;
	u8 use_ack;
	u8 ack64;
	u8 mpc_map;
	u8 frozen;
	u8 reset_transient;
	u8 reset_reason;
	u8 csum_reqd;
	u8 infinite_map;
	char __data[0];
};

struct trace_event_raw_mptcp_subflow_get_send {
	struct trace_entry ent;
	bool active;
	bool free;
	u32 snd_wnd;
	u32 pace;
	u8 backup;
	u64 ratio;
	char __data[0];
};

struct trace_event_raw_msr_trace_class {
	struct trace_entry ent;
	unsigned int msr;
	u64 val;
	int failed;
	char __data[0];
};

struct trace_event_raw_napi_poll {
	struct trace_entry ent;
	struct napi_struct *napi;
	u32 __data_loc_dev_name;
	int work;
	int budget;
	char __data[0];
};

struct trace_event_raw_neigh__update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u32 err;
	char __data[0];
};

struct trace_event_raw_neigh_create {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	int entries;
	u8 created;
	u8 gc_exempt;
	u8 primary_key4[4];
	u8 primary_key6[16];
	char __data[0];
};

struct trace_event_raw_neigh_update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u8 new_lladdr[32];
	u8 new_state;
	u32 update_flags;
	u32 pid;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_exit_template {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_verbose_template {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int napi_id;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	u32 hash;
	bool l4_hash;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	bool mac_header_valid;
	int mac_header;
	unsigned char nr_frags;
	u16 gso_size;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_start_xmit {
	struct trace_entry ent;
	u32 __data_loc_name;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	unsigned int len;
	unsigned int data_len;
	int network_offset;
	bool transport_offset_valid;
	int transport_offset;
	u8 tx_flags;
	u16 gso_size;
	u16 gso_segs;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_template {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	int rc;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit_timeout {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_driver;
	int queue_index;
	char __data[0];
};

struct trace_event_raw_netfs_collect {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned int len;
	long long unsigned int transferred;
	long long unsigned int start;
	char __data[0];
};

struct trace_event_raw_netfs_collect_folio {
	struct trace_entry ent;
	unsigned int wreq;
	long unsigned int index;
	long long unsigned int fend;
	long long unsigned int cleaned_to;
	long long unsigned int collected_to;
	char __data[0];
};

struct trace_event_raw_netfs_collect_gap {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned char stream;
	unsigned char type;
	long long unsigned int from;
	long long unsigned int to;
	char __data[0];
};

struct trace_event_raw_netfs_collect_sreq {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned int subreq;
	unsigned int stream;
	unsigned int len;
	unsigned int transferred;
	long long unsigned int start;
	char __data[0];
};

struct trace_event_raw_netfs_collect_state {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned int notes;
	long long unsigned int collected_to;
	long long unsigned int cleaned_to;
	char __data[0];
};

struct trace_event_raw_netfs_collect_stream {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned char stream;
	long long unsigned int collected_to;
	long long unsigned int front;
	char __data[0];
};

struct trace_event_raw_netfs_failure {
	struct trace_entry ent;
	unsigned int rreq;
	short int index;
	short int error;
	short unsigned int flags;
	enum netfs_io_source source;
	enum netfs_failure what;
	size_t len;
	size_t transferred;
	loff_t start;
	char __data[0];
};

struct trace_event_raw_netfs_folio {
	struct trace_entry ent;
	ino_t ino;
	long unsigned int index;
	unsigned int nr;
	enum netfs_folio_trace why;
	char __data[0];
};

struct trace_event_raw_netfs_folioq {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int id;
	enum netfs_folioq_trace trace;
	char __data[0];
};

struct trace_event_raw_netfs_read {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int cookie;
	loff_t i_size;
	loff_t start;
	size_t len;
	enum netfs_read_trace what;
	unsigned int netfs_inode;
	char __data[0];
};

struct trace_event_raw_netfs_rreq {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int flags;
	enum netfs_io_origin origin;
	enum netfs_rreq_trace what;
	char __data[0];
};

struct trace_event_raw_netfs_rreq_ref {
	struct trace_entry ent;
	unsigned int rreq;
	int ref;
	enum netfs_rreq_ref_trace what;
	char __data[0];
};

struct trace_event_raw_netfs_sreq {
	struct trace_entry ent;
	unsigned int rreq;
	short unsigned int index;
	short int error;
	short unsigned int flags;
	enum netfs_io_source source;
	enum netfs_sreq_trace what;
	u8 slot;
	size_t len;
	size_t transferred;
	loff_t start;
	char __data[0];
};

struct trace_event_raw_netfs_sreq_ref {
	struct trace_entry ent;
	unsigned int rreq;
	unsigned int subreq;
	int ref;
	enum netfs_sreq_ref_trace what;
	char __data[0];
};

struct trace_event_raw_netfs_write {
	struct trace_entry ent;
	unsigned int wreq;
	unsigned int cookie;
	unsigned int ino;
	enum netfs_write_trace what;
	long long unsigned int start;
	long long unsigned int len;
	char __data[0];
};

struct trace_event_raw_netfs_write_iter {
	struct trace_entry ent;
	long long unsigned int start;
	size_t len;
	unsigned int flags;
	unsigned int ino;
	char __data[0];
};

struct trace_event_raw_netlink_extack {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_nfs4_cached_open {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_error_class {
	struct trace_entry ent;
	u32 xid;
	u32 cbident;
	char __data[0];
};

struct trace_event_raw_nfs4_clientid_event {
	struct trace_entry ent;
	u32 __data_loc_dstaddr;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_close {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_commit_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	loff_t offset;
	u32 count;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_delegreturn_exit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_getattr_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int valid;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_idmap_event {
	struct trace_entry ent;
	long unsigned int error;
	u32 id;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_callback_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_stateid_callback_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 __data_loc_dstaddr;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_stateid_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lock_event {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int cmd;
	long unsigned int type;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lookup_event {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs4_lookupp {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_open_event {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	long unsigned int fmode;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	int stateid_seq;
	u32 stateid_hash;
	int openstateid_seq;
	u32 openstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_read_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_rename {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 olddir;
	u32 __data_loc_oldname;
	u64 newdir;
	u32 __data_loc_newname;
	char __data[0];
};

struct trace_event_raw_nfs4_set_delegation_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	char __data[0];
};

struct trace_event_raw_nfs4_set_lock {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int cmd;
	long unsigned int type;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	int lockstateid_seq;
	u32 lockstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_setup_sequence {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_used_slotid;
	char __data[0];
};

struct trace_event_raw_nfs4_state_lock_reclaim {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int state_flags;
	long unsigned int lock_flags;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_hostname;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr_failed {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int state;
	u32 __data_loc_hostname;
	u32 __data_loc_section;
	char __data[0];
};

struct trace_event_raw_nfs4_write_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_xdr_bad_operation {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 op;
	u32 expected;
	char __data[0];
};

struct trace_event_raw_nfs4_xdr_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 op;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs_access_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	unsigned int mask;
	unsigned int permitted;
	char __data[0];
};

struct trace_event_raw_nfs_aop_readahead {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t offset;
	unsigned int nr_pages;
	char __data[0];
};

struct trace_event_raw_nfs_aop_readahead_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	int ret;
	u64 fileid;
	u64 version;
	loff_t offset;
	unsigned int nr_pages;
	char __data[0];
};

struct trace_event_raw_nfs_atomic_open_enter {
	struct trace_entry ent;
	long unsigned int flags;
	long unsigned int fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_atomic_open_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	long unsigned int fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_commit_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	int error;
	long unsigned int stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_create_enter {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_create_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_direct_req_class {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u32 fhandle;
	loff_t offset;
	ssize_t count;
	ssize_t error;
	int flags;
	char __data[0];
};

struct trace_event_raw_nfs_directory_event {
	struct trace_entry ent;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_directory_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_fh_to_dentry {
	struct trace_entry ent;
	int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	char __data[0];
};

struct trace_event_raw_nfs_folio_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t offset;
	size_t count;
	char __data[0];
};

struct trace_event_raw_nfs_folio_event_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	int ret;
	u64 fileid;
	u64 version;
	loff_t offset;
	size_t count;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_commit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_read {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_write {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	long unsigned int stable;
	char __data[0];
};

struct trace_event_raw_nfs_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char __data[0];
};

struct trace_event_raw_nfs_inode_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	char __data[0];
};

struct trace_event_raw_nfs_inode_range_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t range_start;
	loff_t range_end;
	char __data[0];
};

struct trace_event_raw_nfs_link_enter {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_link_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_local_open_fh {
	struct trace_entry ent;
	int error;
	u32 fhandle;
	unsigned int fmode;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u64 fileid;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event_done {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u64 fileid;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_mount_assign {
	struct trace_entry ent;
	u32 __data_loc_option;
	u32 __data_loc_value;
	char __data[0];
};

struct trace_event_raw_nfs_mount_option {
	struct trace_entry ent;
	u32 __data_loc_option;
	char __data[0];
};

struct trace_event_raw_nfs_mount_path {
	struct trace_entry ent;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_nfs_page_error_class {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	unsigned int count;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_pgio_error {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	loff_t pos;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_readdir_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char verifier[8];
	u64 cookie;
	long unsigned int index;
	unsigned int dtsize;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_short {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event {
	struct trace_entry ent;
	dev_t dev;
	u64 old_dir;
	u64 new_dir;
	u32 __data_loc_old_name;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event_done {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 old_dir;
	u32 __data_loc_old_name;
	u64 new_dir;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_sillyrename_unlink {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_update_size_class {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t cur_size;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_nfs_writeback_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	int error;
	long unsigned int stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_xdr_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	long unsigned int error;
	u32 __data_loc_program;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_nlmclnt_lock_event {
	struct trace_entry ent;
	u32 oh;
	u32 svid;
	u32 fh;
	long unsigned int status;
	u64 start;
	u64 len;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_nmi_handler {
	struct trace_entry ent;
	void *handler;
	s64 delta_ns;
	int handled;
	char __data[0];
};

struct trace_event_raw_notifier_info {
	struct trace_entry ent;
	void *cb;
	char __data[0];
};

struct trace_event_raw_nvme_async_event {
	struct trace_entry ent;
	int ctrl_id;
	u32 result;
	char __data[0];
};

struct trace_event_raw_nvme_complete_rq {
	struct trace_entry ent;
	char disk[32];
	int ctrl_id;
	int qid;
	int cid;
	u64 result;
	u8 retries;
	u8 flags;
	u16 status;
	char __data[0];
};

struct trace_event_raw_nvme_setup_cmd {
	struct trace_entry ent;
	char disk[32];
	int ctrl_id;
	int qid;
	u8 opcode;
	u8 flags;
	u8 fctype;
	u16 cid;
	u32 nsid;
	bool metadata;
	u8 cdw10[24];
	char __data[0];
};

struct trace_event_raw_nvme_sq {
	struct trace_entry ent;
	int ctrl_id;
	char disk[32];
	int qid;
	u16 sq_head;
	u16 sq_tail;
	char __data[0];
};

struct trace_event_raw_oom_score_adj_update {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_ovs_do_execute_action {
	struct trace_entry ent;
	void *dpaddr;
	u32 __data_loc_dp_name;
	u32 __data_loc_dev_name;
	void *skbaddr;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	u8 nr_frags;
	u16 gso_size;
	u16 gso_type;
	u32 ovs_flow_hash;
	u32 recirc_id;
	void *keyaddr;
	u16 key_eth_type;
	u8 key_ct_state;
	u8 key_ct_orig_proto;
	u16 key_ct_zone;
	unsigned int flow_key_valid;
	u8 action_type;
	unsigned int action_len;
	void *action_data;
	u8 is_last;
	char __data[0];
};

struct trace_event_raw_ovs_dp_upcall {
	struct trace_entry ent;
	void *dpaddr;
	u32 __data_loc_dp_name;
	u32 __data_loc_dev_name;
	void *skbaddr;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	u8 nr_frags;
	u16 gso_size;
	u16 gso_type;
	u32 ovs_flow_hash;
	u32 recirc_id;
	const void *keyaddr;
	u16 key_eth_type;
	u8 key_ct_state;
	u8 key_ct_orig_proto;
	u16 key_ct_zone;
	unsigned int flow_key_valid;
	u8 upcall_cmd;
	u32 upcall_port;
	u16 upcall_mru;
	char __data[0];
};

struct trace_event_raw_page_pool_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	s32 inflight;
	u32 hold;
	u32 release;
	u64 cnt;
	char __data[0];
};

struct trace_event_raw_page_pool_state_hold {
	struct trace_entry ent;
	const struct page_pool *pool;
	long unsigned int netmem;
	u32 hold;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_state_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	long unsigned int netmem;
	u32 release;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_update_nid {
	struct trace_entry ent;
	const struct page_pool *pool;
	int pool_nid;
	int new_nid;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu {
	struct trace_entry ent;
	long unsigned int call_site;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	void *base_addr;
	int off;
	void *ptr;
	size_t bytes_alloc;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu_fail {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	char __data[0];
};

struct trace_event_raw_percpu_create_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_destroy_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_free_percpu {
	struct trace_entry ent;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_pm_qos_update {
	struct trace_entry ent;
	enum pm_qos_req_action action;
	int prev_value;
	int curr_value;
	char __data[0];
};

struct trace_event_raw_pmap_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int port;
	char __data[0];
};

struct trace_event_raw_power_domain {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_powernv_throttle {
	struct trace_entry ent;
	int chip_id;
	u32 __data_loc_reason;
	int pmax;
	char __data[0];
};

struct trace_event_raw_prq_report {
	struct trace_entry ent;
	u64 dw0;
	u64 dw1;
	u64 dw2;
	u64 dw3;
	long unsigned int seq;
	u32 __data_loc_iommu;
	u32 __data_loc_dev;
	u32 __data_loc_buff;
	char __data[0];
};

struct trace_event_raw_pstate_sample {
	struct trace_entry ent;
	u32 core_busy;
	u32 scaled_busy;
	u32 from;
	u32 to;
	u64 mperf;
	u64 aperf;
	u64 tsc;
	u32 freq;
	u32 io_boost;
	char __data[0];
};

struct trace_event_raw_purge_vmap_area_lazy {
	struct trace_entry ent;
	long unsigned int start;
	long unsigned int end;
	unsigned int npurged;
	char __data[0];
};

struct trace_event_raw_qdisc_create {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	char __data[0];
};

struct trace_event_raw_qdisc_dequeue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	int packets;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	long unsigned int txq_state;
	char __data[0];
};

struct trace_event_raw_qdisc_destroy {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_enqueue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	char __data[0];
};

struct trace_event_raw_qdisc_reset {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qgroup_meta_convert {
	struct trace_entry ent;
	u8 fsid[16];
	u64 refroot;
	s64 diff;
	char __data[0];
};

struct trace_event_raw_qgroup_meta_free_all_pertrans {
	struct trace_entry ent;
	u8 fsid[16];
	u64 refroot;
	s64 diff;
	int type;
	char __data[0];
};

struct trace_event_raw_qgroup_meta_reserve {
	struct trace_entry ent;
	u8 fsid[16];
	u64 refroot;
	s64 diff;
	int type;
	char __data[0];
};

struct trace_event_raw_qgroup_num_dirty_extents {
	struct trace_entry ent;
	u8 fsid[16];
	u64 transid;
	u64 num_dirty_extents;
	char __data[0];
};

struct trace_event_raw_qgroup_update_counters {
	struct trace_entry ent;
	u8 fsid[16];
	u64 qgid;
	u64 old_rfer;
	u64 old_excl;
	u64 cur_old_count;
	u64 cur_new_count;
	char __data[0];
};

struct trace_event_raw_qgroup_update_reserve {
	struct trace_entry ent;
	u8 fsid[16];
	u64 qgid;
	u64 cur_reserved;
	s64 diff;
	int type;
	char __data[0];
};

struct trace_event_raw_qi_submit {
	struct trace_entry ent;
	u64 qw0;
	u64 qw1;
	u64 qw2;
	u64 qw3;
	u32 __data_loc_iommu;
	char __data[0];
};

struct trace_event_raw_rcu_barrier {
	struct trace_entry ent;
	const char *rcuname;
	const char *s;
	int cpu;
	int cnt;
	long unsigned int done;
	char __data[0];
};

struct trace_event_raw_rcu_batch_end {
	struct trace_entry ent;
	const char *rcuname;
	int callbacks_invoked;
	char cb;
	char nr;
	char iit;
	char risk;
	char __data[0];
};

struct trace_event_raw_rcu_batch_start {
	struct trace_entry ent;
	const char *rcuname;
	long int qlen;
	long int blimit;
	char __data[0];
};

struct trace_event_raw_rcu_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	void *func;
	long int qlen;
	char __data[0];
};

struct trace_event_raw_rcu_exp_funnel_lock {
	struct trace_entry ent;
	const char *rcuname;
	u8 level;
	int grplo;
	int grphi;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_exp_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gpseq;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_fqs {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int cpu;
	const char *qsevent;
	char __data[0];
};

struct trace_event_raw_rcu_future_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	long int gp_seq_req;
	u8 level;
	int grplo;
	int grphi;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_grace_period_init {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	u8 level;
	int grplo;
	int grphi;
	long unsigned int qsmask;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	void *func;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_kfree_bulk_callback {
	struct trace_entry ent;
	const char *rcuname;
	long unsigned int nr_records;
	void **p;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_kvfree_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	long unsigned int offset;
	char __data[0];
};

struct trace_event_raw_rcu_kvfree_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	long unsigned int offset;
	long int qlen;
	char __data[0];
};

struct trace_event_raw_rcu_preempt_task {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int pid;
	char __data[0];
};

struct trace_event_raw_rcu_quiescent_state_report {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	long unsigned int mask;
	long unsigned int qsmask;
	u8 level;
	int grplo;
	int grphi;
	u8 gp_tasks;
	char __data[0];
};

struct trace_event_raw_rcu_segcb_stats {
	struct trace_entry ent;
	const char *ctx;
	long unsigned int gp_seq[4];
	long int seglen[4];
	char __data[0];
};

struct trace_event_raw_rcu_sr_normal {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	const char *srevent;
	char __data[0];
};

struct trace_event_raw_rcu_stall_warning {
	struct trace_entry ent;
	const char *rcuname;
	const char *msg;
	char __data[0];
};

struct trace_event_raw_rcu_torture_read {
	struct trace_entry ent;
	char rcutorturename[8];
	struct callback_head *rhp;
	long unsigned int secs;
	long unsigned int c_old;
	long unsigned int c;
	char __data[0];
};

struct trace_event_raw_rcu_unlock_preempted_task {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int pid;
	char __data[0];
};

struct trace_event_raw_rcu_utilization {
	struct trace_entry ent;
	const char *s;
	char __data[0];
};

struct trace_event_raw_rcu_watching {
	struct trace_entry ent;
	const char *polarity;
	long int oldnesting;
	long int newnesting;
	int counter;
	char __data[0];
};

struct trace_event_raw_reclaim_retry_zone {
	struct trace_entry ent;
	int node;
	int zone_idx;
	int order;
	long unsigned int reclaimable;
	long unsigned int available;
	long unsigned int min_wmark;
	int no_progress_loops;
	bool wmark_check;
	char __data[0];
};

struct trace_event_raw_register_class {
	struct trace_entry ent;
	u32 version;
	long unsigned int family;
	short unsigned int protocol;
	short unsigned int port;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_raw_register_session {
	struct trace_entry ent;
	char name[32];
	u32 tid;
	u32 ptid;
	u32 sid;
	u32 psid;
	enum l2tp_pwtype pwtype;
	char __data[0];
};

struct trace_event_raw_register_tunnel {
	struct trace_entry ent;
	char name[20];
	int fd;
	u32 tid;
	u32 ptid;
	int version;
	enum l2tp_encap_type encap;
	char __data[0];
};

struct trace_event_raw_rpc_buf_alloc {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	size_t callsize;
	size_t recvsize;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_call_rpcerror {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int tk_status;
	int rpc_status;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_class {
	struct trace_entry ent;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_clone_err {
	struct trace_entry ent;
	unsigned int client_id;
	int error;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new {
	struct trace_entry ent;
	unsigned int client_id;
	long unsigned int xprtsec;
	long unsigned int flags;
	u32 __data_loc_program;
	u32 __data_loc_server;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new_err {
	struct trace_entry ent;
	int error;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_failure {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_reply_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 __data_loc_progname;
	u32 version;
	u32 __data_loc_procname;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpc_request {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	bool async;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_rpc_socket_nospace {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int total;
	unsigned int remaining;
	char __data[0];
};

struct trace_event_raw_rpc_stats_latency {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	long unsigned int backlog;
	long unsigned int rtt;
	long unsigned int execute;
	u32 xprt_id;
	char __data[0];
};

struct trace_event_raw_rpc_task_queued {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	long unsigned int timeout;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	u32 __data_loc_q_name;
	char __data[0];
};

struct trace_event_raw_rpc_task_running {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *action;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	char __data[0];
};

struct trace_event_raw_rpc_task_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_tls_class {
	struct trace_entry ent;
	long unsigned int requested_policy;
	u32 version;
	u32 __data_loc_servername;
	u32 __data_loc_progname;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_alignment {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t offset;
	unsigned int copied;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_buf_class {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_overflow {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t requested;
	const void *end;
	const void *p;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_event {
	struct trace_entry ent;
	u32 xid;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_lifetime_class {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpcb_getport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int bind_version;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpcb_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_addr;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_rpcb_setport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	short unsigned int port;
	char __data[0];
};

struct trace_event_raw_rpcb_unregister {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_rpcgss_bad_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 expected;
	u32 received;
	char __data[0];
};

struct trace_event_raw_rpcgss_context {
	struct trace_entry ent;
	long unsigned int expiry;
	long unsigned int now;
	unsigned int timeout;
	u32 window_size;
	int len;
	u32 __data_loc_acceptor;
	char __data[0];
};

struct trace_event_raw_rpcgss_createauth {
	struct trace_entry ent;
	unsigned int flavor;
	int error;
	char __data[0];
};

struct trace_event_raw_rpcgss_ctx_class {
	struct trace_entry ent;
	const void *cred;
	long unsigned int service;
	u32 __data_loc_principal;
	char __data[0];
};

struct trace_event_raw_rpcgss_gssapi_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 maj_stat;
	char __data[0];
};

struct trace_event_raw_rpcgss_import_ctx {
	struct trace_entry ent;
	int status;
	char __data[0];
};

struct trace_event_raw_rpcgss_need_reencode {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seq_xmit;
	u32 seqno;
	bool ret;
	char __data[0];
};

struct trace_event_raw_rpcgss_oid_to_mech {
	struct trace_entry ent;
	u32 __data_loc_oid;
	char __data[0];
};

struct trace_event_raw_rpcgss_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_accept_upcall {
	struct trace_entry ent;
	u32 minor_status;
	long unsigned int major_status;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_authenticate {
	struct trace_entry ent;
	u32 seqno;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_gssapi_class {
	struct trace_entry ent;
	u32 xid;
	u32 maj_stat;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_bad {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_class {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_low {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	u32 min;
	u32 max;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_unwrap_failed {
	struct trace_entry ent;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_wrap_failed {
	struct trace_entry ent;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_unwrap_failed {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_result {
	struct trace_entry ent;
	u32 uid;
	int result;
	char __data[0];
};

struct trace_event_raw_rpcgss_update_slack {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	const void *auth;
	unsigned int rslack;
	unsigned int ralign;
	unsigned int verfsize;
	char __data[0];
};

struct trace_event_raw_rpm_internal {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flags;
	int usage_count;
	int disable_depth;
	int runtime_auto;
	int request_pending;
	int irq_safe;
	int child_count;
	char __data[0];
};

struct trace_event_raw_rpm_return_int {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int ip;
	int ret;
	char __data[0];
};

struct trace_event_raw_rpm_status {
	struct trace_entry ent;
	u32 __data_loc_name;
	int status;
	char __data[0];
};

struct trace_event_raw_rseq_ip_fixup {
	struct trace_entry ent;
	long unsigned int regs_ip;
	long unsigned int start_ip;
	long unsigned int post_commit_offset;
	long unsigned int abort_ip;
	char __data[0];
};

struct trace_event_raw_rseq_update {
	struct trace_entry ent;
	s32 cpu_id;
	s32 node_id;
	s32 mm_cid;
	char __data[0];
};

struct trace_event_raw_rss_stat {
	struct trace_entry ent;
	unsigned int mm_id;
	unsigned int curr;
	int member;
	long int size;
	char __data[0];
};

struct trace_event_raw_rtc_alarm_irq_enable {
	struct trace_entry ent;
	unsigned int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_freq {
	struct trace_entry ent;
	int freq;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_state {
	struct trace_entry ent;
	int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_offset_class {
	struct trace_entry ent;
	long int offset;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_time_alarm_class {
	struct trace_entry ent;
	time64_t secs;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_timer_class {
	struct trace_entry ent;
	struct rtc_timer *timer;
	ktime_t expires;
	ktime_t period;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop_ret {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *worker;
	char __data[0];
};

struct trace_event_raw_sched_migrate_task {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int orig_cpu;
	int dest_cpu;
	char __data[0];
};

struct trace_event_raw_sched_move_numa {
	struct trace_entry ent;
	pid_t pid;
	pid_t tgid;
	pid_t ngid;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_numa_pair_template {
	struct trace_entry ent;
	pid_t src_pid;
	pid_t src_tgid;
	pid_t src_ngid;
	int src_cpu;
	int src_nid;
	pid_t dst_pid;
	pid_t dst_tgid;
	pid_t dst_ngid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_pi_setprio {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int oldprio;
	int newprio;
	char __data[0];
};

struct trace_event_raw_sched_prepare_exec {
	struct trace_entry ent;
	u32 __data_loc_interp;
	u32 __data_loc_filename;
	pid_t pid;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_sched_process_exec {
	struct trace_entry ent;
	u32 __data_loc_filename;
	pid_t pid;
	pid_t old_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_fork {
	struct trace_entry ent;
	char parent_comm[16];
	pid_t parent_pid;
	char child_comm[16];
	pid_t child_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_wait {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_stat_runtime {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 runtime;
	char __data[0];
};

struct trace_event_raw_sched_stat_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 delay;
	char __data[0];
};

struct trace_event_raw_sched_switch {
	struct trace_entry ent;
	char prev_comm[16];
	pid_t prev_pid;
	int prev_prio;
	long int prev_state;
	char next_comm[16];
	pid_t next_pid;
	int next_prio;
	char __data[0];
};

struct trace_event_raw_sched_wake_idle_without_ipi {
	struct trace_entry ent;
	int cpu;
	char __data[0];
};

struct trace_event_raw_sched_wakeup_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int target_cpu;
	char __data[0];
};

struct trace_event_raw_scsi_cmd_done_timeout_template {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int result;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_error {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int rtn;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_start {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_eh_wakeup {
	struct trace_entry ent;
	unsigned int host_no;
	char __data[0];
};

struct trace_event_raw_sctp_probe {
	struct trace_entry ent;
	__u64 asoc;
	__u32 mark;
	__u16 bind_port;
	__u16 peer_port;
	__u32 pathmtu;
	__u32 rwnd;
	__u16 unack_data;
	char __data[0];
};

struct trace_event_raw_sctp_probe_path {
	struct trace_entry ent;
	__u64 asoc;
	__u32 primary;
	__u8 ipaddr[28];
	__u32 state;
	__u32 cwnd;
	__u32 ssthresh;
	__u32 flight_size;
	__u32 partial_bytes_acked;
	__u32 pathmtu;
	char __data[0];
};

struct trace_event_raw_session_only_evt {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_session_pkt_discard_evt {
	struct trace_entry ent;
	char name[32];
	u32 pkt_ns;
	u32 my_nr;
	u32 reorder_q_len;
	char __data[0];
};

struct trace_event_raw_session_seqnum_evt {
	struct trace_entry ent;
	char name[32];
	u32 ns;
	u32 nr;
	char __data[0];
};

struct trace_event_raw_signal_deliver {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	long unsigned int sa_handler;
	long unsigned int sa_flags;
	char __data[0];
};

struct trace_event_raw_signal_generate {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	char comm[16];
	pid_t pid;
	int group;
	int result;
	char __data[0];
};

struct trace_event_raw_sk_data_ready {
	struct trace_entry ent;
	const void *skaddr;
	__u16 family;
	__u16 protocol;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_skb_copy_datagram_iovec {
	struct trace_entry ent;
	const void *skbaddr;
	int len;
	char __data[0];
};

struct trace_event_raw_skip_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_smbus_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 flags;
	__u16 addr;
	__u8 command;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 read_write;
	__u8 command;
	__s16 res;
	__u32 protocol;
	char __data[0];
};

struct trace_event_raw_smbus_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_sock_exceed_buf_limit {
	struct trace_entry ent;
	char name[32];
	long int sysctl_mem[3];
	long int allocated;
	int sysctl_rmem;
	int rmem_alloc;
	int sysctl_wmem;
	int wmem_alloc;
	int wmem_queued;
	int kind;
	char __data[0];
};

struct trace_event_raw_sock_msg_length {
	struct trace_entry ent;
	void *sk;
	__u16 family;
	__u16 protocol;
	int ret;
	int flags;
	char __data[0];
};

struct trace_event_raw_sock_rcvqueue_full {
	struct trace_entry ent;
	int rmem_alloc;
	unsigned int truesize;
	int sk_rcvbuf;
	char __data[0];
};

struct trace_event_raw_softirq {
	struct trace_entry ent;
	unsigned int vec;
	char __data[0];
};

struct trace_event_raw_start_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_subflow_check_data_avail {
	struct trace_entry ent;
	u8 status;
	const void *skb;
	char __data[0];
};

struct trace_event_raw_suspend_resume {
	struct trace_entry ent;
	const char *action;
	int val;
	bool start;
	char __data[0];
};

struct trace_event_raw_svc_alloc_arg_err {
	struct trace_entry ent;
	unsigned int requested;
	unsigned int allocated;
	char __data[0];
};

struct trace_event_raw_svc_authenticate {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	long unsigned int svc_status;
	long unsigned int auth_stat;
	char __data[0];
};

struct trace_event_raw_svc_deferred_event {
	struct trace_entry ent;
	const void *dr;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_process {
	struct trace_entry ent;
	u32 xid;
	u32 vers;
	u32 proc;
	u32 __data_loc_service;
	u32 __data_loc_procedure;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_replace_page_err {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	const void *begin;
	const void *respages;
	const void *nextpage;
	char __data[0];
};

struct trace_event_raw_svc_rqst_event {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_svc_rqst_status {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	int status;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_svc_stats_latency {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	long unsigned int execute;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_svc_unregister {
	struct trace_entry ent;
	u32 version;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_raw_svc_wake_up {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_svc_xdr_buf_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_xdr_msg_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_xprt_accept {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	u32 __data_loc_protocol;
	u32 __data_loc_service;
	char __data[0];
};

struct trace_event_raw_svc_xprt_create_err {
	struct trace_entry ent;
	long int error;
	u32 __data_loc_program;
	u32 __data_loc_protocol;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_dequeue {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	long unsigned int wakeup;
	char __data[0];
};

struct trace_event_raw_svc_xprt_enqueue {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_svc_xprt_event {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_svcsock_accept_class {
	struct trace_entry ent;
	long int status;
	u32 __data_loc_service;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_svcsock_class {
	struct trace_entry ent;
	ssize_t result;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_lifetime_class {
	struct trace_entry ent;
	unsigned int netns_ino;
	const void *svsk;
	const void *sk;
	long unsigned int type;
	long unsigned int family;
	long unsigned int state;
	char __data[0];
};

struct trace_event_raw_svcsock_marker {
	struct trace_entry ent;
	unsigned int length;
	bool last;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_recv_short {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_state {
	struct trace_entry ent;
	long unsigned int socket_state;
	long unsigned int sock_state;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_swiotlb_bounced {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u64 dma_mask;
	dma_addr_t dev_addr;
	size_t size;
	bool force;
	char __data[0];
};

struct trace_event_raw_sys_enter {
	struct trace_entry ent;
	long int id;
	long unsigned int args[6];
	char __data[0];
};

struct trace_event_raw_sys_exit {
	struct trace_entry ent;
	long int id;
	long int ret;
	char __data[0];
};

struct trace_event_raw_task_newtask {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	long unsigned int clone_flags;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_task_prctl_unknown {
	struct trace_entry ent;
	int option;
	long unsigned int arg2;
	long unsigned int arg3;
	long unsigned int arg4;
	long unsigned int arg5;
	char __data[0];
};

struct trace_event_raw_task_rename {
	struct trace_entry ent;
	char oldcomm[16];
	char newcomm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_tasklet {
	struct trace_entry ent;
	void *tasklet;
	void *func;
	char __data[0];
};

struct trace_event_raw_tcp_ao_event {
	struct trace_entry ent;
	__u64 net_cookie;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u8 saddr[28];
	__u8 daddr[28];
	int l3index;
	__u16 sport;
	__u16 dport;
	__u16 family;
	bool fin;
	bool syn;
	bool rst;
	bool psh;
	bool ack;
	__u8 keyid;
	__u8 rnext;
	__u8 maclen;
	char __data[0];
};

struct trace_event_raw_tcp_ao_event_sk {
	struct trace_entry ent;
	__u64 net_cookie;
	const void *skaddr;
	int state;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 keyid;
	__u8 rnext;
	char __data[0];
};

struct trace_event_raw_tcp_ao_event_sne {
	struct trace_entry ent;
	__u64 net_cookie;
	const void *skaddr;
	int state;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u32 new_sne;
	char __data[0];
};

struct trace_event_raw_tcp_cong_state_set {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u8 cong_state;
	char __data[0];
};

struct trace_event_raw_tcp_event_sk {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_event_sk_skb {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_event_skb {
	struct trace_entry ent;
	const void *skbaddr;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_tcp_hash_event {
	struct trace_entry ent;
	__u64 net_cookie;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u8 saddr[28];
	__u8 daddr[28];
	int l3index;
	__u16 sport;
	__u16 dport;
	__u16 family;
	bool fin;
	bool syn;
	bool rst;
	bool psh;
	bool ack;
	char __data[0];
};

struct trace_event_raw_tcp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u32 mark;
	__u16 data_len;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 snd_cwnd;
	__u32 ssthresh;
	__u32 snd_wnd;
	__u32 srtt;
	__u32 rcv_wnd;
	__u64 sock_cookie;
	const void *skbaddr;
	const void *skaddr;
	char __data[0];
};

struct trace_event_raw_tcp_retransmit_synack {
	struct trace_entry ent;
	const void *skaddr;
	const void *req;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_send_reset {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	enum sk_rst_reason reason;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_test_pages_isolated {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int fin_pfn;
	char __data[0];
};

struct trace_event_raw_thermal_temperature {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int temp_prev;
	int temp;
	char __data[0];
};

struct trace_event_raw_thermal_zone_trip {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int trip;
	enum thermal_trip_type trip_type;
	char __data[0];
};

struct trace_event_raw_tick_stop {
	struct trace_entry ent;
	int success;
	int dependency;
	char __data[0];
};

struct trace_event_raw_timer_base_idle {
	struct trace_entry ent;
	bool is_idle;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_timer_class {
	struct trace_entry ent;
	void *timer;
	char __data[0];
};

struct trace_event_raw_timer_expire_entry {
	struct trace_entry ent;
	void *timer;
	long unsigned int now;
	void *function;
	long unsigned int baseclk;
	char __data[0];
};

struct trace_event_raw_timer_start {
	struct trace_entry ent;
	void *timer;
	void *function;
	long unsigned int expires;
	long unsigned int bucket_expiry;
	long unsigned int now;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_tipc_fsm_class {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 os;
	u32 ns;
	u32 evt;
	char __data[0];
};

struct trace_event_raw_tipc_l2_device_event {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u32 __data_loc_b_name;
	long unsigned int evt;
	u8 b_up;
	u8 carrier;
	u8 oper;
	char __data[0];
};

struct trace_event_raw_tipc_link_class {
	struct trace_entry ent;
	u32 __data_loc_header;
	char name[68];
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_tipc_link_transmq_class {
	struct trace_entry ent;
	char name[68];
	u16 from;
	u16 to;
	u32 len;
	u16 fseqno;
	u16 lseqno;
	char __data[0];
};

struct trace_event_raw_tipc_list_class {
	struct trace_entry ent;
	u32 __data_loc_header;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_tipc_node_class {
	struct trace_entry ent;
	u32 __data_loc_header;
	u32 addr;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_tipc_sk_class {
	struct trace_entry ent;
	u32 __data_loc_header;
	u32 portid;
	u32 __data_loc_buf;
	u32 __data_loc_skb_buf;
	char __data[0];
};

struct trace_event_raw_tipc_skb_class {
	struct trace_entry ent;
	u32 __data_loc_header;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_tlb_flush {
	struct trace_entry ent;
	int reason;
	long unsigned int pages;
	char __data[0];
};

struct trace_event_raw_tls_contenttype {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	unsigned int netns_ino;
	long unsigned int type;
	char __data[0];
};

struct trace_event_raw_tls_device_decrypted {
	struct trace_entry ent;
	struct sock *sk;
	u64 rec_no;
	u32 tcp_seq;
	u32 rec_len;
	bool encrypted;
	bool decrypted;
	char __data[0];
};

struct trace_event_raw_tls_device_offload_set {
	struct trace_entry ent;
	struct sock *sk;
	u64 rec_no;
	int dir;
	u32 tcp_seq;
	int ret;
	char __data[0];
};

struct trace_event_raw_tls_device_rx_resync_nh_delay {
	struct trace_entry ent;
	struct sock *sk;
	u32 sock_data;
	u32 rec_len;
	char __data[0];
};

struct trace_event_raw_tls_device_rx_resync_nh_schedule {
	struct trace_entry ent;
	struct sock *sk;
	char __data[0];
};

struct trace_event_raw_tls_device_rx_resync_send {
	struct trace_entry ent;
	struct sock *sk;
	u64 rec_no;
	u32 tcp_seq;
	int sync_type;
	char __data[0];
};

struct trace_event_raw_tls_device_tx_resync_req {
	struct trace_entry ent;
	struct sock *sk;
	u32 tcp_seq;
	u32 exp_tcp_seq;
	char __data[0];
};

struct trace_event_raw_tls_device_tx_resync_send {
	struct trace_entry ent;
	struct sock *sk;
	u64 rec_no;
	u32 tcp_seq;
	char __data[0];
};

struct trace_event_raw_tmigr_connect_child_parent {
	struct trace_entry ent;
	void *child;
	void *parent;
	unsigned int lvl;
	unsigned int numa_node;
	unsigned int num_children;
	u32 groupmask;
	char __data[0];
};

struct trace_event_raw_tmigr_connect_cpu_parent {
	struct trace_entry ent;
	void *parent;
	unsigned int cpu;
	unsigned int lvl;
	unsigned int numa_node;
	unsigned int num_children;
	u32 groupmask;
	char __data[0];
};

struct trace_event_raw_tmigr_cpugroup {
	struct trace_entry ent;
	u64 wakeup;
	void *parent;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_tmigr_group_and_cpu {
	struct trace_entry ent;
	void *group;
	void *parent;
	unsigned int lvl;
	unsigned int numa_node;
	u32 childmask;
	u8 active;
	u8 migrator;
	char __data[0];
};

struct trace_event_raw_tmigr_group_set {
	struct trace_entry ent;
	void *group;
	unsigned int lvl;
	unsigned int numa_node;
	char __data[0];
};

struct trace_event_raw_tmigr_handle_remote {
	struct trace_entry ent;
	void *group;
	unsigned int lvl;
	char __data[0];
};

struct trace_event_raw_tmigr_idle {
	struct trace_entry ent;
	u64 nextevt;
	u64 wakeup;
	void *parent;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_tmigr_update_events {
	struct trace_entry ent;
	void *child;
	void *group;
	u64 nextevt;
	u64 group_next_expiry;
	u64 child_evt_expiry;
	unsigned int group_lvl;
	unsigned int child_evtcpu;
	u8 child_active;
	u8 group_active;
	char __data[0];
};

struct trace_event_raw_track_foreign_dirty {
	struct trace_entry ent;
	char name[32];
	u64 bdi_id;
	ino_t ino;
	unsigned int memcg_id;
	ino_t cgroup_ino;
	ino_t page_cgroup_ino;
	char __data[0];
};

struct trace_event_raw_tunnel_only_evt {
	struct trace_entry ent;
	char name[20];
	char __data[0];
};

struct trace_event_raw_udp_fail_queue_rcv_skb {
	struct trace_entry ent;
	int rc;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_unmap {
	struct trace_entry ent;
	u64 iova;
	size_t size;
	size_t unmapped_size;
	char __data[0];
};

struct trace_event_raw_vector_activate {
	struct trace_entry ent;
	unsigned int irq;
	bool is_managed;
	bool can_reserve;
	bool reserve;
	char __data[0];
};

struct trace_event_raw_vector_alloc {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	bool reserved;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_alloc_managed {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_config {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	unsigned int cpu;
	unsigned int apicdest;
	char __data[0];
};

struct trace_event_raw_vector_free_moved {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int cpu;
	unsigned int vector;
	bool is_managed;
	char __data[0];
};

struct trace_event_raw_vector_mod {
	struct trace_entry ent;
	unsigned int irq;
	unsigned int vector;
	unsigned int cpu;
	unsigned int prev_vector;
	unsigned int prev_cpu;
	char __data[0];
};

struct trace_event_raw_vector_reserve {
	struct trace_entry ent;
	unsigned int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_setup {
	struct trace_entry ent;
	unsigned int irq;
	bool is_legacy;
	int ret;
	char __data[0];
};

struct trace_event_raw_vector_teardown {
	struct trace_entry ent;
	unsigned int irq;
	bool is_managed;
	bool has_reserved;
	char __data[0];
};

struct trace_event_raw_virtio_gpu_cmd {
	struct trace_entry ent;
	int dev;
	unsigned int vq;
	u32 __data_loc_name;
	u32 type;
	u32 flags;
	u64 fence_id;
	u32 ctx_id;
	u32 num_free;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_virtio_transport_alloc_pkt {
	struct trace_entry ent;
	__u32 src_cid;
	__u32 src_port;
	__u32 dst_cid;
	__u32 dst_port;
	__u32 len;
	__u16 type;
	__u16 op;
	__u32 flags;
	bool zcopy;
	char __data[0];
};

struct trace_event_raw_virtio_transport_recv_pkt {
	struct trace_entry ent;
	__u32 src_cid;
	__u32 src_port;
	__u32 dst_cid;
	__u32 dst_port;
	__u32 len;
	__u16 type;
	__u16 op;
	__u32 flags;
	__u32 buf_alloc;
	__u32 fwd_cnt;
	char __data[0];
};

struct trace_event_raw_vlv_fifo_size {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 sprite0_start;
	u32 sprite1_start;
	u32 fifo_size;
	char __data[0];
};

struct trace_event_raw_vlv_wm {
	struct trace_entry ent;
	u32 __data_loc_dev;
	char pipe_name;
	u32 frame;
	u32 scanline;
	u32 level;
	u32 cxsr;
	u32 primary;
	u32 sprite0;
	u32 sprite1;
	u32 cursor;
	u32 sr_plane;
	u32 sr_cursor;
	char __data[0];
};

struct trace_event_raw_vm_unmapped_area {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int total_vm;
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
	char __data[0];
};

struct trace_event_raw_vma_mas_szero {
	struct trace_entry ent;
	struct maple_tree *mt;
	long unsigned int start;
	long unsigned int end;
	char __data[0];
};

struct trace_event_raw_vma_store {
	struct trace_entry ent;
	struct maple_tree *mt;
	struct vm_area_struct *vma;
	long unsigned int vm_start;
	long unsigned int vm_end;
	char __data[0];
};

struct trace_event_raw_wake_reaper {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_wakeup_source {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	char __data[0];
};

struct trace_event_raw_watchdog_set_timeout {
	struct trace_entry ent;
	int id;
	unsigned int timeout;
	int err;
	char __data[0];
};

struct trace_event_raw_watchdog_template {
	struct trace_entry ent;
	int id;
	int err;
	char __data[0];
};

struct trace_event_raw_wbc_class {
	struct trace_entry ent;
	char name[32];
	long int nr_to_write;
	long int pages_skipped;
	int sync_mode;
	int for_kupdate;
	int for_background;
	int for_reclaim;
	int range_cyclic;
	long int range_start;
	long int range_end;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_workqueue_activate_work {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	u32 __data_loc_workqueue;
	int req_cpu;
	int cpu;
	char __data[0];
};

struct trace_event_raw_writeback_bdi_register {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_writeback_class {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_dirty_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_writeback_folio_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_writeback_inode_template {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int state;
	__u16 mode;
	long unsigned int dirtied_when;
	char __data[0];
};

struct trace_event_raw_writeback_pages_written {
	struct trace_entry ent;
	long int pages;
	char __data[0];
};

struct trace_event_raw_writeback_queue_io {
	struct trace_entry ent;
	char name[32];
	long unsigned int older;
	long int age;
	int moved;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_sb_inodes_requeue {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_single_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	long unsigned int writeback_index;
	long int nr_to_write;
	long unsigned int wrote;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_work_class {
	struct trace_entry ent;
	char name[32];
	long int nr_pages;
	dev_t sb_dev;
	int sync_mode;
	int for_kupdate;
	int range_cyclic;
	int for_background;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_write_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	int sync_mode;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_x86_exceptions {
	struct trace_entry ent;
	long unsigned int address;
	long unsigned int ip;
	long unsigned int error_code;
	char __data[0];
};

struct trace_event_raw_x86_fpu {
	struct trace_entry ent;
	struct fpu *fpu;
	bool load_fpu;
	u64 xfeatures;
	u64 xcomp_bv;
	char __data[0];
};

struct trace_event_raw_x86_irq_vector {
	struct trace_entry ent;
	int vector;
	char __data[0];
};

struct trace_event_raw_xchk_block_error_class {
	struct trace_entry ent;
	dev_t dev;
	unsigned int type;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_btree_error {
	struct trace_entry ent;
	dev_t dev;
	unsigned int type;
	u32 __data_loc_name;
	int level;
	xfs_agnumber_t agno;
	xfs_agblock_t bno;
	int ptr;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_btree_op_error {
	struct trace_entry ent;
	dev_t dev;
	unsigned int type;
	u32 __data_loc_name;
	int level;
	xfs_agnumber_t agno;
	xfs_agblock_t bno;
	int ptr;
	int error;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	unsigned int type;
	xfs_agnumber_t agno;
	xfs_ino_t inum;
	unsigned int gen;
	unsigned int flags;
	int error;
	char __data[0];
};

struct trace_event_raw_xchk_dirpath_changed {
	struct trace_entry ent;
	dev_t dev;
	unsigned int path_nr;
	unsigned int step_nr;
	xfs_ino_t child_ino;
	xfs_ino_t parent_ino;
	unsigned int namelen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xchk_dirpath_class {
	struct trace_entry ent;
	dev_t dev;
	unsigned int path_nr;
	unsigned int step_nr;
	xfs_ino_t child_ino;
	unsigned int child_gen;
	xfs_ino_t parent_ino;
	unsigned int parent_gen;
	unsigned int namelen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xchk_dirpath_outcome_class {
	struct trace_entry ent;
	dev_t dev;
	long long unsigned int path_nr;
	unsigned int nr_steps;
	unsigned int outcome;
	char __data[0];
};

struct trace_event_raw_xchk_dirtree_class {
	struct trace_entry ent;
	dev_t dev;
	unsigned int path_nr;
	xfs_ino_t child_ino;
	unsigned int child_gen;
	xfs_ino_t parent_ino;
	unsigned int parent_gen;
	unsigned int namelen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xchk_dirtree_evaluate_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_ino_t rootino;
	unsigned int nr_paths;
	unsigned int bad;
	unsigned int suspect;
	unsigned int good;
	bool needs_adoption;
	char __data[0];
};

struct trace_event_raw_xchk_dirtree_live_update {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t parent_ino;
	int action;
	xfs_ino_t child_ino;
	int delta;
	unsigned int namelen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xchk_dqiter_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_dqtype_t dqtype;
	xfs_ino_t ino;
	long long unsigned int cur_id;
	long long unsigned int id;
	xfs_fileoff_t startoff;
	xfs_fsblock_t startblock;
	xfs_filblks_t blockcount;
	xfs_exntst_t state;
	char __data[0];
};

struct trace_event_raw_xchk_fblock_error_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int whichfork;
	unsigned int type;
	xfs_fileoff_t offset;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_file_op_error {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int whichfork;
	unsigned int type;
	xfs_fileoff_t offset;
	int error;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_fscounters_calc {
	struct trace_entry ent;
	dev_t dev;
	int64_t icount_sb;
	uint64_t icount_calculated;
	int64_t ifree_sb;
	uint64_t ifree_calculated;
	int64_t fdblocks_sb;
	uint64_t fdblocks_calculated;
	uint64_t delalloc;
	char __data[0];
};

struct trace_event_raw_xchk_fscounters_within_range {
	struct trace_entry ent;
	dev_t dev;
	uint64_t expected;
	int64_t curr_value;
	int64_t old_value;
	char __data[0];
};

struct trace_event_raw_xchk_fsfreeze_class {
	struct trace_entry ent;
	dev_t dev;
	unsigned int type;
	int error;
	char __data[0];
};

struct trace_event_raw_xchk_fsgate_class {
	struct trace_entry ent;
	dev_t dev;
	unsigned int type;
	unsigned int fsgate_flags;
	char __data[0];
};

struct trace_event_raw_xchk_iallocbt_check_cluster {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t startino;
	xfs_daddr_t map_daddr;
	short unsigned int map_len;
	unsigned int chunk_ino;
	unsigned int nr_inodes;
	unsigned int cluster_ino;
	uint16_t cluster_mask;
	uint16_t holemask;
	char __data[0];
};

struct trace_event_raw_xchk_ifork_btree_error {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int whichfork;
	unsigned int type;
	u32 __data_loc_name;
	int level;
	xfs_agnumber_t agno;
	xfs_agblock_t bno;
	int ptr;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_ifork_btree_op_error {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int whichfork;
	unsigned int type;
	u32 __data_loc_name;
	int level;
	int ptr;
	xfs_agnumber_t agno;
	xfs_agblock_t bno;
	int error;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_incomplete {
	struct trace_entry ent;
	dev_t dev;
	unsigned int type;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_ino_error_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	unsigned int type;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_inode_is_allocated {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	long unsigned int iflags;
	umode_t mode;
	char __data[0];
};

struct trace_event_raw_xchk_iscan_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t cursor;
	xfs_ino_t visited;
	char __data[0];
};

struct trace_event_raw_xchk_iscan_iget {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t cursor;
	xfs_ino_t visited;
	int error;
	char __data[0];
};

struct trace_event_raw_xchk_iscan_iget_batch {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t cursor;
	xfs_ino_t visited;
	unsigned int nr;
	unsigned int avail;
	unsigned int unavail;
	xfs_ino_t batch_ino;
	long long unsigned int skipmask;
	char __data[0];
};

struct trace_event_raw_xchk_iscan_ino_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t startino;
	xfs_ino_t cursor;
	xfs_ino_t visited;
	xfs_ino_t ino;
	char __data[0];
};

struct trace_event_raw_xchk_iscan_retry_wait_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t cursor;
	xfs_ino_t visited;
	unsigned int retry_delay;
	long unsigned int remaining;
	unsigned int iget_timeout;
	char __data[0];
};

struct trace_event_raw_xchk_metapath_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t scrub_ino;
	xfs_ino_t parent_ino;
	xfs_ino_t ino;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xchk_nlinks_check_zero {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_nlink_t parents;
	xfs_nlink_t backrefs;
	xfs_nlink_t children;
	char __data[0];
};

struct trace_event_raw_xchk_nlinks_collect_dirent {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t dir;
	xfs_ino_t ino;
	unsigned int namelen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xchk_nlinks_collect_metafile {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	char __data[0];
};

struct trace_event_raw_xchk_nlinks_collect_pptr {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t dir;
	xfs_ino_t ino;
	unsigned int namelen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xchk_nlinks_diff_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	uint8_t ftype;
	xfs_nlink_t nlink;
	xfs_nlink_t parents;
	xfs_nlink_t backrefs;
	xfs_nlink_t children;
	char __data[0];
};

struct trace_event_raw_xchk_nlinks_live_update {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t dir;
	int action;
	xfs_ino_t ino;
	int delta;
	unsigned int namelen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xchk_nlinks_update_incore {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_nlink_t parents;
	xfs_nlink_t backrefs;
	xfs_nlink_t children;
	int parents_delta;
	int backrefs_delta;
	int children_delta;
	char __data[0];
};

struct trace_event_raw_xchk_op_error {
	struct trace_entry ent;
	dev_t dev;
	unsigned int type;
	xfs_agnumber_t agno;
	xfs_agblock_t bno;
	int error;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_pptr_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	unsigned int namelen;
	u32 __data_loc_name;
	xfs_ino_t far_ino;
	char __data[0];
};

struct trace_event_raw_xchk_qcheck_error {
	struct trace_entry ent;
	dev_t dev;
	xfs_dqtype_t dqtype;
	xfs_dqid_t id;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xchk_refcount_incorrect {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	enum xfs_refc_domain domain;
	xfs_agblock_t startblock;
	xfs_extlen_t blockcount;
	xfs_nlink_t refcount;
	xfs_nlink_t seen;
	char __data[0];
};

struct trace_event_raw_xchk_sbtree_class {
	struct trace_entry ent;
	dev_t dev;
	int type;
	u32 __data_loc_name;
	xfs_agnumber_t agno;
	xfs_agblock_t bno;
	int level;
	int nlevels;
	int ptr;
	char __data[0];
};

struct trace_event_raw_xchk_vector_class {
	struct trace_entry ent;
	dev_t dev;
	unsigned int vec_nr;
	unsigned int vec_type;
	unsigned int vec_flags;
	int vec_ret;
	char __data[0];
};

struct trace_event_raw_xchk_vector_head_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_agnumber_t agno;
	xfs_ino_t inum;
	unsigned int gen;
	unsigned int flags;
	short unsigned int rest_us;
	short unsigned int nr_vecs;
	char __data[0];
};

struct trace_event_raw_xchk_xref_error {
	struct trace_entry ent;
	dev_t dev;
	int type;
	int error;
	void *ret_ip;
	char __data[0];
};

struct trace_event_raw_xdp_bulk_tx {
	struct trace_entry ent;
	int ifindex;
	u32 act;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_enqueue {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int to_cpu;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_kthread {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int sched;
	unsigned int xdp_pass;
	unsigned int xdp_drop;
	unsigned int xdp_redirect;
	char __data[0];
};

struct trace_event_raw_xdp_devmap_xmit {
	struct trace_entry ent;
	int from_ifindex;
	u32 act;
	int to_ifindex;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_exception {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_xdp_redirect_template {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	int err;
	int to_ifindex;
	u32 map_id;
	int map_index;
	char __data[0];
};

struct trace_event_raw_xfarray_create {
	struct trace_entry ent;
	long unsigned int ino;
	uint64_t max_nr;
	size_t obj_size;
	int obj_size_log;
	long long unsigned int required_capacity;
	char __data[0];
};

struct trace_event_raw_xfarray_foliosort {
	struct trace_entry ent;
	long unsigned int ino;
	long long unsigned int lo;
	long long unsigned int hi;
	char __data[0];
};

struct trace_event_raw_xfarray_isort {
	struct trace_entry ent;
	long unsigned int ino;
	long long unsigned int lo;
	long long unsigned int hi;
	char __data[0];
};

struct trace_event_raw_xfarray_qsort {
	struct trace_entry ent;
	long unsigned int ino;
	long long unsigned int lo;
	long long unsigned int hi;
	int stack_depth;
	int max_stack_depth;
	char __data[0];
};

struct trace_event_raw_xfarray_sort {
	struct trace_entry ent;
	long unsigned int ino;
	long long unsigned int nr;
	size_t obj_size;
	size_t bytes;
	unsigned int max_stack_depth;
	char __data[0];
};

struct trace_event_raw_xfarray_sort_scan {
	struct trace_entry ent;
	long unsigned int ino;
	long long unsigned int nr;
	size_t obj_size;
	long long unsigned int idx;
	long long unsigned int folio_pos;
	long unsigned int folio_bytes;
	long long unsigned int first_idx;
	long long unsigned int last_idx;
	char __data[0];
};

struct trace_event_raw_xfarray_sort_stats {
	struct trace_entry ent;
	long unsigned int ino;
	unsigned int max_stack_depth;
	unsigned int max_stack_used;
	int error;
	char __data[0];
};

struct trace_event_raw_xfile_class {
	struct trace_entry ent;
	long unsigned int ino;
	long long unsigned int bytes_used;
	loff_t pos;
	loff_t size;
	long long unsigned int bytecount;
	char __data[0];
};

struct trace_event_raw_xfile_create {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ino;
	char pathname[256];
	char __data[0];
};

struct trace_event_raw_xfile_destroy {
	struct trace_entry ent;
	long unsigned int ino;
	long long unsigned int bytes;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_xfs_ag_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	char __data[0];
};

struct trace_event_raw_xfs_ag_inode_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	char __data[0];
};

struct trace_event_raw_xfs_ag_resv_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	int resv;
	xfs_extlen_t freeblks;
	xfs_extlen_t flcount;
	xfs_extlen_t reserved;
	xfs_extlen_t asked;
	xfs_extlen_t len;
	char __data[0];
};

struct trace_event_raw_xfs_ag_resv_init_error {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	int error;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_agf_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	int flags;
	__u32 length;
	__u32 bno_root;
	__u32 cnt_root;
	__u32 bno_level;
	__u32 cnt_level;
	__u32 flfirst;
	__u32 fllast;
	__u32 flcount;
	__u32 freeblks;
	__u32 longest;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_ail_class {
	struct trace_entry ent;
	dev_t dev;
	void *lip;
	uint type;
	long unsigned int flags;
	xfs_lsn_t old_lsn;
	xfs_lsn_t new_lsn;
	char __data[0];
};

struct trace_event_raw_xfs_alloc_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t minlen;
	xfs_extlen_t maxlen;
	xfs_extlen_t mod;
	xfs_extlen_t prod;
	xfs_extlen_t minleft;
	xfs_extlen_t total;
	xfs_extlen_t alignment;
	xfs_extlen_t minalignslop;
	xfs_extlen_t len;
	char wasdel;
	char wasfromfl;
	int resv;
	int datatype;
	xfs_agnumber_t highest_agno;
	char __data[0];
};

struct trace_event_raw_xfs_alloc_cur_check {
	struct trace_entry ent;
	dev_t dev;
	u32 __data_loc_name;
	xfs_agblock_t bno;
	xfs_extlen_t len;
	xfs_extlen_t diff;
	bool new;
	char __data[0];
};

struct trace_event_raw_xfs_attr_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	u32 __data_loc_name;
	int namelen;
	int valuelen;
	xfs_dahash_t hashval;
	unsigned int attr_filter;
	uint32_t op_flags;
	char __data[0];
};

struct trace_event_raw_xfs_attr_list_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	u32 hashval;
	u32 blkno;
	u32 offset;
	void *buffer;
	int bufsize;
	int count;
	int firstu;
	int dupcnt;
	unsigned int attr_filter;
	char __data[0];
};

struct trace_event_raw_xfs_attr_list_node_descend {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	u32 hashval;
	u32 blkno;
	u32 offset;
	void *buffer;
	int bufsize;
	int count;
	int firstu;
	int dupcnt;
	unsigned int attr_filter;
	u32 bt_hashval;
	u32 bt_before;
	char __data[0];
};

struct trace_event_raw_xfs_bmap_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	void *leaf;
	int pos;
	xfs_fileoff_t startoff;
	xfs_fsblock_t startblock;
	xfs_filblks_t blockcount;
	xfs_exntst_t state;
	int bmap_state;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_bmap_deferred_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	xfs_ino_t ino;
	long long unsigned int gbno;
	int whichfork;
	xfs_fileoff_t l_loff;
	xfs_filblks_t l_len;
	xfs_exntst_t l_state;
	int op;
	char __data[0];
};

struct trace_event_raw_xfs_btree_alloc_block {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_ino_t ino;
	u32 __data_loc_name;
	int error;
	xfs_agblock_t agbno;
	char __data[0];
};

struct trace_event_raw_xfs_btree_bload_block {
	struct trace_entry ent;
	dev_t dev;
	u32 __data_loc_name;
	unsigned int level;
	long long unsigned int block_idx;
	long long unsigned int nr_blocks;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	unsigned int nr_records;
	char __data[0];
};

struct trace_event_raw_xfs_btree_bload_level_geometry {
	struct trace_entry ent;
	dev_t dev;
	u32 __data_loc_name;
	unsigned int level;
	unsigned int nlevels;
	uint64_t nr_this_level;
	unsigned int nr_per_block;
	unsigned int desired_npb;
	long long unsigned int blocks;
	long long unsigned int blocks_with_extra;
	char __data[0];
};

struct trace_event_raw_xfs_btree_commit_afakeroot {
	struct trace_entry ent;
	dev_t dev;
	u32 __data_loc_name;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	unsigned int levels;
	unsigned int blocks;
	char __data[0];
};

struct trace_event_raw_xfs_btree_commit_ifakeroot {
	struct trace_entry ent;
	dev_t dev;
	u32 __data_loc_name;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	unsigned int levels;
	unsigned int blocks;
	int whichfork;
	char __data[0];
};

struct trace_event_raw_xfs_btree_cur_class {
	struct trace_entry ent;
	dev_t dev;
	u32 __data_loc_name;
	int level;
	int nlevels;
	int ptr;
	xfs_daddr_t daddr;
	char __data[0];
};

struct trace_event_raw_xfs_btree_error_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_ino_t ino;
	int error;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_btree_free_block {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_ino_t ino;
	u32 __data_loc_name;
	xfs_agblock_t agbno;
	char __data[0];
};

struct trace_event_raw_xfs_buf_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_daddr_t bno;
	int nblks;
	int hold;
	int pincount;
	unsigned int lockval;
	unsigned int flags;
	long unsigned int caller_ip;
	const void *buf_ops;
	char __data[0];
};

struct trace_event_raw_xfs_buf_flags_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_daddr_t bno;
	unsigned int length;
	int hold;
	int pincount;
	unsigned int lockval;
	unsigned int flags;
	long unsigned int caller_ip;
	char __data[0];
};

typedef void *xfs_failaddr_t;

struct trace_event_raw_xfs_buf_ioerror {
	struct trace_entry ent;
	dev_t dev;
	xfs_daddr_t bno;
	unsigned int length;
	unsigned int flags;
	int hold;
	int pincount;
	unsigned int lockval;
	int error;
	xfs_failaddr_t caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_buf_item_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_daddr_t buf_bno;
	unsigned int buf_len;
	int buf_hold;
	int buf_pincount;
	int buf_lockval;
	unsigned int buf_flags;
	unsigned int bli_recur;
	int bli_refcount;
	unsigned int bli_flags;
	long unsigned int li_flags;
	char __data[0];
};

struct trace_event_raw_xfs_bunmap {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fsize_t size;
	xfs_fileoff_t fileoff;
	xfs_filblks_t len;
	long unsigned int caller_ip;
	int flags;
	char __data[0];
};

struct trace_event_raw_xfs_check_new_dalign {
	struct trace_entry ent;
	dev_t dev;
	int new_dalign;
	xfs_ino_t sb_rootino;
	xfs_ino_t calc_rootino;
	char __data[0];
};

struct trace_event_raw_xfs_da_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	u32 __data_loc_name;
	int namelen;
	xfs_dahash_t hashval;
	xfs_ino_t inumber;
	uint32_t op_flags;
	xfs_ino_t owner;
	char __data[0];
};

struct trace_event_raw_xfs_das_state_class {
	struct trace_entry ent;
	int das;
	xfs_ino_t ino;
	char __data[0];
};

struct xfs_trans;

struct trace_event_raw_xfs_defer_class {
	struct trace_entry ent;
	dev_t dev;
	struct xfs_trans *tp;
	char committed;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_defer_error_class {
	struct trace_entry ent;
	dev_t dev;
	struct xfs_trans *tp;
	char committed;
	int error;
	char __data[0];
};

struct trace_event_raw_xfs_defer_pending_class {
	struct trace_entry ent;
	dev_t dev;
	u32 __data_loc_name;
	void *intent;
	unsigned int flags;
	char committed;
	int nr;
	char __data[0];
};

struct trace_event_raw_xfs_defer_pending_item_class {
	struct trace_entry ent;
	dev_t dev;
	u32 __data_loc_name;
	void *intent;
	void *item;
	char committed;
	unsigned int flags;
	int nr;
	char __data[0];
};

struct trace_event_raw_xfs_dir2_leafn_moveents {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	uint32_t op_flags;
	int src_idx;
	int dst_idx;
	int count;
	char __data[0];
};

struct trace_event_raw_xfs_dir2_space_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	uint32_t op_flags;
	int idx;
	char __data[0];
};

struct trace_event_raw_xfs_discard_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	char __data[0];
};

struct trace_event_raw_xfs_double_io_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t src_ino;
	loff_t src_isize;
	loff_t src_disize;
	loff_t src_offset;
	long long int len;
	xfs_ino_t dest_ino;
	loff_t dest_isize;
	loff_t dest_disize;
	loff_t dest_offset;
	char __data[0];
};

struct trace_event_raw_xfs_dqtrx_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_dqtype_t type;
	unsigned int flags;
	u32 dqid;
	uint64_t blk_res;
	int64_t bcount_delta;
	int64_t delbcnt_delta;
	uint64_t rtblk_res;
	uint64_t rtblk_res_used;
	int64_t rtbcount_delta;
	int64_t delrtb_delta;
	uint64_t ino_res;
	uint64_t ino_res_used;
	int64_t icount_delta;
	char __data[0];
};

struct trace_event_raw_xfs_dquot_class {
	struct trace_entry ent;
	dev_t dev;
	u32 id;
	xfs_dqtype_t type;
	unsigned int flags;
	unsigned int nrefs;
	long long unsigned int res_bcount;
	long long unsigned int res_rtbcount;
	long long unsigned int res_icount;
	long long unsigned int bcount;
	long long unsigned int rtbcount;
	long long unsigned int icount;
	long long unsigned int blk_hardlimit;
	long long unsigned int blk_softlimit;
	long long unsigned int rtb_hardlimit;
	long long unsigned int rtb_softlimit;
	long long unsigned int ino_hardlimit;
	long long unsigned int ino_softlimit;
	char __data[0];
};

struct trace_event_raw_xfs_exchmaps_delta_nextents {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino1;
	xfs_ino_t ino2;
	xfs_extnum_t nexts1;
	xfs_extnum_t nexts2;
	int64_t d_nexts1;
	int64_t d_nexts2;
	char __data[0];
};

struct trace_event_raw_xfs_exchmaps_delta_nextents_step {
	struct trace_entry ent;
	dev_t dev;
	xfs_fileoff_t loff;
	xfs_fsblock_t lstart;
	xfs_filblks_t lcount;
	xfs_fileoff_t coff;
	xfs_fsblock_t cstart;
	xfs_filblks_t ccount;
	xfs_fileoff_t noff;
	xfs_fsblock_t nstart;
	xfs_filblks_t ncount;
	xfs_fileoff_t roff;
	xfs_fsblock_t rstart;
	xfs_filblks_t rcount;
	int delta;
	unsigned int state;
	char __data[0];
};

struct trace_event_raw_xfs_exchmaps_estimate_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino1;
	xfs_ino_t ino2;
	xfs_fileoff_t startoff1;
	xfs_fileoff_t startoff2;
	xfs_filblks_t blockcount;
	uint64_t flags;
	xfs_filblks_t ip1_bcount;
	xfs_filblks_t ip2_bcount;
	xfs_filblks_t ip1_rtbcount;
	xfs_filblks_t ip2_rtbcount;
	long long unsigned int resblks;
	long long unsigned int nr_exchanges;
	char __data[0];
};

struct trace_event_raw_xfs_exchmaps_intent_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino1;
	xfs_ino_t ino2;
	uint64_t flags;
	xfs_fileoff_t startoff1;
	xfs_fileoff_t startoff2;
	xfs_filblks_t blockcount;
	xfs_fsize_t isize1;
	xfs_fsize_t isize2;
	xfs_fsize_t new_isize1;
	xfs_fsize_t new_isize2;
	char __data[0];
};

struct trace_event_raw_xfs_exchmaps_overhead {
	struct trace_entry ent;
	dev_t dev;
	long long unsigned int bmbt_blocks;
	long long unsigned int rmapbt_blocks;
	char __data[0];
};

struct trace_event_raw_xfs_exchrange_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ip1_ino;
	loff_t ip1_isize;
	loff_t ip1_disize;
	xfs_ino_t ip2_ino;
	loff_t ip2_isize;
	loff_t ip2_disize;
	loff_t file1_offset;
	loff_t file2_offset;
	long long unsigned int length;
	long long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_exchrange_freshness {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ip2_ino;
	long long int ip2_mtime;
	long long int ip2_ctime;
	int ip2_mtime_nsec;
	int ip2_ctime_nsec;
	xfs_ino_t file2_ino;
	long long int file2_mtime;
	long long int file2_ctime;
	int file2_mtime_nsec;
	int file2_ctime_nsec;
	char __data[0];
};

struct trace_event_raw_xfs_exchrange_inode_class {
	struct trace_entry ent;
	dev_t dev;
	int whichfile;
	xfs_ino_t ino;
	int format;
	xfs_extnum_t nex;
	int broot_size;
	int fork_off;
	char __data[0];
};

struct trace_event_raw_xfs_extent_busy_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	char __data[0];
};

struct trace_event_raw_xfs_extent_busy_trim {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	xfs_agblock_t tbno;
	xfs_extlen_t tlen;
	char __data[0];
};

struct trace_event_raw_xfs_fault_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_xfs_file_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fsize_t size;
	loff_t offset;
	size_t count;
	char __data[0];
};

struct trace_event_raw_xfs_filestream_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_agnumber_t agno;
	int streams;
	char __data[0];
};

struct trace_event_raw_xfs_filestream_pick {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_agnumber_t agno;
	int streams;
	xfs_extlen_t free;
	char __data[0];
};

struct trace_event_raw_xfs_force_shutdown {
	struct trace_entry ent;
	dev_t dev;
	int ptag;
	int flags;
	u32 __data_loc_fname;
	int line_num;
	char __data[0];
};

struct trace_event_raw_xfs_free_extent {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	int resv;
	int haveleft;
	int haveright;
	char __data[0];
};

struct trace_event_raw_xfs_free_extent_deferred_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_fs_class {
	struct trace_entry ent;
	dev_t dev;
	long long unsigned int mflags;
	long unsigned int opstate;
	long unsigned int sbflags;
	void *caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_fs_corrupt_class {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_fsmap_group_key_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	uint64_t owner;
	uint64_t offset;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_fsmap_linear_key_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	xfs_fsblock_t bno;
	char __data[0];
};

struct trace_event_raw_xfs_fsmap_mapping {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_daddr_t start_daddr;
	xfs_daddr_t len_daddr;
	uint64_t owner;
	uint64_t offset;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	xfs_daddr_t block;
	xfs_daddr_t len;
	uint64_t owner;
	uint64_t offset;
	uint64_t flags;
	char __data[0];
};

struct trace_event_raw_xfs_getparents_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	short unsigned int iflags;
	short unsigned int oflags;
	unsigned int bufsize;
	unsigned int hashval;
	unsigned int blkno;
	unsigned int offset;
	int initted;
	char __data[0];
};

struct trace_event_raw_xfs_getparents_rec_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	unsigned int firstu;
	short unsigned int reclen;
	unsigned int bufsize;
	xfs_ino_t parent_ino;
	unsigned int parent_gen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xfs_group_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	int refcount;
	int active_refcount;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_group_corrupt_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	uint32_t index;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_group_intents_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	uint32_t index;
	long int nr_intents;
	void *caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_icwalk_class {
	struct trace_entry ent;
	dev_t dev;
	__u32 flags;
	uint32_t uid;
	uint32_t gid;
	prid_t prid;
	__u64 min_file_size;
	long int scan_limit;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_imap_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	loff_t size;
	loff_t offset;
	size_t count;
	int whichfork;
	xfs_fileoff_t startoff;
	xfs_fsblock_t startblock;
	xfs_filblks_t blockcount;
	char __data[0];
};

struct trace_event_raw_xfs_inode_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	long unsigned int iflags;
	char __data[0];
};

struct trace_event_raw_xfs_inode_corrupt_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_inode_error_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int error;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_inode_irec_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fileoff_t lblk;
	xfs_extlen_t len;
	xfs_fsblock_t pblk;
	int state;
	char __data[0];
};

struct trace_event_raw_xfs_inode_reload_unlinked_bucket {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	char __data[0];
};

struct trace_event_raw_xfs_inodegc_shrinker_scan {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int nr_to_scan;
	void *caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_inodegc_worker {
	struct trace_entry ent;
	dev_t dev;
	unsigned int shrinker_hits;
	char __data[0];
};

struct trace_event_raw_xfs_ioctl_clone {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int src_ino;
	loff_t src_isize;
	long unsigned int dest_ino;
	loff_t dest_isize;
	char __data[0];
};

struct trace_event_raw_xfs_iomap_invalid_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	u64 addr;
	loff_t pos;
	u64 len;
	u64 validity_cookie;
	u64 inodeseq;
	u16 type;
	u16 flags;
	char __data[0];
};

struct trace_event_raw_xfs_iomap_prealloc_size {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fsblock_t blocks;
	int shift;
	unsigned int writeio_blocks;
	char __data[0];
};

struct trace_event_raw_xfs_irec_merge_post {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	uint16_t holemask;
	char __data[0];
};

struct trace_event_raw_xfs_irec_merge_pre {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	uint16_t holemask;
	xfs_agino_t nagino;
	uint16_t nholemask;
	char __data[0];
};

struct trace_event_raw_xfs_iref_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int count;
	int pincount;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_itrunc_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fsize_t size;
	xfs_fsize_t new_size;
	char __data[0];
};

struct trace_event_raw_xfs_iunlink_reload_next {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	xfs_agino_t prev_agino;
	xfs_agino_t next_agino;
	char __data[0];
};

struct trace_event_raw_xfs_iunlink_update_bucket {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	unsigned int bucket;
	xfs_agino_t old_ptr;
	xfs_agino_t new_ptr;
	char __data[0];
};

struct trace_event_raw_xfs_iunlink_update_dinode {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t agino;
	xfs_agino_t old_ptr;
	xfs_agino_t new_ptr;
	char __data[0];
};

struct trace_event_raw_xfs_iwalk_ag_rec {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agino_t startino;
	uint64_t freemask;
	char __data[0];
};

struct trace_event_raw_xfs_lock_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	int lock_flags;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_log_assign_tail_lsn {
	struct trace_entry ent;
	dev_t dev;
	xfs_lsn_t new_lsn;
	xfs_lsn_t old_lsn;
	xfs_lsn_t head_lsn;
	char __data[0];
};

struct trace_event_raw_xfs_log_force {
	struct trace_entry ent;
	dev_t dev;
	xfs_lsn_t lsn;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_log_get_max_trans_res {
	struct trace_entry ent;
	dev_t dev;
	uint logres;
	int logcount;
	char __data[0];
};

struct trace_event_raw_xfs_log_item_class {
	struct trace_entry ent;
	dev_t dev;
	void *lip;
	uint type;
	long unsigned int flags;
	xfs_lsn_t lsn;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover {
	struct trace_entry ent;
	dev_t dev;
	xfs_daddr_t headblk;
	xfs_daddr_t tailblk;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover_buf_item_class {
	struct trace_entry ent;
	dev_t dev;
	int64_t blkno;
	short unsigned int len;
	short unsigned int flags;
	short unsigned int size;
	unsigned int map_size;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover_icreate_item_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	unsigned int count;
	unsigned int isize;
	xfs_agblock_t length;
	unsigned int gen;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover_ino_item_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	short unsigned int size;
	int fields;
	short unsigned int asize;
	short unsigned int dsize;
	int64_t blkno;
	int len;
	int boffset;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover_item_class {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int item;
	xlog_tid_t tid;
	xfs_lsn_t lsn;
	int type;
	int pass;
	int count;
	int total;
	char __data[0];
};

struct trace_event_raw_xfs_log_recover_record {
	struct trace_entry ent;
	dev_t dev;
	xfs_lsn_t lsn;
	int len;
	int num_logops;
	int pass;
	char __data[0];
};

struct trace_event_raw_xfs_loggrant_class {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tic;
	char ocnt;
	char cnt;
	int curr_res;
	int unit_res;
	unsigned int flags;
	int reserveq;
	int writeq;
	uint64_t grant_reserve_bytes;
	uint64_t grant_write_bytes;
	uint64_t tail_space;
	int curr_cycle;
	int curr_block;
	xfs_lsn_t tail_lsn;
	char __data[0];
};

struct trace_event_raw_xfs_metadir_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t dp_ino;
	xfs_ino_t ino;
	int ftype;
	int namelen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xfs_metadir_update_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t dp_ino;
	xfs_ino_t ino;
	u32 __data_loc_fname;
	char __data[0];
};

struct trace_event_raw_xfs_metadir_update_error_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t dp_ino;
	xfs_ino_t ino;
	int error;
	u32 __data_loc_fname;
	char __data[0];
};

struct trace_event_raw_xfs_metafile_resv_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	long long unsigned int freeblks;
	long long unsigned int reserved;
	long long unsigned int asked;
	long long unsigned int used;
	long long unsigned int len;
	char __data[0];
};

struct trace_event_raw_xfs_namespace_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t dp_ino;
	int namelen;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_xfs_pagecache_inval {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	xfs_fsize_t size;
	xfs_off_t start;
	xfs_off_t finish;
	char __data[0];
};

struct trace_event_raw_xfs_perag_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_agnumber_t agno;
	int refcount;
	int active_refcount;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_pwork_init {
	struct trace_entry ent;
	dev_t dev;
	unsigned int nr_threads;
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	xfs_agblock_t gbno;
	xfs_extlen_t len;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_deferred_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	int op;
	xfs_agblock_t gbno;
	xfs_extlen_t len;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_double_extent_at_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	enum xfs_refc_domain i1_domain;
	xfs_agblock_t i1_startblock;
	xfs_extlen_t i1_blockcount;
	xfs_nlink_t i1_refcount;
	enum xfs_refc_domain i2_domain;
	xfs_agblock_t i2_startblock;
	xfs_extlen_t i2_blockcount;
	xfs_nlink_t i2_refcount;
	xfs_agblock_t gbno;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_double_extent_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	enum xfs_refc_domain i1_domain;
	xfs_agblock_t i1_startblock;
	xfs_extlen_t i1_blockcount;
	xfs_nlink_t i1_refcount;
	enum xfs_refc_domain i2_domain;
	xfs_agblock_t i2_startblock;
	xfs_extlen_t i2_blockcount;
	xfs_nlink_t i2_refcount;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_extent_at_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	enum xfs_refc_domain domain;
	xfs_agblock_t startblock;
	xfs_extlen_t blockcount;
	xfs_nlink_t refcount;
	xfs_agblock_t gbno;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_extent_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	enum xfs_refc_domain domain;
	xfs_agblock_t startblock;
	xfs_extlen_t blockcount;
	xfs_nlink_t refcount;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_lookup {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	xfs_agblock_t gbno;
	xfs_lookup_t dir;
	char __data[0];
};

struct trace_event_raw_xfs_refcount_triple_extent_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	enum xfs_refc_domain i1_domain;
	xfs_agblock_t i1_startblock;
	xfs_extlen_t i1_blockcount;
	xfs_nlink_t i1_refcount;
	enum xfs_refc_domain i2_domain;
	xfs_agblock_t i2_startblock;
	xfs_extlen_t i2_blockcount;
	xfs_nlink_t i2_refcount;
	enum xfs_refc_domain i3_domain;
	xfs_agblock_t i3_startblock;
	xfs_extlen_t i3_blockcount;
	xfs_nlink_t i3_refcount;
	char __data[0];
};

struct trace_event_raw_xfs_reflink_remap_blocks {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t src_ino;
	xfs_fileoff_t src_lblk;
	xfs_filblks_t len;
	xfs_ino_t dest_ino;
	xfs_fileoff_t dest_lblk;
	char __data[0];
};

struct trace_event_raw_xfs_rename {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t src_dp_ino;
	xfs_ino_t target_dp_ino;
	int src_namelen;
	int target_namelen;
	u32 __data_loc_src_name;
	u32 __data_loc_target_name;
	char __data[0];
};

struct trace_event_raw_xfs_rmap_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	xfs_agblock_t gbno;
	xfs_extlen_t len;
	uint64_t owner;
	uint64_t offset;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_rmap_convert_state {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	int state;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_rmap_deferred_class {
	struct trace_entry ent;
	dev_t dev;
	long long unsigned int owner;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	xfs_agblock_t gbno;
	int whichfork;
	xfs_fileoff_t l_loff;
	xfs_filblks_t l_len;
	xfs_exntst_t l_state;
	int op;
	char __data[0];
};

struct trace_event_raw_xfs_rmapbt_class {
	struct trace_entry ent;
	dev_t dev;
	enum xfs_group_type type;
	xfs_agnumber_t agno;
	xfs_agblock_t gbno;
	xfs_extlen_t len;
	uint64_t owner;
	uint64_t offset;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_xfs_rtdiscard_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_rtblock_t rtbno;
	xfs_rtblock_t len;
	char __data[0];
};

struct trace_event_raw_xfs_simple_io_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	loff_t isize;
	loff_t disize;
	loff_t offset;
	size_t count;
	char __data[0];
};

struct trace_event_raw_xfs_swap_extent_class {
	struct trace_entry ent;
	dev_t dev;
	int which;
	xfs_ino_t ino;
	int format;
	xfs_extnum_t nex;
	int broot_size;
	int fork_off;
	char __data[0];
};

struct trace_event_raw_xfs_timestamp_range_class {
	struct trace_entry ent;
	dev_t dev;
	long long int min;
	long long int max;
	char __data[0];
};

struct trace_event_raw_xfs_trans_class {
	struct trace_entry ent;
	dev_t dev;
	uint32_t tid;
	uint32_t flags;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xfs_trans_mod_dquot {
	struct trace_entry ent;
	dev_t dev;
	xfs_dqtype_t type;
	unsigned int flags;
	unsigned int dqid;
	unsigned int field;
	int64_t delta;
	char __data[0];
};

struct trace_event_raw_xfs_trans_resv_class {
	struct trace_entry ent;
	dev_t dev;
	int type;
	uint logres;
	int logcount;
	int logflags;
	char __data[0];
};

struct trace_event_raw_xfs_wb_invalid_class {
	struct trace_entry ent;
	dev_t dev;
	xfs_ino_t ino;
	u64 addr;
	loff_t pos;
	u64 len;
	u16 type;
	u16 flags;
	u32 wpcseq;
	u32 forkseq;
	char __data[0];
};

struct trace_event_raw_xlog_iclog_class {
	struct trace_entry ent;
	dev_t dev;
	uint32_t state;
	int32_t refcount;
	uint32_t offset;
	uint32_t flags;
	long long unsigned int lsn;
	long unsigned int caller_ip;
	char __data[0];
};

struct trace_event_raw_xlog_intent_recovery_failed {
	struct trace_entry ent;
	dev_t dev;
	u32 __data_loc_name;
	int error;
	char __data[0];
};

struct trace_event_raw_xmbuf_create {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ino;
	char pathname[256];
	char __data[0];
};

struct trace_event_raw_xmbuf_free {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ino;
	long long unsigned int bytes;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_xprt_cong_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	long unsigned int cong;
	long unsigned int cwnd;
	bool wait;
	char __data[0];
};

struct trace_event_raw_xprt_ping {
	struct trace_entry ent;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_reserve {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	char __data[0];
};

struct trace_event_raw_xprt_retransmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int ntrans;
	int version;
	long unsigned int timeout;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_xprt_transmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	int status;
	char __data[0];
};

struct trace_event_raw_xprt_writelock_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	char __data[0];
};

struct trace_event_raw_xs_data_ready {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_socket_event {
	struct trace_entry ent;
	unsigned int socket_state;
	unsigned int sock_state;
	long long unsigned int ino;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_xs_socket_event_done {
	struct trace_entry ent;
	int error;
	unsigned int socket_state;
	unsigned int sock_state;
	long long unsigned int ino;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_xs_stream_read_data {
	struct trace_entry ent;
	ssize_t err;
	size_t total;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_request {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 xid;
	long unsigned int copied;
	unsigned int reclen;
	unsigned int offset;
	char __data[0];
};

struct trace_export {
	struct trace_export *next;
	void (*write)(struct trace_export *, const void *, unsigned int);
	int flags;
};

struct trace_func_repeats {
	long unsigned int ip;
	long unsigned int parent_ip;
	long unsigned int count;
	u64 ts_last_call;
};

struct trace_kprobe {
	struct dyn_event devent;
	struct kretprobe rp;
	long unsigned int *nhit;
	const char *symbol;
	struct trace_probe tp;
};

struct trace_mark {
	long long unsigned int val;
	char sym;
};

struct trace_min_max_param {
	struct mutex *lock;
	u64 *val;
	u64 *min;
	u64 *max;
};

struct tracer_opt;

struct tracer_flags;

struct trace_option_dentry {
	struct tracer_opt *opt;
	struct tracer_flags *flags;
	struct trace_array *tr;
	struct dentry *entry;
};

struct trace_options {
	struct tracer *tracer;
	struct trace_option_dentry *topts;
};

struct trace_parser {
	bool cont;
	char *buffer;
	unsigned int idx;
	unsigned int size;
};

union upper_chunk;

struct trace_pid_list {
	raw_spinlock_t lock;
	struct irq_work refill_irqwork;
	union upper_chunk *upper[256];
	union upper_chunk *upper_list;
	union lower_chunk *lower_list;
	int free_upper_chunks;
	int free_lower_chunks;
};

struct trace_print_flags {
	long unsigned int mask;
	const char *name;
};

struct trace_uprobe_filter {
	rwlock_t rwlock;
	int nr_systemwide;
	struct list_head perf_events;
};

struct trace_probe_event {
	unsigned int flags;
	struct trace_event_class class;
	struct trace_event_call call;
	struct list_head files;
	struct list_head probes;
	struct trace_uprobe_filter filter[0];
};

struct trace_probe_log {
	const char *subsystem;
	const char **argv;
	int argc;
	int index;
};

struct trace_subsystem_dir {
	struct list_head list;
	struct event_subsystem *subsystem;
	struct trace_array *tr;
	struct eventfs_inode *ei;
	int ref_count;
	int nr_events;
};

struct trace_uprobe {
	struct dyn_event devent;
	struct uprobe_consumer consumer;
	struct path path;
	char *filename;
	struct uprobe *uprobe;
	long unsigned int offset;
	long unsigned int ref_ctr_offset;
	long unsigned int *nhits;
	struct trace_probe tp;
};

struct tracefs_dir_ops {
	int (*mkdir)(const char *);
	int (*rmdir)(const char *);
};

struct tracefs_fs_info {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	unsigned int opts;
};

struct tracefs_inode {
	struct inode vfs_inode;
	struct list_head list;
	long unsigned int flags;
	void *private;
};

struct tracepoint_ext;

struct tracepoint {
	const char *name;
	struct static_key_false key;
	struct static_call_key *static_call_key;
	void *static_call_tramp;
	void *iterator;
	void *probestub;
	struct tracepoint_func *funcs;
	struct tracepoint_ext *ext;
};

struct tracepoint_ext {
	int (*regfunc)(void);
	void (*unregfunc)(void);
	unsigned int faultable: 1;
};

struct traceprobe_parse_context {
	struct trace_event_call *event;
	const char *funcname;
	const struct btf_type *proto;
	const struct btf_param *params;
	s32 nr_params;
	struct btf *btf;
	const struct btf_type *last_type;
	u32 last_bitoffs;
	u32 last_bitsize;
	struct trace_probe *tp;
	unsigned int flags;
	int offset;
};

struct tracer {
	const char *name;
	int (*init)(struct trace_array *);
	void (*reset)(struct trace_array *);
	void (*start)(struct trace_array *);
	void (*stop)(struct trace_array *);
	int (*update_thresh)(struct trace_array *);
	void (*open)(struct trace_iterator *);
	void (*pipe_open)(struct trace_iterator *);
	void (*close)(struct trace_iterator *);
	void (*pipe_close)(struct trace_iterator *);
	ssize_t (*read)(struct trace_iterator *, struct file *, char *, size_t, loff_t *);
	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*print_header)(struct seq_file *);
	enum print_line_t (*print_line)(struct trace_iterator *);
	int (*set_flag)(struct trace_array *, u32, u32, int);
	int (*flag_changed)(struct trace_array *, u32, int);
	struct tracer *next;
	struct tracer_flags *flags;
	int enabled;
	bool print_max;
	bool allow_instances;
	bool noboot;
};

struct tracer_flags {
	u32 val;
	struct tracer_opt *opts;
	struct tracer *trace;
};

struct tracer_opt {
	const char *name;
	u32 bit;
};

typedef int (*cmp_func_t)(const void *, const void *);

struct tracer_stat {
	const char *name;
	void * (*stat_start)(struct tracer_stat *);
	void * (*stat_next)(void *, int);
	cmp_func_t stat_cmp;
	int (*stat_show)(struct seq_file *, void *);
	void (*stat_release)(void *);
	int (*stat_headers)(struct seq_file *);
};

struct tracing_log_err {
	struct list_head list;
	struct err_info info;
	char loc[128];
	char *cmd;
};

struct track {
	long unsigned int addr;
	depot_stack_handle_t handle;
	int cpu;
	int pid;
	long unsigned int when;
};

struct trackpoint_attr_data {
	size_t field_offset;
	u8 command;
	u8 mask;
	bool inverted;
	u8 power_on_default;
};

struct trackpoint_data {
	u8 variant_id;
	u8 firmware_id;
	u8 sensitivity;
	u8 speed;
	u8 inertia;
	u8 reach;
	u8 draghys;
	u8 mindrag;
	u8 thresh;
	u8 upthresh;
	u8 ztime;
	u8 jenks;
	u8 drift_time;
	bool press_to_select;
	bool skipback;
	bool ext_dev;
};

struct trampoline_header {
	u64 start;
	u64 efer;
	u32 cr4;
	u32 flags;
	u32 lock;
};

struct transaction_chp_stats_s {
	long unsigned int cs_chp_time;
	__u32 cs_forced_to_close;
	__u32 cs_written;
	__u32 cs_dropped;
};

struct transaction_s {
	journal_t *t_journal;
	tid_t t_tid;
	enum {
		T_RUNNING = 0,
		T_LOCKED = 1,
		T_SWITCH = 2,
		T_FLUSH = 3,
		T_COMMIT = 4,
		T_COMMIT_DFLUSH = 5,
		T_COMMIT_JFLUSH = 6,
		T_COMMIT_CALLBACK = 7,
		T_FINISHED = 8,
	} t_state;
	long unsigned int t_log_start;
	int t_nr_buffers;
	struct journal_head *t_reserved_list;
	struct journal_head *t_buffers;
	struct journal_head *t_forget;
	struct journal_head *t_checkpoint_list;
	struct journal_head *t_shadow_list;
	struct list_head t_inode_list;
	long unsigned int t_max_wait;
	long unsigned int t_start;
	long unsigned int t_requested;
	struct transaction_chp_stats_s t_chp_stats;
	atomic_t t_updates;
	atomic_t t_outstanding_credits;
	atomic_t t_outstanding_revokes;
	atomic_t t_handle_count;
	transaction_t *t_cpnext;
	transaction_t *t_cpprev;
	long unsigned int t_expires;
	ktime_t t_start_time;
	unsigned int t_synchronous_commit: 1;
	int t_need_data_flush;
	struct list_head t_private_list;
};

struct trc_stall_chk_rdr {
	int nesting;
	int ipi_to_cpu;
	u8 needqs;
};

struct tree_block {
	struct {
		struct rb_node rb_node;
		u64 bytenr;
	};
	u64 owner;
	struct btrfs_key key;
	u8 level;
	bool key_ready;
};

typedef struct tree_desc_s tree_desc;

struct tree_descr {
	const char *name;
	const struct file_operations *ops;
	int mode;
};

struct tree_mod_root {
	u64 logical;
	u8 level;
};

struct tree_mod_elem {
	struct rb_node node;
	u64 logical;
	u64 seq;
	enum btrfs_mod_log_op op;
	int slot;
	u64 generation;
	struct btrfs_disk_key key;
	u64 blockptr;
	struct {
		int dst_slot;
		int nr_items;
	} move;
	struct tree_mod_root old_root;
};

struct trie_use_stats;

struct trie {
	struct key_vector kv[1];
	struct trie_use_stats *stats;
};

struct trie_stat {
	unsigned int totdepth;
	unsigned int maxdepth;
	unsigned int tnodes;
	unsigned int leaves;
	unsigned int nullpointers;
	unsigned int prefixes;
	unsigned int nodesizes[32];
};

struct trie_use_stats {
	unsigned int gets;
	unsigned int backtrack;
	unsigned int semantic_match_passed;
	unsigned int semantic_match_miss;
	unsigned int null_node_hit;
	unsigned int resize_node_skipped;
};

struct ts_bm {
	u8 *pattern;
	unsigned int patlen;
	unsigned int bad_shift[256];
	unsigned int good_shift[0];
};

struct ts_ops;

struct ts_state;

struct ts_config {
	struct ts_ops *ops;
	int flags;
	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
	void (*finish)(struct ts_config *, struct ts_state *);
};

struct ts_fsm_token {
	__u16 type;
	__u8 recur;
	__u8 value;
};

struct ts_fsm {
	unsigned int ntokens;
	struct ts_fsm_token tokens[0];
};

struct ts_kmp {
	u8 *pattern;
	unsigned int pattern_len;
	unsigned int prefix_tbl[0];
};

struct ts_linear_state {
	unsigned int len;
	const void *data;
};

struct ts_ops {
	const char *name;
	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
	unsigned int (*find)(struct ts_config *, struct ts_state *);
	void (*destroy)(struct ts_config *);
	void * (*get_pattern)(struct ts_config *);
	unsigned int (*get_pattern_len)(struct ts_config *);
	struct module *owner;
	struct list_head list;
};

struct ts_state {
	unsigned int offset;
	char cb[48];
};

struct tsc_adjust {
	s64 bootval;
	s64 adjusted;
	long unsigned int nextcheck;
	bool warned;
};

struct tsconfig_reply_data {
	struct ethnl_reply_data base;
	struct hwtstamp_provider_desc hwprov_desc;
	struct {
		u32 tx_type;
		u32 rx_filter;
		u32 flags;
	} hwtst_config;
};

struct tsconfig_req_info {
	struct ethnl_req_info base;
};

struct tsinfo_reply_data {
	struct ethnl_reply_data base;
	struct kernel_ethtool_ts_info ts_info;
	struct ethtool_ts_stats stats;
};

struct tsinfo_req_info {
	struct ethnl_req_info base;
	struct hwtstamp_provider_desc hwprov_desc;
};

struct tso_t {
	int next_frag_idx;
	int size;
	void *data;
	u16 ip_id;
	u8 tlen;
	bool ipv6;
	u32 tcp_seq;
};

struct tsq_tasklet {
	struct tasklet_struct tasklet;
	struct list_head head;
};

struct ttm_agp_backend {
	struct ttm_tt ttm;
	struct agp_memory *mem;
	struct agp_bridge_data *bridge;
};

struct ttm_lru_walk_ops;

struct ttm_operation_ctx;

struct ttm_lru_walk {
	const struct ttm_lru_walk_ops *ops;
	struct ttm_operation_ctx *ctx;
	struct ww_acquire_ctx *ticket;
	bool trylock_only;
};

struct ttm_place;

struct ttm_bo_evict_walk {
	struct ttm_lru_walk walk;
	const struct ttm_place *place;
	struct ttm_buffer_object *evictor;
	struct ttm_resource **res;
	long unsigned int evicted;
	struct dmem_cgroup_pool_state *limit_pool;
	bool try_low;
	bool hit_low;
};

struct ttm_bo_kmap_obj {
	void *virtual;
	struct page *page;
	enum {
		ttm_bo_map_iomap = 129,
		ttm_bo_map_vmap = 2,
		ttm_bo_map_kmap = 3,
		ttm_bo_map_premapped = 132,
	} bo_kmap_type;
	struct ttm_buffer_object *bo;
};

struct ttm_bo_swapout_walk {
	struct ttm_lru_walk walk;
	gfp_t gfp_flags;
	bool hit_low;
	bool evict_low;
};

struct ttm_placement;

struct ttm_device_funcs {
	struct ttm_tt * (*ttm_tt_create)(struct ttm_buffer_object *, uint32_t);
	int (*ttm_tt_populate)(struct ttm_device *, struct ttm_tt *, struct ttm_operation_ctx *);
	void (*ttm_tt_unpopulate)(struct ttm_device *, struct ttm_tt *);
	void (*ttm_tt_destroy)(struct ttm_device *, struct ttm_tt *);
	bool (*eviction_valuable)(struct ttm_buffer_object *, const struct ttm_place *);
	void (*evict_flags)(struct ttm_buffer_object *, struct ttm_placement *);
	int (*move)(struct ttm_buffer_object *, bool, struct ttm_operation_ctx *, struct ttm_resource *, struct ttm_place *);
	void (*delete_mem_notify)(struct ttm_buffer_object *);
	void (*swap_notify)(struct ttm_buffer_object *);
	int (*io_mem_reserve)(struct ttm_device *, struct ttm_resource *);
	void (*io_mem_free)(struct ttm_device *, struct ttm_resource *);
	long unsigned int (*io_mem_pfn)(struct ttm_buffer_object *, long unsigned int);
	int (*access_memory)(struct ttm_buffer_object *, long unsigned int, void *, int, int);
	void (*release_notify)(struct ttm_buffer_object *);
};

struct ttm_global {
	struct page *dummy_read_page;
	struct list_head device_list;
	atomic_t bo_count;
};

struct ttm_kmap_iter_linear_io {
	struct ttm_kmap_iter base;
	struct iosys_map dmap;
	bool needs_unmap;
};

struct ttm_kmap_iter_ops {
	void (*map_local)(struct ttm_kmap_iter *, struct iosys_map *, long unsigned int);
	void (*unmap_local)(struct ttm_kmap_iter *, struct iosys_map *);
	bool maps_tt;
};

struct ttm_lru_bulk_move_pos {
	struct ttm_resource *first;
	struct ttm_resource *last;
};

struct ttm_lru_bulk_move {
	struct ttm_lru_bulk_move_pos pos[32];
	struct list_head cursor_list;
};

struct ttm_lru_walk_ops {
	s64 (*process_bo)(struct ttm_lru_walk *, struct ttm_buffer_object *);
};

struct ttm_operation_ctx {
	bool interruptible;
	bool no_wait_gpu;
	bool gfp_retry_mayfail;
	bool allow_res_evict;
	bool force_alloc;
	struct dma_resv *resv;
	uint64_t bytes_moved;
};

struct ttm_place {
	unsigned int fpfn;
	unsigned int lpfn;
	uint32_t mem_type;
	uint32_t flags;
};

struct ttm_placement {
	unsigned int num_placement;
	const struct ttm_place *placement;
};

struct ttm_pool_dma {
	dma_addr_t addr;
	long unsigned int vaddr;
};

struct ttm_range_manager {
	struct ttm_resource_manager manager;
	struct drm_mm mm;
	spinlock_t lock;
};

struct ttm_range_mgr_node {
	struct ttm_resource base;
	struct drm_mm_node mm_nodes[0];
};

struct ttm_resource_cursor {
	struct ttm_resource_manager *man;
	struct ttm_lru_item hitch;
	struct list_head bulk_link;
	struct ttm_lru_bulk_move *bulk;
	unsigned int mem_type;
	unsigned int priority;
};

struct ttm_resource_manager_func {
	int (*alloc)(struct ttm_resource_manager *, struct ttm_buffer_object *, const struct ttm_place *, struct ttm_resource **);
	void (*free)(struct ttm_resource_manager *, struct ttm_resource *);
	bool (*intersects)(struct ttm_resource_manager *, struct ttm_resource *, const struct ttm_place *, size_t);
	bool (*compatible)(struct ttm_resource_manager *, struct ttm_resource *, const struct ttm_place *, size_t);
	void (*debug)(struct ttm_resource_manager *, struct drm_printer *);
};

struct ttm_transfer_obj {
	struct ttm_buffer_object base;
	struct ttm_buffer_object *bo;
};

struct ttm_validate_buffer {
	struct list_head head;
	struct ttm_buffer_object *bo;
	unsigned int num_shared;
};

struct tty_audit_buf {
	struct mutex mutex;
	dev_t dev;
	bool icanon;
	size_t valid;
	u8 *data;
};

struct tty_operations;

struct tty_driver {
	struct kref kref;
	struct cdev **cdevs;
	struct module *owner;
	const char *driver_name;
	const char *name;
	int name_base;
	int major;
	int minor_start;
	unsigned int num;
	short int type;
	short int subtype;
	struct ktermios init_termios;
	long unsigned int flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;
	const struct tty_operations *ops;
	struct list_head tty_drivers;
};

struct tty_file_private {
	struct tty_struct *tty;
	struct file *file;
	struct list_head list;
};

struct tty_ldisc_ops;

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};

struct tty_ldisc_ops {
	char *name;
	int num;
	int (*open)(struct tty_struct *);
	void (*close)(struct tty_struct *);
	void (*flush_buffer)(struct tty_struct *);
	ssize_t (*read)(struct tty_struct *, struct file *, u8 *, size_t, void **, long unsigned int);
	ssize_t (*write)(struct tty_struct *, struct file *, const u8 *, size_t);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, const struct ktermios *);
	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
	void (*hangup)(struct tty_struct *);
	void (*receive_buf)(struct tty_struct *, const u8 *, const u8 *, size_t);
	void (*write_wakeup)(struct tty_struct *);
	void (*dcd_change)(struct tty_struct *, bool);
	size_t (*receive_buf2)(struct tty_struct *, const u8 *, const u8 *, size_t);
	void (*lookahead_buf)(struct tty_struct *, const u8 *, const u8 *, size_t);
	struct module *owner;
};

struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
	int (*install)(struct tty_driver *, struct tty_struct *);
	void (*remove)(struct tty_driver *, struct tty_struct *);
	int (*open)(struct tty_struct *, struct file *);
	void (*close)(struct tty_struct *, struct file *);
	void (*shutdown)(struct tty_struct *);
	void (*cleanup)(struct tty_struct *);
	ssize_t (*write)(struct tty_struct *, const u8 *, size_t);
	int (*put_char)(struct tty_struct *, u8);
	void (*flush_chars)(struct tty_struct *);
	unsigned int (*write_room)(struct tty_struct *);
	unsigned int (*chars_in_buffer)(struct tty_struct *);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, const struct ktermios *);
	void (*throttle)(struct tty_struct *);
	void (*unthrottle)(struct tty_struct *);
	void (*stop)(struct tty_struct *);
	void (*start)(struct tty_struct *);
	void (*hangup)(struct tty_struct *);
	int (*break_ctl)(struct tty_struct *, int);
	void (*flush_buffer)(struct tty_struct *);
	int (*ldisc_ok)(struct tty_struct *, int);
	void (*set_ldisc)(struct tty_struct *);
	void (*wait_until_sent)(struct tty_struct *, int);
	void (*send_xchar)(struct tty_struct *, u8);
	int (*tiocmget)(struct tty_struct *);
	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
	int (*resize)(struct tty_struct *, struct winsize *);
	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
	int (*get_serial)(struct tty_struct *, struct serial_struct *);
	int (*set_serial)(struct tty_struct *, struct serial_struct *);
	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
	int (*proc_show)(struct seq_file *, void *);
};

struct tty_port_client_operations {
	size_t (*receive_buf)(struct tty_port *, const u8 *, const u8 *, size_t);
	void (*lookahead_buf)(struct tty_port *, const u8 *, const u8 *, size_t);
	void (*write_wakeup)(struct tty_port *);
};

struct tty_port_operations {
	bool (*carrier_raised)(struct tty_port *);
	void (*dtr_rts)(struct tty_port *, bool);
	void (*shutdown)(struct tty_port *);
	int (*activate)(struct tty_port *, struct tty_struct *);
	void (*destruct)(struct tty_port *);
};

struct tty_struct {
	struct kref kref;
	int index;
	struct device *dev;
	struct tty_driver *driver;
	struct tty_port *port;
	const struct tty_operations *ops;
	struct tty_ldisc *ldisc;
	struct ld_semaphore ldisc_sem;
	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	struct ktermios termios;
	struct ktermios termios_locked;
	char name[64];
	long unsigned int flags;
	int count;
	unsigned int receive_room;
	struct winsize winsize;
	struct {
		spinlock_t lock;
		bool stopped;
		bool tco_stopped;
	} flow;
	struct {
		struct pid *pgrp;
		struct pid *session;
		spinlock_t lock;
		unsigned char pktstatus;
		bool packet;
	} ctrl;
	bool hw_stopped;
	bool closing;
	int flow_change;
	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	int write_cnt;
	u8 *write_buf;
	struct list_head tty_files;
	struct work_struct SAK_work;
};

struct tun_msg_ctl {
	short unsigned int type;
	short unsigned int num;
	void *ptr;
};

struct virtio_net_hdr {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	__virtio16 csum_start;
	__virtio16 csum_offset;
};

struct tun_xdp_hdr {
	int buflen;
	struct virtio_net_hdr gso;
};

struct tunnel_msg {
	__u8 family;
	__u8 flags;
	__u16 reserved2;
	__u32 ifindex;
};

struct tuple_flags {
	u_int link_space: 4;
	u_int has_link: 1;
	u_int mfc_fn: 3;
	u_int space: 4;
};

struct tuple_t {
	u_int Attributes;
	cisdata_t DesiredTuple;
	u_int Flags;
	u_int LinkOffset;
	u_int CISOffset;
	cisdata_t TupleCode;
	cisdata_t TupleLink;
	cisdata_t TupleOffset;
	cisdata_t TupleDataMax;
	cisdata_t TupleDataLen;
	cisdata_t *TupleData;
};

struct video_levels;

struct tv_mode {
	const char *name;
	u32 clock;
	u16 refresh;
	u8 oversample;
	u8 hsync_end;
	u16 hblank_start;
	u16 hblank_end;
	u16 htotal;
	bool progressive: 1;
	bool trilevel_sync: 1;
	bool component_only: 1;
	u8 vsync_start_f1;
	u8 vsync_start_f2;
	u8 vsync_len;
	bool veq_ena: 1;
	u8 veq_start_f1;
	u8 veq_start_f2;
	u8 veq_len;
	u8 vi_end_f1;
	u8 vi_end_f2;
	u16 nbr_end;
	bool burst_ena: 1;
	u8 hburst_start;
	u8 hburst_len;
	u8 vburst_start_f1;
	u16 vburst_end_f1;
	u8 vburst_start_f2;
	u16 vburst_end_f2;
	u8 vburst_start_f3;
	u16 vburst_end_f3;
	u8 vburst_start_f4;
	u16 vburst_end_f4;
	u16 dda2_size;
	u16 dda3_size;
	u8 dda1_inc;
	u16 dda2_inc;
	u16 dda3_inc;
	u32 sc_reset;
	bool pal_burst: 1;
	const struct video_levels *composite_levels;
	const struct video_levels *svideo_levels;
	const struct color_conversion *composite_color;
	const struct color_conversion *svideo_color;
	const u32 *filter_table;
};

struct uart_8250_em485 {
	struct hrtimer start_tx_timer;
	struct hrtimer stop_tx_timer;
	struct hrtimer *active_timer;
	struct uart_8250_port *port;
	unsigned int tx_stopped: 1;
};

struct uart_8250_ops {
	int (*setup_irq)(struct uart_8250_port *);
	void (*release_irq)(struct uart_8250_port *);
	void (*setup_timer)(struct uart_8250_port *);
};

struct mctrl_gpios;

struct uart_8250_port {
	struct uart_port port;
	struct timer_list timer;
	struct list_head list;
	u32 capabilities;
	u16 bugs;
	unsigned int tx_loadsz;
	unsigned char acr;
	unsigned char fcr;
	unsigned char ier;
	unsigned char lcr;
	unsigned char mcr;
	unsigned char cur_iotype;
	unsigned int rpm_tx_active;
	unsigned char canary;
	unsigned char probe;
	struct mctrl_gpios *gpios;
	u16 lsr_saved_flags;
	u16 lsr_save_mask;
	unsigned char msr_saved_flags;
	struct uart_8250_dma *dma;
	const struct uart_8250_ops *ops;
	u32 (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, u32);
	struct uart_8250_em485 *em485;
	void (*rs485_start_tx)(struct uart_8250_port *, bool);
	void (*rs485_stop_tx)(struct uart_8250_port *, bool);
	struct delayed_work overrun_backoff;
	u32 overrun_backoff_time_ms;
};

struct uart_driver {
	struct module *owner;
	const char *driver_name;
	const char *dev_name;
	int major;
	int minor;
	int nr;
	struct console *cons;
	struct uart_state *state;
	struct tty_driver *tty_driver;
};

struct uart_match {
	struct uart_port *port;
	struct uart_driver *driver;
};

struct uart_ops {
	unsigned int (*tx_empty)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*stop_tx)(struct uart_port *);
	void (*start_tx)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	void (*send_xchar)(struct uart_port *, char);
	void (*stop_rx)(struct uart_port *);
	void (*start_rx)(struct uart_port *);
	void (*enable_ms)(struct uart_port *);
	void (*break_ctl)(struct uart_port *, int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*flush_buffer)(struct uart_port *);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	const char * (*type)(struct uart_port *);
	void (*release_port)(struct uart_port *);
	int (*request_port)(struct uart_port *);
	void (*config_port)(struct uart_port *, int);
	int (*verify_port)(struct uart_port *, struct serial_struct *);
	int (*ioctl)(struct uart_port *, unsigned int, long unsigned int);
};

struct uart_state {
	struct tty_port port;
	enum uart_pm_state pm_state;
	atomic_t refcount;
	wait_queue_head_t remove_wait;
	struct uart_port *uart_port;
};

struct ubuf_info_msgzc {
	struct ubuf_info ubuf;
	union {
		struct {
			long unsigned int desc;
			void *ctx;
		};
		struct {
			u32 id;
			u16 len;
			u16 zerocopy: 1;
			u32 bytelen;
		};
	};
	struct mmpin mmp;
};

struct ubuf_info_ops {
	void (*complete)(struct sk_buff *, struct ubuf_info *, bool);
	int (*link_skb)(struct sk_buff *, struct ubuf_info *);
};

struct uc_css_header {
	u32 module_type;
	u32 header_size_dw;
	u32 header_version;
	u32 module_id;
	u32 module_vendor;
	u32 date;
	u32 size_dw;
	u32 key_size_dw;
	u32 modulus_size_dw;
	u32 exponent_size_dw;
	u32 time;
	char username[8];
	char buildnumber[12];
	u32 sw_version;
	u32 vf_version;
	u32 reserved0[12];
	union {
		u32 private_data_size;
		u32 reserved1;
	};
	u32 header_info;
};

struct uc_fw_blob {
	const char *path;
	bool legacy;
	u8 major;
	u8 minor;
	u8 patch;
	bool has_gsc_headers;
} __attribute__((packed));

struct uc_fw_platform_requirement {
	enum intel_platform p;
	u8 rev;
	const struct uc_fw_blob blob;
} __attribute__((packed));

union ucmd_buffer {
	struct iommu_destroy destroy;
	struct iommu_fault_alloc fault;
	struct iommu_hw_info info;
	struct iommu_hwpt_alloc hwpt;
	struct iommu_hwpt_get_dirty_bitmap get_dirty_bitmap;
	struct iommu_hwpt_invalidate cache;
	struct iommu_hwpt_set_dirty_tracking set_dirty_tracking;
	struct iommu_ioas_alloc alloc;
	struct iommu_ioas_allow_iovas allow_iovas;
	struct iommu_ioas_copy ioas_copy;
	struct iommu_ioas_iova_ranges iova_ranges;
	struct iommu_ioas_map map;
	struct iommu_ioas_unmap unmap;
	struct iommu_option option;
	struct iommu_vdevice_alloc vdev;
	struct iommu_vfio_ioas vfio_ioas;
	struct iommu_viommu_alloc viommu;
};

struct ucode_cpu_info {
	struct cpu_signature cpu_sig;
	void *mc;
};

struct ucode_patch {
	struct list_head plist;
	void *data;
	unsigned int size;
	u32 patch_id;
	u16 equiv_cpu;
};

struct ucounts {
	struct hlist_node node;
	struct user_namespace *ns;
	kuid_t uid;
	atomic_t count;
	atomic_long_t ucount[10];
	atomic_long_t rlimit[4];
};

struct ucred {
	__u32 pid;
	__u32 uid;
	__u32 gid;
};

struct udp_sock {
	struct inet_sock inet;
	long unsigned int udp_flags;
	int pending;
	__u8 encap_type;
	__u16 udp_lrpa_hash;
	struct hlist_nulls_node udp_lrpa_node;
	__u16 len;
	__u16 gso_size;
	__u16 pcslen;
	__u16 pcrlen;
	int (*encap_rcv)(struct sock *, struct sk_buff *);
	void (*encap_err_rcv)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
	void (*encap_destroy)(struct sock *);
	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sock *, struct sk_buff *, int);
	long: 64;
	struct sk_buff_head reader_queue;
	int forward_deficit;
	int forward_threshold;
	bool peeking_with_offset;
	long: 64;
	long: 64;
	long: 64;
};

struct udp6_sock {
	struct udp_sock udp;
	struct ipv6_pinfo inet6;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct udp_media_addr {
	__be16 proto;
	__be16 port;
	union {
		struct in_addr ipv4;
		struct in6_addr ipv6;
	};
};

struct udp_replicast {
	struct udp_media_addr addr;
	struct dst_cache dst_cache;
	struct callback_head rcu;
	struct list_head list;
};

struct udp_bearer {
	struct tipc_bearer *bearer;
	struct socket *ubsock;
	u32 ifindex;
	struct work_struct work;
	struct udp_replicast rcast;
};

struct udp_dev_scratch {
	u32 _tsize_state;
	u16 len;
	bool is_linear;
	bool csum_unnecessary;
};

struct udp_hslot {
	union {
		struct hlist_head head;
		struct hlist_nulls_head nulls_head;
	};
	int count;
	spinlock_t lock;
};

struct udp_hslot_main {
	struct udp_hslot hslot;
	u32 hash4_cnt;
	long: 64;
};

struct udp_mib {
	long unsigned int mibs[10];
};

struct udp_port_cfg {
	u8 family;
	union {
		struct in_addr local_ip;
		struct in6_addr local_ip6;
	};
	union {
		struct in_addr peer_ip;
		struct in6_addr peer_ip6;
	};
	__be16 local_udp_port;
	__be16 peer_udp_port;
	int bind_ifindex;
	unsigned int use_udp_checksums: 1;
	unsigned int use_udp6_tx_checksums: 1;
	unsigned int use_udp6_rx_checksums: 1;
	unsigned int ipv6_v6only: 1;
};

struct udp_seq_afinfo {
	sa_family_t family;
	struct udp_table *udp_table;
};

struct udp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u16 cscov;
	__u8 partial_cov;
};

struct udp_table {
	struct udp_hslot *hash;
	struct udp_hslot_main *hash2;
	struct udp_hslot *hash4;
	unsigned int mask;
	unsigned int log;
};

struct udp_tunnel_info {
	short unsigned int type;
	sa_family_t sa_family;
	__be16 port;
	u8 hw_priv;
};

struct udp_tunnel_nic_table_entry;

struct udp_tunnel_nic {
	struct work_struct work;
	struct net_device *dev;
	u8 need_sync: 1;
	u8 need_replay: 1;
	u8 work_pending: 1;
	unsigned int n_tables;
	long unsigned int missed;
	struct udp_tunnel_nic_table_entry *entries[0];
};

struct udp_tunnel_nic_table_info {
	unsigned int n_entries;
	unsigned int tunnel_types;
};

struct udp_tunnel_nic_shared;

struct udp_tunnel_nic_info {
	int (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*sync_table)(struct net_device *, unsigned int);
	struct udp_tunnel_nic_shared *shared;
	unsigned int flags;
	struct udp_tunnel_nic_table_info tables[4];
};

struct udp_tunnel_nic_ops {
	void (*get_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	void (*set_port_priv)(struct net_device *, unsigned int, unsigned int, u8);
	void (*add_port)(struct net_device *, struct udp_tunnel_info *);
	void (*del_port)(struct net_device *, struct udp_tunnel_info *);
	void (*reset_ntf)(struct net_device *);
	size_t (*dump_size)(struct net_device *, unsigned int);
	int (*dump_write)(struct net_device *, unsigned int, struct sk_buff *);
};

struct udp_tunnel_nic_shared {
	struct udp_tunnel_nic *udp_tunnel_nic_info;
	struct list_head devices;
};

struct udp_tunnel_nic_shared_node {
	struct net_device *dev;
	struct list_head list;
};

struct udp_tunnel_nic_table_entry {
	__be16 port;
	u8 type;
	u8 flags;
	u16 use_cnt;
	u8 hw_priv;
};

typedef int (*udp_tunnel_encap_rcv_t)(struct sock *, struct sk_buff *);

typedef int (*udp_tunnel_encap_err_lookup_t)(struct sock *, struct sk_buff *);

typedef void (*udp_tunnel_encap_err_rcv_t)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);

typedef void (*udp_tunnel_encap_destroy_t)(struct sock *);

typedef struct sk_buff * (*udp_tunnel_gro_receive_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef int (*udp_tunnel_gro_complete_t)(struct sock *, struct sk_buff *, int);

struct udp_tunnel_sock_cfg {
	void *sk_user_data;
	__u8 encap_type;
	udp_tunnel_encap_rcv_t encap_rcv;
	udp_tunnel_encap_err_lookup_t encap_err_lookup;
	udp_tunnel_encap_err_rcv_t encap_err_rcv;
	udp_tunnel_encap_destroy_t encap_destroy;
	udp_tunnel_gro_receive_t gro_receive;
	udp_tunnel_gro_complete_t gro_complete;
};

struct uevent_sock {
	struct list_head list;
	struct sock *sk;
};

struct ulist_iterator {
	struct list_head *cur_list;
};

struct ulist_node {
	u64 val;
	u64 aux;
	struct list_head list;
	struct rb_node rb_node;
};

struct uncached_list {
	spinlock_t lock;
	struct list_head head;
};

struct uncharge_gather {
	struct mem_cgroup *memcg;
	long unsigned int nr_memory;
	long unsigned int pgpgout;
	long unsigned int nr_kmem;
	int nid;
};

struct uncore_event_desc {
	struct device_attribute attr;
	const char *config;
};

struct uncore_global_discovery {
	union {
		u64 table1;
		struct {
			u64 type: 8;
			u64 stride: 8;
			u64 max_units: 10;
			u64 __reserved_1: 36;
			u64 access_type: 2;
		};
	};
	u64 ctl;
	union {
		u64 table3;
		struct {
			u64 status_offset: 8;
			u64 num_status: 16;
			u64 __reserved_2: 40;
		};
	};
};

struct uncore_iio_topology {
	int pci_bus_no;
	int segment;
};

struct uncore_unit_discovery {
	union {
		u64 table1;
		struct {
			u64 num_regs: 8;
			u64 ctl_offset: 8;
			u64 bit_width: 8;
			u64 ctr_offset: 8;
			u64 status_offset: 8;
			u64 __reserved_1: 22;
			u64 access_type: 2;
		};
	};
	u64 ctl;
	union {
		u64 table3;
		struct {
			u64 box_type: 16;
			u64 box_id: 16;
			u64 __reserved_2: 32;
		};
	};
};

struct uncore_upi_topology {
	int die_to;
	int pmu_idx_to;
	int enabled;
};

struct uni_pagedict {
	u16 **uni_pgdir[32];
	long unsigned int refcount;
	long unsigned int sum;
	unsigned char *inverse_translations[4];
	u16 *inverse_trans_unicode;
};

struct unipair;

struct unimapdesc {
	short unsigned int entry_ct;
	struct unipair *entries;
};

struct unipair {
	short unsigned int unicode;
	short unsigned int fontpos;
};

struct unity_map_entry {
	struct list_head list;
	u16 devid_start;
	u16 devid_end;
	u64 address_start;
	u64 address_end;
	int prot;
};

struct unix_address {
	refcount_t refcnt;
	int len;
	struct sockaddr_un name[0];
};

struct unix_diag_msg {
	__u8 udiag_family;
	__u8 udiag_type;
	__u8 udiag_state;
	__u8 pad;
	__u32 udiag_ino;
	__u32 udiag_cookie[2];
};

struct unix_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 udiag_states;
	__u32 udiag_ino;
	__u32 udiag_show;
	__u32 udiag_cookie[2];
};

struct unix_diag_rqlen {
	__u32 udiag_rqueue;
	__u32 udiag_wqueue;
};

struct unix_diag_vfs {
	__u32 udiag_vfs_ino;
	__u32 udiag_vfs_dev;
};

struct unix_domain {
	struct auth_domain h;
};

struct unix_edge {
	struct unix_sock *predecessor;
	struct unix_sock *successor;
	struct list_head vertex_entry;
	struct list_head stack_entry;
};

struct unix_gid {
	struct cache_head h;
	kuid_t uid;
	struct group_info *gi;
	struct callback_head rcu;
};

struct unix_skb_parms {
	struct pid *pid;
	kuid_t uid;
	kgid_t gid;
	struct scm_fp_list *fp;
	u32 secid;
	u32 consumed;
};

struct unix_vertex;

struct unix_sock {
	struct sock sk;
	struct unix_address *addr;
	struct path path;
	struct mutex iolock;
	struct mutex bindlock;
	struct sock *peer;
	struct sock *listener;
	struct unix_vertex *vertex;
	spinlock_t lock;
	long: 64;
	struct socket_wq peer_wq;
	wait_queue_entry_t peer_wake;
	struct scm_stat scm_stat;
	struct sk_buff *oob_skb;
};

struct unix_stream_read_state {
	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
	struct socket *socket;
	struct msghdr *msg;
	struct pipe_inode_info *pipe;
	size_t size;
	int flags;
	unsigned int splice_flags;
};

struct unix_vertex {
	struct list_head edges;
	struct list_head entry;
	struct list_head scc_entry;
	long unsigned int out_degree;
	long unsigned int index;
	long unsigned int scc_index;
};

struct unlink_vma_file_batch {
	int count;
	struct vm_area_struct *vmas[8];
};

struct unwind_state {
	struct stack_info stack_info;
	long unsigned int stack_mask;
	struct task_struct *task;
	int graph_idx;
	struct llist_node *kr_cur;
	bool error;
	bool signal;
	bool full_regs;
	long unsigned int sp;
	long unsigned int bp;
	long unsigned int ip;
	struct pt_regs *regs;
	struct pt_regs *prev_regs;
};

struct update_classid_context {
	u32 classid;
	unsigned int batch;
};

union upper_chunk {
	union upper_chunk *next;
	union lower_chunk *data[256];
};

struct uprobe {
	struct rb_node rb_node;
	refcount_t ref;
	struct rw_semaphore register_rwsem;
	struct rw_semaphore consumer_rwsem;
	struct list_head pending_list;
	struct list_head consumers;
	struct inode *inode;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
	loff_t offset;
	loff_t ref_ctr_offset;
	long unsigned int flags;
	struct arch_uprobe arch;
};

struct uprobe_cpu_buffer {
	struct mutex mutex;
	void *buf;
	int dsize;
};

struct uprobe_dispatch_data {
	struct trace_uprobe *tu;
	long unsigned int bp_addr;
};

struct uprobe_task {
	enum uprobe_task_state state;
	unsigned int depth;
	struct return_instance *return_instances;
	struct return_instance *ri_pool;
	struct timer_list ri_timer;
	seqcount_t ri_seqcount;
	union {
		struct {
			struct arch_uprobe_task autask;
			long unsigned int vaddr;
		};
		struct {
			struct callback_head dup_xol_work;
			long unsigned int dup_xol_addr;
		};
	};
	struct uprobe *active_uprobe;
	long unsigned int xol_vaddr;
	struct arch_uprobe *auprobe;
};

struct uprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int vaddr[0];
};

struct uprobe_xol_ops {
	bool (*emulate)(struct arch_uprobe *, struct pt_regs *);
	int (*pre_xol)(struct arch_uprobe *, struct pt_regs *);
	int (*post_xol)(struct arch_uprobe *, struct pt_regs *);
	void (*abort)(struct arch_uprobe *, struct pt_regs *);
};

struct usb_ctrlrequest {
	__u8 bRequestType;
	__u8 bRequest;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

struct usb_debug_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDebugInEndpoint;
	__u8 bDebugOutEndpoint;
};

struct used_address {
	struct __kernel_sockaddr_storage name;
	unsigned int name_len;
};

struct user_arg_ptr {
	union {
		const char * const *native;
	} ptr;
};

struct user_desc {
	unsigned int entry_number;
	unsigned int base_addr;
	unsigned int limit;
	unsigned int seg_32bit: 1;
	unsigned int contents: 2;
	unsigned int read_exec_only: 1;
	unsigned int limit_in_pages: 1;
	unsigned int seg_not_present: 1;
	unsigned int useable: 1;
	unsigned int lm: 1;
};

struct user_i387_ia32_struct {
	u32 cwd;
	u32 swd;
	u32 twd;
	u32 fip;
	u32 fcs;
	u32 foo;
	u32 fos;
	u32 st_space[20];
};

struct user_key_payload {
	struct callback_head rcu;
	short unsigned int datalen;
	long: 0;
	char data[0];
};

struct user_namespace {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	struct user_namespace *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common ns;
	long unsigned int flags;
	bool parent_could_setfcap;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts *ucounts;
	long int ucount_max[10];
	long int rlimit_max[4];
	struct binfmt_misc *binfmt_misc;
};

struct user_regset;

typedef int user_regset_get2_fn(struct task_struct *, const struct user_regset *, struct membuf);

typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void *);

typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);

typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);

struct user_regset {
	user_regset_get2_fn *regset_get;
	user_regset_set_fn *set;
	user_regset_active_fn *active;
	user_regset_writeback_fn *writeback;
	unsigned int n;
	unsigned int size;
	unsigned int align;
	unsigned int bias;
	unsigned int core_note_type;
};

struct user_regset_view {
	const char *name;
	const struct user_regset *regsets;
	unsigned int n;
	u32 e_flags;
	u16 e_machine;
	u8 ei_osabi;
};

struct user_return_notifier {
	void (*on_user_return)(struct user_return_notifier *);
	struct hlist_node link;
};

struct user_struct {
	refcount_t __count;
	struct percpu_counter epoll_watches;
	long unsigned int unix_inflight;
	atomic_long_t pipe_bufs;
	struct hlist_node uidhash_node;
	kuid_t uid;
	atomic_long_t locked_vm;
	struct ratelimit_state ratelimit;
};

struct user_threshold {
	struct list_head list_node;
	int temperature;
	int direction;
};

struct userspace_policy {
	unsigned int is_managed;
	unsigned int setspeed;
	struct mutex mutex;
};

struct userstack_entry {
	struct trace_entry ent;
	unsigned int tgid;
	long unsigned int caller[8];
};

struct ustat {
	__kernel_daddr_t f_tfree;
	long unsigned int f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct ustring_buffer {
	char buffer[1024];
};

struct utf8_table {
	int cmask;
	int cval;
	int shift;
	long int lmask;
	long int lval;
};

struct utimbuf {
	__kernel_old_time_t actime;
	__kernel_old_time_t modtime;
};

struct uts_namespace {
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

union uu {
	short unsigned int us;
	unsigned char b[2];
};

struct uuidcmp {
	const char *uuid;
	int len;
};

struct v2_disk_dqheader {
	__le32 dqh_magic;
	__le32 dqh_version;
};

struct v2_disk_dqinfo {
	__le32 dqi_bgrace;
	__le32 dqi_igrace;
	__le32 dqi_flags;
	__le32 dqi_blocks;
	__le32 dqi_free_blk;
	__le32 dqi_free_entry;
};

struct v2r0_disk_dqblk {
	__le32 dqb_id;
	__le32 dqb_ihardlimit;
	__le32 dqb_isoftlimit;
	__le32 dqb_curinodes;
	__le32 dqb_bhardlimit;
	__le32 dqb_bsoftlimit;
	__le64 dqb_curspace;
	__le64 dqb_btime;
	__le64 dqb_itime;
};

struct v2r1_disk_dqblk {
	__le32 dqb_id;
	__le32 dqb_pad;
	__le64 dqb_ihardlimit;
	__le64 dqb_isoftlimit;
	__le64 dqb_curinodes;
	__le64 dqb_bhardlimit;
	__le64 dqb_bsoftlimit;
	__le64 dqb_curspace;
	__le64 dqb_btime;
	__le64 dqb_itime;
};

struct v9fs_inode {
	struct netfs_inode netfs;
	struct p9_qid qid;
	unsigned int cache_validity;
	struct mutex v_mutex;
};

struct v9fs_session_info {
	unsigned int flags;
	unsigned char nodev;
	short unsigned int debug;
	unsigned int afid;
	unsigned int cache;
	char *uname;
	char *aname;
	unsigned int maxdata;
	kuid_t dfltuid;
	kgid_t dfltgid;
	kuid_t uid;
	struct p9_client *clnt;
	struct list_head slist;
	struct rw_semaphore rename_sem;
	long int session_lock_timeout;
};

struct va_alignment {
	int flags;
	long unsigned int mask;
	long unsigned int bits;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct va_format {
	const char *fmt;
	va_list *va;
};

struct value_name_pair {
	int value;
	const char *name;
};

struct var_mtrr_range_state {
	long unsigned int base_pfn;
	long unsigned int size_pfn;
	mtrr_type type;
};

struct var_mtrr_state {
	long unsigned int range_startk;
	long unsigned int range_sizek;
	long unsigned int chunk_sizek;
	long unsigned int gran_sizek;
	unsigned int reg;
};

struct variable_validate {
	efi_guid_t vendor;
	char *name;
	bool (*validate)(efi_char16_t *, int, u8 *, long unsigned int);
};

struct vbt_header {
	u8 signature[20];
	u16 version;
	u16 header_size;
	u16 vbt_size;
	u8 vbt_checksum;
	u8 reserved0;
	u32 bdb_offset;
	u32 aim_offset[4];
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;
};

struct vc_state {
	unsigned int x;
	unsigned int y;
	unsigned char color;
	unsigned char Gx_charset[2];
	unsigned int charset: 1;
	enum vc_intensity intensity;
	bool italic;
	bool underline;
	bool blink;
	bool reverse;
};

struct vt_mode {
	char mode;
	char waitv;
	short int relsig;
	short int acqsig;
	short int frsig;
};

struct vc_data {
	struct tty_port port;
	struct vc_state state;
	struct vc_state saved_state;
	short unsigned int vc_num;
	unsigned int vc_cols;
	unsigned int vc_rows;
	unsigned int vc_size_row;
	unsigned int vc_scan_lines;
	unsigned int vc_cell_height;
	long unsigned int vc_origin;
	long unsigned int vc_scr_end;
	long unsigned int vc_visible_origin;
	unsigned int vc_top;
	unsigned int vc_bottom;
	const struct consw *vc_sw;
	short unsigned int *vc_screenbuf;
	unsigned int vc_screenbuf_size;
	unsigned char vc_mode;
	unsigned char vc_attr;
	unsigned char vc_def_color;
	unsigned char vc_ulcolor;
	unsigned char vc_itcolor;
	unsigned char vc_halfcolor;
	unsigned int vc_cursor_type;
	short unsigned int vc_complement_mask;
	short unsigned int vc_s_complement_mask;
	long unsigned int vc_pos;
	short unsigned int vc_hi_font_mask;
	struct console_font vc_font;
	short unsigned int vc_video_erase_char;
	unsigned int vc_state;
	unsigned int vc_npar;
	unsigned int vc_par[16];
	struct vt_mode vt_mode;
	struct pid *vt_pid;
	int vt_newvt;
	wait_queue_head_t paste_wait;
	unsigned int vc_disp_ctrl: 1;
	unsigned int vc_toggle_meta: 1;
	unsigned int vc_decscnm: 1;
	unsigned int vc_decom: 1;
	unsigned int vc_decawm: 1;
	unsigned int vc_deccm: 1;
	unsigned int vc_decim: 1;
	unsigned int vc_priv: 3;
	unsigned int vc_need_wrap: 1;
	unsigned int vc_can_do_color: 1;
	unsigned int vc_report_mouse: 2;
	unsigned char vc_utf: 1;
	unsigned char vc_utf_count;
	int vc_utf_char;
	long unsigned int vc_tab_stop[4];
	unsigned char vc_palette[48];
	short unsigned int *vc_translate;
	unsigned int vc_bell_pitch;
	unsigned int vc_bell_duration;
	short unsigned int vc_cur_blink_ms;
	struct vc_data **vc_display_fg;
	struct uni_pagedict *uni_pagedict;
	struct uni_pagedict **uni_pagedict_loc;
	u32 **vc_uni_lines;
};

struct vc_draw_region {
	long unsigned int from;
	long unsigned int to;
	int x;
};

struct vc_selection {
	struct mutex lock;
	struct vc_data *cons;
	char *buffer;
	unsigned int buf_len;
	volatile int start;
	int end;
};

struct vcc_state {
	int bucket;
	struct sock *sk;
};

struct vcs_poll_data {
	struct notifier_block notifier;
	unsigned int cons_num;
	int event;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
};

struct vdso_timestamp {
	u64 sec;
	u64 nsec;
};

struct vdso_data {
	u32 seq;
	s32 clock_mode;
	u64 cycle_last;
	u64 max_cycles;
	u64 mask;
	u32 mult;
	u32 shift;
	union {
		struct vdso_timestamp basetime[12];
		struct timens_offset offset[12];
	};
	s32 tz_minuteswest;
	s32 tz_dsttime;
	u32 hrtimer_res;
	u32 __unused;
	struct arch_vdso_time_data arch_data;
};

union vdso_data_store {
	struct vdso_data data[2];
	u8 page[4096];
};

struct vdso_exception_table_entry {
	int insn;
	int fixup;
};

struct vdso_image {
	void *data;
	long unsigned int size;
	long unsigned int alt;
	long unsigned int alt_len;
	long unsigned int extable_base;
	long unsigned int extable_len;
	const void *extable;
	long int sym_vvar_start;
	long int sym_vvar_page;
	long int sym_pvclock_page;
	long int sym_hvclock_page;
	long int sym_timens_page;
	long int sym_VDSO32_NOTE_MASK;
	long int sym___kernel_sigreturn;
	long int sym___kernel_rt_sigreturn;
	long int sym___kernel_vsyscall;
	long int sym_int80_landing_pad;
	long int sym_vdso32_sigreturn_landing_pad;
	long int sym_vdso32_rt_sigreturn_landing_pad;
};

struct vdso_rng_data {
	u64 generation;
	u8 is_ready;
};

struct ve_node {
	struct rb_node rb;
	int prio;
};

struct vector_cleanup {
	struct hlist_head head;
	struct timer_list timer;
};

struct vegas {
	u32 beg_snd_nxt;
	u32 beg_snd_una;
	u32 beg_snd_cwnd;
	u8 doing_vegas_now;
	u16 cntRTT;
	u32 minRTT;
	u32 baseRTT;
};

struct veno {
	u8 doing_veno_now;
	u16 cntrtt;
	u32 minrtt;
	u32 basertt;
	u32 inc;
	u32 diff;
};

struct vers_iter {
	size_t param_size;
	struct dm_target_versions *vers;
	struct dm_target_versions *old_vers;
	char *end;
	uint32_t flags;
};

struct veth_rq;

struct veth_priv {
	struct net_device *peer;
	atomic64_t dropped;
	struct bpf_prog *_xdp_prog;
	struct veth_rq *rq;
	unsigned int requested_headroom;
};

struct veth_q_stat_desc {
	char desc[32];
	size_t offset;
};

struct veth_stats {
	u64 rx_drops;
	u64 xdp_packets;
	u64 xdp_bytes;
	u64 xdp_redirect;
	u64 xdp_drops;
	u64 xdp_tx;
	u64 xdp_tx_err;
	u64 peer_tq_xdp_xmit;
	u64 peer_tq_xdp_xmit_err;
};

struct veth_rq_stats {
	struct veth_stats vs;
	struct u64_stats_sync syncp;
};

struct veth_rq {
	struct napi_struct xdp_napi;
	struct napi_struct *napi;
	struct net_device *dev;
	struct bpf_prog *xdp_prog;
	struct xdp_mem_info xdp_mem;
	struct veth_rq_stats stats;
	bool rx_notify_masked;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring xdp_ring;
	struct xdp_rxq_info xdp_rxq;
	struct page_pool *page_pool;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct veth_xdp_buff {
	struct xdp_buff xdp;
	struct sk_buff *skb;
};

struct veth_xdp_tx_bq {
	struct xdp_frame *q[16];
	unsigned int count;
};

struct vfio_info_cap_header {
	__u16 id;
	__u16 version;
	__u32 next;
};

struct vfio_iommu_type1_dma_map {
	__u32 argsz;
	__u32 flags;
	__u64 vaddr;
	__u64 iova;
	__u64 size;
};

struct vfio_iommu_type1_dma_unmap {
	__u32 argsz;
	__u32 flags;
	__u64 iova;
	__u64 size;
	__u8 data[0];
};

struct vfio_iommu_type1_info {
	__u32 argsz;
	__u32 flags;
	__u64 iova_pgsizes;
	__u32 cap_offset;
	__u32 pad;
};

struct vfio_iova_range {
	__u64 start;
	__u64 end;
};

struct vfio_iommu_type1_info_cap_iova_range {
	struct vfio_info_cap_header header;
	__u32 nr_iovas;
	__u32 reserved;
	struct vfio_iova_range iova_ranges[0];
};

struct vfio_iommu_type1_info_dma_avail {
	struct vfio_info_cap_header header;
	__u32 avail;
};

struct vfree_deferred {
	struct llist_head list;
	struct work_struct wq;
};

struct vfs_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
};

struct vfs_ns_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
	__le32 rootid;
};

struct vga_arb_user_card {
	struct pci_dev *pdev;
	unsigned int mem_cnt;
	unsigned int io_cnt;
};

struct vga_arb_private {
	struct list_head list;
	struct pci_dev *target;
	struct vga_arb_user_card cards[16];
	spinlock_t lock;
};

struct vga_device {
	struct list_head list;
	struct pci_dev *pdev;
	unsigned int decodes;
	unsigned int owns;
	unsigned int locks;
	unsigned int io_lock_cnt;
	unsigned int mem_lock_cnt;
	unsigned int io_norm_cnt;
	unsigned int mem_norm_cnt;
	bool bridge_has_one_vga;
	bool is_firmware_default;
	unsigned int (*set_decode)(struct pci_dev *, bool);
};

struct vga_switcheroo_client_ops {
	void (*set_gpu_state)(struct pci_dev *, enum vga_switcheroo_state);
	void (*reprobe)(struct pci_dev *);
	bool (*can_switch)(struct pci_dev *);
	void (*gpu_bound)(struct pci_dev *, enum vga_switcheroo_client_id);
};

struct vgastate {
	void *vgabase;
	long unsigned int membase;
	__u32 memsize;
	__u32 flags;
	__u32 depth;
	__u32 num_attr;
	__u32 num_crtc;
	__u32 num_gfx;
	__u32 num_seq;
	void *vidstate;
};

struct vhost_task {
	bool (*fn)(void *);
	void (*handle_sigkill)(void *);
	void *data;
	struct completion exited;
	long unsigned int flags;
	struct task_struct *task;
	struct mutex exit_mutex;
};

struct video_levels {
	u16 blank;
	u16 black;
	u8 burst;
};

struct vif_entry_notifier_info {
	struct fib_notifier_info info;
	struct net_device *dev;
	short unsigned int vif_index;
	short unsigned int vif_flags;
	u32 tb_id;
};

struct vifctl {
	vifi_t vifc_vifi;
	unsigned char vifc_flags;
	unsigned char vifc_threshold;
	unsigned int vifc_rate_limit;
	union {
		struct in_addr vifc_lcl_addr;
		int vifc_lcl_ifindex;
	};
	struct in_addr vifc_rmt_addr;
};

struct viommu_dev {
	struct iommu_device iommu;
	struct device *dev;
	struct virtio_device *vdev;
	struct ida domain_ids;
	struct virtqueue *vqs[2];
	spinlock_t request_lock;
	struct list_head requests;
	void *evts;
	struct iommu_domain_geometry geometry;
	u64 pgsize_bitmap;
	u32 first_domain;
	u32 last_domain;
	u32 map_flags;
	u32 probe_size;
};

struct viommu_domain {
	struct iommu_domain domain;
	struct viommu_dev *viommu;
	struct mutex mutex;
	unsigned int id;
	u32 map_flags;
	spinlock_t mappings_lock;
	struct rb_root_cached mappings;
	long unsigned int nr_endpoints;
	bool bypass;
};

struct viommu_endpoint {
	struct device *dev;
	struct viommu_dev *viommu;
	struct viommu_domain *vdomain;
	struct list_head resv_regions;
};

struct virtio_iommu_fault {
	__u8 reason;
	__u8 reserved[3];
	__le32 flags;
	__le32 endpoint;
	__u8 reserved2[4];
	__le64 address;
};

struct viommu_event {
	union {
		u32 head;
		struct virtio_iommu_fault fault;
	};
};

struct viommu_mapping {
	phys_addr_t paddr;
	struct interval_tree_node iova;
	u32 flags;
};

struct viommu_request {
	struct list_head list;
	void *writeback;
	unsigned int write_offset;
	unsigned int len;
	char buf[0];
};

struct viot_iommu;

struct viot_endpoint {
	union {
		struct {
			u16 segment_start;
			u16 segment_end;
			u16 bdf_start;
			u16 bdf_end;
		};
		u64 address;
	};
	u32 endpoint_id;
	struct viot_iommu *viommu;
	struct list_head list;
};

struct viot_iommu {
	unsigned int offset;
	struct fwnode_handle *fwnode;
	struct list_head list;
};

struct virtio_blk_outhdr {
	__virtio32 type;
	__virtio32 ioprio;
	__virtio64 sector;
};

struct virtblk_req {
	struct virtio_blk_outhdr out_hdr;
	union {
		u8 status;
		struct {
			__virtio64 sector;
			u8 status;
		} zone_append;
	} in_hdr;
	size_t in_hdr_len;
	struct sg_table sg_table;
	struct scatterlist sg[0];
};

struct virtio_9p_config {
	__virtio16 tag_len;
	__u8 tag[0];
};

struct virtio_admin_cmd {
	__le16 opcode;
	__le16 group_type;
	__le64 group_member_id;
	struct scatterlist *data_sg;
	struct scatterlist *result_sg;
	struct completion completion;
	u32 result_sg_size;
	int ret;
};

struct virtio_admin_cmd_cap_get_data {
	__le16 id;
	__u8 reserved[6];
};

struct virtio_admin_cmd_cap_set_data {
	__le16 id;
	__u8 reserved[6];
	__u8 cap_specific_data[0];
};

struct virtio_admin_cmd_dev_mode_set_data {
	__u8 flags;
};

struct virtio_admin_cmd_resource_obj_cmd_hdr {
	__le16 type;
	__u8 reserved[2];
	__le32 id;
};

struct virtio_dev_part_hdr {
	__le16 part_type;
	__u8 flags;
	__u8 reserved;
	union {
		struct {
			__le32 offset;
			__le32 reserved;
		} pci_common_cfg;
		struct {
			__le16 index;
			__u8 reserved[6];
		} vq_index;
	} selector;
	__le32 length;
};

struct virtio_admin_cmd_dev_parts_get_data {
	struct virtio_admin_cmd_resource_obj_cmd_hdr hdr;
	__u8 type;
	__u8 reserved[7];
	struct virtio_dev_part_hdr hdr_list[0];
};

struct virtio_admin_cmd_dev_parts_metadata_data {
	struct virtio_admin_cmd_resource_obj_cmd_hdr hdr;
	__u8 type;
	__u8 reserved[7];
};

struct virtio_admin_cmd_dev_parts_metadata_result {
	union {
		struct {
			__le32 size;
			__le32 reserved;
		} parts_size;
		struct {
			__le32 count;
			__le32 reserved;
		} hdr_list_count;
		struct {
			__le32 count;
			__le32 reserved;
			struct virtio_dev_part_hdr hdrs[0];
		} hdr_list;
	};
};

struct virtio_admin_cmd_hdr {
	__le16 opcode;
	__le16 group_type;
	__u8 reserved1[12];
	__le64 group_member_id;
};

struct virtio_admin_cmd_legacy_rd_data {
	__u8 offset;
};

struct virtio_admin_cmd_legacy_wr_data {
	__u8 offset;
	__u8 reserved[7];
	__u8 registers[0];
};

struct virtio_admin_cmd_notify_info_data {
	__u8 flags;
	__u8 bar;
	__u8 padding[6];
	__le64 offset;
};

struct virtio_admin_cmd_notify_info_result {
	struct virtio_admin_cmd_notify_info_data entries[4];
};

struct virtio_admin_cmd_query_cap_id_result {
	__le64 supported_caps[1];
};

struct virtio_admin_cmd_resource_obj_create_data {
	struct virtio_admin_cmd_resource_obj_cmd_hdr hdr;
	__le64 flags;
	__u8 resource_obj_specific_data[0];
};

struct virtio_admin_cmd_status {
	__le16 status;
	__le16 status_qualifier;
	__u8 reserved2[4];
};

struct virtio_blk_vq;

struct virtio_blk {
	struct mutex vdev_mutex;
	struct virtio_device *vdev;
	struct gendisk *disk;
	struct blk_mq_tag_set tag_set;
	struct work_struct config_work;
	int index;
	int num_vqs;
	int io_queues[3];
	struct virtio_blk_vq *vqs;
	unsigned int zone_sectors;
};

struct virtio_blk_geometry {
	__virtio16 cylinders;
	__u8 heads;
	__u8 sectors;
};

struct virtio_blk_zoned_characteristics {
	__virtio32 zone_sectors;
	__virtio32 max_open_zones;
	__virtio32 max_active_zones;
	__virtio32 max_append_sectors;
	__virtio32 write_granularity;
	__u8 model;
	__u8 unused2[3];
};

struct virtio_blk_config {
	__virtio64 capacity;
	__virtio32 size_max;
	__virtio32 seg_max;
	struct virtio_blk_geometry geometry;
	__virtio32 blk_size;
	__u8 physical_block_exp;
	__u8 alignment_offset;
	__virtio16 min_io_size;
	__virtio32 opt_io_size;
	__u8 wce;
	__u8 unused;
	__virtio16 num_queues;
	__virtio32 max_discard_sectors;
	__virtio32 max_discard_seg;
	__virtio32 discard_sector_alignment;
	__virtio32 max_write_zeroes_sectors;
	__virtio32 max_write_zeroes_seg;
	__u8 write_zeroes_may_unmap;
	__u8 unused1[3];
	__virtio32 max_secure_erase_sectors;
	__virtio32 max_secure_erase_seg;
	__virtio32 secure_erase_sector_alignment;
	struct virtio_blk_zoned_characteristics zoned;
};

struct virtio_blk_discard_write_zeroes {
	__le64 sector;
	__le32 num_sectors;
	__le32 flags;
};

struct virtio_blk_vq {
	struct virtqueue *vq;
	spinlock_t lock;
	char name[16];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct virtio_chan {
	bool inuse;
	spinlock_t lock;
	struct p9_client *client;
	struct virtio_device *vdev;
	struct virtqueue *vq;
	int ring_bufs_avail;
	wait_queue_head_t *vc_wq;
	long unsigned int p9_max_pages;
	struct scatterlist sg[128];
	char *tag;
	struct list_head chan_list;
};

struct virtqueue_info;

struct virtio_shm_region;

struct virtio_config_ops {
	void (*get)(struct virtio_device *, unsigned int, void *, unsigned int);
	void (*set)(struct virtio_device *, unsigned int, const void *, unsigned int);
	u32 (*generation)(struct virtio_device *);
	u8 (*get_status)(struct virtio_device *);
	void (*set_status)(struct virtio_device *, u8);
	void (*reset)(struct virtio_device *);
	int (*find_vqs)(struct virtio_device *, unsigned int, struct virtqueue **, struct virtqueue_info *, struct irq_affinity *);
	void (*del_vqs)(struct virtio_device *);
	void (*synchronize_cbs)(struct virtio_device *);
	u64 (*get_features)(struct virtio_device *);
	int (*finalize_features)(struct virtio_device *);
	const char * (*bus_name)(struct virtio_device *);
	int (*set_vq_affinity)(struct virtqueue *, const struct cpumask *);
	const struct cpumask * (*get_vq_affinity)(struct virtio_device *, int);
	bool (*get_shm_region)(struct virtio_device *, struct virtio_shm_region *, u8);
	int (*disable_vq_and_reset)(struct virtqueue *);
	int (*enable_vq_after_reset)(struct virtqueue *);
};

struct virtio_console_config {
	__virtio16 cols;
	__virtio16 rows;
	__virtio32 max_nr_ports;
	__virtio32 emerg_wr;
};

struct virtio_dev_parts_cap {
	__u8 get_parts_resource_objects_limit;
	__u8 set_parts_resource_objects_limit;
};

struct virtio_device_id {
	__u32 device;
	__u32 vendor;
};

struct vringh_config_ops;

struct virtio_device {
	int index;
	bool failed;
	bool config_core_enabled;
	bool config_driver_disabled;
	bool config_change_pending;
	spinlock_t config_lock;
	spinlock_t vqs_list_lock;
	struct device dev;
	struct virtio_device_id id;
	const struct virtio_config_ops *config;
	const struct vringh_config_ops *vringh_config;
	struct list_head vqs;
	u64 features;
	void *priv;
};

struct virtio_dma_buf_ops {
	struct dma_buf_ops ops;
	int (*device_attach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*get_uuid)(struct dma_buf *, uuid_t *);
};

struct virtio_driver {
	struct device_driver driver;
	const struct virtio_device_id *id_table;
	const unsigned int *feature_table;
	unsigned int feature_table_size;
	const unsigned int *feature_table_legacy;
	unsigned int feature_table_size_legacy;
	int (*validate)(struct virtio_device *);
	int (*probe)(struct virtio_device *);
	void (*scan)(struct virtio_device *);
	void (*remove)(struct virtio_device *);
	void (*config_changed)(struct virtio_device *);
	int (*freeze)(struct virtio_device *);
	int (*restore)(struct virtio_device *);
	int (*reset_prepare)(struct virtio_device *);
	int (*reset_done)(struct virtio_device *);
};

struct virtio_fs_vq;

struct virtio_fs {
	struct kobject kobj;
	struct kobject *mqs_kobj;
	struct list_head list;
	char *tag;
	struct virtio_fs_vq *vqs;
	unsigned int nvqs;
	unsigned int num_request_queues;
	struct dax_device *dax_dev;
	unsigned int *mq_map;
	void *window_kaddr;
	phys_addr_t window_phys_addr;
	size_t window_len;
};

struct virtio_fs_config {
	__u8 tag[36];
	__le32 num_request_queues;
};

struct virtio_fs_forget_req {
	struct fuse_in_header ih;
	struct fuse_forget_in arg;
};

struct virtio_fs_forget {
	struct list_head list;
	struct virtio_fs_forget_req req;
};

struct virtio_fs_req_work {
	struct fuse_req *req;
	struct virtio_fs_vq *fsvq;
	struct work_struct done_work;
};

struct virtio_fs_vq {
	spinlock_t lock;
	struct virtqueue *vq;
	struct work_struct done_work;
	struct list_head queued_reqs;
	struct list_head end_reqs;
	struct work_struct dispatch_work;
	struct fuse_dev *fud;
	bool connected;
	long int in_flight;
	struct completion in_flight_zero;
	struct kobject *kobj;
	char name[24];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct virtio_gpu_box {
	__le32 x;
	__le32 y;
	__le32 z;
	__le32 w;
	__le32 h;
	__le32 d;
};

struct virtio_gpu_ctrl_hdr {
	__le32 type;
	__le32 flags;
	__le64 fence_id;
	__le32 ctx_id;
	__u8 ring_idx;
	__u8 padding[3];
};

struct virtio_gpu_cmd_get_edid {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 scanout;
	__le32 padding;
};

struct virtio_gpu_cmd_submit {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 size;
	__le32 padding;
};

struct virtio_gpu_config {
	__le32 events_read;
	__le32 events_clear;
	__le32 num_scanouts;
	__le32 num_capsets;
};

struct virtio_gpu_ctx_create {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 nlen;
	__le32 context_init;
	char debug_name[64];
};

struct virtio_gpu_ctx_destroy {
	struct virtio_gpu_ctrl_hdr hdr;
};

struct virtio_gpu_ctx_resource {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_cursor_pos {
	__le32 scanout_id;
	__le32 x;
	__le32 y;
	__le32 padding;
};

struct virtio_gpu_rect {
	__le32 x;
	__le32 y;
	__le32 width;
	__le32 height;
};

struct virtio_gpu_display_one {
	struct virtio_gpu_rect r;
	__le32 enabled;
	__le32 flags;
};

struct virtio_gpu_update_cursor {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_cursor_pos pos;
	__le32 resource_id;
	__le32 hot_x;
	__le32 hot_y;
	__le32 padding;
};

struct virtio_gpu_output {
	int index;
	struct drm_crtc crtc;
	struct drm_connector conn;
	struct drm_encoder enc;
	struct virtio_gpu_display_one info;
	struct virtio_gpu_update_cursor cursor;
	const struct drm_edid *drm_edid;
	int cur_x;
	int cur_y;
	bool needs_modeset;
};

struct virtio_gpu_queue {
	struct virtqueue *vq;
	spinlock_t qlock;
	wait_queue_head_t ack_queue;
	struct work_struct dequeue_work;
	uint32_t seqno;
};

struct virtio_gpu_fence_driver {
	atomic64_t last_fence_id;
	uint64_t current_fence_id;
	uint64_t context;
	struct list_head fences;
	spinlock_t lock;
};

struct virtio_shm_region {
	u64 addr;
	u64 len;
};

struct virtio_gpu_drv_capset;

struct virtio_gpu_device {
	struct drm_device *ddev;
	struct virtio_device *vdev;
	struct virtio_gpu_output outputs[16];
	uint32_t num_scanouts;
	struct virtio_gpu_queue ctrlq;
	struct virtio_gpu_queue cursorq;
	struct kmem_cache *vbufs;
	atomic_t pending_commands;
	struct ida resource_ida;
	wait_queue_head_t resp_wq;
	spinlock_t display_info_lock;
	bool display_info_pending;
	struct virtio_gpu_fence_driver fence_drv;
	struct ida ctx_id_ida;
	bool has_virgl_3d;
	bool has_edid;
	bool has_indirect;
	bool has_resource_assign_uuid;
	bool has_resource_blob;
	bool has_host_visible;
	bool has_context_init;
	struct virtio_shm_region host_visible_region;
	struct drm_mm host_visible_mm;
	struct work_struct config_changed_work;
	struct work_struct obj_free_work;
	spinlock_t obj_free_lock;
	struct list_head obj_free_list;
	struct virtio_gpu_drv_capset *capsets;
	uint32_t num_capsets;
	uint64_t capset_id_mask;
	struct list_head cap_cache;
	spinlock_t resource_export_lock;
	spinlock_t host_visible_lock;
};

struct virtio_gpu_drv_cap_cache {
	struct list_head head;
	void *caps_cache;
	uint32_t id;
	uint32_t version;
	uint32_t size;
	atomic_t is_valid;
};

struct virtio_gpu_drv_capset {
	uint32_t id;
	uint32_t max_version;
	uint32_t max_size;
};

struct virtio_gpu_fence_event;

struct virtio_gpu_fence {
	struct dma_fence f;
	uint32_t ring_idx;
	uint64_t fence_id;
	bool emit_fence_info;
	struct virtio_gpu_fence_event *e;
	struct virtio_gpu_fence_driver *drv;
	struct list_head node;
};

struct virtio_gpu_fence_event {
	struct drm_pending_event base;
	struct drm_event event;
};

struct virtio_gpu_fpriv {
	uint32_t ctx_id;
	uint32_t context_init;
	bool context_created;
	uint32_t num_rings;
	uint64_t base_fence_ctx;
	uint64_t ring_idx_mask;
	struct mutex context_lock;
	char debug_name[65];
	bool explicit_debug_name;
};

struct virtio_gpu_framebuffer {
	struct drm_framebuffer base;
	struct virtio_gpu_fence *fence;
};

struct virtio_gpu_get_capset {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 capset_id;
	__le32 capset_version;
};

struct virtio_gpu_get_capset_info {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 capset_index;
	__le32 padding;
};

struct virtio_gpu_mem_entry {
	__le64 addr;
	__le32 length;
	__le32 padding;
};

struct virtio_gpu_object {
	struct drm_gem_shmem_object base;
	struct sg_table *sgt;
	uint32_t hw_res_handle;
	bool dumb;
	bool created;
	bool attached;
	bool host3d_blob;
	bool guest_blob;
	uint32_t blob_mem;
	uint32_t blob_flags;
	int uuid_state;
	uuid_t uuid;
};

struct virtio_gpu_object_array {
	struct ww_acquire_ctx ticket;
	struct list_head next;
	u32 nents;
	u32 total;
	struct drm_gem_object *objs[0];
};

struct virtio_gpu_object_params {
	long unsigned int size;
	bool dumb;
	bool virgl;
	bool blob;
	uint32_t format;
	uint32_t width;
	uint32_t height;
	uint32_t target;
	uint32_t bind;
	uint32_t depth;
	uint32_t array_size;
	uint32_t last_level;
	uint32_t nr_samples;
	uint32_t flags;
	uint32_t ctx_id;
	uint32_t blob_mem;
	uint32_t blob_flags;
	uint64_t blob_id;
};

struct virtio_gpu_object_shmem {
	struct virtio_gpu_object base;
};

struct virtio_gpu_object_vram {
	struct virtio_gpu_object base;
	uint32_t map_state;
	uint32_t map_info;
	struct drm_mm_node vram_node;
};

struct virtio_gpu_plane_state {
	struct drm_plane_state base;
	struct virtio_gpu_fence *fence;
};

struct virtio_gpu_resource_assign_uuid {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_resource_attach_backing {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 nr_entries;
};

struct virtio_gpu_resource_create_2d {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 format;
	__le32 width;
	__le32 height;
};

struct virtio_gpu_resource_create_3d {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 target;
	__le32 format;
	__le32 bind;
	__le32 width;
	__le32 height;
	__le32 depth;
	__le32 array_size;
	__le32 last_level;
	__le32 nr_samples;
	__le32 flags;
	__le32 padding;
};

struct virtio_gpu_resource_create_blob {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 blob_mem;
	__le32 blob_flags;
	__le32 nr_entries;
	__le64 blob_id;
	__le64 size;
};

struct virtio_gpu_resource_detach_backing {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_resource_flush {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_rect r;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_resource_map_blob {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
	__le64 offset;
};

struct virtio_gpu_resource_unmap_blob {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_resource_unref {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_resp_capset {
	struct virtio_gpu_ctrl_hdr hdr;
	__u8 capset_data[0];
};

struct virtio_gpu_resp_capset_info {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 capset_id;
	__le32 capset_max_version;
	__le32 capset_max_size;
	__le32 padding;
};

struct virtio_gpu_resp_display_info {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_display_one pmodes[16];
};

struct virtio_gpu_resp_edid {
	struct virtio_gpu_ctrl_hdr hdr;
	__le32 size;
	__le32 padding;
	__u8 edid[1024];
};

struct virtio_gpu_resp_map_info {
	struct virtio_gpu_ctrl_hdr hdr;
	__u32 map_info;
	__u32 padding;
};

struct virtio_gpu_resp_resource_uuid {
	struct virtio_gpu_ctrl_hdr hdr;
	__u8 uuid[16];
};

struct virtio_gpu_set_scanout {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_rect r;
	__le32 scanout_id;
	__le32 resource_id;
};

struct virtio_gpu_set_scanout_blob {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_rect r;
	__le32 scanout_id;
	__le32 resource_id;
	__le32 width;
	__le32 height;
	__le32 format;
	__le32 padding;
	__le32 strides[4];
	__le32 offsets[4];
};

struct virtio_gpu_submit_post_dep;

struct virtio_gpu_submit {
	struct virtio_gpu_submit_post_dep *post_deps;
	unsigned int num_out_syncobjs;
	struct drm_syncobj **in_syncobjs;
	unsigned int num_in_syncobjs;
	struct virtio_gpu_object_array *buflist;
	struct drm_virtgpu_execbuffer *exbuf;
	struct virtio_gpu_fence *out_fence;
	struct virtio_gpu_fpriv *vfpriv;
	struct virtio_gpu_device *vgdev;
	struct sync_file *sync_file;
	struct drm_file *file;
	int out_fence_fd;
	u64 fence_ctx;
	u32 ring_idx;
	void *buf;
};

struct virtio_gpu_submit_post_dep {
	struct drm_syncobj *syncobj;
	struct dma_fence_chain *chain;
	u64 point;
};

struct virtio_gpu_transfer_host_3d {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_box box;
	__le64 offset;
	__le32 resource_id;
	__le32 level;
	__le32 stride;
	__le32 layer_stride;
};

struct virtio_gpu_transfer_to_host_2d {
	struct virtio_gpu_ctrl_hdr hdr;
	struct virtio_gpu_rect r;
	__le64 offset;
	__le32 resource_id;
	__le32 padding;
};

struct virtio_gpu_vbuffer;

typedef void (*virtio_gpu_resp_cb)(struct virtio_gpu_device *, struct virtio_gpu_vbuffer *);

struct virtio_gpu_vbuffer {
	char *buf;
	int size;
	void *data_buf;
	uint32_t data_size;
	char *resp_buf;
	int resp_size;
	virtio_gpu_resp_cb resp_cb;
	void *resp_cb_data;
	struct virtio_gpu_object_array *objs;
	struct list_head list;
	uint32_t seqno;
};

struct virtio_input_event {
	__le16 type;
	__le16 code;
	__le32 value;
};

struct virtio_input {
	struct virtio_device *vdev;
	struct input_dev *idev;
	char name[64];
	char serial[64];
	char phys[64];
	struct virtqueue *evt;
	struct virtqueue *sts;
	struct virtio_input_event evts[64];
	spinlock_t lock;
	bool ready;
};

struct virtio_input_absinfo {
	__le32 min;
	__le32 max;
	__le32 fuzz;
	__le32 flat;
	__le32 res;
};

struct virtio_input_devids {
	__le16 bustype;
	__le16 vendor;
	__le16 product;
	__le16 version;
};

struct virtio_input_config {
	__u8 select;
	__u8 subsel;
	__u8 size;
	__u8 reserved[5];
	union {
		char string[128];
		__u8 bitmap[128];
		struct virtio_input_absinfo abs;
		struct virtio_input_devids ids;
	} u;
};

struct virtio_iommu_range_64 {
	__le64 start;
	__le64 end;
};

struct virtio_iommu_range_32 {
	__le32 start;
	__le32 end;
};

struct virtio_iommu_config {
	__le64 page_size_mask;
	struct virtio_iommu_range_64 input_range;
	struct virtio_iommu_range_32 domain_range;
	__le32 probe_size;
	__u8 bypass;
	__u8 reserved[3];
};

struct virtio_iommu_probe_property {
	__le16 type;
	__le16 length;
};

struct virtio_iommu_probe_resv_mem {
	struct virtio_iommu_probe_property head;
	__u8 subtype;
	__u8 reserved[3];
	__le64 start;
	__le64 end;
};

struct virtio_iommu_req_head {
	__u8 type;
	__u8 reserved[3];
};

struct virtio_iommu_req_tail {
	__u8 status;
	__u8 reserved[3];
};

struct virtio_iommu_req_attach {
	struct virtio_iommu_req_head head;
	__le32 domain;
	__le32 endpoint;
	__le32 flags;
	__u8 reserved[4];
	struct virtio_iommu_req_tail tail;
};

struct virtio_iommu_req_detach {
	struct virtio_iommu_req_head head;
	__le32 domain;
	__le32 endpoint;
	__u8 reserved[8];
	struct virtio_iommu_req_tail tail;
};

struct virtio_iommu_req_map {
	struct virtio_iommu_req_head head;
	__le32 domain;
	__le64 virt_start;
	__le64 virt_end;
	__le64 phys_start;
	__le32 flags;
	struct virtio_iommu_req_tail tail;
};

struct virtio_iommu_req_probe {
	struct virtio_iommu_req_head head;
	__le32 endpoint;
	__u8 reserved[64];
	__u8 properties[0];
};

struct virtio_iommu_req_unmap {
	struct virtio_iommu_req_head head;
	__le32 domain;
	__le64 virt_start;
	__le64 virt_end;
	__u8 reserved[4];
	struct virtio_iommu_req_tail tail;
};

struct virtio_net_hdr_mrg_rxbuf {
	struct virtio_net_hdr hdr;
	__virtio16 num_buffers;
};

struct virtio_net_hdr_v1 {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	union {
		struct {
			__virtio16 csum_start;
			__virtio16 csum_offset;
		};
		struct {
			__virtio16 start;
			__virtio16 offset;
		} csum;
		struct {
			__le16 segments;
			__le16 dup_acks;
		} rsc;
	};
	__virtio16 num_buffers;
};

struct virtio_net_hdr_v1_hash {
	struct virtio_net_hdr_v1 hdr;
	__le32 hash_value;
	__le16 hash_report;
	__le16 padding;
};

struct virtio_net_common_hdr {
	union {
		struct virtio_net_hdr hdr;
		struct virtio_net_hdr_mrg_rxbuf mrg_hdr;
		struct virtio_net_hdr_v1_hash hash_v1_hdr;
	};
};

struct virtio_net_config {
	__u8 mac[6];
	__virtio16 status;
	__virtio16 max_virtqueue_pairs;
	__virtio16 mtu;
	__le32 speed;
	__u8 duplex;
	__u8 rss_max_key_size;
	__le16 rss_max_indirection_table_length;
	__le32 supported_hash_types;
};

struct virtio_net_ctrl_coal {
	__le32 max_packets;
	__le32 max_usecs;
};

struct virtio_net_ctrl_coal_rx {
	__le32 rx_max_packets;
	__le32 rx_usecs;
};

struct virtio_net_ctrl_coal_tx {
	__le32 tx_max_packets;
	__le32 tx_usecs;
};

struct virtio_net_ctrl_coal_vq {
	__le16 vqn;
	__le16 reserved;
	struct virtio_net_ctrl_coal coal;
};

struct virtio_net_ctrl_mac {
	__virtio32 entries;
	__u8 macs[0];
};

struct virtio_net_ctrl_mq {
	__virtio16 virtqueue_pairs;
};

struct virtio_net_ctrl_queue_stats {
	struct {
		__le16 vq_index;
		__le16 reserved[3];
		__le64 types_bitmap[1];
	} stats[1];
};

struct virtio_net_ctrl_rss {
	__le32 hash_types;
	__le16 indirection_table_mask;
	__le16 unclassified_queue;
	__le16 hash_cfg_reserved;
	__le16 max_tx_vq;
	u8 hash_key_length;
	u8 key[40];
	__le16 *indirection_table;
};

struct virtio_net_stats_capabilities {
	__le64 supported_stats_types[1];
};

struct virtio_net_stats_reply_hdr {
	__u8 type;
	__u8 reserved;
	__le16 vq_index;
	__le16 reserved1;
	__le16 size;
};

struct virtio_pci_vq_info;

struct virtio_pci_admin_vq {
	struct virtio_pci_vq_info *info;
	spinlock_t lock;
	u64 supported_cmds;
	u64 supported_caps;
	u8 max_dev_parts_objects;
	struct ida dev_parts_ida;
	char name[10];
	u16 vq_index;
};

struct virtio_pci_common_cfg {
	__le32 device_feature_select;
	__le32 device_feature;
	__le32 guest_feature_select;
	__le32 guest_feature;
	__le16 msix_config;
	__le16 num_queues;
	__u8 device_status;
	__u8 config_generation;
	__le16 queue_select;
	__le16 queue_size;
	__le16 queue_msix_vector;
	__le16 queue_enable;
	__le16 queue_notify_off;
	__le32 queue_desc_lo;
	__le32 queue_desc_hi;
	__le32 queue_avail_lo;
	__le32 queue_avail_hi;
	__le32 queue_used_lo;
	__le32 queue_used_hi;
};

struct virtio_pci_legacy_device {
	struct pci_dev *pci_dev;
	u8 *isr;
	void *ioaddr;
	struct virtio_device_id id;
};

struct virtio_pci_modern_device {
	struct pci_dev *pci_dev;
	struct virtio_pci_common_cfg *common;
	void *device;
	void *notify_base;
	resource_size_t notify_pa;
	u8 *isr;
	size_t notify_len;
	size_t device_len;
	size_t common_len;
	int notify_map_cap;
	u32 notify_offset_multiplier;
	int modern_bars;
	struct virtio_device_id id;
	int (*device_id_check)(struct pci_dev *);
	u64 dma_mask;
};

struct virtio_pci_device {
	struct virtio_device vdev;
	struct pci_dev *pci_dev;
	union {
		struct virtio_pci_legacy_device ldev;
		struct virtio_pci_modern_device mdev;
	};
	bool is_legacy;
	u8 *isr;
	spinlock_t lock;
	struct list_head virtqueues;
	struct list_head slow_virtqueues;
	struct virtio_pci_vq_info **vqs;
	struct virtio_pci_admin_vq admin_vq;
	int msix_enabled;
	int intx_enabled;
	cpumask_var_t *msix_affinity_masks;
	char (*msix_names)[256];
	unsigned int msix_vectors;
	unsigned int msix_used_vectors;
	bool per_vq_vectors;
	struct virtqueue * (*setup_vq)(struct virtio_pci_device *, struct virtio_pci_vq_info *, unsigned int, void (*)(struct virtqueue *), const char *, bool, u16);
	void (*del_vq)(struct virtio_pci_vq_info *);
	u16 (*config_vector)(struct virtio_pci_device *, u16);
	int (*avq_index)(struct virtio_device *, u16 *, u16 *);
};

struct virtio_pci_modern_common_cfg {
	struct virtio_pci_common_cfg cfg;
	__le16 queue_notify_data;
	__le16 queue_reset;
	__le16 admin_queue_index;
	__le16 admin_queue_num;
};

struct virtio_pci_vq_info {
	struct virtqueue *vq;
	struct list_head node;
	unsigned int msix_vector;
};

struct virtio_resource_obj_dev_parts {
	__u8 type;
	__u8 reserved[7];
};

struct virtio_scsi_event {
	__virtio32 event;
	__u8 lun[8];
	__virtio32 reason;
};

struct virtio_scsi;

struct virtio_scsi_event_node {
	struct virtio_scsi *vscsi;
	struct virtio_scsi_event event;
	struct work_struct work;
};

struct virtio_scsi_vq {
	spinlock_t vq_lock;
	struct virtqueue *vq;
};

struct virtio_scsi {
	struct virtio_device *vdev;
	struct virtio_scsi_event_node event_list[8];
	u32 num_queues;
	int io_queues[3];
	struct hlist_node node;
	bool stop_events;
	struct virtio_scsi_vq ctrl_vq;
	struct virtio_scsi_vq event_vq;
	struct virtio_scsi_vq req_vqs[0];
};

struct virtio_scsi_cmd_req {
	__u8 lun[8];
	__virtio64 tag;
	__u8 task_attr;
	__u8 prio;
	__u8 crn;
	__u8 cdb[32];
} __attribute__((packed));

struct virtio_scsi_cmd_req_pi {
	__u8 lun[8];
	__virtio64 tag;
	__u8 task_attr;
	__u8 prio;
	__u8 crn;
	__virtio32 pi_bytesout;
	__virtio32 pi_bytesin;
	__u8 cdb[32];
} __attribute__((packed));

struct virtio_scsi_ctrl_tmf_req {
	__virtio32 type;
	__virtio32 subtype;
	__u8 lun[8];
	__virtio64 tag;
};

struct virtio_scsi_ctrl_an_req {
	__virtio32 type;
	__u8 lun[8];
	__virtio32 event_requested;
};

struct virtio_scsi_cmd_resp {
	__virtio32 sense_len;
	__virtio32 resid;
	__virtio16 status_qualifier;
	__u8 status;
	__u8 response;
	__u8 sense[96];
};

struct virtio_scsi_ctrl_tmf_resp {
	__u8 response;
};

struct virtio_scsi_ctrl_an_resp {
	__virtio32 event_actual;
	__u8 response;
} __attribute__((packed));

struct virtio_scsi_cmd {
	struct scsi_cmnd *sc;
	struct completion *comp;
	union {
		struct virtio_scsi_cmd_req cmd;
		struct virtio_scsi_cmd_req_pi cmd_pi;
		struct virtio_scsi_ctrl_tmf_req tmf;
		struct virtio_scsi_ctrl_an_req an;
	} req;
	union {
		struct virtio_scsi_cmd_resp cmd;
		struct virtio_scsi_ctrl_tmf_resp tmf;
		struct virtio_scsi_ctrl_an_resp an;
		struct virtio_scsi_event evt;
	} resp;
	long: 64;
} __attribute__((packed));

struct virtio_scsi_config {
	__virtio32 num_queues;
	__virtio32 seg_max;
	__virtio32 max_sectors;
	__virtio32 cmd_per_lun;
	__virtio32 event_info_size;
	__virtio32 sense_size;
	__virtio32 cdb_size;
	__virtio16 max_channel;
	__virtio16 max_target;
	__virtio32 max_lun;
};

struct vsock_sock;

struct vsock_transport_recv_notify_data;

struct vsock_transport_send_notify_data;

struct vsock_transport {
	struct module *module;
	int (*init)(struct vsock_sock *, struct vsock_sock *);
	void (*destruct)(struct vsock_sock *);
	void (*release)(struct vsock_sock *);
	int (*cancel_pkt)(struct vsock_sock *);
	int (*connect)(struct vsock_sock *);
	int (*dgram_bind)(struct vsock_sock *, struct sockaddr_vm *);
	int (*dgram_dequeue)(struct vsock_sock *, struct msghdr *, size_t, int);
	int (*dgram_enqueue)(struct vsock_sock *, struct sockaddr_vm *, struct msghdr *, size_t);
	bool (*dgram_allow)(u32, u32);
	ssize_t (*stream_dequeue)(struct vsock_sock *, struct msghdr *, size_t, int);
	ssize_t (*stream_enqueue)(struct vsock_sock *, struct msghdr *, size_t);
	s64 (*stream_has_data)(struct vsock_sock *);
	s64 (*stream_has_space)(struct vsock_sock *);
	u64 (*stream_rcvhiwat)(struct vsock_sock *);
	bool (*stream_is_active)(struct vsock_sock *);
	bool (*stream_allow)(u32, u32);
	ssize_t (*seqpacket_dequeue)(struct vsock_sock *, struct msghdr *, int);
	int (*seqpacket_enqueue)(struct vsock_sock *, struct msghdr *, size_t);
	bool (*seqpacket_allow)(u32);
	u32 (*seqpacket_has_data)(struct vsock_sock *);
	int (*notify_poll_in)(struct vsock_sock *, size_t, bool *);
	int (*notify_poll_out)(struct vsock_sock *, size_t, bool *);
	int (*notify_recv_init)(struct vsock_sock *, size_t, struct vsock_transport_recv_notify_data *);
	int (*notify_recv_pre_block)(struct vsock_sock *, size_t, struct vsock_transport_recv_notify_data *);
	int (*notify_recv_pre_dequeue)(struct vsock_sock *, size_t, struct vsock_transport_recv_notify_data *);
	int (*notify_recv_post_dequeue)(struct vsock_sock *, size_t, ssize_t, bool, struct vsock_transport_recv_notify_data *);
	int (*notify_send_init)(struct vsock_sock *, struct vsock_transport_send_notify_data *);
	int (*notify_send_pre_block)(struct vsock_sock *, struct vsock_transport_send_notify_data *);
	int (*notify_send_pre_enqueue)(struct vsock_sock *, struct vsock_transport_send_notify_data *);
	int (*notify_send_post_enqueue)(struct vsock_sock *, ssize_t, struct vsock_transport_send_notify_data *);
	void (*notify_buffer_size)(struct vsock_sock *, u64 *);
	int (*notify_set_rcvlowat)(struct vsock_sock *, int);
	ssize_t (*unsent_bytes)(struct vsock_sock *);
	int (*shutdown)(struct vsock_sock *, int);
	u32 (*get_local_cid)(void);
	int (*read_skb)(struct vsock_sock *, skb_read_actor_t);
	bool (*msgzerocopy_allow)(void);
};

struct virtio_transport {
	struct vsock_transport transport;
	int (*send_pkt)(struct sk_buff *);
	bool (*can_msgzerocopy)(int);
};

struct virtio_vsock_event {
	__le32 id;
};

struct virtio_vsock {
	struct virtio_device *vdev;
	struct virtqueue *vqs[3];
	struct work_struct tx_work;
	struct work_struct rx_work;
	struct work_struct event_work;
	struct mutex tx_lock;
	bool tx_run;
	long: 0;
	struct work_struct send_pkt_work;
	struct sk_buff_head send_pkt_queue;
	atomic_t queued_replies;
	long: 0;
	struct mutex rx_lock;
	bool rx_run;
	int: 0;
	int rx_buf_nr;
	int rx_buf_max_nr;
	long: 0;
	struct mutex event_lock;
	bool event_run;
	struct virtio_vsock_event event_list[8];
	int: 0;
	u32 guest_cid;
	bool seqpacket_allow;
	long: 0;
	struct scatterlist *out_sgs[18];
	struct scatterlist out_bufs[18];
} __attribute__((packed));

struct virtio_vsock_hdr {
	__le64 src_cid;
	__le64 dst_cid;
	__le32 src_port;
	__le32 dst_port;
	__le32 len;
	__le16 type;
	__le16 op;
	__le32 flags;
	__le32 buf_alloc;
	__le32 fwd_cnt;
} __attribute__((packed));

struct virtio_vsock_pkt_info {
	u32 remote_cid;
	u32 remote_port;
	struct vsock_sock *vsk;
	struct msghdr *msg;
	u32 pkt_len;
	u16 type;
	u16 op;
	u32 flags;
	bool reply;
};

struct virtio_vsock_skb_cb {
	bool reply;
	bool tap_delivered;
	u32 offset;
};

struct virtio_vsock_sock {
	struct vsock_sock *vsk;
	spinlock_t tx_lock;
	spinlock_t rx_lock;
	u32 tx_cnt;
	u32 peer_fwd_cnt;
	u32 peer_buf_alloc;
	size_t bytes_unsent;
	u32 fwd_cnt;
	u32 last_fwd_cnt;
	u32 rx_bytes;
	u32 buf_alloc;
	struct sk_buff_head rx_queue;
	u32 msg_count;
};

struct virtnet_info {
	struct virtio_device *vdev;
	struct virtqueue *cvq;
	struct net_device *dev;
	struct send_queue *sq;
	struct receive_queue *rq;
	unsigned int status;
	u16 max_queue_pairs;
	u16 curr_queue_pairs;
	u16 xdp_queue_pairs;
	bool xdp_enabled;
	bool big_packets;
	unsigned int big_packets_num_skbfrags;
	bool mergeable_rx_bufs;
	bool has_rss;
	bool has_rss_hash_report;
	u8 rss_key_size;
	u16 rss_indir_table_size;
	u32 rss_hash_types_supported;
	u32 rss_hash_types_saved;
	struct virtio_net_ctrl_rss rss;
	bool has_cvq;
	struct mutex cvq_lock;
	bool any_header_sg;
	u8 hdr_len;
	struct delayed_work refill;
	bool refill_enabled;
	spinlock_t refill_lock;
	struct work_struct config_work;
	struct work_struct rx_mode_work;
	bool rx_mode_work_enabled;
	bool affinity_hint_set;
	struct hlist_node node;
	struct hlist_node node_dead;
	struct control_buf *ctrl;
	u8 duplex;
	u32 speed;
	bool rx_dim_enabled;
	struct virtnet_interrupt_coalesce intr_coal_tx;
	struct virtnet_interrupt_coalesce intr_coal_rx;
	long unsigned int guest_offloads;
	long unsigned int guest_offloads_capable;
	struct failover *failover;
	u64 device_stats_cap;
};

struct virtnet_rq_dma {
	dma_addr_t addr;
	u32 ref;
	u16 len;
	u16 need_sync;
};

struct virtnet_sq_free_stats {
	u64 packets;
	u64 bytes;
	u64 napi_packets;
	u64 napi_bytes;
	u64 xsk;
};

struct virtnet_stat_desc {
	char desc[32];
	size_t offset;
	size_t qstat_offset;
};

struct virtnet_stats_ctx {
	bool to_qstat;
	u32 desc_num[3];
	u64 bitmap[3];
	u32 size[3];
	u64 *data;
};

struct virtqueue {
	struct list_head list;
	void (*callback)(struct virtqueue *);
	const char *name;
	struct virtio_device *vdev;
	unsigned int index;
	unsigned int num_free;
	unsigned int num_max;
	bool reset;
	void *priv;
};

typedef void vq_callback_t(struct virtqueue *);

struct virtqueue_info {
	const char *name;
	vq_callback_t *callback;
	bool ctx;
};

struct virtual_engine {
	struct intel_engine_cs base;
	struct intel_context context;
	struct rcu_work rcu;
	struct i915_request *request;
	struct ve_node nodes[27];
	unsigned int num_siblings;
	struct intel_engine_cs *siblings[0];
};

struct vlan_priority_tci_mapping;

struct vlan_dev_priv {
	unsigned int nr_ingress_mappings;
	u32 ingress_priority_map[8];
	unsigned int nr_egress_mappings;
	struct vlan_priority_tci_mapping *egress_priority_map[16];
	__be16 vlan_proto;
	u16 vlan_id;
	u16 flags;
	struct net_device *real_dev;
	netdevice_tracker dev_tracker;
	unsigned char real_dev_addr[6];
	struct proc_dir_entry *dent;
	struct vlan_pcpu_stats *vlan_pcpu_stats;
	struct netpoll *netpoll;
};

struct vlan_group {
	unsigned int nr_vlan_devs;
	struct hlist_node hlist;
	struct net_device **vlan_devices_arrays[16];
};

struct vlan_hdr {
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct vlan_info {
	struct net_device *real_dev;
	struct vlan_group grp;
	struct list_head vid_list;
	unsigned int nr_vids;
	struct callback_head rcu;
};

struct vlan_pcpu_stats {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t rx_multicast;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	struct u64_stats_sync syncp;
	u32 rx_errors;
	u32 tx_dropped;
};

struct vlan_priority_tci_mapping {
	u32 priority;
	u16 vlan_qos;
	struct vlan_priority_tci_mapping *next;
};

struct vlan_vid_info {
	struct list_head list;
	__be16 proto;
	u16 vid;
	int refcount;
};

struct vlv_s0ix_state {
	u32 wr_watermark;
	u32 gfx_prio_ctrl;
	u32 arb_mode;
	u32 gfx_pend_tlb0;
	u32 gfx_pend_tlb1;
	u32 lra_limits[13];
	u32 media_max_req_count;
	u32 gfx_max_req_count;
	u32 render_hwsp;
	u32 ecochk;
	u32 bsd_hwsp;
	u32 blt_hwsp;
	u32 tlb_rd_addr;
	u32 g3dctl;
	u32 gsckgctl;
	u32 mbctl;
	u32 ucgctl1;
	u32 ucgctl3;
	u32 rcgctl1;
	u32 rcgctl2;
	u32 rstctl;
	u32 misccpctl;
	u32 gfxpause;
	u32 rpdeuhwtc;
	u32 rpdeuc;
	u32 ecobus;
	u32 pwrdwnupctl;
	u32 rp_down_timeout;
	u32 rp_deucsw;
	u32 rcubmabdtmr;
	u32 rcedata;
	u32 spare2gh;
	u32 gt_imr;
	u32 gt_ier;
	u32 pm_imr;
	u32 pm_ier;
	u32 gt_scratch[8];
	u32 tilectl;
	u32 gt_fifoctl;
	u32 gtlc_wake_ctrl;
	u32 gtlc_survive;
	u32 pmwgicz;
	u32 gu_ctl0;
	u32 gu_ctl1;
	u32 pcbr;
	u32 clock_gate_dis2;
};

struct vm_userfaultfd_ctx {};

struct vma_lock;

struct vm_area_struct {
	union {
		struct {
			long unsigned int vm_start;
			long unsigned int vm_end;
		};
		struct callback_head vm_rcu;
	};
	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	union {
		const vm_flags_t vm_flags;
		vm_flags_t __vm_flags;
	};
	bool detached;
	unsigned int vm_lock_seq;
	struct vma_lock *vm_lock;
	struct {
		struct rb_node rb;
		long unsigned int rb_subtree_last;
	} shared;
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct *vm_ops;
	long unsigned int vm_pgoff;
	struct file *vm_file;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct mempolicy *vm_policy;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

struct vm_event_state {
	long unsigned int event[82];
};

struct vm_fault {
	const struct {
		struct vm_area_struct *vma;
		gfp_t gfp_mask;
		long unsigned int pgoff;
		long unsigned int address;
		long unsigned int real_address;
	};
	enum fault_flag flags;
	pmd_t *pmd;
	pud_t *pud;
	union {
		pte_t orig_pte;
		pmd_t orig_pmd;
	};
	struct page *cow_page;
	struct page *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t prealloc_pte;
};

struct vm_operations_struct {
	void (*open)(struct vm_area_struct *);
	void (*close)(struct vm_area_struct *);
	int (*may_split)(struct vm_area_struct *, long unsigned int);
	int (*mremap)(struct vm_area_struct *);
	int (*mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);
	vm_fault_t (*fault)(struct vm_fault *);
	vm_fault_t (*huge_fault)(struct vm_fault *, unsigned int);
	vm_fault_t (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);
	long unsigned int (*pagesize)(struct vm_area_struct *);
	vm_fault_t (*page_mkwrite)(struct vm_fault *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
	int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
	const char * (*name)(struct vm_area_struct *);
	int (*set_policy)(struct vm_area_struct *, struct mempolicy *);
	struct mempolicy * (*get_policy)(struct vm_area_struct *, long unsigned int, long unsigned int *);
	struct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);
};

struct vm_special_mapping {
	const char *name;
	struct page **pages;
	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
	void (*close)(const struct vm_special_mapping *, struct vm_area_struct *);
};

struct vm_stack {
	struct callback_head rcu;
	struct vm_struct *stack_vm_area;
};

struct vm_struct {
	struct vm_struct *next;
	void *addr;
	long unsigned int size;
	long unsigned int flags;
	struct page **pages;
	unsigned int page_order;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

struct vm_unmapped_area_info {
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
	long unsigned int start_gap;
};

struct vma_list {
	struct vm_area_struct *vma;
	struct list_head head;
	refcount_t mmap_count;
};

struct vma_lock {
	struct rw_semaphore lock;
};

struct vma_merge_struct {
	struct mm_struct *mm;
	struct vma_iterator *vmi;
	long unsigned int pgoff;
	struct vm_area_struct *prev;
	struct vm_area_struct *next;
	struct vm_area_struct *vma;
	long unsigned int start;
	long unsigned int end;
	long unsigned int flags;
	struct file *file;
	struct anon_vma *anon_vma;
	struct mempolicy *policy;
	struct vm_userfaultfd_ctx uffd_ctx;
	struct anon_vma_name *anon_name;
	enum vma_merge_flags merge_flags;
	enum vma_merge_state state;
};

struct vma_prepare {
	struct vm_area_struct *vma;
	struct vm_area_struct *adj_next;
	struct file *file;
	struct address_space *mapping;
	struct anon_vma *anon_vma;
	struct vm_area_struct *insert;
	struct vm_area_struct *remove;
	struct vm_area_struct *remove2;
};

struct vmap_area {
	long unsigned int va_start;
	long unsigned int va_end;
	struct rb_node rb_node;
	struct list_head list;
	union {
		long unsigned int subtree_max_size;
		struct vm_struct *vm;
	};
	long unsigned int flags;
};

struct vmap_block {
	spinlock_t lock;
	struct vmap_area *va;
	long unsigned int free;
	long unsigned int dirty;
	long unsigned int used_map[16];
	long unsigned int dirty_min;
	long unsigned int dirty_max;
	struct list_head free_list;
	struct callback_head callback_head;
	struct list_head purge;
	unsigned int cpu;
};

struct vmap_block_queue {
	spinlock_t lock;
	struct list_head free;
	struct xarray vmap_blocks;
};

struct vmap_pool {
	struct list_head head;
	long unsigned int len;
};

struct vmap_node {
	struct vmap_pool pool[256];
	spinlock_t pool_lock;
	bool skip_populate;
	struct rb_list busy;
	struct rb_list lazy;
	struct list_head purge_list;
	struct work_struct purge_work;
	long unsigned int nr_purged;
};

struct vmap_pfn_data {
	long unsigned int *pfns;
	pgprot_t prot;
	unsigned int idx;
};

struct vmclock_abi {
	__le32 magic;
	__le32 size;
	__le16 version;
	__u8 counter_id;
	__u8 time_type;
	__le32 seq_count;
	__le64 disruption_marker;
	__le64 flags;
	__u8 pad[2];
	__u8 clock_status;
	__u8 leap_second_smearing_hint;
	__le16 tai_offset_sec;
	__u8 leap_indicator;
	__u8 counter_period_shift;
	__le64 counter_value;
	__le64 counter_period_frac_sec;
	__le64 counter_period_esterror_rate_frac_sec;
	__le64 counter_period_maxerror_rate_frac_sec;
	__le64 time_sec;
	__le64 time_frac_sec;
	__le64 time_esterror_nanosec;
	__le64 time_maxerror_nanosec;
};

struct vmclock_state {
	struct resource res;
	struct vmclock_abi *clk;
	struct miscdevice miscdev;
	struct ptp_clock_info ptp_clock_info;
	struct ptp_clock *ptp_clock;
	enum clocksource_ids cs_id;
	enum clocksource_ids sys_cs_id;
	int index;
	char *name;
};

struct vmcore_cb {
	bool (*pfn_is_ram)(struct vmcore_cb *, long unsigned int);
	int (*get_device_ram)(struct vmcore_cb *, struct list_head *);
	struct list_head next;
};

struct vmcore_range {
	struct list_head list;
	long long unsigned int paddr;
	long long unsigned int size;
	loff_t offset;
};

struct vmemmap_remap_walk {
	void (*remap_pte)(pte_t *, long unsigned int, struct vmemmap_remap_walk *);
	long unsigned int nr_walked;
	struct page *reuse_page;
	long unsigned int reuse_addr;
	struct list_head *vmemmap_pages;
	long unsigned int flags;
};

struct vmpressure_event {
	struct eventfd_ctx *efd;
	enum vmpressure_levels level;
	enum vmpressure_modes mode;
	struct list_head node;
};

struct vmware_steal_time {
	union {
		u64 clock;
		struct {
			u32 clock_low;
			u32 clock_high;
		};
	};
	u64 reserved[7];
};

struct vport_portids;

struct vport_ops;

struct vport_upcall_stats_percpu;

struct vport {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct datapath *dp;
	struct vport_portids *upcall_portids;
	u16 port_no;
	struct hlist_node hash_node;
	struct hlist_node dp_hash_node;
	const struct vport_ops *ops;
	struct vport_upcall_stats_percpu *upcall_stats;
	struct list_head detach_list;
	struct callback_head rcu;
};

struct vport_parms;

struct vport_ops {
	enum ovs_vport_type type;
	struct vport * (*create)(const struct vport_parms *);
	void (*destroy)(struct vport *);
	int (*set_options)(struct vport *, struct nlattr *);
	int (*get_options)(const struct vport *, struct sk_buff *);
	int (*send)(struct sk_buff *);
	struct module *owner;
	struct list_head list;
};

struct vport_parms {
	const char *name;
	enum ovs_vport_type type;
	int desired_ifindex;
	struct nlattr *options;
	struct datapath *dp;
	u16 port_no;
	struct nlattr *upcall_portids;
};

struct vport_portids {
	struct reciprocal_value rn_ids;
	struct callback_head rcu;
	u32 n_ids;
	u32 ids[0];
};

struct vport_upcall_stats_percpu {
	struct u64_stats_sync syncp;
	u64_stats_t n_success;
	u64_stats_t n_fail;
};

struct vring_desc;

typedef struct vring_desc vring_desc_t;

struct vring_avail;

typedef struct vring_avail vring_avail_t;

struct vring_used;

typedef struct vring_used vring_used_t;

struct vring {
	unsigned int num;
	vring_desc_t *desc;
	vring_avail_t *avail;
	vring_used_t *used;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[0];
};

struct vring_desc {
	__virtio64 addr;
	__virtio32 len;
	__virtio16 flags;
	__virtio16 next;
};

struct vring_desc_extra {
	dma_addr_t addr;
	u32 len;
	u16 flags;
	u16 next;
};

struct vring_packed_desc;

struct vring_desc_state_packed {
	void *data;
	struct vring_packed_desc *indir_desc;
	u16 num;
	u16 last;
};

struct vring_desc_state_split {
	void *data;
	struct vring_desc *indir_desc;
};

struct vring_packed_desc {
	__le64 addr;
	__le32 len;
	__le16 id;
	__le16 flags;
};

struct vring_packed_desc_event {
	__le16 off_wrap;
	__le16 flags;
};

struct vring_used_elem {
	__virtio32 id;
	__virtio32 len;
};

typedef struct vring_used_elem vring_used_elem_t;

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	vring_used_elem_t ring[0];
};

struct vring_virtqueue_split {
	struct vring vring;
	u16 avail_flags_shadow;
	u16 avail_idx_shadow;
	struct vring_desc_state_split *desc_state;
	struct vring_desc_extra *desc_extra;
	dma_addr_t queue_dma_addr;
	size_t queue_size_in_bytes;
	u32 vring_align;
	bool may_reduce_num;
};

struct vring_virtqueue_packed {
	struct {
		unsigned int num;
		struct vring_packed_desc *desc;
		struct vring_packed_desc_event *driver;
		struct vring_packed_desc_event *device;
	} vring;
	bool avail_wrap_counter;
	u16 avail_used_flags;
	u16 next_avail_idx;
	u16 event_flags_shadow;
	struct vring_desc_state_packed *desc_state;
	struct vring_desc_extra *desc_extra;
	dma_addr_t ring_dma_addr;
	dma_addr_t driver_event_dma_addr;
	dma_addr_t device_event_dma_addr;
	size_t ring_size_in_bytes;
	size_t event_size_in_bytes;
};

struct vring_virtqueue {
	struct virtqueue vq;
	bool packed_ring;
	bool use_dma_api;
	bool weak_barriers;
	bool broken;
	bool indirect;
	bool event;
	unsigned int free_head;
	unsigned int num_added;
	u16 last_used_idx;
	bool event_triggered;
	union {
		struct vring_virtqueue_split split;
		struct vring_virtqueue_packed packed;
	};
	bool (*notify)(struct virtqueue *);
	bool we_own_ring;
	struct device *dma_dev;
};

struct vsock_diag_msg {
	__u8 vdiag_family;
	__u8 vdiag_type;
	__u8 vdiag_state;
	__u8 vdiag_shutdown;
	__u32 vdiag_src_cid;
	__u32 vdiag_src_port;
	__u32 vdiag_dst_cid;
	__u32 vdiag_dst_port;
	__u32 vdiag_ino;
	__u32 vdiag_cookie[2];
};

struct vsock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 vdiag_states;
	__u32 vdiag_ino;
	__u32 vdiag_show;
	__u32 vdiag_cookie[2];
};

struct vsock_loopback {
	struct workqueue_struct *workqueue;
	struct sk_buff_head pkt_queue;
	struct work_struct pkt_work;
};

struct vsock_sock {
	struct sock sk;
	const struct vsock_transport *transport;
	struct sockaddr_vm local_addr;
	struct sockaddr_vm remote_addr;
	struct list_head bound_table;
	struct list_head connected_table;
	bool trusted;
	bool cached_peer_allow_dgram;
	u32 cached_peer;
	const struct cred *owner;
	long int connect_timeout;
	struct sock *listener;
	struct list_head pending_links;
	struct list_head accept_queue;
	bool rejected;
	struct delayed_work connect_work;
	struct delayed_work pending_work;
	struct delayed_work close_work;
	bool close_work_scheduled;
	u32 peer_shutdown;
	bool sent_request;
	bool ignore_connecting_rst;
	u64 buffer_size;
	u64 buffer_min_size;
	u64 buffer_max_size;
	void *trans;
};

struct vsock_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct vsock_transport_recv_notify_data {
	u64 data1;
	u64 data2;
	bool notify_on_block;
};

struct vsock_transport_send_notify_data {
	u64 data1;
	u64 data2;
};

struct vt_consize {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_vlin;
	short unsigned int v_clin;
	short unsigned int v_vcol;
	short unsigned int v_ccol;
};

struct vt_event {
	unsigned int event;
	unsigned int oldev;
	unsigned int newev;
	unsigned int pad[4];
};

struct vt_event_wait {
	struct list_head list;
	struct vt_event event;
	int done;
};

struct vt_notifier_param {
	struct vc_data *vc;
	unsigned int c;
};

struct vt_setactivate {
	unsigned int console;
	struct vt_mode mode;
};

struct vt_sizes {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_scrollsize;
};

struct vt_spawn_console {
	spinlock_t lock;
	struct pid *pid;
	int sig;
};

struct vt_stat {
	short unsigned int v_active;
	short unsigned int v_signal;
	short unsigned int v_state;
};

struct vti6_net {
	struct net_device *fb_tnl_dev;
	struct ip6_tnl *tnls_r_l[32];
	struct ip6_tnl *tnls_wc[1];
	struct ip6_tnl **tnls[2];
};

struct vtunnel_info {
	u32 tunid;
	u16 vid;
	u16 flags;
};

struct vxlanhdr {
	__be32 vx_flags;
	__be32 vx_vni;
};

struct vxlan_config {
	union vxlan_addr remote_ip;
	union vxlan_addr saddr;
	__be32 vni;
	int remote_ifindex;
	int mtu;
	__be16 dst_port;
	u16 port_min;
	u16 port_max;
	u8 tos;
	u8 ttl;
	__be32 label;
	enum ifla_vxlan_label_policy label_policy;
	u32 flags;
	long unsigned int age_interval;
	unsigned int addrmax;
	bool no_share;
	enum ifla_vxlan_df df;
	struct vxlanhdr reserved_bits;
};

struct vxlan_dev;

struct vxlan_dev_node {
	struct hlist_node hlist;
	struct vxlan_dev *vxlan;
};

struct vxlan_rdst {
	union vxlan_addr remote_ip;
	__be16 remote_port;
	u8 offloaded: 1;
	__be32 remote_vni;
	u32 remote_ifindex;
	struct net_device *remote_dev;
	struct list_head list;
	struct callback_head rcu;
	struct dst_cache dst_cache;
};

struct vxlan_sock;

struct vxlan_vni_group;

struct vxlan_dev {
	struct vxlan_dev_node hlist4;
	struct vxlan_dev_node hlist6;
	struct list_head next;
	struct vxlan_sock *vn4_sock;
	struct vxlan_sock *vn6_sock;
	struct net_device *dev;
	struct net *net;
	struct vxlan_rdst default_dst;
	struct timer_list age_timer;
	spinlock_t hash_lock[256];
	unsigned int addrcnt;
	struct gro_cells gro_cells;
	struct vxlan_config cfg;
	struct vxlan_vni_group *vnigrp;
	struct hlist_head fdb_head[256];
	struct rhashtable mdb_tbl;
	struct hlist_head mdb_list;
	unsigned int mdb_seq;
};

struct vxlan_fdb {
	struct hlist_node hlist;
	struct callback_head rcu;
	long unsigned int updated;
	long unsigned int used;
	struct list_head remotes;
	u8 eth_addr[6];
	u16 state;
	__be32 vni;
	u16 flags;
	struct list_head nh_list;
	struct nexthop *nh;
	struct vxlan_dev *vdev;
};

struct vxlan_fdb_flush_desc {
	bool ignore_default_entry;
	long unsigned int state;
	long unsigned int state_mask;
	long unsigned int flags;
	long unsigned int flags_mask;
	__be32 src_vni;
	u32 nhid;
	__be32 vni;
	__be16 port;
	union vxlan_addr dst_ip;
};

struct vxlan_mdb_entry_key {
	union vxlan_addr src;
	union vxlan_addr dst;
	__be32 vni;
};

struct vxlan_mdb_config {
	struct vxlan_dev *vxlan;
	struct vxlan_mdb_entry_key group;
	struct list_head src_list;
	union vxlan_addr remote_ip;
	u32 remote_ifindex;
	__be32 remote_vni;
	__be16 remote_port;
	u16 nlflags;
	u8 flags;
	u8 filter_mode;
	u8 rt_protocol;
};

struct vxlan_mdb_config_src_entry {
	union vxlan_addr addr;
	struct list_head node;
};

struct vxlan_mdb_dump_ctx {
	long int reserved;
	long int entry_idx;
	long int remote_idx;
};

struct vxlan_mdb_entry {
	struct rhash_head rhnode;
	struct list_head remotes;
	struct vxlan_mdb_entry_key key;
	struct hlist_node mdb_node;
	struct callback_head rcu;
};

struct vxlan_mdb_flush_desc {
	union vxlan_addr remote_ip;
	__be32 src_vni;
	__be32 remote_vni;
	__be16 remote_port;
	u8 rt_protocol;
};

struct vxlan_mdb_remote {
	struct list_head list;
	struct vxlan_rdst *rd;
	u8 flags;
	u8 filter_mode;
	u8 rt_protocol;
	struct hlist_head src_list;
	struct callback_head rcu;
};

struct vxlan_mdb_src_entry {
	struct hlist_node node;
	union vxlan_addr addr;
	u8 flags;
};

struct vxlan_net {
	struct list_head vxlan_list;
	struct hlist_head sock_list[256];
	spinlock_t sock_lock;
	struct notifier_block nexthop_notifier_block;
};

struct vxlan_sock {
	struct hlist_node hlist;
	struct socket *sock;
	struct hlist_head vni_list[1024];
	refcount_t refcnt;
	u32 flags;
};

struct vxlan_vni_group {
	struct rhashtable vni_hash;
	struct list_head vni_list;
	u32 num_vnis;
};

struct vxlan_vni_stats_pcpu;

struct vxlan_vni_node {
	struct rhash_head vnode;
	struct vxlan_dev_node hlist4;
	struct vxlan_dev_node hlist6;
	struct list_head vlist;
	__be32 vni;
	union vxlan_addr remote_ip;
	struct vxlan_vni_stats_pcpu *stats;
	struct callback_head rcu;
};

struct vxlan_vni_stats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 rx_drops;
	u64 rx_errors;
	u64 tx_packets;
	u64 tx_bytes;
	u64 tx_drops;
	u64 tx_errors;
};

struct vxlan_vni_stats_pcpu {
	struct vxlan_vni_stats stats;
	struct u64_stats_sync syncp;
};

struct vxlanhdr_gbp {
	u8 vx_flags;
	u8 reserved_flags1: 3;
	u8 policy_applied: 1;
	u8 reserved_flags2: 2;
	u8 dont_learn: 1;
	u8 reserved_flags3: 1;
	__be16 policy_id;
	__be32 vx_vni;
};

struct vxlanhdr_gpe {
	u8 oam_flag: 1;
	u8 reserved_flags1: 1;
	u8 np_applied: 1;
	u8 instance_applied: 1;
	u8 version: 2;
	u8 reserved_flags2: 2;
	u8 reserved_flags3;
	u8 reserved_flags4;
	u8 next_protocol;
	__be32 vx_vni;
};

struct wait_barrier {
	struct wait_queue_entry base;
	struct i915_active *ref;
};

struct wait_bit_key {
	long unsigned int *flags;
	int bit_nr;
	long unsigned int timeout;
};

struct wait_bit_queue_entry {
	struct wait_bit_key key;
	struct wait_queue_entry wq_entry;
};

struct wait_page_key {
	struct folio *folio;
	int bit_nr;
	int page_match;
};

struct wait_rps_boost {
	struct wait_queue_entry wait;
	struct drm_crtc *crtc;
	struct i915_request *request;
};

struct waiting_dir_move {
	struct rb_node node;
	u64 ino;
	u64 rmdir_ino;
	u64 rmdir_gen;
	bool orphanized;
};

struct wake_irq {
	struct device *dev;
	unsigned int status;
	int irq;
	const char *name;
};

struct wakeup_header {
	u16 video_mode;
	u32 pmode_entry;
	u16 pmode_cs;
	u32 pmode_cr0;
	u32 pmode_cr3;
	u32 pmode_cr4;
	u32 pmode_efer_low;
	u32 pmode_efer_high;
	u64 pmode_gdt;
	u32 pmode_misc_en_low;
	u32 pmode_misc_en_high;
	u32 pmode_behavior;
	u32 realmode_flags;
	u32 real_magic;
	u32 signature;
} __attribute__((packed));

struct wakeup_source {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	long unsigned int timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	long unsigned int event_count;
	long unsigned int active_count;
	long unsigned int relax_count;
	long unsigned int expire_count;
	long unsigned int wakeup_count;
	struct device *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
};

struct walk_control {
	u64 refs[8];
	u64 flags[8];
	struct btrfs_key update_progress;
	struct btrfs_key drop_progress;
	int drop_level;
	int stage;
	int level;
	int shared_level;
	int update_ref;
	int keep_locks;
	int reada_slot;
	int reada_count;
	int restarted;
	int lookup_info;
};

struct walk_control___2 {
	int free;
	int pin;
	int stage;
	bool ignore_cur_inode;
	struct btrfs_root *replay_dest;
	struct btrfs_trans_handle *trans;
	int (*process_func)(struct btrfs_root *, struct extent_buffer *, struct walk_control___2 *, u64, int);
};

struct walk_rcec_data {
	struct pci_dev *rcec;
	int (*user_callback)(struct pci_dev *, void *);
	void *user_data;
};

struct warn_args {
	const char *fmt;
	va_list args;
};

struct watchdog_device;

struct watchdog_core_data {
	struct device dev;
	struct cdev cdev;
	struct watchdog_device *wdd;
	struct mutex lock;
	ktime_t last_keepalive;
	ktime_t last_hw_keepalive;
	ktime_t open_deadline;
	struct hrtimer timer;
	struct kthread_work work;
	long unsigned int status;
};

struct watchdog_info;

struct watchdog_ops;

struct watchdog_governor;

struct watchdog_device {
	int id;
	struct device *parent;
	const struct attribute_group **groups;
	const struct watchdog_info *info;
	const struct watchdog_ops *ops;
	const struct watchdog_governor *gov;
	unsigned int bootstatus;
	unsigned int timeout;
	unsigned int pretimeout;
	unsigned int min_timeout;
	unsigned int max_timeout;
	unsigned int min_hw_heartbeat_ms;
	unsigned int max_hw_heartbeat_ms;
	struct notifier_block reboot_nb;
	struct notifier_block restart_nb;
	struct notifier_block pm_nb;
	void *driver_data;
	struct watchdog_core_data *wd_data;
	long unsigned int status;
	struct list_head deferred;
};

struct watchdog_governor {
	const char name[20];
	void (*pretimeout)(struct watchdog_device *);
};

struct watchdog_info {
	__u32 options;
	__u32 firmware_version;
	__u8 identity[32];
};

struct watchdog_ops {
	struct module *owner;
	int (*start)(struct watchdog_device *);
	int (*stop)(struct watchdog_device *);
	int (*ping)(struct watchdog_device *);
	unsigned int (*status)(struct watchdog_device *);
	int (*set_timeout)(struct watchdog_device *, unsigned int);
	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
	unsigned int (*get_timeleft)(struct watchdog_device *);
	int (*restart)(struct watchdog_device *, long unsigned int, void *);
	long int (*ioctl)(struct watchdog_device *, unsigned int, long unsigned int);
};

struct wb_lock_cookie {
	bool locked;
	long unsigned int flags;
};

struct wb_stats {
	long unsigned int nr_dirty;
	long unsigned int nr_io;
	long unsigned int nr_more_io;
	long unsigned int nr_dirty_time;
	long unsigned int nr_writeback;
	long unsigned int nr_reclaimable;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	long unsigned int dirty_thresh;
	long unsigned int wb_thresh;
};

struct wb_writeback_work {
	long int nr_pages;
	struct super_block *sb;
	enum writeback_sync_modes sync_mode;
	unsigned int tagged_writepages: 1;
	unsigned int for_kupdate: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_background: 1;
	unsigned int for_sync: 1;
	unsigned int auto_free: 1;
	enum wb_reason reason;
	struct list_head list;
	struct wb_completion *done;
};

struct westwood {
	u32 bw_ns_est;
	u32 bw_est;
	u32 rtt_win_sx;
	u32 bk;
	u32 snd_una;
	u32 cumul_ack;
	u32 accounted;
	u32 rtt;
	u32 rtt_min;
	u8 first_ack;
	u8 reset_rtt_min;
};

struct wired_cmd_ake_send_hprime_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 h_prime[32];
};

struct wired_cmd_ake_send_hprime_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_ake_send_pairing_info_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 e_kh_km[16];
};

struct wired_cmd_ake_send_pairing_info_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_close_session_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_close_session_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_enable_auth_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 stream_type;
} __attribute__((packed));

struct wired_cmd_enable_auth_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_get_session_key_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_get_session_key_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 e_dkey_ks[16];
	u8 r_iv[8];
};

struct wired_cmd_init_locality_check_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_init_locality_check_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 r_n[8];
};

struct wired_cmd_initiate_hdcp2_session_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 protocol;
} __attribute__((packed));

struct wired_cmd_initiate_hdcp2_session_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 r_tx[8];
	struct hdcp2_tx_caps tx_caps;
} __attribute__((packed));

struct wired_cmd_repeater_auth_stream_req_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 seq_num_m[3];
	u8 m_prime[32];
	__be16 k;
	struct hdcp2_streamid_type streams[0];
} __attribute__((packed));

struct wired_cmd_repeater_auth_stream_req_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_validate_locality_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 l_prime[32];
};

struct wired_cmd_validate_locality_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
};

struct wired_cmd_verify_receiver_cert_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	struct hdcp2_cert_rx cert_rx;
	u8 r_rx[8];
	u8 rx_caps[3];
} __attribute__((packed));

struct wired_cmd_verify_receiver_cert_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 km_stored;
	u8 reserved[3];
	union encrypted_buff ekm_buff;
};

struct wired_cmd_verify_repeater_in {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 rx_info[2];
	u8 seq_num_v[3];
	u8 v_prime[16];
	u8 receiver_ids[155];
};

struct wired_cmd_verify_repeater_out {
	struct hdcp_cmd_header header;
	struct hdcp_port_id port;
	u8 content_type_supported;
	u8 v[16];
} __attribute__((packed));

struct wmi_device {
	struct device dev;
	bool setable;
	const char *driver_override;
};

typedef void (*wmi_notify_handler)(union acpi_object *, void *);

struct wmi_block {
	struct wmi_device dev;
	struct guid_block gblock;
	struct acpi_device *acpi_device;
	struct rw_semaphore notify_lock;
	wmi_notify_handler handler;
	void *handler_data;
	bool driver_ready;
	long unsigned int flags;
};

struct wmi_brightness_args {
	u32 mode;
	u32 val;
	u32 ret;
	u32 ignored[3];
};

struct wmi_device_id {
	const char guid_string[37];
	const void *context;
};

struct wmi_driver {
	struct device_driver driver;
	const struct wmi_device_id *id_table;
	bool no_notify_data;
	bool no_singleton;
	int (*probe)(struct wmi_device *, const void *);
	void (*remove)(struct wmi_device *);
	void (*shutdown)(struct wmi_device *);
	void (*notify)(struct wmi_device *, union acpi_object *);
};

struct wmi_guid_count_context {
	const guid_t *guid;
	int count;
};

struct wol_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_wolinfo wol;
	bool show_sopass;
};

struct word_at_a_time {
	const long unsigned int one_bits;
	const long unsigned int high_bits;
};

struct work_for_cpu {
	struct work_struct work;
	long int (*fn)(void *);
	void *arg;
	long int ret;
};

struct work_offq_data {
	u32 pool_id;
	u32 disable;
	u32 flags;
};

struct work_queue_wrapper {
	struct work_struct work;
	struct scsi_device *sdev;
};

struct worker {
	union {
		struct list_head entry;
		struct hlist_node hentry;
	};
	struct work_struct *current_work;
	work_func_t current_func;
	struct pool_workqueue *current_pwq;
	u64 current_at;
	unsigned int current_color;
	int sleeping;
	work_func_t last_func;
	struct list_head scheduled;
	struct task_struct *task;
	struct worker_pool *pool;
	struct list_head node;
	long unsigned int last_active;
	unsigned int flags;
	int id;
	char desc[32];
	struct workqueue_struct *rescue_wq;
};

struct worker_pool {
	raw_spinlock_t lock;
	int cpu;
	int node;
	int id;
	unsigned int flags;
	long unsigned int watchdog_ts;
	bool cpu_stall;
	int nr_running;
	struct list_head worklist;
	int nr_workers;
	int nr_idle;
	struct list_head idle_list;
	struct timer_list idle_timer;
	struct work_struct idle_cull_work;
	struct timer_list mayday_timer;
	struct hlist_head busy_hash[64];
	struct worker *manager;
	struct list_head workers;
	struct ida worker_ida;
	struct workqueue_attrs *attrs;
	struct hlist_node hash_node;
	int refcnt;
	struct callback_head rcu;
};

struct workqueue_attrs {
	int nice;
	cpumask_var_t cpumask;
	cpumask_var_t __pod_cpumask;
	bool affn_strict;
	enum wq_affn_scope affn_scope;
	bool ordered;
};

struct wq_flusher;

struct wq_device;

struct wq_node_nr_active;

struct workqueue_struct {
	struct list_head pwqs;
	struct list_head list;
	struct mutex mutex;
	int work_color;
	int flush_color;
	atomic_t nr_pwqs_to_flush;
	struct wq_flusher *first_flusher;
	struct list_head flusher_queue;
	struct list_head flusher_overflow;
	struct list_head maydays;
	struct worker *rescuer;
	int nr_drainers;
	int max_active;
	int min_active;
	int saved_max_active;
	int saved_min_active;
	struct workqueue_attrs *unbound_attrs;
	struct pool_workqueue *dfl_pwq;
	struct wq_device *wq_dev;
	char name[32];
	struct callback_head rcu;
	long: 64;
	long: 64;
	unsigned int flags;
	struct pool_workqueue **cpu_pwq;
	struct wq_node_nr_active *node_nr_active[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct workspace {
	void *mem;
	void *buf;
	void *cbuf;
	struct list_head list;
};

struct workspace___2 {
	z_stream strm;
	char *buf;
	unsigned int buf_size;
	struct list_head list;
	int level;
};

struct workspace___3 {
	void *mem;
	size_t size;
	char *buf;
	unsigned int level;
	unsigned int req_level;
	long unsigned int last_used;
	struct list_head list;
	struct list_head lru_list;
	zstd_in_buffer in_buf;
	zstd_out_buffer out_buf;
};

struct workspace_manager {
	struct list_head idle_ws;
	spinlock_t ws_lock;
	int free_ws;
	atomic_t total_ws;
	wait_queue_head_t ws_wait;
};

struct wpan_phy;

struct wpan_dev_header_ops;

struct wpan_dev {
	struct wpan_phy *wpan_phy;
	int iftype;
	struct list_head list;
	struct net_device *netdev;
	const struct wpan_dev_header_ops *header_ops;
	struct net_device *lowpan_dev;
	u32 identifier;
	__le16 pan_id;
	__le16 short_addr;
	__le64 extended_addr;
	atomic_t bsn;
	atomic_t dsn;
	u8 min_be;
	u8 max_be;
	u8 csma_retries;
	s8 frame_retries;
	bool lbt;
	bool ackreq;
	struct mutex association_lock;
	struct ieee802154_pan_device *parent;
	struct list_head children;
	unsigned int max_associations;
	unsigned int nchildren;
};

struct wpan_dev_header_ops {
	int (*create)(struct sk_buff *, struct net_device *, const struct ieee802154_addr *, const struct ieee802154_addr *, unsigned int);
};

struct wpan_phy_supported {
	u32 channels[32];
	u32 cca_modes;
	u32 cca_opts;
	u32 iftypes;
	enum nl802154_supported_bool_states lbt;
	u8 min_minbe;
	u8 max_minbe;
	u8 min_maxbe;
	u8 max_maxbe;
	u8 min_csma_backoffs;
	u8 max_csma_backoffs;
	s8 min_frame_retries;
	s8 max_frame_retries;
	size_t tx_powers_size;
	size_t cca_ed_levels_size;
	const s32 *tx_powers;
	const s32 *cca_ed_levels;
};

struct wpan_phy_cca {
	enum nl802154_cca_modes mode;
	enum nl802154_cca_opts opt;
};

struct wpan_phy {
	const void *privid;
	long unsigned int flags;
	u8 current_channel;
	u8 current_page;
	struct wpan_phy_supported supported;
	s32 transmit_power;
	struct wpan_phy_cca cca;
	__le64 perm_extended_addr;
	s32 cca_ed_level;
	u32 symbol_duration;
	u16 lifs_period;
	u16 sifs_period;
	struct device dev;
	possible_net_t _net;
	spinlock_t queue_lock;
	atomic_t ongoing_txs;
	atomic_t hold_txs;
	wait_queue_head_t sync_txq;
	enum ieee802154_filtering_level filtering;
	long: 0;
	char priv[0];
};

struct wq_barrier {
	struct work_struct work;
	struct completion done;
	struct task_struct *task;
};

struct wq_device {
	struct workqueue_struct *wq;
	struct device dev;
};

struct wq_drain_dead_softirq_work {
	struct work_struct work;
	struct worker_pool *pool;
	struct completion done;
};

struct wq_flusher {
	struct list_head list;
	int flush_color;
	struct completion done;
};

struct wq_node_nr_active {
	int max;
	atomic_t nr;
	raw_spinlock_t lock;
	struct list_head pending_pwqs;
};

struct wq_pod_type {
	int nr_pods;
	cpumask_var_t *pod_cpus;
	int *pod_node;
	int *cpu_pod;
};

typedef void (*swap_func_t)(void *, void *, int);

struct wrapper {
	cmp_func_t cmp;
	swap_func_t swap;
};

struct write_context {
	int no_wait;
	struct list_head *write_list;
};

struct writeback_control {
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	enum writeback_sync_modes sync_mode;
	unsigned int for_kupdate: 1;
	unsigned int for_background: 1;
	unsigned int tagged_writepages: 1;
	unsigned int for_reclaim: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_sync: 1;
	unsigned int unpinned_netfs_wb: 1;
	unsigned int no_cgroup_owner: 1;
	struct swap_iocb **swap_plug;
	struct list_head *list;
	struct folio_batch fbatch;
	long unsigned int index;
	int saved_err;
	struct bdi_writeback *wb;
	struct inode *inode;
	int wb_id;
	int wb_lcand_id;
	int wb_tcand_id;
	size_t wb_bytes;
	size_t wb_lcand_bytes;
	size_t wb_tcand_bytes;
};

struct writer {
	uint8_t *buffer;
	uint8_t previous_byte;
	size_t buffer_pos;
	int bufsize;
	size_t global_pos;
	long int (*flush)(void *, long unsigned int);
	struct lzma_header *header;
};

struct ww_class {
	atomic_long_t stamp;
	struct lock_class_key acquire_key;
	struct lock_class_key mutex_key;
	const char *acquire_name;
	const char *mutex_name;
	unsigned int is_wait_die;
};

struct x25_calluserdata {
	unsigned int cudlength;
	unsigned char cuddata[128];
};

struct x25_causediag {
	unsigned char cause;
	unsigned char diagnostic;
};

struct x25_dte_facilities {
	__u16 delay_cumul;
	__u16 delay_target;
	__u16 delay_max;
	__u8 min_throughput;
	__u8 expedited;
	__u8 calling_len;
	__u8 called_len;
	__u8 calling_ae[20];
	__u8 called_ae[20];
};

struct x25_facilities {
	unsigned int winsize_in;
	unsigned int winsize_out;
	unsigned int pacsize_in;
	unsigned int pacsize_out;
	unsigned int throughput;
	unsigned int reverse;
};

struct x25_forward {
	struct list_head node;
	unsigned int lci;
	struct net_device *dev1;
	struct net_device *dev2;
	atomic_t refcnt;
};

struct x25_neigh {
	struct list_head node;
	struct net_device *dev;
	unsigned int state;
	unsigned int extended;
	struct sk_buff_head queue;
	long unsigned int t20;
	struct timer_list t20timer;
	long unsigned int global_facil_mask;
	refcount_t refcnt;
};

struct x25_route {
	struct list_head node;
	struct x25_address address;
	unsigned int sigdigits;
	struct net_device *dev;
	refcount_t refcnt;
};

struct x25_route_struct {
	struct x25_address address;
	unsigned int sigdigits;
	char device[200];
};

struct x25_skb_cb {
	unsigned int flags;
};

struct x25_sock {
	struct sock sk;
	struct x25_address source_addr;
	struct x25_address dest_addr;
	struct x25_neigh *neighbour;
	unsigned int lci;
	unsigned int cudmatchlength;
	unsigned char state;
	unsigned char condition;
	short unsigned int vs;
	short unsigned int vr;
	short unsigned int va;
	short unsigned int vl;
	long unsigned int t2;
	long unsigned int t21;
	long unsigned int t22;
	long unsigned int t23;
	short unsigned int fraglen;
	long unsigned int flags;
	struct sk_buff_head ack_queue;
	struct sk_buff_head fragment_queue;
	struct sk_buff_head interrupt_in_queue;
	struct sk_buff_head interrupt_out_queue;
	struct timer_list timer;
	struct x25_causediag causediag;
	struct x25_facilities facilities;
	struct x25_dte_facilities dte_facilities;
	struct x25_calluserdata calluserdata;
	long unsigned int vc_facil_mask;
};

struct x25_subaddr {
	unsigned int cudmatchlength;
};

struct x25_subscrip_struct {
	char device[192];
	long unsigned int global_facil_mask;
	unsigned int extended;
};

struct x509_certificate {
	struct x509_certificate *next;
	struct x509_certificate *signer;
	struct public_key *pub;
	struct public_key_signature *sig;
	char *issuer;
	char *subject;
	struct asymmetric_key_id *id;
	struct asymmetric_key_id *skid;
	time64_t valid_from;
	time64_t valid_to;
	const void *tbs;
	unsigned int tbs_size;
	unsigned int raw_sig_size;
	const void *raw_sig;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_subject;
	unsigned int raw_subject_size;
	unsigned int raw_skid_size;
	const void *raw_skid;
	unsigned int index;
	bool seen;
	bool verified;
	bool self_signed;
	bool unsupported_sig;
	bool blacklisted;
};

struct x509_parse_context {
	struct x509_certificate *cert;
	long unsigned int data;
	const void *key;
	size_t key_size;
	const void *params;
	size_t params_size;
	enum OID key_algo;
	enum OID last_oid;
	enum OID sig_algo;
	u8 o_size;
	u8 cn_size;
	u8 email_size;
	u16 o_offset;
	u16 cn_offset;
	u16 email_offset;
	unsigned int raw_akid_size;
	const void *raw_akid;
	const void *akid_raw_issuer;
	unsigned int akid_raw_issuer_size;
};

struct x64_jit_data {
	struct bpf_binary_header *rw_header;
	struct bpf_binary_header *header;
	int *addrs;
	u8 *image;
	int proglen;
	struct jit_context ctx;
};

struct x86_apic_ops {
	unsigned int (*io_apic_read)(unsigned int, unsigned int);
	void (*restore)(void);
};

struct x86_cpuinit_ops {
	void (*setup_percpu_clockev)(void);
	void (*early_percpu_clock_init)(void);
	void (*fixup_cpu_id)(struct cpuinfo_x86 *, int);
	bool parallel_bringup;
};

struct x86_guest {
	int (*enc_status_change_prepare)(long unsigned int, int, bool);
	int (*enc_status_change_finish)(long unsigned int, int, bool);
	bool (*enc_tlb_flush_required)(bool);
	bool (*enc_cache_flush_required)(void);
	void (*enc_kexec_begin)(void);
	void (*enc_kexec_finish)(void);
};

struct x86_hybrid_pmu {
	struct pmu pmu;
	const char *name;
	enum hybrid_pmu_type pmu_type;
	cpumask_t supported_cpus;
	union perf_capabilities intel_cap;
	u64 intel_ctrl;
	u64 pebs_events_mask;
	u64 config_mask;
	union {
		u64 cntr_mask64;
		long unsigned int cntr_mask[1];
	};
	union {
		u64 fixed_cntr_mask64;
		long unsigned int fixed_cntr_mask[1];
	};
	struct event_constraint unconstrained;
	u64 hw_cache_event_ids[42];
	u64 hw_cache_extra_regs[42];
	struct event_constraint *event_constraints;
	struct event_constraint *pebs_constraints;
	struct extra_reg *extra_regs;
	unsigned int late_ack: 1;
	unsigned int mid_ack: 1;
	unsigned int enabled_ack: 1;
	u64 pebs_data_source[256];
};

struct x86_init_acpi {
	void (*set_root_pointer)(u64);
	u64 (*get_root_pointer)(void);
	void (*reduced_hw_early_init)(void);
};

struct x86_init_iommu {
	int (*iommu_init)(void);
};

struct x86_init_irqs {
	void (*pre_vector_init)(void);
	void (*intr_init)(void);
	void (*intr_mode_select)(void);
	void (*intr_mode_init)(void);
	struct irq_domain * (*create_pci_msi_domain)(void);
};

struct x86_init_mpparse {
	void (*setup_ioapic_ids)(void);
	void (*find_mptable)(void);
	void (*early_parse_smp_cfg)(void);
	void (*parse_smp_cfg)(void);
};

struct x86_init_oem {
	void (*arch_setup)(void);
	void (*banner)(void);
};

struct x86_init_resources {
	void (*probe_roms)(void);
	void (*reserve_resources)(void);
	char * (*memory_setup)(void);
	void (*dmi_setup)(void);
};

struct x86_init_paging {
	void (*pagetable_init)(void);
};

struct x86_init_timers {
	void (*setup_percpu_clockev)(void);
	void (*timer_init)(void);
	void (*wallclock_init)(void);
};

struct x86_init_pci {
	int (*arch_init)(void);
	int (*init)(void);
	void (*init_irq)(void);
	void (*fixup_irqs)(void);
};

struct x86_init_ops {
	struct x86_init_resources resources;
	struct x86_init_mpparse mpparse;
	struct x86_init_irqs irqs;
	struct x86_init_oem oem;
	struct x86_init_paging paging;
	struct x86_init_timers timers;
	struct x86_init_iommu iommu;
	struct x86_init_pci pci;
	struct x86_hyper_init hyper;
	struct x86_init_acpi acpi;
};

struct x86_legacy_devices {
	int pnpbios;
};

struct x86_legacy_features {
	enum x86_legacy_i8042_state i8042;
	int rtc;
	int warm_reset;
	int no_vga;
	int reserve_bios_regions;
	struct x86_legacy_devices devices;
};

struct x86_mapping_info {
	void * (*alloc_pgt_page)(void *);
	void (*free_pgt_page)(void *, void *);
	void *context;
	long unsigned int page_flag;
	long unsigned int offset;
	bool direct_gbpages;
	long unsigned int kernpg_flag;
};

struct x86_perf_regs {
	struct pt_regs regs;
	u64 *xmm_regs;
};

struct x86_perf_task_context_opt {
	int lbr_callstack_users;
	int lbr_stack_state;
	int log_id;
};

struct x86_perf_task_context {
	u64 lbr_sel;
	int tos;
	int valid_lbrs;
	struct x86_perf_task_context_opt opt;
	struct lbr_entry lbr[32];
};

struct x86_perf_task_context_arch_lbr {
	struct x86_perf_task_context_opt opt;
	struct lbr_entry entries[0];
};

struct x86_perf_task_context_arch_lbr_xsave {
	struct x86_perf_task_context_opt opt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct xregs_state xsave;
		struct {
			struct fxregs_state i387;
			struct xstate_header header;
			struct arch_lbr_state lbr;
			long: 64;
			long: 64;
			long: 64;
		};
	};
};

struct x86_platform_ops {
	long unsigned int (*calibrate_cpu)(void);
	long unsigned int (*calibrate_tsc)(void);
	void (*get_wallclock)(struct timespec64 *);
	int (*set_wallclock)(const struct timespec64 *);
	void (*iommu_shutdown)(void);
	bool (*is_untracked_pat_range)(u64, u64);
	void (*nmi_init)(void);
	unsigned char (*get_nmi_reason)(void);
	void (*save_sched_clock_state)(void);
	void (*restore_sched_clock_state)(void);
	void (*apic_post_init)(void);
	struct x86_legacy_features legacy;
	void (*set_legacy_features)(void);
	void (*realmode_reserve)(void);
	void (*realmode_init)(void);
	struct x86_hyper_runtime hyper;
	struct x86_guest guest;
};

struct x86_pmu_quirk;

struct x86_pmu {
	const char *name;
	int version;
	int (*handle_irq)(struct pt_regs *);
	void (*disable_all)(void);
	void (*enable_all)(int);
	void (*enable)(struct perf_event *);
	void (*disable)(struct perf_event *);
	void (*assign)(struct perf_event *, int);
	void (*add)(struct perf_event *);
	void (*del)(struct perf_event *);
	void (*read)(struct perf_event *);
	int (*set_period)(struct perf_event *);
	u64 (*update)(struct perf_event *);
	int (*hw_config)(struct perf_event *);
	int (*schedule_events)(struct cpu_hw_events *, int, int *);
	unsigned int eventsel;
	unsigned int perfctr;
	unsigned int fixedctr;
	int (*addr_offset)(int, bool);
	int (*rdpmc_index)(int);
	u64 (*event_map)(int);
	int max_events;
	u64 config_mask;
	union {
		u64 cntr_mask64;
		long unsigned int cntr_mask[1];
	};
	union {
		u64 fixed_cntr_mask64;
		long unsigned int fixed_cntr_mask[1];
	};
	int cntval_bits;
	u64 cntval_mask;
	union {
		long unsigned int events_maskl;
		long unsigned int events_mask[1];
	};
	int events_mask_len;
	int apic;
	u64 max_period;
	struct event_constraint * (*get_event_constraints)(struct cpu_hw_events *, int, struct perf_event *);
	void (*put_event_constraints)(struct cpu_hw_events *, struct perf_event *);
	void (*start_scheduling)(struct cpu_hw_events *);
	void (*commit_scheduling)(struct cpu_hw_events *, int, int);
	void (*stop_scheduling)(struct cpu_hw_events *);
	struct event_constraint *event_constraints;
	struct x86_pmu_quirk *quirks;
	void (*limit_period)(struct perf_event *, s64 *);
	unsigned int late_ack: 1;
	unsigned int mid_ack: 1;
	unsigned int enabled_ack: 1;
	int attr_rdpmc_broken;
	int attr_rdpmc;
	struct attribute **format_attrs;
	ssize_t (*events_sysfs_show)(char *, u64);
	const struct attribute_group **attr_update;
	long unsigned int attr_freeze_on_smi;
	int (*cpu_prepare)(int);
	void (*cpu_starting)(int);
	void (*cpu_dying)(int);
	void (*cpu_dead)(int);
	void (*check_microcode)(void);
	void (*sched_task)(struct perf_event_pmu_context *, struct task_struct *, bool);
	u64 intel_ctrl;
	union perf_capabilities intel_cap;
	unsigned int bts: 1;
	unsigned int bts_active: 1;
	unsigned int pebs: 1;
	unsigned int pebs_active: 1;
	unsigned int pebs_broken: 1;
	unsigned int pebs_prec_dist: 1;
	unsigned int pebs_no_tlb: 1;
	unsigned int pebs_no_isolation: 1;
	unsigned int pebs_block: 1;
	unsigned int pebs_ept: 1;
	int pebs_record_size;
	int pebs_buffer_size;
	u64 pebs_events_mask;
	void (*drain_pebs)(struct pt_regs *, struct perf_sample_data *);
	struct event_constraint *pebs_constraints;
	void (*pebs_aliases)(struct perf_event *);
	u64 (*pebs_latency_data)(struct perf_event *, u64);
	long unsigned int large_pebs_flags;
	u64 rtm_abort_event;
	u64 pebs_capable;
	unsigned int lbr_tos;
	unsigned int lbr_from;
	unsigned int lbr_to;
	unsigned int lbr_info;
	unsigned int lbr_nr;
	union {
		u64 lbr_sel_mask;
		u64 lbr_ctl_mask;
	};
	union {
		const int *lbr_sel_map;
		int *lbr_ctl_map;
	};
	u64 lbr_callstack_users;
	bool lbr_double_abort;
	bool lbr_pt_coexist;
	unsigned int lbr_has_info: 1;
	unsigned int lbr_has_tsx: 1;
	unsigned int lbr_from_flags: 1;
	unsigned int lbr_to_cycles: 1;
	unsigned int lbr_depth_mask: 8;
	unsigned int lbr_deep_c_reset: 1;
	unsigned int lbr_lip: 1;
	unsigned int lbr_cpl: 1;
	unsigned int lbr_filter: 1;
	unsigned int lbr_call_stack: 1;
	unsigned int lbr_mispred: 1;
	unsigned int lbr_timed_lbr: 1;
	unsigned int lbr_br_type: 1;
	unsigned int lbr_counters: 4;
	void (*lbr_reset)(void);
	void (*lbr_read)(struct cpu_hw_events *);
	void (*lbr_save)(void *);
	void (*lbr_restore)(void *);
	atomic_t lbr_exclusive[3];
	int num_topdown_events;
	void (*swap_task_ctx)(struct perf_event_pmu_context *, struct perf_event_pmu_context *);
	unsigned int amd_nb_constraints: 1;
	u64 perf_ctr_pair_en;
	struct extra_reg *extra_regs;
	unsigned int flags;
	struct perf_guest_switch_msr * (*guest_get_msrs)(int *, void *);
	int (*check_period)(struct perf_event *, u64);
	int (*aux_output_match)(struct perf_event *);
	void (*filter)(struct pmu *, int, bool *);
	int num_hybrid_pmus;
	struct x86_hybrid_pmu *hybrid_pmu;
	enum hybrid_cpu_type (*get_hybrid_cpu_type)(void);
};

struct x86_pmu_capability {
	int version;
	int num_counters_gp;
	int num_counters_fixed;
	int bit_width_gp;
	int bit_width_fixed;
	unsigned int events_mask;
	int events_mask_len;
	unsigned int pebs_ept: 1;
};

union x86_pmu_config {
	struct {
		u64 event: 8;
		u64 umask: 8;
		u64 usr: 1;
		u64 os: 1;
		u64 edge: 1;
		u64 pc: 1;
		u64 interrupt: 1;
		u64 __reserved1: 1;
		u64 en: 1;
		u64 inv: 1;
		u64 cmask: 8;
		u64 event2: 4;
		u64 __reserved2: 4;
		u64 go: 1;
		u64 ho: 1;
	} bits;
	u64 value;
};

struct x86_pmu_lbr {
	unsigned int nr;
	unsigned int from;
	unsigned int to;
	unsigned int info;
	bool has_callstack;
};

struct x86_pmu_quirk {
	struct x86_pmu_quirk *next;
	void (*func)(void);
};

struct x86_topology_system {
	unsigned int dom_shifts[7];
	unsigned int dom_size[7];
};

struct x86_xfeat_component {
	__u32 type;
	__u32 size;
	__u32 offset;
	__u32 flags;
};

struct xa_limit {
	u32 max;
	u32 min;
};

struct xa_node {
	unsigned char shift;
	unsigned char offset;
	unsigned char count;
	unsigned char nr_values;
	struct xa_node *parent;
	struct xarray *array;
	union {
		struct list_head private_list;
		struct callback_head callback_head;
	};
	void *slots[64];
	union {
		long unsigned int tags[3];
		long unsigned int marks[3];
	};
};

typedef void (*xa_update_node_t)(struct xa_node *);

struct xa_state {
	struct xarray *xa;
	long unsigned int xa_index;
	unsigned char xa_shift;
	unsigned char xa_sibs;
	unsigned char xa_offset;
	unsigned char xa_pad;
	struct xa_node *xa_node;
	struct xa_node *xa_alloc;
	xa_update_node_t xa_update;
	struct list_lru *xa_lru;
};

struct xbitmap32 {
	struct rb_root_cached xb_root;
};

struct xagb_bitmap {
	struct xbitmap32 agbitmap;
};

struct xattr {
	const char *name;
	void *value;
	size_t value_len;
};

struct xattr_args {
	__u64 value;
	__u32 size;
	__u32 flags;
};

struct xattr_handler {
	const char *name;
	const char *prefix;
	int flags;
	bool (*list)(struct dentry *);
	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);
	int (*set)(const struct xattr_handler *, struct mnt_idmap *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
};

struct xattr_name {
	char name[256];
};

struct xb_key {
	uint32_t xb_magic;
	uint32_t xb_size;
	loff_t xb_offset;
};

struct xbitmap32_node {
	struct rb_node bn_rbnode;
	uint32_t bn_start;
	uint32_t bn_last;
	uint32_t __bn_subtree_last;
};

struct xbitmap64 {
	struct rb_root_cached xb_root;
};

struct xbitmap64_node {
	struct rb_node bn_rbnode;
	uint64_t bn_start;
	uint64_t bn_last;
	uint64_t __bn_subtree_last;
};

struct xbtree_afakeroot {
	xfs_agblock_t af_root;
	unsigned int af_levels;
	unsigned int af_blocks;
};

struct xfs_ifork;

struct xbtree_ifakeroot {
	struct xfs_ifork *if_fork;
	int64_t if_blocks;
	unsigned int if_levels;
	unsigned int if_fork_size;
};

struct xfs_perag;

struct xfs_buf;

struct xfs_btree_cur;

struct xchk_ag {
	struct xfs_perag *pag;
	struct xfs_buf *agf_bp;
	struct xfs_buf *agi_bp;
	struct xfs_btree_cur *bno_cur;
	struct xfs_btree_cur *cnt_cur;
	struct xfs_btree_cur *ino_cur;
	struct xfs_btree_cur *fino_cur;
	struct xfs_btree_cur *rmap_cur;
	struct xfs_btree_cur *refc_cur;
};

struct xfs_scrub;

struct xchk_agfl_info {
	unsigned int agflcount;
	unsigned int nr_entries;
	xfs_agblock_t *entries;
	struct xfs_buf *agfl_bp;
	struct xfs_scrub *sc;
};

struct xfs_alloc_rec_incore {
	xfs_agblock_t ar_startblock;
	xfs_extlen_t ar_blockcount;
};

struct xchk_alloc {
	struct xfs_alloc_rec_incore prev;
};

struct xfs_iext_leaf;

struct xfs_iext_cursor {
	struct xfs_iext_leaf *leaf;
	int pos;
};

struct xchk_bmap_check_rmap_info {
	struct xfs_scrub *sc;
	int whichfork;
	struct xfs_iext_cursor icur;
};

struct xfs_bmbt_irec {
	xfs_fileoff_t br_startoff;
	xfs_fsblock_t br_startblock;
	xfs_filblks_t br_blockcount;
	xfs_exntst_t br_state;
};

struct xchk_bmap_info {
	struct xfs_scrub *sc;
	struct xfs_iext_cursor icur;
	struct xfs_bmbt_irec prev_rec;
	bool is_rt;
	bool is_shared;
	bool was_loaded;
	int whichfork;
};

struct xchk_btree;

union xfs_btree_rec;

typedef int (*xchk_btree_rec_fn)(struct xchk_btree *, const union xfs_btree_rec *);

struct xfs_bmbt_rec {
	__be64 l0;
	__be64 l1;
};

typedef struct xfs_bmbt_rec xfs_bmbt_rec_t;

typedef xfs_bmbt_rec_t xfs_bmdr_rec_t;

struct xfs_alloc_rec {
	__be32 ar_startblock;
	__be32 ar_blockcount;
};

struct xfs_inobt_rec {
	__be32 ir_startino;
	union {
		struct {
			__be32 ir_freecount;
		} f;
		struct {
			__be16 ir_holemask;
			__u8 ir_count;
			__u8 ir_freecount;
		} sp;
	} ir_u;
	__be64 ir_free;
};

struct xfs_rmap_rec {
	__be32 rm_startblock;
	__be32 rm_blockcount;
	__be64 rm_owner;
	__be64 rm_offset;
};

struct xfs_refcount_rec {
	__be32 rc_startblock;
	__be32 rc_blockcount;
	__be32 rc_refcount;
};

union xfs_btree_rec {
	struct xfs_bmbt_rec bmbt;
	xfs_bmdr_rec_t bmbr;
	struct xfs_alloc_rec alloc;
	struct xfs_inobt_rec inobt;
	struct xfs_rmap_rec rmap;
	struct xfs_refcount_rec refc;
};

struct xfs_bmbt_key {
	__be64 br_startoff;
};

typedef struct xfs_bmbt_key xfs_bmdr_key_t;

typedef struct xfs_alloc_rec xfs_alloc_key_t;

struct xfs_inobt_key {
	__be32 ir_startino;
};

struct xfs_rmap_key {
	__be32 rm_startblock;
	__be64 rm_owner;
	__be64 rm_offset;
} __attribute__((packed));

struct xfs_refcount_key {
	__be32 rc_startblock;
};

union xfs_btree_key {
	struct xfs_bmbt_key bmbt;
	xfs_bmdr_key_t bmbr;
	xfs_alloc_key_t alloc;
	struct xfs_inobt_key inobt;
	struct xfs_rmap_key rmap;
	struct xfs_rmap_key __rmap_bigkey[2];
	struct xfs_refcount_key refc;
};

struct xchk_btree_key {
	union xfs_btree_key key;
	bool valid;
};

struct xfs_owner_info;

struct xchk_btree {
	struct xfs_scrub *sc;
	struct xfs_btree_cur *cur;
	xchk_btree_rec_fn scrub_rec;
	const struct xfs_owner_info *oinfo;
	void *private;
	bool lastrec_valid;
	union xfs_btree_rec lastrec;
	struct list_head to_check;
	struct xchk_btree_key lastkey[0];
};

struct xfs_da_geometry;

struct xfs_inode;

struct xfs_da_args {
	struct xfs_da_geometry *geo;
	const uint8_t *name;
	const uint8_t *new_name;
	void *value;
	void *new_value;
	struct xfs_inode *dp;
	struct xfs_trans *trans;
	xfs_ino_t inumber;
	xfs_ino_t owner;
	int valuelen;
	int new_valuelen;
	uint8_t filetype;
	uint8_t op_flags;
	uint8_t attr_filter;
	short int namelen;
	short int new_namelen;
	xfs_dahash_t hashval;
	xfs_extlen_t total;
	int whichfork;
	xfs_dablk_t blkno;
	int index;
	xfs_dablk_t rmtblkno;
	int rmtblkcnt;
	int rmtvaluelen;
	xfs_dablk_t blkno2;
	int index2;
	xfs_dablk_t rmtblkno2;
	int rmtblkcnt2;
	int rmtvaluelen2;
	enum xfs_dacmp cmpresult;
};

struct xfs_da_state;

struct xchk_da_btree {
	struct xfs_da_args dargs;
	xfs_dahash_t hashes[5];
	int maxrecs[5];
	struct xfs_da_state *state;
	struct xfs_scrub *sc;
	void *private;
	xfs_dablk_t lowest;
	xfs_dablk_t highest;
	int tree_level;
};

struct xfs_parent_rec {
	__be64 p_ino;
	__be32 p_gen;
} __attribute__((packed));

struct xfs_name {
	const unsigned char *name;
	int len;
	int type;
};

struct xfarray;

struct xfblob;

struct xchk_dir {
	struct xfs_scrub *sc;
	struct xfs_parent_rec pptr_rec;
	struct xfs_da_args pptr_args;
	struct xfarray *dir_entries;
	struct xfblob *dir_names;
	bool need_revalidate;
	struct xfs_name xname;
	uint8_t namebuf[256];
};

struct xchk_dirent {
	xfblob_cookie name_cookie;
	xfs_ino_t ino;
	uint8_t namelen;
};

struct xino_bitmap {
	struct xbitmap64 inobitmap;
};

struct xchk_dirpath {
	struct list_head list;
	xfarray_idx_t first_step;
	xfarray_idx_t second_step;
	struct xino_bitmap seen_inodes;
	unsigned int nr_steps;
	unsigned int path_nr;
	enum xchk_dirpath_outcome outcome;
};

struct xchk_dirpath_step {
	xfblob_cookie name_cookie;
	unsigned int name_len;
	struct xfs_parent_rec pptr_rec;
};

struct xrep_adoption {};

struct xfs_hook {
	struct notifier_block nb;
};

struct xfs_dir_hook {
	struct xfs_hook dirent_hook;
};

struct xfs_parent_args {
	struct xfs_parent_rec rec;
	struct xfs_parent_rec new_rec;
	struct xfs_da_args args;
};

struct xchk_dirtree {
	struct xfs_scrub *sc;
	xfs_ino_t root_ino;
	xfs_ino_t scan_ino;
	xfs_ino_t parent_ino;
	struct xfs_parent_rec pptr_rec;
	struct xfs_da_args pptr_args;
	struct xfs_name xname;
	char namebuf[256];
	struct xrep_adoption adoption;
	struct xfs_dir_hook dhook;
	struct xfs_parent_args ppargs;
	struct mutex lock;
	struct xfs_name hook_xname;
	unsigned char hook_namebuf[256];
	struct xfarray *path_steps;
	struct xfblob *path_names;
	struct list_head path_list;
	unsigned int nr_paths;
	unsigned int parents_found;
	bool stale: 1;
	bool aborted: 1;
};

struct xchk_dirtree_outcomes {
	unsigned int bad;
	unsigned int suspect;
	unsigned int good;
	bool needs_adoption;
};

struct xchk_dqiter {
	struct xfs_scrub *sc;
	struct xfs_inode *quota_ip;
	struct xfs_bmbt_irec bmap;
	uint64_t id;
	xfs_dqtype_t dqtype;
	unsigned int if_seq;
};

struct xchk_fscounters {
	struct xfs_scrub *sc;
	uint64_t icount;
	uint64_t ifree;
	uint64_t fdblocks;
	uint64_t frextents;
	uint64_t frextents_delayed;
	long long unsigned int icount_min;
	long long unsigned int icount_max;
	bool frozen;
};

struct xchk_health_map {
	enum xchk_health_group group;
	unsigned int sick_mask;
};

struct xchk_iallocbt {
	long long unsigned int inodes;
	xfs_agino_t next_startino;
	xfs_agino_t next_cluster_ino;
};

struct xchk_iscan {
	struct xfs_scrub *sc;
	struct mutex lock;
	xfs_ino_t scan_start_ino;
	xfs_ino_t cursor_ino;
	xfs_ino_t skip_ino;
	xfs_ino_t __visited_ino;
	long unsigned int __opstate;
	long unsigned int __iget_deadline;
	unsigned int iget_timeout;
	unsigned int iget_retry_delay;
	xfs_ino_t __batch_ino;
	xfs_inofree_t __skipped_inomask;
	struct xfs_inode *__inodes[64];
};

struct xfs_mount;

struct xchk_meta_ops {
	int (*setup)(struct xfs_scrub *);
	int (*scrub)(struct xfs_scrub *);
	int (*repair)(struct xfs_scrub *);
	int (*repair_eval)(struct xfs_scrub *);
	bool (*has)(const struct xfs_mount *);
	enum xchk_type type;
};

struct xfs_dir_update {
	struct xfs_inode *dp;
	const struct xfs_name *name;
	struct xfs_inode *ip;
	struct xfs_parent_args *ppargs;
};

struct xchk_metapath {
	struct xfs_scrub *sc;
	struct xfs_name xname;
	struct xfs_dir_update du;
	const char *path;
	struct xfs_inode *dp;
	unsigned int dp_ilock_flags;
	unsigned int link_resblks;
	unsigned int unlink_resblks;
	struct xfs_parent_args link_ppargs;
	struct xfs_parent_args unlink_ppargs;
	struct xfs_da_args pptr_args;
};

struct xchk_nlink {
	xfs_nlink_t parents;
	xfs_nlink_t backrefs;
	xfs_nlink_t children;
	unsigned int flags;
};

struct xchk_nlink_ctrs {
	struct xfs_scrub *sc;
	struct xfarray *nlinks;
	struct mutex lock;
	struct xchk_iscan collect_iscan;
	struct xchk_iscan compare_iscan;
	struct xfs_dir_hook dhook;
	struct xrep_adoption adoption;
	struct xfs_name xname;
	char namebuf[256];
};

struct xchk_parent_ctx {
	struct xfs_scrub *sc;
	xfs_nlink_t nlink;
};

struct xchk_pptr {
	xfblob_cookie name_cookie;
	struct xfs_parent_rec pptr_rec;
	uint8_t namelen;
};

struct xchk_pptrs {
	struct xfs_scrub *sc;
	long long unsigned int pptrs_found;
	xfs_ino_t parent_ino;
	struct xfarray *pptr_entries;
	struct xfblob *pptr_names;
	struct xfs_da_args pptr_args;
	bool need_revalidate;
	struct xfs_name xname;
	char namebuf[256];
};

struct xchk_quota_info {
	struct xfs_scrub *sc;
	xfs_dqid_t last_id;
};

struct xfs_refcount_irec {
	xfs_agblock_t rc_startblock;
	xfs_extlen_t rc_blockcount;
	xfs_nlink_t rc_refcount;
	enum xfs_refc_domain rc_domain;
};

struct xchk_refcbt_records {
	struct xfs_refcount_irec prev_rec;
	xfs_agblock_t next_unshared_agbno;
	xfs_agblock_t cow_blocks;
	enum xfs_refc_domain prev_domain;
};

struct xchk_refcnt_check {
	struct xfs_scrub *sc;
	struct list_head fragments;
	xfs_agblock_t bno;
	xfs_extlen_t len;
	xfs_nlink_t refcount;
	xfs_nlink_t seen;
};

struct xfs_rmap_irec {
	xfs_agblock_t rm_startblock;
	xfs_extlen_t rm_blockcount;
	uint64_t rm_owner;
	uint64_t rm_offset;
	unsigned int rm_flags;
};

struct xchk_refcnt_frag {
	struct list_head list;
	struct xfs_rmap_irec rm;
};

struct xchk_relax {
	long unsigned int next_resched;
	unsigned int resched_nr;
	bool interruptible;
};

struct xchk_rmap {
	struct xfs_rmap_irec overlap_rec;
	struct xfs_rmap_irec prev_rec;
	struct xagb_bitmap fs_owned;
	struct xagb_bitmap log_owned;
	struct xagb_bitmap ag_owned;
	struct xagb_bitmap inobt_owned;
	struct xagb_bitmap refcbt_owned;
	bool bitmaps_complete;
};

struct xchk_rmap_ownedby_info {
	const struct xfs_owner_info *oinfo;
	xfs_filblks_t *blocks;
};

struct xfs_rtgroup;

struct xchk_rt {
	struct xfs_rtgroup *rtg;
	unsigned int rtlock_flags;
	struct xfs_btree_cur *rmap_cur;
	struct xfs_btree_cur *refc_cur;
};

struct xchk_stats_run {
	u64 scrub_ns;
	u64 repair_ns;
	unsigned int retries;
	bool repair_attempted;
	bool repair_succeeded;
};

struct xchk_xattr_buf {
	long unsigned int *usedmap;
	long unsigned int *freemap;
	unsigned char *name;
	void *value;
	size_t value_sz;
};

struct xdab_bitmap {
	struct xbitmap32 dabitmap;
};

struct xdp_attachment_info {
	struct bpf_prog *prog;
	u32 flags;
};

struct xdp_buff_xsk {
	struct xdp_buff xdp;
	u8 cb[24];
	dma_addr_t dma;
	dma_addr_t frame_dma;
	struct xsk_buff_pool *pool;
	struct list_head list_node;
	long: 64;
};

struct xdp_bulk_queue {
	void *q[8];
	struct list_head flush_node;
	struct bpf_cpu_map_entry *obj;
	unsigned int count;
};

struct xdp_cpumap_stats {
	unsigned int redirect;
	unsigned int pass;
	unsigned int drop;
};

struct xdp_desc {
	__u64 addr;
	__u32 len;
	__u32 options;
};

struct xdp_dev_bulk_queue {
	struct xdp_frame *q[16];
	struct list_head flush_node;
	struct net_device *dev;
	struct net_device *dev_rx;
	struct bpf_prog *xdp_prog;
	unsigned int count;
};

struct xdp_frame {
	void *data;
	u32 len;
	u32 headroom;
	u32 metasize;
	enum xdp_mem_type mem_type: 32;
	struct net_device *dev_rx;
	u32 frame_sz;
	u32 flags;
};

struct xdp_frame_bulk {
	int count;
	netmem_ref q[16];
};

struct xdp_mem_allocator {
	struct xdp_mem_info mem;
	union {
		void *allocator;
		struct page_pool *page_pool;
	};
	struct rhash_head node;
	struct callback_head rcu;
};

struct xdp_metadata_ops {
	int (*xmo_rx_timestamp)(const struct xdp_md *, u64 *);
	int (*xmo_rx_hash)(const struct xdp_md *, u32 *, enum xdp_rss_hash_type *);
	int (*xmo_rx_vlan_tag)(const struct xdp_md *, __be16 *, u16 *);
};

struct xdp_page_head {
	struct xdp_buff orig_ctx;
	struct xdp_buff ctx;
	union {
		struct {
			struct {} __empty_frame;
			struct xdp_frame frame[0];
		};
		struct {
			struct {} __empty_data;
			u8 data[0];
		};
	};
};

struct xsk_queue;

struct xdp_umem;

struct xdp_sock {
	struct sock sk;
	struct xsk_queue *rx;
	struct net_device *dev;
	struct xdp_umem *umem;
	struct list_head flush_node;
	struct xsk_buff_pool *pool;
	u16 queue_id;
	bool zc;
	bool sg;
	enum {
		XSK_READY = 0,
		XSK_BOUND = 1,
		XSK_UNBOUND = 2,
	} state;
	long: 64;
	struct xsk_queue *tx;
	struct list_head tx_list;
	u32 tx_budget_spent;
	spinlock_t rx_lock;
	u64 rx_dropped;
	u64 rx_queue_full;
	struct sk_buff *skb;
	struct list_head map_list;
	spinlock_t map_list_lock;
	struct mutex mutex;
	struct xsk_queue *fq_tmp;
	struct xsk_queue *cq_tmp;
};

struct xdp_test_data {
	struct xdp_buff *orig_ctx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info rxq;
	struct net_device *dev;
	struct page_pool *pp;
	struct xdp_frame **frames;
	struct sk_buff **skbs;
	struct xdp_mem_info mem;
	u32 batch_size;
	u32 frame_cnt;
	long: 64;
	long: 64;
};

struct xdp_txq_info {
	struct net_device *dev;
};

struct xdp_umem {
	void *addrs;
	u64 size;
	u32 headroom;
	u32 chunk_size;
	u32 chunks;
	u32 npgs;
	struct user_struct *user;
	refcount_t users;
	u8 flags;
	u8 tx_metadata_len;
	bool zc;
	struct page **pgs;
	int id;
	struct list_head xsk_dma_list;
	struct work_struct work;
};

struct xdr_skb_reader {
	struct sk_buff *skb;
	unsigned int offset;
	size_t count;
	__wsum csum;
};

struct xfile;

struct xfarray {
	struct xfile *xfile;
	xfarray_idx_t nr;
	xfarray_idx_t max_nr;
	uint64_t unset_slots;
	size_t obj_size;
	int obj_size_log;
};

typedef cmp_func_t xfarray_cmp_fn;

struct xfarray_sortinfo {
	struct xfarray *array;
	xfarray_cmp_fn cmp_fn;
	uint8_t max_stack_depth;
	int8_t stack_depth;
	uint8_t max_stack_used;
	unsigned int flags;
	struct xchk_relax relax;
	struct folio *folio;
	xfarray_idx_t first_folio_idx;
	xfarray_idx_t last_folio_idx;
};

struct xfblob {
	struct xfile *xfile;
	loff_t last_offset;
};

union xfs_btree_ptr {
	__be32 s;
	__be64 l;
};

struct xfs_buftarg;

struct xfbtree {
	struct xfs_buftarg *target;
	xfbno_t highest_bno;
	long long unsigned int owner;
	union xfs_btree_ptr root;
	unsigned int nlevels;
	unsigned int maxrecs[2];
	unsigned int minrecs[2];
};

struct xfile {
	struct file *file;
};

struct xfrm4_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm4_protocol *next;
	int priority;
};

struct xfrm6_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	struct xfrm6_protocol *next;
	int priority;
};

struct xfrm6_tunnel {
	int (*handler)(struct sk_buff *);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	struct xfrm6_tunnel *next;
	int priority;
};

struct xfrm6_tunnel_net {
	struct hlist_head spi_byaddr[256];
	struct hlist_head spi_byspi[256];
	u32 spi;
};

struct xfrm6_tunnel_spi {
	struct hlist_node list_byaddr;
	struct hlist_node list_byspi;
	xfrm_address_t addr;
	u32 spi;
	refcount_t refcnt;
	struct callback_head callback_head;
};

struct xfrm_address_filter {
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__u16 family;
	__u8 splen;
	__u8 dplen;
};

struct xfrm_aead_name {
	const char *name;
	int icvbits;
};

struct xfrm_usersa_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u16 family;
	__u8 proto;
};

struct xfrm_aevent_id {
	struct xfrm_usersa_id sa_id;
	xfrm_address_t saddr;
	__u32 flags;
	__u32 reqid;
};

struct xfrm_algo {
	char alg_name[64];
	unsigned int alg_key_len;
	char alg_key[0];
};

struct xfrm_algo_aead {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_icv_len;
	char alg_key[0];
};

struct xfrm_algo_aead_info {
	char *geniv;
	u16 icv_truncbits;
};

struct xfrm_algo_auth {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_trunc_len;
	char alg_key[0];
};

struct xfrm_algo_auth_info {
	u16 icv_truncbits;
	u16 icv_fullbits;
};

struct xfrm_algo_comp_info {
	u16 threshold;
};

struct xfrm_algo_encr_info {
	char *geniv;
	u16 blockbits;
	u16 defkeybits;
};

struct xfrm_algo_desc {
	char *name;
	char *compat;
	u8 available: 1;
	u8 pfkey_supported: 1;
	union {
		struct xfrm_algo_aead_info aead;
		struct xfrm_algo_auth_info auth;
		struct xfrm_algo_encr_info encr;
		struct xfrm_algo_comp_info comp;
	} uinfo;
	struct sadb_alg desc;
};

struct xfrm_algo_list {
	int (*find)(const char *, u32, u32);
	struct xfrm_algo_desc *algs;
	int entries;
};

struct xfrm_dev_offload {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct net_device *real_dev;
	long unsigned int offload_handle;
	u8 dir: 2;
	u8 type: 2;
	u8 flags: 2;
};

struct xfrm_dst {
	union {
		struct dst_entry dst;
		struct rtable rt;
		struct rt6_info rt6;
	} u;
	struct dst_entry *route;
	struct dst_entry *child;
	struct dst_entry *path;
	struct xfrm_policy *pols[2];
	int num_pols;
	int num_xfrms;
	u32 xfrm_genid;
	u32 policy_genid;
	u32 route_mtu_cached;
	u32 child_mtu_cached;
	u32 route_cookie;
	u32 path_cookie;
};

struct xfrm_dst_lookup_params {
	struct net *net;
	dscp_t dscp;
	int oif;
	xfrm_address_t *saddr;
	xfrm_address_t *daddr;
	u32 mark;
	__u8 ipproto;
	union flowi_uli uli;
};

struct xfrm_dump_info {
	struct sk_buff *in_skb;
	struct sk_buff *out_skb;
	u32 nlmsg_seq;
	u16 nlmsg_flags;
};

struct xfrm_encap_tmpl {
	__u16 encap_type;
	__be16 encap_sport;
	__be16 encap_dport;
	xfrm_address_t encap_oa;
};

struct xfrm_flo {
	struct dst_entry *dst_orig;
	u8 flags;
};

struct xfrm_flow_keys {
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_control control;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	} addrs;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_keyid gre;
};

struct xfrm_hash_state_ptrs {
	const struct hlist_head *bydst;
	const struct hlist_head *bysrc;
	const struct hlist_head *byspi;
	unsigned int hmask;
};

struct xfrm_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u8 proto;
};

struct xfrm_if_parms {
	int link;
	u32 if_id;
	bool collect_md;
};

struct xfrm_if {
	struct xfrm_if *next;
	struct net_device *dev;
	struct net *net;
	struct xfrm_if_parms p;
	struct gro_cells gro_cells;
};

struct xfrm_if_decode_session_result;

struct xfrm_if_cb {
	bool (*decode_session)(struct sk_buff *, short unsigned int, struct xfrm_if_decode_session_result *);
};

struct xfrm_if_decode_session_result {
	struct net *net;
	u32 if_id;
};

struct xfrm_input_afinfo {
	u8 family;
	bool is_ipip;
	int (*callback)(struct sk_buff *, u8, int);
};

struct xfrm_kmaddress {
	xfrm_address_t local;
	xfrm_address_t remote;
	u32 reserved;
	u16 family;
};

struct xfrm_lifetime_cfg {
	__u64 soft_byte_limit;
	__u64 hard_byte_limit;
	__u64 soft_packet_limit;
	__u64 hard_packet_limit;
	__u64 soft_add_expires_seconds;
	__u64 hard_add_expires_seconds;
	__u64 soft_use_expires_seconds;
	__u64 hard_use_expires_seconds;
};

struct xfrm_lifetime_cur {
	__u64 bytes;
	__u64 packets;
	__u64 add_time;
	__u64 use_time;
};

struct xfrm_link {
	int (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **, struct netlink_ext_ack *);
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *nla_pol;
	int nla_max;
};

struct xfrm_mark {
	__u32 v;
	__u32 m;
};

struct xfrm_tmpl;

struct xfrm_selector;

struct xfrm_migrate;

struct xfrm_mgr {
	struct list_head list;
	int (*notify)(struct xfrm_state *, const struct km_event *);
	int (*acquire)(struct xfrm_state *, struct xfrm_tmpl *, struct xfrm_policy *);
	struct xfrm_policy * (*compile_policy)(struct sock *, int, u8 *, int, int *);
	int (*new_mapping)(struct xfrm_state *, xfrm_address_t *, __be16);
	int (*notify_policy)(struct xfrm_policy *, int, const struct km_event *);
	int (*report)(struct net *, u8, struct xfrm_selector *, xfrm_address_t *);
	int (*migrate)(const struct xfrm_selector *, u8, u8, const struct xfrm_migrate *, int, const struct xfrm_kmaddress *, const struct xfrm_encap_tmpl *);
	bool (*is_alive)(const struct km_event *);
};

struct xfrm_migrate {
	xfrm_address_t old_daddr;
	xfrm_address_t old_saddr;
	xfrm_address_t new_daddr;
	xfrm_address_t new_saddr;
	u8 proto;
	u8 mode;
	u16 reserved;
	u32 reqid;
	u16 old_family;
	u16 new_family;
};

struct xfrm_mode {
	u8 encap;
	u8 family;
	u8 flags;
};

struct xfrm_mode_cbs {
	struct module *owner;
	int (*init_state)(struct xfrm_state *);
	int (*clone_state)(struct xfrm_state *, struct xfrm_state *);
	void (*destroy_state)(struct xfrm_state *);
	int (*user_init)(struct net *, struct xfrm_state *, struct nlattr **, struct netlink_ext_ack *);
	int (*copy_to_user)(struct xfrm_state *, struct sk_buff *);
	unsigned int (*sa_len)(const struct xfrm_state *);
	u32 (*get_inner_mtu)(struct xfrm_state *, int);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*prepare_output)(struct xfrm_state *, struct sk_buff *);
};

struct xfrm_mode_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	__be16 id;
	__be16 frag_off;
	u8 ihl;
	u8 tos;
	u8 ttl;
	u8 protocol;
	u8 optlen;
	u8 flow_lbl[3];
};

struct xfrm_pol_inexact_key {
	possible_net_t net;
	u32 if_id;
	u16 family;
	u8 dir;
	u8 type;
};

struct xfrm_pol_inexact_bin {
	struct xfrm_pol_inexact_key k;
	struct rhash_head head;
	struct hlist_head hhead;
	seqcount_spinlock_t count;
	struct rb_root root_d;
	struct rb_root root_s;
	struct list_head inexact_bins;
	struct callback_head rcu;
};

struct xfrm_pol_inexact_candidates {
	struct hlist_head *res[4];
};

struct xfrm_pol_inexact_node {
	struct rb_node node;
	union {
		xfrm_address_t addr;
		struct callback_head rcu;
	};
	u8 prefixlen;
	struct rb_root root;
	struct hlist_head hhead;
};

struct xfrm_selector {
	xfrm_address_t daddr;
	xfrm_address_t saddr;
	__be16 dport;
	__be16 dport_mask;
	__be16 sport;
	__be16 sport_mask;
	__u16 family;
	__u8 prefixlen_d;
	__u8 prefixlen_s;
	__u8 proto;
	int ifindex;
	__kernel_uid32_t user;
};

struct xfrm_policy_queue {
	struct sk_buff_head hold_queue;
	struct timer_list hold_timer;
	long unsigned int timeout;
};

struct xfrm_tmpl {
	struct xfrm_id id;
	xfrm_address_t saddr;
	short unsigned int encap_family;
	u32 reqid;
	u8 mode;
	u8 share;
	u8 optional;
	u8 allalgs;
	u32 aalgos;
	u32 ealgos;
	u32 calgos;
};

struct xfrm_sec_ctx;

struct xfrm_policy {
	possible_net_t xp_net;
	struct hlist_node bydst;
	struct hlist_node byidx;
	struct hlist_head state_cache_list;
	rwlock_t lock;
	refcount_t refcnt;
	u32 pos;
	struct timer_list timer;
	atomic_t genid;
	u32 priority;
	u32 index;
	u32 if_id;
	struct xfrm_mark mark;
	struct xfrm_selector selector;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	struct xfrm_policy_walk_entry walk;
	struct xfrm_policy_queue polq;
	bool bydst_reinsert;
	u8 type;
	u8 action;
	u8 flags;
	u8 xfrm_nr;
	u16 family;
	struct xfrm_sec_ctx *security;
	struct xfrm_tmpl xfrm_vec[6];
	struct callback_head rcu;
	struct xfrm_dev_offload xdo;
};

struct xfrm_policy_afinfo {
	struct dst_ops *dst_ops;
	struct dst_entry * (*dst_lookup)(const struct xfrm_dst_lookup_params *);
	int (*get_saddr)(xfrm_address_t *, const struct xfrm_dst_lookup_params *);
	int (*fill_dst)(struct xfrm_dst *, struct net_device *, const struct flowi *);
	struct dst_entry * (*blackhole_route)(struct net *, struct dst_entry *);
};

struct xfrm_replay_state {
	__u32 oseq;
	__u32 seq;
	__u32 bitmap;
};

struct xfrm_replay_state_esn {
	unsigned int bmp_len;
	__u32 oseq;
	__u32 seq;
	__u32 oseq_hi;
	__u32 seq_hi;
	__u32 replay_window;
	__u32 bmp[0];
};

struct xfrm_sec_ctx {
	__u8 ctx_doi;
	__u8 ctx_alg;
	__u16 ctx_len;
	__u32 ctx_sid;
	char ctx_str[0];
};

struct xfrm_spi_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	unsigned int daddroff;
	unsigned int family;
	__be32 seq;
};

struct xfrm_stats {
	__u32 replay_window;
	__u32 replay;
	__u32 integrity_failed;
};

struct xfrm_type;

struct xfrm_type_offload;

struct xfrm_state {
	possible_net_t xs_net;
	union {
		struct hlist_node gclist;
		struct hlist_node bydst;
	};
	union {
		struct hlist_node dev_gclist;
		struct hlist_node bysrc;
	};
	struct hlist_node byspi;
	struct hlist_node byseq;
	struct hlist_node state_cache;
	struct hlist_node state_cache_input;
	refcount_t refcnt;
	spinlock_t lock;
	u32 pcpu_num;
	struct xfrm_id id;
	struct xfrm_selector sel;
	struct xfrm_mark mark;
	u32 if_id;
	u32 tfcpad;
	u32 genid;
	struct xfrm_state_walk km;
	struct {
		u32 reqid;
		u8 mode;
		u8 replay_window;
		u8 aalgo;
		u8 ealgo;
		u8 calgo;
		u8 flags;
		u16 family;
		xfrm_address_t saddr;
		int header_len;
		int enc_hdr_len;
		int trailer_len;
		u32 extra_flags;
		struct xfrm_mark smark;
	} props;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_algo_auth *aalg;
	struct xfrm_algo *ealg;
	struct xfrm_algo *calg;
	struct xfrm_algo_aead *aead;
	const char *geniv;
	__be16 new_mapping_sport;
	u32 new_mapping;
	u32 mapping_maxage;
	struct xfrm_encap_tmpl *encap;
	struct sock *encap_sk;
	u32 nat_keepalive_interval;
	time64_t nat_keepalive_expiration;
	xfrm_address_t *coaddr;
	struct xfrm_state *tunnel;
	atomic_t tunnel_users;
	struct xfrm_replay_state replay;
	struct xfrm_replay_state_esn *replay_esn;
	struct xfrm_replay_state preplay;
	struct xfrm_replay_state_esn *preplay_esn;
	enum xfrm_replay_mode repl_mode;
	u32 xflags;
	u32 replay_maxage;
	u32 replay_maxdiff;
	struct timer_list rtimer;
	struct xfrm_stats stats;
	struct xfrm_lifetime_cur curlft;
	struct hrtimer mtimer;
	struct xfrm_dev_offload xso;
	long int saved_tmo;
	time64_t lastused;
	struct page_frag xfrag;
	const struct xfrm_type *type;
	struct xfrm_mode inner_mode;
	struct xfrm_mode inner_mode_iaf;
	struct xfrm_mode outer_mode;
	const struct xfrm_type_offload *type_offload;
	struct xfrm_sec_ctx *security;
	void *data;
	u8 dir;
	const struct xfrm_mode_cbs *mode_cbs;
	void *mode_data;
};

struct xfrm_state_afinfo {
	u8 family;
	u8 proto;
	const struct xfrm_type_offload *type_offload_esp;
	const struct xfrm_type *type_esp;
	const struct xfrm_type *type_ipip;
	const struct xfrm_type *type_ipip6;
	const struct xfrm_type *type_comp;
	const struct xfrm_type *type_ah;
	const struct xfrm_type *type_routing;
	const struct xfrm_type *type_dstopts;
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*transport_finish)(struct sk_buff *, int);
	void (*local_error)(struct sk_buff *, u32);
};

struct xfrm_trans_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	int (*finish)(struct net *, struct sock *, struct sk_buff *);
	struct net *net;
};

struct xfrm_trans_tasklet {
	struct work_struct work;
	spinlock_t queue_lock;
	struct sk_buff_head queue;
};

struct xfrm_translator {
	int (*alloc_compat)(struct sk_buff *, const struct nlmsghdr *);
	struct nlmsghdr * (*rcv_msg_compat)(const struct nlmsghdr *, int, const struct nla_policy *, struct netlink_ext_ack *);
	int (*xlate_user_policy_sockptr)(u8 **, int);
	struct module *owner;
};

struct xfrm_tunnel {
	int (*handler)(struct sk_buff *);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm_tunnel *next;
	int priority;
};

struct xfrm_type {
	struct module *owner;
	u8 proto;
	u8 flags;
	int (*init_state)(struct xfrm_state *, struct netlink_ext_ack *);
	void (*destructor)(struct xfrm_state *);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct xfrm_state *, struct sk_buff *);
	int (*reject)(struct xfrm_state *, struct sk_buff *, const struct flowi *);
};

struct xfrm_type_offload {
	struct module *owner;
	u8 proto;
	void (*encap)(struct xfrm_state *, struct sk_buff *);
	int (*input_tail)(struct xfrm_state *, struct sk_buff *);
	int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t);
};

struct xfrm_userpolicy_info {
	struct xfrm_selector sel;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	__u32 priority;
	__u32 index;
	__u8 dir;
	__u8 action;
	__u8 flags;
	__u8 share;
};

struct xfrm_user_acquire {
	struct xfrm_id id;
	xfrm_address_t saddr;
	struct xfrm_selector sel;
	struct xfrm_userpolicy_info policy;
	__u32 aalgos;
	__u32 ealgos;
	__u32 calgos;
	__u32 seq;
};

struct xfrm_usersa_info {
	struct xfrm_selector sel;
	struct xfrm_id id;
	xfrm_address_t saddr;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	struct xfrm_stats stats;
	__u32 seq;
	__u32 reqid;
	__u16 family;
	__u8 mode;
	__u8 replay_window;
	__u8 flags;
};

struct xfrm_user_expire {
	struct xfrm_usersa_info state;
	__u8 hard;
};

struct xfrm_user_kmaddress {
	xfrm_address_t local;
	xfrm_address_t remote;
	__u32 reserved;
	__u16 family;
};

struct xfrm_user_mapping {
	struct xfrm_usersa_id id;
	__u32 reqid;
	xfrm_address_t old_saddr;
	xfrm_address_t new_saddr;
	__be16 old_sport;
	__be16 new_sport;
};

struct xfrm_user_migrate {
	xfrm_address_t old_daddr;
	xfrm_address_t old_saddr;
	xfrm_address_t new_daddr;
	xfrm_address_t new_saddr;
	__u8 proto;
	__u8 mode;
	__u16 reserved;
	__u32 reqid;
	__u16 old_family;
	__u16 new_family;
};

struct xfrm_user_offload {
	int ifindex;
	__u8 flags;
};

struct xfrm_user_polexpire {
	struct xfrm_userpolicy_info pol;
	__u8 hard;
};

struct xfrm_user_report {
	__u8 proto;
	struct xfrm_selector sel;
};

struct xfrm_user_sec_ctx {
	__u16 len;
	__u16 exttype;
	__u8 ctx_alg;
	__u8 ctx_doi;
	__u16 ctx_len;
};

struct xfrm_user_tmpl {
	struct xfrm_id id;
	__u16 family;
	xfrm_address_t saddr;
	__u32 reqid;
	__u8 mode;
	__u8 share;
	__u8 optional;
	__u32 aalgos;
	__u32 ealgos;
	__u32 calgos;
};

struct xfrm_userpolicy_default {
	__u8 in;
	__u8 fwd;
	__u8 out;
};

struct xfrm_userpolicy_id {
	struct xfrm_selector sel;
	__u32 index;
	__u8 dir;
};

struct xfrm_userpolicy_type {
	__u8 type;
	__u16 reserved1;
	__u8 reserved2;
};

struct xfrm_usersa_flush {
	__u8 proto;
};

struct xfrm_userspi_info {
	struct xfrm_usersa_info info;
	__u32 min;
	__u32 max;
};

struct xfrmdev_ops {
	int (*xdo_dev_state_add)(struct xfrm_state *, struct netlink_ext_ack *);
	void (*xdo_dev_state_delete)(struct xfrm_state *);
	void (*xdo_dev_state_free)(struct xfrm_state *);
	bool (*xdo_dev_offload_ok)(struct sk_buff *, struct xfrm_state *);
	void (*xdo_dev_state_advance_esn)(struct xfrm_state *);
	void (*xdo_dev_state_update_stats)(struct xfrm_state *);
	int (*xdo_dev_policy_add)(struct xfrm_policy *, struct netlink_ext_ack *);
	void (*xdo_dev_policy_delete)(struct xfrm_policy *);
	void (*xdo_dev_policy_free)(struct xfrm_policy *);
};

struct xfrmi_net {
	struct xfrm_if *xfrmi[256];
	struct xfrm_if *collect_md_xfrmi;
};

struct xfrmk_sadinfo {
	u32 sadhcnt;
	u32 sadhmcnt;
	u32 sadcnt;
};

struct xfrmk_spdinfo {
	u32 incnt;
	u32 outcnt;
	u32 fwdcnt;
	u32 inscnt;
	u32 outscnt;
	u32 fwdscnt;
	u32 spdhcnt;
	u32 spdhmcnt;
};

struct xfrmu_sadhinfo {
	__u32 sadhcnt;
	__u32 sadhmcnt;
};

struct xfrmu_spdhinfo {
	__u32 spdhcnt;
	__u32 spdhmcnt;
};

struct xfrmu_spdhthresh {
	__u8 lbits;
	__u8 rbits;
};

struct xfrmu_spdinfo {
	__u32 incnt;
	__u32 outcnt;
	__u32 fwdcnt;
	__u32 inscnt;
	__u32 outscnt;
	__u32 fwdscnt;
};

struct xfs_acl_entry {
	__be32 ae_tag;
	__be32 ae_id;
	__be16 ae_perm;
	__be16 ae_pad;
};

struct xfs_acl {
	__be32 acl_cnt;
	struct xfs_acl_entry acl_entry[0];
};

struct xfs_ag_geometry {
	uint32_t ag_number;
	uint32_t ag_length;
	uint32_t ag_freeblks;
	uint32_t ag_icount;
	uint32_t ag_ifree;
	uint32_t ag_sick;
	uint32_t ag_checked;
	uint32_t ag_flags;
	uint64_t ag_reserved[12];
};

struct xfs_ag_resv {
	xfs_extlen_t ar_orig_reserved;
	xfs_extlen_t ar_reserved;
	xfs_extlen_t ar_asked;
};

struct xfs_agf {
	__be32 agf_magicnum;
	__be32 agf_versionnum;
	__be32 agf_seqno;
	__be32 agf_length;
	__be32 agf_bno_root;
	__be32 agf_cnt_root;
	__be32 agf_rmap_root;
	__be32 agf_bno_level;
	__be32 agf_cnt_level;
	__be32 agf_rmap_level;
	__be32 agf_flfirst;
	__be32 agf_fllast;
	__be32 agf_flcount;
	__be32 agf_freeblks;
	__be32 agf_longest;
	__be32 agf_btreeblks;
	uuid_t agf_uuid;
	__be32 agf_rmap_blocks;
	__be32 agf_refcount_blocks;
	__be32 agf_refcount_root;
	__be32 agf_refcount_level;
	__be64 agf_spare64[14];
	__be64 agf_lsn;
	__be32 agf_crc;
	__be32 agf_spare2;
};

struct xfs_agfl {
	__be32 agfl_magicnum;
	__be32 agfl_seqno;
	uuid_t agfl_uuid;
	__be64 agfl_lsn;
	__be32 agfl_crc;
} __attribute__((packed));

typedef void (*aghdr_init_work_f)(struct xfs_mount *, struct xfs_buf *, struct aghdr_init_data *);

struct xfs_buf_ops;

struct xfs_aghdr_grow_data {
	xfs_daddr_t daddr;
	size_t numblks;
	const struct xfs_buf_ops *ops;
	aghdr_init_work_f work;
	const struct xfs_btree_ops *bc_ops;
	bool need_init;
};

struct xfs_agi {
	__be32 agi_magicnum;
	__be32 agi_versionnum;
	__be32 agi_seqno;
	__be32 agi_length;
	__be32 agi_count;
	__be32 agi_root;
	__be32 agi_level;
	__be32 agi_freecount;
	__be32 agi_newino;
	__be32 agi_dirino;
	__be32 agi_unlinked[64];
	uuid_t agi_uuid;
	__be32 agi_crc;
	__be32 agi_pad32;
	__be64 agi_lsn;
	__be32 agi_free_root;
	__be32 agi_free_level;
	__be32 agi_iblocks;
	__be32 agi_fblocks;
};

struct xlog;

struct xfs_ail {
	struct xlog *ail_log;
	struct task_struct *ail_task;
	struct list_head ail_head;
	struct list_head ail_cursors;
	spinlock_t ail_lock;
	xfs_lsn_t ail_last_pushed_lsn;
	xfs_lsn_t ail_head_lsn;
	int ail_log_flush;
	long unsigned int ail_opstate;
	struct list_head ail_buf_list;
	wait_queue_head_t ail_empty;
	xfs_lsn_t ail_target;
};

struct xfs_log_item;

struct xfs_ail_cursor {
	struct list_head list;
	struct xfs_log_item *item;
};

struct xfs_owner_info {
	uint64_t oi_owner;
	xfs_fileoff_t oi_offset;
	unsigned int oi_flags;
};

struct xfs_alloc_arg {
	struct xfs_trans *tp;
	struct xfs_mount *mp;
	struct xfs_buf *agbp;
	struct xfs_perag *pag;
	xfs_fsblock_t fsbno;
	xfs_agnumber_t agno;
	xfs_agblock_t agbno;
	xfs_extlen_t minlen;
	xfs_extlen_t maxlen;
	xfs_extlen_t mod;
	xfs_extlen_t prod;
	xfs_extlen_t minleft;
	xfs_extlen_t total;
	xfs_extlen_t alignment;
	xfs_extlen_t minalignslop;
	xfs_agblock_t min_agbno;
	xfs_agblock_t max_agbno;
	xfs_extlen_t len;
	int datatype;
	char wasdel;
	char wasfromfl;
	bool alloc_minlen_only;
	struct xfs_owner_info oinfo;
	enum xfs_ag_resv_type resv;
};

typedef struct xfs_alloc_arg xfs_alloc_arg_t;

struct xfs_defer_pending;

struct xfs_alloc_autoreap {
	struct xfs_defer_pending *dfp;
};

struct xfs_alloc_cur {
	struct xfs_btree_cur *cnt;
	struct xfs_btree_cur *bnolt;
	struct xfs_btree_cur *bnogt;
	xfs_extlen_t cur_len;
	xfs_agblock_t rec_bno;
	xfs_extlen_t rec_len;
	xfs_agblock_t bno;
	xfs_extlen_t len;
	xfs_extlen_t diff;
	unsigned int busy_gen;
	bool busy;
};

typedef int (*xfs_alloc_query_range_fn)(struct xfs_btree_cur *, const struct xfs_alloc_rec_incore *, void *);

struct xfs_alloc_query_range_info {
	xfs_alloc_query_range_fn fn;
	void *priv;
};

typedef struct xfs_alloc_rec xfs_alloc_rec_t;

struct xfs_apply_dqtrx_params {
	uintptr_t tx_id;
	xfs_ino_t ino;
	xfs_dqtype_t q_type;
	xfs_dqid_t q_id;
};

struct xfs_attr3_icleaf_hdr {
	uint32_t forw;
	uint32_t back;
	uint16_t magic;
	uint16_t count;
	uint16_t usedbytes;
	uint32_t firstused;
	__u8 holes;
	struct {
		uint16_t base;
		uint16_t size;
	} freemap[3];
};

struct xfs_da_blkinfo {
	__be32 forw;
	__be32 back;
	__be16 magic;
	__be16 pad;
};

struct xfs_da3_blkinfo {
	struct xfs_da_blkinfo hdr;
	__be32 crc;
	__be64 blkno;
	__be64 lsn;
	uuid_t uuid;
	__be64 owner;
};

struct xfs_attr_leaf_map {
	__be16 base;
	__be16 size;
};

struct xfs_attr3_leaf_hdr {
	struct xfs_da3_blkinfo info;
	__be16 count;
	__be16 usedbytes;
	__be16 firstused;
	__u8 holes;
	__u8 pad1;
	struct xfs_attr_leaf_map freemap[3];
	__be32 pad2;
};

struct xfs_attr_leaf_entry {
	__be32 hashval;
	__be16 nameidx;
	__u8 flags;
	__u8 pad2;
};

struct xfs_attr3_leafblock {
	struct xfs_attr3_leaf_hdr hdr;
	struct xfs_attr_leaf_entry entries[0];
};

struct xfs_attr3_rmt_hdr {
	__be32 rm_magic;
	__be32 rm_offset;
	__be32 rm_bytes;
	__be32 rm_crc;
	uuid_t rm_uuid;
	__be64 rm_owner;
	__be64 rm_blkno;
	__be64 rm_lsn;
};

struct xfs_attri_log_nameval;

struct xfs_attr_intent {
	struct list_head xattri_list;
	struct xfs_da_state *xattri_da_state;
	struct xfs_da_args *xattri_da_args;
	struct xfs_attri_log_nameval *xattri_nameval;
	enum xfs_delattr_state xattri_dela_state;
	unsigned int xattri_op_flags;
	xfs_dablk_t xattri_lblkno;
	int xattri_blkcnt;
	struct xfs_bmbt_irec xattri_map;
};

typedef struct xfs_attr_leaf_entry xfs_attr_leaf_entry_t;

typedef struct xfs_da_blkinfo xfs_da_blkinfo_t;

typedef struct xfs_attr_leaf_map xfs_attr_leaf_map_t;

struct xfs_attr_leaf_hdr {
	xfs_da_blkinfo_t info;
	__be16 count;
	__be16 usedbytes;
	__be16 firstused;
	__u8 holes;
	__u8 pad1;
	xfs_attr_leaf_map_t freemap[3];
};

typedef struct xfs_attr_leaf_hdr xfs_attr_leaf_hdr_t;

struct xfs_attr_leaf_name_local {
	__be16 valuelen;
	__u8 namelen;
	__u8 nameval[0];
};

typedef struct xfs_attr_leaf_name_local xfs_attr_leaf_name_local_t;

struct xfs_attr_leaf_name_remote {
	__be32 valueblk;
	__be32 valuelen;
	__u8 namelen;
	__u8 name[0];
};

typedef struct xfs_attr_leaf_name_remote xfs_attr_leaf_name_remote_t;

struct xfs_attr_leafblock {
	xfs_attr_leaf_hdr_t hdr;
	xfs_attr_leaf_entry_t entries[0];
};

typedef struct xfs_attr_leafblock xfs_attr_leafblock_t;

struct xfs_attrlist_cursor_kern {
	__u32 hashval;
	__u32 blkno;
	__u32 offset;
	__u16 pad1;
	__u8 pad2;
	__u8 initted;
};

struct xfs_attr_list_context;

typedef void (*put_listent_func_t)(struct xfs_attr_list_context *, int, unsigned char *, int, void *, int);

struct xfs_attr_list_context {
	struct xfs_trans *tp;
	struct xfs_inode *dp;
	struct xfs_attrlist_cursor_kern cursor;
	void *buffer;
	int seen_enough;
	bool allow_incomplete;
	ssize_t count;
	int dupcnt;
	int bufsize;
	int firstu;
	unsigned int attr_filter;
	int resynch;
	put_listent_func_t put_listent;
	int index;
};

struct xfs_attr_multiop {
	__u32 am_opcode;
	__s32 am_error;
	void *am_attrname;
	void *am_attrvalue;
	__u32 am_length;
	__u32 am_flags;
};

typedef struct xfs_attr_multiop xfs_attr_multiop_t;

struct xfs_attr_sf_entry {
	__u8 namelen;
	__u8 valuelen;
	__u8 flags;
	__u8 nameval[0];
};

struct xfs_attr_sf_hdr {
	__be16 totsize;
	__u8 count;
	__u8 padding;
};

struct xfs_attr_sf_sort {
	uint8_t entno;
	uint8_t namelen;
	uint8_t valuelen;
	uint8_t flags;
	xfs_dahash_t hash;
	unsigned char *name;
	void *value;
};

typedef struct xfs_attr_sf_sort xfs_attr_sf_sort_t;

struct xfs_attrd_log_format {
	uint16_t alfd_type;
	uint16_t alfd_size;
	uint32_t __pad;
	uint64_t alfd_alf_id;
};

struct xfs_item_ops;

struct xfs_log_vec;

struct xfs_log_item {
	struct list_head li_ail;
	struct list_head li_trans;
	xfs_lsn_t li_lsn;
	struct xlog *li_log;
	struct xfs_ail *li_ailp;
	uint li_type;
	long unsigned int li_flags;
	struct xfs_buf *li_buf;
	struct list_head li_bio_list;
	const struct xfs_item_ops *li_ops;
	struct list_head li_cil;
	struct xfs_log_vec *li_lv;
	struct xfs_log_vec *li_lv_shadow;
	xfs_csn_t li_seq;
	uint32_t li_order_id;
};

struct xfs_attri_log_item;

struct xfs_attrd_log_item {
	struct xfs_log_item attrd_item;
	struct xfs_attri_log_item *attrd_attrip;
	struct xfs_attrd_log_format attrd_format;
};

struct xfs_attri_log_format {
	uint16_t alfi_type;
	uint16_t alfi_size;
	uint32_t alfi_igen;
	uint64_t alfi_id;
	uint64_t alfi_ino;
	uint32_t alfi_op_flags;
	union {
		uint32_t alfi_name_len;
		struct {
			uint16_t alfi_old_name_len;
			uint16_t alfi_new_name_len;
		};
	};
	uint32_t alfi_value_len;
	uint32_t alfi_attr_filter;
};

struct xfs_attri_log_item {
	struct xfs_log_item attri_item;
	atomic_t attri_refcount;
	struct xfs_attri_log_nameval *attri_nameval;
	struct xfs_attri_log_format attri_format;
};

struct xfs_log_iovec {
	void *i_addr;
	int i_len;
	uint i_type;
};

struct xfs_attri_log_nameval {
	struct xfs_log_iovec name;
	struct xfs_log_iovec new_name;
	struct xfs_log_iovec value;
	struct xfs_log_iovec new_value;
	refcount_t refcount;
};

struct xfs_attrlist {
	__s32 al_count;
	__s32 al_more;
	__s32 al_offset[0];
};

struct xfs_attrlist_cursor {
	__u32 opaque[4];
};

struct xfs_attrlist_ent {
	__u32 a_valuelen;
	char a_name[0];
};

struct xfs_bmalloca {
	struct xfs_trans *tp;
	struct xfs_inode *ip;
	struct xfs_bmbt_irec prev;
	struct xfs_bmbt_irec got;
	xfs_fileoff_t offset;
	xfs_extlen_t length;
	xfs_fsblock_t blkno;
	struct xfs_btree_cur *cur;
	struct xfs_iext_cursor icur;
	int nallocs;
	int logflags;
	xfs_extlen_t total;
	xfs_extlen_t minlen;
	xfs_extlen_t minleft;
	bool eof;
	bool wasdel;
	bool aeof;
	bool conv;
	int datatype;
	uint32_t flags;
};

struct xfs_group;

struct xfs_bmap_intent {
	struct list_head bi_list;
	enum xfs_bmap_intent_type bi_type;
	int bi_whichfork;
	struct xfs_inode *bi_owner;
	struct xfs_group *bi_group;
	struct xfs_bmbt_irec bi_bmap;
};

typedef int (*xfs_bmap_query_range_fn)(struct xfs_btree_cur *, struct xfs_bmbt_irec *, void *);

struct xfs_bmap_query_range {
	xfs_bmap_query_range_fn fn;
	void *priv;
};

typedef struct xfs_bmbt_irec xfs_bmbt_irec_t;

typedef struct xfs_bmbt_key xfs_bmbt_key_t;

struct xfs_bmdr_block {
	__be16 bb_level;
	__be16 bb_numrecs;
};

typedef struct xfs_bmdr_block xfs_bmdr_block_t;

struct xfs_bstime {
	__kernel_long_t tv_sec;
	__s32 tv_nsec;
};

typedef struct xfs_bstime xfs_bstime_t;

struct xfs_bstat {
	__u64 bs_ino;
	__u16 bs_mode;
	__u16 bs_nlink;
	__u32 bs_uid;
	__u32 bs_gid;
	__u32 bs_rdev;
	__s32 bs_blksize;
	__s64 bs_size;
	xfs_bstime_t bs_atime;
	xfs_bstime_t bs_mtime;
	xfs_bstime_t bs_ctime;
	int64_t bs_blocks;
	__u32 bs_xflags;
	__s32 bs_extsize;
	__s32 bs_extents;
	__u32 bs_gen;
	__u16 bs_projid_lo;
	__u16 bs_forkoff;
	__u16 bs_projid_hi;
	uint16_t bs_sick;
	uint16_t bs_checked;
	unsigned char bs_pad[2];
	__u32 bs_cowextsize;
	__u32 bs_dmevmask;
	__u16 bs_dmstate;
	__u16 bs_aextents;
};

struct xfs_ibulk;

struct xfs_bulkstat;

typedef int (*bulkstat_one_fmt_pf)(struct xfs_ibulk *, const struct xfs_bulkstat *);

struct xfs_bstat_chunk {
	bulkstat_one_fmt_pf formatter;
	struct xfs_ibulk *breq;
	struct xfs_bulkstat *buf;
};

struct xfs_btree_block;

typedef int (*xfs_btree_bload_get_records_fn)(struct xfs_btree_cur *, unsigned int, struct xfs_btree_block *, unsigned int, void *);

typedef int (*xfs_btree_bload_claim_block_fn)(struct xfs_btree_cur *, union xfs_btree_ptr *, void *);

typedef size_t (*xfs_btree_bload_iroot_size_fn)(struct xfs_btree_cur *, unsigned int, unsigned int, void *);

struct xfs_btree_bload {
	xfs_btree_bload_get_records_fn get_records;
	xfs_btree_bload_claim_block_fn claim_block;
	xfs_btree_bload_iroot_size_fn iroot_size;
	uint64_t nr_records;
	int leaf_slack;
	int node_slack;
	uint64_t nr_blocks;
	unsigned int btree_height;
	uint16_t max_dirty;
	uint16_t nr_dirty;
};

struct xfs_btree_block_shdr {
	__be32 bb_leftsib;
	__be32 bb_rightsib;
	__be64 bb_blkno;
	__be64 bb_lsn;
	uuid_t bb_uuid;
	__be32 bb_owner;
	__le32 bb_crc;
};

struct xfs_btree_block_lhdr {
	__be64 bb_leftsib;
	__be64 bb_rightsib;
	__be64 bb_blkno;
	__be64 bb_lsn;
	uuid_t bb_uuid;
	__be64 bb_owner;
	__le32 bb_crc;
	__be32 bb_pad;
};

struct xfs_btree_block {
	__be32 bb_magic;
	__be16 bb_level;
	__be16 bb_numrecs;
	union {
		struct xfs_btree_block_shdr s;
		struct xfs_btree_block_lhdr l;
	} bb_u;
};

struct xfs_btree_block_change_owner_info {
	uint64_t new_owner;
	struct list_head *buffer_list;
};

struct xfs_inobt_rec_incore {
	xfs_agino_t ir_startino;
	uint16_t ir_holemask;
	uint8_t ir_count;
	uint8_t ir_freecount;
	xfs_inofree_t ir_free;
};

union xfs_btree_irec {
	struct xfs_alloc_rec_incore a;
	struct xfs_bmbt_irec b;
	struct xfs_inobt_rec_incore i;
	struct xfs_rmap_irec r;
	struct xfs_refcount_irec rc;
};

struct xfs_btree_level {
	struct xfs_buf *bp;
	uint16_t ptr;
	uint16_t ra;
};

struct xfs_btree_cur {
	struct xfs_trans *bc_tp;
	struct xfs_mount *bc_mp;
	const struct xfs_btree_ops *bc_ops;
	struct kmem_cache *bc_cache;
	unsigned int bc_flags;
	union xfs_btree_irec bc_rec;
	uint8_t bc_nlevels;
	uint8_t bc_maxlevels;
	struct xfs_group *bc_group;
	union {
		struct {
			struct xfs_inode *ip;
			short int forksize;
			char whichfork;
			struct xbtree_ifakeroot *ifake;
		} bc_ino;
		struct {
			struct xfs_buf *agbp;
			struct xbtree_afakeroot *afake;
		} bc_ag;
		struct {
			struct xfbtree *xfbtree;
		} bc_mem;
	};
	union {
		struct {
			int allocated;
		} bc_bmap;
		struct {
			unsigned int nr_ops;
			unsigned int shape_changes;
		} bc_refc;
	};
	struct xfs_btree_level bc_levels[0];
};

struct xfs_btree_has_records {
	union xfs_btree_key start_key;
	union xfs_btree_key end_key;
	const union xfs_btree_key *key_mask;
	union xfs_btree_key high_key;
	enum xbtree_recpacking outcome;
};

struct xfs_btree_ops {
	const char *name;
	enum xfs_btree_type type;
	unsigned int geom_flags;
	size_t key_len;
	size_t ptr_len;
	size_t rec_len;
	unsigned int lru_refs;
	unsigned int statoff;
	unsigned int sick_mask;
	struct xfs_btree_cur * (*dup_cursor)(struct xfs_btree_cur *);
	void (*update_cursor)(struct xfs_btree_cur *, struct xfs_btree_cur *);
	void (*set_root)(struct xfs_btree_cur *, const union xfs_btree_ptr *, int);
	int (*alloc_block)(struct xfs_btree_cur *, const union xfs_btree_ptr *, union xfs_btree_ptr *, int *);
	int (*free_block)(struct xfs_btree_cur *, struct xfs_buf *);
	int (*get_minrecs)(struct xfs_btree_cur *, int);
	int (*get_maxrecs)(struct xfs_btree_cur *, int);
	int (*get_dmaxrecs)(struct xfs_btree_cur *, int);
	void (*init_key_from_rec)(union xfs_btree_key *, const union xfs_btree_rec *);
	void (*init_rec_from_cur)(struct xfs_btree_cur *, union xfs_btree_rec *);
	void (*init_ptr_from_cur)(struct xfs_btree_cur *, union xfs_btree_ptr *);
	void (*init_high_key_from_rec)(union xfs_btree_key *, const union xfs_btree_rec *);
	int64_t (*key_diff)(struct xfs_btree_cur *, const union xfs_btree_key *);
	int64_t (*diff_two_keys)(struct xfs_btree_cur *, const union xfs_btree_key *, const union xfs_btree_key *, const union xfs_btree_key *);
	const struct xfs_buf_ops *buf_ops;
	int (*keys_inorder)(struct xfs_btree_cur *, const union xfs_btree_key *, const union xfs_btree_key *);
	int (*recs_inorder)(struct xfs_btree_cur *, const union xfs_btree_rec *, const union xfs_btree_rec *);
	enum xbtree_key_contig (*keys_contiguous)(struct xfs_btree_cur *, const union xfs_btree_key *, const union xfs_btree_key *, const union xfs_btree_key *);
	struct xfs_btree_block * (*broot_realloc)(struct xfs_btree_cur *, unsigned int);
};

struct xfs_btree_split_args {
	struct xfs_btree_cur *cur;
	int level;
	union xfs_btree_ptr *ptrp;
	union xfs_btree_key *key;
	struct xfs_btree_cur **curp;
	int *stat;
	int result;
	bool kswapd;
	struct completion *done;
	struct work_struct work;
};

struct xfs_bud_log_format {
	uint16_t bud_type;
	uint16_t bud_size;
	uint32_t __pad;
	uint64_t bud_bui_id;
};

struct xfs_bui_log_item;

struct xfs_bud_log_item {
	struct xfs_log_item bud_item;
	struct xfs_bui_log_item *bud_buip;
	struct xfs_bud_log_format bud_format;
};

struct xfs_buf_map {
	xfs_daddr_t bm_bn;
	int bm_len;
	unsigned int bm_flags;
};

struct xfs_buf_log_item;

struct xfs_buf {
	struct rhash_head b_rhash_head;
	xfs_daddr_t b_rhash_key;
	int b_length;
	unsigned int b_hold;
	atomic_t b_lru_ref;
	xfs_buf_flags_t b_flags;
	struct semaphore b_sema;
	struct list_head b_lru;
	spinlock_t b_lock;
	unsigned int b_state;
	wait_queue_head_t b_waiters;
	struct list_head b_list;
	struct xfs_perag *b_pag;
	struct xfs_mount *b_mount;
	struct xfs_buftarg *b_target;
	void *b_addr;
	struct work_struct b_ioend_work;
	struct completion b_iowait;
	struct xfs_buf_log_item *b_log_item;
	struct list_head b_li_list;
	struct xfs_trans *b_transp;
	struct page **b_pages;
	struct page *b_page_array[2];
	struct xfs_buf_map *b_maps;
	struct xfs_buf_map __b_map;
	int b_map_count;
	atomic_t b_pin_count;
	unsigned int b_page_count;
	unsigned int b_offset;
	int b_error;
	void (*b_iodone)(struct xfs_buf *);
	int b_retries;
	long unsigned int b_first_retry_time;
	int b_last_error;
	const struct xfs_buf_ops *b_ops;
	struct callback_head b_rcu;
};

struct xfs_buf_cache {
	struct rhashtable bc_hash;
};

struct xfs_buf_cancel {
	xfs_daddr_t bc_blkno;
	uint bc_len;
	int bc_refcount;
	struct list_head bc_list;
};

struct xfs_buf_log_format {
	short unsigned int blf_type;
	short unsigned int blf_size;
	short unsigned int blf_flags;
	short unsigned int blf_len;
	int64_t blf_blkno;
	unsigned int blf_map_size;
	unsigned int blf_data_map[17];
};

struct xfs_buf_log_item {
	struct xfs_log_item bli_item;
	struct xfs_buf *bli_buf;
	unsigned int bli_flags;
	unsigned int bli_recur;
	atomic_t bli_refcount;
	int bli_format_count;
	struct xfs_buf_log_format *bli_formats;
	struct xfs_buf_log_format __bli_format;
};

struct xfs_buf_ops {
	char *name;
	union {
		__be32 magic[2];
		__be16 magic16[2];
	};
	void (*verify_read)(struct xfs_buf *);
	void (*verify_write)(struct xfs_buf *);
	xfs_failaddr_t (*verify_struct)(struct xfs_buf *);
};

struct xfs_buftarg {
	dev_t bt_dev;
	struct file *bt_bdev_file;
	struct block_device *bt_bdev;
	struct dax_device *bt_daxdev;
	struct file *bt_file;
	u64 bt_dax_part_off;
	struct xfs_mount *bt_mount;
	unsigned int bt_meta_sectorsize;
	size_t bt_meta_sectormask;
	size_t bt_logical_sectorsize;
	size_t bt_logical_sectormask;
	struct shrinker *bt_shrinker;
	struct list_lru bt_lru;
	struct percpu_counter bt_readahead_count;
	struct ratelimit_state bt_ioerror_rl;
	unsigned int bt_bdev_awu_min;
	unsigned int bt_bdev_awu_max;
	struct xfs_buf_cache bt_cache[0];
};

struct xfs_map_extent {
	uint64_t me_owner;
	uint64_t me_startblock;
	uint64_t me_startoff;
	uint32_t me_len;
	uint32_t me_flags;
};

struct xfs_bui_log_format {
	uint16_t bui_type;
	uint16_t bui_size;
	uint32_t bui_nextents;
	uint64_t bui_id;
	struct xfs_map_extent bui_extents[0];
};

struct xfs_bui_log_item {
	struct xfs_log_item bui_item;
	atomic_t bui_refcount;
	atomic_t bui_next_extent;
	struct xfs_bui_log_format bui_format;
};

struct xfs_bulk_ireq {
	uint64_t ino;
	uint32_t flags;
	uint32_t icount;
	uint32_t ocount;
	uint32_t agno;
	uint64_t reserved[5];
};

struct xfs_bulkstat {
	uint64_t bs_ino;
	uint64_t bs_size;
	uint64_t bs_blocks;
	uint64_t bs_xflags;
	int64_t bs_atime;
	int64_t bs_mtime;
	int64_t bs_ctime;
	int64_t bs_btime;
	uint32_t bs_gen;
	uint32_t bs_uid;
	uint32_t bs_gid;
	uint32_t bs_projectid;
	uint32_t bs_atime_nsec;
	uint32_t bs_mtime_nsec;
	uint32_t bs_ctime_nsec;
	uint32_t bs_btime_nsec;
	uint32_t bs_blksize;
	uint32_t bs_rdev;
	uint32_t bs_cowextsize_blks;
	uint32_t bs_extsize_blks;
	uint32_t bs_nlink;
	uint32_t bs_extents;
	uint32_t bs_aextents;
	uint16_t bs_version;
	uint16_t bs_forkoff;
	uint16_t bs_sick;
	uint16_t bs_checked;
	uint16_t bs_mode;
	uint16_t bs_pad2;
	uint64_t bs_extents64;
	uint64_t bs_pad[6];
};

struct xfs_bulkstat_req {
	struct xfs_bulk_ireq hdr;
	struct xfs_bulkstat bulkstat[0];
};

struct xfs_busy_extents {
	struct list_head extent_list;
	struct work_struct endio_work;
	void *owner;
};

struct xfs_cil_ctx;

struct xfs_cil {
	struct xlog *xc_log;
	long unsigned int xc_flags;
	atomic_t xc_iclog_hdrs;
	struct workqueue_struct *xc_push_wq;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct rw_semaphore xc_ctx_lock;
	struct xfs_cil_ctx *xc_ctx;
	long: 64;
	long: 64;
	spinlock_t xc_push_lock;
	xfs_csn_t xc_push_seq;
	bool xc_push_commit_stable;
	struct list_head xc_committing;
	wait_queue_head_t xc_commit_wait;
	wait_queue_head_t xc_start_wait;
	xfs_csn_t xc_current_sequence;
	wait_queue_head_t xc_push_wait;
	void *xc_pcp;
};

struct xlog_in_core;

struct xlog_ticket;

struct xfs_cil_ctx {
	struct xfs_cil *cil;
	xfs_csn_t sequence;
	xfs_lsn_t start_lsn;
	xfs_lsn_t commit_lsn;
	struct xlog_in_core *commit_iclog;
	struct xlog_ticket *ticket;
	atomic_t space_used;
	struct xfs_busy_extents busy_extents;
	struct list_head log_items;
	struct list_head lv_chain;
	struct list_head iclog_entry;
	struct list_head committing;
	struct work_struct push_work;
	atomic_t order_id;
	struct cpumask cil_pcpmask;
};

struct xfs_commit_range {
	__s32 file1_fd;
	__u32 pad;
	__u64 file1_offset;
	__u64 file2_offset;
	__u64 length;
	__u64 flags;
	__u64 file2_freshness[6];
};

struct xfs_fsid {
	__u32 val[2];
};

typedef struct xfs_fsid xfs_fsid_t;

struct xfs_commit_range_fresh {
	xfs_fsid_t fsid;
	__u64 file2_ino;
	__s64 file2_mtime;
	__s64 file2_ctime;
	__s32 file2_mtime_nsec;
	__s32 file2_ctime_nsec;
	__u32 file2_gen;
	__u32 magic;
};

struct xfs_cud_log_format {
	uint16_t cud_type;
	uint16_t cud_size;
	uint32_t __pad;
	uint64_t cud_cui_id;
};

struct xfs_cui_log_item;

struct xfs_cud_log_item {
	struct xfs_log_item cud_item;
	struct xfs_cui_log_item *cud_cuip;
	struct xfs_cud_log_format cud_format;
};

struct xfs_phys_extent {
	uint64_t pe_startblock;
	uint32_t pe_len;
	uint32_t pe_flags;
};

struct xfs_cui_log_format {
	uint16_t cui_type;
	uint16_t cui_size;
	uint32_t cui_nextents;
	uint64_t cui_id;
	struct xfs_phys_extent cui_extents[0];
};

struct xfs_cui_log_item {
	struct xfs_log_item cui_item;
	atomic_t cui_refcount;
	atomic_t cui_next_extent;
	struct xfs_cui_log_format cui_format;
};

struct xfs_da_node_entry;

struct xfs_da3_icnode_hdr {
	uint32_t forw;
	uint32_t back;
	uint16_t magic;
	uint16_t count;
	uint16_t level;
	struct xfs_da_node_entry *btree;
};

struct xfs_da3_node_hdr {
	struct xfs_da3_blkinfo info;
	__be16 __count;
	__be16 __level;
	__be32 __pad32;
};

struct xfs_da_node_entry {
	__be32 hashval;
	__be32 before;
};

struct xfs_da3_intnode {
	struct xfs_da3_node_hdr hdr;
	struct xfs_da_node_entry __btree[0];
};

typedef struct xfs_da_args xfs_da_args_t;

struct xfs_da_geometry {
	unsigned int blksize;
	unsigned int fsbcount;
	uint8_t fsblog;
	uint8_t blklog;
	unsigned int node_hdr_size;
	unsigned int node_ents;
	unsigned int magicpct;
	xfs_dablk_t datablk;
	unsigned int leaf_hdr_size;
	unsigned int leaf_max_ents;
	xfs_dablk_t leafblk;
	unsigned int free_hdr_size;
	unsigned int free_max_bests;
	xfs_dablk_t freeblk;
	xfs_extnum_t max_extents;
	xfs_dir2_data_aoff_t data_first_offset;
	size_t data_entry_offset;
};

struct xfs_da_node_hdr {
	struct xfs_da_blkinfo info;
	__be16 __count;
	__be16 __level;
};

struct xfs_da_intnode {
	struct xfs_da_node_hdr hdr;
	struct xfs_da_node_entry __btree[0];
};

typedef struct xfs_da_intnode xfs_da_intnode_t;

struct xfs_da_state_blk {
	struct xfs_buf *bp;
	xfs_dablk_t blkno;
	xfs_daddr_t disk_blkno;
	int index;
	xfs_dahash_t hashval;
	int magic;
};

typedef struct xfs_da_state_blk xfs_da_state_blk_t;

struct xfs_da_state_path {
	int active;
	xfs_da_state_blk_t blk[5];
};

typedef struct xfs_da_state_path xfs_da_state_path_t;

struct xfs_da_state {
	xfs_da_args_t *args;
	struct xfs_mount *mp;
	xfs_da_state_path_t path;
	xfs_da_state_path_t altpath;
	unsigned char inleaf;
	unsigned char extravalid;
	unsigned char extraafter;
	xfs_da_state_blk_t extrablk;
};

typedef struct xfs_da_state xfs_da_state_t;

struct xfs_quota_limits {
	xfs_qcnt_t hard;
	xfs_qcnt_t soft;
	time64_t time;
};

struct xfs_def_quota {
	struct xfs_quota_limits blk;
	struct xfs_quota_limits ino;
	struct xfs_quota_limits rtb;
};

struct xfs_defer_resources {
	struct xfs_buf *dr_bp[2];
	struct xfs_inode *dr_ip[5];
	short unsigned int dr_bufs;
	short unsigned int dr_ordered;
	short unsigned int dr_inos;
};

struct xfs_defer_capture {
	struct list_head dfc_list;
	struct list_head dfc_dfops;
	unsigned int dfc_tpflags;
	unsigned int dfc_blkres;
	unsigned int dfc_rtxres;
	unsigned int dfc_logres;
	struct xfs_defer_resources dfc_held;
};

struct xfs_defer_drain {
	atomic_t dr_count;
	struct wait_queue_head dr_waiters;
};

struct xfs_defer_op_type {
	const char *name;
	unsigned int max_items;
	struct xfs_log_item * (*create_intent)(struct xfs_trans *, struct list_head *, unsigned int, bool);
	void (*abort_intent)(struct xfs_log_item *);
	struct xfs_log_item * (*create_done)(struct xfs_trans *, struct xfs_log_item *, unsigned int);
	int (*finish_item)(struct xfs_trans *, struct xfs_log_item *, struct list_head *, struct xfs_btree_cur **);
	void (*finish_cleanup)(struct xfs_trans *, struct xfs_btree_cur *, int);
	void (*cancel_item)(struct list_head *);
	int (*recover_work)(struct xfs_defer_pending *, struct list_head *);
	struct xfs_log_item * (*relog_intent)(struct xfs_trans *, struct xfs_log_item *, struct xfs_log_item *);
};

struct xfs_defer_pending {
	struct list_head dfp_list;
	struct list_head dfp_work;
	struct xfs_log_item *dfp_intent;
	struct xfs_log_item *dfp_done;
	const struct xfs_defer_op_type *dfp_ops;
	unsigned int dfp_count;
	unsigned int dfp_flags;
};

struct xfs_dinode {
	__be16 di_magic;
	__be16 di_mode;
	__u8 di_version;
	__u8 di_format;
	__be16 di_metatype;
	__be32 di_uid;
	__be32 di_gid;
	__be32 di_nlink;
	__be16 di_projid_lo;
	__be16 di_projid_hi;
	union {
		__be64 di_big_nextents;
		__be64 di_v3_pad;
		struct {
			__u8 di_v2_pad[6];
			__be16 di_flushiter;
		};
	};
	xfs_timestamp_t di_atime;
	xfs_timestamp_t di_mtime;
	xfs_timestamp_t di_ctime;
	__be64 di_size;
	__be64 di_nblocks;
	__be32 di_extsize;
	union {
		struct {
			__be32 di_nextents;
			__be16 di_anextents;
		} __attribute__((packed));
		struct {
			__be32 di_big_anextents;
			__be16 di_nrext64_pad;
		} __attribute__((packed));
	};
	__u8 di_forkoff;
	__s8 di_aformat;
	__be32 di_dmevmask;
	__be16 di_dmstate;
	__be16 di_flags;
	__be32 di_gen;
	__be32 di_next_unlinked;
	__le32 di_crc;
	__be64 di_changecount;
	__be64 di_lsn;
	__be64 di_flags2;
	__be32 di_cowextsize;
	__u8 di_pad2[12];
	xfs_timestamp_t di_crtime;
	__be64 di_ino;
	uuid_t di_uuid;
};

struct xfs_dir2_block_tail {
	__be32 count;
	__be32 stale;
};

typedef struct xfs_dir2_block_tail xfs_dir2_block_tail_t;

struct xfs_dir2_data_entry {
	__be64 inumber;
	__u8 namelen;
	__u8 name[0];
};

typedef struct xfs_dir2_data_entry xfs_dir2_data_entry_t;

struct xfs_dir2_data_free {
	__be16 offset;
	__be16 length;
};

typedef struct xfs_dir2_data_free xfs_dir2_data_free_t;

struct xfs_dir2_data_hdr {
	__be32 magic;
	xfs_dir2_data_free_t bestfree[3];
};

typedef struct xfs_dir2_data_hdr xfs_dir2_data_hdr_t;

struct xfs_dir2_data_unused {
	__be16 freetag;
	__be16 length;
	__be16 tag;
};

typedef struct xfs_dir2_data_unused xfs_dir2_data_unused_t;

struct xfs_dir2_free_hdr {
	__be32 magic;
	__be32 firstdb;
	__be32 nvalid;
	__be32 nused;
};

typedef struct xfs_dir2_free_hdr xfs_dir2_free_hdr_t;

struct xfs_dir2_free {
	xfs_dir2_free_hdr_t hdr;
	__be16 bests[0];
};

typedef struct xfs_dir2_free xfs_dir2_free_t;

struct xfs_dir2_leaf_hdr {
	xfs_da_blkinfo_t info;
	__be16 count;
	__be16 stale;
};

typedef struct xfs_dir2_leaf_hdr xfs_dir2_leaf_hdr_t;

struct xfs_dir2_leaf_entry {
	__be32 hashval;
	__be32 address;
};

typedef struct xfs_dir2_leaf_entry xfs_dir2_leaf_entry_t;

struct xfs_dir2_leaf {
	xfs_dir2_leaf_hdr_t hdr;
	xfs_dir2_leaf_entry_t __ents[0];
};

typedef struct xfs_dir2_leaf xfs_dir2_leaf_t;

struct xfs_dir2_leaf_tail {
	__be32 bestcount;
};

typedef struct xfs_dir2_leaf_tail xfs_dir2_leaf_tail_t;

struct xfs_dir2_sf_entry {
	__u8 namelen;
	__u8 offset[2];
	__u8 name[0];
};

typedef struct xfs_dir2_sf_entry xfs_dir2_sf_entry_t;

struct xfs_dir2_sf_hdr {
	uint8_t count;
	uint8_t i8count;
	uint8_t parent[8];
};

typedef struct xfs_dir2_sf_hdr xfs_dir2_sf_hdr_t;

struct xfs_dir3_blk_hdr {
	__be32 magic;
	__be32 crc;
	__be64 blkno;
	__be64 lsn;
	uuid_t uuid;
	__be64 owner;
};

struct xfs_dir3_data_hdr {
	struct xfs_dir3_blk_hdr hdr;
	xfs_dir2_data_free_t best_free[3];
	__be32 pad;
};

struct xfs_dir3_free_hdr {
	struct xfs_dir3_blk_hdr hdr;
	__be32 firstdb;
	__be32 nvalid;
	__be32 nused;
	__be32 pad;
};

struct xfs_dir3_free {
	struct xfs_dir3_free_hdr hdr;
	__be16 bests[0];
};

struct xfs_dir3_icfree_hdr {
	uint32_t magic;
	uint32_t firstdb;
	uint32_t nvalid;
	uint32_t nused;
	__be16 *bests;
};

struct xfs_dir3_icleaf_hdr {
	uint32_t forw;
	uint32_t back;
	uint16_t magic;
	uint16_t count;
	uint16_t stale;
	struct xfs_dir2_leaf_entry *ents;
};

struct xfs_dir3_leaf_hdr {
	struct xfs_da3_blkinfo info;
	__be16 count;
	__be16 stale;
	__be32 pad;
};

struct xfs_dir3_leaf {
	struct xfs_dir3_leaf_hdr hdr;
	struct xfs_dir2_leaf_entry __ents[0];
};

struct xfs_dir_update_params {
	const struct xfs_inode *dp;
	const struct xfs_inode *ip;
	const struct xfs_name *name;
	int delta;
};

struct xfs_disk_dquot {
	__be16 d_magic;
	__u8 d_version;
	__u8 d_type;
	__be32 d_id;
	__be64 d_blk_hardlimit;
	__be64 d_blk_softlimit;
	__be64 d_ino_hardlimit;
	__be64 d_ino_softlimit;
	__be64 d_bcount;
	__be64 d_icount;
	__be32 d_itimer;
	__be32 d_btimer;
	__be16 d_iwarns;
	__be16 d_bwarns;
	__be32 d_pad0;
	__be64 d_rtb_hardlimit;
	__be64 d_rtb_softlimit;
	__be64 d_rtbcount;
	__be32 d_rtbtimer;
	__be16 d_rtbwarns;
	__be16 d_pad;
};

struct xfs_dq_logformat {
	uint16_t qlf_type;
	uint16_t qlf_size;
	xfs_dqid_t qlf_id;
	int64_t qlf_blkno;
	int32_t qlf_len;
	uint32_t qlf_boffset;
};

struct xfs_dquot;

struct xfs_dq_logitem {
	struct xfs_log_item qli_item;
	struct xfs_dquot *qli_dquot;
	xfs_lsn_t qli_flush_lsn;
	spinlock_t qli_lock;
	bool qli_dirty;
};

struct xfs_dqblk {
	struct xfs_disk_dquot dd_diskdq;
	char dd_fill[4];
	__be32 dd_crc;
	__be64 dd_lsn;
	uuid_t dd_uuid;
};

struct xfs_dqtrx {
	struct xfs_dquot *qt_dquot;
	uint64_t qt_blk_res;
	int64_t qt_bcount_delta;
	int64_t qt_delbcnt_delta;
	uint64_t qt_rtblk_res;
	uint64_t qt_rtblk_res_used;
	int64_t qt_rtbcount_delta;
	int64_t qt_delrtb_delta;
	uint64_t qt_ino_res;
	uint64_t qt_ino_res_used;
	int64_t qt_icount_delta;
};

struct xfs_dqtrx_hook {
	struct xfs_hook mod_hook;
	struct xfs_hook apply_hook;
};

struct xfs_dquot_res {
	xfs_qcnt_t reserved;
	xfs_qcnt_t count;
	xfs_qcnt_t hardlimit;
	xfs_qcnt_t softlimit;
	time64_t timer;
};

struct xfs_dquot_pre {
	xfs_qcnt_t q_prealloc_lo_wmark;
	xfs_qcnt_t q_prealloc_hi_wmark;
	int64_t q_low_space[3];
};

struct xfs_dquot {
	struct list_head q_lru;
	struct xfs_mount *q_mount;
	xfs_dqtype_t q_type;
	uint16_t q_flags;
	xfs_dqid_t q_id;
	uint q_nrefs;
	int q_bufoffset;
	xfs_daddr_t q_blkno;
	xfs_fileoff_t q_fileoffset;
	struct xfs_dquot_res q_blk;
	struct xfs_dquot_res q_ino;
	struct xfs_dquot_res q_rtb;
	struct xfs_dq_logitem q_logitem;
	struct xfs_dquot_pre q_blk_prealloc;
	struct xfs_dquot_pre q_rtb_prealloc;
	struct mutex q_qlock;
	struct completion q_flush;
	atomic_t q_pincount;
	struct wait_queue_head q_pinwait;
};

struct xfs_dquot_acct {
	struct xfs_dqtrx dqs[15];
};

struct xfs_dsb {
	__be32 sb_magicnum;
	__be32 sb_blocksize;
	__be64 sb_dblocks;
	__be64 sb_rblocks;
	__be64 sb_rextents;
	uuid_t sb_uuid;
	__be64 sb_logstart;
	__be64 sb_rootino;
	__be64 sb_rbmino;
	__be64 sb_rsumino;
	__be32 sb_rextsize;
	__be32 sb_agblocks;
	__be32 sb_agcount;
	__be32 sb_rbmblocks;
	__be32 sb_logblocks;
	__be16 sb_versionnum;
	__be16 sb_sectsize;
	__be16 sb_inodesize;
	__be16 sb_inopblock;
	char sb_fname[12];
	__u8 sb_blocklog;
	__u8 sb_sectlog;
	__u8 sb_inodelog;
	__u8 sb_inopblog;
	__u8 sb_agblklog;
	__u8 sb_rextslog;
	__u8 sb_inprogress;
	__u8 sb_imax_pct;
	__be64 sb_icount;
	__be64 sb_ifree;
	__be64 sb_fdblocks;
	__be64 sb_frextents;
	__be64 sb_uquotino;
	__be64 sb_gquotino;
	__be16 sb_qflags;
	__u8 sb_flags;
	__u8 sb_shared_vn;
	__be32 sb_inoalignmt;
	__be32 sb_unit;
	__be32 sb_width;
	__u8 sb_dirblklog;
	__u8 sb_logsectlog;
	__be16 sb_logsectsize;
	__be32 sb_logsunit;
	__be32 sb_features2;
	__be32 sb_bad_features2;
	__be32 sb_features_compat;
	__be32 sb_features_ro_compat;
	__be32 sb_features_incompat;
	__be32 sb_features_log_incompat;
	__le32 sb_crc;
	__be32 sb_spino_align;
	__be64 sb_pquotino;
	__be64 sb_lsn;
	uuid_t sb_meta_uuid;
	__be64 sb_metadirino;
	__be32 sb_rgcount;
	__be32 sb_rgextents;
	__u8 sb_rgblklog;
	__u8 sb_pad[7];
};

struct xfs_dsymlink_hdr {
	__be32 sl_magic;
	__be32 sl_offset;
	__be32 sl_bytes;
	__be32 sl_crc;
	uuid_t sl_uuid;
	__be64 sl_owner;
	__be64 sl_blkno;
	__be64 sl_lsn;
};

struct xfs_extent {
	xfs_fsblock_t ext_start;
	xfs_extlen_t ext_len;
};

typedef struct xfs_extent xfs_extent_t;

struct xfs_efd_log_format {
	uint16_t efd_type;
	uint16_t efd_size;
	uint32_t efd_nextents;
	uint64_t efd_efi_id;
	xfs_extent_t efd_extents[0];
};

typedef struct xfs_efd_log_format xfs_efd_log_format_t;

struct xfs_efi_log_item;

struct xfs_efd_log_item {
	struct xfs_log_item efd_item;
	struct xfs_efi_log_item *efd_efip;
	uint efd_next_extent;
	xfs_efd_log_format_t efd_format;
};

struct xfs_efi_log_format {
	uint16_t efi_type;
	uint16_t efi_size;
	uint32_t efi_nextents;
	uint64_t efi_id;
	xfs_extent_t efi_extents[0];
};

typedef struct xfs_efi_log_format xfs_efi_log_format_t;

struct xfs_extent_32 {
	uint64_t ext_start;
	uint32_t ext_len;
} __attribute__((packed));

typedef struct xfs_extent_32 xfs_extent_32_t;

struct xfs_efi_log_format_32 {
	uint16_t efi_type;
	uint16_t efi_size;
	uint32_t efi_nextents;
	uint64_t efi_id;
	xfs_extent_32_t efi_extents[0];
};

typedef struct xfs_efi_log_format_32 xfs_efi_log_format_32_t;

struct xfs_extent_64 {
	uint64_t ext_start;
	uint32_t ext_len;
	uint32_t ext_pad;
};

typedef struct xfs_extent_64 xfs_extent_64_t;

struct xfs_efi_log_format_64 {
	uint16_t efi_type;
	uint16_t efi_size;
	uint32_t efi_nextents;
	uint64_t efi_id;
	xfs_extent_64_t efi_extents[0];
};

typedef struct xfs_efi_log_format_64 xfs_efi_log_format_64_t;

struct xfs_efi_log_item {
	struct xfs_log_item efi_item;
	atomic_t efi_refcount;
	atomic_t efi_next_extent;
	xfs_efi_log_format_t efi_format;
};

struct xfs_kobj {
	struct kobject kobject;
	struct completion complete;
};

struct xfs_error_cfg {
	struct xfs_kobj kobj;
	int max_retries;
	long int retry_timeout;
};

struct xfs_error_init {
	char *name;
	int max_retries;
	int retry_timeout;
};

struct xfs_error_injection {
	__s32 fd;
	__s32 errtag;
};

typedef struct xfs_error_injection xfs_error_injection_t;

struct xfs_exchange_range {
	__s32 file1_fd;
	__u32 pad;
	__u64 file1_offset;
	__u64 file2_offset;
	__u64 length;
	__u64 flags;
};

struct xfs_exchmaps_adjacent {
	struct xfs_bmbt_irec left1;
	struct xfs_bmbt_irec right1;
	struct xfs_bmbt_irec left2;
	struct xfs_bmbt_irec right2;
};

struct xfs_exchmaps_intent {
	struct list_head xmi_list;
	struct xfs_inode *xmi_ip1;
	struct xfs_inode *xmi_ip2;
	xfs_fileoff_t xmi_startoff1;
	xfs_fileoff_t xmi_startoff2;
	xfs_filblks_t xmi_blockcount;
	xfs_fsize_t xmi_isize1;
	xfs_fsize_t xmi_isize2;
	uint64_t xmi_flags;
};

struct xfs_exchmaps_req {
	struct xfs_inode *ip1;
	struct xfs_inode *ip2;
	xfs_fileoff_t startoff1;
	xfs_fileoff_t startoff2;
	xfs_filblks_t blockcount;
	uint64_t flags;
	xfs_filblks_t ip1_bcount;
	xfs_filblks_t ip2_bcount;
	xfs_filblks_t ip1_rtbcount;
	xfs_filblks_t ip2_rtbcount;
	long long unsigned int resblks;
	long long unsigned int nr_exchanges;
};

struct xfs_exchrange {
	struct file *file1;
	struct file *file2;
	loff_t file1_offset;
	loff_t file2_offset;
	u64 length;
	u64 flags;
	u64 file2_ino;
	struct timespec64 file2_mtime;
	struct timespec64 file2_ctime;
	u32 file2_gen;
};

struct xfs_extent_busy {
	struct rb_node rb_node;
	struct list_head list;
	struct xfs_group *group;
	xfs_agblock_t bno;
	xfs_extlen_t length;
	unsigned int flags;
};

struct xfs_extent_busy_tree {
	spinlock_t eb_lock;
	struct rb_root eb_tree;
	unsigned int eb_gen;
	wait_queue_head_t eb_wait;
};

struct xfs_extent_free_item {
	struct list_head xefi_list;
	uint64_t xefi_owner;
	xfs_fsblock_t xefi_startblock;
	xfs_extlen_t xefi_blockcount;
	struct xfs_group *xefi_group;
	unsigned int xefi_flags;
	enum xfs_ag_resv_type xefi_agresv;
};

struct xfs_fid {
	__u16 fid_len;
	__u16 fid_pad;
	__u32 fid_gen;
	__u64 fid_ino;
};

typedef struct xfs_fid xfs_fid_t;

struct xfs_fid64 {
	u64 ino;
	u32 gen;
	u64 parent_ino;
	u32 parent_gen;
} __attribute__((packed));

struct xfs_find_left_neighbor_info {
	struct xfs_rmap_irec high;
	struct xfs_rmap_irec *irec;
};

struct xfs_fs_eofblocks {
	__u32 eof_version;
	__u32 eof_flags;
	uid_t eof_uid;
	gid_t eof_gid;
	prid_t eof_prid;
	__u32 pad32;
	__u64 eof_min_file_size;
	__u64 pad64[12];
};

struct xfs_fsmap {
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	xfs_fileoff_t fmr_offset;
	xfs_filblks_t fmr_length;
};

struct xfs_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct xfs_fsmap fmh_keys[2];
};

struct xfs_fsmap_irec {
	xfs_daddr_t start_daddr;
	xfs_daddr_t len_daddr;
	uint64_t owner;
	uint64_t offset;
	unsigned int rm_flags;
	xfs_agblock_t rec_key;
};

struct xfs_fsop_handlereq {
	__u32 fd;
	void *path;
	__u32 oflags;
	void *ihandle;
	__u32 ihandlen;
	void *ohandle;
	__u32 *ohandlen;
};

struct xfs_fsop_attrlist_handlereq {
	struct xfs_fsop_handlereq hreq;
	struct xfs_attrlist_cursor pos;
	__u32 flags;
	__u32 buflen;
	void *buffer;
};

struct xfs_fsop_attrmulti_handlereq {
	struct xfs_fsop_handlereq hreq;
	__u32 opcount;
	struct xfs_attr_multiop *ops;
};

typedef struct xfs_fsop_attrmulti_handlereq xfs_fsop_attrmulti_handlereq_t;

struct xfs_fsop_bulkreq {
	__u64 *lastip;
	__s32 icount;
	void *ubuffer;
	__s32 *ocount;
};

struct xfs_fsop_counts {
	__u64 freedata;
	__u64 freertx;
	__u64 freeino;
	__u64 allocino;
};

struct xfs_fsop_geom {
	__u32 blocksize;
	__u32 rtextsize;
	__u32 agblocks;
	__u32 agcount;
	__u32 logblocks;
	__u32 sectsize;
	__u32 inodesize;
	__u32 imaxpct;
	__u64 datablocks;
	__u64 rtblocks;
	__u64 rtextents;
	__u64 logstart;
	unsigned char uuid[16];
	__u32 sunit;
	__u32 swidth;
	__s32 version;
	__u32 flags;
	__u32 logsectsize;
	__u32 rtsectsize;
	__u32 dirblocksize;
	__u32 logsunit;
	uint32_t sick;
	uint32_t checked;
	__u32 rgextents;
	__u32 rgcount;
	__u64 reserved[16];
};

typedef struct xfs_fsop_handlereq xfs_fsop_handlereq_t;

struct xfs_fsop_resblks {
	__u64 resblks;
	__u64 resblks_avail;
};

struct xfs_mru_cache_elem {
	struct list_head list_node;
	long unsigned int key;
};

struct xfs_fstrm_item {
	struct xfs_mru_cache_elem mru;
	struct xfs_perag *pag;
};

struct xfs_getfsmap_info;

struct xfs_getfsmap_dev {
	u32 dev;
	int (*fn)(struct xfs_trans *, const struct xfs_fsmap *, struct xfs_getfsmap_info *);
	sector_t nr_sectors;
};

struct xfs_getfsmap_info {
	struct xfs_fsmap_head *head;
	struct fsmap *fsmap_recs;
	struct xfs_buf *agf_bp;
	struct xfs_group *group;
	xfs_daddr_t next_daddr;
	xfs_daddr_t low_daddr;
	xfs_daddr_t end_daddr;
	u64 missing_owner;
	u32 dev;
	struct xfs_rmap_irec low;
	struct xfs_rmap_irec high;
	bool last;
};

struct xfs_getparents {
	struct xfs_attrlist_cursor gp_cursor;
	__u16 gp_iflags;
	__u16 gp_oflags;
	__u32 gp_bufsize;
	__u64 gp_reserved;
	__u64 gp_buffer;
};

struct xfs_handle {
	union {
		__s64 align;
		xfs_fsid_t _ha_fsid;
	} ha_u;
	xfs_fid_t ha_fid;
};

struct xfs_getparents_by_handle {
	struct xfs_handle gph_handle;
	struct xfs_getparents gph_request;
};

struct xfs_getparents_rec;

struct xfs_getparents_ctx {
	struct xfs_attr_list_context context;
	struct xfs_getparents_by_handle gph;
	struct xfs_inode *ip;
	void *krecords;
	struct xfs_getparents_rec *lastrec;
	unsigned int count;
};

struct xfs_getparents_rec {
	struct xfs_handle gpr_parent;
	__u32 gpr_reclen;
	__u32 gpr_reserved;
	char gpr_name[0];
};

struct xfs_globals {
	int bload_leaf_slack;
	int bload_node_slack;
	int log_recovery_delay;
	int mount_delay;
	bool bug_on_assert;
	bool always_cow;
};

struct xfs_hooks {
	struct blocking_notifier_head head;
};

struct xfs_group {
	struct xfs_mount *xg_mount;
	uint32_t xg_gno;
	enum xfs_group_type xg_type;
	atomic_t xg_ref;
	atomic_t xg_active_ref;
	uint32_t xg_block_count;
	uint32_t xg_min_gbno;
	struct xfs_extent_busy_tree *xg_busy_extents;
	uint16_t xg_checked;
	uint16_t xg_sick;
	spinlock_t xg_state_lock;
	struct xfs_defer_drain xg_intents_drain;
	struct xfs_hooks xg_rmap_update_hooks;
};

struct xfs_groups {
	struct xarray xa;
	uint32_t blocks;
	uint8_t blklog;
	uint64_t blkmask;
};

struct xfs_growfs_data {
	__u64 newblocks;
	__u32 imaxpct;
};

struct xfs_growfs_log {
	__u32 newblocks;
	__u32 isint;
};

struct xfs_growfs_rt {
	__u64 newblocks;
	__u32 extsize;
};

typedef struct xfs_growfs_rt xfs_growfs_rt_t;

typedef struct xfs_handle xfs_handle_t;

struct xfs_ialloc_count_inodes {
	xfs_agino_t count;
	xfs_agino_t freecount;
};

struct xfs_ibulk {
	struct xfs_mount *mp;
	struct mnt_idmap *idmap;
	void *ubuffer;
	xfs_ino_t startino;
	unsigned int icount;
	unsigned int ocount;
	unsigned int flags;
};

struct xfs_icluster {
	bool deleted;
	xfs_ino_t first_ino;
	uint64_t alloc;
};

struct xfs_icreate_args {
	struct mnt_idmap *idmap;
	struct xfs_inode *pip;
	dev_t rdev;
	umode_t mode;
	uint16_t flags;
};

struct xfs_icreate_log {
	uint16_t icl_type;
	uint16_t icl_size;
	__be32 icl_ag;
	__be32 icl_agbno;
	__be32 icl_count;
	__be32 icl_isize;
	__be32 icl_length;
	__be32 icl_gen;
};

struct xfs_icreate_item {
	struct xfs_log_item ic_item;
	struct xfs_icreate_log ic_format;
};

struct xfs_icwalk {
	__u32 icw_flags;
	kuid_t icw_uid;
	kgid_t icw_gid;
	prid_t icw_prid;
	__u64 icw_min_file_size;
	long int icw_scan_limit;
};

struct xfs_iext_rec {
	uint64_t lo;
	uint64_t hi;
};

struct xfs_iext_leaf {
	struct xfs_iext_rec recs[15];
	struct xfs_iext_leaf *prev;
	struct xfs_iext_leaf *next;
};

struct xfs_iext_node {
	uint64_t keys[16];
	void *ptrs[16];
};

struct xfs_ifork {
	int64_t if_bytes;
	struct xfs_btree_block *if_broot;
	unsigned int if_seq;
	int if_height;
	void *if_data;
	xfs_extnum_t if_nextents;
	short int if_broot_bytes;
	int8_t if_format;
	uint8_t if_needextents;
};

struct xfs_imap {
	xfs_daddr_t im_blkno;
	short unsigned int im_len;
	short unsigned int im_boffset;
};

struct xfs_ino_geometry {
	uint64_t maxicount;
	unsigned int inode_cluster_size;
	unsigned int inode_cluster_size_raw;
	unsigned int inodes_per_cluster;
	unsigned int blocks_per_cluster;
	unsigned int cluster_align;
	unsigned int cluster_align_inodes;
	unsigned int inoalign_mask;
	unsigned int inobt_mxr[2];
	unsigned int inobt_mnr[2];
	unsigned int inobt_maxlevels;
	unsigned int ialloc_inos;
	unsigned int ialloc_blks;
	unsigned int ialloc_min_blks;
	unsigned int ialloc_align;
	unsigned int agino_log;
	unsigned int attr_fork_offset;
	uint64_t new_diflags2;
	unsigned int min_folio_order;
};

typedef struct xfs_inobt_rec_incore xfs_inobt_rec_incore_t;

struct xfs_inode_log_item;

struct xfs_inode {
	struct xfs_mount *i_mount;
	union {
		struct {
			struct xfs_dquot *i_udquot;
			struct xfs_dquot *i_gdquot;
			struct xfs_dquot *i_pdquot;
		};
		uint64_t i_meta_resv_asked;
	};
	xfs_ino_t i_ino;
	struct xfs_imap i_imap;
	struct xfs_ifork *i_cowfp;
	struct xfs_ifork i_df;
	struct xfs_ifork i_af;
	struct xfs_inode_log_item *i_itemp;
	struct rw_semaphore i_lock;
	atomic_t i_pincount;
	struct llist_node i_gclist;
	uint16_t i_checked;
	uint16_t i_sick;
	spinlock_t i_flags_lock;
	long unsigned int i_flags;
	uint64_t i_delayed_blks;
	xfs_fsize_t i_disk_size;
	xfs_rfsblock_t i_nblocks;
	prid_t i_projid;
	xfs_extlen_t i_extsize;
	union {
		xfs_extlen_t i_cowextsize;
		uint16_t i_flushiter;
	};
	uint8_t i_forkoff;
	enum xfs_metafile_type i_metatype;
	uint16_t i_diflags;
	uint64_t i_diflags2;
	struct timespec64 i_crtime;
	xfs_agino_t i_next_unlinked;
	xfs_agino_t i_prev_unlinked;
	struct inode i_vnode;
	spinlock_t i_ioend_lock;
	struct work_struct i_ioend_work;
	struct list_head i_ioend_list;
};

typedef struct xfs_inode xfs_inode_t;

struct xfs_inode_log_format {
	uint16_t ilf_type;
	uint16_t ilf_size;
	uint32_t ilf_fields;
	uint16_t ilf_asize;
	uint16_t ilf_dsize;
	uint32_t ilf_pad;
	uint64_t ilf_ino;
	union {
		uint32_t ilfu_rdev;
		uint8_t __pad[16];
	} ilf_u;
	int64_t ilf_blkno;
	int32_t ilf_len;
	int32_t ilf_boffset;
};

struct xfs_inode_log_format_32 {
	uint16_t ilf_type;
	uint16_t ilf_size;
	uint32_t ilf_fields;
	uint16_t ilf_asize;
	uint16_t ilf_dsize;
	uint64_t ilf_ino;
	union {
		uint32_t ilfu_rdev;
		uint8_t __pad[16];
	} ilf_u;
	int64_t ilf_blkno;
	int32_t ilf_len;
	int32_t ilf_boffset;
} __attribute__((packed));

struct xfs_inode_log_item {
	struct xfs_log_item ili_item;
	struct xfs_inode *ili_inode;
	short unsigned int ili_lock_flags;
	unsigned int ili_dirty_flags;
	spinlock_t ili_lock;
	unsigned int ili_last_fields;
	unsigned int ili_fields;
	unsigned int ili_fsync_fields;
	xfs_lsn_t ili_flush_lsn;
	xfs_csn_t ili_commit_seq;
};

struct xfs_inodegc {
	struct xfs_mount *mp;
	struct llist_head list;
	struct delayed_work work;
	int error;
	unsigned int items;
	unsigned int shrinker_hits;
	unsigned int cpu;
};

struct xfs_inogrp {
	__u64 xi_startino;
	__s32 xi_alloccount;
	__u64 xi_allocmask;
};

struct xfs_inumbers {
	uint64_t xi_startino;
	uint64_t xi_allocmask;
	uint8_t xi_alloccount;
	uint8_t xi_version;
	uint8_t xi_padding[6];
};

typedef int (*inumbers_fmt_pf)(struct xfs_ibulk *, const struct xfs_inumbers *);

struct xfs_inumbers_chunk {
	inumbers_fmt_pf formatter;
	struct xfs_ibulk *breq;
};

struct xfs_inumbers_req {
	struct xfs_bulk_ireq hdr;
	struct xfs_inumbers inumbers[0];
};

struct xfs_iread_state {
	struct xfs_iext_cursor icur;
	xfs_extnum_t loaded;
};

struct xfs_item_ops {
	unsigned int flags;
	void (*iop_size)(struct xfs_log_item *, int *, int *);
	void (*iop_format)(struct xfs_log_item *, struct xfs_log_vec *);
	void (*iop_pin)(struct xfs_log_item *);
	void (*iop_unpin)(struct xfs_log_item *, int);
	uint64_t (*iop_sort)(struct xfs_log_item *);
	int (*iop_precommit)(struct xfs_trans *, struct xfs_log_item *);
	void (*iop_committing)(struct xfs_log_item *, xfs_csn_t);
	xfs_lsn_t (*iop_committed)(struct xfs_log_item *, xfs_lsn_t);
	uint (*iop_push)(struct xfs_log_item *, struct list_head *);
	void (*iop_release)(struct xfs_log_item *);
	bool (*iop_match)(struct xfs_log_item *, uint64_t);
	struct xfs_log_item * (*iop_intent)(struct xfs_log_item *);
};

struct xfs_iunlink_item {
	struct xfs_log_item item;
	struct xfs_inode *ip;
	struct xfs_perag *pag;
	xfs_agino_t next_agino;
	xfs_agino_t old_agino;
};

struct xfs_pwork_ctl;

struct xfs_pwork {
	struct work_struct work;
	struct xfs_pwork_ctl *pctl;
};

typedef int (*xfs_iwalk_fn)(struct xfs_mount *, struct xfs_trans *, xfs_ino_t, void *);

typedef int (*xfs_inobt_walk_fn)(struct xfs_mount *, struct xfs_trans *, xfs_agnumber_t, const struct xfs_inobt_rec_incore *, void *);

struct xfs_iwalk_ag {
	struct xfs_pwork pwork;
	struct xfs_mount *mp;
	struct xfs_trans *tp;
	struct xfs_perag *pag;
	xfs_ino_t startino;
	xfs_ino_t lastino;
	struct xfs_inobt_rec_incore *recs;
	unsigned int sz_recs;
	unsigned int nr_recs;
	xfs_iwalk_fn iwalk_fn;
	xfs_inobt_walk_fn inobt_walk_fn;
	void *data;
	unsigned int trim_start: 1;
	unsigned int skip_empty: 1;
	unsigned int drop_trans: 1;
};

struct xfs_legacy_timestamp {
	__be32 t_sec;
	__be32 t_nsec;
};

struct xfs_log_dinode {
	uint16_t di_magic;
	uint16_t di_mode;
	int8_t di_version;
	int8_t di_format;
	uint16_t di_metatype;
	uint32_t di_uid;
	uint32_t di_gid;
	uint32_t di_nlink;
	uint16_t di_projid_lo;
	uint16_t di_projid_hi;
	union {
		uint64_t di_big_nextents;
		uint64_t di_v3_pad;
		struct {
			uint8_t di_v2_pad[6];
			uint16_t di_flushiter;
		};
	};
	xfs_log_timestamp_t di_atime;
	xfs_log_timestamp_t di_mtime;
	xfs_log_timestamp_t di_ctime;
	xfs_fsize_t di_size;
	xfs_rfsblock_t di_nblocks;
	xfs_extlen_t di_extsize;
	union {
		struct {
			uint32_t di_nextents;
			uint16_t di_anextents;
		} __attribute__((packed));
		struct {
			uint32_t di_big_anextents;
			uint16_t di_nrext64_pad;
		} __attribute__((packed));
	};
	uint8_t di_forkoff;
	int8_t di_aformat;
	uint32_t di_dmevmask;
	uint16_t di_dmstate;
	uint16_t di_flags;
	uint32_t di_gen;
	xfs_agino_t di_next_unlinked;
	uint32_t di_crc;
	uint64_t di_changecount;
	xfs_lsn_t di_lsn;
	uint64_t di_flags2;
	uint32_t di_cowextsize;
	uint8_t di_pad2[12];
	xfs_log_timestamp_t di_crtime;
	xfs_ino_t di_ino;
	uuid_t di_uuid;
};

typedef struct xfs_log_iovec xfs_log_iovec_t;

struct xfs_log_legacy_timestamp {
	int32_t t_sec;
	int32_t t_nsec;
};

struct xfs_log_vec {
	struct list_head lv_list;
	uint32_t lv_order_id;
	int lv_niovecs;
	struct xfs_log_iovec *lv_iovecp;
	struct xfs_log_item *lv_item;
	char *lv_buf;
	int lv_bytes;
	int lv_buf_len;
	int lv_size;
};

struct xfs_metadir_update {
	struct xfs_inode *dp;
	const char *path;
	struct xfs_parent_args *ppargs;
	struct xfs_inode *ip;
	struct xfs_trans *tp;
	enum xfs_metafile_type metafile_type;
	unsigned int dp_locked: 1;
	unsigned int ip_locked: 1;
};

struct xfs_mod_ino_dqtrx_params {
	uintptr_t tx_id;
	xfs_ino_t ino;
	xfs_dqtype_t q_type;
	xfs_dqid_t q_id;
	int64_t delta;
};

struct xfs_sb {
	uint32_t sb_magicnum;
	uint32_t sb_blocksize;
	xfs_rfsblock_t sb_dblocks;
	xfs_rfsblock_t sb_rblocks;
	xfs_rtbxlen_t sb_rextents;
	uuid_t sb_uuid;
	xfs_fsblock_t sb_logstart;
	xfs_ino_t sb_rootino;
	xfs_ino_t sb_rbmino;
	xfs_ino_t sb_rsumino;
	xfs_agblock_t sb_rextsize;
	xfs_agblock_t sb_agblocks;
	xfs_agnumber_t sb_agcount;
	xfs_extlen_t sb_rbmblocks;
	xfs_extlen_t sb_logblocks;
	uint16_t sb_versionnum;
	uint16_t sb_sectsize;
	uint16_t sb_inodesize;
	uint16_t sb_inopblock;
	char sb_fname[12];
	uint8_t sb_blocklog;
	uint8_t sb_sectlog;
	uint8_t sb_inodelog;
	uint8_t sb_inopblog;
	uint8_t sb_agblklog;
	uint8_t sb_rextslog;
	uint8_t sb_inprogress;
	uint8_t sb_imax_pct;
	uint64_t sb_icount;
	uint64_t sb_ifree;
	uint64_t sb_fdblocks;
	uint64_t sb_frextents;
	xfs_ino_t sb_uquotino;
	xfs_ino_t sb_gquotino;
	uint16_t sb_qflags;
	uint8_t sb_flags;
	uint8_t sb_shared_vn;
	xfs_extlen_t sb_inoalignmt;
	uint32_t sb_unit;
	uint32_t sb_width;
	uint8_t sb_dirblklog;
	uint8_t sb_logsectlog;
	uint16_t sb_logsectsize;
	uint32_t sb_logsunit;
	uint32_t sb_features2;
	uint32_t sb_bad_features2;
	uint32_t sb_features_compat;
	uint32_t sb_features_ro_compat;
	uint32_t sb_features_incompat;
	uint32_t sb_features_log_incompat;
	uint32_t sb_crc;
	xfs_extlen_t sb_spino_align;
	xfs_ino_t sb_pquotino;
	xfs_lsn_t sb_lsn;
	uuid_t sb_meta_uuid;
	xfs_ino_t sb_metadirino;
	xfs_rgnumber_t sb_rgcount;
	xfs_rtxlen_t sb_rgextents;
	uint8_t sb_rgblklog;
	uint8_t sb_pad[7];
};

struct xfs_trans_res {
	uint tr_logres;
	int tr_logcount;
	int tr_logflags;
};

struct xfs_trans_resv {
	struct xfs_trans_res tr_write;
	struct xfs_trans_res tr_itruncate;
	struct xfs_trans_res tr_rename;
	struct xfs_trans_res tr_link;
	struct xfs_trans_res tr_remove;
	struct xfs_trans_res tr_symlink;
	struct xfs_trans_res tr_create;
	struct xfs_trans_res tr_create_tmpfile;
	struct xfs_trans_res tr_mkdir;
	struct xfs_trans_res tr_ifree;
	struct xfs_trans_res tr_ichange;
	struct xfs_trans_res tr_growdata;
	struct xfs_trans_res tr_addafork;
	struct xfs_trans_res tr_writeid;
	struct xfs_trans_res tr_attrinval;
	struct xfs_trans_res tr_attrsetm;
	struct xfs_trans_res tr_attrsetrt;
	struct xfs_trans_res tr_attrrm;
	struct xfs_trans_res tr_clearagi;
	struct xfs_trans_res tr_growrtalloc;
	struct xfs_trans_res tr_growrtzero;
	struct xfs_trans_res tr_growrtfree;
	struct xfs_trans_res tr_qm_setqlim;
	struct xfs_trans_res tr_qm_dqalloc;
	struct xfs_trans_res tr_sb;
	struct xfs_trans_res tr_fsyncts;
};

struct xfsstats;

struct xstats {
	struct xfsstats *xs_stats;
	struct xfs_kobj xs_kobj;
};

struct xfs_quotainfo;

struct xfs_mru_cache;

struct xfs_mount {
	struct xfs_sb m_sb;
	struct super_block *m_super;
	struct xfs_ail *m_ail;
	struct xfs_buf *m_sb_bp;
	struct xfs_buf *m_rtsb_bp;
	char *m_rtname;
	char *m_logname;
	struct xfs_da_geometry *m_dir_geo;
	struct xfs_da_geometry *m_attr_geo;
	struct xlog *m_log;
	struct xfs_inode *m_rootip;
	struct xfs_inode *m_metadirip;
	struct xfs_inode *m_rtdirip;
	struct xfs_quotainfo *m_quotainfo;
	struct xfs_buftarg *m_ddev_targp;
	struct xfs_buftarg *m_logdev_targp;
	struct xfs_buftarg *m_rtdev_targp;
	void *m_inodegc;
	struct xfs_mru_cache *m_filestream;
	struct workqueue_struct *m_buf_workqueue;
	struct workqueue_struct *m_unwritten_workqueue;
	struct workqueue_struct *m_reclaim_workqueue;
	struct workqueue_struct *m_sync_workqueue;
	struct workqueue_struct *m_blockgc_wq;
	struct workqueue_struct *m_inodegc_wq;
	int m_bsize;
	uint8_t m_blkbit_log;
	uint8_t m_blkbb_log;
	uint8_t m_agno_log;
	uint8_t m_sectbb_log;
	int8_t m_rtxblklog;
	uint m_blockmask;
	uint m_blockwsize;
	unsigned int m_rtx_per_rbmblock;
	uint m_alloc_mxr[2];
	uint m_alloc_mnr[2];
	uint m_bmap_dmxr[2];
	uint m_bmap_dmnr[2];
	uint m_rmap_mxr[2];
	uint m_rmap_mnr[2];
	uint m_rtrmap_mxr[2];
	uint m_rtrmap_mnr[2];
	uint m_refc_mxr[2];
	uint m_refc_mnr[2];
	uint m_rtrefc_mxr[2];
	uint m_rtrefc_mnr[2];
	uint m_alloc_maxlevels;
	uint m_bm_maxlevels[2];
	uint m_rmap_maxlevels;
	uint m_rtrmap_maxlevels;
	uint m_refc_maxlevels;
	uint m_rtrefc_maxlevels;
	unsigned int m_agbtree_maxlevels;
	unsigned int m_rtbtree_maxlevels;
	xfs_extlen_t m_ag_prealloc_blocks;
	uint m_alloc_set_aside;
	uint m_ag_max_usable;
	int m_dalign;
	int m_swidth;
	xfs_agnumber_t m_maxagi;
	uint m_allocsize_log;
	uint m_allocsize_blocks;
	int m_logbufs;
	int m_logbsize;
	unsigned int m_rsumlevels;
	xfs_filblks_t m_rsumblocks;
	int m_fixedfsid[2];
	uint m_qflags;
	uint64_t m_features;
	uint64_t m_low_space[5];
	uint64_t m_low_rtexts[5];
	uint64_t m_rtxblkmask;
	struct xfs_ino_geometry m_ino_geo;
	struct xfs_trans_resv m_resv;
	long unsigned int m_opstate;
	bool m_always_cow;
	bool m_fail_unmount;
	bool m_finobt_nores;
	bool m_update_sb;
	uint8_t m_fs_checked;
	uint8_t m_fs_sick;
	uint8_t m_rt_checked;
	uint8_t m_rt_sick;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t m_sb_lock;
	struct percpu_counter m_icount;
	struct percpu_counter m_ifree;
	struct percpu_counter m_fdblocks;
	struct percpu_counter m_frextents;
	struct percpu_counter m_delalloc_blks;
	struct percpu_counter m_delalloc_rtextents;
	atomic64_t m_allocbt_blks;
	struct xfs_groups m_groups[2];
	uint64_t m_resblks;
	uint64_t m_resblks_avail;
	uint64_t m_resblks_save;
	struct delayed_work m_reclaim_work;
	struct dentry *m_debugfs;
	struct xfs_kobj m_kobj;
	struct xfs_kobj m_error_kobj;
	struct xfs_kobj m_error_meta_kobj;
	struct xfs_error_cfg m_error_cfg[4];
	struct xstats m_stats;
	xfs_agnumber_t m_agfrotor;
	atomic_t m_agirotor;
	atomic_t m_rtgrotor;
	struct shrinker *m_inodegc_shrinker;
	struct work_struct m_flush_inodes_work;
	uint32_t m_generation;
	struct mutex m_growlock;
	struct cpumask m_inodegc_cpumask;
	struct xfs_hooks m_dir_update_hooks;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef struct xfs_mount xfs_mount_t;

typedef void (*xfs_mru_cache_free_func_t)(void *, struct xfs_mru_cache_elem *);

struct xfs_mru_cache {
	struct xarray store;
	struct list_head *lists;
	struct list_head reap_list;
	spinlock_t lock;
	unsigned int grp_count;
	unsigned int grp_time;
	unsigned int lru_grp;
	long unsigned int time_zero;
	xfs_mru_cache_free_func_t free_func;
	struct delayed_work work;
	unsigned int queued;
	void *data;
};

struct xfs_sysctl_val {
	int min;
	int val;
	int max;
};

typedef struct xfs_sysctl_val xfs_sysctl_val_t;

struct xfs_param {
	xfs_sysctl_val_t sgid_inherit;
	xfs_sysctl_val_t symlink_mode;
	xfs_sysctl_val_t panic_mask;
	xfs_sysctl_val_t error_level;
	xfs_sysctl_val_t syncd_timer;
	xfs_sysctl_val_t stats_clear;
	xfs_sysctl_val_t inherit_sync;
	xfs_sysctl_val_t inherit_nodump;
	xfs_sysctl_val_t inherit_noatim;
	xfs_sysctl_val_t xfs_buf_timer;
	xfs_sysctl_val_t xfs_buf_age;
	xfs_sysctl_val_t inherit_nosym;
	xfs_sysctl_val_t rotorstep;
	xfs_sysctl_val_t inherit_nodfrg;
	xfs_sysctl_val_t fstrm_timer;
	xfs_sysctl_val_t blockgc_timer;
};

typedef struct xfs_param xfs_param_t;

struct xfs_perag {
	struct xfs_group pag_group;
	long unsigned int pag_opstate;
	uint8_t pagf_bno_level;
	uint8_t pagf_cnt_level;
	uint8_t pagf_rmap_level;
	uint32_t pagf_flcount;
	xfs_extlen_t pagf_freeblks;
	xfs_extlen_t pagf_longest;
	uint32_t pagf_btreeblks;
	xfs_agino_t pagi_freecount;
	xfs_agino_t pagi_count;
	xfs_agino_t pagl_pagino;
	xfs_agino_t pagl_leftrec;
	xfs_agino_t pagl_rightrec;
	uint8_t pagf_refcount_level;
	struct xfs_ag_resv pag_meta_resv;
	struct xfs_ag_resv pag_rmapbt_resv;
	xfs_agino_t agino_min;
	xfs_agino_t agino_max;
	atomic_t pagf_fstrms;
	spinlock_t pag_ici_lock;
	struct xarray pag_ici_root;
	int pag_ici_reclaimable;
	long unsigned int pag_ici_reclaim_cursor;
	struct xfs_buf_cache pag_bcache;
	struct delayed_work pag_blockgc_work;
};

typedef int (*xfs_pwork_work_fn)(struct xfs_mount *, struct xfs_pwork *);

struct xfs_pwork_ctl {
	struct workqueue_struct *wq;
	struct xfs_mount *mp;
	xfs_pwork_work_fn work_fn;
	struct wait_queue_head poll_wait;
	atomic_t nr_work;
	int error;
};

struct xfs_qm_isolate {
	struct list_head buffers;
	struct list_head dispose;
};

struct xfs_qoff_logformat {
	short unsigned int qf_type;
	short unsigned int qf_size;
	unsigned int qf_flags;
	char qf_pad[12];
};

struct xfs_quotainfo {
	struct xarray qi_uquota_tree;
	struct xarray qi_gquota_tree;
	struct xarray qi_pquota_tree;
	struct mutex qi_tree_lock;
	struct xfs_inode *qi_uquotaip;
	struct xfs_inode *qi_gquotaip;
	struct xfs_inode *qi_pquotaip;
	struct xfs_inode *qi_dirip;
	struct list_lru qi_lru;
	int qi_dquots;
	struct mutex qi_quotaofflock;
	xfs_filblks_t qi_dqchunklen;
	uint qi_dqperchunk;
	struct xfs_def_quota qi_usr_default;
	struct xfs_def_quota qi_grp_default;
	struct xfs_def_quota qi_prj_default;
	struct shrinker *qi_shrinker;
	time64_t qi_expiry_min;
	time64_t qi_expiry_max;
	struct xfs_hooks qi_mod_ino_dqtrx_hooks;
	struct xfs_hooks qi_apply_dqtrx_hooks;
};

struct xfs_refcount_intent {
	struct list_head ri_list;
	struct xfs_group *ri_group;
	enum xfs_refcount_intent_type ri_type;
	xfs_extlen_t ri_blockcount;
	xfs_fsblock_t ri_startblock;
	bool ri_realtime;
};

typedef int (*xfs_refcount_query_range_fn)(struct xfs_btree_cur *, const struct xfs_refcount_irec *, void *);

struct xfs_refcount_query_range_info {
	xfs_refcount_query_range_fn fn;
	void *priv;
};

struct xfs_refcount_recovery {
	struct list_head rr_list;
	struct xfs_refcount_irec rr_rrec;
};

struct xfs_rmap_hook {
	struct xfs_hook rmap_hook;
};

struct xfs_rmap_intent {
	struct list_head ri_list;
	enum xfs_rmap_intent_type ri_type;
	int ri_whichfork;
	uint64_t ri_owner;
	struct xfs_bmbt_irec ri_bmap;
	struct xfs_group *ri_group;
	bool ri_realtime;
};

struct xfs_rmap_matches {
	long long unsigned int matches;
	long long unsigned int non_owner_matches;
	long long unsigned int bad_non_owner_matches;
};

struct xfs_rmap_ownercount {
	struct xfs_rmap_irec good;
	struct xfs_rmap_irec low;
	struct xfs_rmap_irec high;
	struct xfs_rmap_matches *results;
	bool stop_on_nonmatch;
};

typedef int (*xfs_rmap_query_range_fn)(struct xfs_btree_cur *, const struct xfs_rmap_irec *, void *);

struct xfs_rmap_query_range_info {
	xfs_rmap_query_range_fn fn;
	void *priv;
};

struct xfs_rmap_update_params {
	xfs_agblock_t startblock;
	xfs_extlen_t blockcount;
	struct xfs_owner_info oinfo;
	bool unwritten;
};

struct xfs_rtbuf_blkinfo {
	__be32 rt_magic;
	__be32 rt_crc;
	__be64 rt_owner;
	__be64 rt_blkno;
	__be64 rt_lsn;
	uuid_t rt_uuid;
};

struct xfs_rtgroup {
	struct xfs_group rtg_group;
	struct xfs_inode *rtg_inodes[4];
	xfs_rtxnum_t rtg_extents;
	uint8_t *rtg_rsum_cache;
};

struct xfs_rtgroup_geometry {
	__u32 rg_number;
	__u32 rg_length;
	__u32 rg_sick;
	__u32 rg_checked;
	__u32 rg_flags;
	__u32 rg_reserved[27];
};

struct xfs_rtrefcount_root {
	__be16 bb_level;
	__be16 bb_numrecs;
};

struct xfs_rtrmap_root {
	__be16 bb_level;
	__be16 bb_numrecs;
};

struct xfs_rud_log_format {
	uint16_t rud_type;
	uint16_t rud_size;
	uint32_t __pad;
	uint64_t rud_rui_id;
};

struct xfs_rui_log_item;

struct xfs_rud_log_item {
	struct xfs_log_item rud_item;
	struct xfs_rui_log_item *rud_ruip;
	struct xfs_rud_log_format rud_format;
};

struct xfs_rui_log_format {
	uint16_t rui_type;
	uint16_t rui_size;
	uint32_t rui_nextents;
	uint64_t rui_id;
	struct xfs_map_extent rui_extents[0];
};

struct xfs_rui_log_item {
	struct xfs_log_item rui_item;
	atomic_t rui_refcount;
	atomic_t rui_next_extent;
	struct xfs_rui_log_format rui_format;
};

typedef struct xfs_sb xfs_sb_t;

struct xfs_scrub_metadata;

struct xfs_scrub {
	struct xfs_mount *mp;
	struct xfs_scrub_metadata *sm;
	const struct xchk_meta_ops *ops;
	struct xfs_trans *tp;
	struct file *file;
	struct xfs_inode *ip;
	void *buf;
	void (*buf_cleanup)(void *);
	struct xfile *xfile;
	struct xfs_buftarg *xmbtp;
	uint ilock_flags;
	uint orphanage_ilock_flags;
	struct xfs_inode *orphanage;
	struct xfs_inode *tempip;
	uint temp_ilock_flags;
	unsigned int flags;
	unsigned int sick_mask;
	unsigned int healthy_mask;
	struct xchk_relax relax;
	struct xchk_ag sa;
	struct xchk_rt sr;
};

struct xfs_scrub_metadata {
	__u32 sm_type;
	__u32 sm_flags;
	__u64 sm_ino;
	__u32 sm_gen;
	__u32 sm_agno;
	__u64 sm_reserved[5];
};

struct xfs_scrub_subord {
	struct xfs_scrub sc;
	struct xfs_scrub *parent_sc;
	unsigned int old_smtype;
	unsigned int old_smflags;
};

struct xfs_scrub_vec {
	__u32 sv_type;
	__u32 sv_flags;
	__s32 sv_ret;
	__u32 sv_reserved;
};

struct xfs_scrub_vec_head {
	__u64 svh_ino;
	__u32 svh_gen;
	__u32 svh_agno;
	__u32 svh_flags;
	__u16 svh_rest_us;
	__u16 svh_nr;
	__u64 svh_reserved;
	__u64 svh_vectors;
};

struct xfs_swapext {
	int64_t sx_version;
	int64_t sx_fdtarget;
	int64_t sx_fdtmp;
	xfs_off_t sx_offset;
	xfs_off_t sx_length;
	char sx_pad[16];
	struct xfs_bstat sx_stat;
};

typedef struct xfs_swapext xfs_swapext_t;

struct xfs_sysfs_attr {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, char *);
	ssize_t (*store)(struct kobject *, const char *, size_t);
};

struct xfs_trans {
	unsigned int t_log_res;
	unsigned int t_log_count;
	unsigned int t_blk_res;
	unsigned int t_blk_res_used;
	unsigned int t_rtx_res;
	unsigned int t_rtx_res_used;
	unsigned int t_flags;
	xfs_agnumber_t t_highest_agno;
	struct xlog_ticket *t_ticket;
	struct xfs_mount *t_mountp;
	struct xfs_dquot_acct *t_dqinfo;
	int64_t t_icount_delta;
	int64_t t_ifree_delta;
	int64_t t_fdblocks_delta;
	int64_t t_res_fdblocks_delta;
	int64_t t_frextents_delta;
	int64_t t_res_frextents_delta;
	int64_t t_dblocks_delta;
	int64_t t_agcount_delta;
	int64_t t_imaxpct_delta;
	int64_t t_rextsize_delta;
	int64_t t_rbmblocks_delta;
	int64_t t_rblocks_delta;
	int64_t t_rextents_delta;
	int64_t t_rextslog_delta;
	int64_t t_rgcount_delta;
	struct list_head t_items;
	struct list_head t_busy;
	struct list_head t_dfops;
	long unsigned int t_pflags;
};

typedef struct xfs_trans xfs_trans_t;

struct xfs_trans_header {
	uint th_magic;
	uint th_type;
	int32_t th_tid;
	uint th_num_items;
};

typedef struct xfs_trans_header xfs_trans_header_t;

struct xfs_trim_cur {
	xfs_agblock_t start;
	xfs_extlen_t count;
	xfs_agblock_t end;
	xfs_extlen_t minlen;
	bool by_bno;
};

struct xfs_unmount_log_format {
	uint16_t magic;
	uint16_t pad1;
	uint32_t pad2;
};

struct xfs_writepage_ctx {
	struct iomap_writepage_ctx ctx;
	unsigned int data_seq;
	unsigned int cow_seq;
};

struct xfs_xmd_log_format {
	uint16_t xmd_type;
	uint16_t xmd_size;
	uint32_t __pad;
	uint64_t xmd_xmi_id;
};

struct xfs_xmi_log_item;

struct xfs_xmd_log_item {
	struct xfs_log_item xmd_item;
	struct xfs_xmi_log_item *xmd_intent_log_item;
	struct xfs_xmd_log_format xmd_format;
};

struct xfs_xmi_log_format {
	uint16_t xmi_type;
	uint16_t xmi_size;
	uint32_t __pad;
	uint64_t xmi_id;
	uint64_t xmi_inode1;
	uint64_t xmi_inode2;
	uint32_t xmi_igen1;
	uint32_t xmi_igen2;
	uint64_t xmi_startoff1;
	uint64_t xmi_startoff2;
	uint64_t xmi_blockcount;
	uint64_t xmi_flags;
	uint64_t xmi_isize1;
	uint64_t xmi_isize2;
};

struct xfs_xmi_log_item {
	struct xfs_log_item xmi_item;
	atomic_t xmi_refcount;
	struct xfs_xmi_log_format xmi_format;
};

struct xfsstats {
	union {
		struct __xfsstats s;
		uint32_t a[262];
	};
};

struct xlog_grant_head {
	spinlock_t lock;
	struct list_head waiters;
	atomic64_t grant;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef struct xlog_in_core xlog_in_core_t;

struct xlog {
	struct xfs_mount *l_mp;
	struct xfs_ail *l_ailp;
	struct xfs_cil *l_cilp;
	struct xfs_buftarg *l_targ;
	struct workqueue_struct *l_ioend_workqueue;
	struct delayed_work l_work;
	long int l_opstate;
	uint l_quotaoffs_flag;
	struct list_head *l_buf_cancel_table;
	struct list_head r_dfops;
	int l_iclog_hsize;
	int l_iclog_heads;
	uint l_sectBBsize;
	int l_iclog_size;
	int l_iclog_bufs;
	xfs_daddr_t l_logBBstart;
	int l_logsize;
	int l_logBBsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	wait_queue_head_t l_flush_wait;
	int l_covered_state;
	xlog_in_core_t *l_iclog;
	spinlock_t l_icloglock;
	int l_curr_cycle;
	int l_prev_cycle;
	int l_curr_block;
	int l_prev_block;
	atomic64_t l_tail_lsn;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xlog_grant_head l_reserve_head;
	struct xlog_grant_head l_write_head;
	uint64_t l_tail_space;
	struct xfs_kobj l_kobj;
	xfs_lsn_t l_recovery_lsn;
	uint32_t l_iclog_roundoff;
	long: 64;
};

struct xlog_cil_pcp {
	int32_t space_used;
	uint32_t space_reserved;
	struct list_head busy_extents;
	struct list_head log_items;
};

struct xlog_op_header {
	__be32 oh_tid;
	__be32 oh_len;
	__u8 oh_clientid;
	__u8 oh_flags;
	__u16 oh_res2;
};

struct xlog_cil_trans_hdr {
	struct xlog_op_header oph[2];
	struct xfs_trans_header thdr;
	struct xfs_log_iovec lhdr[2];
};

union xlog_in_core2;

typedef union xlog_in_core2 xlog_in_core_2_t;

struct xlog_in_core {
	wait_queue_head_t ic_force_wait;
	wait_queue_head_t ic_write_wait;
	struct xlog_in_core *ic_next;
	struct xlog_in_core *ic_prev;
	struct xlog *ic_log;
	u32 ic_size;
	u32 ic_offset;
	enum xlog_iclog_state ic_state;
	unsigned int ic_flags;
	void *ic_datap;
	struct list_head ic_callbacks;
	long: 64;
	long: 64;
	atomic_t ic_refcnt;
	xlog_in_core_2_t *ic_data;
	struct semaphore ic_sema;
	struct work_struct ic_end_io_work;
	struct bio ic_bio;
	struct bio_vec ic_bvec[0];
};

struct xlog_rec_header {
	__be32 h_magicno;
	__be32 h_cycle;
	__be32 h_version;
	__be32 h_len;
	__be64 h_lsn;
	__be64 h_tail_lsn;
	__le32 h_crc;
	__be32 h_prev_block;
	__be32 h_num_logops;
	__be32 h_cycle_data[64];
	__be32 h_fmt;
	uuid_t h_fs_uuid;
	__be32 h_size;
};

typedef struct xlog_rec_header xlog_rec_header_t;

struct xlog_rec_ext_header {
	__be32 xh_cycle;
	__be32 xh_cycle_data[64];
};

typedef struct xlog_rec_ext_header xlog_rec_ext_header_t;

union xlog_in_core2 {
	xlog_rec_header_t hic_header;
	xlog_rec_ext_header_t hic_xheader;
	char hic_sector[512];
};

struct xlog_recover {
	struct hlist_node r_list;
	xlog_tid_t r_log_tid;
	xfs_trans_header_t r_theader;
	int r_state;
	xfs_lsn_t r_lsn;
	struct list_head r_itemq;
};

struct xlog_recover_item_ops;

struct xlog_recover_item {
	struct list_head ri_list;
	int ri_cnt;
	int ri_total;
	struct xfs_log_iovec *ri_buf;
	const struct xlog_recover_item_ops *ri_ops;
};

struct xlog_recover_item_ops {
	uint16_t item_type;
	enum xlog_recover_reorder (*reorder)(struct xlog_recover_item *);
	void (*ra_pass2)(struct xlog *, struct xlog_recover_item *);
	int (*commit_pass1)(struct xlog *, struct xlog_recover_item *);
	int (*commit_pass2)(struct xlog *, struct list_head *, struct xlog_recover_item *, xfs_lsn_t);
};

struct xlog_ticket {
	struct list_head t_queue;
	struct task_struct *t_task;
	xlog_tid_t t_tid;
	atomic_t t_ref;
	int t_curr_res;
	int t_unit_res;
	char t_ocnt;
	char t_cnt;
	uint8_t t_flags;
	int t_iclog_hdrs;
};

typedef struct xlog_ticket xlog_ticket_t;

struct xol_area {
	wait_queue_head_t wq;
	long unsigned int *bitmap;
	struct page *page;
	long unsigned int vaddr;
};

struct xor_block_template {
	struct xor_block_template *next;
	const char *name;
	int speed;
	void (*do_2)(long unsigned int, long unsigned int * restrict, const long unsigned int * restrict);
	void (*do_3)(long unsigned int, long unsigned int * restrict, const long unsigned int * restrict, const long unsigned int * restrict);
	void (*do_4)(long unsigned int, long unsigned int * restrict, const long unsigned int * restrict, const long unsigned int * restrict, const long unsigned int * restrict);
	void (*do_5)(long unsigned int, long unsigned int * restrict, const long unsigned int * restrict, const long unsigned int * restrict, const long unsigned int * restrict, const long unsigned int * restrict);
};

struct xprt_addr {
	const char *addr;
	struct callback_head rcu;
};

struct xprt_create;

struct xprt_class {
	struct list_head list;
	int ident;
	struct rpc_xprt * (*setup)(struct xprt_create *);
	struct module *owner;
	char name[32];
	const char *netid[0];
};

struct xprt_create {
	int ident;
	struct net *net;
	struct sockaddr *srcaddr;
	struct sockaddr *dstaddr;
	size_t addrlen;
	const char *servername;
	struct svc_xprt *bc_xprt;
	struct rpc_xprt_switch *bc_xps;
	unsigned int flags;
	struct xprtsec_parms xprtsec;
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct xps_map;

struct xps_dev_maps {
	struct callback_head rcu;
	unsigned int nr_ids;
	s16 num_tc;
	struct xps_map *attr_map[0];
};

struct xps_map {
	unsigned int len;
	unsigned int alloc_len;
	struct callback_head rcu;
	u16 queues[0];
};

struct xqcheck {
	struct xfs_scrub *sc;
	struct xfarray *ucounts;
	struct xfarray *gcounts;
	struct xfarray *pcounts;
	struct mutex lock;
	struct xchk_iscan iscan;
	struct xfs_dqtrx_hook qhook;
	struct rhashtable shadow_dquot_acct;
};

struct xqcheck_dqtrx {
	xfs_dqtype_t q_type;
	xfs_dqid_t q_id;
	int64_t icount_delta;
	int64_t bcount_delta;
	int64_t delbcnt_delta;
	int64_t rtbcount_delta;
	int64_t delrtb_delta;
};

struct xqcheck_dqacct {
	struct rhash_head hash;
	uintptr_t tx_id;
	struct xqcheck_dqtrx dqtrx[15];
	unsigned int refcount;
};

struct xqcheck_dquot {
	int64_t bcount;
	int64_t icount;
	int64_t rtbcount;
	unsigned int flags;
};

struct xsk_buff_pool {
	struct device *dev;
	struct net_device *netdev;
	struct list_head xsk_tx_list;
	spinlock_t xsk_tx_list_lock;
	refcount_t users;
	struct xdp_umem *umem;
	struct work_struct work;
	struct list_head free_list;
	struct list_head xskb_list;
	u32 heads_cnt;
	u16 queue_id;
	long: 64;
	struct xsk_queue *fq;
	struct xsk_queue *cq;
	dma_addr_t *dma_pages;
	struct xdp_buff_xsk *heads;
	struct xdp_desc *tx_descs;
	u64 chunk_mask;
	u64 addrs_cnt;
	u32 free_list_cnt;
	u32 dma_pages_cnt;
	u32 free_heads_cnt;
	u32 headroom;
	u32 chunk_size;
	u32 chunk_shift;
	u32 frame_len;
	u32 xdp_zc_max_segs;
	u8 tx_metadata_len;
	u8 cached_need_wakeup;
	bool uses_need_wakeup;
	bool unaligned;
	bool tx_sw_csum;
	void *addrs;
	spinlock_t cq_lock;
	struct xdp_buff_xsk *free_heads[0];
	long: 64;
	long: 64;
};

struct xsk_tx_metadata_ops {
	void (*tmo_request_timestamp)(void *);
	u64 (*tmo_fill_timestamp)(void *);
	void (*tmo_request_checksum)(u16, u16, void *);
	void (*tmo_request_launch_time)(u64, void *);
};

struct xstats_entry {
	char *desc;
	int endpoint;
};

struct xt_CHECKSUM_info {
	__u8 operation;
};

struct xt_DSCP_info {
	__u8 dscp;
};

struct xt_NFQ_info {
	__u16 queuenum;
};

struct xt_NFQ_info_v1 {
	__u16 queuenum;
	__u16 queues_total;
};

struct xt_NFQ_info_v2 {
	__u16 queuenum;
	__u16 queues_total;
	__u16 bypass;
};

struct xt_NFQ_info_v3 {
	__u16 queuenum;
	__u16 queues_total;
	__u16 flags;
};

struct xt_action_param {
	union {
		const struct xt_match *match;
		const struct xt_target *target;
	};
	union {
		const void *matchinfo;
		const void *targinfo;
	};
	const struct nf_hook_state *state;
	unsigned int thoff;
	u16 fragoff;
	bool hotdrop;
};

struct xt_addrtype_info {
	__u16 source;
	__u16 dest;
	__u32 invert_source;
	__u32 invert_dest;
};

struct xt_addrtype_info_v1 {
	__u16 source;
	__u16 dest;
	__u32 flags;
};

struct xt_af {
	struct mutex mutex;
	struct list_head match;
	struct list_head target;
};

struct xt_audit_info {
	__u8 type;
};

struct xt_bpf_info {
	__u16 bpf_program_num_elem;
	struct sock_filter bpf_program[64];
	struct bpf_prog *filter;
};

struct xt_bpf_info_v1 {
	__u16 mode;
	__u16 bpf_program_num_elem;
	__s32 fd;
	union {
		struct sock_filter bpf_program[64];
		char path[512];
	};
	struct bpf_prog *filter;
};

struct xt_cgroup_info_v0 {
	__u32 id;
	__u32 invert;
};

struct xt_cgroup_info_v1 {
	__u8 has_path;
	__u8 has_classid;
	__u8 invert_path;
	__u8 invert_classid;
	char path[4096];
	__u32 classid;
	void *priv;
};

struct xt_cgroup_info_v2 {
	__u8 has_path;
	__u8 has_classid;
	__u8 invert_path;
	__u8 invert_classid;
	union {
		char path[512];
		__u32 classid;
	};
	void *priv;
};

struct xt_classify_target_info {
	__u32 priority;
};

struct xt_cluster_match_info {
	__u32 total_nodes;
	__u32 node_mask;
	__u32 hash_seed;
	__u32 flags;
};

struct xt_connbytes_info {
	struct {
		__u64 from;
		__u64 to;
	} count;
	__u8 what;
	__u8 direction;
};

struct xt_connlabel_mtinfo {
	__u16 bit;
	__u16 options;
};

struct xt_connlimit_info {
	union {
		union nf_inet_addr mask;
	};
	unsigned int limit;
	__u32 flags;
	struct nf_conncount_data *data;
};

struct xt_connmark_mtinfo1 {
	__u32 mark;
	__u32 mask;
	__u8 invert;
};

struct xt_connmark_tginfo1 {
	__u32 ctmark;
	__u32 ctmask;
	__u32 nfmask;
	__u8 mode;
};

struct xt_connmark_tginfo2 {
	__u32 ctmark;
	__u32 ctmask;
	__u32 nfmask;
	__u8 shift_dir;
	__u8 shift_bits;
	__u8 mode;
};

struct xt_connsecmark_target_info {
	__u8 mode;
};

struct xt_conntrack_mtinfo1 {
	union nf_inet_addr origsrc_addr;
	union nf_inet_addr origsrc_mask;
	union nf_inet_addr origdst_addr;
	union nf_inet_addr origdst_mask;
	union nf_inet_addr replsrc_addr;
	union nf_inet_addr replsrc_mask;
	union nf_inet_addr repldst_addr;
	union nf_inet_addr repldst_mask;
	__u32 expires_min;
	__u32 expires_max;
	__u16 l4proto;
	__be16 origsrc_port;
	__be16 origdst_port;
	__be16 replsrc_port;
	__be16 repldst_port;
	__u16 match_flags;
	__u16 invert_flags;
	__u8 state_mask;
	__u8 status_mask;
};

struct xt_conntrack_mtinfo2 {
	union nf_inet_addr origsrc_addr;
	union nf_inet_addr origsrc_mask;
	union nf_inet_addr origdst_addr;
	union nf_inet_addr origdst_mask;
	union nf_inet_addr replsrc_addr;
	union nf_inet_addr replsrc_mask;
	union nf_inet_addr repldst_addr;
	union nf_inet_addr repldst_mask;
	__u32 expires_min;
	__u32 expires_max;
	__u16 l4proto;
	__be16 origsrc_port;
	__be16 origdst_port;
	__be16 replsrc_port;
	__be16 repldst_port;
	__u16 match_flags;
	__u16 invert_flags;
	__u16 state_mask;
	__u16 status_mask;
};

struct xt_conntrack_mtinfo3 {
	union nf_inet_addr origsrc_addr;
	union nf_inet_addr origsrc_mask;
	union nf_inet_addr origdst_addr;
	union nf_inet_addr origdst_mask;
	union nf_inet_addr replsrc_addr;
	union nf_inet_addr replsrc_mask;
	union nf_inet_addr repldst_addr;
	union nf_inet_addr repldst_mask;
	__u32 expires_min;
	__u32 expires_max;
	__u16 l4proto;
	__u16 origsrc_port;
	__u16 origdst_port;
	__u16 replsrc_port;
	__u16 repldst_port;
	__u16 match_flags;
	__u16 invert_flags;
	__u16 state_mask;
	__u16 status_mask;
	__u16 origsrc_port_high;
	__u16 origdst_port_high;
	__u16 replsrc_port_high;
	__u16 repldst_port_high;
};

struct xt_counters_info {
	char name[32];
	unsigned int num_counters;
	struct xt_counters counters[0];
};

struct xt_cpu_info {
	__u32 cpu;
	__u32 invert;
};

struct xt_ct_target_info {
	__u16 flags;
	__u16 zone;
	__u32 ct_events;
	__u32 exp_events;
	char helper[16];
	struct nf_conn *ct;
};

struct xt_ct_target_info_v1 {
	__u16 flags;
	__u16 zone;
	__u32 ct_events;
	__u32 exp_events;
	char helper[16];
	char timeout[32];
	struct nf_conn *ct;
};

struct xt_dccp_info {
	__u16 dpts[2];
	__u16 spts[2];
	__u16 flags;
	__u16 invflags;
	__u16 typemask;
	__u8 option;
};

struct xt_devgroup_info {
	__u32 flags;
	__u32 src_group;
	__u32 src_mask;
	__u32 dst_group;
	__u32 dst_mask;
};

struct xt_dscp_info {
	__u8 dscp;
	__u8 invert;
};

struct xt_ecn_info {
	__u8 operation;
	__u8 invert;
	__u8 ip_ect;
	union {
		struct {
			__u8 ect;
		} tcp;
	} proto;
};

struct xt_entry_match {
	union {
		struct {
			__u16 match_size;
			char name[29];
			__u8 revision;
		} user;
		struct {
			__u16 match_size;
			struct xt_match *match;
		} kernel;
		__u16 match_size;
	} u;
	unsigned char data[0];
};

struct xt_esp {
	__u32 spis[2];
	__u8 invflags;
};

struct xt_get_revision {
	char name[29];
	__u8 revision;
};

struct xt_hashlimit_htable {
	struct hlist_node node;
	refcount_t use;
	u_int8_t family;
	bool rnd_initialized;
	struct hashlimit_cfg3 cfg;
	spinlock_t lock;
	u_int32_t rnd;
	unsigned int count;
	struct delayed_work gc_work;
	struct proc_dir_entry *pde;
	const char *name;
	struct net *net;
	struct hlist_head hash[0];
};

struct xt_hashlimit_mtinfo1 {
	char name[16];
	struct hashlimit_cfg1 cfg;
	struct xt_hashlimit_htable *hinfo;
};

struct xt_hashlimit_mtinfo2 {
	char name[255];
	struct hashlimit_cfg2 cfg;
	struct xt_hashlimit_htable *hinfo;
};

struct xt_hashlimit_mtinfo3 {
	char name[255];
	struct hashlimit_cfg3 cfg;
	struct xt_hashlimit_htable *hinfo;
};

struct xt_helper_info {
	int invert;
	char name[30];
};

struct xt_hmark_info {
	union nf_inet_addr src_mask;
	union nf_inet_addr dst_mask;
	union hmark_ports port_mask;
	union hmark_ports port_set;
	__u32 flags;
	__u16 proto_mask;
	__u32 hashrnd;
	__u32 hmodulus;
	__u32 hoffset;
};

struct xt_ipcomp {
	__u32 spis[2];
	__u8 invflags;
	__u8 hdrres;
};

struct xt_iprange_mtinfo {
	union nf_inet_addr src_min;
	union nf_inet_addr src_max;
	union nf_inet_addr dst_min;
	union nf_inet_addr dst_max;
	__u8 flags;
};

struct xt_l2tp_info {
	__u32 tid;
	__u32 sid;
	__u8 version;
	__u8 type;
	__u8 flags;
};

struct xt_led_info {
	char id[27];
	__u8 always_blink;
	__u32 delay;
	void *internal_data;
};

struct xt_led_info_internal {
	struct list_head list;
	int refcnt;
	char *trigger_id;
	struct led_trigger netfilter_led_trigger;
	struct timer_list timer;
};

struct xt_length_info {
	__u16 min;
	__u16 max;
	__u8 invert;
};

struct xt_limit_priv {
	long unsigned int prev;
	u32 credit;
};

struct xt_log_info {
	unsigned char level;
	unsigned char logflags;
	char prefix[30];
};

struct xt_mac_info {
	unsigned char srcaddr[6];
	int invert;
};

struct xt_mark_mtinfo1 {
	__u32 mark;
	__u32 mask;
	__u8 invert;
};

struct xt_mark_tginfo2 {
	__u32 mark;
	__u32 mask;
};

struct xt_mtchk_param;

struct xt_mtdtor_param;

struct xt_match {
	struct list_head list;
	const char name[29];
	u_int8_t revision;
	bool (*match)(const struct sk_buff *, struct xt_action_param *);
	int (*checkentry)(const struct xt_mtchk_param *);
	void (*destroy)(const struct xt_mtdtor_param *);
	struct module *me;
	const char *table;
	unsigned int matchsize;
	unsigned int usersize;
	unsigned int hooks;
	short unsigned int proto;
	short unsigned int family;
};

struct xt_mtchk_param {
	struct net *net;
	const char *table;
	const void *entryinfo;
	const struct xt_match *match;
	void *matchinfo;
	unsigned int hook_mask;
	u_int8_t family;
	bool nft_compat;
};

struct xt_mtdtor_param {
	struct net *net;
	const struct xt_match *match;
	void *matchinfo;
	u_int8_t family;
};

struct xt_multiport_v1 {
	__u8 flags;
	__u8 count;
	__u16 ports[15];
	__u8 pflags[15];
	__u8 invert;
};

struct xt_nfacct_match_info {
	char name[32];
	struct nf_acct *nfacct;
};

struct xt_nflog_info {
	__u32 len;
	__u16 group;
	__u16 threshold;
	__u16 flags;
	__u16 pad;
	char prefix[64];
};

struct xt_owner_match_info {
	__u32 uid_min;
	__u32 uid_max;
	__u32 gid_min;
	__u32 gid_max;
	__u8 match;
	__u8 invert;
};

struct xt_percpu_counter_alloc_state {
	unsigned int off;
	const char *mem;
};

struct xt_pernet {
	struct list_head tables[11];
};

struct xt_physdev_info {
	char physindev[16];
	char in_mask[16];
	char physoutdev[16];
	char out_mask[16];
	__u8 invert;
	__u8 bitmask;
};

struct xt_pkttype_info {
	int pkttype;
	int invert;
};

struct xt_policy_spec {
	__u8 saddr: 1;
	__u8 daddr: 1;
	__u8 proto: 1;
	__u8 mode: 1;
	__u8 spi: 1;
	__u8 reqid: 1;
};

struct xt_policy_elem {
	union {
		struct {
			union nf_inet_addr saddr;
			union nf_inet_addr smask;
			union nf_inet_addr daddr;
			union nf_inet_addr dmask;
		};
	};
	__be32 spi;
	__u32 reqid;
	__u8 proto;
	__u8 mode;
	struct xt_policy_spec match;
	struct xt_policy_spec invert;
};

struct xt_policy_info {
	struct xt_policy_elem pol[4];
	__u16 flags;
	__u16 len;
};

struct xt_quota_priv;

struct xt_quota_info {
	__u32 flags;
	__u32 pad;
	__u64 quota;
	struct xt_quota_priv *master;
};

struct xt_quota_priv {
	spinlock_t lock;
	uint64_t quota;
};

struct xt_rateest {
	struct gnet_stats_basic_sync bstats;
	spinlock_t lock;
	unsigned int refcnt;
	struct hlist_node list;
	char name[16];
	struct gnet_estimator params;
	struct callback_head rcu;
	struct net_rate_estimator *rate_est;
	long: 64;
};

struct xt_rateest_match_info {
	char name1[16];
	char name2[16];
	__u16 flags;
	__u16 mode;
	__u32 bps1;
	__u32 pps1;
	__u32 bps2;
	__u32 pps2;
	struct xt_rateest *est1;
	struct xt_rateest *est2;
};

struct xt_rateest_net {
	struct mutex hash_lock;
	struct hlist_head hash[16];
};

struct xt_rateest_target_info {
	char name[16];
	__s8 interval;
	__u8 ewma_log;
	struct xt_rateest *est;
};

struct xt_rateinfo {
	__u32 avg;
	__u32 burst;
	long unsigned int prev;
	__u32 credit;
	__u32 credit_cap;
	__u32 cost;
	struct xt_limit_priv *master;
};

struct xt_realm_info {
	__u32 id;
	__u32 mask;
	__u8 invert;
};

struct xt_recent_mtinfo_v1 {
	__u32 seconds;
	__u32 hit_count;
	__u8 check_set;
	__u8 invert;
	char name[200];
	__u8 side;
	union nf_inet_addr mask;
};

struct xt_rpfilter_info {
	__u8 flags;
};

struct xt_sctp_flag_info {
	__u8 chunktype;
	__u8 flag;
	__u8 flag_mask;
};

struct xt_sctp_info {
	__u16 dpts[2];
	__u16 spts[2];
	__u32 chunkmap[64];
	__u32 chunk_match_type;
	struct xt_sctp_flag_info flag_info[4];
	int flag_count;
	__u32 flags;
	__u32 invflags;
};

struct xt_secmark_target_info {
	__u8 mode;
	__u32 secid;
	char secctx[256];
};

struct xt_secmark_target_info_v1 {
	__u8 mode;
	char secctx[256];
	__u32 secid;
};

struct xt_set_info {
	ip_set_id_t index;
	__u8 dim;
	__u8 flags;
};

struct xt_socket_mtinfo1 {
	__u8 flags;
};

struct xt_socket_mtinfo2 {
	__u8 flags;
};

struct xt_socket_mtinfo3 {
	__u8 flags;
};

struct xt_state_info {
	unsigned int statemask;
};

struct xt_statistic_priv;

struct xt_statistic_info {
	__u16 mode;
	__u16 flags;
	union {
		struct {
			__u32 probability;
		} random;
		struct {
			__u32 every;
			__u32 packet;
			__u32 count;
		} nth;
	} u;
	struct xt_statistic_priv *master;
};

struct xt_statistic_priv {
	atomic_t count;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xt_string_info {
	__u16 from_offset;
	__u16 to_offset;
	char algo[16];
	char pattern[128];
	__u8 patlen;
	union {
		struct {
			__u8 invert;
		} v0;
		struct {
			__u8 flags;
		} v1;
	} u;
	struct ts_config *config;
};

struct xt_table_info;

struct xt_table {
	struct list_head list;
	unsigned int valid_hooks;
	struct xt_table_info *private;
	struct nf_hook_ops *ops;
	struct module *me;
	u_int8_t af;
	int priority;
	const char name[32];
};

struct xt_table_info {
	unsigned int size;
	unsigned int number;
	unsigned int initial_entries;
	unsigned int hook_entry[5];
	unsigned int underflow[5];
	unsigned int stacksize;
	void ***jumpstack;
	unsigned char entries[0];
};

struct xt_tgchk_param;

struct xt_tgdtor_param;

struct xt_target {
	struct list_head list;
	const char name[29];
	u_int8_t revision;
	unsigned int (*target)(struct sk_buff *, const struct xt_action_param *);
	int (*checkentry)(const struct xt_tgchk_param *);
	void (*destroy)(const struct xt_tgdtor_param *);
	struct module *me;
	const char *table;
	unsigned int targetsize;
	unsigned int usersize;
	unsigned int hooks;
	short unsigned int proto;
	short unsigned int family;
};

struct xt_tcp {
	__u16 spts[2];
	__u16 dpts[2];
	__u8 option;
	__u8 flg_mask;
	__u8 flg_cmp;
	__u8 invflags;
};

struct xt_tcpmss_info {
	__u16 mss;
};

struct xt_tcpmss_match_info {
	__u16 mss_min;
	__u16 mss_max;
	__u8 invert;
};

struct xt_tcpoptstrip_target_info {
	__u32 strip_bmap[8];
};

struct xt_tee_tginfo;

struct xt_tee_priv {
	struct list_head list;
	struct xt_tee_tginfo *tginfo;
	int oif;
};

struct xt_tee_tginfo {
	union nf_inet_addr gw;
	char oif[16];
	struct xt_tee_priv *priv;
};

struct xt_template {
	struct list_head list;
	int (*table_init)(struct net *);
	struct module *me;
	char name[32];
};

struct xt_tgchk_param {
	struct net *net;
	const char *table;
	const void *entryinfo;
	const struct xt_target *target;
	void *targinfo;
	unsigned int hook_mask;
	u_int8_t family;
	bool nft_compat;
};

struct xt_tgdtor_param {
	struct net *net;
	const struct xt_target *target;
	void *targinfo;
	u_int8_t family;
};

struct xt_time_info {
	__u32 date_start;
	__u32 date_stop;
	__u32 daytime_start;
	__u32 daytime_stop;
	__u32 monthdays_match;
	__u8 weekdays_match;
	__u8 flags;
};

struct xt_tos_match_info {
	__u8 tos_mask;
	__u8 tos_value;
	__u8 invert;
};

struct xt_tos_target_info {
	__u8 tos_value;
	__u8 tos_mask;
};

struct xt_tproxy_target_info {
	__u32 mark_mask;
	__u32 mark_value;
	__be32 laddr;
	__be16 lport;
};

struct xt_tproxy_target_info_v1 {
	__u32 mark_mask;
	__u32 mark_value;
	union nf_inet_addr laddr;
	__be16 lport;
};

struct xt_u32_location_element {
	__u32 number;
	__u8 nextop;
};

struct xt_u32_value_element {
	__u32 min;
	__u32 max;
};

struct xt_u32_test {
	struct xt_u32_location_element location[11];
	struct xt_u32_value_element value[11];
	__u8 nnums;
	__u8 nvalues;
};

struct xt_u32 {
	struct xt_u32_test tests[11];
	__u8 ntests;
	__u8 invert;
};

struct xt_udp {
	__u16 spts[2];
	__u16 dpts[2];
	__u8 invflags;
};

struct xtm {
	u_int8_t month;
	u_int8_t monthday;
	u_int8_t weekday;
	u_int8_t hour;
	u_int8_t minute;
	u_int8_t second;
	unsigned int dse;
};

struct xxh32_state {
	uint32_t total_len_32;
	uint32_t large_len;
	uint32_t v1;
	uint32_t v2;
	uint32_t v3;
	uint32_t v4;
	uint32_t mem32[4];
	uint32_t memsize;
};

struct xxhash64_desc_ctx {
	struct xxh64_state xxhstate;
};

struct xxhash64_tfm_ctx {
	u64 seed;
};

struct xz_buf {
	const uint8_t *in;
	size_t in_pos;
	size_t in_size;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
};

struct xz_dec_hash {
	vli_type unpadded;
	vli_type uncompressed;
	uint32_t crc32;
};

struct xz_dec_lzma2;

struct xz_dec_bcj;

struct xz_dec {
	enum {
		SEQ_STREAM_HEADER = 0,
		SEQ_BLOCK_START = 1,
		SEQ_BLOCK_HEADER = 2,
		SEQ_BLOCK_UNCOMPRESS = 3,
		SEQ_BLOCK_PADDING = 4,
		SEQ_BLOCK_CHECK = 5,
		SEQ_INDEX = 6,
		SEQ_INDEX_PADDING = 7,
		SEQ_INDEX_CRC32 = 8,
		SEQ_STREAM_FOOTER = 9,
	} sequence;
	uint32_t pos;
	vli_type vli;
	size_t in_start;
	size_t out_start;
	uint32_t crc32;
	enum xz_check check_type;
	enum xz_mode mode;
	bool allow_buf_error;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		uint32_t size;
	} block_header;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		vli_type count;
		struct xz_dec_hash hash;
	} block;
	struct {
		enum {
			SEQ_INDEX_COUNT = 0,
			SEQ_INDEX_UNPADDED = 1,
			SEQ_INDEX_UNCOMPRESSED = 2,
		} sequence;
		vli_type size;
		vli_type count;
		struct xz_dec_hash hash;
	} index;
	struct {
		size_t pos;
		size_t size;
		uint8_t buf[1024];
	} temp;
	struct xz_dec_lzma2 *lzma2;
	struct xz_dec_bcj *bcj;
	bool bcj_active;
};

struct xz_dec_bcj {
	enum {
		BCJ_X86 = 4,
		BCJ_POWERPC = 5,
		BCJ_IA64 = 6,
		BCJ_ARM = 7,
		BCJ_ARMTHUMB = 8,
		BCJ_SPARC = 9,
		BCJ_ARM64 = 10,
		BCJ_RISCV = 11,
	} type;
	enum xz_ret ret;
	bool single_call;
	uint32_t pos;
	uint32_t x86_prev_mask;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
	struct {
		size_t filtered;
		size_t size;
		uint8_t buf[16];
	} temp;
};

struct xz_dec_lzma2 {
	struct rc_dec rc;
	struct dictionary dict;
	struct lzma2_dec lzma2;
	struct lzma_dec lzma;
	struct {
		uint32_t size;
		uint8_t buf[63];
	} temp;
};

struct yeah {
	struct vegas vegas;
	u32 lastQ;
	u32 doing_reno_now;
	u32 reno_count;
	u32 fast_count;
};

struct yenta_socket {
	struct pci_dev *dev;
	int cb_irq;
	int io_irq;
	void *base;
	struct timer_list poll_timer;
	struct pcmcia_socket socket;
	struct cardbus_type *type;
	u32 flags;
	unsigned int probe_status;
	unsigned int private[8];
	u32 saved_state[2];
};

struct zap_details {
	struct folio *single_folio;
	bool even_cows;
	bool reclaim_pt;
	zap_flags_t zap_flags;
};

union zen_patch_rev {
	struct {
		__u32 rev: 8;
		__u32 stepping: 4;
		__u32 model: 4;
		__u32 __reserved: 4;
		__u32 ext_model: 4;
		__u32 ext_fam: 8;
	};
	__u32 ucode_rev;
};

struct zone_device {
	int cpu;
	bool work_scheduled;
	u32 msr_pkg_therm_low;
	u32 msr_pkg_therm_high;
	struct delayed_work work;
	struct thermal_zone_device *tzone;
	struct cpumask cpumask;
};

struct zstd_ctx {
	zstd_cctx *cctx;
	zstd_dctx *dctx;
	void *cwksp;
	void *dwksp;
};

struct zstd_workspace_manager {
	const struct btrfs_compress_op *ops;
	spinlock_t lock;
	struct list_head lru_list;
	struct list_head idle_ws[15];
	long unsigned int active_map;
	wait_queue_head_t wait;
	struct timer_list timer;
};

typedef size_t (*ZSTD_blockCompressor)(ZSTD_matchState_t *, seqStore_t *, U32 *, const void *, size_t);

typedef U32 (*ZSTD_getAllMatchesFn)(ZSTD_match_t *, ZSTD_matchState_t *, U32 *, const BYTE *, const BYTE *, const U32 *, const U32, const U32);

typedef size_t (*ZSTD_sequenceCopier)(ZSTD_CCtx *, ZSTD_sequencePosition *, const ZSTD_Sequence * const, size_t, const void *, size_t);

typedef acpi_status (*acpi_exception_handler)(acpi_status, acpi_name, u16, u32, void *);

typedef acpi_status (*acpi_execute_op)(struct acpi_walk_state *);

typedef void (*acpi_gbl_event_handler)(u32, acpi_handle, u32, void *);

typedef acpi_status (*acpi_gpe_callback)(struct acpi_gpe_xrupt_info *, struct acpi_gpe_block_info *, void *);

typedef acpi_status (*acpi_init_handler)(acpi_handle, u32);

typedef u32 (*acpi_interface_handler)(acpi_string, u32);

typedef u32 (*acpi_osd_handler)(void *);

typedef acpi_status (*acpi_pkg_callback)(u8, union acpi_operand_object *, union acpi_generic_state *, void *);

typedef acpi_status (*acpi_table_handler)(u32, void *, void *);

typedef acpi_status (*acpi_walk_aml_callback)(u8 *, u32, u32, u8, void **);

typedef acpi_status (*acpi_walk_resource_callback)(struct acpi_resource *, void *);

typedef void amd_pmu_branch_reset_t(void);

typedef int (*arch_set_vga_state_t)(struct pci_dev *, bool, unsigned int, u32);

typedef struct iommufd_hw_pagetable * (*attach_fn)(struct iommufd_device *, struct iommufd_hw_pagetable *);

typedef void (*b_release)(struct dm_buffer *);

typedef u32 (*batadv_hashdata_choose_cb)(const void *, u32);

typedef bool (*batadv_hashdata_compare_cb)(const struct hlist_node *, const void *);

typedef void (*blake2b_compress_t)(struct blake2b_state *, const u8 *, size_t, u32);

typedef void blk_log_action_t(struct trace_iterator *, const char *, bool);

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);

typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);

typedef long unsigned int (*bpf_ctx_copy_t)(void *, const void *, long unsigned int, long unsigned int);

typedef unsigned int (*bpf_dispatcher_fn)(const void *, const struct bpf_insn *, unsigned int (*)(const void *, const struct bpf_insn *));

typedef unsigned int (*bpf_func_t)(const void *, const struct bpf_insn *);

typedef void (*bpf_jit_fill_hole_t)(void *, unsigned int);

typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);

typedef u32 (*bpf_prog_run_fn)(const struct bpf_prog *, const void *);

typedef u64 (*bpf_trampoline_enter_t)(struct bpf_prog *, struct bpf_tramp_run_ctx *);

typedef void (*bpf_trampoline_exit_t)(struct bpf_prog *, u64, struct bpf_tramp_run_ctx *);

typedef u64 (*btf_bpf_bind)(struct bpf_sock_addr_kern *, struct sockaddr *, int);

typedef u64 (*btf_bpf_bprm_opts_set)(struct linux_binprm *, u64);

typedef u64 (*btf_bpf_btf_find_by_name_kind)(char *, int, u32, int);

typedef u64 (*btf_bpf_cgrp_storage_delete)(struct bpf_map *, struct cgroup *);

typedef u64 (*btf_bpf_cgrp_storage_get)(struct bpf_map *, struct cgroup *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_clone_redirect)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_copy_from_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_copy_from_user_task)(void *, u32, const void *, struct task_struct *, u64);

typedef u64 (*btf_bpf_csum_diff)(__be32 *, u32, __be32 *, u32, __wsum);

typedef u64 (*btf_bpf_csum_level)(struct sk_buff *, u64);

typedef u64 (*btf_bpf_csum_update)(struct sk_buff *, __wsum);

typedef u64 (*btf_bpf_current_task_under_cgroup)(struct bpf_map *, u32);

typedef u64 (*btf_bpf_d_path)(struct path *, char *, u32);

typedef u64 (*btf_bpf_dynptr_data)(const struct bpf_dynptr_kern *, u32, u32);

typedef u64 (*btf_bpf_dynptr_from_mem)(void *, u32, u64, struct bpf_dynptr_kern *);

typedef u64 (*btf_bpf_dynptr_read)(void *, u32, const struct bpf_dynptr_kern *, u32, u64);

typedef u64 (*btf_bpf_dynptr_write)(const struct bpf_dynptr_kern *, u32, void *, u32, u64);

typedef u64 (*btf_bpf_event_output_data)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_find_vma)(struct task_struct *, u64, bpf_callback_t, void *, u64);

typedef u64 (*btf_bpf_flow_dissector_load_bytes)(const struct bpf_flow_dissector *, u32, void *, u32);

typedef u64 (*btf_bpf_for_each_map_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_get_attach_cookie)(void *);

typedef u64 (*btf_bpf_get_attach_cookie_kprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_attach_cookie_pe)(struct bpf_perf_event_data_kern *);

typedef u64 (*btf_bpf_get_attach_cookie_trace)(void *);

typedef u64 (*btf_bpf_get_attach_cookie_tracing)(void *);

typedef u64 (*btf_bpf_get_attach_cookie_uprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_branch_snapshot)(void *, u32, u64);

typedef u64 (*btf_bpf_get_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_cgroup_classid_curr)(void);

typedef u64 (*btf_bpf_get_current_ancestor_cgroup_id)(int);

typedef u64 (*btf_bpf_get_current_cgroup_id)(void);

typedef u64 (*btf_bpf_get_current_comm)(char *, u32);

typedef u64 (*btf_bpf_get_current_pid_tgid)(void);

typedef u64 (*btf_bpf_get_current_task)(void);

typedef u64 (*btf_bpf_get_current_task_btf)(void);

typedef u64 (*btf_bpf_get_current_uid_gid)(void);

typedef u64 (*btf_bpf_get_func_ip_kprobe)(struct pt_regs *);

typedef u64 (*btf_bpf_get_func_ip_kprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_func_ip_tracing)(void *);

typedef u64 (*btf_bpf_get_func_ip_uprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_hash_recalc)(struct sk_buff *);

typedef u64 (*btf_bpf_get_listener_sock)(struct sock *);

typedef u64 (*btf_bpf_get_local_storage)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_netns_cookie)(struct sk_buff *);

typedef u64 (*btf_bpf_get_netns_cookie_sk_msg)(struct sk_msg *);

typedef u64 (*btf_bpf_get_netns_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sockopt)(struct bpf_sockopt_kern *);

typedef u64 (*btf_bpf_get_ns_current_pid_tgid)(u64, u64, struct bpf_pidns_info *, u32);

typedef u64 (*btf_bpf_get_numa_node_id)(void);

typedef u64 (*btf_bpf_get_raw_cpu_id)(void);

typedef u64 (*btf_bpf_get_retval)(void);

typedef u64 (*btf_bpf_get_route_realm)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_smp_processor_id)(void);

typedef u64 (*btf_bpf_get_socket_cookie)(struct sk_buff *);

typedef u64 (*btf_bpf_get_socket_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_socket_ptr_cookie)(struct sock *);

typedef u64 (*btf_bpf_get_socket_uid)(struct sk_buff *);

typedef u64 (*btf_bpf_get_stack)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_pe)(struct bpf_perf_event_data_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_raw_tp)(struct bpf_raw_tracepoint_args *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_sleepable)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_tp)(void *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stackid)(struct pt_regs *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_pe)(struct bpf_perf_event_data_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_tp)(void *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_task_stack)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_get_task_stack_sleepable)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_ima_file_hash)(struct file *, void *, u32);

typedef u64 (*btf_bpf_ima_inode_hash)(struct inode *, void *, u32);

typedef u64 (*btf_bpf_inode_storage_delete)(struct bpf_map *, struct inode *);

typedef u64 (*btf_bpf_inode_storage_get)(struct bpf_map *, struct inode *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_jiffies64)(void);

typedef u64 (*btf_bpf_kallsyms_lookup_name)(const char *, int, int, u64 *);

typedef u64 (*btf_bpf_kptr_xchg)(void *, void *);

typedef u64 (*btf_bpf_ktime_get_boot_ns)(void);

typedef u64 (*btf_bpf_ktime_get_coarse_ns)(void);

typedef u64 (*btf_bpf_ktime_get_ns)(void);

typedef u64 (*btf_bpf_ktime_get_tai_ns)(void);

typedef u64 (*btf_bpf_l3_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_l4_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_loop)(u32, void *, void *, u64);

typedef u64 (*btf_bpf_lwt_in_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_action)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_seg6_adjust_srh)(struct sk_buff *, u32, s32);

typedef u64 (*btf_bpf_lwt_seg6_store_bytes)(struct sk_buff *, u32, const void *, u32);

typedef u64 (*btf_bpf_lwt_xmit_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_map_delete_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_lookup_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_lookup_percpu_elem)(struct bpf_map *, void *, u32);

typedef u64 (*btf_bpf_map_peek_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_pop_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_push_elem)(struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_map_update_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_msg_apply_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_cork_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_pop_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_pull_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_push_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_redirect_hash)(struct sk_msg *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_msg_redirect_map)(struct sk_msg *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_per_cpu_ptr)(const void *, u32);

typedef u64 (*btf_bpf_perf_event_output)(struct pt_regs *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_perf_event_output_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_perf_event_output_tp)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_perf_event_read)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_perf_event_read_value)(struct bpf_map *, u64, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_perf_prog_read_value)(struct bpf_perf_event_data_kern *, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_probe_read_compat)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_user_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_write_user)(void *, const void *, u32);

typedef u64 (*btf_bpf_read_branch_records)(struct bpf_perf_event_data_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_redirect)(u32, u64);

typedef u64 (*btf_bpf_redirect_neigh)(u32, struct bpf_redir_neigh *, int, u64);

typedef u64 (*btf_bpf_redirect_peer)(u32, u64);

typedef u64 (*btf_bpf_ringbuf_discard)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_discard_dynptr)(struct bpf_dynptr_kern *, u64);

typedef u64 (*btf_bpf_ringbuf_output)(struct bpf_map *, void *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_query)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_ringbuf_reserve)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_reserve_dynptr)(struct bpf_map *, u32, u64, struct bpf_dynptr_kern *);

typedef u64 (*btf_bpf_ringbuf_submit)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_submit_dynptr)(struct bpf_dynptr_kern *, u64);

typedef u64 (*btf_bpf_send_signal)(u32);

typedef u64 (*btf_bpf_send_signal_thread)(u32);

typedef u64 (*btf_bpf_seq_printf)(struct seq_file *, char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_printf_btf)(struct seq_file *, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_seq_write)(struct seq_file *, const void *, u32);

typedef u64 (*btf_bpf_set_hash)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_set_hash_invalid)(struct sk_buff *);

typedef u64 (*btf_bpf_set_retval)(int);

typedef u64 (*btf_bpf_sk_ancestor_cgroup_id)(struct sock *, int);

typedef u64 (*btf_bpf_sk_assign)(struct sk_buff *, struct sock *, u64);

typedef u64 (*btf_bpf_sk_cgroup_id)(struct sock *);

typedef u64 (*btf_bpf_sk_fullsock)(struct sock *);

typedef u64 (*btf_bpf_sk_getsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_sk_lookup_assign)(struct bpf_sk_lookup_kern *, struct sock *, u64);

typedef u64 (*btf_bpf_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_redirect_hash)(struct sk_buff *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_map)(struct sk_buff *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_sk_release)(struct sock *);

typedef u64 (*btf_bpf_sk_setsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_sk_storage_delete)(struct bpf_map *, struct sock *);

typedef u64 (*btf_bpf_sk_storage_delete_tracing)(struct bpf_map *, struct sock *);

typedef u64 (*btf_bpf_sk_storage_get)(struct bpf_map *, struct sock *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_sk_storage_get_tracing)(struct bpf_map *, struct sock *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_ancestor_cgroup_id)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_skb_cgroup_id)(const struct sk_buff *);

typedef u64 (*btf_bpf_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_proto)(struct sk_buff *, __be16, u64);

typedef u64 (*btf_bpf_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_type)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_check_mtu)(struct sk_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_skb_ecn_set_ce)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_event_output)(struct sk_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_skb_fib_lookup)(struct sk_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_get_nlattr)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_nlattr_nest)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_pay_offset)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_get_tunnel_key)(struct sk_buff *, struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_opt)(struct sk_buff *, u8 *, u32);

typedef u64 (*btf_bpf_skb_get_xfrm_state)(struct sk_buff *, u32, struct bpf_xfrm_state *, u32, u64);

typedef u64 (*btf_bpf_skb_load_bytes)(const struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_skb_load_bytes_relative)(const struct sk_buff *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_skb_load_helper_16)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_16_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_32)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_32_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_8)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_8_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_set_tstamp)(struct sk_buff *, u64, u32);

typedef u64 (*btf_bpf_skb_set_tunnel_key)(struct sk_buff *, const struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tunnel_opt)(struct sk_buff *, const u8 *, u32);

typedef u64 (*btf_bpf_skb_store_bytes)(struct sk_buff *, u32, const void *, u32, u64);

typedef u64 (*btf_bpf_skb_under_cgroup)(struct sk_buff *, struct bpf_map *, u32);

typedef u64 (*btf_bpf_skb_vlan_pop)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_vlan_push)(struct sk_buff *, __be16, u16);

typedef u64 (*btf_bpf_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_skc_to_mptcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_request_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_timewait_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_udp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_unix_sock)(struct sock *);

typedef u64 (*btf_bpf_snprintf)(char *, u32, char *, const void *, u32);

typedef u64 (*btf_bpf_snprintf_btf)(char *, u32, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_sock_addr_getsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_setsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_udp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_skc_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_from_file)(struct file *);

typedef u64 (*btf_bpf_sock_hash_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sock_map_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops_kern *, int);

typedef u64 (*btf_bpf_sock_ops_getsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_load_hdr_opt)(struct bpf_sock_ops_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_reserve_hdr_opt)(struct bpf_sock_ops_kern *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_setsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_store_hdr_opt)(struct bpf_sock_ops_kern *, const void *, u32, u64);

typedef u64 (*btf_bpf_spin_lock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_spin_unlock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_strncmp)(const char *, u32, const char *);

typedef u64 (*btf_bpf_strtol)(const char *, size_t, u64, s64 *);

typedef u64 (*btf_bpf_strtoul)(const char *, size_t, u64, u64 *);

typedef u64 (*btf_bpf_sys_bpf)(int, union bpf_attr *, u32);

typedef u64 (*btf_bpf_sys_close)(u32);

typedef u64 (*btf_bpf_sysctl_get_current_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_get_name)(struct bpf_sysctl_kern *, char *, size_t, u64);

typedef u64 (*btf_bpf_sysctl_get_new_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_set_new_value)(struct bpf_sysctl_kern *, const char *, size_t);

typedef u64 (*btf_bpf_task_pt_regs)(struct task_struct *);

typedef u64 (*btf_bpf_task_storage_delete)(struct bpf_map *, struct task_struct *);

typedef u64 (*btf_bpf_task_storage_delete_recur)(struct bpf_map *, struct task_struct *);

typedef u64 (*btf_bpf_task_storage_get)(struct bpf_map *, struct task_struct *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_task_storage_get_recur)(struct bpf_map *, struct task_struct *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_tc_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tc_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tc_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tcp_check_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_gen_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_raw_check_syncookie_ipv4)(struct iphdr *, struct tcphdr *);

typedef u64 (*btf_bpf_tcp_raw_check_syncookie_ipv6)(struct ipv6hdr *, struct tcphdr *);

typedef u64 (*btf_bpf_tcp_raw_gen_syncookie_ipv4)(struct iphdr *, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_raw_gen_syncookie_ipv6)(struct ipv6hdr *, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_send_ack)(struct tcp_sock *, u32);

typedef u64 (*btf_bpf_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_this_cpu_ptr)(const void *);

typedef u64 (*btf_bpf_timer_cancel)(struct bpf_async_kern *);

typedef u64 (*btf_bpf_timer_init)(struct bpf_async_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_timer_set_callback)(struct bpf_async_kern *, void *, struct bpf_prog_aux *);

typedef u64 (*btf_bpf_timer_start)(struct bpf_async_kern *, u64, u64);

typedef u64 (*btf_bpf_trace_printk)(char *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_trace_vprintk)(char *, u32, const void *, u32);

typedef u64 (*btf_bpf_unlocked_sk_getsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_unlocked_sk_setsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_user_ringbuf_drain)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_user_rnd_u32)(void);

typedef u64 (*btf_bpf_xdp_adjust_head)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_meta)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_tail)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_check_mtu)(struct xdp_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_xdp_event_output)(struct xdp_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_xdp_fib_lookup)(struct xdp_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_xdp_get_buff_len)(struct xdp_buff *);

typedef u64 (*btf_bpf_xdp_load_bytes)(struct xdp_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_xdp_redirect)(u32, u64);

typedef u64 (*btf_bpf_xdp_redirect_map)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_udp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_skc_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_store_bytes)(struct xdp_buff *, u32, void *, u32);

typedef u64 (*btf_get_func_arg)(void *, u32, u64 *);

typedef u64 (*btf_get_func_arg_cnt)(void *);

typedef u64 (*btf_get_func_ret)(void *, u64 *);

typedef u64 (*btf_sk_reuseport_load_bytes)(const struct sk_reuseport_kern *, u32, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes_relative)(const struct sk_reuseport_kern *, u32, void *, u32, u32);

typedef u64 (*btf_sk_select_reuseport)(struct sk_reuseport_kern *, struct bpf_map *, void *, u32);

typedef u64 (*btf_sk_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_sk_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_pull_data)(struct sk_buff *, u32);

typedef void (*btf_trace_9p_client_req)(void *, struct p9_client *, int8_t, int);

typedef void (*btf_trace_9p_client_res)(void *, struct p9_client *, int8_t, int, int);

typedef void (*btf_trace_9p_fid_ref)(void *, struct p9_fid *, __u8);

typedef void (*btf_trace_9p_protocol_dump)(void *, struct p9_client *, struct p9_fcall *);

typedef void (*btf_trace_ack_update_msk)(void *, u64, u64, u64, u64, u64);

typedef void (*btf_trace_add_delayed_data_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *);

typedef void (*btf_trace_add_delayed_ref_head)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_head *, int);

typedef void (*btf_trace_add_delayed_tree_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *);

typedef void (*btf_trace_add_device_to_group)(void *, int, struct device *);

typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);

typedef void (*btf_trace_alloc_extent_state)(void *, const struct extent_state *, gfp_t, long unsigned int);

typedef void (*btf_trace_alloc_vmap_area)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_amd_pstate_epp_perf)(void *, unsigned int, u8, u8, u8, u8, bool);

typedef void (*btf_trace_amd_pstate_perf)(void *, u8, u8, u8, u64, u64, u64, u64, unsigned int, bool);

typedef void (*btf_trace_attach_device_to_domain)(void *, struct device *);

typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, struct dirty_throttle_control *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long int, long unsigned int);

typedef void (*btf_trace_batadv_dbg)(void *, struct batadv_priv *, struct va_format *);

typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, long unsigned int, long unsigned int);

typedef void (*btf_trace_block_bio_backmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_bounce)(void *, struct bio *);

typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_frontmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_queue)(void *, struct bio *);

typedef void (*btf_trace_block_bio_remap)(void *, struct bio *, dev_t, sector_t);

typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_getrq)(void *, struct bio *);

typedef void (*btf_trace_block_io_done)(void *, struct request *);

typedef void (*btf_trace_block_io_start)(void *, struct request *);

typedef void (*btf_trace_block_plug)(void *, struct request_queue *);

typedef void (*btf_trace_block_rq_complete)(void *, struct request *, blk_status_t, unsigned int);

typedef void (*btf_trace_block_rq_error)(void *, struct request *, blk_status_t, unsigned int);

typedef void (*btf_trace_block_rq_insert)(void *, struct request *);

typedef void (*btf_trace_block_rq_issue)(void *, struct request *);

typedef void (*btf_trace_block_rq_merge)(void *, struct request *);

typedef void (*btf_trace_block_rq_remap)(void *, struct request *, dev_t, sector_t);

typedef void (*btf_trace_block_rq_requeue)(void *, struct request *);

typedef void (*btf_trace_block_split)(void *, struct bio *, unsigned int);

typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);

typedef void (*btf_trace_bpf_test_finish)(void *, int *);

typedef void (*btf_trace_bpf_trace_printk)(void *, const char *);

typedef void (*btf_trace_bpf_trigger_tp)(void *, int);

typedef void (*btf_trace_bpf_xdp_link_attach_failed)(void *, const char *);

typedef void (*btf_trace_br_fdb_add)(void *, struct ndmsg *, struct net_device *, const unsigned char *, u16, u16);

typedef void (*btf_trace_br_fdb_external_learn_add)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16);

typedef void (*btf_trace_br_fdb_update)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16, long unsigned int);

typedef void (*btf_trace_br_mdb_full)(void *, const struct net_device *, const struct br_ip *);

typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_btrfs_add_block_group)(void *, const struct btrfs_fs_info *, const struct btrfs_block_group *, int);

typedef void (*btf_trace_btrfs_add_reclaim_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_add_unused_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_all_work_done)(void *, const struct btrfs_fs_info *, const void *);

typedef void (*btf_trace_btrfs_chunk_alloc)(void *, const struct btrfs_fs_info *, const struct btrfs_chunk_map *, u64, u64);

typedef void (*btf_trace_btrfs_chunk_free)(void *, const struct btrfs_fs_info *, const struct btrfs_chunk_map *, u64, u64);

typedef void (*btf_trace_btrfs_clear_extent_bit)(void *, const struct extent_io_tree *, u64, u64, unsigned int);

typedef void (*btf_trace_btrfs_convert_extent_bit)(void *, const struct extent_io_tree *, u64, u64, unsigned int, unsigned int);

typedef void (*btf_trace_btrfs_cow_block)(void *, const struct btrfs_root *, const struct extent_buffer *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_done_preemptive_reclaim)(void *, struct btrfs_fs_info *, const struct btrfs_space_info *);

typedef void (*btf_trace_btrfs_extent_map_shrinker_count)(void *, const struct btrfs_fs_info *, long int);

typedef void (*btf_trace_btrfs_extent_map_shrinker_remove_em)(void *, const struct btrfs_inode *, const struct extent_map *);

typedef void (*btf_trace_btrfs_extent_map_shrinker_scan_enter)(void *, const struct btrfs_fs_info *, long int);

typedef void (*btf_trace_btrfs_extent_map_shrinker_scan_exit)(void *, const struct btrfs_fs_info *, long int, long int);

typedef void (*btf_trace_btrfs_fail_all_tickets)(void *, struct btrfs_fs_info *, const struct btrfs_space_info *);

typedef void (*btf_trace_btrfs_failed_cluster_setup)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_find_cluster)(void *, const struct btrfs_block_group *, u64, u64, u64, u64);

typedef void (*btf_trace_btrfs_finish_ordered_extent)(void *, const struct btrfs_inode *, u64, u64, bool);

typedef void (*btf_trace_btrfs_flush_space)(void *, const struct btrfs_fs_info *, u64, u64, int, int, bool);

typedef void (*btf_trace_btrfs_get_extent)(void *, const struct btrfs_root *, const struct btrfs_inode *, const struct extent_map *);

typedef void (*btf_trace_btrfs_get_extent_show_fi_inline)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, int, u64);

typedef void (*btf_trace_btrfs_get_extent_show_fi_regular)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, u64);

typedef void (*btf_trace_btrfs_get_raid_extent_offset)(void *, const struct btrfs_fs_info *, u64, u64, u64, u64);

typedef void (*btf_trace_btrfs_handle_em_exist)(void *, const struct btrfs_fs_info *, const struct extent_map *, const struct extent_map *, u64, u64);

typedef void (*btf_trace_btrfs_inode_evict)(void *, const struct inode *);

typedef void (*btf_trace_btrfs_inode_mod_outstanding_extents)(void *, const struct btrfs_root *, u64, int, unsigned int);

typedef void (*btf_trace_btrfs_inode_new)(void *, const struct inode *);

typedef void (*btf_trace_btrfs_inode_request)(void *, const struct inode *);

typedef void (*btf_trace_btrfs_insert_one_raid_extent)(void *, const struct btrfs_fs_info *, u64, u64, int);

typedef void (*btf_trace_btrfs_ordered_extent_add)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_dec_test_pending)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_lookup)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_lookup_first)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_lookup_first_range)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_lookup_for_logging)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_lookup_range)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_mark_finished)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_put)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_remove)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_split)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_extent_start)(void *, const struct btrfs_inode *, const struct btrfs_ordered_extent *);

typedef void (*btf_trace_btrfs_ordered_sched)(void *, const struct btrfs_work *);

typedef void (*btf_trace_btrfs_prelim_ref_insert)(void *, const struct btrfs_fs_info *, const struct prelim_ref *, const struct prelim_ref *, u64);

typedef void (*btf_trace_btrfs_prelim_ref_merge)(void *, const struct btrfs_fs_info *, const struct prelim_ref *, const struct prelim_ref *, u64);

typedef void (*btf_trace_btrfs_qgroup_account_extent)(void *, const struct btrfs_fs_info *, u64, u64, u64, u64, u64);

typedef void (*btf_trace_btrfs_qgroup_account_extents)(void *, const struct btrfs_fs_info *, const struct btrfs_qgroup_extent_record *, u64);

typedef void (*btf_trace_btrfs_qgroup_release_data)(void *, const struct inode *, u64, u64, u64, int);

typedef void (*btf_trace_btrfs_qgroup_reserve_data)(void *, const struct inode *, u64, u64, u64, int);

typedef void (*btf_trace_btrfs_qgroup_trace_extent)(void *, const struct btrfs_fs_info *, const struct btrfs_qgroup_extent_record *, u64);

typedef void (*btf_trace_btrfs_raid_extent_delete)(void *, const struct btrfs_fs_info *, u64, u64, u64, u64);

typedef void (*btf_trace_btrfs_reclaim_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_remove_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_reserve_extent)(void *, const struct btrfs_block_group *, const struct find_free_extent_ctl *);

typedef void (*btf_trace_btrfs_reserve_extent_cluster)(void *, const struct btrfs_block_group *, const struct find_free_extent_ctl *);

typedef void (*btf_trace_btrfs_reserve_ticket)(void *, const struct btrfs_fs_info *, u64, u64, u64, int, int);

typedef void (*btf_trace_btrfs_reserved_extent_alloc)(void *, const struct btrfs_fs_info *, u64, u64);

typedef void (*btf_trace_btrfs_reserved_extent_free)(void *, const struct btrfs_fs_info *, u64, u64);

typedef void (*btf_trace_btrfs_set_extent_bit)(void *, const struct extent_io_tree *, u64, u64, unsigned int);

typedef void (*btf_trace_btrfs_set_lock_blocking_read)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_set_lock_blocking_write)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_setup_cluster)(void *, const struct btrfs_block_group *, const struct btrfs_free_cluster *, u64, int);

typedef void (*btf_trace_btrfs_skip_unused_block_group)(void *, const struct btrfs_block_group *);

typedef void (*btf_trace_btrfs_space_reservation)(void *, const struct btrfs_fs_info *, const char *, u64, u64, int);

typedef void (*btf_trace_btrfs_sync_file)(void *, const struct file *, int);

typedef void (*btf_trace_btrfs_sync_fs)(void *, const struct btrfs_fs_info *, int);

typedef void (*btf_trace_btrfs_transaction_commit)(void *, const struct btrfs_fs_info *);

typedef void (*btf_trace_btrfs_tree_lock)(void *, const struct extent_buffer *, u64);

typedef void (*btf_trace_btrfs_tree_read_lock)(void *, const struct extent_buffer *, u64);

typedef void (*btf_trace_btrfs_tree_read_lock_atomic)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_tree_read_unlock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_tree_read_unlock_blocking)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_tree_unlock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_trigger_flush)(void *, const struct btrfs_fs_info *, u64, u64, int, const char *);

typedef void (*btf_trace_btrfs_truncate_show_fi_inline)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, int, u64);

typedef void (*btf_trace_btrfs_truncate_show_fi_regular)(void *, const struct btrfs_inode *, const struct extent_buffer *, const struct btrfs_file_extent_item *, u64);

typedef void (*btf_trace_btrfs_try_tree_read_lock)(void *, const struct extent_buffer *);

typedef void (*btf_trace_btrfs_work_queued)(void *, const struct btrfs_work *);

typedef void (*btf_trace_btrfs_work_sched)(void *, const struct btrfs_work *);

typedef void (*btf_trace_btrfs_workqueue_alloc)(void *, const struct btrfs_workqueue *, const char *);

typedef void (*btf_trace_btrfs_workqueue_destroy)(void *, const struct btrfs_workqueue *);

typedef void (*btf_trace_btrfs_writepage_end_io_hook)(void *, const struct btrfs_inode *, u64, u64, int);

typedef void (*btf_trace_cache_entry_expired)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_make_negative)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_no_listener)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_upcall)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_update)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_tag_assign)(void *, struct cache_tag *);

typedef void (*btf_trace_cache_tag_flush_all)(void *, struct cache_tag *);

typedef void (*btf_trace_cache_tag_flush_range)(void *, struct cache_tag *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_cache_tag_flush_range_np)(void *, struct cache_tag *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_cache_tag_unassign)(void *, struct cache_tag *);

typedef void (*btf_trace_call_function_entry)(void *, int);

typedef void (*btf_trace_call_function_exit)(void *, int);

typedef void (*btf_trace_call_function_single_entry)(void *, int);

typedef void (*btf_trace_call_function_single_exit)(void *, int);

typedef void (*btf_trace_cap_capable)(void *, const struct cred *, struct user_namespace *, const struct user_namespace *, int, int);

typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, long unsigned int);

typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rstat_cpu_lock_contended)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_cpu_lock_contended_fastpath)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_cpu_locked)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_cpu_locked_fastpath)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_cpu_unlock)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_cpu_unlock_fastpath)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_lock_contended)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_locked)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_rstat_unlock)(void *, struct cgroup *, int, bool);

typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);

typedef void (*btf_trace_console)(void *, const char *, size_t);

typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *, void *);

typedef void (*btf_trace_contention_begin)(void *, void *, unsigned int);

typedef void (*btf_trace_contention_end)(void *, void *, int);

typedef void (*btf_trace_count_memcg_events)(void *, struct mem_cgroup *, int, long unsigned int);

typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);

typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_idle_miss)(void *, unsigned int, unsigned int, bool);

typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));

typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);

typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);

typedef void (*btf_trace_csd_function_entry)(void *, smp_call_func_t, call_single_data_t *);

typedef void (*btf_trace_csd_function_exit)(void *, smp_call_func_t, call_single_data_t *);

typedef void (*btf_trace_csd_queue_cpu)(void *, const unsigned int, long unsigned int, smp_call_func_t, call_single_data_t *);

typedef void (*btf_trace_ctime_ns_xchg)(void *, struct inode *, u32, u32, u32);

typedef void (*btf_trace_ctime_xchg_skip)(void *, struct inode *, struct timespec64 *);

typedef void (*btf_trace_dccp_probe)(void *, struct sock *, size_t);

typedef void (*btf_trace_deferred_error_apic_entry)(void *, int);

typedef void (*btf_trace_deferred_error_apic_exit)(void *, int);

typedef void (*btf_trace_delete_session)(void *, struct l2tp_session *);

typedef void (*btf_trace_delete_tunnel)(void *, struct l2tp_tunnel *);

typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);

typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);

typedef void (*btf_trace_devres_log)(void *, struct device *, const char *, void *, const char *, size_t);

typedef void (*btf_trace_dma_alloc)(void *, struct device *, void *, dma_addr_t, size_t, enum dma_data_direction, gfp_t, long unsigned int);

typedef void (*btf_trace_dma_alloc_pages)(void *, struct device *, void *, dma_addr_t, size_t, enum dma_data_direction, gfp_t, long unsigned int);

typedef void (*btf_trace_dma_alloc_sgt)(void *, struct device *, struct sg_table *, size_t, enum dma_data_direction, gfp_t, long unsigned int);

typedef void (*btf_trace_dma_alloc_sgt_err)(void *, struct device *, void *, dma_addr_t, size_t, enum dma_data_direction, gfp_t, long unsigned int);

typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_free)(void *, struct device *, void *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_free_pages)(void *, struct device *, void *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_free_sgt)(void *, struct device *, struct sg_table *, size_t, enum dma_data_direction);

typedef void (*btf_trace_dma_map_page)(void *, struct device *, phys_addr_t, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_map_resource)(void *, struct device *, phys_addr_t, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_map_sg)(void *, struct device *, struct scatterlist *, int, int, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_map_sg_err)(void *, struct device *, struct scatterlist *, int, int, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_sync_sg_for_cpu)(void *, struct device *, struct scatterlist *, int, enum dma_data_direction);

typedef void (*btf_trace_dma_sync_sg_for_device)(void *, struct device *, struct scatterlist *, int, enum dma_data_direction);

typedef void (*btf_trace_dma_sync_single_for_cpu)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction);

typedef void (*btf_trace_dma_sync_single_for_device)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction);

typedef void (*btf_trace_dma_unmap_page)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_unmap_resource)(void *, struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dma_unmap_sg)(void *, struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);

typedef void (*btf_trace_dql_stall_detected)(void *, short unsigned int, unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int *);

typedef void (*btf_trace_drm_vblank_event)(void *, int, unsigned int, ktime_t, bool);

typedef void (*btf_trace_drm_vblank_event_delivered)(void *, struct drm_file *, int, unsigned int);

typedef void (*btf_trace_drm_vblank_event_queued)(void *, struct drm_file *, int, unsigned int);

typedef void (*btf_trace_emulate_vsyscall)(void *, int);

typedef void (*btf_trace_error_apic_entry)(void *, int);

typedef void (*btf_trace_error_apic_exit)(void *, int);

typedef void (*btf_trace_error_report_end)(void *, enum error_detector, long unsigned int);

typedef void (*btf_trace_exit_mmap)(void *, struct mm_struct *);

typedef void (*btf_trace_ext4_alloc_da_blocks)(void *, struct inode *);

typedef void (*btf_trace_ext4_allocate_blocks)(void *, struct ext4_allocation_request *, long long unsigned int);

typedef void (*btf_trace_ext4_allocate_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_ext4_begin_ordered_truncate)(void *, struct inode *, loff_t);

typedef void (*btf_trace_ext4_collapse_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_da_release_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_da_reserve_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_da_update_reserve_space)(void *, struct inode *, int, int);

typedef void (*btf_trace_ext4_da_write_begin)(void *, struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_ext4_da_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_pages)(void *, struct inode *, long unsigned int, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages_extent)(void *, struct inode *, struct ext4_map_blocks *);

typedef void (*btf_trace_ext4_discard_blocks)(void *, struct super_block *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_ext4_discard_preallocations)(void *, struct inode *, unsigned int);

typedef void (*btf_trace_ext4_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_error)(void *, struct super_block *, const char *, unsigned int);

typedef void (*btf_trace_ext4_es_cache_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_find_extent_range_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_exit)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_insert_delayed_extent)(void *, struct inode *, struct extent_status *, bool, bool);

typedef void (*btf_trace_ext4_es_insert_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_lookup_extent_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_lookup_extent_exit)(void *, struct inode *, struct extent_status *, int);

typedef void (*btf_trace_ext4_es_remove_extent)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_shrink)(void *, struct super_block *, int, u64, int, int);

typedef void (*btf_trace_ext4_es_shrink_count)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_enter)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_exit)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_enter)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_fastpath)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_handle_unwritten_extents)(void *, struct inode *, struct ext4_map_blocks *, int, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_load_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ext_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_remove_space)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_ext_remove_space_done)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, struct partial_cluster *, __le16);

typedef void (*btf_trace_ext4_ext_rm_idx)(void *, struct inode *, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_rm_leaf)(void *, struct inode *, ext4_lblk_t, struct ext4_extent *, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_show_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t, short unsigned int);

typedef void (*btf_trace_ext4_fallocate_enter)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_fallocate_exit)(void *, struct inode *, loff_t, unsigned int, int);

typedef void (*btf_trace_ext4_fc_cleanup)(void *, journal_t *, int, tid_t);

typedef void (*btf_trace_ext4_fc_commit_start)(void *, struct super_block *, tid_t);

typedef void (*btf_trace_ext4_fc_commit_stop)(void *, struct super_block *, int, int, tid_t);

typedef void (*btf_trace_ext4_fc_replay)(void *, struct super_block *, int, int, int, int);

typedef void (*btf_trace_ext4_fc_replay_scan)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_stats)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_track_create)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_inode)(void *, handle_t *, struct inode *, int);

typedef void (*btf_trace_ext4_fc_track_link)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_range)(void *, handle_t *, struct inode *, long int, long int, int);

typedef void (*btf_trace_ext4_fc_track_unlink)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_forget)(void *, struct inode *, int, __u64);

typedef void (*btf_trace_ext4_free_blocks)(void *, struct inode *, __u64, long unsigned int, int);

typedef void (*btf_trace_ext4_free_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_fsmap_high_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_low_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_mapping)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_get_implied_cluster_alloc_exit)(void *, struct super_block *, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_getfsmap_high_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_low_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_mapping)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_ind_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ind_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_insert_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_invalidate_folio)(void *, struct folio *, size_t, size_t);

typedef void (*btf_trace_ext4_journal_start_inode)(void *, struct inode *, int, int, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_reserved)(void *, struct super_block *, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_sb)(void *, struct super_block *, int, int, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journalled_invalidate_folio)(void *, struct folio *, size_t, size_t);

typedef void (*btf_trace_ext4_journalled_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_lazy_itable_init)(void *, struct super_block *, ext4_group_t);

typedef void (*btf_trace_ext4_load_inode)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_load_inode_bitmap)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mark_inode_dirty)(void *, struct inode *, long unsigned int);

typedef void (*btf_trace_ext4_mb_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_buddy_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_discard_preallocations)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_mb_new_group_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_new_inode_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_group_pa)(void *, struct super_block *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_inode_pa)(void *, struct ext4_prealloc_space *, long long unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mballoc_alloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_discard)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_free)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_prealloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_nfs_commit_metadata)(void *, struct inode *);

typedef void (*btf_trace_ext4_other_inode_update_time)(void *, struct inode *, ino_t);

typedef void (*btf_trace_ext4_prefetch_bitmaps)(void *, struct super_block *, ext4_group_t, ext4_group_t, unsigned int);

typedef void (*btf_trace_ext4_punch_hole)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_read_block_bitmap_load)(void *, struct super_block *, long unsigned int, bool);

typedef void (*btf_trace_ext4_read_folio)(void *, struct inode *, struct folio *);

typedef void (*btf_trace_ext4_release_folio)(void *, struct inode *, struct folio *);

typedef void (*btf_trace_ext4_remove_blocks)(void *, struct inode *, struct ext4_extent *, ext4_lblk_t, ext4_fsblk_t, struct partial_cluster *);

typedef void (*btf_trace_ext4_request_blocks)(void *, struct ext4_allocation_request *);

typedef void (*btf_trace_ext4_request_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_shutdown)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_sync_file_enter)(void *, struct file *, int);

typedef void (*btf_trace_ext4_sync_file_exit)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_trim_all_free)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_trim_extent)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_truncate_enter)(void *, struct inode *);

typedef void (*btf_trace_ext4_truncate_exit)(void *, struct inode *);

typedef void (*btf_trace_ext4_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_ext4_unlink_exit)(void *, struct dentry *, int);

typedef void (*btf_trace_ext4_update_sb)(void *, struct super_block *, ext4_fsblk_t, unsigned int);

typedef void (*btf_trace_ext4_write_begin)(void *, struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_ext4_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_writepages)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_ext4_writepages_result)(void *, struct inode *, struct writeback_control *, int, int);

typedef void (*btf_trace_ext4_zero_range)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_extent_writepage)(void *, const struct folio *, const struct inode *, const struct writeback_control *);

typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_fdb_delete)(void *, struct net_bridge *, struct net_bridge_fdb_entry *);

typedef void (*btf_trace_fib6_table_lookup)(void *, const struct net *, const struct fib6_result *, struct fib6_table *, const struct flowi6 *);

typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);

typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file *, errseq_t);

typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space *, errseq_t);

typedef void (*btf_trace_fill_mg_cmtime)(void *, struct inode *, struct timespec64 *, struct timespec64 *);

typedef void (*btf_trace_find_free_extent)(void *, const struct btrfs_root *, const struct find_free_extent_ctl *);

typedef void (*btf_trace_find_free_extent_have_block_group)(void *, const struct btrfs_root *, const struct find_free_extent_ctl *, const struct btrfs_block_group *);

typedef void (*btf_trace_find_free_extent_search_loop)(void *, const struct btrfs_root *, const struct find_free_extent_ctl *);

typedef void (*btf_trace_finish_task_reaping)(void *, int);

typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_flush_foreign)(void *, struct bdi_writeback *, unsigned int, unsigned int);

typedef void (*btf_trace_folio_wait_writeback)(void *, struct folio *, struct address_space *);

typedef void (*btf_trace_free_extent_state)(void *, const struct extent_state *, long unsigned int);

typedef void (*btf_trace_free_session)(void *, struct l2tp_session *);

typedef void (*btf_trace_free_tunnel)(void *, struct l2tp_tunnel *);

typedef void (*btf_trace_free_vmap_area_noflush)(void *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_fuse_request_end)(void *, const struct fuse_req *);

typedef void (*btf_trace_fuse_request_send)(void *, const struct fuse_req *);

typedef void (*btf_trace_g4x_wm)(void *, struct intel_crtc *, const struct g4x_wm_values *);

typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_get_mapping_status)(void *, struct mptcp_ext *);

typedef void (*btf_trace_global_dirty_state)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_guest_halt_poll_ns)(void *, bool, unsigned int, unsigned int);

typedef void (*btf_trace_handshake_cancel)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_cancel_busy)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_cancel_none)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_cmd_accept)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cmd_accept_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cmd_done)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_cmd_done_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_complete)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_destruct)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_notify_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_handshake_submit)(void *, const struct net *, const struct handshake_req *, const struct sock *);

typedef void (*btf_trace_handshake_submit_err)(void *, const struct net *, const struct handshake_req *, const struct sock *, int);

typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);

typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);

typedef void (*btf_trace_hugetlbfs_alloc_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_hugetlbfs_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_hugetlbfs_fallocate)(void *, struct inode *, int, loff_t, loff_t, int);

typedef void (*btf_trace_hugetlbfs_free_inode)(void *, struct inode *);

typedef void (*btf_trace_hugetlbfs_setattr)(void *, struct inode *, struct dentry *, struct iattr *);

typedef void (*btf_trace_hwmon_attr_show)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_show_string)(void *, int, const char *, const char *);

typedef void (*btf_trace_hwmon_attr_store)(void *, int, const char *, long int);

typedef void (*btf_trace_i2c_read)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_reply)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_result)(void *, const struct i2c_adapter *, int, int);

typedef void (*btf_trace_i2c_write)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i915_context_create)(void *, struct i915_gem_context *);

typedef void (*btf_trace_i915_context_free)(void *, struct i915_gem_context *);

typedef void (*btf_trace_i915_gem_evict)(void *, struct i915_address_space *, u64, u64, unsigned int);

typedef void (*btf_trace_i915_gem_evict_node)(void *, struct i915_address_space *, struct drm_mm_node *, unsigned int);

typedef void (*btf_trace_i915_gem_evict_vm)(void *, struct i915_address_space *);

typedef void (*btf_trace_i915_gem_object_clflush)(void *, struct drm_i915_gem_object *);

typedef void (*btf_trace_i915_gem_object_create)(void *, struct drm_i915_gem_object *);

typedef void (*btf_trace_i915_gem_object_destroy)(void *, struct drm_i915_gem_object *);

typedef void (*btf_trace_i915_gem_object_fault)(void *, struct drm_i915_gem_object *, u64, bool, bool);

typedef void (*btf_trace_i915_gem_object_pread)(void *, struct drm_i915_gem_object *, u64, u64);

typedef void (*btf_trace_i915_gem_object_pwrite)(void *, struct drm_i915_gem_object *, u64, u64);

typedef void (*btf_trace_i915_gem_shrink)(void *, struct drm_i915_private *, long unsigned int, unsigned int);

typedef void (*btf_trace_i915_ppgtt_create)(void *, struct i915_address_space *);

typedef void (*btf_trace_i915_ppgtt_release)(void *, struct i915_address_space *);

typedef void (*btf_trace_i915_reg_rw)(void *, bool, i915_reg_t, u64, int, bool);

typedef void (*btf_trace_i915_request_add)(void *, struct i915_request *);

typedef void (*btf_trace_i915_request_queue)(void *, struct i915_request *, u32);

typedef void (*btf_trace_i915_request_retire)(void *, struct i915_request *);

typedef void (*btf_trace_i915_request_wait_begin)(void *, struct i915_request *, unsigned int);

typedef void (*btf_trace_i915_request_wait_end)(void *, struct i915_request *);

typedef void (*btf_trace_i915_vma_bind)(void *, struct i915_vma *, unsigned int);

typedef void (*btf_trace_i915_vma_unbind)(void *, struct i915_vma *);

typedef void (*btf_trace_icmp_send)(void *, const struct sk_buff *, int, int);

typedef void (*btf_trace_inet_sk_error_report)(void *, const struct sock *);

typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);

typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);

typedef void (*btf_trace_initcall_level)(void *, const char *);

typedef void (*btf_trace_initcall_start)(void *, initcall_t);

typedef void (*btf_trace_inode_foreign_history)(void *, struct inode *, struct writeback_control *, unsigned int);

typedef void (*btf_trace_inode_set_ctime_to_ts)(void *, struct inode *, struct timespec64 *);

typedef void (*btf_trace_inode_switch_wbs)(void *, struct inode *, struct bdi_writeback *, struct bdi_writeback *);

typedef void (*btf_trace_intel_cpu_fifo_underrun)(void *, struct intel_display *, enum pipe);

typedef void (*btf_trace_intel_crtc_flip_done)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_crtc_vblank_work_end)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_crtc_vblank_work_start)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_fbc_activate)(void *, struct intel_plane *);

typedef void (*btf_trace_intel_fbc_deactivate)(void *, struct intel_plane *);

typedef void (*btf_trace_intel_fbc_nuke)(void *, struct intel_plane *);

typedef void (*btf_trace_intel_frontbuffer_flush)(void *, struct intel_display *, unsigned int, unsigned int);

typedef void (*btf_trace_intel_frontbuffer_invalidate)(void *, struct intel_display *, unsigned int, unsigned int);

typedef void (*btf_trace_intel_memory_cxsr)(void *, struct intel_display *, bool, bool);

typedef void (*btf_trace_intel_pch_fifo_underrun)(void *, struct intel_display *, enum pipe);

typedef void (*btf_trace_intel_pipe_crc)(void *, struct intel_crtc *, const u32 *);

typedef void (*btf_trace_intel_pipe_disable)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_pipe_enable)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_pipe_update_end)(void *, struct intel_crtc *, u32, int);

typedef void (*btf_trace_intel_pipe_update_start)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_pipe_update_vblank_evaded)(void *, struct intel_crtc *);

typedef void (*btf_trace_intel_plane_async_flip)(void *, struct intel_plane *, struct intel_crtc *, bool);

typedef void (*btf_trace_intel_plane_disable_arm)(void *, struct intel_plane *, struct intel_crtc *);

typedef void (*btf_trace_intel_plane_update_arm)(void *, struct intel_plane *, struct intel_crtc *);

typedef void (*btf_trace_intel_plane_update_noarm)(void *, struct intel_plane *, struct intel_crtc *);

typedef void (*btf_trace_io_page_fault)(void *, struct device *, long unsigned int, int);

typedef void (*btf_trace_io_uring_complete)(void *, struct io_ring_ctx *, void *, struct io_uring_cqe *);

typedef void (*btf_trace_io_uring_cqe_overflow)(void *, void *, long long unsigned int, s32, u32, void *);

typedef void (*btf_trace_io_uring_cqring_wait)(void *, void *, int);

typedef void (*btf_trace_io_uring_create)(void *, int, void *, u32, u32, u32);

typedef void (*btf_trace_io_uring_defer)(void *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_fail_link)(void *, struct io_kiocb *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_file_get)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_link)(void *, struct io_kiocb *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_local_work_run)(void *, void *, int, unsigned int);

typedef void (*btf_trace_io_uring_poll_arm)(void *, struct io_kiocb *, int, int);

typedef void (*btf_trace_io_uring_queue_async_work)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_register)(void *, void *, unsigned int, unsigned int, unsigned int, long int);

typedef void (*btf_trace_io_uring_req_failed)(void *, const struct io_uring_sqe *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_short_write)(void *, void *, u64, u64, u64);

typedef void (*btf_trace_io_uring_submit_req)(void *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_task_add)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_task_work_run)(void *, void *, unsigned int);

typedef void (*btf_trace_iocost_inuse_adjust)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_inuse_shortage)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_inuse_transfer)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u32, u64, u64);

typedef void (*btf_trace_iocost_ioc_vrate_adj)(void *, struct ioc *, u64, u32 *, u32, int, int);

typedef void (*btf_trace_iocost_iocg_activate)(void *, struct ioc_gq *, const char *, struct ioc_now *, u64, u64, u64);

typedef void (*btf_trace_iocost_iocg_forgive_debt)(void *, struct ioc_gq *, const char *, struct ioc_now *, u32, u64, u64, u64, u64);

typedef void (*btf_trace_iocost_iocg_idle)(void *, struct ioc_gq *, const char *, struct ioc_now *, u64, u64, u64);

typedef void (*btf_trace_iomap_dio_complete)(void *, struct kiocb *, int, ssize_t);

typedef void (*btf_trace_iomap_dio_invalidate_fail)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_dio_rw_begin)(void *, struct kiocb *, struct iov_iter *, unsigned int, size_t);

typedef void (*btf_trace_iomap_dio_rw_queued)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_invalidate_folio)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_iter)(void *, struct iomap_iter *, const void *, long unsigned int);

typedef void (*btf_trace_iomap_iter_dstmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_iter_srcmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_readahead)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_readpage)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_release_folio)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_writepage)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_writepage_map)(void *, struct inode *, u64, unsigned int, struct iomap *);

typedef void (*btf_trace_ipi_entry)(void *, const char *);

typedef void (*btf_trace_ipi_exit)(void *, const char *);

typedef void (*btf_trace_ipi_raise)(void *, const struct cpumask *, const char *);

typedef void (*btf_trace_ipi_send_cpu)(void *, const unsigned int, long unsigned int, void *);

typedef void (*btf_trace_ipi_send_cpumask)(void *, const struct cpumask *, long unsigned int, void *);

typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);

typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);

typedef void (*btf_trace_irq_matrix_alloc)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_alloc_managed)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_alloc_reserved)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_assign)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_assign_system)(void *, int, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_free)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_offline)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_online)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_remove_managed)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_matrix_remove_reserved)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_reserve)(void *, struct irq_matrix *);

typedef void (*btf_trace_irq_matrix_reserve_managed)(void *, int, unsigned int, struct irq_matrix *, struct cpumap *);

typedef void (*btf_trace_irq_work_entry)(void *, int);

typedef void (*btf_trace_irq_work_exit)(void *, int);

typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, long long unsigned int);

typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerspec64 * const, long long unsigned int);

typedef void (*btf_trace_jbd2_checkpoint)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_checkpoint_stats)(void *, dev_t, tid_t, struct transaction_chp_stats_s *);

typedef void (*btf_trace_jbd2_commit_flushing)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_locking)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_logging)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_drop_transaction)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_end_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_handle_extend)(void *, dev_t, tid_t, unsigned int, unsigned int, int, int);

typedef void (*btf_trace_jbd2_handle_restart)(void *, dev_t, tid_t, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_start)(void *, dev_t, tid_t, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_stats)(void *, dev_t, tid_t, unsigned int, unsigned int, int, int, int, int);

typedef void (*btf_trace_jbd2_lock_buffer_stall)(void *, dev_t, long unsigned int);

typedef void (*btf_trace_jbd2_run_stats)(void *, dev_t, tid_t, struct transaction_run_stats_s *);

typedef void (*btf_trace_jbd2_shrink_checkpoint_list)(void *, journal_t *, tid_t, tid_t, tid_t, long unsigned int, tid_t);

typedef void (*btf_trace_jbd2_shrink_count)(void *, journal_t *, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_scan_enter)(void *, journal_t *, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_scan_exit)(void *, journal_t *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_start_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_submit_inode_data)(void *, struct inode *);

typedef void (*btf_trace_jbd2_update_log_tail)(void *, journal_t *, tid_t, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_write_superblock)(void *, journal_t *, blk_opf_t);

typedef void (*btf_trace_kfree)(void *, long unsigned int, const void *);

typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *, enum skb_drop_reason, struct sock *);

typedef void (*btf_trace_kmalloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kmem_cache_alloc)(void *, long unsigned int, const void *, struct kmem_cache *, gfp_t, int);

typedef void (*btf_trace_kmem_cache_free)(void *, long unsigned int, const void *, const struct kmem_cache *);

typedef void (*btf_trace_kyber_adjust)(void *, dev_t, const char *, unsigned int);

typedef void (*btf_trace_kyber_latency)(void *, dev_t, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_kyber_throttled)(void *, dev_t, const char *);

typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lease *, struct file_lease *);

typedef void (*btf_trace_local_timer_entry)(void *, int);

typedef void (*btf_trace_local_timer_exit)(void *, int);

typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);

typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_ma_op)(void *, const char *, struct ma_state *);

typedef void (*btf_trace_ma_read)(void *, const char *, struct ma_state *);

typedef void (*btf_trace_ma_write)(void *, const char *, struct ma_state *, long unsigned int, void *);

typedef void (*btf_trace_map)(void *, long unsigned int, phys_addr_t, size_t);

typedef void (*btf_trace_mark_victim)(void *, struct task_struct *, uid_t);

typedef void (*btf_trace_mce_record)(void *, struct mce_hw_err *);

typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);

typedef void (*btf_trace_mei_pci_cfg_read)(void *, const struct device *, const char *, u32, u32);

typedef void (*btf_trace_mei_reg_read)(void *, const struct device *, const char *, u32, u32);

typedef void (*btf_trace_mei_reg_write)(void *, const struct device *, const char *, u32, u32);

typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);

typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);

typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);

typedef void (*btf_trace_memcg_flush_stats)(void *, struct mem_cgroup *, s64, bool, bool);

typedef void (*btf_trace_mm_alloc_contig_migrate_range_info)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_compaction_begin)(void *, struct compact_control *, long unsigned int, long unsigned int, bool);

typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_end)(void *, struct compact_control *, long unsigned int, long unsigned int, bool, int);

typedef void (*btf_trace_mm_compaction_fast_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);

typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_compaction_migratepages)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);

typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct folio *);

typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct folio *);

typedef void (*btf_trace_mm_filemap_fault)(void *, struct address_space *, long unsigned int);

typedef void (*btf_trace_mm_filemap_get_pages)(void *, struct address_space *, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_filemap_map_pages)(void *, struct address_space *, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_lru_activate)(void *, struct folio *);

typedef void (*btf_trace_mm_lru_insertion)(void *, struct folio *);

typedef void (*btf_trace_mm_migrate_pages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, enum migrate_mode, int);

typedef void (*btf_trace_mm_migrate_pages_start)(void *, enum migrate_mode, int);

typedef void (*btf_trace_mm_page_alloc)(void *, struct page *, unsigned int, gfp_t, int);

typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page *, int, int, int, int);

typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page *, unsigned int, int, int);

typedef void (*btf_trace_mm_page_free)(void *, struct page *, unsigned int);

typedef void (*btf_trace_mm_page_free_batched)(void *, struct page *);

typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long int, long int, long int);

typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long int, long unsigned int, long long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);

typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);

typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *, int, int);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_reclaim_pages)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *);

typedef void (*btf_trace_mm_vmscan_throttled)(void *, int, int, int, int);

typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_write_folio)(void *, struct folio *);

typedef void (*btf_trace_mmap_lock_acquire_returned)(void *, struct mm_struct *, bool, bool);

typedef void (*btf_trace_mmap_lock_released)(void *, struct mm_struct *, bool);

typedef void (*btf_trace_mmap_lock_start_locking)(void *, struct mm_struct *, bool);

typedef void (*btf_trace_mod_memcg_lruvec_state)(void *, struct mem_cgroup *, int, int);

typedef void (*btf_trace_mod_memcg_state)(void *, struct mem_cgroup *, int, int);

typedef void (*btf_trace_module_free)(void *, struct module *);

typedef void (*btf_trace_module_get)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_load)(void *, struct module *);

typedef void (*btf_trace_module_put)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_request)(void *, char *, bool, long unsigned int);

typedef void (*btf_trace_mptcp_sendmsg_frag)(void *, struct mptcp_ext *);

typedef void (*btf_trace_mptcp_subflow_get_send)(void *, struct mptcp_subflow_context *);

typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);

typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);

typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);

typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);

typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);

typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);

typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);

typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);

typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);

typedef void (*btf_trace_netfs_collect)(void *, const struct netfs_io_request *);

typedef void (*btf_trace_netfs_collect_folio)(void *, const struct netfs_io_request *, const struct folio *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_netfs_collect_gap)(void *, const struct netfs_io_request *, const struct netfs_io_stream *, long long unsigned int, char);

typedef void (*btf_trace_netfs_collect_sreq)(void *, const struct netfs_io_request *, const struct netfs_io_subrequest *);

typedef void (*btf_trace_netfs_collect_state)(void *, const struct netfs_io_request *, long long unsigned int, unsigned int);

typedef void (*btf_trace_netfs_collect_stream)(void *, const struct netfs_io_request *, const struct netfs_io_stream *);

typedef void (*btf_trace_netfs_failure)(void *, struct netfs_io_request *, struct netfs_io_subrequest *, int, enum netfs_failure);

typedef void (*btf_trace_netfs_folio)(void *, struct folio *, enum netfs_folio_trace);

typedef void (*btf_trace_netfs_folioq)(void *, const struct folio_queue *, enum netfs_folioq_trace);

typedef void (*btf_trace_netfs_read)(void *, struct netfs_io_request *, loff_t, size_t, enum netfs_read_trace);

typedef void (*btf_trace_netfs_rreq)(void *, struct netfs_io_request *, enum netfs_rreq_trace);

typedef void (*btf_trace_netfs_rreq_ref)(void *, unsigned int, int, enum netfs_rreq_ref_trace);

typedef void (*btf_trace_netfs_sreq)(void *, struct netfs_io_subrequest *, enum netfs_sreq_trace);

typedef void (*btf_trace_netfs_sreq_ref)(void *, unsigned int, unsigned int, int, enum netfs_sreq_ref_trace);

typedef void (*btf_trace_netfs_write)(void *, const struct netfs_io_request *, enum netfs_write_trace);

typedef void (*btf_trace_netfs_write_iter)(void *, const struct kiocb *, const struct iov_iter *);

typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);

typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_exit)(void *, int);

typedef void (*btf_trace_netlink_extack)(void *, const char *);

typedef void (*btf_trace_nfs4_access)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_cached_open)(void *, const struct nfs4_state *);

typedef void (*btf_trace_nfs4_cb_getattr)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, int);

typedef void (*btf_trace_nfs4_cb_layoutrecall_file)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_cb_recall)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_close)(void *, const struct nfs4_state *, const struct nfs_closeargs *, const struct nfs_closeres *, int);

typedef void (*btf_trace_nfs4_close_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_commit)(void *, const struct nfs_commit_data *, int);

typedef void (*btf_trace_nfs4_delegreturn)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_delegreturn_exit)(void *, const struct nfs4_delegreturnargs *, const struct nfs4_delegreturnres *, int);

typedef void (*btf_trace_nfs4_fsinfo)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_get_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_get_fs_locations)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_get_lock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_getattr)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_lookup)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_lookup_root)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_lookupp)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_map_gid_to_group)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_group_to_gid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_name_to_uid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_uid_to_name)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_mkdir)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_mknod)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_open_expired)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_file)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_reclaim)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_stateid_update)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_open_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_read)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_readdir)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_readlink)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_reclaim_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_remove)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_rename)(void *, const struct inode *, const struct qstr *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_renew)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_renew_async)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_secinfo)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_set_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_set_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_set_lock)(void *, const struct file_lock *, const struct nfs4_state *, const nfs4_stateid *, int, int);

typedef void (*btf_trace_nfs4_setattr)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_setclientid)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_setclientid_confirm)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_setup_sequence)(void *, const struct nfs4_session *, const struct nfs4_sequence_args *);

typedef void (*btf_trace_nfs4_state_lock_reclaim)(void *, const struct nfs4_state *, const struct nfs4_lock_state *);

typedef void (*btf_trace_nfs4_state_mgr)(void *, const struct nfs_client *);

typedef void (*btf_trace_nfs4_state_mgr_failed)(void *, const struct nfs_client *, const char *, int);

typedef void (*btf_trace_nfs4_symlink)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_unlock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_write)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_xdr_bad_filehandle)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs4_xdr_bad_operation)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs4_xdr_status)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs_access_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_access_exit)(void *, const struct inode *, unsigned int, unsigned int, int);

typedef void (*btf_trace_nfs_aop_readahead)(void *, const struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_nfs_aop_readahead_done)(void *, const struct inode *, unsigned int, int);

typedef void (*btf_trace_nfs_aop_readpage)(void *, const struct inode *, loff_t, size_t);

typedef void (*btf_trace_nfs_aop_readpage_done)(void *, const struct inode *, loff_t, size_t, int);

typedef void (*btf_trace_nfs_async_rename_done)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_atomic_open_enter)(void *, const struct inode *, const struct nfs_open_context *, unsigned int);

typedef void (*btf_trace_nfs_atomic_open_exit)(void *, const struct inode *, const struct nfs_open_context *, unsigned int, int);

typedef void (*btf_trace_nfs_cb_badprinc)(void *, __be32, u32);

typedef void (*btf_trace_nfs_cb_no_clp)(void *, __be32, u32);

typedef void (*btf_trace_nfs_commit_done)(void *, const struct rpc_task *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_commit_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_comp_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_create_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_create_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_direct_commit_complete)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_resched_write)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_complete)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_completion)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_reschedule_io)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_schedule_iovec)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_fh_to_dentry)(void *, const struct super_block *, const struct nfs_fh *, u64, int);

typedef void (*btf_trace_nfs_fsync_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_fsync_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_getattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_getattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_initiate_commit)(void *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_initiate_read)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_initiate_write)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_invalidate_folio)(void *, const struct inode *, loff_t, size_t);

typedef void (*btf_trace_nfs_invalidate_mapping_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_invalidate_mapping_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_launder_folio_done)(void *, const struct inode *, loff_t, size_t, int);

typedef void (*btf_trace_nfs_link_enter)(void *, const struct inode *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_link_exit)(void *, const struct inode *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_local_open_fh)(void *, const struct nfs_fh *, fmode_t, int);

typedef void (*btf_trace_nfs_lookup_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_lookup_revalidate_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_revalidate_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_mkdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mkdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_mknod_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mknod_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_mount_assign)(void *, const char *, const char *);

typedef void (*btf_trace_nfs_mount_option)(void *, const struct fs_parameter *);

typedef void (*btf_trace_nfs_mount_path)(void *, const char *);

typedef void (*btf_trace_nfs_pgio_error)(void *, const struct nfs_pgio_header *, int, loff_t);

typedef void (*btf_trace_nfs_readdir_cache_fill)(void *, const struct file *, const __be32 *, u64, long unsigned int, unsigned int);

typedef void (*btf_trace_nfs_readdir_cache_fill_done)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_readdir_force_readdirplus)(void *, const struct inode *);

typedef void (*btf_trace_nfs_readdir_invalidate_cache_range)(void *, const struct inode *, loff_t, loff_t);

typedef void (*btf_trace_nfs_readdir_lookup)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_readdir_lookup_revalidate)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_readdir_lookup_revalidate_failed)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_readdir_uncached)(void *, const struct file *, const __be32 *, u64, long unsigned int, unsigned int);

typedef void (*btf_trace_nfs_readdir_uncached_done)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_readpage_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_short)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_refresh_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_remove_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_remove_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rename_enter)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rename_exit)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_revalidate_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_revalidate_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_rmdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rmdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_set_cache_invalid)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_set_inode_stale)(void *, const struct inode *);

typedef void (*btf_trace_nfs_setattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_setattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_sillyrename_unlink)(void *, const struct nfs_unlinkdata *, int);

typedef void (*btf_trace_nfs_size_grow)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_truncate)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_update)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_wcc)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_symlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_symlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_unlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_unlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_write_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_writeback_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_writeback_folio)(void *, const struct inode *, loff_t, size_t);

typedef void (*btf_trace_nfs_writeback_folio_done)(void *, const struct inode *, loff_t, size_t, int);

typedef void (*btf_trace_nfs_writeback_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_xdr_bad_filehandle)(void *, const struct xdr_stream *, int);

typedef void (*btf_trace_nfs_xdr_status)(void *, const struct xdr_stream *, int);

typedef void (*btf_trace_nlmclnt_grant)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nlmclnt_lock)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nlmclnt_test)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nlmclnt_unlock)(void *, const struct nlm_lock *, const struct sockaddr *, unsigned int, __be32);

typedef void (*btf_trace_nmi_handler)(void *, void *, s64, int);

typedef void (*btf_trace_notifier_register)(void *, void *);

typedef void (*btf_trace_notifier_run)(void *, void *);

typedef void (*btf_trace_notifier_unregister)(void *, void *);

typedef void (*btf_trace_nvme_async_event)(void *, struct nvme_ctrl *, u32);

typedef void (*btf_trace_nvme_complete_rq)(void *, struct request *);

typedef void (*btf_trace_nvme_setup_cmd)(void *, struct request *, struct nvme_command *);

typedef void (*btf_trace_nvme_sq)(void *, struct request *, __le16, int);

typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct *);

typedef void (*btf_trace_ovs_do_execute_action)(void *, struct datapath *, struct sk_buff *, struct sw_flow_key *, const struct nlattr *, int);

typedef void (*btf_trace_ovs_dp_upcall)(void *, struct datapath *, struct sk_buff *, const struct sw_flow_key *, const struct dp_upcall_info *);

typedef void (*btf_trace_page_fault_kernel)(void *, long unsigned int, struct pt_regs *, long unsigned int);

typedef void (*btf_trace_page_fault_user)(void *, long unsigned int, struct pt_regs *, long unsigned int);

typedef void (*btf_trace_page_pool_release)(void *, const struct page_pool *, s32, u32, u32);

typedef void (*btf_trace_page_pool_state_hold)(void *, const struct page_pool *, netmem_ref, u32);

typedef void (*btf_trace_page_pool_state_release)(void *, const struct page_pool *, netmem_ref, u32);

typedef void (*btf_trace_page_pool_update_nid)(void *, const struct page_pool *, int);

typedef void (*btf_trace_pelt_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_pelt_dl_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_hw_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_irq_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_rt_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_percpu_alloc_percpu)(void *, long unsigned int, bool, bool, size_t, size_t, void *, int, void *, size_t, gfp_t);

typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);

typedef void (*btf_trace_percpu_create_chunk)(void *, void *);

typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);

typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void *);

typedef void (*btf_trace_pm_qos_add_request)(void *, s32);

typedef void (*btf_trace_pm_qos_remove_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pm_qos_update_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pmap_register)(void *, u32, u32, int, short unsigned int);

typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);

typedef void (*btf_trace_prq_report)(void *, struct intel_iommu *, struct device *, u64, u64, u64, u64, long unsigned int);

typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);

typedef void (*btf_trace_purge_vmap_area_lazy)(void *, long unsigned int, long unsigned int, unsigned int);

typedef void (*btf_trace_qdisc_create)(void *, const struct Qdisc_ops *, struct net_device *, u32);

typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);

typedef void (*btf_trace_qdisc_destroy)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_enqueue)(void *, struct Qdisc *, const struct netdev_queue *, struct sk_buff *);

typedef void (*btf_trace_qdisc_reset)(void *, struct Qdisc *);

typedef void (*btf_trace_qgroup_meta_convert)(void *, const struct btrfs_root *, s64);

typedef void (*btf_trace_qgroup_meta_free_all_pertrans)(void *, struct btrfs_root *);

typedef void (*btf_trace_qgroup_meta_reserve)(void *, const struct btrfs_root *, s64, int);

typedef void (*btf_trace_qgroup_num_dirty_extents)(void *, const struct btrfs_fs_info *, u64, u64);

typedef void (*btf_trace_qgroup_update_counters)(void *, const struct btrfs_fs_info *, const struct btrfs_qgroup *, u64, u64);

typedef void (*btf_trace_qgroup_update_reserve)(void *, const struct btrfs_fs_info *, const struct btrfs_qgroup *, s64, int);

typedef void (*btf_trace_qi_submit)(void *, struct intel_iommu *, u64, u64, u64, u64);

typedef void (*btf_trace_raid56_read)(void *, const struct btrfs_raid_bio *, const struct bio *, const struct raid56_bio_trace_info *);

typedef void (*btf_trace_raid56_write)(void *, const struct btrfs_raid_bio *, const struct bio *, const struct raid56_bio_trace_info *);

typedef void (*btf_trace_rcu_barrier)(void *, const char *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_rcu_batch_end)(void *, const char *, int, char, char, char, char);

typedef void (*btf_trace_rcu_batch_start)(void *, const char *, long int, long int);

typedef void (*btf_trace_rcu_callback)(void *, const char *, struct callback_head *, long int);

typedef void (*btf_trace_rcu_exp_funnel_lock)(void *, const char *, u8, int, int, const char *);

typedef void (*btf_trace_rcu_exp_grace_period)(void *, const char *, long unsigned int, const char *);

typedef void (*btf_trace_rcu_fqs)(void *, const char *, long unsigned int, int, const char *);

typedef void (*btf_trace_rcu_future_grace_period)(void *, const char *, long unsigned int, long unsigned int, u8, int, int, const char *);

typedef void (*btf_trace_rcu_grace_period)(void *, const char *, long unsigned int, const char *);

typedef void (*btf_trace_rcu_grace_period_init)(void *, const char *, long unsigned int, u8, int, int, long unsigned int);

typedef void (*btf_trace_rcu_invoke_callback)(void *, const char *, struct callback_head *);

typedef void (*btf_trace_rcu_invoke_kfree_bulk_callback)(void *, const char *, long unsigned int, void **);

typedef void (*btf_trace_rcu_invoke_kvfree_callback)(void *, const char *, struct callback_head *, long unsigned int);

typedef void (*btf_trace_rcu_kvfree_callback)(void *, const char *, struct callback_head *, long unsigned int, long int);

typedef void (*btf_trace_rcu_preempt_task)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_rcu_quiescent_state_report)(void *, const char *, long unsigned int, long unsigned int, long unsigned int, u8, int, int, int);

typedef void (*btf_trace_rcu_segcb_stats)(void *, struct rcu_segcblist *, const char *);

typedef void (*btf_trace_rcu_sr_normal)(void *, const char *, struct callback_head *, const char *);

typedef void (*btf_trace_rcu_stall_warning)(void *, const char *, const char *);

typedef void (*btf_trace_rcu_torture_read)(void *, const char *, struct callback_head *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_rcu_unlock_preempted_task)(void *, const char *, long unsigned int, int);

typedef void (*btf_trace_rcu_utilization)(void *, const char *);

typedef void (*btf_trace_rcu_watching)(void *, const char *, long int, long int, int);

typedef void (*btf_trace_rdpmc)(void *, unsigned int, u64, int);

typedef void (*btf_trace_read_msr)(void *, unsigned int, u64, int);

typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, long unsigned int, long unsigned int, long unsigned int, int, bool);

typedef void (*btf_trace_register_session)(void *, struct l2tp_session *);

typedef void (*btf_trace_register_tunnel)(void *, struct l2tp_tunnel *);

typedef void (*btf_trace_remove_device_from_group)(void *, int, struct device *);

typedef void (*btf_trace_remove_migration_pte)(void *, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_reschedule_entry)(void *, int);

typedef void (*btf_trace_reschedule_exit)(void *, int);

typedef void (*btf_trace_rpc__auth_tooweak)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__bad_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__garbage_args)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__proc_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__stale_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__unparsable)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_bad_callhdr)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_bad_verifier)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_buf_alloc)(void *, const struct rpc_task *, int);

typedef void (*btf_trace_rpc_call_rpcerror)(void *, const struct rpc_task *, int, int);

typedef void (*btf_trace_rpc_call_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_clnt_clone_err)(void *, const struct rpc_clnt *, int);

typedef void (*btf_trace_rpc_clnt_free)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_killall)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_new)(void *, const struct rpc_clnt *, const struct rpc_xprt *, const struct rpc_create_args *);

typedef void (*btf_trace_rpc_clnt_new_err)(void *, const char *, const char *, int);

typedef void (*btf_trace_rpc_clnt_release)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt_err)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_shutdown)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_connect_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_request)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_retry_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_socket_close)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_connect)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_error)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_nospace)(void *, const struct rpc_rqst *, const struct sock_xprt *);

typedef void (*btf_trace_rpc_socket_reset_connection)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_shutdown)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_state_change)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_stats_latency)(void *, const struct rpc_task *, ktime_t, ktime_t, ktime_t);

typedef void (*btf_trace_rpc_task_begin)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_call_done)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_complete)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_end)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_run_action)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_signalled)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sleep)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_task_sync_sleep)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_wake)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_timeout)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_wakeup)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_timeout_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_tls_not_started)(void *, const struct rpc_clnt *, const struct rpc_xprt *);

typedef void (*btf_trace_rpc_tls_unavailable)(void *, const struct rpc_clnt *, const struct rpc_xprt *);

typedef void (*btf_trace_rpc_xdr_alignment)(void *, const struct xdr_stream *, size_t, unsigned int);

typedef void (*btf_trace_rpc_xdr_overflow)(void *, const struct xdr_stream *, size_t);

typedef void (*btf_trace_rpc_xdr_recvfrom)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_reply_pages)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_sendto)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpcb_bind_version_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_getport)(void *, const struct rpc_clnt *, const struct rpc_task *, unsigned int);

typedef void (*btf_trace_rpcb_prog_unavail_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_register)(void *, u32, u32, const char *, const char *);

typedef void (*btf_trace_rpcb_setport)(void *, const struct rpc_task *, int, short unsigned int);

typedef void (*btf_trace_rpcb_timeout_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unreachable_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unrecognized_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unregister)(void *, u32, u32, const char *);

typedef void (*btf_trace_rpcgss_bad_seqno)(void *, const struct rpc_task *, u32, u32);

typedef void (*btf_trace_rpcgss_context)(void *, u32, long unsigned int, long unsigned int, unsigned int, unsigned int, const u8 *);

typedef void (*btf_trace_rpcgss_createauth)(void *, unsigned int, int);

typedef void (*btf_trace_rpcgss_ctx_destroy)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_ctx_init)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_get_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_import_ctx)(void *, int);

typedef void (*btf_trace_rpcgss_need_reencode)(void *, const struct rpc_task *, u32, bool);

typedef void (*btf_trace_rpcgss_oid_to_mech)(void *, const char *);

typedef void (*btf_trace_rpcgss_seqno)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_svc_accept_upcall)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_authenticate)(void *, const struct svc_rqst *, const struct rpc_gss_wire_cred *);

typedef void (*btf_trace_rpcgss_svc_get_mic)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_mic)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_bad)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_large)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_low)(void *, const struct svc_rqst *, u32, u32, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_seen)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_unwrap)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_unwrap_failed)(void *, const struct svc_rqst *);

typedef void (*btf_trace_rpcgss_svc_wrap)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_wrap_failed)(void *, const struct svc_rqst *);

typedef void (*btf_trace_rpcgss_unwrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_unwrap_failed)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_upcall_msg)(void *, const char *);

typedef void (*btf_trace_rpcgss_upcall_result)(void *, u32, int);

typedef void (*btf_trace_rpcgss_update_slack)(void *, const struct rpc_task *, const struct rpc_auth *);

typedef void (*btf_trace_rpcgss_verify_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_wrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpm_idle)(void *, struct device *, int);

typedef void (*btf_trace_rpm_resume)(void *, struct device *, int);

typedef void (*btf_trace_rpm_return_int)(void *, struct device *, long unsigned int, int);

typedef void (*btf_trace_rpm_status)(void *, struct device *, enum rpm_status);

typedef void (*btf_trace_rpm_suspend)(void *, struct device *, int);

typedef void (*btf_trace_rpm_usage)(void *, struct device *, int);

typedef void (*btf_trace_rseq_ip_fixup)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_rseq_update)(void *, struct task_struct *);

typedef void (*btf_trace_rss_stat)(void *, struct mm_struct *, int);

typedef void (*btf_trace_rtc_alarm_irq_enable)(void *, unsigned int, int);

typedef void (*btf_trace_rtc_irq_set_freq)(void *, int, int);

typedef void (*btf_trace_rtc_irq_set_state)(void *, int, int);

typedef void (*btf_trace_rtc_read_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_read_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_set_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_timer_dequeue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_enqueue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_fired)(void *, struct rtc_timer *);

typedef void (*btf_trace_run_delayed_data_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *);

typedef void (*btf_trace_run_delayed_ref_head)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_head *, int);

typedef void (*btf_trace_run_delayed_tree_ref)(void *, const struct btrfs_fs_info *, const struct btrfs_delayed_ref_node *);

typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sched_compute_energy_tp)(void *, struct task_struct *, int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_sched_cpu_capacity_tp)(void *, struct rq *);

typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);

typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);

typedef void (*btf_trace_sched_kthread_work_execute_end)(void *, struct kthread_work *, kthread_work_func_t);

typedef void (*btf_trace_sched_kthread_work_execute_start)(void *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_queue_work)(void *, struct kthread_worker *, struct kthread_work *);

typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);

typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_overutilized_tp)(void *, struct root_domain *, bool);

typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_prepare_exec)(void *, struct task_struct *, struct linux_binprm *);

typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);

typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);

typedef void (*btf_trace_sched_stat_blocked)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_iowait)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_sleep)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stat_wait)(void *, struct task_struct *, u64);

typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *, unsigned int);

typedef void (*btf_trace_sched_update_nr_running_tp)(void *, struct rq *, int);

typedef void (*btf_trace_sched_util_est_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_sched_util_est_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);

typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);

typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);

typedef void (*btf_trace_scsi_dispatch_cmd_done)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_error)(void *, struct scsi_cmnd *, int);

typedef void (*btf_trace_scsi_dispatch_cmd_start)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_timeout)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_eh_wakeup)(void *, struct Scsi_Host *);

typedef void (*btf_trace_sctp_probe)(void *, const struct sctp_endpoint *, const struct sctp_association *, struct sctp_chunk *);

typedef void (*btf_trace_sctp_probe_path)(void *, struct sctp_transport *, const struct sctp_association *);

typedef void (*btf_trace_session_pkt_expired)(void *, struct l2tp_session *, u32);

typedef void (*btf_trace_session_pkt_oos)(void *, struct l2tp_session *, u32);

typedef void (*btf_trace_session_pkt_outside_rx_window)(void *, struct l2tp_session *, u32);

typedef void (*btf_trace_session_seqnum_lns_disable)(void *, struct l2tp_session *);

typedef void (*btf_trace_session_seqnum_lns_enable)(void *, struct l2tp_session *);

typedef void (*btf_trace_session_seqnum_reset)(void *, struct l2tp_session *);

typedef void (*btf_trace_session_seqnum_update)(void *, struct l2tp_session *);

typedef void (*btf_trace_set_migration_pte)(void *, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);

typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);

typedef void (*btf_trace_sk_data_ready)(void *, const struct sock *);

typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);

typedef void (*btf_trace_skip_task_reaping)(void *, int);

typedef void (*btf_trace_smbus_read)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int);

typedef void (*btf_trace_smbus_reply)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *, int);

typedef void (*btf_trace_smbus_result)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, int);

typedef void (*btf_trace_smbus_write)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *);

typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long int, int);

typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_sock_recv_length)(void *, struct sock *, int, int);

typedef void (*btf_trace_sock_send_length)(void *, struct sock *, int, int);

typedef void (*btf_trace_softirq_entry)(void *, unsigned int);

typedef void (*btf_trace_softirq_exit)(void *, unsigned int);

typedef void (*btf_trace_softirq_raise)(void *, unsigned int);

typedef void (*btf_trace_spurious_apic_entry)(void *, int);

typedef void (*btf_trace_spurious_apic_exit)(void *, int);

typedef void (*btf_trace_start_task_reaping)(void *, int);

typedef void (*btf_trace_subflow_check_data_avail)(void *, __u8, struct sk_buff *);

typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);

typedef void (*btf_trace_svc_alloc_arg_err)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_svc_authenticate)(void *, const struct svc_rqst *, enum svc_auth_status);

typedef void (*btf_trace_svc_defer)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_defer_drop)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_queue)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_recv)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_drop)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_noregister)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_process)(void *, const struct svc_rqst *, const char *);

typedef void (*btf_trace_svc_register)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_replace_page_err)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_send)(void *, const struct svc_rqst *, int);

typedef void (*btf_trace_svc_stats_latency)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_tls_not_started)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_start)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_timed_out)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_unavailable)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_tls_upcall)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_unregister)(void *, const char *, const u32, int);

typedef void (*btf_trace_svc_wake_up)(void *, int);

typedef void (*btf_trace_svc_xdr_recvfrom)(void *, const struct xdr_buf *);

typedef void (*btf_trace_svc_xdr_sendto)(void *, __be32, const struct xdr_buf *);

typedef void (*btf_trace_svc_xprt_accept)(void *, const struct svc_xprt *, const char *);

typedef void (*btf_trace_svc_xprt_close)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_create_err)(void *, const char *, const char *, struct sockaddr *, size_t, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_dequeue)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_xprt_detach)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_enqueue)(void *, const struct svc_xprt *, long unsigned int);

typedef void (*btf_trace_svc_xprt_free)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_no_write_space)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svcsock_accept_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_svcsock_data_ready)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_free)(void *, const void *, const struct socket *);

typedef void (*btf_trace_svcsock_getpeername_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_svcsock_marker)(void *, const struct svc_xprt *, __be32);

typedef void (*btf_trace_svcsock_new)(void *, const void *, const struct socket *);

typedef void (*btf_trace_svcsock_tcp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_eagain)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_short)(void *, const struct svc_xprt *, u32, u32);

typedef void (*btf_trace_svcsock_tcp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_state)(void *, const struct svc_xprt *, const struct socket *);

typedef void (*btf_trace_svcsock_udp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_write_space)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_swiotlb_bounced)(void *, struct device *, dma_addr_t, size_t);

typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, long unsigned int);

typedef void (*btf_trace_task_prctl_unknown)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);

typedef void (*btf_trace_tasklet_entry)(void *, struct tasklet_struct *, void *);

typedef void (*btf_trace_tasklet_exit)(void *, struct tasklet_struct *, void *);

typedef void (*btf_trace_tcp_ao_handshake_failure)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);

typedef void (*btf_trace_tcp_ao_key_not_found)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);

typedef void (*btf_trace_tcp_ao_mismatch)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);

typedef void (*btf_trace_tcp_ao_rcv_sne_update)(void *, const struct sock *, __u32);

typedef void (*btf_trace_tcp_ao_rnext_request)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);

typedef void (*btf_trace_tcp_ao_snd_sne_update)(void *, const struct sock *, __u32);

typedef void (*btf_trace_tcp_ao_synack_no_key)(void *, const struct sock *, const __u8, const __u8);

typedef void (*btf_trace_tcp_ao_wrong_maclen)(void *, const struct sock *, const struct sk_buff *, const __u8, const __u8, const __u8);

typedef void (*btf_trace_tcp_bad_csum)(void *, const struct sk_buff *);

typedef void (*btf_trace_tcp_cong_state_set)(void *, struct sock *, const u8);

typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);

typedef void (*btf_trace_tcp_hash_ao_required)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_hash_bad_header)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_hash_md5_mismatch)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_hash_md5_required)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_hash_md5_unexpected)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);

typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);

typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);

typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *, const enum sk_rst_reason);

typedef void (*btf_trace_test_pages_isolated)(void *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_thermal_apic_entry)(void *, int);

typedef void (*btf_trace_thermal_apic_exit)(void *, int);

typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);

typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);

typedef void (*btf_trace_threshold_apic_entry)(void *, int);

typedef void (*btf_trace_threshold_apic_exit)(void *, int);

typedef void (*btf_trace_tick_stop)(void *, int, int);

typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lease *);

typedef void (*btf_trace_timer_base_idle)(void *, bool, unsigned int);

typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);

typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);

typedef void (*btf_trace_timer_init)(void *, struct timer_list *);

typedef void (*btf_trace_timer_start)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_tipc_l2_device_event)(void *, struct net_device *, struct tipc_bearer *, long unsigned int);

typedef void (*btf_trace_tipc_link_bc_ack)(void *, struct tipc_link *, u16, u16, struct sk_buff_head *);

typedef void (*btf_trace_tipc_link_conges)(void *, struct tipc_link *, u16, const char *);

typedef void (*btf_trace_tipc_link_dump)(void *, struct tipc_link *, u16, const char *);

typedef void (*btf_trace_tipc_link_fsm)(void *, const char *, u32, u32, int);

typedef void (*btf_trace_tipc_link_reset)(void *, struct tipc_link *, u16, const char *);

typedef void (*btf_trace_tipc_link_retrans)(void *, struct tipc_link *, u16, u16, struct sk_buff_head *);

typedef void (*btf_trace_tipc_link_timeout)(void *, struct tipc_link *, u16, const char *);

typedef void (*btf_trace_tipc_link_too_silent)(void *, struct tipc_link *, u16, const char *);

typedef void (*btf_trace_tipc_list_dump)(void *, struct sk_buff_head *, bool, const char *);

typedef void (*btf_trace_tipc_node_check_state)(void *, struct tipc_node *, bool, const char *);

typedef void (*btf_trace_tipc_node_create)(void *, struct tipc_node *, bool, const char *);

typedef void (*btf_trace_tipc_node_delete)(void *, struct tipc_node *, bool, const char *);

typedef void (*btf_trace_tipc_node_dump)(void *, struct tipc_node *, bool, const char *);

typedef void (*btf_trace_tipc_node_fsm)(void *, const char *, u32, u32, int);

typedef void (*btf_trace_tipc_node_link_down)(void *, struct tipc_node *, bool, const char *);

typedef void (*btf_trace_tipc_node_link_up)(void *, struct tipc_node *, bool, const char *);

typedef void (*btf_trace_tipc_node_lost_contact)(void *, struct tipc_node *, bool, const char *);

typedef void (*btf_trace_tipc_node_reset_links)(void *, struct tipc_node *, bool, const char *);

typedef void (*btf_trace_tipc_node_timeout)(void *, struct tipc_node *, bool, const char *);

typedef void (*btf_trace_tipc_proto_build)(void *, struct sk_buff *, bool, const char *);

typedef void (*btf_trace_tipc_proto_rcv)(void *, struct sk_buff *, bool, const char *);

typedef void (*btf_trace_tipc_sk_advance_rx)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_create)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_drop_msg)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_dump)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_filter_rcv)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_overlimit1)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_overlimit2)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_poll)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_rej_msg)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_release)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_sendmcast)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_sendmsg)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_sendstream)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_sk_shutdown)(void *, struct sock *, struct sk_buff *, u16, const char *);

typedef void (*btf_trace_tipc_skb_dump)(void *, struct sk_buff *, bool, const char *);

typedef void (*btf_trace_tlb_flush)(void *, int, long unsigned int);

typedef void (*btf_trace_tls_alert_recv)(void *, const struct sock *, unsigned char, unsigned char);

typedef void (*btf_trace_tls_alert_send)(void *, const struct sock *, unsigned char, unsigned char);

typedef void (*btf_trace_tls_contenttype)(void *, const struct sock *, unsigned char);

typedef void (*btf_trace_tls_device_decrypted)(void *, struct sock *, u32, u8 *, u32, bool, bool);

typedef void (*btf_trace_tls_device_offload_set)(void *, struct sock *, int, u32, u8 *, int);

typedef void (*btf_trace_tls_device_rx_resync_nh_delay)(void *, struct sock *, u32, u32);

typedef void (*btf_trace_tls_device_rx_resync_nh_schedule)(void *, struct sock *);

typedef void (*btf_trace_tls_device_rx_resync_send)(void *, struct sock *, u32, u8 *, int);

typedef void (*btf_trace_tls_device_tx_resync_req)(void *, struct sock *, u32, u32);

typedef void (*btf_trace_tls_device_tx_resync_send)(void *, struct sock *, u32, u8 *);

typedef void (*btf_trace_tmigr_connect_child_parent)(void *, struct tmigr_group *);

typedef void (*btf_trace_tmigr_connect_cpu_parent)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_cpu_active)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_cpu_idle)(void *, struct tmigr_cpu *, u64);

typedef void (*btf_trace_tmigr_cpu_new_timer)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_cpu_new_timer_idle)(void *, struct tmigr_cpu *, u64);

typedef void (*btf_trace_tmigr_cpu_offline)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_cpu_online)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_group_set)(void *, struct tmigr_group *);

typedef void (*btf_trace_tmigr_group_set_cpu_active)(void *, struct tmigr_group *, union tmigr_state, u32);

typedef void (*btf_trace_tmigr_group_set_cpu_inactive)(void *, struct tmigr_group *, union tmigr_state, u32);

typedef void (*btf_trace_tmigr_handle_remote)(void *, struct tmigr_group *);

typedef void (*btf_trace_tmigr_handle_remote_cpu)(void *, struct tmigr_cpu *);

typedef void (*btf_trace_tmigr_update_events)(void *, struct tmigr_group *, struct tmigr_group *, union tmigr_state, union tmigr_state, u64);

typedef void (*btf_trace_track_foreign_dirty)(void *, struct folio *, struct bdi_writeback *);

typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *, struct sk_buff *);

typedef void (*btf_trace_unmap)(void *, long unsigned int, size_t, size_t);

typedef void (*btf_trace_update_bytes_may_use)(void *, const struct btrfs_fs_info *, const struct btrfs_space_info *, u64, s64);

typedef void (*btf_trace_update_bytes_pinned)(void *, const struct btrfs_fs_info *, const struct btrfs_space_info *, u64, s64);

typedef void (*btf_trace_update_bytes_zone_unusable)(void *, const struct btrfs_fs_info *, const struct btrfs_space_info *, u64, s64);

typedef void (*btf_trace_vector_activate)(void *, unsigned int, bool, bool, bool);

typedef void (*btf_trace_vector_alloc)(void *, unsigned int, unsigned int, bool, int);

typedef void (*btf_trace_vector_alloc_managed)(void *, unsigned int, unsigned int, int);

typedef void (*btf_trace_vector_clear)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_vector_config)(void *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_vector_deactivate)(void *, unsigned int, bool, bool, bool);

typedef void (*btf_trace_vector_free_moved)(void *, unsigned int, unsigned int, unsigned int, bool);

typedef void (*btf_trace_vector_reserve)(void *, unsigned int, int);

typedef void (*btf_trace_vector_reserve_managed)(void *, unsigned int, int);

typedef void (*btf_trace_vector_setup)(void *, unsigned int, bool, int);

typedef void (*btf_trace_vector_teardown)(void *, unsigned int, bool, bool);

typedef void (*btf_trace_vector_update)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_virtio_gpu_cmd_queue)(void *, struct virtqueue *, struct virtio_gpu_ctrl_hdr *, u32);

typedef void (*btf_trace_virtio_gpu_cmd_response)(void *, struct virtqueue *, struct virtio_gpu_ctrl_hdr *, u32);

typedef void (*btf_trace_virtio_transport_alloc_pkt)(void *, __u32, __u32, __u32, __u32, __u32, __u16, __u16, __u32, bool);

typedef void (*btf_trace_virtio_transport_recv_pkt)(void *, __u32, __u32, __u32, __u32, __u32, __u16, __u16, __u32, __u32, __u32);

typedef void (*btf_trace_vlv_fifo_size)(void *, struct intel_crtc *, u32, u32, u32);

typedef void (*btf_trace_vlv_wm)(void *, struct intel_crtc *, const struct vlv_wm_values *);

typedef void (*btf_trace_vm_unmapped_area)(void *, long unsigned int, struct vm_unmapped_area_info *);

typedef void (*btf_trace_vma_mas_szero)(void *, struct maple_tree *, long unsigned int, long unsigned int);

typedef void (*btf_trace_vma_store)(void *, struct maple_tree *, struct vm_area_struct *);

typedef void (*btf_trace_wake_reaper)(void *, int);

typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);

typedef void (*btf_trace_watchdog_ping)(void *, struct watchdog_device *, int);

typedef void (*btf_trace_watchdog_set_timeout)(void *, struct watchdog_device *, unsigned int, int);

typedef void (*btf_trace_watchdog_start)(void *, struct watchdog_device *, int);

typedef void (*btf_trace_watchdog_stop)(void *, struct watchdog_device *, int);

typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);

typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *, work_func_t);

typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_queue_work)(void *, int, struct pool_workqueue *, struct work_struct *);

typedef void (*btf_trace_write_msr)(void *, unsigned int, u64, int);

typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);

typedef void (*btf_trace_writeback_dirty_folio)(void *, struct folio *, struct address_space *);

typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);

typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);

typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);

typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_pages_written)(void *, long int);

typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, long unsigned int, int);

typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);

typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);

typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_x86_fpu_after_restore)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_after_save)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_before_restore)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_before_save)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_copy_dst)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_copy_src)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_dropped)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_init_state)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_regs_activated)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_regs_deactivated)(void *, struct fpu *);

typedef void (*btf_trace_x86_fpu_xstate_check_failed)(void *, struct fpu *);

typedef void (*btf_trace_x86_platform_ipi_entry)(void *, int);

typedef void (*btf_trace_x86_platform_ipi_exit)(void *, int);

typedef void (*btf_trace_xchk_block_error)(void *, struct xfs_scrub *, xfs_daddr_t, void *);

typedef void (*btf_trace_xchk_block_preen)(void *, struct xfs_scrub *, xfs_daddr_t, void *);

typedef void (*btf_trace_xchk_btree_error)(void *, struct xfs_scrub *, struct xfs_btree_cur *, int, void *);

typedef void (*btf_trace_xchk_btree_key)(void *, struct xfs_scrub *, struct xfs_btree_cur *, int);

typedef void (*btf_trace_xchk_btree_op_error)(void *, struct xfs_scrub *, struct xfs_btree_cur *, int, int, void *);

typedef void (*btf_trace_xchk_btree_rec)(void *, struct xfs_scrub *, struct xfs_btree_cur *, int);

typedef void (*btf_trace_xchk_deadlock_retry)(void *, struct xfs_inode *, struct xfs_scrub_metadata *, int);

typedef void (*btf_trace_xchk_dir_defer)(void *, struct xfs_inode *, const struct xfs_name *, xfs_ino_t);

typedef void (*btf_trace_xchk_dir_slowpath)(void *, struct xfs_inode *, const struct xfs_name *, xfs_ino_t);

typedef void (*btf_trace_xchk_dir_ultraslowpath)(void *, struct xfs_inode *, const struct xfs_name *, xfs_ino_t);

typedef void (*btf_trace_xchk_dirpath_badgen)(void *, struct xfs_scrub *, struct xfs_inode *, unsigned int, unsigned int, const struct xfs_name *, const struct xfs_parent_rec *);

typedef void (*btf_trace_xchk_dirpath_changed)(void *, struct xfs_scrub *, unsigned int, unsigned int, const struct xfs_inode *, const struct xfs_inode *, const struct xfs_name *);

typedef void (*btf_trace_xchk_dirpath_crosses_tree)(void *, struct xfs_scrub *, struct xfs_inode *, unsigned int, unsigned int, const struct xfs_name *, const struct xfs_parent_rec *);

typedef void (*btf_trace_xchk_dirpath_disappeared)(void *, struct xfs_scrub *, struct xfs_inode *, unsigned int, unsigned int, const struct xfs_name *, const struct xfs_parent_rec *);

typedef void (*btf_trace_xchk_dirpath_evaluate_path)(void *, struct xfs_scrub *, long long unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_xchk_dirpath_found_next_step)(void *, struct xfs_scrub *, struct xfs_inode *, unsigned int, unsigned int, const struct xfs_name *, const struct xfs_parent_rec *);

typedef void (*btf_trace_xchk_dirpath_nondir_parent)(void *, struct xfs_scrub *, struct xfs_inode *, unsigned int, unsigned int, const struct xfs_name *, const struct xfs_parent_rec *);

typedef void (*btf_trace_xchk_dirpath_set_outcome)(void *, struct xfs_scrub *, long long unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_xchk_dirpath_unlinked_parent)(void *, struct xfs_scrub *, struct xfs_inode *, unsigned int, unsigned int, const struct xfs_name *, const struct xfs_parent_rec *);

typedef void (*btf_trace_xchk_dirpath_walk_upwards)(void *, struct xfs_scrub *, struct xfs_inode *, unsigned int, const struct xfs_name *, const struct xfs_parent_rec *);

typedef void (*btf_trace_xchk_dirtree_create_path)(void *, struct xfs_scrub *, struct xfs_inode *, unsigned int, const struct xfs_name *, const struct xfs_parent_rec *);

typedef void (*btf_trace_xchk_dirtree_done)(void *, struct xfs_inode *, struct xfs_scrub_metadata *, int);

typedef void (*btf_trace_xchk_dirtree_evaluate)(void *, const struct xchk_dirtree *, const struct xchk_dirtree_outcomes *);

typedef void (*btf_trace_xchk_dirtree_live_update)(void *, struct xfs_scrub *, const struct xfs_inode *, int, const struct xfs_inode *, int, const struct xfs_name *);

typedef void (*btf_trace_xchk_dirtree_start)(void *, struct xfs_inode *, struct xfs_scrub_metadata *, int);

typedef void (*btf_trace_xchk_done)(void *, struct xfs_inode *, struct xfs_scrub_metadata *, int);

typedef void (*btf_trace_xchk_dquot_iter)(void *, struct xchk_dqiter *, uint64_t);

typedef void (*btf_trace_xchk_dquot_iter_advance_bmap)(void *, struct xchk_dqiter *, uint64_t);

typedef void (*btf_trace_xchk_dquot_iter_advance_incore)(void *, struct xchk_dqiter *, uint64_t);

typedef void (*btf_trace_xchk_dquot_iter_revalidate_bmap)(void *, struct xchk_dqiter *, uint64_t);

typedef void (*btf_trace_xchk_fblock_error)(void *, struct xfs_scrub *, int, xfs_fileoff_t, void *);

typedef void (*btf_trace_xchk_fblock_preen)(void *, struct xfs_scrub *, int, xfs_fileoff_t, void *);

typedef void (*btf_trace_xchk_fblock_warning)(void *, struct xfs_scrub *, int, xfs_fileoff_t, void *);

typedef void (*btf_trace_xchk_file_op_error)(void *, struct xfs_scrub *, int, xfs_fileoff_t, int, void *);

typedef void (*btf_trace_xchk_fs_error)(void *, struct xfs_scrub *, xfs_daddr_t, void *);

typedef void (*btf_trace_xchk_fscounters_calc)(void *, struct xfs_mount *, uint64_t, uint64_t, uint64_t, uint64_t);

typedef void (*btf_trace_xchk_fscounters_within_range)(void *, struct xfs_mount *, uint64_t, int64_t, int64_t);

typedef void (*btf_trace_xchk_fsfreeze)(void *, struct xfs_scrub *, int);

typedef void (*btf_trace_xchk_fsgates_disable)(void *, struct xfs_scrub *, unsigned int);

typedef void (*btf_trace_xchk_fsgates_enable)(void *, struct xfs_scrub *, unsigned int);

typedef void (*btf_trace_xchk_fsthaw)(void *, struct xfs_scrub *, int);

typedef void (*btf_trace_xchk_iallocbt_check_cluster)(void *, const struct xfs_perag *, xfs_agino_t, xfs_daddr_t, short unsigned int, unsigned int, unsigned int, uint16_t, uint16_t, unsigned int);

typedef void (*btf_trace_xchk_ifork_btree_error)(void *, struct xfs_scrub *, struct xfs_btree_cur *, int, void *);

typedef void (*btf_trace_xchk_ifork_btree_op_error)(void *, struct xfs_scrub *, struct xfs_btree_cur *, int, int, void *);

typedef void (*btf_trace_xchk_incomplete)(void *, struct xfs_scrub *, void *);

typedef void (*btf_trace_xchk_ino_error)(void *, struct xfs_scrub *, xfs_ino_t, void *);

typedef void (*btf_trace_xchk_ino_preen)(void *, struct xfs_scrub *, xfs_ino_t, void *);

typedef void (*btf_trace_xchk_ino_warning)(void *, struct xfs_scrub *, xfs_ino_t, void *);

typedef void (*btf_trace_xchk_inode_is_allocated)(void *, struct xfs_inode *);

typedef void (*btf_trace_xchk_iscan_advance_ag)(void *, struct xchk_iscan *);

typedef void (*btf_trace_xchk_iscan_agi_retry_wait)(void *, struct xchk_iscan *);

typedef void (*btf_trace_xchk_iscan_iget)(void *, struct xchk_iscan *, int);

typedef void (*btf_trace_xchk_iscan_iget_batch)(void *, struct xfs_mount *, struct xchk_iscan *, unsigned int, unsigned int);

typedef void (*btf_trace_xchk_iscan_iget_retry_wait)(void *, struct xchk_iscan *);

typedef void (*btf_trace_xchk_iscan_move_cursor)(void *, struct xchk_iscan *);

typedef void (*btf_trace_xchk_iscan_skip)(void *, struct xchk_iscan *);

typedef void (*btf_trace_xchk_iscan_start)(void *, struct xchk_iscan *, xfs_ino_t);

typedef void (*btf_trace_xchk_iscan_visit)(void *, struct xchk_iscan *);

typedef void (*btf_trace_xchk_iscan_want_live_update)(void *, struct xchk_iscan *, xfs_ino_t);

typedef void (*btf_trace_xchk_metapath_lookup)(void *, struct xfs_scrub *, const char *, struct xfs_inode *, xfs_ino_t);

typedef void (*btf_trace_xchk_nlinks_check_zero)(void *, struct xfs_mount *, xfs_ino_t, const struct xchk_nlink *);

typedef void (*btf_trace_xchk_nlinks_collect_dirent)(void *, struct xfs_mount *, struct xfs_inode *, xfs_ino_t, const struct xfs_name *);

typedef void (*btf_trace_xchk_nlinks_collect_metafile)(void *, struct xfs_mount *, xfs_ino_t);

typedef void (*btf_trace_xchk_nlinks_collect_pptr)(void *, struct xfs_mount *, struct xfs_inode *, const struct xfs_name *, const struct xfs_parent_rec *);

typedef void (*btf_trace_xchk_nlinks_compare_inode)(void *, struct xfs_mount *, struct xfs_inode *, const struct xchk_nlink *);

typedef void (*btf_trace_xchk_nlinks_live_update)(void *, struct xfs_mount *, const struct xfs_inode *, int, xfs_ino_t, int, const char *, unsigned int);

typedef void (*btf_trace_xchk_nlinks_update_incore)(void *, struct xfs_mount *, xfs_ino_t, const struct xchk_nlink *, int, int, int);

typedef void (*btf_trace_xchk_op_error)(void *, struct xfs_scrub *, xfs_agnumber_t, xfs_agblock_t, int, void *);

typedef void (*btf_trace_xchk_parent_defer)(void *, struct xfs_inode *, const struct xfs_name *, xfs_ino_t);

typedef void (*btf_trace_xchk_parent_slowpath)(void *, struct xfs_inode *, const struct xfs_name *, xfs_ino_t);

typedef void (*btf_trace_xchk_parent_ultraslowpath)(void *, struct xfs_inode *, const struct xfs_name *, xfs_ino_t);

typedef void (*btf_trace_xchk_qcheck_error)(void *, struct xfs_scrub *, xfs_dqtype_t, xfs_dqid_t, void *);

typedef void (*btf_trace_xchk_refcount_incorrect)(void *, const struct xfs_perag *, const struct xfs_refcount_irec *, xfs_nlink_t);

typedef void (*btf_trace_xchk_scrubv_barrier_fail)(void *, struct xfs_mount *, struct xfs_scrub_vec_head *, unsigned int, struct xfs_scrub_vec *);

typedef void (*btf_trace_xchk_scrubv_item)(void *, struct xfs_mount *, struct xfs_scrub_vec_head *, unsigned int, struct xfs_scrub_vec *);

typedef void (*btf_trace_xchk_scrubv_outcome)(void *, struct xfs_mount *, struct xfs_scrub_vec_head *, unsigned int, struct xfs_scrub_vec *);

typedef void (*btf_trace_xchk_scrubv_start)(void *, struct xfs_inode *, struct xfs_scrub_vec_head *);

typedef void (*btf_trace_xchk_start)(void *, struct xfs_inode *, struct xfs_scrub_metadata *, int);

typedef void (*btf_trace_xchk_xref_error)(void *, struct xfs_scrub *, int, void *);

typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int, struct xdp_cpumap_stats *);

typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct net_device *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);

typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xfarray_create)(void *, struct xfarray *, long long unsigned int);

typedef void (*btf_trace_xfarray_foliosort)(void *, struct xfarray_sortinfo *, uint64_t, uint64_t);

typedef void (*btf_trace_xfarray_isort)(void *, struct xfarray_sortinfo *, uint64_t, uint64_t);

typedef void (*btf_trace_xfarray_qsort)(void *, struct xfarray_sortinfo *, uint64_t, uint64_t);

typedef void (*btf_trace_xfarray_sort)(void *, struct xfarray_sortinfo *, size_t);

typedef void (*btf_trace_xfarray_sort_scan)(void *, struct xfarray_sortinfo *, long long unsigned int);

typedef void (*btf_trace_xfarray_sort_stats)(void *, struct xfarray_sortinfo *, int);

typedef void (*btf_trace_xfile_create)(void *, struct xfile *);

typedef void (*btf_trace_xfile_destroy)(void *, struct xfile *);

typedef void (*btf_trace_xfile_discard)(void *, struct xfile *, loff_t, long long unsigned int);

typedef void (*btf_trace_xfile_get_folio)(void *, struct xfile *, loff_t, long long unsigned int);

typedef void (*btf_trace_xfile_load)(void *, struct xfile *, loff_t, long long unsigned int);

typedef void (*btf_trace_xfile_put_folio)(void *, struct xfile *, loff_t, long long unsigned int);

typedef void (*btf_trace_xfile_seek_data)(void *, struct xfile *, loff_t, long long unsigned int);

typedef void (*btf_trace_xfile_store)(void *, struct xfile *, loff_t, long long unsigned int);

typedef void (*btf_trace_xfs_ag_resv_alloc_extent)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_critical)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_free)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_free_extent)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_init)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_ag_resv_init_error)(void *, const struct xfs_perag *, int, long unsigned int);

typedef void (*btf_trace_xfs_ag_resv_needed)(void *, struct xfs_perag *, enum xfs_ag_resv_type, xfs_extlen_t);

typedef void (*btf_trace_xfs_agf)(void *, struct xfs_mount *, struct xfs_agf *, int, long unsigned int);

typedef void (*btf_trace_xfs_agfl_free_deferred)(void *, struct xfs_mount *, struct xfs_extent_free_item *);

typedef void (*btf_trace_xfs_agfl_reset)(void *, struct xfs_mount *, struct xfs_agf *, int, long unsigned int);

typedef void (*btf_trace_xfs_ail_delete)(void *, struct xfs_log_item *, xfs_lsn_t, xfs_lsn_t);

typedef void (*btf_trace_xfs_ail_flushing)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_ail_insert)(void *, struct xfs_log_item *, xfs_lsn_t, xfs_lsn_t);

typedef void (*btf_trace_xfs_ail_locked)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_ail_move)(void *, struct xfs_log_item *, xfs_lsn_t, xfs_lsn_t);

typedef void (*btf_trace_xfs_ail_pinned)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_ail_push)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_alloc_cur)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_cur_check)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, xfs_extlen_t, bool);

typedef void (*btf_trace_xfs_alloc_cur_left)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_cur_lookup)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_cur_lookup_done)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_cur_right)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_exact_done)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_exact_error)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_exact_notfound)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_file_space)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_alloc_near_busy)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_near_error)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_near_first)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_near_noentry)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_near_nominleft)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_read_agf)(void *, const struct xfs_perag *);

typedef void (*btf_trace_xfs_alloc_size_busy)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_done)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_error)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_neither)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_noentry)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_size_nominleft)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_small_done)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_small_error)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_small_freelist)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_small_notenough)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_allfailed)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_badargs)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_exact_bno)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_finish)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_first_ag)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_loopfailed)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_near_bno)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_noagbp)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_nofix)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_skip_deadlock)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_start_ag)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_alloc_vextent_this_ag)(void *, struct xfs_alloc_arg *);

typedef void (*btf_trace_xfs_attr_defer_add)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_fillstate)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_add)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_add_new)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_add_old)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_add_work)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_addname_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_leaf_clearflag)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_compact)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_create)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_flipflags)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_get)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_list)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_leaf_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_rebalance)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_remove)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_setflag)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_split)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_split_after)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_split_before)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_to_node)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_to_sf)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_toosmall)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_leaf_unbalance)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_list_add)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_full)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_leaf)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_leaf_end)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_node_descend)(void *, struct xfs_attr_list_context *, struct xfs_da_node_entry *);

typedef void (*btf_trace_xfs_attr_list_notfound)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_sf)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_sf_all)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_list_wrong_blk)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_node_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_node_addname_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_node_get)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_node_list)(void *, struct xfs_attr_list_context *);

typedef void (*btf_trace_xfs_attr_node_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_node_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_refillstate)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_remove_iter_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_rmtval_alloc)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_rmtval_get)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_rmtval_remove_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_rmtval_set)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_set_iter_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_sf_add)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_addname_return)(void *, int, struct xfs_inode *);

typedef void (*btf_trace_xfs_attr_sf_create)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_remove)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_attr_sf_to_leaf)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_blockgc_flush_all)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_blockgc_free_space)(void *, struct xfs_mount *, struct xfs_icwalk *, long unsigned int);

typedef void (*btf_trace_xfs_blockgc_start)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_blockgc_stop)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_blockgc_worker)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_bmap_defer)(void *, struct xfs_bmap_intent *);

typedef void (*btf_trace_xfs_bmap_deferred)(void *, struct xfs_bmap_intent *);

typedef void (*btf_trace_xfs_bmap_post_update)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_bmap_pre_update)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_btree_alloc_block)(void *, struct xfs_btree_cur *, union xfs_btree_ptr *, int, int);

typedef void (*btf_trace_xfs_btree_bload_block)(void *, struct xfs_btree_cur *, unsigned int, uint64_t, uint64_t, union xfs_btree_ptr *, unsigned int);

typedef void (*btf_trace_xfs_btree_bload_level_geometry)(void *, struct xfs_btree_cur *, unsigned int, uint64_t, unsigned int, unsigned int, uint64_t, uint64_t);

typedef void (*btf_trace_xfs_btree_commit_afakeroot)(void *, struct xfs_btree_cur *);

typedef void (*btf_trace_xfs_btree_commit_ifakeroot)(void *, struct xfs_btree_cur *);

typedef void (*btf_trace_xfs_btree_corrupt)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_btree_free_block)(void *, struct xfs_btree_cur *, struct xfs_buf *);

typedef void (*btf_trace_xfs_btree_overlapped_query_range)(void *, struct xfs_btree_cur *, int, struct xfs_buf *);

typedef void (*btf_trace_xfs_btree_updkeys)(void *, struct xfs_btree_cur *, int, struct xfs_buf *);

typedef void (*btf_trace_xfs_buf_delwri_pushbuf)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_delwri_queue)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_delwri_queued)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_delwri_split)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_drain_buftarg)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_error_relse)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_find)(void *, struct xfs_buf *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_buf_free)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_get)(void *, struct xfs_buf *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_buf_get_uncached)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_hold)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_init)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_iodone)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_iodone_async)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_ioerror)(void *, struct xfs_buf *, int, xfs_failaddr_t);

typedef void (*btf_trace_xfs_buf_iowait)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_iowait_done)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_item_committed)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_format)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_format_stale)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_ordered)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_pin)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_push)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_release)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_relse)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_item_size)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_size_ordered)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_size_stale)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_unpin)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_item_unpin_stale)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_buf_lock)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_lock_done)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_read)(void *, struct xfs_buf *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_buf_readahead)(void *, struct xfs_buf *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_buf_rele)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_submit)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_trylock)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_trylock_fail)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_buf_unlock)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_bunmap)(void *, struct xfs_inode *, xfs_fileoff_t, xfs_filblks_t, int, long unsigned int);

typedef void (*btf_trace_xfs_check_new_dalign)(void *, struct xfs_mount *, int, xfs_ino_t);

typedef void (*btf_trace_xfs_cil_whiteout_mark)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_cil_whiteout_skip)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_cil_whiteout_unpin)(void *, struct xfs_log_item *);

typedef void (*btf_trace_xfs_collapse_file_space)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_create)(void *, struct xfs_inode *, const struct xfs_name *);

typedef void (*btf_trace_xfs_da_fixhashpath)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_grow_inode)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_join)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_link_after)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_link_before)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_add)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_create)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_rebalance)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_remove)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_split)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_toosmall)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_node_unbalance)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_path_shift)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_root_join)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_root_split)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_shrink_inode)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_split)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_swap_lastblock)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_unlink_back)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_da_unlink_forward)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_defer_add_item)(void *, struct xfs_mount *, struct xfs_defer_pending *, void *);

typedef void (*btf_trace_xfs_defer_cancel)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_defer_cancel_item)(void *, struct xfs_mount *, struct xfs_defer_pending *, void *);

typedef void (*btf_trace_xfs_defer_cancel_list)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_create_intent)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_finish)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_defer_finish_done)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_defer_finish_error)(void *, struct xfs_trans *, int);

typedef void (*btf_trace_xfs_defer_finish_item)(void *, struct xfs_mount *, struct xfs_defer_pending *, void *);

typedef void (*btf_trace_xfs_defer_isolate_paused)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_item_pause)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_item_unpause)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_pending_abort)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_pending_finish)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_relog_intent)(void *, struct xfs_mount *, struct xfs_defer_pending *);

typedef void (*btf_trace_xfs_defer_trans_abort)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_defer_trans_roll)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_defer_trans_roll_error)(void *, struct xfs_trans *, int);

typedef void (*btf_trace_xfs_delalloc_enospc)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_destroy_inode)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_dir2_block_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_to_leaf)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_block_to_sf)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_grow_inode)(void *, struct xfs_da_args *, int);

typedef void (*btf_trace_xfs_dir2_leaf_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_to_block)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leaf_to_node)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_leafn_add)(void *, struct xfs_da_args *, int);

typedef void (*btf_trace_xfs_dir2_leafn_moveents)(void *, struct xfs_da_args *, int, int, int);

typedef void (*btf_trace_xfs_dir2_leafn_remove)(void *, struct xfs_da_args *, int);

typedef void (*btf_trace_xfs_dir2_node_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_node_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_node_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_node_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_node_to_leaf)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_addname)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_create)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_lookup)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_removename)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_replace)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_to_block)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_toino4)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_sf_toino8)(void *, struct xfs_da_args *);

typedef void (*btf_trace_xfs_dir2_shrink_inode)(void *, struct xfs_da_args *, int);

typedef void (*btf_trace_xfs_dir_fsync)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_discard_busy)(void *, const struct xfs_group *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_discard_exclude)(void *, const struct xfs_group *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_discard_extent)(void *, const struct xfs_group *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_discard_rtextent)(void *, struct xfs_mount *, xfs_rtblock_t, xfs_rtblock_t);

typedef void (*btf_trace_xfs_discard_rtrelax)(void *, struct xfs_mount *, xfs_rtblock_t, xfs_rtblock_t);

typedef void (*btf_trace_xfs_discard_rttoosmall)(void *, struct xfs_mount *, xfs_rtblock_t, xfs_rtblock_t);

typedef void (*btf_trace_xfs_discard_toosmall)(void *, const struct xfs_group *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_dqadjust)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqalloc)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqattach_found)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqattach_get)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqflush)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqflush_done)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqflush_force)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqget_dup)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqget_freeing)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqget_hit)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqget_miss)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqput)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqput_free)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqread)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqread_fail)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqreclaim_busy)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqreclaim_dirty)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqreclaim_done)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqreclaim_want)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqrele)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dqtobp_read)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_dquot_dqalloc)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_dquot_dqdetach)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_end_io_direct_write)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_end_io_direct_write_append)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_end_io_direct_write_unwritten)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_exchmaps_defer)(void *, struct xfs_mount *, const struct xfs_exchmaps_intent *);

typedef void (*btf_trace_xfs_exchmaps_delta_nextents)(void *, const struct xfs_exchmaps_req *, int64_t, int64_t);

typedef void (*btf_trace_xfs_exchmaps_delta_nextents_step)(void *, struct xfs_mount *, const struct xfs_bmbt_irec *, const struct xfs_bmbt_irec *, const struct xfs_bmbt_irec *, const struct xfs_bmbt_irec *, int, unsigned int);

typedef void (*btf_trace_xfs_exchmaps_final_estimate)(void *, const struct xfs_exchmaps_req *);

typedef void (*btf_trace_xfs_exchmaps_initial_estimate)(void *, const struct xfs_exchmaps_req *);

typedef void (*btf_trace_xfs_exchmaps_mapping1)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_exchmaps_mapping1_skip)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_exchmaps_mapping2)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_exchmaps_overhead)(void *, struct xfs_mount *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_xfs_exchmaps_recover)(void *, struct xfs_mount *, const struct xfs_exchmaps_intent *);

typedef void (*btf_trace_xfs_exchmaps_update_inode_size)(void *, struct xfs_inode *, xfs_fsize_t);

typedef void (*btf_trace_xfs_exchrange_after)(void *, struct xfs_inode *, int);

typedef void (*btf_trace_xfs_exchrange_before)(void *, struct xfs_inode *, int);

typedef void (*btf_trace_xfs_exchrange_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_exchrange_flush)(void *, const struct xfs_exchrange *, struct xfs_inode *, struct xfs_inode *);

typedef void (*btf_trace_xfs_exchrange_freshness)(void *, const struct xfs_exchrange *, struct xfs_inode *);

typedef void (*btf_trace_xfs_exchrange_mappings)(void *, const struct xfs_exchrange *, struct xfs_inode *, struct xfs_inode *);

typedef void (*btf_trace_xfs_exchrange_prep)(void *, const struct xfs_exchrange *, struct xfs_inode *, struct xfs_inode *);

typedef void (*btf_trace_xfs_extent_busy)(void *, const struct xfs_group *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_extent_busy_clear)(void *, const struct xfs_group *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_extent_busy_force)(void *, const struct xfs_group *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_extent_busy_reuse)(void *, const struct xfs_group *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_extent_busy_trim)(void *, const struct xfs_group *, xfs_agblock_t, xfs_extlen_t, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_extent_free_defer)(void *, struct xfs_mount *, struct xfs_extent_free_item *);

typedef void (*btf_trace_xfs_extent_free_deferred)(void *, struct xfs_mount *, struct xfs_extent_free_item *);

typedef void (*btf_trace_xfs_file_buffered_read)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_buffered_write)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_compat_ioctl)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_file_dax_read)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_dax_write)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_direct_read)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_direct_write)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_file_fsync)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_file_ioctl)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_file_splice_read)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_filestream_free)(void *, const struct xfs_perag *, xfs_ino_t);

typedef void (*btf_trace_xfs_filestream_lookup)(void *, const struct xfs_perag *, xfs_ino_t);

typedef void (*btf_trace_xfs_filestream_pick)(void *, const struct xfs_perag *, xfs_ino_t);

typedef void (*btf_trace_xfs_filestream_scan)(void *, const struct xfs_perag *, xfs_ino_t);

typedef void (*btf_trace_xfs_force_shutdown)(void *, struct xfs_mount *, int, int, const char *, int);

typedef void (*btf_trace_xfs_free_extent)(void *, const struct xfs_perag *, xfs_agblock_t, xfs_extlen_t, enum xfs_ag_resv_type, int, int);

typedef void (*btf_trace_xfs_free_file_space)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_fs_mark_corrupt)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_fs_mark_healthy)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_fs_mark_sick)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_fs_sync_fs)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_fs_unfixed_corruption)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_fsmap_high_group_key)(void *, struct xfs_mount *, u32, xfs_agnumber_t, const struct xfs_rmap_irec *);

typedef void (*btf_trace_xfs_fsmap_high_linear_key)(void *, struct xfs_mount *, u32, uint64_t);

typedef void (*btf_trace_xfs_fsmap_low_group_key)(void *, struct xfs_mount *, u32, xfs_agnumber_t, const struct xfs_rmap_irec *);

typedef void (*btf_trace_xfs_fsmap_low_linear_key)(void *, struct xfs_mount *, u32, uint64_t);

typedef void (*btf_trace_xfs_fsmap_mapping)(void *, struct xfs_mount *, u32, xfs_agnumber_t, const struct xfs_fsmap_irec *);

typedef void (*btf_trace_xfs_get_acl)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_getattr)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_getfsmap_high_key)(void *, struct xfs_mount *, struct xfs_fsmap *);

typedef void (*btf_trace_xfs_getfsmap_low_key)(void *, struct xfs_mount *, struct xfs_fsmap *);

typedef void (*btf_trace_xfs_getfsmap_mapping)(void *, struct xfs_mount *, struct xfs_fsmap *);

typedef void (*btf_trace_xfs_getparents_begin)(void *, struct xfs_inode *, const struct xfs_getparents *, const struct xfs_attrlist_cursor_kern *);

typedef void (*btf_trace_xfs_getparents_end)(void *, struct xfs_inode *, const struct xfs_getparents *, const struct xfs_attrlist_cursor_kern *);

typedef void (*btf_trace_xfs_getparents_expand_lastrec)(void *, struct xfs_inode *, const struct xfs_getparents *, const struct xfs_attr_list_context *, const struct xfs_getparents_rec *);

typedef void (*btf_trace_xfs_getparents_put_listent)(void *, struct xfs_inode *, const struct xfs_getparents *, const struct xfs_attr_list_context *, const struct xfs_getparents_rec *);

typedef void (*btf_trace_xfs_group_get)(void *, struct xfs_group *, long unsigned int);

typedef void (*btf_trace_xfs_group_grab)(void *, struct xfs_group *, long unsigned int);

typedef void (*btf_trace_xfs_group_grab_next_tag)(void *, struct xfs_group *, long unsigned int);

typedef void (*btf_trace_xfs_group_hold)(void *, struct xfs_group *, long unsigned int);

typedef void (*btf_trace_xfs_group_intent_hold)(void *, const struct xfs_group *, void *);

typedef void (*btf_trace_xfs_group_intent_rele)(void *, const struct xfs_group *, void *);

typedef void (*btf_trace_xfs_group_mark_corrupt)(void *, const struct xfs_group *, unsigned int);

typedef void (*btf_trace_xfs_group_mark_healthy)(void *, const struct xfs_group *, unsigned int);

typedef void (*btf_trace_xfs_group_mark_sick)(void *, const struct xfs_group *, unsigned int);

typedef void (*btf_trace_xfs_group_put)(void *, struct xfs_group *, long unsigned int);

typedef void (*btf_trace_xfs_group_rele)(void *, struct xfs_group *, long unsigned int);

typedef void (*btf_trace_xfs_group_unfixed_corruption)(void *, const struct xfs_group *, unsigned int);

typedef void (*btf_trace_xfs_group_wait_intents)(void *, const struct xfs_group *, void *);

typedef void (*btf_trace_xfs_ialloc_read_agi)(void *, const struct xfs_perag *);

typedef void (*btf_trace_xfs_iext_insert)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_iext_remove)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_iget_hit)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iget_miss)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iget_recycle)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iget_recycle_fail)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iget_skip)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_ilock)(void *, struct xfs_inode *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_ilock_demote)(void *, struct xfs_inode *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_ilock_nowait)(void *, struct xfs_inode *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_inactive_symlink)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_clear_cowblocks_tag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_clear_eofblocks_tag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_free_cowblocks_invalid)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_free_eofblocks_invalid)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_inactivating)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_mark_corrupt)(void *, struct xfs_inode *, unsigned int);

typedef void (*btf_trace_xfs_inode_mark_healthy)(void *, struct xfs_inode *, unsigned int);

typedef void (*btf_trace_xfs_inode_mark_sick)(void *, struct xfs_inode *, unsigned int);

typedef void (*btf_trace_xfs_inode_pin)(void *, struct xfs_inode *, long unsigned int);

typedef void (*btf_trace_xfs_inode_reclaiming)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_reload_unlinked_bucket)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_set_cowblocks_tag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_set_eofblocks_tag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_set_need_inactive)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_set_reclaimable)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_inode_timestamp_range)(void *, struct xfs_mount *, long long int, long long int);

typedef void (*btf_trace_xfs_inode_unfixed_corruption)(void *, struct xfs_inode *, unsigned int);

typedef void (*btf_trace_xfs_inode_unpin)(void *, struct xfs_inode *, long unsigned int);

typedef void (*btf_trace_xfs_inode_unpin_nowait)(void *, struct xfs_inode *, long unsigned int);

typedef void (*btf_trace_xfs_inodegc_flush)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_push)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_queue)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_shrinker_scan)(void *, struct xfs_mount *, struct shrink_control *, void *);

typedef void (*btf_trace_xfs_inodegc_start)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_stop)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_throttle)(void *, struct xfs_mount *, void *);

typedef void (*btf_trace_xfs_inodegc_worker)(void *, struct xfs_mount *, unsigned int);

typedef void (*btf_trace_xfs_insert_file_space)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_ioc_free_eofblocks)(void *, struct xfs_mount *, struct xfs_icwalk *, long unsigned int);

typedef void (*btf_trace_xfs_ioctl_clone)(void *, struct inode *, struct inode *);

typedef void (*btf_trace_xfs_ioctl_setattr)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iomap_alloc)(void *, struct xfs_inode *, xfs_off_t, ssize_t, int, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_iomap_found)(void *, struct xfs_inode *, xfs_off_t, ssize_t, int, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_iomap_invalid)(void *, struct xfs_inode *, const struct iomap *);

typedef void (*btf_trace_xfs_iomap_prealloc_size)(void *, struct xfs_inode *, xfs_fsblock_t, int, unsigned int);

typedef void (*btf_trace_xfs_irec_merge_post)(void *, const struct xfs_perag *, const struct xfs_inobt_rec_incore *);

typedef void (*btf_trace_xfs_irec_merge_pre)(void *, const struct xfs_perag *, const struct xfs_inobt_rec_incore *, const struct xfs_inobt_rec_incore *);

typedef void (*btf_trace_xfs_irele)(void *, struct xfs_inode *, long unsigned int);

typedef void (*btf_trace_xfs_itruncate_extents_end)(void *, struct xfs_inode *, xfs_fsize_t);

typedef void (*btf_trace_xfs_itruncate_extents_start)(void *, struct xfs_inode *, xfs_fsize_t);

typedef void (*btf_trace_xfs_iunlink)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iunlink_reload_next)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iunlink_remove)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_iunlink_update_bucket)(void *, const struct xfs_perag *, unsigned int, xfs_agino_t, xfs_agino_t);

typedef void (*btf_trace_xfs_iunlink_update_dinode)(void *, const struct xfs_iunlink_item *, xfs_agino_t);

typedef void (*btf_trace_xfs_iunlock)(void *, struct xfs_inode *, unsigned int, long unsigned int);

typedef void (*btf_trace_xfs_iwalk_ag_rec)(void *, const struct xfs_perag *, struct xfs_inobt_rec_incore *);

typedef void (*btf_trace_xfs_link)(void *, struct xfs_inode *, const struct xfs_name *);

typedef void (*btf_trace_xfs_log_assign_tail_lsn)(void *, struct xlog *, xfs_lsn_t);

typedef void (*btf_trace_xfs_log_cil_return)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_cil_wait)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_force)(void *, struct xfs_mount *, xfs_lsn_t, long unsigned int);

typedef void (*btf_trace_xfs_log_get_max_trans_res)(void *, struct xfs_mount *, const struct xfs_trans_res *);

typedef void (*btf_trace_xfs_log_grant_sleep)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_grant_wake)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_grant_wake_up)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_recover)(void *, struct xlog *, xfs_daddr_t, xfs_daddr_t);

typedef void (*btf_trace_xfs_log_recover_buf_cancel)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_cancel_add)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_cancel_ref_inc)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_dquot_buf)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_inode_buf)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_not_cancel)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_recover)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_reg_buf)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_buf_skip)(void *, struct xlog *, struct xfs_buf_log_format *);

typedef void (*btf_trace_xfs_log_recover_icreate_cancel)(void *, struct xlog *, struct xfs_icreate_log *);

typedef void (*btf_trace_xfs_log_recover_icreate_recover)(void *, struct xlog *, struct xfs_icreate_log *);

typedef void (*btf_trace_xfs_log_recover_inode_cancel)(void *, struct xlog *, struct xfs_inode_log_format *);

typedef void (*btf_trace_xfs_log_recover_inode_recover)(void *, struct xlog *, struct xfs_inode_log_format *);

typedef void (*btf_trace_xfs_log_recover_inode_skip)(void *, struct xlog *, struct xfs_inode_log_format *);

typedef void (*btf_trace_xfs_log_recover_item_add)(void *, struct xlog *, struct xlog_recover *, struct xlog_recover_item *, int);

typedef void (*btf_trace_xfs_log_recover_item_add_cont)(void *, struct xlog *, struct xlog_recover *, struct xlog_recover_item *, int);

typedef void (*btf_trace_xfs_log_recover_item_recover)(void *, struct xlog *, struct xlog_recover *, struct xlog_recover_item *, int);

typedef void (*btf_trace_xfs_log_recover_item_reorder_head)(void *, struct xlog *, struct xlog_recover *, struct xlog_recover_item *, int);

typedef void (*btf_trace_xfs_log_recover_item_reorder_tail)(void *, struct xlog *, struct xlog_recover *, struct xlog_recover_item *, int);

typedef void (*btf_trace_xfs_log_recover_record)(void *, struct xlog *, struct xlog_rec_header *, int);

typedef void (*btf_trace_xfs_log_regrant)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_regrant_exit)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_reserve)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_reserve_exit)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_regrant)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_regrant_exit)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_regrant_sub)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_ungrant)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_ungrant_exit)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_ticket_ungrant_sub)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_log_umount_write)(void *, struct xlog *, struct xlog_ticket *);

typedef void (*btf_trace_xfs_lookup)(void *, struct xfs_inode *, const struct xfs_name *);

typedef void (*btf_trace_xfs_map_blocks_alloc)(void *, struct xfs_inode *, xfs_off_t, ssize_t, int, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_map_blocks_found)(void *, struct xfs_inode *, xfs_off_t, ssize_t, int, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_metadir_cancel)(void *, const struct xfs_metadir_update *);

typedef void (*btf_trace_xfs_metadir_commit)(void *, const struct xfs_metadir_update *);

typedef void (*btf_trace_xfs_metadir_create)(void *, const struct xfs_metadir_update *);

typedef void (*btf_trace_xfs_metadir_link)(void *, const struct xfs_metadir_update *);

typedef void (*btf_trace_xfs_metadir_lookup)(void *, struct xfs_inode *, struct xfs_name *, xfs_ino_t);

typedef void (*btf_trace_xfs_metadir_start_create)(void *, const struct xfs_metadir_update *);

typedef void (*btf_trace_xfs_metadir_start_link)(void *, const struct xfs_metadir_update *);

typedef void (*btf_trace_xfs_metadir_teardown)(void *, const struct xfs_metadir_update *, int);

typedef void (*btf_trace_xfs_metadir_try_create)(void *, const struct xfs_metadir_update *);

typedef void (*btf_trace_xfs_metafile_resv_alloc_space)(void *, struct xfs_inode *, xfs_filblks_t);

typedef void (*btf_trace_xfs_metafile_resv_critical)(void *, struct xfs_inode *, xfs_filblks_t);

typedef void (*btf_trace_xfs_metafile_resv_free)(void *, struct xfs_inode *, xfs_filblks_t);

typedef void (*btf_trace_xfs_metafile_resv_free_space)(void *, struct xfs_inode *, xfs_filblks_t);

typedef void (*btf_trace_xfs_metafile_resv_init)(void *, struct xfs_inode *, xfs_filblks_t);

typedef void (*btf_trace_xfs_metafile_resv_init_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_pagecache_inval)(void *, struct xfs_inode *, xfs_off_t, xfs_off_t);

typedef void (*btf_trace_xfs_perag_clear_inode_tag)(void *, const struct xfs_perag *, long unsigned int);

typedef void (*btf_trace_xfs_perag_set_inode_tag)(void *, const struct xfs_perag *, long unsigned int);

typedef void (*btf_trace_xfs_pwork_init)(void *, struct xfs_mount *, unsigned int, pid_t);

typedef void (*btf_trace_xfs_quota_expiry_range)(void *, struct xfs_mount *, long long int, long long int);

typedef void (*btf_trace_xfs_read_agf)(void *, const struct xfs_perag *);

typedef void (*btf_trace_xfs_read_agi)(void *, const struct xfs_perag *);

typedef void (*btf_trace_xfs_read_extent)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_read_fault)(void *, struct xfs_inode *, unsigned int);

typedef void (*btf_trace_xfs_readdir)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_readlink)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_reclaim_inodes_count)(void *, const struct xfs_perag *, long unsigned int);

typedef void (*btf_trace_xfs_refcount_adjust_cow_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_adjust_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_cow_decrease)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_cow_increase)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_decrease)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_defer)(void *, struct xfs_mount *, struct xfs_refcount_intent *);

typedef void (*btf_trace_xfs_refcount_deferred)(void *, struct xfs_mount *, struct xfs_refcount_intent *);

typedef void (*btf_trace_xfs_refcount_delete)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_delete_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_find_left_extent)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *, struct xfs_refcount_irec *, xfs_agblock_t);

typedef void (*btf_trace_xfs_refcount_find_left_extent_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_find_right_extent)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *, struct xfs_refcount_irec *, xfs_agblock_t);

typedef void (*btf_trace_xfs_refcount_find_right_extent_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_find_shared)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_find_shared_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_find_shared_result)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_finish_one_leftover)(void *, struct xfs_mount *, struct xfs_refcount_intent *);

typedef void (*btf_trace_xfs_refcount_get)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_increase)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t);

typedef void (*btf_trace_xfs_refcount_insert)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_insert_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_lookup)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_lookup_t);

typedef void (*btf_trace_xfs_refcount_merge_center_extents)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *, struct xfs_refcount_irec *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_merge_center_extents_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_merge_left_extent)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_merge_left_extent_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_merge_right_extent)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_merge_right_extent_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_modify_extent)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_modify_extent_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_split_extent)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *, xfs_agblock_t);

typedef void (*btf_trace_xfs_refcount_split_extent_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_refcount_update)(void *, struct xfs_btree_cur *, struct xfs_refcount_irec *);

typedef void (*btf_trace_xfs_refcount_update_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_bounce_dio_write)(void *, struct kiocb *, struct iov_iter *);

typedef void (*btf_trace_xfs_reflink_cancel_cow)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_cancel_cow_range)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_reflink_cancel_cow_range_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_compare_extents)(void *, struct xfs_inode *, xfs_off_t, xfs_off_t, struct xfs_inode *, xfs_off_t);

typedef void (*btf_trace_xfs_reflink_compare_extents_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_convert_cow)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_cow_enospc)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_cow_found)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_cow_remap_from)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_cow_remap_to)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_end_cow)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_reflink_end_cow_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_remap_blocks)(void *, struct xfs_inode *, xfs_fileoff_t, xfs_filblks_t, struct xfs_inode *, xfs_fileoff_t);

typedef void (*btf_trace_xfs_reflink_remap_blocks_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_remap_extent_dest)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_remap_extent_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_remap_extent_src)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_remap_range)(void *, struct xfs_inode *, xfs_off_t, xfs_off_t, struct xfs_inode *, xfs_off_t);

typedef void (*btf_trace_xfs_reflink_remap_range_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_set_inode_flag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_reflink_set_inode_flag_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_trim_around_shared)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_reflink_unset_inode_flag)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_reflink_unshare)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_reflink_unshare_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_reflink_update_inode_size)(void *, struct xfs_inode *, xfs_fsize_t);

typedef void (*btf_trace_xfs_reflink_update_inode_size_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_remove)(void *, struct xfs_inode *, const struct xfs_name *);

typedef void (*btf_trace_xfs_rename)(void *, struct xfs_inode *, struct xfs_inode *, struct xfs_name *, struct xfs_name *);

typedef void (*btf_trace_xfs_reset_dqcounts)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_rmap_convert)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_convert_done)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_convert_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_convert_state)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_defer)(void *, struct xfs_mount *, struct xfs_rmap_intent *);

typedef void (*btf_trace_xfs_rmap_deferred)(void *, struct xfs_mount *, struct xfs_rmap_intent *);

typedef void (*btf_trace_xfs_rmap_delete)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_delete_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_find_left_neighbor_candidate)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_find_left_neighbor_query)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_find_left_neighbor_result)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_find_right_neighbor_result)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_insert)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_insert_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_lookup_le_range)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_lookup_le_range_candidate)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_lookup_le_range_result)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_map)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_map_done)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_map_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_unmap)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_unmap_done)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, bool, const struct xfs_owner_info *);

typedef void (*btf_trace_xfs_rmap_unmap_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_rmap_update)(void *, struct xfs_btree_cur *, xfs_agblock_t, xfs_extlen_t, uint64_t, uint64_t, unsigned int);

typedef void (*btf_trace_xfs_rmap_update_error)(void *, struct xfs_btree_cur *, int, long unsigned int);

typedef void (*btf_trace_xfs_setattr)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_setfilesize)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_swap_extent_after)(void *, struct xfs_inode *, int);

typedef void (*btf_trace_xfs_swap_extent_before)(void *, struct xfs_inode *, int);

typedef void (*btf_trace_xfs_swap_extent_rmap_error)(void *, struct xfs_inode *, int, long unsigned int);

typedef void (*btf_trace_xfs_swap_extent_rmap_remap)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_swap_extent_rmap_remap_piece)(void *, struct xfs_inode *, struct xfs_bmbt_irec *);

typedef void (*btf_trace_xfs_symlink)(void *, struct xfs_inode *, const struct xfs_name *);

typedef void (*btf_trace_xfs_trans_add_item)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_alloc)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_apply_dquot_deltas)(void *, struct xfs_dqtrx *);

typedef void (*btf_trace_xfs_trans_apply_dquot_deltas_after)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_trans_apply_dquot_deltas_before)(void *, struct xfs_dquot *);

typedef void (*btf_trace_xfs_trans_bdetach)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_bhold)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_bhold_release)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_binval)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_bjoin)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_brelse)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_cancel)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_commit)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_commit_items)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_dup)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_free)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_free_items)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_trans_get_buf)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_get_buf_recur)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_getsb)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_getsb_recur)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_log_buf)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_mod_dquot)(void *, struct xfs_trans *, struct xfs_dquot *, unsigned int, int64_t);

typedef void (*btf_trace_xfs_trans_mod_dquot_after)(void *, struct xfs_dqtrx *);

typedef void (*btf_trace_xfs_trans_mod_dquot_before)(void *, struct xfs_dqtrx *);

typedef void (*btf_trace_xfs_trans_read_buf)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_read_buf_recur)(void *, struct xfs_buf_log_item *);

typedef void (*btf_trace_xfs_trans_read_buf_shut)(void *, struct xfs_buf *, long unsigned int);

typedef void (*btf_trace_xfs_trans_resv_calc)(void *, struct xfs_mount *, unsigned int, struct xfs_trans_res *);

typedef void (*btf_trace_xfs_trans_resv_calc_minlogsize)(void *, struct xfs_mount *, unsigned int, struct xfs_trans_res *);

typedef void (*btf_trace_xfs_trans_roll)(void *, struct xfs_trans *, long unsigned int);

typedef void (*btf_trace_xfs_unwritten_convert)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_update_time)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_vm_bmap)(void *, struct xfs_inode *);

typedef void (*btf_trace_xfs_wb_cow_iomap_invalid)(void *, struct xfs_inode *, const struct iomap *, unsigned int, int);

typedef void (*btf_trace_xfs_wb_data_iomap_invalid)(void *, struct xfs_inode *, const struct iomap *, unsigned int, int);

typedef void (*btf_trace_xfs_write_extent)(void *, struct xfs_inode *, struct xfs_iext_cursor *, int, long unsigned int);

typedef void (*btf_trace_xfs_write_fault)(void *, struct xfs_inode *, unsigned int);

typedef void (*btf_trace_xfs_zero_eof)(void *, struct xfs_inode *, xfs_off_t, ssize_t);

typedef void (*btf_trace_xfs_zero_file_space)(void *, struct xfs_inode *);

typedef void (*btf_trace_xlog_iclog_activate)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_callback)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_callbacks_done)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_callbacks_start)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_clean)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_force)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_force_lsn)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_get_space)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_release)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_switch)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_sync)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_sync_done)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_syncing)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_wait_on)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_want_sync)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_iclog_write)(void *, struct xlog_in_core *, long unsigned int);

typedef void (*btf_trace_xlog_intent_recovery_failed)(void *, struct xfs_mount *, const struct xfs_defer_op_type *, int);

typedef void (*btf_trace_xmbuf_create)(void *, struct xfs_buftarg *);

typedef void (*btf_trace_xmbuf_free)(void *, struct xfs_buftarg *);

typedef void (*btf_trace_xprt_connect)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_create)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_destroy)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_auto)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_done)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_force)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_get_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_lookup_rqst)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_ping)(void *, const struct rpc_xprt *, int);

typedef void (*btf_trace_xprt_put_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xprt_reserve_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_retransmit)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xprt_timer)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_transmit)(void *, const struct rpc_rqst *, int);

typedef void (*btf_trace_xrep_attempt)(void *, struct xfs_inode *, struct xfs_scrub_metadata *, int);

typedef void (*btf_trace_xrep_done)(void *, struct xfs_inode *, struct xfs_scrub_metadata *, int);

typedef void (*btf_trace_xs_data_ready)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xs_stream_read_data)(void *, struct rpc_xprt *, ssize_t, size_t);

typedef void (*btf_trace_xs_stream_read_request)(void *, struct sock_xprt *);

typedef int (*cb_t)(struct param *);

typedef bool (*check_reserved_t)(u64, u64, enum e820_type);

typedef void cleanup_cb_t(struct rq_wait *, void *);

typedef int (*cmp_r_func_t)(const void *, const void *, const void *);

typedef struct sk_buff * (*codel_skb_dequeue_t)(struct codel_vars *, void *);

typedef void (*codel_skb_drop_t)(struct sk_buff *, void *);

typedef u32 (*codel_skb_len_t)(const struct sk_buff *);

typedef codel_time_t (*codel_skb_time_t)(const struct sk_buff *);

typedef bool (*cond_update_fn_t)(struct trace_array *, void *);

typedef int (*cppc_mode_transition_fn)(int);

typedef int (*decoder_t)(struct bitstr *, const struct field_t *, char *, int);

typedef void detailed_cb(const struct detailed_timing *, void *);

typedef void * (*devcon_match_fn_t)(const struct fwnode_handle *, const char *, void *);

typedef int (*device_iter_t)(struct device *, void *);

typedef int (*device_match_t)(struct device *, const void *);

typedef int (*dr_match_t)(struct device *, void *, void *);

typedef bool (*drm_vblank_get_scanout_position_func)(struct drm_crtc *, bool, int *, int *, ktime_t *, ktime_t *, const struct drm_display_mode *);

typedef int (*dummy_ops_test_ret_fn)(struct bpf_dummy_ops_state *, ...);

typedef int (*dynevent_check_arg_fn_t)(void *);

typedef void (*efi_element_handler_t)(const char *, const void *, size_t);

typedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *, bool);

typedef void (*ethnl_notify_handler_t)(struct net_device *, unsigned int, const void *);

typedef void (*exitcall_t)(void);

typedef int (*ext4_mballoc_query_range_fn)(struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t, void *);

typedef void ext4_update_sb_callback(struct ext4_super_block *, const void *);

typedef int (*fill_cap_fn)(struct iommufd_ioas *, struct vfio_info_cap_header *, size_t);

typedef int filler_t(struct file *, struct folio *);

typedef bool (*filter_func_t)(struct uprobe_consumer *, struct mm_struct *);

typedef void fn_handler_fn(struct vc_data *);

typedef const u8 * (*fn_mipi_elem_exec)(struct intel_dsi *, const u8 *);

typedef void free_folio_t(struct folio *, long unsigned int);

typedef int (*g_rand)(struct tcf_gact *);

typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);

typedef u32 (*hotplug_enables_func)(struct intel_encoder *);

typedef u32 (*hotplug_mask_func)(enum hpd_pin);

typedef bool (*i8042_filter_t)(unsigned char, unsigned char, struct serio *, void *);

typedef int (*i915_user_extension_fn)(struct i915_user_extension *, void *);

typedef u32 inet6_ehashfn_t(const struct net *, const struct in6_addr *, const u16, const struct in6_addr *, const __be16);

typedef u32 inet_ehashfn_t(const struct net *, const __be32, const __u16, const __be32, const __be16);

typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);

typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);

typedef int (*ioctl_fn)(struct file *, struct autofs_sb_info *, struct autofs_dev_ioctl *);

typedef int (*ioctl_fn___2)(struct file *, struct dm_ioctl *, size_t);

typedef void (*iomap_punch_t)(struct inode *, loff_t, loff_t, struct iomap *);

typedef size_t (*iov_step_f)(void *, size_t, size_t, void *, void *);

typedef size_t (*iov_ustep_f)(void *, size_t, size_t, void *, void *);

typedef int (*iova_bitmap_fn_t)(struct iova_bitmap *, long unsigned int, size_t, void *);

typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *, const struct inet6_skb_parm *);

typedef void (*irq_write_msi_msg_t)(struct msi_desc *, struct msi_msg *);

typedef int (*is_acked_func)(struct rds_message *, uint64_t);

typedef enum it_action (*iter_fn)(struct dm_buffer *, void *);

typedef bool (*iter_predicate)(struct lru_entry *, void *);

typedef int (*iterate_dir_item_t)(int, struct btrfs_key *, const char *, int, const char *, int, void *);

typedef int (*iterate_inode_ref_t)(u64, struct fs_path *, void *);

typedef void k_handler_fn(struct vc_data *, unsigned char, char);

typedef enum evict_result (*le_predicate)(struct lru_entry *, void *);

typedef int (*list_cmp_func_t)(void *, const struct list_head *, const struct list_head *);

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, void *);

typedef int mh_filter_t(struct sock *, struct sk_buff *);

typedef void (*move_fn_t)(struct lruvec *, struct folio *);

typedef int (*netlink_filter_fn)(struct sock *, struct sk_buff *, void *);

typedef struct folio *new_folio_t(struct folio *, long unsigned int);

typedef int (*nfqnl_cmpfn)(struct nf_queue_entry *, long unsigned int);

typedef int (*nlm_host_match_fn_t)(void *, struct nlm_host *);

typedef void (*nmi_shootdown_cb)(int, struct pt_regs *);

typedef struct ns_common *ns_get_path_helper_t(void *);

typedef int (*objpool_init_obj_cb)(void *, void *);

typedef void (*online_page_callback_t)(struct page *, unsigned int);

typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);

typedef int (*parse_unknown_fn)(char *, char *, const char *, void *);

typedef int (*pcie_callback_t)(struct pcie_device *);

typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);

typedef int pcpu_fc_cpu_to_node_fn_t(int);

typedef void perf_iterate_f(struct perf_event *, void *);

typedef int perf_snapshot_branch_stack_t(struct perf_branch_entry *, unsigned int);

typedef int (*pfkey_handler)(struct sock *, struct sk_buff *, const struct sadb_msg *, void * const *);

typedef int (*pm_callback_t)(struct device *);

typedef int (*pm_cpu_match_t)(const struct x86_cpu_id *);

typedef struct rt6_info * (*pol_lookup_t)(struct net *, struct fib6_table *, struct flowi6 *, const struct sk_buff *, int);

typedef int (*pp_nl_fill_cb)(struct sk_buff *, const struct page_pool *, const struct genl_info *);

typedef bool (*pps_check)(struct intel_display *, int);

typedef const char *printfn_t(union sctp_subtype);

typedef int (*proc_visitor)(struct task_struct *, void *);

typedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);

typedef void (*rds_info_func)(struct socket *, unsigned int, struct rds_info_iterator *, struct rds_info_lengths *);

typedef int read_block_fn(void *, u8 *, unsigned int, size_t);

typedef long unsigned int relocate_kernel_fn(long unsigned int, long unsigned int, long unsigned int, unsigned int, unsigned int);

typedef int (*reset_func)(struct intel_gt *, intel_engine_mask_t, unsigned int);

typedef void (*rethook_handler_t)(struct rethook_node *, void *, long unsigned int, struct pt_regs *);

typedef bool (*ring_buffer_cond_fn)(void *);

typedef void (*rpc_action)(struct rpc_task *);

typedef irqreturn_t (*rtc_irq_handler)(int, void *);

typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);

typedef int (*sctp_callback_t)(struct sctp_endpoint *, struct sctp_transport *, void *);

typedef void sctp_timer_event_t(struct timer_list *);

typedef u8 (*sel_io_reader)(const struct dmi_system_event_log *, loff_t);

typedef int (*sendmsg_func)(struct sock *, struct msghdr *);

typedef void (*serial8250_isa_config_fn)(int, struct uart_port *, u32 *);

typedef int (*set_callee_state_fn)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *, int);

typedef void (*set_debug_port_t)(int);

typedef void (*setup_fn)(struct perf_event *, struct pt_regs *, void *, struct perf_sample_data *, struct pt_regs *);

typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);

typedef void sg_free_fn(struct scatterlist *, unsigned int);

typedef void sha1_block_fn(struct sha1_state *, const u8 *, int);

typedef void sha256_block_fn(struct sha256_state *, const u8 *, int);

typedef void sha512_block_fn(struct sha512_state *, const u8 *, int);

typedef bool (*smp_cond_func_t)(int, void *);

typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);

typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);

typedef bool (*stack_trace_consume_fn)(void *, long unsigned int);

typedef void (*swap_r_func_t)(void *, void *, int, const void *);

typedef long int (*sys_call_ptr_t)(const struct pt_regs *);

typedef int (*task_call_f)(struct task_struct *, void *);

typedef void (*task_work_func_t)(struct callback_head *);

typedef void text_poke_f(void *, const void *, size_t);

typedef int (*tg_visitor)(struct task_group *, void *);

typedef struct sock * (*udp_lookup_t)(const struct sk_buff *, __be16, __be16);

typedef bool (*up_f)(struct tmigr_group *, struct tmigr_group *, struct tmigr_walk *);

typedef void (*vlv_dsi_dmi_quirk_func)(struct intel_dsi *);

typedef u32 * (*wa_bb_func_t)(struct intel_engine_cs *, u32 *);

typedef int wait_bit_action_f(struct wait_bit_key *, int);

typedef int (*walk_memory_groups_func_t)(struct memory_group *, void *);

typedef int (*writepage_t)(struct folio *, struct writeback_control *, void *);

typedef int (*xbitmap32_walk_fn)(uint32_t, uint32_t, void *);

typedef int (*xbitmap64_walk_fn)(uint64_t, uint64_t, void *);

typedef int (*xchk_da_btree_rec_fn)(struct xchk_da_btree *, int);

typedef int (*xchk_dirent_fn)(struct xfs_scrub *, struct xfs_inode *, xfs_dir2_dataptr_t, const struct xfs_name *, xfs_ino_t, void *);

typedef int (*xchk_xattr_fn)(struct xfs_scrub *, struct xfs_inode *, unsigned int, const unsigned char *, unsigned int, const void *, unsigned int, void *);

typedef int (*xchk_xattrleaf_fn)(struct xfs_scrub *, void *);

typedef size_t (*xdr_skb_read_actor)(struct xdr_skb_reader *, void *, size_t);

typedef int (*xfs_agfl_walk_fn)(struct xfs_mount *, xfs_agblock_t, void *);

typedef int (*xfs_btree_query_range_fn)(struct xfs_btree_cur *, const union xfs_btree_rec *, void *);

typedef int (*xfs_btree_visit_blocks_fn)(struct xfs_btree_cur *, int, void *);

typedef struct rpc_xprt * (*xprt_switch_find_xprt_t)(struct rpc_xprt_switch *, const struct rpc_xprt *);

struct bpf_iter;

struct creds;

struct dax_dev;

struct fscrypt_inode_info;

struct fsverity_info;

struct virtio_gpu_command;

struct xt_recent_mtinfo_v0;


/* BPF kfuncs */
#ifndef BPF_NO_KFUNC_PROTOTYPES
extern void bbr_cwnd_event(struct sock *sk, enum tcp_ca_event event) __weak __ksym;
extern void bbr_init(struct sock *sk) __weak __ksym;
extern void bbr_main(struct sock *sk, u32 ack, int flag, const struct rate_sample *rs) __weak __ksym;
extern u32 bbr_min_tso_segs(struct sock *sk) __weak __ksym;
extern void bbr_set_state(struct sock *sk, u8 new_state) __weak __ksym;
extern u32 bbr_sndbuf_expand(struct sock *sk) __weak __ksym;
extern u32 bbr_ssthresh(struct sock *sk) __weak __ksym;
extern u32 bbr_undo_cwnd(struct sock *sk) __weak __ksym;
extern void *bpf_arena_alloc_pages(void *p__map, void *addr__ign, u32 page_cnt, int node_id, u64 flags) __weak __ksym;
extern void bpf_arena_free_pages(void *p__map, void *ptr__ign, u32 page_cnt) __weak __ksym;
extern void *bpf_cast_to_kern_ctx(void *obj) __weak __ksym;
extern struct cgroup *bpf_cgroup_acquire(struct cgroup *cgrp) __weak __ksym;
extern struct cgroup *bpf_cgroup_ancestor(struct cgroup *cgrp, int level) __weak __ksym;
extern struct cgroup *bpf_cgroup_from_id(u64 cgid) __weak __ksym;
extern void bpf_cgroup_release(struct cgroup *cgrp) __weak __ksym;
extern int bpf_copy_from_user_str(void *dst, u32 dst__sz, const void *unsafe_ptr__ign, u64 flags) __weak __ksym;
extern struct bpf_cpumask *bpf_cpumask_acquire(struct bpf_cpumask *cpumask) __weak __ksym;
extern bool bpf_cpumask_and(struct bpf_cpumask *dst, const struct cpumask *src1, const struct cpumask *src2) __weak __ksym;
extern u32 bpf_cpumask_any_and_distribute(const struct cpumask *src1, const struct cpumask *src2) __weak __ksym;
extern u32 bpf_cpumask_any_distribute(const struct cpumask *cpumask) __weak __ksym;
extern void bpf_cpumask_clear(struct bpf_cpumask *cpumask) __weak __ksym;
extern void bpf_cpumask_clear_cpu(u32 cpu, struct bpf_cpumask *cpumask) __weak __ksym;
extern void bpf_cpumask_copy(struct bpf_cpumask *dst, const struct cpumask *src) __weak __ksym;
extern struct bpf_cpumask *bpf_cpumask_create(void) __weak __ksym;
extern bool bpf_cpumask_empty(const struct cpumask *cpumask) __weak __ksym;
extern bool bpf_cpumask_equal(const struct cpumask *src1, const struct cpumask *src2) __weak __ksym;
extern u32 bpf_cpumask_first(const struct cpumask *cpumask) __weak __ksym;
extern u32 bpf_cpumask_first_and(const struct cpumask *src1, const struct cpumask *src2) __weak __ksym;
extern u32 bpf_cpumask_first_zero(const struct cpumask *cpumask) __weak __ksym;
extern bool bpf_cpumask_full(const struct cpumask *cpumask) __weak __ksym;
extern bool bpf_cpumask_intersects(const struct cpumask *src1, const struct cpumask *src2) __weak __ksym;
extern void bpf_cpumask_or(struct bpf_cpumask *dst, const struct cpumask *src1, const struct cpumask *src2) __weak __ksym;
extern void bpf_cpumask_release(struct bpf_cpumask *cpumask) __weak __ksym;
extern void bpf_cpumask_set_cpu(u32 cpu, struct bpf_cpumask *cpumask) __weak __ksym;
extern void bpf_cpumask_setall(struct bpf_cpumask *cpumask) __weak __ksym;
extern bool bpf_cpumask_subset(const struct cpumask *src1, const struct cpumask *src2) __weak __ksym;
extern bool bpf_cpumask_test_and_clear_cpu(u32 cpu, struct bpf_cpumask *cpumask) __weak __ksym;
extern bool bpf_cpumask_test_and_set_cpu(u32 cpu, struct bpf_cpumask *cpumask) __weak __ksym;
extern bool bpf_cpumask_test_cpu(u32 cpu, const struct cpumask *cpumask) __weak __ksym;
extern u32 bpf_cpumask_weight(const struct cpumask *cpumask) __weak __ksym;
extern void bpf_cpumask_xor(struct bpf_cpumask *dst, const struct cpumask *src1, const struct cpumask *src2) __weak __ksym;
extern struct bpf_crypto_ctx *bpf_crypto_ctx_acquire(struct bpf_crypto_ctx *ctx) __weak __ksym;
extern struct bpf_crypto_ctx *bpf_crypto_ctx_create(const struct bpf_crypto_params *params, u32 params__sz, int *err) __weak __ksym;
extern void bpf_crypto_ctx_release(struct bpf_crypto_ctx *ctx) __weak __ksym;
extern int bpf_crypto_decrypt(struct bpf_crypto_ctx *ctx, const struct bpf_dynptr *src, const struct bpf_dynptr *dst, const struct bpf_dynptr *siv__nullable) __weak __ksym;
extern int bpf_crypto_encrypt(struct bpf_crypto_ctx *ctx, const struct bpf_dynptr *src, const struct bpf_dynptr *dst, const struct bpf_dynptr *siv__nullable) __weak __ksym;
extern int bpf_ct_change_status(struct nf_conn *nfct, u32 status) __weak __ksym;
extern int bpf_ct_change_timeout(struct nf_conn *nfct, u32 timeout) __weak __ksym;
extern struct nf_conn *bpf_ct_insert_entry(struct nf_conn___init *nfct_i) __weak __ksym;
extern void bpf_ct_release(struct nf_conn *nfct) __weak __ksym;
extern int bpf_ct_set_nat_info(struct nf_conn___init *nfct, union nf_inet_addr *addr, int port, enum nf_nat_manip_type manip) __weak __ksym;
extern int bpf_ct_set_status(const struct nf_conn___init *nfct, u32 status) __weak __ksym;
extern void bpf_ct_set_timeout(struct nf_conn___init *nfct, u32 timeout) __weak __ksym;
extern int bpf_dynptr_adjust(const struct bpf_dynptr *p, u32 start, u32 end) __weak __ksym;
extern int bpf_dynptr_clone(const struct bpf_dynptr *p, struct bpf_dynptr *clone__uninit) __weak __ksym;
extern int bpf_dynptr_from_skb(struct __sk_buff *s, u64 flags, struct bpf_dynptr *ptr__uninit) __weak __ksym;
extern int bpf_dynptr_from_xdp(struct xdp_md *x, u64 flags, struct bpf_dynptr *ptr__uninit) __weak __ksym;
extern bool bpf_dynptr_is_null(const struct bpf_dynptr *p) __weak __ksym;
extern bool bpf_dynptr_is_rdonly(const struct bpf_dynptr *p) __weak __ksym;
extern __u32 bpf_dynptr_size(const struct bpf_dynptr *p) __weak __ksym;
extern void *bpf_dynptr_slice(const struct bpf_dynptr *p, u32 offset, void *buffer__opt, u32 buffer__szk) __weak __ksym;
extern void *bpf_dynptr_slice_rdwr(const struct bpf_dynptr *p, u32 offset, void *buffer__opt, u32 buffer__szk) __weak __ksym;
extern int bpf_fentry_test1(int a) __weak __ksym;
extern int bpf_get_dentry_xattr(struct dentry *dentry, const char *name__str, struct bpf_dynptr *value_p) __weak __ksym;
extern int bpf_get_file_xattr(struct file *file, const char *name__str, struct bpf_dynptr *value_p) __weak __ksym;
extern struct kmem_cache *bpf_get_kmem_cache(u64 addr) __weak __ksym;
extern struct file *bpf_get_task_exe_file(struct task_struct *task) __weak __ksym;
extern void bpf_iter_bits_destroy(struct bpf_iter_bits *it) __weak __ksym;
extern int bpf_iter_bits_new(struct bpf_iter_bits *it, const u64 *unsafe_ptr__ign, u32 nr_words) __weak __ksym;
extern int *bpf_iter_bits_next(struct bpf_iter_bits *it) __weak __ksym;
extern void bpf_iter_css_destroy(struct bpf_iter_css *it) __weak __ksym;
extern int bpf_iter_css_new(struct bpf_iter_css *it, struct cgroup_subsys_state *start, unsigned int flags) __weak __ksym;
extern struct cgroup_subsys_state *bpf_iter_css_next(struct bpf_iter_css *it) __weak __ksym;
extern void bpf_iter_css_task_destroy(struct bpf_iter_css_task *it) __weak __ksym;
extern int bpf_iter_css_task_new(struct bpf_iter_css_task *it, struct cgroup_subsys_state *css, unsigned int flags) __weak __ksym;
extern struct task_struct *bpf_iter_css_task_next(struct bpf_iter_css_task *it) __weak __ksym;
extern void bpf_iter_kmem_cache_destroy(struct bpf_iter_kmem_cache *it) __weak __ksym;
extern int bpf_iter_kmem_cache_new(struct bpf_iter_kmem_cache *it) __weak __ksym;
extern struct kmem_cache *bpf_iter_kmem_cache_next(struct bpf_iter_kmem_cache *it) __weak __ksym;
extern void bpf_iter_num_destroy(struct bpf_iter_num *it) __weak __ksym;
extern int bpf_iter_num_new(struct bpf_iter_num *it, int start, int end) __weak __ksym;
extern int *bpf_iter_num_next(struct bpf_iter_num *it) __weak __ksym;
extern void bpf_iter_task_destroy(struct bpf_iter_task *it) __weak __ksym;
extern int bpf_iter_task_new(struct bpf_iter_task *it, struct task_struct *task__nullable, unsigned int flags) __weak __ksym;
extern struct task_struct *bpf_iter_task_next(struct bpf_iter_task *it) __weak __ksym;
extern void bpf_iter_task_vma_destroy(struct bpf_iter_task_vma *it) __weak __ksym;
extern int bpf_iter_task_vma_new(struct bpf_iter_task_vma *it, struct task_struct *task, u64 addr) __weak __ksym;
extern struct vm_area_struct *bpf_iter_task_vma_next(struct bpf_iter_task_vma *it) __weak __ksym;
extern void bpf_key_put(struct bpf_key *bkey) __weak __ksym;
extern void bpf_kfunc_call_memb_release(struct prog_test_member *p) __weak __ksym;
extern void bpf_kfunc_call_test_release(struct prog_test_ref_kfunc *p) __weak __ksym;
extern struct bpf_list_node *bpf_list_pop_back(struct bpf_list_head *head) __weak __ksym;
extern struct bpf_list_node *bpf_list_pop_front(struct bpf_list_head *head) __weak __ksym;
extern int bpf_list_push_back_impl(struct bpf_list_head *head, struct bpf_list_node *node, void *meta__ign, u64 off) __weak __ksym;
extern int bpf_list_push_front_impl(struct bpf_list_head *head, struct bpf_list_node *node, void *meta__ign, u64 off) __weak __ksym;
extern void bpf_local_irq_restore(long unsigned int *flags__irq_flag) __weak __ksym;
extern void bpf_local_irq_save(long unsigned int *flags__irq_flag) __weak __ksym;
extern struct bpf_key *bpf_lookup_system_key(u64 id) __weak __ksym;
extern struct bpf_key *bpf_lookup_user_key(u32 serial, u64 flags) __weak __ksym;
extern s64 bpf_map_sum_elem_count(const struct bpf_map *map) __weak __ksym;
extern int bpf_modify_return_test(int a, int *b) __weak __ksym;
extern int bpf_modify_return_test2(int a, int *b, short int c, int d, void *e, char f, int g) __weak __ksym;
extern int bpf_modify_return_test_tp(int nonce) __weak __ksym;
extern void bpf_obj_drop_impl(void *p__alloc, void *meta__ign) __weak __ksym;
extern void *bpf_obj_new_impl(u64 local_type_id__k, void *meta__ign) __weak __ksym;
extern int bpf_path_d_path(struct path *path, char *buf, size_t buf__sz) __weak __ksym;
extern void bpf_percpu_obj_drop_impl(void *p__alloc, void *meta__ign) __weak __ksym;
extern void *bpf_percpu_obj_new_impl(u64 local_type_id__k, void *meta__ign) __weak __ksym;
extern void bpf_preempt_disable(void) __weak __ksym;
extern void bpf_preempt_enable(void) __weak __ksym;
extern void bpf_put_file(struct file *file) __weak __ksym;
extern int bpf_rbtree_add_impl(struct bpf_rb_root *root, struct bpf_rb_node *node, bool (*less)(struct bpf_rb_node *, const struct bpf_rb_node *), void *meta__ign, u64 off) __weak __ksym;
extern struct bpf_rb_node *bpf_rbtree_first(struct bpf_rb_root *root) __weak __ksym;
extern struct bpf_rb_node *bpf_rbtree_remove(struct bpf_rb_root *root, struct bpf_rb_node *node) __weak __ksym;
extern void bpf_rcu_read_lock(void) __weak __ksym;
extern void bpf_rcu_read_unlock(void) __weak __ksym;
extern void *bpf_rdonly_cast(const void *obj__ign, u32 btf_id__k) __weak __ksym;
extern void *bpf_refcount_acquire_impl(void *p__refcounted_kptr, void *meta__ign) __weak __ksym;
extern int bpf_send_signal_task(struct task_struct *task, int sig, enum pid_type type, u64 value) __weak __ksym;
extern __u64 *bpf_session_cookie(void) __weak __ksym;
extern bool bpf_session_is_return(void) __weak __ksym;
extern int bpf_sk_assign_tcp_reqsk(struct __sk_buff *s, struct sock *sk, struct bpf_tcp_req_attrs *attrs, int attrs__sz) __weak __ksym;
extern struct nf_conn___init *bpf_skb_ct_alloc(struct __sk_buff *skb_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz) __weak __ksym;
extern struct nf_conn *bpf_skb_ct_lookup(struct __sk_buff *skb_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz) __weak __ksym;
extern int bpf_skb_get_xfrm_info(struct __sk_buff *skb_ctx, struct bpf_xfrm_info *to) __weak __ksym;
extern int bpf_skb_set_xfrm_info(struct __sk_buff *skb_ctx, const struct bpf_xfrm_info *from) __weak __ksym;
extern int bpf_sock_addr_set_sun_path(struct bpf_sock_addr_kern *sa_kern, const u8 *sun_path, u32 sun_path__sz) __weak __ksym;
extern int bpf_sock_destroy(struct sock_common *sock) __weak __ksym;
extern struct task_struct *bpf_task_acquire(struct task_struct *p) __weak __ksym;
extern struct task_struct *bpf_task_from_pid(s32 pid) __weak __ksym;
extern struct task_struct *bpf_task_from_vpid(s32 vpid) __weak __ksym;
extern struct cgroup *bpf_task_get_cgroup1(struct task_struct *task, int hierarchy_id) __weak __ksym;
extern void bpf_task_release(struct task_struct *p) __weak __ksym;
extern long int bpf_task_under_cgroup(struct task_struct *task, struct cgroup *ancestor) __weak __ksym;
extern void bpf_throw(u64 cookie) __weak __ksym;
extern int bpf_verify_pkcs7_signature(struct bpf_dynptr *data_p, struct bpf_dynptr *sig_p, struct bpf_key *trusted_keyring) __weak __ksym;
extern int bpf_wq_init(struct bpf_wq *wq, void *p__map, unsigned int flags) __weak __ksym;
extern int bpf_wq_set_callback_impl(struct bpf_wq *wq, int (*callback_fn)(void *, int *, void *), unsigned int flags, void *aux__ign) __weak __ksym;
extern int bpf_wq_start(struct bpf_wq *wq, unsigned int flags) __weak __ksym;
extern struct nf_conn___init *bpf_xdp_ct_alloc(struct xdp_md *xdp_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz) __weak __ksym;
extern struct nf_conn *bpf_xdp_ct_lookup(struct xdp_md *xdp_ctx, struct bpf_sock_tuple *bpf_tuple, u32 tuple__sz, struct bpf_ct_opts *opts, u32 opts__sz) __weak __ksym;
extern struct flow_offload_tuple_rhash *bpf_xdp_flow_lookup(struct xdp_md *ctx, struct bpf_fib_lookup *fib_tuple, struct bpf_flowtable_opts *opts, u32 opts_len) __weak __ksym;
extern struct xfrm_state *bpf_xdp_get_xfrm_state(struct xdp_md *ctx, struct bpf_xfrm_state_opts *opts, u32 opts__sz) __weak __ksym;
extern int bpf_xdp_metadata_rx_hash(const struct xdp_md *ctx, u32 *hash, enum xdp_rss_hash_type *rss_type) __weak __ksym;
extern int bpf_xdp_metadata_rx_timestamp(const struct xdp_md *ctx, u64 *timestamp) __weak __ksym;
extern int bpf_xdp_metadata_rx_vlan_tag(const struct xdp_md *ctx, __be16 *vlan_proto, u16 *vlan_tci) __weak __ksym;
extern void bpf_xdp_xfrm_state_release(struct xfrm_state *x) __weak __ksym;
extern void cgroup_rstat_flush(struct cgroup *cgrp) __weak __ksym;
extern void cgroup_rstat_updated(struct cgroup *cgrp, int cpu) __weak __ksym;
extern void crash_kexec(struct pt_regs *regs) __weak __ksym;
extern void cubictcp_acked(struct sock *sk, const struct ack_sample *sample) __weak __ksym;
extern void cubictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked) __weak __ksym;
extern void cubictcp_cwnd_event(struct sock *sk, enum tcp_ca_event event) __weak __ksym;
extern void cubictcp_init(struct sock *sk) __weak __ksym;
extern u32 cubictcp_recalc_ssthresh(struct sock *sk) __weak __ksym;
extern void cubictcp_state(struct sock *sk, u8 new_state) __weak __ksym;
extern void dctcp_cwnd_event(struct sock *sk, enum tcp_ca_event ev) __weak __ksym;
extern u32 dctcp_cwnd_undo(struct sock *sk) __weak __ksym;
extern void dctcp_init(struct sock *sk) __weak __ksym;
extern u32 dctcp_ssthresh(struct sock *sk) __weak __ksym;
extern void dctcp_state(struct sock *sk, u8 new_state) __weak __ksym;
extern void dctcp_update_alpha(struct sock *sk, u32 flags) __weak __ksym;
extern void tcp_cong_avoid_ai(struct tcp_sock *tp, u32 w, u32 acked) __weak __ksym;
extern void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 acked) __weak __ksym;
extern u32 tcp_reno_ssthresh(struct sock *sk) __weak __ksym;
extern u32 tcp_reno_undo_cwnd(struct sock *sk) __weak __ksym;
extern u32 tcp_slow_start(struct tcp_sock *tp, u32 acked) __weak __ksym;
#endif

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute pop
#endif

#endif /* __VMLINUX_H__ */
